#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 8216B5E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B5E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B5E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B5E0);
		  /* 8216B5E0h */ case    0:  		/* cmpwi CR0, R11, 0 */
		/* 8216B5E0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8216B5E0h case    0:*/		return 0x8216B5E4;
		  /* 8216B5E4h */ case    1:  		/* bc 4, CR0_EQ, -484 */
		/* 8216B5E4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B5E4h case    1:*/		return 0x8216B5E8;
		  /* 8216B5E8h */ case    2:  		/* lbz R11, <#[R23 + 40]> */
		/* 8216B5E8h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000028) );
		/* 8216B5E8h case    2:*/		return 0x8216B5EC;
		  /* 8216B5ECh */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8216B5ECh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216B5ECh case    3:*/		return 0x8216B5F0;
		  /* 8216B5F0h */ case    4:  		/* bc 4, CR0_EQ, -496 */
		/* 8216B5F0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B5F0h case    4:*/		return 0x8216B5F4;
		  /* 8216B5F4h */ case    5:  		/* mr R3, R25 */
		/* 8216B5F4h case    5:*/		regs.R3 = regs.R25;
		/* 8216B5F4h case    5:*/		return 0x8216B5F8;
	}
	return 0x8216B5F8;
} // Block from 8216B5E0h-8216B5F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216B5F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B5F8);
		  /* 8216B5F8h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 8216B5F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8216B5F8h case    0:*/		return 0x8216B5FC;
		  /* 8216B5FCh */ case    1:  		/* bc 12, CR6_LT, -500 */
		/* 8216B5FCh case    1:*/		if ( regs.CR[6].lt ) { return 0x8216B408;  }
		/* 8216B5FCh case    1:*/		return 0x8216B600;
	}
	return 0x8216B600;
} // Block from 8216B5F8h-8216B600h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B600);
		  /* 8216B600h */ case    0:  		/* cmpwi CR6, R29, 2 */
		/* 8216B600h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000002);
		/* 8216B600h case    0:*/		return 0x8216B604;
		  /* 8216B604h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 8216B604h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216B620;  }
		/* 8216B604h case    1:*/		return 0x8216B608;
		  /* 8216B608h */ case    2:  		/* cmpwi CR6, R29, 4 */
		/* 8216B608h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 8216B608h case    2:*/		return 0x8216B60C;
		  /* 8216B60Ch */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 8216B60Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8216B620;  }
		/* 8216B60Ch case    3:*/		return 0x8216B610;
	}
	return 0x8216B610;
} // Block from 8216B600h-8216B610h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216B610h
// Function '?ValidateCondCall@@YAJTGPUFLOW_INSTRUCTION@@PAUTODO_LIST@@PBUInstructionUsageLite@@PBT1@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B610);
		  /* 8216B610h */ case    0:  		/* cmpwi CR6, R29, 6 */
		/* 8216B610h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000006);
		/* 8216B610h case    0:*/		return 0x8216B614;
		  /* 8216B614h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8216B614h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216B620;  }
		/* 8216B614h case    1:*/		return 0x8216B618;
		  /* 8216B618h */ case    2:  		/* cmpwi CR6, R29, 14 */
		/* 8216B618h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x0000000E);
		/* 8216B618h case    2:*/		return 0x8216B61C;
		  /* 8216B61Ch */ case    3:  		/* bc 4, CR6_EQ, 124 */
		/* 8216B61Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216B698;  }
		/* 8216B61Ch case    3:*/		return 0x8216B620;
	}
	return 0x8216B620;
} // Block from 8216B610h-8216B620h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216B620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B620);
		  /* 8216B620h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 8216B620h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8216B620h case    0:*/		return 0x8216B624;
		  /* 8216B624h */ case    1:  		/* stw R30, <#[R28 + 8]> */
		/* 8216B624h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000008) );
		/* 8216B624h case    1:*/		return 0x8216B628;
		  /* 8216B628h */ case    2:  		/* bc 4, CR6_EQ, -552 */
		/* 8216B628h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216B400;  }
		/* 8216B628h case    2:*/		return 0x8216B62C;
		  /* 8216B62Ch */ case    3:  		/* cmpwi CR6, R20, 0 */
		/* 8216B62Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 8216B62Ch case    3:*/		return 0x8216B630;
		  /* 8216B630h */ case    4:  		/* bc 4, CR6_EQ, -560 */
		/* 8216B630h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8216B400;  }
		/* 8216B630h case    4:*/		return 0x8216B634;
		  /* 8216B634h */ case    5:  		/* addic. R11, R27, 4 */
		/* 8216B634h case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R27,0x4);
		/* 8216B634h case    5:*/		return 0x8216B638;
		  /* 8216B638h */ case    6:  		/* bc 12, CR0_EQ, -568 */
		/* 8216B638h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B638h case    6:*/		return 0x8216B63C;
		  /* 8216B63Ch */ case    7:  		/* lbz R11, <#[R11]> */
		/* 8216B63Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216B63Ch case    7:*/		return 0x8216B640;
		  /* 8216B640h */ case    8:  		/* cmpwi CR6, R11, 35 */
		/* 8216B640h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000023);
		/* 8216B640h case    8:*/		return 0x8216B644;
		  /* 8216B644h */ case    9:  		/* bc 4, CR6_LT, 12 */
		/* 8216B644h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8216B650;  }
		/* 8216B644h case    9:*/		return 0x8216B648;
		  /* 8216B648h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 8216B648h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216B648h case   10:*/		return 0x8216B64C;
		  /* 8216B64Ch */ case   11:  		/* bc 12, CR6_GT, 8 */
		/* 8216B64Ch case   11:*/		if ( regs.CR[6].gt ) { return 0x8216B654;  }
		/* 8216B64Ch case   11:*/		return 0x8216B650;
	}
	return 0x8216B650;
} // Block from 8216B620h-8216B650h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216B650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B650);
		  /* 8216B650h */ case    0:  		/* mr R11, R25 */
		/* 8216B650h case    0:*/		regs.R11 = regs.R25;
		/* 8216B650h case    0:*/		return 0x8216B654;
	}
	return 0x8216B654;
} // Block from 8216B650h-8216B654h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B654);
		  /* 8216B654h */ case    0:  		/* cmpwi CR6, R11, 34 */
		/* 8216B654h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000022);
		/* 8216B654h case    0:*/		return 0x8216B658;
		  /* 8216B658h */ case    1:  		/* bc 4, CR6_EQ, -600 */
		/* 8216B658h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216B400;  }
		/* 8216B658h case    1:*/		return 0x8216B65C;
		  /* 8216B65Ch */ case    2:  		/* lbz R11, <#[R23 + 40]> */
		/* 8216B65Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000028) );
		/* 8216B65Ch case    2:*/		return 0x8216B660;
		  /* 8216B660h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8216B660h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216B660h case    3:*/		return 0x8216B664;
		  /* 8216B664h */ case    4:  		/* lwz R11, <#[R27]> */
		/* 8216B664h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B664h case    4:*/		return 0x8216B668;
		  /* 8216B668h */ case    5:  		/* bc 4, CR0_EQ, 32 */
		/* 8216B668h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216B688;  }
		/* 8216B668h case    5:*/		return 0x8216B66C;
		  /* 8216B66Ch */ case    6:  		/* rlwinm. R10, R11, 0, 21, 21 */
		/* 8216B66Ch case    6:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R11);
		/* 8216B66Ch case    6:*/		return 0x8216B670;
		  /* 8216B670h */ case    7:  		/* bc 12, CR0_EQ, -624 */
		/* 8216B670h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B670h case    7:*/		return 0x8216B674;
		  /* 8216B674h */ case    8:  		/* rlwinm. R10, R11, 0, 20, 20 */
		/* 8216B674h case    8:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R11);
		/* 8216B674h case    8:*/		return 0x8216B678;
		  /* 8216B678h */ case    9:  		/* bc 12, CR0_EQ, -632 */
		/* 8216B678h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B678h case    9:*/		return 0x8216B67C;
		  /* 8216B67Ch */ case   10:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 8216B67Ch case   10:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 8216B67Ch case   10:*/		return 0x8216B680;
		  /* 8216B680h */ case   11:  		/* bc 12, CR0_EQ, -640 */
		/* 8216B680h case   11:*/		if ( regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B680h case   11:*/		return 0x8216B684;
		  /* 8216B684h */ case   12:  		/* b 20 */
		/* 8216B684h case   12:*/		return 0x8216B698;
		/* 8216B684h case   12:*/		return 0x8216B688;
	}
	return 0x8216B688;
} // Block from 8216B654h-8216B688h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216B688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B688);
		  /* 8216B688h */ case    0:  		/* rlwinm. R10, R11, 0, 21, 21 */
		/* 8216B688h case    0:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R11);
		/* 8216B688h case    0:*/		return 0x8216B68C;
		  /* 8216B68Ch */ case    1:  		/* bc 12, CR0_EQ, -652 */
		/* 8216B68Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B68Ch case    1:*/		return 0x8216B690;
		  /* 8216B690h */ case    2:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8216B690h case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8216B690h case    2:*/		return 0x8216B694;
		  /* 8216B694h */ case    3:  		/* bc 4, CR0_EQ, -660 */
		/* 8216B694h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B694h case    3:*/		return 0x8216B698;
	}
	return 0x8216B698;
} // Block from 8216B688h-8216B698h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216B698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B698);
		  /* 8216B698h */ case    0:  		/* lis R12, -32252 */
		/* 8216B698h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 8216B698h case    0:*/		return 0x8216B69C;
		  /* 8216B69Ch */ case    1:  		/* rlwinm R0, R29, 1, 0, 30 */
		/* 8216B69Ch case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R29);
		/* 8216B69Ch case    1:*/		return 0x8216B6A0;
		  /* 8216B6A0h */ case    2:  		/* addi R12, R12, -17320 */
		/* 8216B6A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBC58);
		/* 8216B6A0h case    2:*/		return 0x8216B6A4;
		  /* 8216B6A4h */ case    3:  		/* lhzx R0, <#[R12 + R0]> */
		/* 8216B6A4h case    3:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 8216B6A4h case    3:*/		return 0x8216B6A8;
		  /* 8216B6A8h */ case    4:  		/* lis R12, -32233 */
		/* 8216B6A8h case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8217);
		/* 8216B6A8h case    4:*/		return 0x8216B6AC;
		  /* 8216B6ACh */ case    5:  		/* addi R12, R12, -20044 */
		/* 8216B6ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFB1B4);
		/* 8216B6ACh case    5:*/		return 0x8216B6B0;
		  /* 8216B6B0h */ case    6:  		/* ori R0, R0, 0 */
		/* 8216B6B0h case    6:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8216B6B0h case    6:*/		return 0x8216B6B4;
		  /* 8216B6B4h */ case    7:  		/* add R12, R12, R0 */
		/* 8216B6B4h case    7:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 8216B6B4h case    7:*/		return 0x8216B6B8;
		  /* 8216B6B8h */ case    8:  		/* mtspr CTR, R12 */
		/* 8216B6B8h case    8:*/		regs.CTR = regs.R12;
		/* 8216B6B8h case    8:*/		return 0x8216B6BC;
		  /* 8216B6BCh */ case    9:  		/* bcctr 20, CR0_LT */
		/* 8216B6BCh case    9:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8216B6BCh case    9:*/		return 0x8216B6C0;
		  /* 8216B6C0h */ case   10:  		/* addic. R24, R24, 1 */
		/* 8216B6C0h case   10:*/		cpu::op::addic<1>(regs,&regs.R24,regs.R24,0x1);
		/* 8216B6C0h case   10:*/		return 0x8216B6C4;
		  /* 8216B6C4h */ case   11:  		/* addi R31, R31, 4 */
		/* 8216B6C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8216B6C4h case   11:*/		return 0x8216B6C8;
		  /* 8216B6C8h */ case   12:  		/* bc 4, CR0_LT, -1724 */
		/* 8216B6C8h case   12:*/		if ( !regs.CR[0].lt ) { return 0x8216B00C;  }
		/* 8216B6C8h case   12:*/		return 0x8216B6CC;
		  /* 8216B6CCh */ case   13:  		/* b -716 */
		/* 8216B6CCh case   13:*/		return 0x8216B400;
		/* 8216B6CCh case   13:*/		return 0x8216B6D0;
		  /* 8216B6D0h */ case   14:  		/* cmplwi CR6, R4, 0 */
		/* 8216B6D0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8216B6D0h case   14:*/		return 0x8216B6D4;
		  /* 8216B6D4h */ case   15:  		/* bc 12, CR6_EQ, 72 */
		/* 8216B6D4h case   15:*/		if ( regs.CR[6].eq ) { return 0x8216B71C;  }
		/* 8216B6D4h case   15:*/		return 0x8216B6D8;
		  /* 8216B6D8h */ case   16:  		/* cmplw CR6, R4, R5 */
		/* 8216B6D8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 8216B6D8h case   16:*/		return 0x8216B6DC;
		  /* 8216B6DCh */ case   17:  		/* bc 4, CR6_GT, 16 */
		/* 8216B6DCh case   17:*/		if ( !regs.CR[6].gt ) { return 0x8216B6EC;  }
		/* 8216B6DCh case   17:*/		return 0x8216B6E0;
		  /* 8216B6E0h */ case   18:  		/* lis R3, -32768 */
		/* 8216B6E0h case   18:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216B6E0h case   18:*/		return 0x8216B6E4;
		  /* 8216B6E4h */ case   19:  		/* ori R3, R3, 16389 */
		/* 8216B6E4h case   19:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216B6E4h case   19:*/		return 0x8216B6E8;
		  /* 8216B6E8h */ case   20:  		/* bclr 20, CR0_LT */
		/* 8216B6E8h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216B6E8h case   20:*/		return 0x8216B6EC;
	}
	return 0x8216B6EC;
} // Block from 8216B698h-8216B6ECh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216B6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B6EC);
		  /* 8216B6ECh */ case    0:  		/* subf. R10, R4, R5 */
		/* 8216B6ECh case    0:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R4,regs.R5);
		/* 8216B6ECh case    0:*/		return 0x8216B6F0;
		  /* 8216B6F0h */ case    1:  		/* li R11, 0 */
		/* 8216B6F0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216B6F0h case    1:*/		return 0x8216B6F4;
		  /* 8216B6F4h */ case    2:  		/* bc 12, CR0_EQ, -20 */
		/* 8216B6F4h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216B6E0;  }
		/* 8216B6F4h case    2:*/		return 0x8216B6F8;
		  /* 8216B6F8h */ case    3:  		/* cmplw CR6, R11, R6 */
		/* 8216B6F8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 8216B6F8h case    3:*/		return 0x8216B6FC;
		  /* 8216B6FCh */ case    4:  		/* bc 4, CR6_LT, -28 */
		/* 8216B6FCh case    4:*/		if ( !regs.CR[6].lt ) { return 0x8216B6E0;  }
		/* 8216B6FCh case    4:*/		return 0x8216B700;
		  /* 8216B700h */ case    5:  		/* lbzx R9, <#[R11 + R3]> */
		/* 8216B700h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216B700h case    5:*/		return 0x8216B704;
		  /* 8216B704h */ case    6:  		/* cmplwi CR0, R9, 0 */
		/* 8216B704h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 8216B704h case    6:*/		return 0x8216B708;
	}
	return 0x8216B708;
} // Block from 8216B6ECh-8216B708h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216B708h
// Function '?ValidateReturn@@YAJTGPUFLOW_INSTRUCTION@@PBUTODO_LIST@@PAUInstructionUsageLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B708);
		  /* 8216B708h */ case    0:  		/* bc 12, CR0_EQ, 20 */
		/* 8216B708h case    0:*/		if ( regs.CR[0].eq ) { return 0x8216B71C;  }
		/* 8216B708h case    0:*/		return 0x8216B70C;
		  /* 8216B70Ch */ case    1:  		/* addi R11, R11, 1 */
		/* 8216B70Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216B70Ch case    1:*/		return 0x8216B710;
		  /* 8216B710h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8216B710h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216B710h case    2:*/		return 0x8216B714;
		  /* 8216B714h */ case    3:  		/* bc 12, CR6_LT, -28 */
		/* 8216B714h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216B6F8;  }
		/* 8216B714h case    3:*/		return 0x8216B718;
		  /* 8216B718h */ case    4:  		/* b -56 */
		/* 8216B718h case    4:*/		return 0x8216B6E0;
		/* 8216B718h case    4:*/		return 0x8216B71C;
	}
	return 0x8216B71C;
} // Block from 8216B708h-8216B71Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216B71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B71C);
		  /* 8216B71Ch */ case    0:  		/* li R3, 0 */
		/* 8216B71Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216B71Ch case    0:*/		return 0x8216B720;
		  /* 8216B720h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216B720h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216B720h case    1:*/		return 0x8216B724;
	}
	return 0x8216B724;
} // Block from 8216B71Ch-8216B724h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B724);
		  /* 8216B724h */ case    0:  		/* nop */
		/* 8216B724h case    0:*/		cpu::op::nop();
		/* 8216B724h case    0:*/		return 0x8216B728;
	}
	return 0x8216B728;
} // Block from 8216B724h-8216B728h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B728);
		  /* 8216B728h */ case    0:  		/* mfspr R12, LR */
		/* 8216B728h case    0:*/		regs.R12 = regs.LR;
		/* 8216B728h case    0:*/		return 0x8216B72C;
		  /* 8216B72Ch */ case    1:  		/* bl -894172 */
		/* 8216B72Ch case    1:*/		regs.LR = 0x8216B730; return 0x82091250;
		/* 8216B72Ch case    1:*/		return 0x8216B730;
		  /* 8216B730h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216B730h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216B730h case    2:*/		return 0x8216B734;
		  /* 8216B734h */ case    3:  		/* mr R27, R4 */
		/* 8216B734h case    3:*/		regs.R27 = regs.R4;
		/* 8216B734h case    3:*/		return 0x8216B738;
		  /* 8216B738h */ case    4:  		/* mr R28, R5 */
		/* 8216B738h case    4:*/		regs.R28 = regs.R5;
		/* 8216B738h case    4:*/		return 0x8216B73C;
		  /* 8216B73Ch */ case    5:  		/* mr R11, R6 */
		/* 8216B73Ch case    5:*/		regs.R11 = regs.R6;
		/* 8216B73Ch case    5:*/		return 0x8216B740;
		  /* 8216B740h */ case    6:  		/* cmplwi CR6, R6, 0 */
		/* 8216B740h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8216B740h case    6:*/		return 0x8216B744;
		  /* 8216B744h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 8216B744h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216B760;  }
		/* 8216B744h case    7:*/		return 0x8216B748;
		  /* 8216B748h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 8216B748h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216B748h case    8:*/		return 0x8216B74C;
		  /* 8216B74Ch */ case    9:  		/* cmplw CR6, R10, R3 */
		/* 8216B74Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R3);
		/* 8216B74Ch case    9:*/		return 0x8216B750;
		  /* 8216B750h */ case   10:  		/* bc 12, CR6_EQ, 232 */
		/* 8216B750h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216B838;  }
		/* 8216B750h case   10:*/		return 0x8216B754;
		  /* 8216B754h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216B754h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216B754h case   11:*/		return 0x8216B758;
		  /* 8216B758h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8216B758h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216B758h case   12:*/		return 0x8216B75C;
		  /* 8216B75Ch */ case   13:  		/* bc 4, CR6_EQ, -20 */
		/* 8216B75Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x8216B748;  }
		/* 8216B75Ch case   13:*/		return 0x8216B760;
	}
	return 0x8216B760;
} // Block from 8216B728h-8216B760h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216B760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B760);
		  /* 8216B760h */ case    0:  		/* lhz R11, <#[R3]> */
		/* 8216B760h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8216B760h case    0:*/		return 0x8216B764;
		  /* 8216B764h */ case    1:  		/* cmpwi CR0, R11, 0 */
		/* 8216B764h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8216B764h case    1:*/		return 0x8216B768;
		  /* 8216B768h */ case    2:  		/* bc 12, CR0_LT, 208 */
		/* 8216B768h case    2:*/		if ( regs.CR[0].lt ) { return 0x8216B838;  }
		/* 8216B768h case    2:*/		return 0x8216B76C;
		  /* 8216B76Ch */ case    3:  		/* cmpwi CR6, R11, 5 */
		/* 8216B76Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 8216B76Ch case    3:*/		return 0x8216B770;
		  /* 8216B770h */ case    4:  		/* bc 12, CR6_GT, 200 */
		/* 8216B770h case    4:*/		if ( regs.CR[6].gt ) { return 0x8216B838;  }
		/* 8216B770h case    4:*/		return 0x8216B774;
		  /* 8216B774h */ case    5:  		/* lhz R11, <#[R3 + 2]> */
		/* 8216B774h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000002) );
		/* 8216B774h case    5:*/		return 0x8216B778;
		  /* 8216B778h */ case    6:  		/* cmpwi CR0, R11, 0 */
		/* 8216B778h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8216B778h case    6:*/		return 0x8216B77C;
		  /* 8216B77Ch */ case    7:  		/* bc 12, CR0_LT, 188 */
		/* 8216B77Ch case    7:*/		if ( regs.CR[0].lt ) { return 0x8216B838;  }
		/* 8216B77Ch case    7:*/		return 0x8216B780;
		  /* 8216B780h */ case    8:  		/* cmpwi CR6, R11, 18 */
		/* 8216B780h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 8216B780h case    8:*/		return 0x8216B784;
		  /* 8216B784h */ case    9:  		/* bc 12, CR6_GT, 180 */
		/* 8216B784h case    9:*/		if ( regs.CR[6].gt ) { return 0x8216B838;  }
		/* 8216B784h case    9:*/		return 0x8216B788;
		  /* 8216B788h */ case   10:  		/* lwz R11, <#[R3 + 12]> */
		/* 8216B788h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8216B788h case   10:*/		return 0x8216B78C;
		  /* 8216B78Ch */ case   11:  		/* lhz R10, <#[R3 + 10]> */
		/* 8216B78Ch case   11:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000A) );
		/* 8216B78Ch case   11:*/		return 0x8216B790;
		  /* 8216B790h */ case   12:  		/* cmplw CR6, R11, R28 */
		/* 8216B790h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8216B790h case   12:*/		return 0x8216B794;
		  /* 8216B794h */ case   13:  		/* bc 12, CR6_GT, 164 */
		/* 8216B794h case   13:*/		if ( regs.CR[6].gt ) { return 0x8216B838;  }
		/* 8216B794h case   13:*/		return 0x8216B798;
		  /* 8216B798h */ case   14:  		/* rlwinm R8, R10, 3, 13, 28 */
		/* 8216B798h case   14:*/		cpu::op::rlwinm<0,3,13,28>(regs,&regs.R8,regs.R10);
		/* 8216B798h case   14:*/		return 0x8216B79C;
		  /* 8216B79Ch */ case   15:  		/* rldicl R9, R11, 0, 32 */
		/* 8216B79Ch case   15:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8216B79Ch case   15:*/		return 0x8216B7A0;
		  /* 8216B7A0h */ case   16:  		/* rldicl R26, R28, 0, 32 */
		/* 8216B7A0h case   16:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R26,regs.R28);
		/* 8216B7A0h case   16:*/		return 0x8216B7A4;
		  /* 8216B7A4h */ case   17:  		/* add R9, R8, R9 */
		/* 8216B7A4h case   17:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8216B7A4h case   17:*/		return 0x8216B7A8;
		  /* 8216B7A8h */ case   18:  		/* cmpld CR6, R9, R26 */
		/* 8216B7A8h case   18:*/		cpu::op::cmpld<6>(regs,regs.R9,regs.R26);
		/* 8216B7A8h case   18:*/		return 0x8216B7AC;
		  /* 8216B7ACh */ case   19:  		/* bc 12, CR6_GT, 140 */
		/* 8216B7ACh case   19:*/		if ( regs.CR[6].gt ) { return 0x8216B838;  }
		/* 8216B7ACh case   19:*/		return 0x8216B7B0;
		  /* 8216B7B0h */ case   20:  		/* rlwinm. R30, R10, 0, 16, 31 */
		/* 8216B7B0h case   20:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R30,regs.R10);
		/* 8216B7B0h case   20:*/		return 0x8216B7B4;
		  /* 8216B7B4h */ case   21:  		/* stw R3, <#[R1 + 80]> */
		/* 8216B7B4h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 8216B7B4h case   21:*/		return 0x8216B7B8;
		  /* 8216B7B8h */ case   22:  		/* add R31, R11, R27 */
		/* 8216B7B8h case   22:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R27);
		/* 8216B7B8h case   22:*/		return 0x8216B7BC;
		  /* 8216B7BCh */ case   23:  		/* stw R6, <#[R1 + 84]> */
		/* 8216B7BCh case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8216B7BCh case   23:*/		return 0x8216B7C0;
	}
	return 0x8216B7C0;
} // Block from 8216B760h-8216B7C0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8216B7C0h
// Function '?ValidateCondJump@@YAJTGPUFLOW_INSTRUCTION@@PAUTODO_LIST@@PBUInstructionUsageLite@@PBT1@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B7C0);
		  /* 8216B7C0h */ case    0:  		/* li R29, 0 */
		/* 8216B7C0h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8216B7C0h case    0:*/		return 0x8216B7C4;
		  /* 8216B7C4h */ case    1:  		/* bc 4, CR0_GT, 108 */
		/* 8216B7C4h case    1:*/		if ( !regs.CR[0].gt ) { return 0x8216B830;  }
		/* 8216B7C4h case    1:*/		return 0x8216B7C8;
		  /* 8216B7C8h */ case    2:  		/* li R6, 240 */
		/* 8216B7C8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0xF0);
		/* 8216B7C8h case    2:*/		return 0x8216B7CC;
		  /* 8216B7CCh */ case    3:  		/* lwz R4, <#[R31]> */
		/* 8216B7CCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B7CCh case    3:*/		return 0x8216B7D0;
		  /* 8216B7D0h */ case    4:  		/* mr R5, R28 */
		/* 8216B7D0h case    4:*/		regs.R5 = regs.R28;
		/* 8216B7D0h case    4:*/		return 0x8216B7D4;
		  /* 8216B7D4h */ case    5:  		/* mr R3, R27 */
		/* 8216B7D4h case    5:*/		regs.R3 = regs.R27;
		/* 8216B7D4h case    5:*/		return 0x8216B7D8;
		  /* 8216B7D8h */ case    6:  		/* bl -264 */
		/* 8216B7D8h case    6:*/		regs.LR = 0x8216B7DC; return 0x8216B6D0;
		/* 8216B7D8h case    6:*/		return 0x8216B7DC;
		  /* 8216B7DCh */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8216B7DCh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216B7DCh case    7:*/		return 0x8216B7E0;
		  /* 8216B7E0h */ case    8:  		/* bc 12, CR0_LT, 56 */
		/* 8216B7E0h case    8:*/		if ( regs.CR[0].lt ) { return 0x8216B818;  }
		/* 8216B7E0h case    8:*/		return 0x8216B7E4;
		  /* 8216B7E4h */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 8216B7E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8216B7E4h case    9:*/		return 0x8216B7E8;
		  /* 8216B7E8h */ case   10:  		/* cmplw CR6, R11, R28 */
		/* 8216B7E8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8216B7E8h case   10:*/		return 0x8216B7EC;
		  /* 8216B7ECh */ case   11:  		/* bc 12, CR6_GT, 76 */
		/* 8216B7ECh case   11:*/		if ( regs.CR[6].gt ) { return 0x8216B838;  }
		/* 8216B7ECh case   11:*/		return 0x8216B7F0;
		  /* 8216B7F0h */ case   12:  		/* rldicl R10, R11, 0, 32 */
		/* 8216B7F0h case   12:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R11);
		/* 8216B7F0h case   12:*/		return 0x8216B7F4;
		  /* 8216B7F4h */ case   13:  		/* addi R10, R10, 16 */
		/* 8216B7F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x10);
		/* 8216B7F4h case   13:*/		return 0x8216B7F8;
		  /* 8216B7F8h */ case   14:  		/* cmpld CR6, R10, R26 */
		/* 8216B7F8h case   14:*/		cpu::op::cmpld<6>(regs,regs.R10,regs.R26);
		/* 8216B7F8h case   14:*/		return 0x8216B7FC;
		  /* 8216B7FCh */ case   15:  		/* bc 12, CR6_GT, 60 */
		/* 8216B7FCh case   15:*/		if ( regs.CR[6].gt ) { return 0x8216B838;  }
		/* 8216B7FCh case   15:*/		return 0x8216B800;
		  /* 8216B800h */ case   16:  		/* addi R6, R1, 80 */
		/* 8216B800h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8216B800h case   16:*/		return 0x8216B804;
		  /* 8216B804h */ case   17:  		/* mr R4, R27 */
		/* 8216B804h case   17:*/		regs.R4 = regs.R27;
		/* 8216B804h case   17:*/		return 0x8216B808;
		  /* 8216B808h */ case   18:  		/* add R3, R11, R27 */
		/* 8216B808h case   18:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 8216B808h case   18:*/		return 0x8216B80C;
		  /* 8216B80Ch */ case   19:  		/* bl -228 */
		/* 8216B80Ch case   19:*/		regs.LR = 0x8216B810; return 0x8216B728;
		/* 8216B80Ch case   19:*/		return 0x8216B810;
		  /* 8216B810h */ case   20:  		/* srawi R11, R3, 31 */
		/* 8216B810h case   20:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 8216B810h case   20:*/		return 0x8216B814;
		  /* 8216B814h */ case   21:  		/* and R3, R11, R3 */
		/* 8216B814h case   21:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 8216B814h case   21:*/		return 0x8216B818;
	}
	return 0x8216B818;
} // Block from 8216B7C0h-8216B818h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8216B818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B818);
		  /* 8216B818h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 8216B818h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8216B818h case    0:*/		return 0x8216B81C;
		  /* 8216B81Ch */ case    1:  		/* bc 12, CR6_LT, 36 */
		/* 8216B81Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8216B840;  }
		/* 8216B81Ch case    1:*/		return 0x8216B820;
		  /* 8216B820h */ case    2:  		/* addi R29, R29, 1 */
		/* 8216B820h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8216B820h case    2:*/		return 0x8216B824;
		  /* 8216B824h */ case    3:  		/* addi R31, R31, 8 */
		/* 8216B824h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 8216B824h case    3:*/		return 0x8216B828;
		  /* 8216B828h */ case    4:  		/* cmpw CR6, R29, R30 */
		/* 8216B828h case    4:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R30);
		/* 8216B828h case    4:*/		return 0x8216B82C;
		  /* 8216B82Ch */ case    5:  		/* bc 12, CR6_LT, -100 */
		/* 8216B82Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8216B7C8;  }
		/* 8216B82Ch case    5:*/		return 0x8216B830;
	}
	return 0x8216B830;
} // Block from 8216B818h-8216B830h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216B830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B830);
		  /* 8216B830h */ case    0:  		/* li R3, 0 */
		/* 8216B830h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216B830h case    0:*/		return 0x8216B834;
		  /* 8216B834h */ case    1:  		/* b 12 */
		/* 8216B834h case    1:*/		return 0x8216B840;
		/* 8216B834h case    1:*/		return 0x8216B838;
	}
	return 0x8216B838;
} // Block from 8216B830h-8216B838h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B838);
		  /* 8216B838h */ case    0:  		/* lis R3, -32768 */
		/* 8216B838h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216B838h case    0:*/		return 0x8216B83C;
		  /* 8216B83Ch */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216B83Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216B83Ch case    1:*/		return 0x8216B840;
	}
	return 0x8216B840;
} // Block from 8216B838h-8216B840h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B840);
		  /* 8216B840h */ case    0:  		/* addi R1, R1, 144 */
		/* 8216B840h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216B840h case    0:*/		return 0x8216B844;
		  /* 8216B844h */ case    1:  		/* b -894372 */
		/* 8216B844h case    1:*/		return 0x820912A0;
		/* 8216B844h case    1:*/		return 0x8216B848;
	}
	return 0x8216B848;
} // Block from 8216B840h-8216B848h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B848);
		  /* 8216B848h */ case    0:  		/* mfspr R12, LR */
		/* 8216B848h case    0:*/		regs.R12 = regs.LR;
		/* 8216B848h case    0:*/		return 0x8216B84C;
		  /* 8216B84Ch */ case    1:  		/* bl -894448 */
		/* 8216B84Ch case    1:*/		regs.LR = 0x8216B850; return 0x8209125C;
		/* 8216B84Ch case    1:*/		return 0x8216B850;
		  /* 8216B850h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216B850h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216B850h case    2:*/		return 0x8216B854;
		  /* 8216B854h */ case    3:  		/* mr R8, R4 */
		/* 8216B854h case    3:*/		regs.R8 = regs.R4;
		/* 8216B854h case    3:*/		return 0x8216B858;
		  /* 8216B858h */ case    4:  		/* lwz R4, <#[R3]> */
		/* 8216B858h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8216B858h case    4:*/		return 0x8216B85C;
		  /* 8216B85Ch */ case    5:  		/* mr R7, R3 */
		/* 8216B85Ch case    5:*/		regs.R7 = regs.R3;
		/* 8216B85Ch case    5:*/		return 0x8216B860;
		  /* 8216B860h */ case    6:  		/* li R6, 240 */
		/* 8216B860h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0xF0);
		/* 8216B860h case    6:*/		return 0x8216B864;
		  /* 8216B864h */ case    7:  		/* mr R3, R8 */
		/* 8216B864h case    7:*/		regs.R3 = regs.R8;
		/* 8216B864h case    7:*/		return 0x8216B868;
		  /* 8216B868h */ case    8:  		/* mr R31, R5 */
		/* 8216B868h case    8:*/		regs.R31 = regs.R5;
		/* 8216B868h case    8:*/		return 0x8216B86C;
		  /* 8216B86Ch */ case    9:  		/* bl -412 */
		/* 8216B86Ch case    9:*/		regs.LR = 0x8216B870; return 0x8216B6D0;
		/* 8216B86Ch case    9:*/		return 0x8216B870;
		  /* 8216B870h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 8216B870h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216B870h case   10:*/		return 0x8216B874;
		  /* 8216B874h */ case   11:  		/* bc 12, CR0_LT, 200 */
		/* 8216B874h case   11:*/		if ( regs.CR[0].lt ) { return 0x8216B93C;  }
		/* 8216B874h case   11:*/		return 0x8216B878;
		  /* 8216B878h */ case   12:  		/* lwz R11, <#[R7 + 12]> */
		/* 8216B878h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 8216B878h case   12:*/		return 0x8216B87C;
		  /* 8216B87Ch */ case   13:  		/* cmplw CR6, R11, R5 */
		/* 8216B87Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8216B87Ch case   13:*/		return 0x8216B880;
		  /* 8216B880h */ case   14:  		/* bc 12, CR6_GT, 24 */
		/* 8216B880h case   14:*/		if ( regs.CR[6].gt ) { return 0x8216B898;  }
		/* 8216B880h case   14:*/		return 0x8216B884;
		  /* 8216B884h */ case   15:  		/* rldicl R10, R11, 0, 32 */
		/* 8216B884h case   15:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R11);
		/* 8216B884h case   15:*/		return 0x8216B888;
		  /* 8216B888h */ case   16:  		/* rldicl R29, R5, 0, 32 */
		/* 8216B888h case   16:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R29,regs.R5);
		/* 8216B888h case   16:*/		return 0x8216B88C;
		  /* 8216B88Ch */ case   17:  		/* addi R10, R10, 16 */
		/* 8216B88Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x10);
		/* 8216B88Ch case   17:*/		return 0x8216B890;
		  /* 8216B890h */ case   18:  		/* cmpld CR6, R10, R29 */
		/* 8216B890h case   18:*/		cpu::op::cmpld<6>(regs,regs.R10,regs.R29);
		/* 8216B890h case   18:*/		return 0x8216B894;
		  /* 8216B894h */ case   19:  		/* bc 4, CR6_GT, 16 */
		/* 8216B894h case   19:*/		if ( !regs.CR[6].gt ) { return 0x8216B8A4;  }
		/* 8216B894h case   19:*/		return 0x8216B898;
	}
	return 0x8216B898;
} // Block from 8216B848h-8216B898h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216B898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B898);
		  /* 8216B898h */ case    0:  		/* lis R3, -32768 */
		/* 8216B898h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216B898h case    0:*/		return 0x8216B89C;
		  /* 8216B89Ch */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216B89Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216B89Ch case    1:*/		return 0x8216B8A0;
		  /* 8216B8A0h */ case    2:  		/* b 156 */
		/* 8216B8A0h case    2:*/		return 0x8216B93C;
		/* 8216B8A0h case    2:*/		return 0x8216B8A4;
	}
	return 0x8216B8A4;
} // Block from 8216B898h-8216B8A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216B8A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B8A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B8A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B8A4);
		  /* 8216B8A4h */ case    0:  		/* add R3, R11, R8 */
		/* 8216B8A4h case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R8);
		/* 8216B8A4h case    0:*/		return 0x8216B8A8;
		  /* 8216B8A8h */ case    1:  		/* lwz R30, <#[R7 + 16]> */
		/* 8216B8A8h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + 0x00000010) );
		/* 8216B8A8h case    1:*/		return 0x8216B8AC;
		  /* 8216B8ACh */ case    2:  		/* li R6, 0 */
		/* 8216B8ACh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216B8ACh case    2:*/		return 0x8216B8B0;
		  /* 8216B8B0h */ case    3:  		/* mr R5, R31 */
		/* 8216B8B0h case    3:*/		regs.R5 = regs.R31;
		/* 8216B8B0h case    3:*/		return 0x8216B8B4;
		  /* 8216B8B4h */ case    4:  		/* mr R4, R8 */
		/* 8216B8B4h case    4:*/		regs.R4 = regs.R8;
		/* 8216B8B4h case    4:*/		return 0x8216B8B8;
		  /* 8216B8B8h */ case    5:  		/* bl -400 */
		/* 8216B8B8h case    5:*/		regs.LR = 0x8216B8BC; return 0x8216B728;
		/* 8216B8B8h case    5:*/		return 0x8216B8BC;
		  /* 8216B8BCh */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8216B8BCh case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216B8BCh case    6:*/		return 0x8216B8C0;
		  /* 8216B8C0h */ case    7:  		/* bc 12, CR0_LT, 124 */
		/* 8216B8C0h case    7:*/		if ( regs.CR[0].lt ) { return 0x8216B93C;  }
		/* 8216B8C0h case    7:*/		return 0x8216B8C4;
		  /* 8216B8C4h */ case    8:  		/* lhz R11, <#[R7 + 4]> */
		/* 8216B8C4h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 8216B8C4h case    8:*/		return 0x8216B8C8;
		  /* 8216B8C8h */ case    9:  		/* lhz R9, <#[R7 + 6]> */
		/* 8216B8C8h case    9:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000006) );
		/* 8216B8C8h case    9:*/		return 0x8216B8CC;
		  /* 8216B8CCh */ case   10:  		/* lhz R7, <#[R7 + 8]> */
		/* 8216B8CCh case   10:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000008) );
		/* 8216B8CCh case   10:*/		return 0x8216B8D0;
		  /* 8216B8D0h */ case   11:  		/* cmplwi CR6, R11, 1 */
		/* 8216B8D0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216B8D0h case   11:*/		return 0x8216B8D4;
		  /* 8216B8D4h */ case   12:  		/* bc 12, CR6_LT, 132 */
		/* 8216B8D4h case   12:*/		if ( regs.CR[6].lt ) { return 0x8216B958;  }
		/* 8216B8D4h case   12:*/		return 0x8216B8D8;
		  /* 8216B8D8h */ case   13:  		/* bc 12, CR6_EQ, 116 */
		/* 8216B8D8h case   13:*/		if ( regs.CR[6].eq ) { return 0x8216B94C;  }
		/* 8216B8D8h case   13:*/		return 0x8216B8DC;
		  /* 8216B8DCh */ case   14:  		/* cmplwi CR6, R11, 3 */
		/* 8216B8DCh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8216B8DCh case   14:*/		return 0x8216B8E0;
		  /* 8216B8E0h */ case   15:  		/* bc 12, CR6_LT, 100 */
		/* 8216B8E0h case   15:*/		if ( regs.CR[6].lt ) { return 0x8216B944;  }
		/* 8216B8E0h case   15:*/		return 0x8216B8E4;
		  /* 8216B8E4h */ case   16:  		/* bc 4, CR6_EQ, -76 */
		/* 8216B8E4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8216B898;  }
		/* 8216B8E4h case   16:*/		return 0x8216B8E8;
	}
	return 0x8216B8E8;
} // Block from 8216B8A4h-8216B8E8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216B8E8h
// Function '?ValidateAlloc@@YAJTGPUFLOW_INSTRUCTION@@PAUTODO_LIST@@PBUInstructionUsageLite@@PBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B8E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B8E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B8E8);
		  /* 8216B8E8h */ case    0:  		/* li R11, 32 */
		/* 8216B8E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 8216B8E8h case    0:*/		return 0x8216B8EC;
		  /* 8216B8ECh */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 8216B8ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216B8ECh case    1:*/		return 0x8216B8F0;
		  /* 8216B8F0h */ case    2:  		/* bc 4, CR6_EQ, -88 */
		/* 8216B8F0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216B898;  }
		/* 8216B8F0h case    2:*/		return 0x8216B8F4;
		  /* 8216B8F4h */ case    3:  		/* lwz R8, <#[R1 + 80]> */
		/* 8216B8F4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8216B8F4h case    3:*/		return 0x8216B8F8;
		  /* 8216B8F8h */ case    4:  		/* rlwinm R10, R7, 0, 16, 31 */
		/* 8216B8F8h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R7);
		/* 8216B8F8h case    4:*/		return 0x8216B8FC;
		  /* 8216B8FCh */ case    5:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 8216B8FCh case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 8216B8FCh case    5:*/		return 0x8216B900;
		  /* 8216B900h */ case    6:  		/* add R10, R10, R9 */
		/* 8216B900h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216B900h case    6:*/		return 0x8216B904;
		  /* 8216B904h */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 8216B904h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216B904h case    7:*/		return 0x8216B908;
		  /* 8216B908h */ case    8:  		/* bc 12, CR6_GT, -112 */
		/* 8216B908h case    8:*/		if ( regs.CR[6].gt ) { return 0x8216B898;  }
		/* 8216B908h case    8:*/		return 0x8216B90C;
		  /* 8216B90Ch */ case    9:  		/* cmplwi CR6, R30, 0 */
		/* 8216B90Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216B90Ch case    9:*/		return 0x8216B910;
		  /* 8216B910h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 8216B910h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216B938;  }
		/* 8216B910h case   10:*/		return 0x8216B914;
		  /* 8216B914h */ case   11:  		/* cmplw CR6, R30, R31 */
		/* 8216B914h case   11:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 8216B914h case   11:*/		return 0x8216B918;
		  /* 8216B918h */ case   12:  		/* bc 12, CR6_GT, -128 */
		/* 8216B918h case   12:*/		if ( regs.CR[6].gt ) { return 0x8216B898;  }
		/* 8216B918h case   12:*/		return 0x8216B91C;
		  /* 8216B91Ch */ case   13:  		/* rldicl R11, R7, 0, 48 */
		/* 8216B91Ch case   13:*/		cpu::op::rldicl<0,0,48>(regs,&regs.R11,regs.R7);
		/* 8216B91Ch case   13:*/		return 0x8216B920;
		  /* 8216B920h */ case   14:  		/* rldicl R9, R8, 0, 32 */
		/* 8216B920h case   14:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R8);
		/* 8216B920h case   14:*/		return 0x8216B924;
		  /* 8216B924h */ case   15:  		/* rldicl R10, R30, 0, 32 */
		/* 8216B924h case   15:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R30);
		/* 8216B924h case   15:*/		return 0x8216B928;
		  /* 8216B928h */ case   16:  		/* mulld R11, R11, R9 */
		/* 8216B928h case   16:*/		cpu::op::mulld<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216B928h case   16:*/		return 0x8216B92C;
		  /* 8216B92Ch */ case   17:  		/* add R11, R11, R10 */
		/* 8216B92Ch case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216B92Ch case   17:*/		return 0x8216B930;
		  /* 8216B930h */ case   18:  		/* cmpld CR6, R11, R29 */
		/* 8216B930h case   18:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R29);
		/* 8216B930h case   18:*/		return 0x8216B934;
		  /* 8216B934h */ case   19:  		/* bc 12, CR6_GT, -156 */
		/* 8216B934h case   19:*/		if ( regs.CR[6].gt ) { return 0x8216B898;  }
		/* 8216B934h case   19:*/		return 0x8216B938;
	}
	return 0x8216B938;
} // Block from 8216B8E8h-8216B938h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216B938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B938);
		  /* 8216B938h */ case    0:  		/* li R3, 0 */
		/* 8216B938h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216B938h case    0:*/		return 0x8216B93C;
	}
	return 0x8216B93C;
} // Block from 8216B938h-8216B93Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B93C);
		  /* 8216B93Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8216B93Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216B93Ch case    0:*/		return 0x8216B940;
		  /* 8216B940h */ case    1:  		/* b -894612 */
		/* 8216B940h case    1:*/		return 0x820912AC;
		/* 8216B940h case    1:*/		return 0x8216B944;
	}
	return 0x8216B944;
} // Block from 8216B93Ch-8216B944h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B944);
		  /* 8216B944h */ case    0:  		/* li R11, 256 */
		/* 8216B944h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x100);
		/* 8216B944h case    0:*/		return 0x8216B948;
		  /* 8216B948h */ case    1:  		/* b 8 */
		/* 8216B948h case    1:*/		return 0x8216B950;
		/* 8216B948h case    1:*/		return 0x8216B94C;
	}
	return 0x8216B94C;
} // Block from 8216B944h-8216B94Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B94C);
		  /* 8216B94Ch */ case    0:  		/* li R11, 64 */
		/* 8216B94Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x40);
		/* 8216B94Ch case    0:*/		return 0x8216B950;
	}
	return 0x8216B950;
} // Block from 8216B94Ch-8216B950h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B950);
		  /* 8216B950h */ case    0:  		/* li R8, 16 */
		/* 8216B950h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x10);
		/* 8216B950h case    0:*/		return 0x8216B954;
		  /* 8216B954h */ case    1:  		/* b -92 */
		/* 8216B954h case    1:*/		return 0x8216B8F8;
		/* 8216B954h case    1:*/		return 0x8216B958;
	}
	return 0x8216B958;
} // Block from 8216B950h-8216B958h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B958);
		  /* 8216B958h */ case    0:  		/* li R11, 256 */
		/* 8216B958h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x100);
		/* 8216B958h case    0:*/		return 0x8216B95C;
		  /* 8216B95Ch */ case    1:  		/* li R8, 4 */
		/* 8216B95Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8216B95Ch case    1:*/		return 0x8216B960;
		  /* 8216B960h */ case    2:  		/* b -104 */
		/* 8216B960h case    2:*/		return 0x8216B8F8;
		/* 8216B960h case    2:*/		return 0x8216B964;
		  /* 8216B964h */ case    3:  		/* nop */
		/* 8216B964h case    3:*/		cpu::op::nop();
		/* 8216B964h case    3:*/		return 0x8216B968;
	}
	return 0x8216B968;
} // Block from 8216B958h-8216B968h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216B968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B968);
		  /* 8216B968h */ case    0:  		/* mfspr R12, LR */
		/* 8216B968h case    0:*/		regs.R12 = regs.LR;
		/* 8216B968h case    0:*/		return 0x8216B96C;
		  /* 8216B96Ch */ case    1:  		/* bl -894744 */
		/* 8216B96Ch case    1:*/		regs.LR = 0x8216B970; return 0x82091254;
		/* 8216B96Ch case    1:*/		return 0x8216B970;
		  /* 8216B970h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216B970h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216B970h case    2:*/		return 0x8216B974;
		  /* 8216B974h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 8216B974h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8216B974h case    3:*/		return 0x8216B978;
		  /* 8216B978h */ case    4:  		/* bc 12, CR6_EQ, 236 */
		/* 8216B978h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216BA64;  }
		/* 8216B978h case    4:*/		return 0x8216B97C;
		  /* 8216B97Ch */ case    5:  		/* lwz R11, <#[R4 + 68]> */
		/* 8216B97Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000044) );
		/* 8216B97Ch case    5:*/		return 0x8216B980;
		  /* 8216B980h */ case    6:  		/* cmplw CR6, R3, R11 */
		/* 8216B980h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8216B980h case    6:*/		return 0x8216B984;
		  /* 8216B984h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 8216B984h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8216B994;  }
		/* 8216B984h case    7:*/		return 0x8216B988;
		  /* 8216B988h */ case    8:  		/* lis R3, -32768 */
		/* 8216B988h case    8:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216B988h case    8:*/		return 0x8216B98C;
		  /* 8216B98Ch */ case    9:  		/* ori R3, R3, 16389 */
		/* 8216B98Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216B98Ch case    9:*/		return 0x8216B990;
		  /* 8216B990h */ case   10:  		/* b 216 */
		/* 8216B990h case   10:*/		return 0x8216BA68;
		/* 8216B990h case   10:*/		return 0x8216B994;
	}
	return 0x8216B994;
} // Block from 8216B968h-8216B994h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216B994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B994);
		  /* 8216B994h */ case    0:  		/* lwz R10, <#[R4 + 72]> */
		/* 8216B994h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000048) );
		/* 8216B994h case    0:*/		return 0x8216B998;
		  /* 8216B998h */ case    1:  		/* rldicl R9, R11, 0, 32 */
		/* 8216B998h case    1:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8216B998h case    1:*/		return 0x8216B99C;
		  /* 8216B99Ch */ case    2:  		/* rldicl R11, R3, 0, 32 */
		/* 8216B99Ch case    2:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R3);
		/* 8216B99Ch case    2:*/		return 0x8216B9A0;
		  /* 8216B9A0h */ case    3:  		/* add R10, R10, R9 */
		/* 8216B9A0h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216B9A0h case    3:*/		return 0x8216B9A4;
		  /* 8216B9A4h */ case    4:  		/* addi R9, R11, 4 */
		/* 8216B9A4h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8216B9A4h case    4:*/		return 0x8216B9A8;
		  /* 8216B9A8h */ case    5:  		/* cmpld CR6, R9, R10 */
		/* 8216B9A8h case    5:*/		cpu::op::cmpld<6>(regs,regs.R9,regs.R10);
		/* 8216B9A8h case    5:*/		return 0x8216B9AC;
		  /* 8216B9ACh */ case    6:  		/* bc 12, CR6_GT, -36 */
		/* 8216B9ACh case    6:*/		if ( regs.CR[6].gt ) { return 0x8216B988;  }
		/* 8216B9ACh case    6:*/		return 0x8216B9B0;
		  /* 8216B9B0h */ case    7:  		/* lwz R29, <#[R3]> */
		/* 8216B9B0h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8216B9B0h case    7:*/		return 0x8216B9B4;
		  /* 8216B9B4h */ case    8:  		/* add R11, R29, R11 */
		/* 8216B9B4h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8216B9B4h case    8:*/		return 0x8216B9B8;
		  /* 8216B9B8h */ case    9:  		/* mr R9, R29 */
		/* 8216B9B8h case    9:*/		regs.R9 = regs.R29;
		/* 8216B9B8h case    9:*/		return 0x8216B9BC;
		  /* 8216B9BCh */ case   10:  		/* addi R11, R11, 4 */
		/* 8216B9BCh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216B9BCh case   10:*/		return 0x8216B9C0;
		  /* 8216B9C0h */ case   11:  		/* cmpld CR6, R11, R10 */
		/* 8216B9C0h case   11:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R10);
		/* 8216B9C0h case   11:*/		return 0x8216B9C4;
		  /* 8216B9C4h */ case   12:  		/* bc 12, CR6_GT, -60 */
		/* 8216B9C4h case   12:*/		if ( regs.CR[6].gt ) { return 0x8216B988;  }
		/* 8216B9C4h case   12:*/		return 0x8216B9C8;
		  /* 8216B9C8h */ case   13:  		/* cmplwi CR6, R29, 28 */
		/* 8216B9C8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000001C);
		/* 8216B9C8h case   13:*/		return 0x8216B9CC;
		  /* 8216B9CCh */ case   14:  		/* bc 12, CR6_LT, -68 */
		/* 8216B9CCh case   14:*/		if ( regs.CR[6].lt ) { return 0x8216B988;  }
		/* 8216B9CCh case   14:*/		return 0x8216B9D0;
		  /* 8216B9D0h */ case   15:  		/* lwz R8, <#[R3 + 20]> */
		/* 8216B9D0h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 8216B9D0h case   15:*/		return 0x8216B9D4;
		  /* 8216B9D4h */ case   16:  		/* addi R31, R3, 4 */
		/* 8216B9D4h case   16:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 8216B9D4h case   16:*/		return 0x8216B9D8;
		  /* 8216B9D8h */ case   17:  		/* lwz R27, <#[R3 + 16]> */
		/* 8216B9D8h case   17:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000010) );
		/* 8216B9D8h case   17:*/		return 0x8216B9DC;
		  /* 8216B9DCh */ case   18:  		/* cmplw CR6, R8, R29 */
		/* 8216B9DCh case   18:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 8216B9DCh case   18:*/		return 0x8216B9E0;
		  /* 8216B9E0h */ case   19:  		/* bc 12, CR6_GT, -88 */
		/* 8216B9E0h case   19:*/		if ( regs.CR[6].gt ) { return 0x8216B988;  }
		/* 8216B9E0h case   19:*/		return 0x8216B9E4;
		  /* 8216B9E4h */ case   20:  		/* rldicl R11, R27, 0, 32 */
		/* 8216B9E4h case   20:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R27);
		/* 8216B9E4h case   20:*/		return 0x8216B9E8;
		  /* 8216B9E8h */ case   21:  		/* rldicl R10, R8, 0, 32 */
		/* 8216B9E8h case   21:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R8);
		/* 8216B9E8h case   21:*/		return 0x8216B9EC;
		  /* 8216B9ECh */ case   22:  		/* mulli R11, R11, 20 */
		/* 8216B9ECh case   22:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x14);
		/* 8216B9ECh case   22:*/		return 0x8216B9F0;
		  /* 8216B9F0h */ case   23:  		/* add R11, R11, R10 */
		/* 8216B9F0h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216B9F0h case   23:*/		return 0x8216B9F4;
		  /* 8216B9F4h */ case   24:  		/* cmpld CR6, R11, R29 */
		/* 8216B9F4h case   24:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R29);
		/* 8216B9F4h case   24:*/		return 0x8216B9F8;
		  /* 8216B9F8h */ case   25:  		/* bc 12, CR6_GT, -112 */
		/* 8216B9F8h case   25:*/		if ( regs.CR[6].gt ) { return 0x8216B988;  }
		/* 8216B9F8h case   25:*/		return 0x8216B9FC;
		  /* 8216B9FCh */ case   26:  		/* li R6, 240 */
		/* 8216B9FCh case   26:*/		cpu::op::li<0>(regs,&regs.R6,0xF0);
		/* 8216B9FCh case   26:*/		return 0x8216BA00;
		  /* 8216BA00h */ case   27:  		/* lwz R4, <#[R31 + 4]> */
		/* 8216BA00h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 8216BA00h case   27:*/		return 0x8216BA04;
		  /* 8216BA04h */ case   28:  		/* mr R5, R29 */
		/* 8216BA04h case   28:*/		regs.R5 = regs.R29;
		/* 8216BA04h case   28:*/		return 0x8216BA08;
	}
	return 0x8216BA08;
} // Block from 8216B994h-8216BA08h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8216BA08h
// Function '?ParseControlFlowLite@@YAJPBTGPUFLOW_INSTRUCTION@@PAUTODO_LIST@@PAUInstructionUsageLite@@PBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BA08);
		  /* 8216BA08h */ case    0:  		/* mr R3, R31 */
		/* 8216BA08h case    0:*/		regs.R3 = regs.R31;
		/* 8216BA08h case    0:*/		return 0x8216BA0C;
		  /* 8216BA0Ch */ case    1:  		/* bl -828 */
		/* 8216BA0Ch case    1:*/		regs.LR = 0x8216BA10; return 0x8216B6D0;
		/* 8216BA0Ch case    1:*/		return 0x8216BA10;
		  /* 8216BA10h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8216BA10h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216BA10h case    2:*/		return 0x8216BA14;
		  /* 8216BA14h */ case    3:  		/* bc 12, CR0_LT, 84 */
		/* 8216BA14h case    3:*/		if ( regs.CR[0].lt ) { return 0x8216BA68;  }
		/* 8216BA14h case    3:*/		return 0x8216BA18;
		  /* 8216BA18h */ case    4:  		/* mr R3, R31 */
		/* 8216BA18h case    4:*/		regs.R3 = regs.R31;
		/* 8216BA18h case    4:*/		return 0x8216BA1C;
		  /* 8216BA1Ch */ case    5:  		/* lwz R4, <#[R31 + 24]> */
		/* 8216BA1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 8216BA1Ch case    5:*/		return 0x8216BA20;
		  /* 8216BA20h */ case    6:  		/* bl -848 */
		/* 8216BA20h case    6:*/		regs.LR = 0x8216BA24; return 0x8216B6D0;
		/* 8216BA20h case    6:*/		return 0x8216BA24;
		  /* 8216BA24h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8216BA24h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216BA24h case    7:*/		return 0x8216BA28;
		  /* 8216BA28h */ case    8:  		/* bc 12, CR0_LT, 64 */
		/* 8216BA28h case    8:*/		if ( regs.CR[0].lt ) { return 0x8216BA68;  }
		/* 8216BA28h case    8:*/		return 0x8216BA2C;
		  /* 8216BA2Ch */ case    9:  		/* add R30, R8, R31 */
		/* 8216BA2Ch case    9:*/		cpu::op::add<0>(regs,&regs.R30,regs.R8,regs.R31);
		/* 8216BA2Ch case    9:*/		return 0x8216BA30;
		  /* 8216BA30h */ case   10:  		/* li R28, 0 */
		/* 8216BA30h case   10:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8216BA30h case   10:*/		return 0x8216BA34;
		  /* 8216BA34h */ case   11:  		/* cmplwi CR6, R27, 0 */
		/* 8216BA34h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8216BA34h case   11:*/		return 0x8216BA38;
		  /* 8216BA38h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 8216BA38h case   12:*/		if ( regs.CR[6].eq ) { return 0x8216BA64;  }
		/* 8216BA38h case   12:*/		return 0x8216BA3C;
		  /* 8216BA3Ch */ case   13:  		/* mr R5, R29 */
		/* 8216BA3Ch case   13:*/		regs.R5 = regs.R29;
		/* 8216BA3Ch case   13:*/		return 0x8216BA40;
		  /* 8216BA40h */ case   14:  		/* mr R4, R31 */
		/* 8216BA40h case   14:*/		regs.R4 = regs.R31;
		/* 8216BA40h case   14:*/		return 0x8216BA44;
		  /* 8216BA44h */ case   15:  		/* mr R3, R30 */
		/* 8216BA44h case   15:*/		regs.R3 = regs.R30;
		/* 8216BA44h case   15:*/		return 0x8216BA48;
		  /* 8216BA48h */ case   16:  		/* bl -512 */
		/* 8216BA48h case   16:*/		regs.LR = 0x8216BA4C; return 0x8216B848;
		/* 8216BA48h case   16:*/		return 0x8216BA4C;
		  /* 8216BA4Ch */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 8216BA4Ch case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216BA4Ch case   17:*/		return 0x8216BA50;
		  /* 8216BA50h */ case   18:  		/* bc 12, CR0_LT, 24 */
		/* 8216BA50h case   18:*/		if ( regs.CR[0].lt ) { return 0x8216BA68;  }
		/* 8216BA50h case   18:*/		return 0x8216BA54;
		  /* 8216BA54h */ case   19:  		/* addi R28, R28, 1 */
		/* 8216BA54h case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8216BA54h case   19:*/		return 0x8216BA58;
		  /* 8216BA58h */ case   20:  		/* addi R30, R30, 20 */
		/* 8216BA58h case   20:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x14);
		/* 8216BA58h case   20:*/		return 0x8216BA5C;
		  /* 8216BA5Ch */ case   21:  		/* cmplw CR6, R28, R27 */
		/* 8216BA5Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 8216BA5Ch case   21:*/		return 0x8216BA60;
		  /* 8216BA60h */ case   22:  		/* bc 12, CR6_LT, -36 */
		/* 8216BA60h case   22:*/		if ( regs.CR[6].lt ) { return 0x8216BA3C;  }
		/* 8216BA60h case   22:*/		return 0x8216BA64;
	}
	return 0x8216BA64;
} // Block from 8216BA08h-8216BA64h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8216BA64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BA64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BA64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BA64);
		  /* 8216BA64h */ case    0:  		/* li R3, 0 */
		/* 8216BA64h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216BA64h case    0:*/		return 0x8216BA68;
	}
	return 0x8216BA68;
} // Block from 8216BA64h-8216BA68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216BA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BA68);
		  /* 8216BA68h */ case    0:  		/* addi R1, R1, 128 */
		/* 8216BA68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216BA68h case    0:*/		return 0x8216BA6C;
		  /* 8216BA6Ch */ case    1:  		/* b -894920 */
		/* 8216BA6Ch case    1:*/		return 0x820912A4;
		/* 8216BA6Ch case    1:*/		return 0x8216BA70;
		  /* 8216BA70h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 8216BA70h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8216BA70h case    2:*/		return 0x8216BA74;
		  /* 8216BA74h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 8216BA74h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8216BA74h case    3:*/		return 0x8216BA78;
	}
	return 0x8216BA78;
} // Block from 8216BA68h-8216BA78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216BA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BA78);
		  /* 8216BA78h */ case    0:  		/* lwz R11, <#[R4 + 68]> */
		/* 8216BA78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000044) );
		/* 8216BA78h case    0:*/		return 0x8216BA7C;
		  /* 8216BA7Ch */ case    1:  		/* cmplw CR6, R3, R11 */
		/* 8216BA7Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8216BA7Ch case    1:*/		return 0x8216BA80;
		  /* 8216BA80h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 8216BA80h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8216BA90;  }
		/* 8216BA80h case    2:*/		return 0x8216BA84;
		  /* 8216BA84h */ case    3:  		/* lis R3, -32768 */
		/* 8216BA84h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216BA84h case    3:*/		return 0x8216BA88;
		  /* 8216BA88h */ case    4:  		/* ori R3, R3, 16389 */
		/* 8216BA88h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216BA88h case    4:*/		return 0x8216BA8C;
		  /* 8216BA8Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8216BA8Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216BA8Ch case    5:*/		return 0x8216BA90;
	}
	return 0x8216BA90;
} // Block from 8216BA78h-8216BA90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216BA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BA90);
		  /* 8216BA90h */ case    0:  		/* lwz R9, <#[R4 + 72]> */
		/* 8216BA90h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000048) );
		/* 8216BA90h case    0:*/		return 0x8216BA94;
		  /* 8216BA94h */ case    1:  		/* addi R10, R3, 24 */
		/* 8216BA94h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x18);
		/* 8216BA94h case    1:*/		return 0x8216BA98;
		  /* 8216BA98h */ case    2:  		/* add R8, R9, R11 */
		/* 8216BA98h case    2:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 8216BA98h case    2:*/		return 0x8216BA9C;
		  /* 8216BA9Ch */ case    3:  		/* cmplw CR6, R10, R8 */
		/* 8216BA9Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8216BA9Ch case    3:*/		return 0x8216BAA0;
		  /* 8216BAA0h */ case    4:  		/* bc 12, CR6_GT, -28 */
		/* 8216BAA0h case    4:*/		if ( regs.CR[6].gt ) { return 0x8216BA84;  }
		/* 8216BAA0h case    4:*/		return 0x8216BAA4;
		  /* 8216BAA4h */ case    5:  		/* rldicl R7, R9, 0, 32 */
		/* 8216BAA4h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R9);
		/* 8216BAA4h case    5:*/		return 0x8216BAA8;
		  /* 8216BAA8h */ case    6:  		/* lwz R10, <#[R3 + 16]> */
		/* 8216BAA8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8216BAA8h case    6:*/		return 0x8216BAAC;
		  /* 8216BAACh */ case    7:  		/* rldicl R8, R11, 0, 32 */
		/* 8216BAACh case    7:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R11);
		/* 8216BAACh case    7:*/		return 0x8216BAB0;
		  /* 8216BAB0h */ case    8:  		/* rldicl R9, R3, 0, 32 */
		/* 8216BAB0h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R3);
		/* 8216BAB0h case    8:*/		return 0x8216BAB4;
		  /* 8216BAB4h */ case    9:  		/* add R8, R7, R8 */
		/* 8216BAB4h case    9:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8216BAB4h case    9:*/		return 0x8216BAB8;
		  /* 8216BAB8h */ case   10:  		/* add R11, R10, R9 */
		/* 8216BAB8h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 8216BAB8h case   10:*/		return 0x8216BABC;
		  /* 8216BABCh */ case   11:  		/* cmpld CR6, R11, R8 */
		/* 8216BABCh case   11:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R8);
		/* 8216BABCh case   11:*/		return 0x8216BAC0;
		  /* 8216BAC0h */ case   12:  		/* bc 12, CR6_GT, -60 */
		/* 8216BAC0h case   12:*/		if ( regs.CR[6].gt ) { return 0x8216BA84;  }
		/* 8216BAC0h case   12:*/		return 0x8216BAC4;
		  /* 8216BAC4h */ case   13:  		/* addi R11, R3, 20 */
		/* 8216BAC4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x14);
		/* 8216BAC4h case   13:*/		return 0x8216BAC8;
		  /* 8216BAC8h */ case   14:  		/* rlwinm R10, R10, 0, 0, 29 */
		/* 8216BAC8h case   14:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R10);
		/* 8216BAC8h case   14:*/		return 0x8216BACC;
		  /* 8216BACCh */ case   15:  		/* li R3, 0 */
		/* 8216BACCh case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216BACCh case   15:*/		return 0x8216BAD0;
		  /* 8216BAD0h */ case   16:  		/* add R5, R10, R11 */
		/* 8216BAD0h case   16:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 8216BAD0h case   16:*/		return 0x8216BAD4;
		  /* 8216BAD4h */ case   17:  		/* b 236 */
		/* 8216BAD4h case   17:*/		return 0x8216BBC0;
		/* 8216BAD4h case   17:*/		return 0x8216BAD8;
		  /* 8216BAD8h */ case   18:  		/* lhz R10, <#[R11 + 2]> */
		/* 8216BAD8h case   18:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000002) );
		/* 8216BAD8h case   18:*/		return 0x8216BADC;
		  /* 8216BADCh */ case   19:  		/* lhz R6, <#[R11]> */
		/* 8216BADCh case   19:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216BADCh case   19:*/		return 0x8216BAE0;
		  /* 8216BAE0h */ case   20:  		/* addi R11, R11, 4 */
		/* 8216BAE0h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216BAE0h case   20:*/		return 0x8216BAE4;
		  /* 8216BAE4h */ case   21:  		/* or. R8, R10, R10 */
		/* 8216BAE4h case   21:*/		cpu::op::or<1>(regs,&regs.R8,regs.R10,regs.R10);
		/* 8216BAE4h case   21:*/		return 0x8216BAE8;
		  /* 8216BAE8h */ case   22:  		/* bc 4, CR0_EQ, 20 */
		/* 8216BAE8h case   22:*/		if ( !regs.CR[0].eq ) { return 0x8216BAFC;  }
		/* 8216BAE8h case   22:*/		return 0x8216BAEC;
		  /* 8216BAECh */ case   23:  		/* addi R3, R3, 1 */
		/* 8216BAECh case   23:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 8216BAECh case   23:*/		return 0x8216BAF0;
		  /* 8216BAF0h */ case   24:  		/* cmplwi CR6, R3, 3 */
		/* 8216BAF0h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000003);
		/* 8216BAF0h case   24:*/		return 0x8216BAF4;
		  /* 8216BAF4h */ case   25:  		/* bc 4, CR6_LT, 212 */
		/* 8216BAF4h case   25:*/		if ( !regs.CR[6].lt ) { return 0x8216BBC8;  }
		/* 8216BAF4h case   25:*/		return 0x8216BAF8;
		  /* 8216BAF8h */ case   26:  		/* b 200 */
		/* 8216BAF8h case   26:*/		return 0x8216BBC0;
		/* 8216BAF8h case   26:*/		return 0x8216BAFC;
	}
	return 0x8216BAFC;
} // Block from 8216BA90h-8216BAFCh (27 instructions)

//////////////////////////////////////////////////////
// Block at 8216BAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BAFC);
		  /* 8216BAFCh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 8216BAFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8216BAFCh case    0:*/		return 0x8216BB00;
		  /* 8216BB00h */ case    1:  		/* bc 4, CR6_EQ, 88 */
		/* 8216BB00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216BB58;  }
		/* 8216BB00h case    1:*/		return 0x8216BB04;
		  /* 8216BB04h */ case    2:  		/* rlwinm. R9, R8, 0, 28, 31 */
		/* 8216BB04h case    2:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R9,regs.R8);
		/* 8216BB04h case    2:*/		return 0x8216BB08;
		  /* 8216BB08h */ case    3:  		/* bc 4, CR0_EQ, -132 */
		/* 8216BB08h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216BA84;  }
		/* 8216BB08h case    3:*/		return 0x8216BB0C;
		  /* 8216BB0Ch */ case    4:  		/* cmplw CR6, R11, R5 */
		/* 8216BB0Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8216BB0Ch case    4:*/		return 0x8216BB10;
		  /* 8216BB10h */ case    5:  		/* bc 4, CR6_LT, -140 */
		/* 8216BB10h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8216BA84;  }
		/* 8216BB10h case    5:*/		return 0x8216BB14;
		  /* 8216BB14h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 8216BB14h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216BB14h case    6:*/		return 0x8216BB18;
		  /* 8216BB18h */ case    7:  		/* addi R11, R11, 4 */
		/* 8216BB18h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216BB18h case    7:*/		return 0x8216BB1C;
		  /* 8216BB1Ch */ case    8:  		/* lwz R8, <#[R4 + 80]> */
		/* 8216BB1Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000050) );
		/* 8216BB1Ch case    8:*/		return 0x8216BB20;
		  /* 8216BB20h */ case    9:  		/* cmplw CR6, R9, R8 */
		/* 8216BB20h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8216BB20h case    9:*/		return 0x8216BB24;
		  /* 8216BB24h */ case   10:  		/* bc 4, CR6_LT, -160 */
		/* 8216BB24h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8216BA84;  }
		/* 8216BB24h case   10:*/		return 0x8216BB28;
		  /* 8216BB28h */ case   11:  		/* rlwinm R7, R10, 2, 14, 29 */
		/* 8216BB28h case   11:*/		cpu::op::rlwinm<0,2,14,29>(regs,&regs.R7,regs.R10);
		/* 8216BB28h case   11:*/		return 0x8216BB2C;
		  /* 8216BB2Ch */ case   12:  		/* rldicl R9, R9, 0, 32 */
		/* 8216BB2Ch case   12:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 8216BB2Ch case   12:*/		return 0x8216BB30;
		  /* 8216BB30h */ case   13:  		/* rldicl R8, R8, 0, 32 */
		/* 8216BB30h case   13:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R8);
		/* 8216BB30h case   13:*/		return 0x8216BB34;
		  /* 8216BB34h */ case   14:  		/* add R9, R7, R9 */
		/* 8216BB34h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8216BB34h case   14:*/		return 0x8216BB38;
		  /* 8216BB38h */ case   15:  		/* rldicl R10, R10, 0, 48 */
		/* 8216BB38h case   15:*/		cpu::op::rldicl<0,0,48>(regs,&regs.R10,regs.R10);
		/* 8216BB38h case   15:*/		return 0x8216BB3C;
		  /* 8216BB3Ch */ case   16:  		/* cmpld CR6, R9, R8 */
		/* 8216BB3Ch case   16:*/		cpu::op::cmpld<6>(regs,regs.R9,regs.R8);
		/* 8216BB3Ch case   16:*/		return 0x8216BB40;
		  /* 8216BB40h */ case   17:  		/* bc 12, CR6_GT, -188 */
		/* 8216BB40h case   17:*/		if ( regs.CR[6].gt ) { return 0x8216BA84;  }
		/* 8216BB40h case   17:*/		return 0x8216BB44;
		  /* 8216BB44h */ case   18:  		/* rldicl R10, R10, 62, 2 */
		/* 8216BB44h case   18:*/		cpu::op::rldicl<0,62,2>(regs,&regs.R10,regs.R10);
		/* 8216BB44h case   18:*/		return 0x8216BB48;
		  /* 8216BB48h */ case   19:  		/* rldicl R9, R6, 0, 48 */
		/* 8216BB48h case   19:*/		cpu::op::rldicl<0,0,48>(regs,&regs.R9,regs.R6);
		/* 8216BB48h case   19:*/		return 0x8216BB4C;
		  /* 8216BB4Ch */ case   20:  		/* add R10, R10, R9 */
		/* 8216BB4Ch case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216BB4Ch case   20:*/		return 0x8216BB50;
		  /* 8216BB50h */ case   21:  		/* cmpldi CR6, R10, 512 */
		/* 8216BB50h case   21:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000200);
		/* 8216BB50h case   21:*/		return 0x8216BB54;
		  /* 8216BB54h */ case   22:  		/* b 104 */
		/* 8216BB54h case   22:*/		return 0x8216BBBC;
		/* 8216BB54h case   22:*/		return 0x8216BB58;
	}
	return 0x8216BB58;
} // Block from 8216BAFCh-8216BB58h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8216BB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BB58);
		  /* 8216BB58h */ case    0:  		/* cmplwi CR6, R3, 1 */
		/* 8216BB58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8216BB58h case    0:*/		return 0x8216BB5C;
		  /* 8216BB5Ch */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 8216BB5Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216BB80;  }
		/* 8216BB5Ch case    1:*/		return 0x8216BB60;
		  /* 8216BB60h */ case    2:  		/* rlwinm R9, R6, 0, 16, 31 */
		/* 8216BB60h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R6);
		/* 8216BB60h case    2:*/		return 0x8216BB64;
		  /* 8216BB64h */ case    3:  		/* cmplwi CR6, R9, 8992 */
		/* 8216BB64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00002320);
		/* 8216BB64h case    3:*/		return 0x8216BB68;
		  /* 8216BB68h */ case    4:  		/* bc 12, CR6_LT, -228 */
		/* 8216BB68h case    4:*/		if ( regs.CR[6].lt ) { return 0x8216BA84;  }
		/* 8216BB68h case    4:*/		return 0x8216BB6C;
		  /* 8216BB6Ch */ case    5:  		/* rlwinm R10, R10, 2, 14, 29 */
		/* 8216BB6Ch case    5:*/		cpu::op::rlwinm<0,2,14,29>(regs,&regs.R10,regs.R10);
		/* 8216BB6Ch case    5:*/		return 0x8216BB70;
		  /* 8216BB70h */ case    6:  		/* rldicl R9, R6, 0, 48 */
		/* 8216BB70h case    6:*/		cpu::op::rldicl<0,0,48>(regs,&regs.R9,regs.R6);
		/* 8216BB70h case    6:*/		return 0x8216BB74;
		  /* 8216BB74h */ case    7:  		/* add R10, R10, R9 */
		/* 8216BB74h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216BB74h case    7:*/		return 0x8216BB78;
		  /* 8216BB78h */ case    8:  		/* cmpldi CR6, R10, 9120 */
		/* 8216BB78h case    8:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x000023A0);
		/* 8216BB78h case    8:*/		return 0x8216BB7C;
		  /* 8216BB7Ch */ case    9:  		/* b 48 */
		/* 8216BB7Ch case    9:*/		return 0x8216BBAC;
		/* 8216BB7Ch case    9:*/		return 0x8216BB80;
	}
	return 0x8216BB80;
} // Block from 8216BB58h-8216BB80h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216BB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BB80);
		  /* 8216BB80h */ case    0:  		/* cmplwi CR6, R3, 2 */
		/* 8216BB80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000002);
		/* 8216BB80h case    0:*/		return 0x8216BB84;
		  /* 8216BB84h */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 8216BB84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216BBC0;  }
		/* 8216BB84h case    1:*/		return 0x8216BB88;
		  /* 8216BB88h */ case    2:  		/* rlwinm. R9, R8, 0, 31, 31 */
		/* 8216BB88h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R8);
		/* 8216BB88h case    2:*/		return 0x8216BB8C;
		  /* 8216BB8Ch */ case    3:  		/* bc 4, CR0_EQ, -264 */
		/* 8216BB8Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216BA84;  }
		/* 8216BB8Ch case    3:*/		return 0x8216BB90;
		  /* 8216BB90h */ case    4:  		/* rlwinm R9, R6, 0, 16, 31 */
		/* 8216BB90h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R6);
		/* 8216BB90h case    4:*/		return 0x8216BB94;
		  /* 8216BB94h */ case    5:  		/* cmplwi CR6, R9, 8960 */
		/* 8216BB94h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00002300);
		/* 8216BB94h case    5:*/		return 0x8216BB98;
		  /* 8216BB98h */ case    6:  		/* bc 12, CR6_LT, -276 */
		/* 8216BB98h case    6:*/		if ( regs.CR[6].lt ) { return 0x8216BA84;  }
		/* 8216BB98h case    6:*/		return 0x8216BB9C;
		  /* 8216BB9Ch */ case    7:  		/* rlwinm R10, R10, 1, 15, 29 */
		/* 8216BB9Ch case    7:*/		cpu::op::rlwinm<0,1,15,29>(regs,&regs.R10,regs.R10);
		/* 8216BB9Ch case    7:*/		return 0x8216BBA0;
		  /* 8216BBA0h */ case    8:  		/* rldicl R9, R6, 0, 48 */
		/* 8216BBA0h case    8:*/		cpu::op::rldicl<0,0,48>(regs,&regs.R9,regs.R6);
		/* 8216BBA0h case    8:*/		return 0x8216BBA4;
		  /* 8216BBA4h */ case    9:  		/* add R10, R10, R9 */
		/* 8216BBA4h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216BBA4h case    9:*/		return 0x8216BBA8;
		  /* 8216BBA8h */ case   10:  		/* cmpldi CR6, R10, 8992 */
		/* 8216BBA8h case   10:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00002320);
		/* 8216BBA8h case   10:*/		return 0x8216BBAC;
	}
	return 0x8216BBAC;
} // Block from 8216BB80h-8216BBACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216BBACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BBAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BBAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BBAC);
		  /* 8216BBACh */ case    0:  		/* bc 12, CR6_GT, -296 */
		/* 8216BBACh case    0:*/		if ( regs.CR[6].gt ) { return 0x8216BA84;  }
		/* 8216BBACh case    0:*/		return 0x8216BBB0;
		  /* 8216BBB0h */ case    1:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 8216BBB0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 8216BBB0h case    1:*/		return 0x8216BBB4;
		  /* 8216BBB4h */ case    2:  		/* add R11, R10, R11 */
		/* 8216BBB4h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216BBB4h case    2:*/		return 0x8216BBB8;
		  /* 8216BBB8h */ case    3:  		/* cmplw CR6, R11, R5 */
		/* 8216BBB8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8216BBB8h case    3:*/		return 0x8216BBBC;
	}
	return 0x8216BBBC;
} // Block from 8216BBACh-8216BBBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216BBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BBBC);
		  /* 8216BBBCh */ case    0:  		/* bc 12, CR6_GT, -312 */
		/* 8216BBBCh case    0:*/		if ( regs.CR[6].gt ) { return 0x8216BA84;  }
		/* 8216BBBCh case    0:*/		return 0x8216BBC0;
	}
	return 0x8216BBC0;
} // Block from 8216BBBCh-8216BBC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216BBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BBC0);
		  /* 8216BBC0h */ case    0:  		/* cmplw CR6, R11, R5 */
		/* 8216BBC0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8216BBC0h case    0:*/		return 0x8216BBC4;
		  /* 8216BBC4h */ case    1:  		/* bc 12, CR6_LT, -236 */
		/* 8216BBC4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8216BAD8;  }
		/* 8216BBC4h case    1:*/		return 0x8216BBC8;
	}
	return 0x8216BBC8;
} // Block from 8216BBC0h-8216BBC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216BBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BBC8);
		  /* 8216BBC8h */ case    0:  		/* subf R11, R11, R5 */
		/* 8216BBC8h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8216BBC8h case    0:*/		return 0x8216BBCC;
		  /* 8216BBCCh */ case    1:  		/* lis R10, -32768 */
		/* 8216BBCCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 8216BBCCh case    1:*/		return 0x8216BBD0;
		  /* 8216BBD0h */ case    2:  		/* subfic R11, R11, 0 */
		/* 8216BBD0h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 8216BBD0h case    2:*/		return 0x8216BBD4;
		  /* 8216BBD4h */ case    3:  		/* ori R10, R10, 16389 */
		/* 8216BBD4h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4005);
		/* 8216BBD4h case    3:*/		return 0x8216BBD8;
		  /* 8216BBD8h */ case    4:  		/* subfe R11, R11, R11 */
		/* 8216BBD8h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8216BBD8h case    4:*/		return 0x8216BBDC;
		  /* 8216BBDCh */ case    5:  		/* and R3, R11, R10 */
		/* 8216BBDCh case    5:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8216BBDCh case    5:*/		return 0x8216BBE0;
		  /* 8216BBE0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8216BBE0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216BBE0h case    6:*/		return 0x8216BBE4;
	}
	return 0x8216BBE4;
} // Block from 8216BBC8h-8216BBE4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216BBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BBE4);
		  /* 8216BBE4h */ case    0:  		/* nop */
		/* 8216BBE4h case    0:*/		cpu::op::nop();
		/* 8216BBE4h case    0:*/		return 0x8216BBE8;
		  /* 8216BBE8h */ case    1:  		/* lwz R10, <#[R4]> */
		/* 8216BBE8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8216BBE8h case    1:*/		return 0x8216BBEC;
		  /* 8216BBECh */ case    2:  		/* lwz R11, <#[R4 + 68]> */
		/* 8216BBECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000044) );
		/* 8216BBECh case    2:*/		return 0x8216BBF0;
		  /* 8216BBF0h */ case    3:  		/* cmplw CR6, R3, R11 */
		/* 8216BBF0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8216BBF0h case    3:*/		return 0x8216BBF4;
		  /* 8216BBF4h */ case    4:  		/* lwz R7, <#[R10 + 28]> */
		/* 8216BBF4h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000001C) );
		/* 8216BBF4h case    4:*/		return 0x8216BBF8;
		  /* 8216BBF8h */ case    5:  		/* bc 12, CR6_LT, 40 */
		/* 8216BBF8h case    5:*/		if ( regs.CR[6].lt ) { return 0x8216BC20;  }
		/* 8216BBF8h case    5:*/		return 0x8216BBFC;
		  /* 8216BBFCh */ case    6:  		/* rldicl R8, R11, 0, 32 */
		/* 8216BBFCh case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R11);
		/* 8216BBFCh case    6:*/		return 0x8216BC00;
		  /* 8216BC00h */ case    7:  		/* lwz R9, <#[R4 + 72]> */
		/* 8216BC00h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000048) );
		/* 8216BC00h case    7:*/		return 0x8216BC04;
		  /* 8216BC04h */ case    8:  		/* li R11, 0 */
		/* 8216BC04h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216BC04h case    8:*/		return 0x8216BC08;
		  /* 8216BC08h */ case    9:  		/* rldicl R10, R3, 0, 32 */
		/* 8216BC08h case    9:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R3);
		/* 8216BC08h case    9:*/		return 0x8216BC0C;
		  /* 8216BC0Ch */ case   10:  		/* rldimi R11, R7, 2, 30 */
		/* 8216BC0Ch case   10:*/		cpu::op::rldimi<0,2,30>(regs,&regs.R11,regs.R7);
		/* 8216BC0Ch case   10:*/		return 0x8216BC10;
		  /* 8216BC10h */ case   11:  		/* add R9, R9, R8 */
		/* 8216BC10h case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216BC10h case   11:*/		return 0x8216BC14;
		  /* 8216BC14h */ case   12:  		/* add R11, R11, R10 */
		/* 8216BC14h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216BC14h case   12:*/		return 0x8216BC18;
		  /* 8216BC18h */ case   13:  		/* cmpld CR6, R11, R9 */
		/* 8216BC18h case   13:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R9);
		/* 8216BC18h case   13:*/		return 0x8216BC1C;
		  /* 8216BC1Ch */ case   14:  		/* bc 4, CR6_GT, 16 */
		/* 8216BC1Ch case   14:*/		if ( !regs.CR[6].gt ) { return 0x8216BC2C;  }
		/* 8216BC1Ch case   14:*/		return 0x8216BC20;
	}
	return 0x8216BC20;
} // Block from 8216BBE4h-8216BC20h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216BC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BC20);
		  /* 8216BC20h */ case    0:  		/* lis R3, -32768 */
		/* 8216BC20h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216BC20h case    0:*/		return 0x8216BC24;
		  /* 8216BC24h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216BC24h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216BC24h case    1:*/		return 0x8216BC28;
		  /* 8216BC28h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216BC28h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216BC28h case    2:*/		return 0x8216BC2C;
	}
	return 0x8216BC2C;
} // Block from 8216BC20h-8216BC2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216BC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BC2C);
		  /* 8216BC2Ch */ case    0:  		/* li R11, 0 */
		/* 8216BC2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216BC2Ch case    0:*/		return 0x8216BC30;
		  /* 8216BC30h */ case    1:  		/* li R6, 0 */
		/* 8216BC30h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216BC30h case    1:*/		return 0x8216BC34;
		  /* 8216BC34h */ case    2:  		/* li R8, 0 */
		/* 8216BC34h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216BC34h case    2:*/		return 0x8216BC38;
		  /* 8216BC38h */ case    3:  		/* cmplwi CR6, R7, 0 */
		/* 8216BC38h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8216BC38h case    3:*/		return 0x8216BC3C;
		  /* 8216BC3Ch */ case    4:  		/* bc 12, CR6_EQ, 156 */
		/* 8216BC3Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8216BCD8;  }
		/* 8216BC3Ch case    4:*/		return 0x8216BC40;
		  /* 8216BC40h */ case    5:  		/* lwz R9, <#[R3]> */
		/* 8216BC40h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8216BC40h case    5:*/		return 0x8216BC44;
		  /* 8216BC44h */ case    6:  		/* rlwinm R10, R9, 0, 20, 31 */
		/* 8216BC44h case    6:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R9);
		/* 8216BC44h case    6:*/		return 0x8216BC48;
		  /* 8216BC48h */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 8216BC48h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216BC48h case    7:*/		return 0x8216BC4C;
		  /* 8216BC4Ch */ case    8:  		/* bc 4, CR6_GT, -44 */
		/* 8216BC4Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x8216BC20;  }
		/* 8216BC4Ch case    8:*/		return 0x8216BC50;
		  /* 8216BC50h */ case    9:  		/* lwz R11, <#[R4 + 84]> */
		/* 8216BC50h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000054) );
		/* 8216BC50h case    9:*/		return 0x8216BC54;
		  /* 8216BC54h */ case   10:  		/* rlwinm R5, R9, 1, 19, 30 */
		/* 8216BC54h case   10:*/		cpu::op::rlwinm<0,1,19,30>(regs,&regs.R5,regs.R9);
		/* 8216BC54h case   10:*/		return 0x8216BC58;
		  /* 8216BC58h */ case   11:  		/* cmpld CR6, R5, R11 */
		/* 8216BC58h case   11:*/		cpu::op::cmpld<6>(regs,regs.R5,regs.R11);
		/* 8216BC58h case   11:*/		return 0x8216BC5C;
		  /* 8216BC5Ch */ case   12:  		/* bc 4, CR6_LT, -60 */
		/* 8216BC5Ch case   12:*/		if ( !regs.CR[6].lt ) { return 0x8216BC20;  }
		/* 8216BC5Ch case   12:*/		return 0x8216BC60;
		  /* 8216BC60h */ case   13:  		/* addi R11, R10, 11 */
		/* 8216BC60h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xB);
		/* 8216BC60h case   13:*/		return 0x8216BC64;
		  /* 8216BC64h */ case   14:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8216BC64h case   14:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8216BC64h case   14:*/		return 0x8216BC68;
		  /* 8216BC68h */ case   15:  		/* lwzx R11, <#[R11 + R4]> */
		/* 8216BC68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 8216BC68h case   15:*/		return 0x8216BC6C;
		  /* 8216BC6Ch */ case   16:  		/* rlwinm R11, R11, 2, 30, 31 */
		/* 8216BC6Ch case   16:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R11,regs.R11);
		/* 8216BC6Ch case   16:*/		return 0x8216BC70;
		  /* 8216BC70h */ case   17:  		/* cmpwi CR6, R11, 1 */
		/* 8216BC70h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8216BC70h case   17:*/		return 0x8216BC74;
		  /* 8216BC74h */ case   18:  		/* bc 12, CR6_EQ, -84 */
		/* 8216BC74h case   18:*/		if ( regs.CR[6].eq ) { return 0x8216BC20;  }
		/* 8216BC74h case   18:*/		return 0x8216BC78;
		  /* 8216BC78h */ case   19:  		/* cmpwi CR6, R11, 2 */
		/* 8216BC78h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8216BC78h case   19:*/		return 0x8216BC7C;
		  /* 8216BC7Ch */ case   20:  		/* bc 12, CR6_EQ, -92 */
		/* 8216BC7Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x8216BC20;  }
		/* 8216BC7Ch case   20:*/		return 0x8216BC80;
		  /* 8216BC80h */ case   21:  		/* lwz R11, <#[R4 + 4]> */
		/* 8216BC80h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8216BC80h case   21:*/		return 0x8216BC84;
		  /* 8216BC84h */ case   22:  		/* mulli R5, R10, 12 */
		/* 8216BC84h case   22:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R10,0xC);
		/* 8216BC84h case   22:*/		return 0x8216BC88;
		  /* 8216BC88h */ case   23:  		/* lwzx R11, <#[R5 + R11]> */
		/* 8216BC88h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 8216BC88h case   23:*/		return 0x8216BC8C;
		  /* 8216BC8Ch */ case   24:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8216BC8Ch case   24:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8216BC8Ch case   24:*/		return 0x8216BC90;
		  /* 8216BC90h */ case   25:  		/* bc 4, CR0_EQ, -112 */
		/* 8216BC90h case   25:*/		if ( !regs.CR[0].eq ) { return 0x8216BC20;  }
		/* 8216BC90h case   25:*/		return 0x8216BC94;
		  /* 8216BC94h */ case   26:  		/* rlwinm R11, R9, 12, 30, 31 */
		/* 8216BC94h case   26:*/		cpu::op::rlwinm<0,12,30,31>(regs,&regs.R11,regs.R9);
		/* 8216BC94h case   26:*/		return 0x8216BC98;
		  /* 8216BC98h */ case   27:  		/* cmplwi CR6, R11, 1 */
		/* 8216BC98h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216BC98h case   27:*/		return 0x8216BC9C;
		  /* 8216BC9Ch */ case   28:  		/* bc 4, CR6_EQ, 20 */
		/* 8216BC9Ch case   28:*/		if ( !regs.CR[6].eq ) { return 0x8216BCB0;  }
		/* 8216BC9Ch case   28:*/		return 0x8216BCA0;
		  /* 8216BCA0h */ case   29:  		/* cmpwi CR6, R6, 0 */
		/* 8216BCA0h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8216BCA0h case   29:*/		return 0x8216BCA4;
		  /* 8216BCA4h */ case   30:  		/* bc 4, CR6_EQ, -132 */
		/* 8216BCA4h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8216BC20;  }
		/* 8216BCA4h case   30:*/		return 0x8216BCA8;
		  /* 8216BCA8h */ case   31:  		/* li R6, 1 */
		/* 8216BCA8h case   31:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216BCA8h case   31:*/		return 0x8216BCAC;
		  /* 8216BCACh */ case   32:  		/* b 24 */
		/* 8216BCACh case   32:*/		return 0x8216BCC4;
		/* 8216BCACh case   32:*/		return 0x8216BCB0;
	}
	return 0x8216BCB0;
} // Block from 8216BC2Ch-8216BCB0h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8216BCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BCB0);
		  /* 8216BCB0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8216BCB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216BCB0h case    0:*/		return 0x8216BCB4;
		  /* 8216BCB4h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8216BCB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216BCC4;  }
		/* 8216BCB4h case    1:*/		return 0x8216BCB8;
		  /* 8216BCB8h */ case    2:  		/* cmpwi CR6, R6, 0 */
		/* 8216BCB8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8216BCB8h case    2:*/		return 0x8216BCBC;
		  /* 8216BCBCh */ case    3:  		/* bc 12, CR6_EQ, -156 */
		/* 8216BCBCh case    3:*/		if ( regs.CR[6].eq ) { return 0x8216BC20;  }
		/* 8216BCBCh case    3:*/		return 0x8216BCC0;
		  /* 8216BCC0h */ case    4:  		/* li R6, 0 */
		/* 8216BCC0h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216BCC0h case    4:*/		return 0x8216BCC4;
	}
	return 0x8216BCC4;
} // Block from 8216BCB0h-8216BCC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216BCC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BCC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BCC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BCC4);
		  /* 8216BCC4h */ case    0:  		/* addi R8, R8, 1 */
		/* 8216BCC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216BCC4h case    0:*/		return 0x8216BCC8;
		  /* 8216BCC8h */ case    1:  		/* mr R11, R10 */
		/* 8216BCC8h case    1:*/		regs.R11 = regs.R10;
		/* 8216BCC8h case    1:*/		return 0x8216BCCC;
		  /* 8216BCCCh */ case    2:  		/* addi R3, R3, 4 */
		/* 8216BCCCh case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 8216BCCCh case    2:*/		return 0x8216BCD0;
		  /* 8216BCD0h */ case    3:  		/* cmplw CR6, R8, R7 */
		/* 8216BCD0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8216BCD0h case    3:*/		return 0x8216BCD4;
		  /* 8216BCD4h */ case    4:  		/* bc 12, CR6_LT, -148 */
		/* 8216BCD4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8216BC40;  }
		/* 8216BCD4h case    4:*/		return 0x8216BCD8;
	}
	return 0x8216BCD8;
} // Block from 8216BCC4h-8216BCD8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216BCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BCD8);
		  /* 8216BCD8h */ case    0:  		/* li R3, 0 */
		/* 8216BCD8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216BCD8h case    0:*/		return 0x8216BCDC;
		  /* 8216BCDCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216BCDCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216BCDCh case    1:*/		return 0x8216BCE0;
	}
	return 0x8216BCE0;
} // Block from 8216BCD8h-8216BCE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216BCE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BCE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BCE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BCE0);
		  /* 8216BCE0h */ case    0:  		/* lwz R10, <#[R4]> */
		/* 8216BCE0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8216BCE0h case    0:*/		return 0x8216BCE4;
		  /* 8216BCE4h */ case    1:  		/* lwz R11, <#[R4 + 68]> */
		/* 8216BCE4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000044) );
		/* 8216BCE4h case    1:*/		return 0x8216BCE8;
		  /* 8216BCE8h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 8216BCE8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8216BCE8h case    2:*/		return 0x8216BCEC;
		  /* 8216BCECh */ case    3:  		/* lwz R7, <#[R10 + 32]> */
		/* 8216BCECh case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000020) );
		/* 8216BCECh case    3:*/		return 0x8216BCF0;
		  /* 8216BCF0h */ case    4:  		/* bc 12, CR6_LT, 40 */
		/* 8216BCF0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8216BD18;  }
		/* 8216BCF0h case    4:*/		return 0x8216BCF4;
		  /* 8216BCF4h */ case    5:  		/* rldicl R8, R11, 0, 32 */
		/* 8216BCF4h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R11);
		/* 8216BCF4h case    5:*/		return 0x8216BCF8;
		  /* 8216BCF8h */ case    6:  		/* lwz R9, <#[R4 + 72]> */
		/* 8216BCF8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000048) );
		/* 8216BCF8h case    6:*/		return 0x8216BCFC;
		  /* 8216BCFCh */ case    7:  		/* li R11, 0 */
		/* 8216BCFCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216BCFCh case    7:*/		return 0x8216BD00;
		  /* 8216BD00h */ case    8:  		/* rldicl R10, R3, 0, 32 */
		/* 8216BD00h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R3);
		/* 8216BD00h case    8:*/		return 0x8216BD04;
		  /* 8216BD04h */ case    9:  		/* rldimi R11, R7, 2, 30 */
		/* 8216BD04h case    9:*/		cpu::op::rldimi<0,2,30>(regs,&regs.R11,regs.R7);
		/* 8216BD04h case    9:*/		return 0x8216BD08;
		  /* 8216BD08h */ case   10:  		/* add R9, R9, R8 */
		/* 8216BD08h case   10:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216BD08h case   10:*/		return 0x8216BD0C;
		  /* 8216BD0Ch */ case   11:  		/* add R11, R11, R10 */
		/* 8216BD0Ch case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216BD0Ch case   11:*/		return 0x8216BD10;
		  /* 8216BD10h */ case   12:  		/* cmpld CR6, R11, R9 */
		/* 8216BD10h case   12:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R9);
		/* 8216BD10h case   12:*/		return 0x8216BD14;
		  /* 8216BD14h */ case   13:  		/* bc 4, CR6_GT, 16 */
		/* 8216BD14h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8216BD24;  }
		/* 8216BD14h case   13:*/		return 0x8216BD18;
	}
	return 0x8216BD18;
} // Block from 8216BCE0h-8216BD18h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216BD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BD18);
		  /* 8216BD18h */ case    0:  		/* lis R3, -32768 */
		/* 8216BD18h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216BD18h case    0:*/		return 0x8216BD1C;
		  /* 8216BD1Ch */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216BD1Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216BD1Ch case    1:*/		return 0x8216BD20;
		  /* 8216BD20h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216BD20h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216BD20h case    2:*/		return 0x8216BD24;
	}
	return 0x8216BD24;
} // Block from 8216BD18h-8216BD24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216BD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BD24);
		  /* 8216BD24h */ case    0:  		/* li R8, 0 */
		/* 8216BD24h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216BD24h case    0:*/		return 0x8216BD28;
		  /* 8216BD28h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 8216BD28h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8216BD28h case    1:*/		return 0x8216BD2C;
		  /* 8216BD2Ch */ case    2:  		/* bc 12, CR6_EQ, 140 */
		/* 8216BD2Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8216BDB8;  }
		/* 8216BD2Ch case    2:*/		return 0x8216BD30;
		  /* 8216BD30h */ case    3:  		/* lwz R6, <#[R4 + 84]> */
		/* 8216BD30h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000054) );
		/* 8216BD30h case    3:*/		return 0x8216BD34;
		  /* 8216BD34h */ case    4:  		/* lis R12, -16 */
		/* 8216BD34h case    4:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFF0);
		/* 8216BD34h case    4:*/		return 0x8216BD38;
		  /* 8216BD38h */ case    5:  		/* lwz R9, <#[R3]> */
		/* 8216BD38h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8216BD38h case    5:*/		return 0x8216BD3C;
		  /* 8216BD3Ch */ case    6:  		/* ori R12, R12, 0 */
		/* 8216BD3Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x0);
		/* 8216BD3Ch case    6:*/		return 0x8216BD40;
		  /* 8216BD40h */ case    7:  		/* rldicl R11, R9, 1, 0 */
		/* 8216BD40h case    7:*/		cpu::op::rldicl<0,1,0>(regs,&regs.R11,regs.R9);
		/* 8216BD40h case    7:*/		return 0x8216BD44;
		  /* 8216BD44h */ case    8:  		/* rldicr R12, R12, 13, 63 */
		/* 8216BD44h case    8:*/		cpu::op::rldicr<0,13,63>(regs,&regs.R12,regs.R12);
		/* 8216BD44h case    8:*/		return 0x8216BD48;
		  /* 8216BD48h */ case    9:  		/* and R11, R11, R12 */
		/* 8216BD48h case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8216BD48h case    9:*/		return 0x8216BD4C;
		  /* 8216BD4Ch */ case   10:  		/* cmpld CR6, R11, R6 */
		/* 8216BD4Ch case   10:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R6);
		/* 8216BD4Ch case   10:*/		return 0x8216BD50;
		  /* 8216BD50h */ case   11:  		/* bc 4, CR6_LT, -56 */
		/* 8216BD50h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8216BD18;  }
		/* 8216BD50h case   11:*/		return 0x8216BD54;
		  /* 8216BD54h */ case   12:  		/* rlwinm R11, R9, 0, 20, 31 */
		/* 8216BD54h case   12:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R9);
		/* 8216BD54h case   12:*/		return 0x8216BD58;
		  /* 8216BD58h */ case   13:  		/* addi R10, R11, 11 */
		/* 8216BD58h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xB);
		/* 8216BD58h case   13:*/		return 0x8216BD5C;
		  /* 8216BD5Ch */ case   14:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 8216BD5Ch case   14:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 8216BD5Ch case   14:*/		return 0x8216BD60;
		  /* 8216BD60h */ case   15:  		/* lwzx R10, <#[R10 + R4]> */
		/* 8216BD60h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8216BD60h case   15:*/		return 0x8216BD64;
		  /* 8216BD64h */ case   16:  		/* rlwinm R10, R10, 2, 30, 31 */
		/* 8216BD64h case   16:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R10,regs.R10);
		/* 8216BD64h case   16:*/		return 0x8216BD68;
		  /* 8216BD68h */ case   17:  		/* cmplwi CR6, R10, 1 */
		/* 8216BD68h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8216BD68h case   17:*/		return 0x8216BD6C;
		  /* 8216BD6Ch */ case   18:  		/* bc 12, CR6_EQ, -84 */
		/* 8216BD6Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x8216BD18;  }
		/* 8216BD6Ch case   18:*/		return 0x8216BD70;
		  /* 8216BD70h */ case   19:  		/* cmplwi CR6, R10, 3 */
		/* 8216BD70h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8216BD70h case   19:*/		return 0x8216BD74;
		  /* 8216BD74h */ case   20:  		/* bc 12, CR6_EQ, -92 */
		/* 8216BD74h case   20:*/		if ( regs.CR[6].eq ) { return 0x8216BD18;  }
		/* 8216BD74h case   20:*/		return 0x8216BD78;
		  /* 8216BD78h */ case   21:  		/* addi R10, R7, -1 */
		/* 8216BD78h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFFFFF);
		/* 8216BD78h case   21:*/		return 0x8216BD7C;
		  /* 8216BD7Ch */ case   22:  		/* cmplw CR6, R8, R10 */
		/* 8216BD7Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 8216BD7Ch case   22:*/		return 0x8216BD80;
		  /* 8216BD80h */ case   23:  		/* bc 4, CR6_EQ, 12 */
		/* 8216BD80h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8216BD8C;  }
		/* 8216BD80h case   23:*/		return 0x8216BD84;
		  /* 8216BD84h */ case   24:  		/* rlwinm. R10, R9, 0, 19, 19 */
		/* 8216BD84h case   24:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R9);
		/* 8216BD84h case   24:*/		return 0x8216BD88;
		  /* 8216BD88h */ case   25:  		/* bc 12, CR0_EQ, -112 */
		/* 8216BD88h case   25:*/		if ( regs.CR[0].eq ) { return 0x8216BD18;  }
		/* 8216BD88h case   25:*/		return 0x8216BD8C;
	}
	return 0x8216BD8C;
} // Block from 8216BD24h-8216BD8Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216BD8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BD8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BD8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BD8C);
		  /* 8216BD8Ch */ case    0:  		/* lwz R10, <#[R4 + 4]> */
		/* 8216BD8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 8216BD8Ch case    0:*/		return 0x8216BD90;
		  /* 8216BD90h */ case    1:  		/* mulli R11, R11, 12 */
		/* 8216BD90h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8216BD90h case    1:*/		return 0x8216BD94;
		  /* 8216BD94h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8216BD94h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8216BD94h case    2:*/		return 0x8216BD98;
		  /* 8216BD98h */ case    3:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 8216BD98h case    3:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 8216BD98h case    3:*/		return 0x8216BD9C;
		  /* 8216BD9Ch */ case    4:  		/* bc 12, CR0_EQ, -132 */
		/* 8216BD9Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8216BD18;  }
		/* 8216BD9Ch case    4:*/		return 0x8216BDA0;
		  /* 8216BDA0h */ case    5:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8216BDA0h case    5:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8216BDA0h case    5:*/		return 0x8216BDA4;
		  /* 8216BDA4h */ case    6:  		/* bc 4, CR0_EQ, -140 */
		/* 8216BDA4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216BD18;  }
		/* 8216BDA4h case    6:*/		return 0x8216BDA8;
		  /* 8216BDA8h */ case    7:  		/* addi R8, R8, 1 */
		/* 8216BDA8h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216BDA8h case    7:*/		return 0x8216BDAC;
		  /* 8216BDACh */ case    8:  		/* addi R3, R3, 4 */
		/* 8216BDACh case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 8216BDACh case    8:*/		return 0x8216BDB0;
		  /* 8216BDB0h */ case    9:  		/* cmplw CR6, R8, R7 */
		/* 8216BDB0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8216BDB0h case    9:*/		return 0x8216BDB4;
		  /* 8216BDB4h */ case   10:  		/* bc 12, CR6_LT, -128 */
		/* 8216BDB4h case   10:*/		if ( regs.CR[6].lt ) { return 0x8216BD34;  }
		/* 8216BDB4h case   10:*/		return 0x8216BDB8;
	}
	return 0x8216BDB8;
} // Block from 8216BD8Ch-8216BDB8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216BDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BDB8);
		  /* 8216BDB8h */ case    0:  		/* li R3, 0 */
		/* 8216BDB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216BDB8h case    0:*/		return 0x8216BDBC;
		  /* 8216BDBCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216BDBCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216BDBCh case    1:*/		return 0x8216BDC0;
	}
	return 0x8216BDC0;
} // Block from 8216BDB8h-8216BDC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216BDC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BDC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BDC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BDC0);
		  /* 8216BDC0h */ case    0:  		/* mfspr R12, LR */
		/* 8216BDC0h case    0:*/		regs.R12 = regs.LR;
		/* 8216BDC0h case    0:*/		return 0x8216BDC4;
		  /* 8216BDC4h */ case    1:  		/* bl -895852 */
		/* 8216BDC4h case    1:*/		regs.LR = 0x8216BDC8; return 0x82091258;
		/* 8216BDC4h case    1:*/		return 0x8216BDC8;
		  /* 8216BDC8h */ case    2:  		/* lwz R10, <#[R4 + 28]> */
		/* 8216BDC8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 8216BDC8h case    2:*/		return 0x8216BDCC;
		  /* 8216BDCCh */ case    3:  		/* rlwinm. R11, R10, 0, 13, 13 */
		/* 8216BDCCh case    3:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R10);
		/* 8216BDCCh case    3:*/		return 0x8216BDD0;
		  /* 8216BDD0h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 8216BDD0h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216BDE0;  }
		/* 8216BDD0h case    4:*/		return 0x8216BDD4;
		  /* 8216BDD4h */ case    5:  		/* lis R3, -32768 */
		/* 8216BDD4h case    5:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216BDD4h case    5:*/		return 0x8216BDD8;
		  /* 8216BDD8h */ case    6:  		/* ori R3, R3, 16389 */
		/* 8216BDD8h case    6:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216BDD8h case    6:*/		return 0x8216BDDC;
		  /* 8216BDDCh */ case    7:  		/* b 228 */
		/* 8216BDDCh case    7:*/		return 0x8216BEC0;
		/* 8216BDDCh case    7:*/		return 0x8216BDE0;
	}
	return 0x8216BDE0;
} // Block from 8216BDC0h-8216BDE0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216BDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BDE0);
		  /* 8216BDE0h */ case    0:  		/* rlwinm. R11, R10, 0, 14, 14 */
		/* 8216BDE0h case    0:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R11,regs.R10);
		/* 8216BDE0h case    0:*/		return 0x8216BDE4;
		  /* 8216BDE4h */ case    1:  		/* bc 4, CR0_EQ, -16 */
		/* 8216BDE4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216BDD4;  }
		/* 8216BDE4h case    1:*/		return 0x8216BDE8;
		  /* 8216BDE8h */ case    2:  		/* lwz R11, <#[R4 + 68]> */
		/* 8216BDE8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000044) );
		/* 8216BDE8h case    2:*/		return 0x8216BDEC;
		  /* 8216BDECh */ case    3:  		/* rlwinm R7, R10, 27, 27, 31 */
		/* 8216BDECh case    3:*/		cpu::op::rlwinm<0,27,27,31>(regs,&regs.R7,regs.R10);
		/* 8216BDECh case    3:*/		return 0x8216BDF0;
		  /* 8216BDF0h */ case    4:  		/* cmplw CR6, R3, R11 */
		/* 8216BDF0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8216BDF0h case    4:*/		return 0x8216BDF4;
		  /* 8216BDF4h */ case    5:  		/* bc 12, CR6_LT, -32 */
		/* 8216BDF4h case    5:*/		if ( regs.CR[6].lt ) { return 0x8216BDD4;  }
		/* 8216BDF4h case    5:*/		return 0x8216BDF8;
		  /* 8216BDF8h */ case    6:  		/* rldicl R8, R11, 0, 32 */
		/* 8216BDF8h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R11);
		/* 8216BDF8h case    6:*/		return 0x8216BDFC;
		  /* 8216BDFCh */ case    7:  		/* lwz R9, <#[R4 + 72]> */
		/* 8216BDFCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000048) );
		/* 8216BDFCh case    7:*/		return 0x8216BE00;
		  /* 8216BE00h */ case    8:  		/* li R11, 0 */
		/* 8216BE00h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216BE00h case    8:*/		return 0x8216BE04;
		  /* 8216BE04h */ case    9:  		/* rldicl R10, R3, 0, 32 */
		/* 8216BE04h case    9:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R3);
		/* 8216BE04h case    9:*/		return 0x8216BE08;
		  /* 8216BE08h */ case   10:  		/* rldimi R11, R7, 2, 30 */
		/* 8216BE08h case   10:*/		cpu::op::rldimi<0,2,30>(regs,&regs.R11,regs.R7);
		/* 8216BE08h case   10:*/		return 0x8216BE0C;
		  /* 8216BE0Ch */ case   11:  		/* add R9, R9, R8 */
		/* 8216BE0Ch case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216BE0Ch case   11:*/		return 0x8216BE10;
		  /* 8216BE10h */ case   12:  		/* add R11, R11, R10 */
		/* 8216BE10h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216BE10h case   12:*/		return 0x8216BE14;
		  /* 8216BE14h */ case   13:  		/* cmpld CR6, R11, R9 */
		/* 8216BE14h case   13:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R9);
		/* 8216BE14h case   13:*/		return 0x8216BE18;
		  /* 8216BE18h */ case   14:  		/* bc 12, CR6_GT, -68 */
		/* 8216BE18h case   14:*/		if ( regs.CR[6].gt ) { return 0x8216BDD4;  }
		/* 8216BE18h case   14:*/		return 0x8216BE1C;
		  /* 8216BE1Ch */ case   15:  		/* lwz R11, <#[R4]> */
		/* 8216BE1Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8216BE1Ch case   15:*/		return 0x8216BE20;
		  /* 8216BE20h */ case   16:  		/* li R31, 0 */
		/* 8216BE20h case   16:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8216BE20h case   16:*/		return 0x8216BE24;
		  /* 8216BE24h */ case   17:  		/* lwz R30, <#[R4 + 24]> */
		/* 8216BE24h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000018) );
		/* 8216BE24h case   17:*/		return 0x8216BE28;
		  /* 8216BE28h */ case   18:  		/* li R6, 0 */
		/* 8216BE28h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216BE28h case   18:*/		return 0x8216BE2C;
		  /* 8216BE2Ch */ case   19:  		/* cmplwi CR6, R7, 0 */
		/* 8216BE2Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8216BE2Ch case   19:*/		return 0x8216BE30;
		  /* 8216BE30h */ case   20:  		/* lwz R29, <#[R11 + 32]> */
		/* 8216BE30h case   20:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000020) );
		/* 8216BE30h case   20:*/		return 0x8216BE34;
		  /* 8216BE34h */ case   21:  		/* bc 12, CR6_EQ, 136 */
		/* 8216BE34h case   21:*/		if ( regs.CR[6].eq ) { return 0x8216BEBC;  }
		/* 8216BE34h case   21:*/		return 0x8216BE38;
		  /* 8216BE38h */ case   22:  		/* lwz R8, <#[R3]> */
		/* 8216BE38h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 8216BE38h case   22:*/		return 0x8216BE3C;
		  /* 8216BE3Ch */ case   23:  		/* rlwinm R11, R8, 16, 20, 31 */
		/* 8216BE3Ch case   23:*/		cpu::op::rlwinm<0,16,20,31>(regs,&regs.R11,regs.R8);
		/* 8216BE3Ch case   23:*/		return 0x8216BE40;
		  /* 8216BE40h */ case   24:  		/* cmplw CR6, R11, R29 */
		/* 8216BE40h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8216BE40h case   24:*/		return 0x8216BE44;
		  /* 8216BE44h */ case   25:  		/* bc 12, CR6_GT, -112 */
		/* 8216BE44h case   25:*/		if ( regs.CR[6].gt ) { return 0x8216BDD4;  }
		/* 8216BE44h case   25:*/		return 0x8216BE48;
		  /* 8216BE48h */ case   26:  		/* lis R10, 0 */
		/* 8216BE48h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8216BE48h case   26:*/		return 0x8216BE4C;
		  /* 8216BE4Ch */ case   27:  		/* rlwinm R5, R8, 24, 28, 31 */
		/* 8216BE4Ch case   27:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R5,regs.R8);
		/* 8216BE4Ch case   27:*/		return 0x8216BE50;
		  /* 8216BE50h */ case   28:  		/* ori R10, R10, 32856 */
		/* 8216BE50h case   28:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8058);
		/* 8216BE50h case   28:*/		return 0x8216BE54;
		  /* 8216BE54h */ case   29:  		/* lwzx R10, <#[R4 + R10]> */
		/* 8216BE54h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + regs.R10 + 0x00000000) );
		/* 8216BE54h case   29:*/		return 0x8216BE58;
		  /* 8216BE58h */ case   30:  		/* cmplw CR6, R5, R10 */
		/* 8216BE58h case   30:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 8216BE58h case   30:*/		return 0x8216BE5C;
		  /* 8216BE5Ch */ case   31:  		/* bc 4, CR6_LT, -136 */
		/* 8216BE5Ch case   31:*/		if ( !regs.CR[6].lt ) { return 0x8216BDD4;  }
		/* 8216BE5Ch case   31:*/		return 0x8216BE60;
		  /* 8216BE60h */ case   32:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216BE60h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216BE60h case   32:*/		return 0x8216BE64;
		  /* 8216BE64h */ case   33:  		/* lwz R9, <#[R4 + 4]> */
		/* 8216BE64h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000004) );
		/* 8216BE64h case   33:*/		return 0x8216BE68;
		  /* 8216BE68h */ case   34:  		/* add R11, R11, R30 */
		/* 8216BE68h case   34:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8216BE68h case   34:*/		return 0x8216BE6C;
		  /* 8216BE6Ch */ case   35:  		/* lwz R10, <#[R11]> */
		/* 8216BE6Ch case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216BE6Ch case   35:*/		return 0x8216BE70;
		  /* 8216BE70h */ case   36:  		/* rlwinm R28, R10, 0, 20, 31 */
		/* 8216BE70h case   36:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R28,regs.R10);
		/* 8216BE70h case   36:*/		return 0x8216BE74;
		  /* 8216BE74h */ case   37:  		/* mulli R28, R28, 12 */
		/* 8216BE74h case   37:*/		cpu::op::mulli<0>(regs,&regs.R28,regs.R28,0xC);
		/* 8216BE74h case   37:*/		return 0x8216BE78;
		  /* 8216BE78h */ case   38:  		/* lwzx R28, <#[R28 + R9]> */
		/* 8216BE78h case   38:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + regs.R9 + 0x00000000) );
		/* 8216BE78h case   38:*/		return 0x8216BE7C;
		  /* 8216BE7Ch */ case   39:  		/* rlwinm R28, R28, 0, 26, 31 */
		/* 8216BE7Ch case   39:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R28,regs.R28);
		/* 8216BE7Ch case   39:*/		return 0x8216BE80;
		  /* 8216BE80h */ case   40:  		/* cmplw CR6, R28, R5 */
		/* 8216BE80h case   40:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R5);
		/* 8216BE80h case   40:*/		return 0x8216BE84;
		  /* 8216BE84h */ case   41:  		/* bc 4, CR6_EQ, -176 */
		/* 8216BE84h case   41:*/		if ( !regs.CR[6].eq ) { return 0x8216BDD4;  }
		/* 8216BE84h case   41:*/		return 0x8216BE88;
		  /* 8216BE88h */ case   42:  		/* rlwinm. R10, R10, 0, 19, 19 */
		/* 8216BE88h case   42:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8216BE88h case   42:*/		return 0x8216BE8C;
		  /* 8216BE8Ch */ case   43:  		/* addi R11, R11, 4 */
		/* 8216BE8Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216BE8Ch case   43:*/		return 0x8216BE90;
		  /* 8216BE90h */ case   44:  		/* bc 12, CR0_EQ, -36 */
		/* 8216BE90h case   44:*/		if ( regs.CR[0].eq ) { return 0x8216BE6C;  }
		/* 8216BE90h case   44:*/		return 0x8216BE94;
		  /* 8216BE94h */ case   45:  		/* cmplwi CR6, R6, 0 */
		/* 8216BE94h case   45:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8216BE94h case   45:*/		return 0x8216BE98;
		  /* 8216BE98h */ case   46:  		/* bc 12, CR6_EQ, 16 */
		/* 8216BE98h case   46:*/		if ( regs.CR[6].eq ) { return 0x8216BEA8;  }
		/* 8216BE98h case   46:*/		return 0x8216BE9C;
		  /* 8216BE9Ch */ case   47:  		/* rlwinm R11, R8, 0, 24, 31 */
		/* 8216BE9Ch case   47:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R8);
		/* 8216BE9Ch case   47:*/		return 0x8216BEA0;
		  /* 8216BEA0h */ case   48:  		/* cmplw CR6, R31, R11 */
		/* 8216BEA0h case   48:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8216BEA0h case   48:*/		return 0x8216BEA4;
		  /* 8216BEA4h */ case   49:  		/* bc 4, CR6_LT, -208 */
		/* 8216BEA4h case   49:*/		if ( !regs.CR[6].lt ) { return 0x8216BDD4;  }
		/* 8216BEA4h case   49:*/		return 0x8216BEA8;
	}
	return 0x8216BEA8;
} // Block from 8216BDE0h-8216BEA8h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8216BEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BEA8);
		  /* 8216BEA8h */ case    0:  		/* addi R6, R6, 1 */
		/* 8216BEA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8216BEA8h case    0:*/		return 0x8216BEAC;
		  /* 8216BEACh */ case    1:  		/* rlwinm R31, R8, 0, 24, 31 */
		/* 8216BEACh case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R31,regs.R8);
		/* 8216BEACh case    1:*/		return 0x8216BEB0;
		  /* 8216BEB0h */ case    2:  		/* addi R3, R3, 4 */
		/* 8216BEB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 8216BEB0h case    2:*/		return 0x8216BEB4;
		  /* 8216BEB4h */ case    3:  		/* cmplw CR6, R6, R7 */
		/* 8216BEB4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 8216BEB4h case    3:*/		return 0x8216BEB8;
		  /* 8216BEB8h */ case    4:  		/* bc 12, CR6_LT, -128 */
		/* 8216BEB8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8216BE38;  }
		/* 8216BEB8h case    4:*/		return 0x8216BEBC;
	}
	return 0x8216BEBC;
} // Block from 8216BEA8h-8216BEBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216BEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BEBC);
		  /* 8216BEBCh */ case    0:  		/* li R3, 0 */
		/* 8216BEBCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216BEBCh case    0:*/		return 0x8216BEC0;
	}
	return 0x8216BEC0;
} // Block from 8216BEBCh-8216BEC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216BEC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BEC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BEC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BEC0);
		  /* 8216BEC0h */ case    0:  		/* b -896024 */
		/* 8216BEC0h case    0:*/		return 0x820912A8;
		/* 8216BEC0h case    0:*/		return 0x8216BEC4;
		  /* 8216BEC4h */ case    1:  		/* nop */
		/* 8216BEC4h case    1:*/		cpu::op::nop();
		/* 8216BEC4h case    1:*/		return 0x8216BEC8;
	}
	return 0x8216BEC8;
} // Block from 8216BEC0h-8216BEC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216BEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BEC8);
		  /* 8216BEC8h */ case    0:  		/* mfspr R12, LR */
		/* 8216BEC8h case    0:*/		regs.R12 = regs.LR;
		/* 8216BEC8h case    0:*/		return 0x8216BECC;
		  /* 8216BECCh */ case    1:  		/* bl -896120 */
		/* 8216BECCh case    1:*/		regs.LR = 0x8216BED0; return 0x82091254;
		/* 8216BECCh case    1:*/		return 0x8216BED0;
		  /* 8216BED0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216BED0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216BED0h case    2:*/		return 0x8216BED4;
		  /* 8216BED4h */ case    3:  		/* addis R7, R3, 1 */
		/* 8216BED4h case    3:*/		cpu::op::addis<0>(regs,&regs.R7,regs.R3,0x1);
		/* 8216BED4h case    3:*/		return 0x8216BED8;
		  /* 8216BED8h */ case    4:  		/* lbz R9, <#[R3 + 40]> */
		/* 8216BED8h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000028) );
		/* 8216BED8h case    4:*/		return 0x8216BEDC;
		  /* 8216BEDCh */ case    5:  		/* addis R10, R3, 1 */
		/* 8216BEDCh case    5:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R3,0x1);
		/* 8216BEDCh case    5:*/		return 0x8216BEE0;
		  /* 8216BEE0h */ case    6:  		/* addis R11, R3, 1 */
		/* 8216BEE0h case    6:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216BEE0h case    6:*/		return 0x8216BEE4;
		  /* 8216BEE4h */ case    7:  		/* addis R8, R3, 1 */
		/* 8216BEE4h case    7:*/		cpu::op::addis<0>(regs,&regs.R8,regs.R3,0x1);
		/* 8216BEE4h case    7:*/		return 0x8216BEE8;
		  /* 8216BEE8h */ case    8:  		/* addi R7, R7, -32680 */
		/* 8216BEE8h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFF8058);
		/* 8216BEE8h case    8:*/		return 0x8216BEEC;
		  /* 8216BEECh */ case    9:  		/* addi R10, R10, -32676 */
		/* 8216BEECh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF805C);
		/* 8216BEECh case    9:*/		return 0x8216BEF0;
		  /* 8216BEF0h */ case   10:  		/* addi R11, R11, -32672 */
		/* 8216BEF0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF8060);
		/* 8216BEF0h case   10:*/		return 0x8216BEF4;
		  /* 8216BEF4h */ case   11:  		/* addi R8, R8, -32668 */
		/* 8216BEF4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFF8064);
		/* 8216BEF4h case   11:*/		return 0x8216BEF8;
		  /* 8216BEF8h */ case   12:  		/* li R27, 0 */
		/* 8216BEF8h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8216BEF8h case   12:*/		return 0x8216BEFC;
		  /* 8216BEFCh */ case   13:  		/* mr R30, R3 */
		/* 8216BEFCh case   13:*/		regs.R30 = regs.R3;
		/* 8216BEFCh case   13:*/		return 0x8216BF00;
		  /* 8216BF00h */ case   14:  		/* cmplwi CR0, R9, 0 */
		/* 8216BF00h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 8216BF00h case   14:*/		return 0x8216BF04;
		  /* 8216BF04h */ case   15:  		/* stw R27, <#[R7]> */
		/* 8216BF04h case   15:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R7 + 0x00000000) );
		/* 8216BF04h case   15:*/		return 0x8216BF08;
		  /* 8216BF08h */ case   16:  		/* stw R27, <#[R10]> */
		/* 8216BF08h case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x00000000) );
		/* 8216BF08h case   16:*/		return 0x8216BF0C;
		  /* 8216BF0Ch */ case   17:  		/* stw R27, <#[R11]> */
		/* 8216BF0Ch case   17:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 8216BF0Ch case   17:*/		return 0x8216BF10;
		  /* 8216BF10h */ case   18:  		/* stw R27, <#[R8]> */
		/* 8216BF10h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R8 + 0x00000000) );
		/* 8216BF10h case   18:*/		return 0x8216BF14;
		  /* 8216BF14h */ case   19:  		/* bc 12, CR0_EQ, 52 */
		/* 8216BF14h case   19:*/		if ( regs.CR[0].eq ) { return 0x8216BF48;  }
		/* 8216BF14h case   19:*/		return 0x8216BF18;
		  /* 8216BF18h */ case   20:  		/* lwz R11, <#[R3 + 52]> */
		/* 8216BF18h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 8216BF18h case   20:*/		return 0x8216BF1C;
		  /* 8216BF1Ch */ case   21:  		/* rlwinm R9, R11, 4, 29, 31 */
		/* 8216BF1Ch case   21:*/		cpu::op::rlwinm<0,4,29,31>(regs,&regs.R9,regs.R11);
		/* 8216BF1Ch case   21:*/		return 0x8216BF20;
		  /* 8216BF20h */ case   22:  		/* cmplwi CR6, R9, 5 */
		/* 8216BF20h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000005);
		/* 8216BF20h case   22:*/		return 0x8216BF24;
		  /* 8216BF24h */ case   23:  		/* bc 12, CR6_LT, 20 */
		/* 8216BF24h case   23:*/		if ( regs.CR[6].lt ) { return 0x8216BF38;  }
		/* 8216BF24h case   23:*/		return 0x8216BF28;
		  /* 8216BF28h */ case   24:  		/* lis R3, -32768 */
		/* 8216BF28h case   24:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216BF28h case   24:*/		return 0x8216BF2C;
		  /* 8216BF2Ch */ case   25:  		/* ori R3, R3, 16389 */
		/* 8216BF2Ch case   25:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216BF2Ch case   25:*/		return 0x8216BF30;
		  /* 8216BF30h */ case   26:  		/* addi R1, R1, 128 */
		/* 8216BF30h case   26:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216BF30h case   26:*/		return 0x8216BF34;
		  /* 8216BF34h */ case   27:  		/* b -896144 */
		/* 8216BF34h case   27:*/		return 0x820912A4;
		/* 8216BF34h case   27:*/		return 0x8216BF38;
	}
	return 0x8216BF38;
} // Block from 8216BEC8h-8216BF38h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8216BF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BF38);
		  /* 8216BF38h */ case    0:  		/* rlwinm R11, R11, 5, 31, 31 */
		/* 8216BF38h case    0:*/		cpu::op::rlwinm<0,5,31,31>(regs,&regs.R11,regs.R11);
		/* 8216BF38h case    0:*/		return 0x8216BF3C;
		  /* 8216BF3Ch */ case    1:  		/* stw R9, <#[R7]> */
		/* 8216BF3Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 8216BF3Ch case    1:*/		return 0x8216BF40;
		  /* 8216BF40h */ case    2:  		/* stw R11, <#[R10]> */
		/* 8216BF40h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8216BF40h case    2:*/		return 0x8216BF44;
		  /* 8216BF44h */ case    3:  		/* b 72 */
		/* 8216BF44h case    3:*/		return 0x8216BF8C;
		/* 8216BF44h case    3:*/		return 0x8216BF48;
	}
	return 0x8216BF48;
} // Block from 8216BF38h-8216BF48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216BF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BF48);
		  /* 8216BF48h */ case    0:  		/* lwz R9, <#[R30 + 52]> */
		/* 8216BF48h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000034) );
		/* 8216BF48h case    0:*/		return 0x8216BF4C;
		  /* 8216BF4Ch */ case    1:  		/* li R6, 1 */
		/* 8216BF4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216BF4Ch case    1:*/		return 0x8216BF50;
		  /* 8216BF50h */ case    2:  		/* rlwinm R10, R9, 8, 29, 31 */
		/* 8216BF50h case    2:*/		cpu::op::rlwinm<0,8,29,31>(regs,&regs.R10,regs.R9);
		/* 8216BF50h case    2:*/		return 0x8216BF54;
		  /* 8216BF54h */ case    3:  		/* stw R6, <#[R11]> */
		/* 8216BF54h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216BF54h case    3:*/		return 0x8216BF58;
		  /* 8216BF58h */ case    4:  		/* cmpwi CR6, R10, 2 */
		/* 8216BF58h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 8216BF58h case    4:*/		return 0x8216BF5C;
		  /* 8216BF5Ch */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8216BF5Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216BF68;  }
		/* 8216BF5Ch case    5:*/		return 0x8216BF60;
		  /* 8216BF60h */ case    6:  		/* stw R6, <#[R8]> */
		/* 8216BF60h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 8216BF60h case    6:*/		return 0x8216BF64;
		  /* 8216BF64h */ case    7:  		/* b 12 */
		/* 8216BF64h case    7:*/		return 0x8216BF70;
		/* 8216BF64h case    7:*/		return 0x8216BF68;
	}
	return 0x8216BF68;
} // Block from 8216BF48h-8216BF68h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216BF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BF68);
		  /* 8216BF68h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 8216BF68h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8216BF68h case    0:*/		return 0x8216BF6C;
		  /* 8216BF6Ch */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 8216BF6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216BF28;  }
		/* 8216BF6Ch case    1:*/		return 0x8216BF70;
	}
	return 0x8216BF70;
} // Block from 8216BF68h-8216BF70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216BF70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BF70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BF70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BF70);
		  /* 8216BF70h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8216BF70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8216BF70h case    0:*/		return 0x8216BF74;
		  /* 8216BF74h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8216BF74h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8216BF74h case    1:*/		return 0x8216BF78;
		  /* 8216BF78h */ case    2:  		/* cmplwi CR6, R11, 16 */
		/* 8216BF78h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8216BF78h case    2:*/		return 0x8216BF7C;
		  /* 8216BF7Ch */ case    3:  		/* bc 12, CR6_GT, -84 */
		/* 8216BF7Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x8216BF28;  }
		/* 8216BF7Ch case    3:*/		return 0x8216BF80;
		  /* 8216BF80h */ case    4:  		/* rlwinm R11, R9, 12, 28, 31 */
		/* 8216BF80h case    4:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R11,regs.R9);
		/* 8216BF80h case    4:*/		return 0x8216BF84;
		  /* 8216BF84h */ case    5:  		/* addi R11, R11, 1 */
		/* 8216BF84h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216BF84h case    5:*/		return 0x8216BF88;
		  /* 8216BF88h */ case    6:  		/* stw R11, <#[R7]> */
		/* 8216BF88h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8216BF88h case    6:*/		return 0x8216BF8C;
	}
	return 0x8216BF8C;
} // Block from 8216BF70h-8216BF8Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216BF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216BF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216BF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216BF8C);
		  /* 8216BF8Ch */ case    0:  		/* lis R3, 16 */
		/* 8216BF8Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0x10);
		/* 8216BF8Ch case    0:*/		return 0x8216BF90;
		  /* 8216BF90h */ case    1:  		/* lis R4, 9351 */
		/* 8216BF90h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2487);
		/* 8216BF90h case    1:*/		return 0x8216BF94;
		  /* 8216BF94h */ case    2:  		/* ori R3, R3, 12 */
		/* 8216BF94h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xC);
		/* 8216BF94h case    2:*/		return 0x8216BF98;
		  /* 8216BF98h */ case    3:  		/* bl -933272 */
		/* 8216BF98h case    3:*/		regs.LR = 0x8216BF9C; return 0x82088200;
		/* 8216BF98h case    3:*/		return 0x8216BF9C;
		  /* 8216BF9Ch */ case    4:  		/* or. R31, R3, R3 */
		/* 8216BF9Ch case    4:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8216BF9Ch case    4:*/		return 0x8216BFA0;
		  /* 8216BFA0h */ case    5:  		/* bc 12, CR0_EQ, -120 */
		/* 8216BFA0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216BF28;  }
		/* 8216BFA0h case    5:*/		return 0x8216BFA4;
		  /* 8216BFA4h */ case    6:  		/* addi R3, R31, 12 */
		/* 8216BFA4h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC);
		/* 8216BFA4h case    6:*/		return 0x8216BFA8;
		  /* 8216BFA8h */ case    7:  		/* stw R27, <#[R31]> */
		/* 8216BFA8h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 8216BFA8h case    7:*/		return 0x8216BFAC;
		  /* 8216BFACh */ case    8:  		/* lis R5, 16 */
		/* 8216BFACh case    8:*/		cpu::op::lis<0>(regs,&regs.R5,0x10);
		/* 8216BFACh case    8:*/		return 0x8216BFB0;
		  /* 8216BFB0h */ case    9:  		/* stw R27, <#[R31 + 4]> */
		/* 8216BFB0h case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000004) );
		/* 8216BFB0h case    9:*/		return 0x8216BFB4;
		  /* 8216BFB4h */ case   10:  		/* li R4, 0 */
		/* 8216BFB4h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216BFB4h case   10:*/		return 0x8216BFB8;
		  /* 8216BFB8h */ case   11:  		/* stw R27, <#[R31 + 8]> */
		/* 8216BFB8h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000008) );
		/* 8216BFB8h case   11:*/		return 0x8216BFBC;
		  /* 8216BFBCh */ case   12:  		/* bl -896124 */
		/* 8216BFBCh case   12:*/		regs.LR = 0x8216BFC0; return 0x82091340;
		/* 8216BFBCh case   12:*/		return 0x8216BFC0;
		  /* 8216BFC0h */ case   13:  		/* lwz R10, <#[R31 + 12]> */
		/* 8216BFC0h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216BFC0h case   13:*/		return 0x8216BFC4;
		  /* 8216BFC4h */ case   14:  		/* addic. R11, R31, 16 */
		/* 8216BFC4h case   14:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R31,0x10);
		/* 8216BFC4h case   14:*/		return 0x8216BFC8;
		  /* 8216BFC8h */ case   15:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 8216BFC8h case   15:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 8216BFC8h case   15:*/		return 0x8216BFCC;
		  /* 8216BFCCh */ case   16:  		/* stw R10, <#[R31 + 12]> */
		/* 8216BFCCh case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216BFCCh case   16:*/		return 0x8216BFD0;
		  /* 8216BFD0h */ case   17:  		/* bc 12, CR0_EQ, -168 */
		/* 8216BFD0h case   17:*/		if ( regs.CR[0].eq ) { return 0x8216BF28;  }
		/* 8216BFD0h case   17:*/		return 0x8216BFD4;
		  /* 8216BFD4h */ case   18:  		/* li R10, 9 */
		/* 8216BFD4h case   18:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 8216BFD4h case   18:*/		return 0x8216BFD8;
		  /* 8216BFD8h */ case   19:  		/* addi R9, R11, -1 */
		/* 8216BFD8h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 8216BFD8h case   19:*/		return 0x8216BFDC;
		  /* 8216BFDCh */ case   20:  		/* mr R8, R27 */
		/* 8216BFDCh case   20:*/		regs.R8 = regs.R27;
		/* 8216BFDCh case   20:*/		return 0x8216BFE0;
		  /* 8216BFE0h */ case   21:  		/* mtspr CTR, R10 */
		/* 8216BFE0h case   21:*/		regs.CTR = regs.R10;
		/* 8216BFE0h case   21:*/		return 0x8216BFE4;
		  /* 8216BFE4h */ case   22:  		/* stbu R8, <#[R9 + 1]> */
		/* 8216BFE4h case   22:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 8216BFE4h case   22:*/		return 0x8216BFE8;
		  /* 8216BFE8h */ case   23:  		/* bc 16, CR0_LT, -4 */
		/* 8216BFE8h case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8216BFE4;  }
		/* 8216BFE8h case   23:*/		return 0x8216BFEC;
		  /* 8216BFECh */ case   24:  		/* li R10, 34 */
		/* 8216BFECh case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x22);
		/* 8216BFECh case   24:*/		return 0x8216BFF0;
		  /* 8216BFF0h */ case   25:  		/* addi R28, R30, 84 */
		/* 8216BFF0h case   25:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x54);
		/* 8216BFF0h case   25:*/		return 0x8216BFF4;
		  /* 8216BFF4h */ case   26:  		/* stb R10, <#[R11]> */
		/* 8216BFF4h case   26:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216BFF4h case   26:*/		return 0x8216BFF8;
		  /* 8216BFF8h */ case   27:  		/* lis R29, 1 */
		/* 8216BFF8h case   27:*/		cpu::op::lis<0>(regs,&regs.R29,0x1);
		/* 8216BFF8h case   27:*/		return 0x8216BFFC;
		  /* 8216BFFCh */ case   28:  		/* mr R6, R30 */
		/* 8216BFFCh case   28:*/		regs.R6 = regs.R30;
		/* 8216BFFCh case   28:*/		return 0x8216C000;
		  /* 8216C000h */ case   29:  		/* lwz R3, <#[R30 + 4]> */
		/* 8216C000h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 8216C000h case   29:*/		return 0x8216C004;
		  /* 8216C004h */ case   30:  		/* mr R5, R28 */
		/* 8216C004h case   30:*/		regs.R5 = regs.R28;
		/* 8216C004h case   30:*/		return 0x8216C008;
		  /* 8216C008h */ case   31:  		/* mr R4, R31 */
		/* 8216C008h case   31:*/		regs.R4 = regs.R31;
		/* 8216C008h case   31:*/		return 0x8216C00C;
		  /* 8216C00Ch */ case   32:  		/* bl -4212 */
		/* 8216C00Ch case   32:*/		regs.LR = 0x8216C010; return 0x8216AF98;
		/* 8216C00Ch case   32:*/		return 0x8216C010;
		  /* 8216C010h */ case   33:  		/* cmpwi CR0, R3, 0 */
		/* 8216C010h case   33:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C010h case   33:*/		return 0x8216C014;
		  /* 8216C014h */ case   34:  		/* bc 12, CR0_LT, 68 */
		/* 8216C014h case   34:*/		if ( regs.CR[0].lt ) { return 0x8216C058;  }
		/* 8216C014h case   34:*/		return 0x8216C018;
		  /* 8216C018h */ case   35:  		/* lwz R11, <#[R31]> */
		/* 8216C018h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216C018h case   35:*/		return 0x8216C01C;
		  /* 8216C01Ch */ case   36:  		/* addi R11, R11, 1 */
		/* 8216C01Ch case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216C01Ch case   36:*/		return 0x8216C020;
		  /* 8216C020h */ case   37:  		/* stw R11, <#[R31]> */
		/* 8216C020h case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216C020h case   37:*/		return 0x8216C024;
		  /* 8216C024h */ case   38:  		/* cmplw CR6, R11, R29 */
		/* 8216C024h case   38:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8216C024h case   38:*/		return 0x8216C028;
		  /* 8216C028h */ case   39:  		/* bc 4, CR6_LT, 48 */
		/* 8216C028h case   39:*/		if ( !regs.CR[6].lt ) { return 0x8216C058;  }
		/* 8216C028h case   39:*/		return 0x8216C02C;
		  /* 8216C02Ch */ case   40:  		/* lwz R10, <#[R31 + 4]> */
		/* 8216C02Ch case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8216C02Ch case   40:*/		return 0x8216C030;
		  /* 8216C030h */ case   41:  		/* cmplw CR6, R10, R29 */
		/* 8216C030h case   41:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8216C030h case   41:*/		return 0x8216C034;
		  /* 8216C034h */ case   42:  		/* bc 4, CR6_LT, 36 */
		/* 8216C034h case   42:*/		if ( !regs.CR[6].lt ) { return 0x8216C058;  }
		/* 8216C034h case   42:*/		return 0x8216C038;
		  /* 8216C038h */ case   43:  		/* cmplw CR6, R11, R10 */
		/* 8216C038h case   43:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216C038h case   43:*/		return 0x8216C03C;
		  /* 8216C03Ch */ case   44:  		/* bc 4, CR6_GT, -64 */
		/* 8216C03Ch case   44:*/		if ( !regs.CR[6].gt ) { return 0x8216BFFC;  }
		/* 8216C03Ch case   44:*/		return 0x8216C040;
		  /* 8216C040h */ case   45:  		/* addi R10, R10, 1 */
		/* 8216C040h case   45:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216C040h case   45:*/		return 0x8216C044;
		  /* 8216C044h */ case   46:  		/* cmplw CR6, R11, R10 */
		/* 8216C044h case   46:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216C044h case   46:*/		return 0x8216C048;
		  /* 8216C048h */ case   47:  		/* bc 4, CR6_EQ, 16 */
		/* 8216C048h case   47:*/		if ( !regs.CR[6].eq ) { return 0x8216C058;  }
		/* 8216C048h case   47:*/		return 0x8216C04C;
		  /* 8216C04Ch */ case   48:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216C04Ch case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216C04Ch case   48:*/		return 0x8216C050;
		  /* 8216C050h */ case   49:  		/* cmpwi CR6, R11, 0 */
		/* 8216C050h case   49:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216C050h case   49:*/		return 0x8216C054;
		  /* 8216C054h */ case   50:  		/* bc 4, CR6_EQ, 32 */
		/* 8216C054h case   50:*/		if ( !regs.CR[6].eq ) { return 0x8216C074;  }
		/* 8216C054h case   50:*/		return 0x8216C058;
	}
	return 0x8216C058;
} // Block from 8216BF8Ch-8216C058h (51 instructions)

//////////////////////////////////////////////////////
// Block at 8216C058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C058);
		  /* 8216C058h */ case    0:  		/* lis R30, -32768 */
		/* 8216C058h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8000);
		/* 8216C058h case    0:*/		return 0x8216C05C;
		  /* 8216C05Ch */ case    1:  		/* ori R30, R30, 16389 */
		/* 8216C05Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x4005);
		/* 8216C05Ch case    1:*/		return 0x8216C060;
		  /* 8216C060h */ case    2:  		/* lis R4, 9351 */
		/* 8216C060h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2487);
		/* 8216C060h case    2:*/		return 0x8216C064;
		  /* 8216C064h */ case    3:  		/* mr R3, R31 */
		/* 8216C064h case    3:*/		regs.R3 = regs.R31;
		/* 8216C064h case    3:*/		return 0x8216C068;
		  /* 8216C068h */ case    4:  		/* bl -933168 */
		/* 8216C068h case    4:*/		regs.LR = 0x8216C06C; return 0x82088338;
		/* 8216C068h case    4:*/		return 0x8216C06C;
		  /* 8216C06Ch */ case    5:  		/* mr R3, R30 */
		/* 8216C06Ch case    5:*/		regs.R3 = regs.R30;
		/* 8216C06Ch case    5:*/		return 0x8216C070;
		  /* 8216C070h */ case    6:  		/* b -320 */
		/* 8216C070h case    6:*/		return 0x8216BF30;
		/* 8216C070h case    6:*/		return 0x8216C074;
	}
	return 0x8216C074;
} // Block from 8216C058h-8216C074h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216C074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C074);
		  /* 8216C074h */ case    0:  		/* mr R30, R27 */
		/* 8216C074h case    0:*/		regs.R30 = regs.R27;
		/* 8216C074h case    0:*/		return 0x8216C078;
		  /* 8216C078h */ case    1:  		/* b -24 */
		/* 8216C078h case    1:*/		return 0x8216C060;
		/* 8216C078h case    1:*/		return 0x8216C07C;
		  /* 8216C07Ch */ case    2:  		/* nop */
		/* 8216C07Ch case    2:*/		cpu::op::nop();
		/* 8216C07Ch case    2:*/		return 0x8216C080;
	}
	return 0x8216C080;
} // Block from 8216C074h-8216C080h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216C080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C080);
		  /* 8216C080h */ case    0:  		/* mfspr R12, LR */
		/* 8216C080h case    0:*/		regs.R12 = regs.LR;
		/* 8216C080h case    0:*/		return 0x8216C084;
		  /* 8216C084h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216C084h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216C084h case    1:*/		return 0x8216C088;
		  /* 8216C088h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8216C088h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216C088h case    2:*/		return 0x8216C08C;
		  /* 8216C08Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8216C08Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216C08Ch case    3:*/		return 0x8216C090;
		  /* 8216C090h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216C090h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216C090h case    4:*/		return 0x8216C094;
		  /* 8216C094h */ case    5:  		/* lwz R11, <#[R3 + 80]> */
		/* 8216C094h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 8216C094h case    5:*/		return 0x8216C098;
		  /* 8216C098h */ case    6:  		/* lis R10, 10 */
		/* 8216C098h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xA);
		/* 8216C098h case    6:*/		return 0x8216C09C;
		  /* 8216C09Ch */ case    7:  		/* lwz R30, <#[R3 + 72]> */
		/* 8216C09Ch case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000048) );
		/* 8216C09Ch case    7:*/		return 0x8216C0A0;
		  /* 8216C0A0h */ case    8:  		/* mr R31, R3 */
		/* 8216C0A0h case    8:*/		regs.R31 = regs.R3;
		/* 8216C0A0h case    8:*/		return 0x8216C0A4;
		  /* 8216C0A4h */ case    9:  		/* ori R10, R10, 53768 */
		/* 8216C0A4h case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xD208);
		/* 8216C0A4h case    9:*/		return 0x8216C0A8;
		  /* 8216C0A8h */ case   10:  		/* add R11, R11, R30 */
		/* 8216C0A8h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8216C0A8h case   10:*/		return 0x8216C0AC;
		  /* 8216C0ACh */ case   11:  		/* cmpld CR6, R11, R10 */
		/* 8216C0ACh case   11:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R10);
		/* 8216C0ACh case   11:*/		return 0x8216C0B0;
		  /* 8216C0B0h */ case   12:  		/* bc 4, CR6_GT, 16 */
		/* 8216C0B0h case   12:*/		if ( !regs.CR[6].gt ) { return 0x8216C0C0;  }
		/* 8216C0B0h case   12:*/		return 0x8216C0B4;
		  /* 8216C0B4h */ case   13:  		/* lis R3, -32768 */
		/* 8216C0B4h case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216C0B4h case   13:*/		return 0x8216C0B8;
		  /* 8216C0B8h */ case   14:  		/* ori R3, R3, 16389 */
		/* 8216C0B8h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216C0B8h case   14:*/		return 0x8216C0BC;
		  /* 8216C0BCh */ case   15:  		/* b 484 */
		/* 8216C0BCh case   15:*/		return 0x8216C2A0;
		/* 8216C0BCh case   15:*/		return 0x8216C0C0;
	}
	return 0x8216C0C0;
} // Block from 8216C080h-8216C0C0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216C0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C0C0);
		  /* 8216C0C0h */ case    0:  		/* mr R4, R31 */
		/* 8216C0C0h case    0:*/		regs.R4 = regs.R31;
		/* 8216C0C0h case    0:*/		return 0x8216C0C4;
		  /* 8216C0C4h */ case    1:  		/* lwz R3, <#[R31 + 44]> */
		/* 8216C0C4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8216C0C4h case    1:*/		return 0x8216C0C8;
		  /* 8216C0C8h */ case    2:  		/* bl -1888 */
		/* 8216C0C8h case    2:*/		regs.LR = 0x8216C0CC; return 0x8216B968;
		/* 8216C0C8h case    2:*/		return 0x8216C0CC;
		  /* 8216C0CCh */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 8216C0CCh case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C0CCh case    3:*/		return 0x8216C0D0;
		  /* 8216C0D0h */ case    4:  		/* bc 12, CR0_LT, 464 */
		/* 8216C0D0h case    4:*/		if ( regs.CR[0].lt ) { return 0x8216C2A0;  }
		/* 8216C0D0h case    4:*/		return 0x8216C0D4;
		  /* 8216C0D4h */ case    5:  		/* mr R4, R31 */
		/* 8216C0D4h case    5:*/		regs.R4 = regs.R31;
		/* 8216C0D4h case    5:*/		return 0x8216C0D8;
		  /* 8216C0D8h */ case    6:  		/* lwz R3, <#[R31 + 8]> */
		/* 8216C0D8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8216C0D8h case    6:*/		return 0x8216C0DC;
		  /* 8216C0DCh */ case    7:  		/* bl -1644 */
		/* 8216C0DCh case    7:*/		regs.LR = 0x8216C0E0; return 0x8216BA70;
		/* 8216C0DCh case    7:*/		return 0x8216C0E0;
		  /* 8216C0E0h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 8216C0E0h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C0E0h case    8:*/		return 0x8216C0E4;
		  /* 8216C0E4h */ case    9:  		/* bc 12, CR0_LT, 444 */
		/* 8216C0E4h case    9:*/		if ( regs.CR[0].lt ) { return 0x8216C2A0;  }
		/* 8216C0E4h case    9:*/		return 0x8216C0E8;
		  /* 8216C0E8h */ case   10:  		/* lwz R10, <#[R31 + 48]> */
		/* 8216C0E8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8216C0E8h case   10:*/		return 0x8216C0EC;
		  /* 8216C0ECh */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 8216C0ECh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216C0ECh case   11:*/		return 0x8216C0F0;
		  /* 8216C0F0h */ case   12:  		/* bc 12, CR6_EQ, 96 */
		/* 8216C0F0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8216C150;  }
		/* 8216C0F0h case   12:*/		return 0x8216C0F4;
		  /* 8216C0F4h */ case   13:  		/* lwz R11, <#[R31 + 68]> */
		/* 8216C0F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 8216C0F4h case   13:*/		return 0x8216C0F8;
		  /* 8216C0F8h */ case   14:  		/* cmplw CR6, R10, R11 */
		/* 8216C0F8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216C0F8h case   14:*/		return 0x8216C0FC;
		  /* 8216C0FCh */ case   15:  		/* bc 12, CR6_LT, -72 */
		/* 8216C0FCh case   15:*/		if ( regs.CR[6].lt ) { return 0x8216C0B4;  }
		/* 8216C0FCh case   15:*/		return 0x8216C100;
		  /* 8216C100h */ case   16:  		/* rldicl R9, R10, 0, 32 */
		/* 8216C100h case   16:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R10);
		/* 8216C100h case   16:*/		return 0x8216C104;
		  /* 8216C104h */ case   17:  		/* rldicl R8, R11, 0, 32 */
		/* 8216C104h case   17:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R11);
		/* 8216C104h case   17:*/		return 0x8216C108;
		  /* 8216C108h */ case   18:  		/* addi R7, R9, 8 */
		/* 8216C108h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R9,0x8);
		/* 8216C108h case   18:*/		return 0x8216C10C;
		  /* 8216C10Ch */ case   19:  		/* add R8, R8, R30 */
		/* 8216C10Ch case   19:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R30);
		/* 8216C10Ch case   19:*/		return 0x8216C110;
		  /* 8216C110h */ case   20:  		/* cmpld CR6, R7, R8 */
		/* 8216C110h case   20:*/		cpu::op::cmpld<6>(regs,regs.R7,regs.R8);
		/* 8216C110h case   20:*/		return 0x8216C114;
		  /* 8216C114h */ case   21:  		/* bc 12, CR6_GT, -96 */
		/* 8216C114h case   21:*/		if ( regs.CR[6].gt ) { return 0x8216C0B4;  }
		/* 8216C114h case   21:*/		return 0x8216C118;
		  /* 8216C118h */ case   22:  		/* lwz R8, <#[R10 + 4]> */
		/* 8216C118h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C118h case   22:*/		return 0x8216C11C;
		  /* 8216C11Ch */ case   23:  		/* cmplwi CR6, R8, 260 */
		/* 8216C11Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000104);
		/* 8216C11Ch case   23:*/		return 0x8216C120;
		  /* 8216C120h */ case   24:  		/* bc 4, CR6_LT, -108 */
		/* 8216C120h case   24:*/		if ( !regs.CR[6].lt ) { return 0x8216C0B4;  }
		/* 8216C120h case   24:*/		return 0x8216C124;
		  /* 8216C124h */ case   25:  		/* cmplw CR6, R10, R11 */
		/* 8216C124h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216C124h case   25:*/		return 0x8216C128;
		  /* 8216C128h */ case   26:  		/* bc 12, CR6_LT, -116 */
		/* 8216C128h case   26:*/		if ( regs.CR[6].lt ) { return 0x8216C0B4;  }
		/* 8216C128h case   26:*/		return 0x8216C12C;
		  /* 8216C12Ch */ case   27:  		/* addi R8, R8, 3 */
		/* 8216C12Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x3);
		/* 8216C12Ch case   27:*/		return 0x8216C130;
		  /* 8216C130h */ case   28:  		/* rldicl R10, R11, 0, 32 */
		/* 8216C130h case   28:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R11);
		/* 8216C130h case   28:*/		return 0x8216C134;
		  /* 8216C134h */ case   29:  		/* rlwinm R11, R8, 0, 0, 29 */
		/* 8216C134h case   29:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R8);
		/* 8216C134h case   29:*/		return 0x8216C138;
		  /* 8216C138h */ case   30:  		/* add R10, R10, R30 */
		/* 8216C138h case   30:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 8216C138h case   30:*/		return 0x8216C13C;
		  /* 8216C13Ch */ case   31:  		/* addi R11, R11, 8 */
		/* 8216C13Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8216C13Ch case   31:*/		return 0x8216C140;
	}
	return 0x8216C140;
} // Block from 8216C0C0h-8216C140h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8216C140h
// Function '?ValidateString@@YAJPBXKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C140);
		  /* 8216C140h */ case    0:  		/* rldicl R11, R11, 0, 32 */
		/* 8216C140h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 8216C140h case    0:*/		return 0x8216C144;
		  /* 8216C144h */ case    1:  		/* add R11, R11, R9 */
		/* 8216C144h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216C144h case    1:*/		return 0x8216C148;
		  /* 8216C148h */ case    2:  		/* cmpld CR6, R11, R10 */
		/* 8216C148h case    2:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R10);
		/* 8216C148h case    2:*/		return 0x8216C14C;
		  /* 8216C14Ch */ case    3:  		/* bc 12, CR6_GT, -152 */
		/* 8216C14Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x8216C0B4;  }
		/* 8216C14Ch case    3:*/		return 0x8216C150;
	}
	return 0x8216C150;
} // Block from 8216C140h-8216C150h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216C150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C150);
		  /* 8216C150h */ case    0:  		/* mr R3, R31 */
		/* 8216C150h case    0:*/		regs.R3 = regs.R31;
		/* 8216C150h case    0:*/		return 0x8216C154;
		  /* 8216C154h */ case    1:  		/* bl -652 */
		/* 8216C154h case    1:*/		regs.LR = 0x8216C158; return 0x8216BEC8;
		/* 8216C154h case    1:*/		return 0x8216C158;
		  /* 8216C158h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8216C158h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C158h case    2:*/		return 0x8216C15C;
		  /* 8216C15Ch */ case    3:  		/* bc 12, CR0_LT, 324 */
		/* 8216C15Ch case    3:*/		if ( regs.CR[0].lt ) { return 0x8216C2A0;  }
		/* 8216C15Ch case    3:*/		return 0x8216C160;
		  /* 8216C160h */ case    4:  		/* lbz R11, <#[R31 + 40]> */
		/* 8216C160h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8216C160h case    4:*/		return 0x8216C164;
		  /* 8216C164h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8216C164h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216C164h case    5:*/		return 0x8216C168;
		  /* 8216C168h */ case    6:  		/* bc 12, CR0_EQ, 140 */
		/* 8216C168h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216C1F4;  }
		/* 8216C168h case    6:*/		return 0x8216C16C;
		  /* 8216C16Ch */ case    7:  		/* lwz R11, <#[R31 + 28]> */
		/* 8216C16Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8216C16Ch case    7:*/		return 0x8216C170;
		  /* 8216C170h */ case    8:  		/* lwz R10, <#[R31 + 12]> */
		/* 8216C170h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216C170h case    8:*/		return 0x8216C174;
		  /* 8216C174h */ case    9:  		/* rlwinm. R9, R11, 0, 14, 14 */
		/* 8216C174h case    9:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R9,regs.R11);
		/* 8216C174h case    9:*/		return 0x8216C178;
		  /* 8216C178h */ case   10:  		/* bc 4, CR0_EQ, -196 */
		/* 8216C178h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216C0B4;  }
		/* 8216C178h case   10:*/		return 0x8216C17C;
		  /* 8216C17Ch */ case   11:  		/* rlwinm. R9, R11, 0, 13, 13 */
		/* 8216C17Ch case   11:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R9,regs.R11);
		/* 8216C17Ch case   11:*/		return 0x8216C180;
		  /* 8216C180h */ case   12:  		/* bc 4, CR0_EQ, -204 */
		/* 8216C180h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8216C0B4;  }
		/* 8216C180h case   12:*/		return 0x8216C184;
		  /* 8216C184h */ case   13:  		/* lwz R9, <#[R31 + 68]> */
		/* 8216C184h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000044) );
		/* 8216C184h case   13:*/		return 0x8216C188;
		  /* 8216C188h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 8216C188h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8216C188h case   14:*/		return 0x8216C18C;
		  /* 8216C18Ch */ case   15:  		/* bc 12, CR6_LT, -216 */
		/* 8216C18Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x8216C0B4;  }
		/* 8216C18Ch case   15:*/		return 0x8216C190;
		  /* 8216C190h */ case   16:  		/* rldicl R7, R11, 61, 57 */
		/* 8216C190h case   16:*/		cpu::op::rldicl<0,61,57>(regs,&regs.R7,regs.R11);
		/* 8216C190h case   16:*/		return 0x8216C194;
		  /* 8216C194h */ case   17:  		/* lwz R8, <#[R31 + 72]> */
		/* 8216C194h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000048) );
		/* 8216C194h case   17:*/		return 0x8216C198;
	}
	return 0x8216C198;
} // Block from 8216C150h-8216C198h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8216C198h
// Function '?ValidateTypeInfo@@YAJPBU_D3DXSHADER_TYPEINFO@@PBU_D3DXSHADER_CONSTANTTABLE@@KPAU_PREV_TYPE_INFO@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C198);
		  /* 8216C198h */ case    0:  		/* rldicl R6, R10, 0, 32 */
		/* 8216C198h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R6,regs.R10);
		/* 8216C198h case    0:*/		return 0x8216C19C;
		  /* 8216C19Ch */ case    1:  		/* rldicr R7, R7, 0, 61 */
		/* 8216C19Ch case    1:*/		cpu::op::rldicr<0,0,61>(regs,&regs.R7,regs.R7);
		/* 8216C19Ch case    1:*/		return 0x8216C1A0;
		  /* 8216C1A0h */ case    2:  		/* rldicl R9, R9, 0, 32 */
		/* 8216C1A0h case    2:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 8216C1A0h case    2:*/		return 0x8216C1A4;
		  /* 8216C1A4h */ case    3:  		/* add R7, R7, R6 */
		/* 8216C1A4h case    3:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 8216C1A4h case    3:*/		return 0x8216C1A8;
		  /* 8216C1A8h */ case    4:  		/* add R9, R9, R8 */
		/* 8216C1A8h case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216C1A8h case    4:*/		return 0x8216C1AC;
		  /* 8216C1ACh */ case    5:  		/* cmpld CR6, R7, R9 */
		/* 8216C1ACh case    5:*/		cpu::op::cmpld<6>(regs,regs.R7,regs.R9);
		/* 8216C1ACh case    5:*/		return 0x8216C1B0;
		  /* 8216C1B0h */ case    6:  		/* bc 12, CR6_GT, -252 */
		/* 8216C1B0h case    6:*/		if ( regs.CR[6].gt ) { return 0x8216C0B4;  }
		/* 8216C1B0h case    6:*/		return 0x8216C1B4;
		  /* 8216C1B4h */ case    7:  		/* rlwinm. R8, R11, 27, 27, 31 */
		/* 8216C1B4h case    7:*/		cpu::op::rlwinm<1,27,27,31>(regs,&regs.R8,regs.R11);
		/* 8216C1B4h case    7:*/		return 0x8216C1B8;
		  /* 8216C1B8h */ case    8:  		/* li R7, 0 */
		/* 8216C1B8h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216C1B8h case    8:*/		return 0x8216C1BC;
		  /* 8216C1BCh */ case    9:  		/* li R11, 0 */
		/* 8216C1BCh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216C1BCh case    9:*/		return 0x8216C1C0;
		  /* 8216C1C0h */ case   10:  		/* bc 12, CR0_EQ, 160 */
		/* 8216C1C0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8216C260;  }
		/* 8216C1C0h case   10:*/		return 0x8216C1C4;
		  /* 8216C1C4h */ case   11:  		/* lwz R9, <#[R10]> */
		/* 8216C1C4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216C1C4h case   11:*/		return 0x8216C1C8;
		  /* 8216C1C8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8216C1C8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216C1C8h case   12:*/		return 0x8216C1CC;
		  /* 8216C1CCh */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 8216C1CCh case   13:*/		if ( regs.CR[6].eq ) { return 0x8216C1DC;  }
		/* 8216C1CCh case   13:*/		return 0x8216C1D0;
		  /* 8216C1D0h */ case   14:  		/* rlwinm R6, R9, 0, 24, 31 */
		/* 8216C1D0h case   14:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R6,regs.R9);
		/* 8216C1D0h case   14:*/		return 0x8216C1D4;
		  /* 8216C1D4h */ case   15:  		/* cmplw CR6, R7, R6 */
		/* 8216C1D4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8216C1D4h case   15:*/		return 0x8216C1D8;
		  /* 8216C1D8h */ case   16:  		/* bc 4, CR6_LT, -292 */
		/* 8216C1D8h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8216C0B4;  }
		/* 8216C1D8h case   16:*/		return 0x8216C1DC;
	}
	return 0x8216C1DC;
} // Block from 8216C198h-8216C1DCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216C1DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C1DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C1DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C1DC);
		  /* 8216C1DCh */ case    0:  		/* addi R11, R11, 1 */
		/* 8216C1DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216C1DCh case    0:*/		return 0x8216C1E0;
		  /* 8216C1E0h */ case    1:  		/* rlwinm R7, R9, 0, 24, 31 */
		/* 8216C1E0h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R7,regs.R9);
		/* 8216C1E0h case    1:*/		return 0x8216C1E4;
		  /* 8216C1E4h */ case    2:  		/* addi R10, R10, 4 */
		/* 8216C1E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C1E4h case    2:*/		return 0x8216C1E8;
		  /* 8216C1E8h */ case    3:  		/* cmplw CR6, R11, R8 */
		/* 8216C1E8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8216C1E8h case    3:*/		return 0x8216C1EC;
		  /* 8216C1ECh */ case    4:  		/* bc 12, CR6_LT, -40 */
		/* 8216C1ECh case    4:*/		if ( regs.CR[6].lt ) { return 0x8216C1C4;  }
		/* 8216C1ECh case    4:*/		return 0x8216C1F0;
		  /* 8216C1F0h */ case    5:  		/* b 112 */
		/* 8216C1F0h case    5:*/		return 0x8216C260;
		/* 8216C1F0h case    5:*/		return 0x8216C1F4;
	}
	return 0x8216C1F4;
} // Block from 8216C1DCh-8216C1F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216C1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C1F4);
		  /* 8216C1F4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8216C1F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216C1F4h case    0:*/		return 0x8216C1F8;
		  /* 8216C1F8h */ case    1:  		/* lwz R8, <#[R31 + 68]> */
		/* 8216C1F8h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000044) );
		/* 8216C1F8h case    1:*/		return 0x8216C1FC;
		  /* 8216C1FCh */ case    2:  		/* cmplw CR6, R11, R8 */
		/* 8216C1FCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8216C1FCh case    2:*/		return 0x8216C200;
		  /* 8216C200h */ case    3:  		/* bc 12, CR6_LT, -332 */
		/* 8216C200h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216C0B4;  }
		/* 8216C200h case    3:*/		return 0x8216C204;
		  /* 8216C204h */ case    4:  		/* lwz R7, <#[R31]> */
		/* 8216C204h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 8216C204h case    4:*/		return 0x8216C208;
		  /* 8216C208h */ case    5:  		/* rldicl R10, R11, 0, 32 */
		/* 8216C208h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R11);
		/* 8216C208h case    5:*/		return 0x8216C20C;
		  /* 8216C20Ch */ case    6:  		/* lwz R9, <#[R31 + 72]> */
		/* 8216C20Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000048) );
		/* 8216C20Ch case    6:*/		return 0x8216C210;
		  /* 8216C210h */ case    7:  		/* rldicl R11, R8, 0, 32 */
		/* 8216C210h case    7:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R8);
		/* 8216C210h case    7:*/		return 0x8216C214;
		  /* 8216C214h */ case    8:  		/* add R9, R11, R9 */
		/* 8216C214h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8216C214h case    8:*/		return 0x8216C218;
		  /* 8216C218h */ case    9:  		/* lwz R11, <#[R7 + 24]> */
		/* 8216C218h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000018) );
		/* 8216C218h case    9:*/		return 0x8216C21C;
		  /* 8216C21Ch */ case   10:  		/* rldicr R11, R11, 2, 63 */
		/* 8216C21Ch case   10:*/		cpu::op::rldicr<0,2,63>(regs,&regs.R11,regs.R11);
		/* 8216C21Ch case   10:*/		return 0x8216C220;
		  /* 8216C220h */ case   11:  		/* add R11, R11, R10 */
		/* 8216C220h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216C220h case   11:*/		return 0x8216C224;
		  /* 8216C224h */ case   12:  		/* cmpld CR6, R11, R9 */
		/* 8216C224h case   12:*/		cpu::op::cmpld<6>(regs,regs.R11,regs.R9);
		/* 8216C224h case   12:*/		return 0x8216C228;
		  /* 8216C228h */ case   13:  		/* bc 12, CR6_GT, -372 */
		/* 8216C228h case   13:*/		if ( regs.CR[6].gt ) { return 0x8216C0B4;  }
		/* 8216C228h case   13:*/		return 0x8216C22C;
		  /* 8216C22Ch */ case   14:  		/* mr R4, R31 */
		/* 8216C22Ch case   14:*/		regs.R4 = regs.R31;
		/* 8216C22Ch case   14:*/		return 0x8216C230;
		  /* 8216C230h */ case   15:  		/* lwz R3, <#[R31 + 16]> */
		/* 8216C230h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8216C230h case   15:*/		return 0x8216C234;
		  /* 8216C234h */ case   16:  		/* bl -1612 */
		/* 8216C234h case   16:*/		regs.LR = 0x8216C238; return 0x8216BBE8;
		/* 8216C234h case   16:*/		return 0x8216C238;
		  /* 8216C238h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 8216C238h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C238h case   17:*/		return 0x8216C23C;
		  /* 8216C23Ch */ case   18:  		/* bc 12, CR0_LT, 100 */
		/* 8216C23Ch case   18:*/		if ( regs.CR[0].lt ) { return 0x8216C2A0;  }
		/* 8216C23Ch case   18:*/		return 0x8216C240;
		  /* 8216C240h */ case   19:  		/* lwz R3, <#[R31 + 24]> */
		/* 8216C240h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 8216C240h case   19:*/		return 0x8216C244;
		  /* 8216C244h */ case   20:  		/* bl -1380 */
		/* 8216C244h case   20:*/		regs.LR = 0x8216C248; return 0x8216BCE0;
		/* 8216C244h case   20:*/		return 0x8216C248;
		  /* 8216C248h */ case   21:  		/* cmpwi CR0, R3, 0 */
		/* 8216C248h case   21:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C248h case   21:*/		return 0x8216C24C;
		  /* 8216C24Ch */ case   22:  		/* bc 12, CR0_LT, 84 */
		/* 8216C24Ch case   22:*/		if ( regs.CR[0].lt ) { return 0x8216C2A0;  }
		/* 8216C24Ch case   22:*/		return 0x8216C250;
		  /* 8216C250h */ case   23:  		/* lwz R3, <#[R31 + 20]> */
		/* 8216C250h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 8216C250h case   23:*/		return 0x8216C254;
		  /* 8216C254h */ case   24:  		/* bl -1172 */
		/* 8216C254h case   24:*/		regs.LR = 0x8216C258; return 0x8216BDC0;
		/* 8216C254h case   24:*/		return 0x8216C258;
		  /* 8216C258h */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 8216C258h case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C258h case   25:*/		return 0x8216C25C;
		  /* 8216C25Ch */ case   26:  		/* bc 12, CR0_LT, 68 */
		/* 8216C25Ch case   26:*/		if ( regs.CR[0].lt ) { return 0x8216C2A0;  }
		/* 8216C25Ch case   26:*/		return 0x8216C260;
	}
	return 0x8216C260;
} // Block from 8216C1F4h-8216C260h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8216C260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C260);
		  /* 8216C260h */ case    0:  		/* lwz R9, <#[R31 + 84]> */
		/* 8216C260h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000054) );
		/* 8216C260h case    0:*/		return 0x8216C264;
		  /* 8216C264h */ case    1:  		/* addi R10, R31, 84 */
		/* 8216C264h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x54);
		/* 8216C264h case    1:*/		return 0x8216C268;
		  /* 8216C268h */ case    2:  		/* addi R11, R9, -2 */
		/* 8216C268h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFE);
		/* 8216C268h case    2:*/		return 0x8216C26C;
		  /* 8216C26Ch */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 8216C26Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8216C26Ch case    3:*/		return 0x8216C270;
		  /* 8216C270h */ case    4:  		/* bc 4, CR6_LT, 44 */
		/* 8216C270h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8216C29C;  }
		/* 8216C270h case    4:*/		return 0x8216C274;
		  /* 8216C274h */ case    5:  		/* addi R8, R11, 1 */
		/* 8216C274h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 8216C274h case    5:*/		return 0x8216C278;
		  /* 8216C278h */ case    6:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8216C278h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8216C278h case    6:*/		return 0x8216C27C;
		  /* 8216C27Ch */ case    7:  		/* add R10, R8, R10 */
		/* 8216C27Ch case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8216C27Ch case    7:*/		return 0x8216C280;
		  /* 8216C280h */ case    8:  		/* lwz R8, <#[R10]> */
		/* 8216C280h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8216C280h case    8:*/		return 0x8216C284;
		  /* 8216C284h */ case    9:  		/* rlwinm. R8, R8, 0, 0, 1 */
		/* 8216C284h case    9:*/		cpu::op::rlwinm<1,0,0,1>(regs,&regs.R8,regs.R8);
		/* 8216C284h case    9:*/		return 0x8216C288;
		  /* 8216C288h */ case   10:  		/* bc 4, CR0_EQ, -468 */
		/* 8216C288h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216C0B4;  }
		/* 8216C288h case   10:*/		return 0x8216C28C;
		  /* 8216C28Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 8216C28Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216C28Ch case   11:*/		return 0x8216C290;
		  /* 8216C290h */ case   12:  		/* addi R10, R10, 4 */
		/* 8216C290h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C290h case   12:*/		return 0x8216C294;
		  /* 8216C294h */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 8216C294h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8216C294h case   13:*/		return 0x8216C298;
		  /* 8216C298h */ case   14:  		/* bc 12, CR6_LT, -24 */
		/* 8216C298h case   14:*/		if ( regs.CR[6].lt ) { return 0x8216C280;  }
		/* 8216C298h case   14:*/		return 0x8216C29C;
	}
	return 0x8216C29C;
} // Block from 8216C260h-8216C29Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216C29Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C29C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C29C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C29C);
		  /* 8216C29Ch */ case    0:  		/* li R3, 0 */
		/* 8216C29Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216C29Ch case    0:*/		return 0x8216C2A0;
	}
	return 0x8216C2A0;
} // Block from 8216C29Ch-8216C2A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C2A0);
		  /* 8216C2A0h */ case    0:  		/* addi R1, R1, 112 */
		/* 8216C2A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216C2A0h case    0:*/		return 0x8216C2A4;
		  /* 8216C2A4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216C2A4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216C2A4h case    1:*/		return 0x8216C2A8;
		  /* 8216C2A8h */ case    2:  		/* mtspr LR, R12 */
		/* 8216C2A8h case    2:*/		regs.LR = regs.R12;
		/* 8216C2A8h case    2:*/		return 0x8216C2AC;
		  /* 8216C2ACh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8216C2ACh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216C2ACh case    3:*/		return 0x8216C2B0;
		  /* 8216C2B0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8216C2B0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216C2B0h case    4:*/		return 0x8216C2B4;
		  /* 8216C2B4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8216C2B4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216C2B4h case    5:*/		return 0x8216C2B8;
	}
	return 0x8216C2B8;
} // Block from 8216C2A0h-8216C2B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216C2B8h
// Function '?ValidateConstantInfo@@YAJPBU_D3DXSHADER_CONSTANTINFO@@PBU_D3DXSHADER_CONSTANTTABLE@@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C2B8);
		  /* 8216C2B8h */ case    0:  		/* mfspr R12, LR */
		/* 8216C2B8h case    0:*/		regs.R12 = regs.LR;
		/* 8216C2B8h case    0:*/		return 0x8216C2BC;
		  /* 8216C2BCh */ case    1:  		/* bl -897128 */
		/* 8216C2BCh case    1:*/		regs.LR = 0x8216C2C0; return 0x82091254;
		/* 8216C2BCh case    1:*/		return 0x8216C2C0;
		  /* 8216C2C0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216C2C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216C2C0h case    2:*/		return 0x8216C2C4;
		  /* 8216C2C4h */ case    3:  		/* mr R30, R3 */
		/* 8216C2C4h case    3:*/		regs.R30 = regs.R3;
		/* 8216C2C4h case    3:*/		return 0x8216C2C8;
		  /* 8216C2C8h */ case    4:  		/* mr R29, R4 */
		/* 8216C2C8h case    4:*/		regs.R29 = regs.R4;
		/* 8216C2C8h case    4:*/		return 0x8216C2CC;
		  /* 8216C2CCh */ case    5:  		/* mr R27, R5 */
		/* 8216C2CCh case    5:*/		regs.R27 = regs.R5;
		/* 8216C2CCh case    5:*/		return 0x8216C2D0;
		  /* 8216C2D0h */ case    6:  		/* mr R31, R6 */
		/* 8216C2D0h case    6:*/		regs.R31 = regs.R6;
		/* 8216C2D0h case    6:*/		return 0x8216C2D4;
		  /* 8216C2D4h */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 8216C2D4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8216C2D4h case    7:*/		return 0x8216C2D8;
		  /* 8216C2D8h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 8216C2D8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8216C2E8;  }
		/* 8216C2D8h case    8:*/		return 0x8216C2DC;
		  /* 8216C2DCh */ case    9:  		/* lis R3, -32768 */
		/* 8216C2DCh case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216C2DCh case    9:*/		return 0x8216C2E0;
		  /* 8216C2E0h */ case   10:  		/* ori R3, R3, 16389 */
		/* 8216C2E0h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216C2E0h case   10:*/		return 0x8216C2E4;
		  /* 8216C2E4h */ case   11:  		/* b 656 */
		/* 8216C2E4h case   11:*/		return 0x8216C574;
		/* 8216C2E4h case   11:*/		return 0x8216C2E8;
	}
	return 0x8216C2E8;
} // Block from 8216C2B8h-8216C2E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216C2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C2E8);
		  /* 8216C2E8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8216C2E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216C2E8h case    0:*/		return 0x8216C2EC;
		  /* 8216C2ECh */ case    1:  		/* lis R10, 4138 */
		/* 8216C2ECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x102A);
		/* 8216C2ECh case    1:*/		return 0x8216C2F0;
		  /* 8216C2F0h */ case    2:  		/* ori R10, R10, 4352 */
		/* 8216C2F0h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1100);
		/* 8216C2F0h case    2:*/		return 0x8216C2F4;
		  /* 8216C2F4h */ case    3:  		/* rlwinm R11, R11, 0, 0, 23 */
		/* 8216C2F4h case    3:*/		cpu::op::rlwinm<0,0,0,23>(regs,&regs.R11,regs.R11);
		/* 8216C2F4h case    3:*/		return 0x8216C2F8;
		  /* 8216C2F8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 8216C2F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216C2F8h case    4:*/		return 0x8216C2FC;
		  /* 8216C2FCh */ case    5:  		/* bc 4, CR6_EQ, -32 */
		/* 8216C2FCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216C2DC;  }
		/* 8216C2FCh case    5:*/		return 0x8216C300;
		  /* 8216C300h */ case    6:  		/* addi R4, R1, 80 */
		/* 8216C300h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8216C300h case    6:*/		return 0x8216C304;
		  /* 8216C304h */ case    7:  		/* mr R3, R30 */
		/* 8216C304h case    7:*/		regs.R3 = regs.R30;
		/* 8216C304h case    7:*/		return 0x8216C308;
		  /* 8216C308h */ case    8:  		/* bl -1062320 */
		/* 8216C308h case    8:*/		regs.LR = 0x8216C30C; return 0x82068D58;
		/* 8216C308h case    8:*/		return 0x8216C30C;
		  /* 8216C30Ch */ case    9:  		/* stw R30, <#[R31 + 64]> */
		/* 8216C30Ch case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000040) );
		/* 8216C30Ch case    9:*/		return 0x8216C310;
		  /* 8216C310h */ case   10:  		/* lwz R11, <#[R30]> */
		/* 8216C310h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216C310h case   10:*/		return 0x8216C314;
		  /* 8216C314h */ case   11:  		/* li R4, 1 */
		/* 8216C314h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216C314h case   11:*/		return 0x8216C318;
		  /* 8216C318h */ case   12:  		/* lwz R10, <#[R1 + 80]> */
		/* 8216C318h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8216C318h case   12:*/		return 0x8216C31C;
		  /* 8216C31Ch */ case   13:  		/* lwz R28, <#[R10 + 4]> */
		/* 8216C31Ch case   13:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C31Ch case   13:*/		return 0x8216C320;
		  /* 8216C320h */ case   14:  		/* stw R28, <#[R1 + 84]> */
		/* 8216C320h case   14:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 8216C320h case   14:*/		return 0x8216C324;
		  /* 8216C324h */ case   15:  		/* lwz R9, <#[R10]> */
		/* 8216C324h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216C324h case   15:*/		return 0x8216C328;
		  /* 8216C328h */ case   16:  		/* rlwinm. R9, R9, 0, 26, 26 */
		/* 8216C328h case   16:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R9,regs.R9);
		/* 8216C328h case   16:*/		return 0x8216C32C;
		  /* 8216C32Ch */ case   17:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8216C32Ch case   17:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216C32Ch case   17:*/		return 0x8216C330;
		  /* 8216C330h */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 8216C330h case   18:*/		if ( regs.CR[0].eq ) { return 0x8216C338;  }
		/* 8216C330h case   18:*/		return 0x8216C334;
		  /* 8216C334h */ case   19:  		/* stb R4, <#[R31 + 41]> */
		/* 8216C334h case   19:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R31 + 0x00000029) );
		/* 8216C334h case   19:*/		return 0x8216C338;
	}
	return 0x8216C338;
} // Block from 8216C2E8h-8216C338h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216C338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C338);
		  /* 8216C338h */ case    0:  		/* li R3, 0 */
		/* 8216C338h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216C338h case    0:*/		return 0x8216C33C;
		  /* 8216C33Ch */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 8216C33Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8216C33Ch case    1:*/		return 0x8216C340;
		  /* 8216C340h */ case    2:  		/* bc 12, CR6_EQ, 168 */
		/* 8216C340h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216C3E8;  }
		/* 8216C340h case    2:*/		return 0x8216C344;
		  /* 8216C344h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8216C344h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216C344h case    3:*/		return 0x8216C348;
		  /* 8216C348h */ case    4:  		/* bc 4, CR6_EQ, -108 */
		/* 8216C348h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8216C2DC;  }
		/* 8216C348h case    4:*/		return 0x8216C34C;
		  /* 8216C34Ch */ case    5:  		/* addi R11, R29, 3 */
		/* 8216C34Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x3);
		/* 8216C34Ch case    5:*/		return 0x8216C350;
		  /* 8216C350h */ case    6:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8216C350h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8216C350h case    6:*/		return 0x8216C354;
		  /* 8216C354h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8216C354h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8216C354h case    7:*/		return 0x8216C358;
		  /* 8216C358h */ case    8:  		/* add R11, R11, R10 */
		/* 8216C358h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216C358h case    8:*/		return 0x8216C35C;
		  /* 8216C35Ch */ case    9:  		/* stw R11, <#[R31]> */
		/* 8216C35Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216C35Ch case    9:*/		return 0x8216C360;
		  /* 8216C360h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 8216C360h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216C360h case   10:*/		return 0x8216C364;
		  /* 8216C364h */ case   11:  		/* bc 12, CR6_LT, -136 */
		/* 8216C364h case   11:*/		if ( regs.CR[6].lt ) { return 0x8216C2DC;  }
		/* 8216C364h case   11:*/		return 0x8216C368;
		  /* 8216C368h */ case   12:  		/* rldicl R8, R28, 0, 32 */
		/* 8216C368h case   12:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R28);
		/* 8216C368h case   12:*/		return 0x8216C36C;
		  /* 8216C36Ch */ case   13:  		/* rldicl R7, R10, 0, 32 */
		/* 8216C36Ch case   13:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R10);
		/* 8216C36Ch case   13:*/		return 0x8216C370;
		  /* 8216C370h */ case   14:  		/* rldicl R9, R11, 0, 32 */
		/* 8216C370h case   14:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8216C370h case   14:*/		return 0x8216C374;
		  /* 8216C374h */ case   15:  		/* add R8, R8, R7 */
		/* 8216C374h case   15:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8216C374h case   15:*/		return 0x8216C378;
		  /* 8216C378h */ case   16:  		/* addi R9, R9, 32 */
		/* 8216C378h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x20);
		/* 8216C378h case   16:*/		return 0x8216C37C;
		  /* 8216C37Ch */ case   17:  		/* cmpld CR6, R9, R8 */
		/* 8216C37Ch case   17:*/		cpu::op::cmpld<6>(regs,regs.R9,regs.R8);
		/* 8216C37Ch case   17:*/		return 0x8216C380;
		  /* 8216C380h */ case   18:  		/* bc 12, CR6_GT, -164 */
		/* 8216C380h case   18:*/		if ( regs.CR[6].gt ) { return 0x8216C2DC;  }
		/* 8216C380h case   18:*/		return 0x8216C384;
		  /* 8216C384h */ case   19:  		/* lwz R9, <#[R11 + 4]> */
		/* 8216C384h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8216C384h case   19:*/		return 0x8216C388;
		  /* 8216C388h */ case   20:  		/* li R8, 12 */
		/* 8216C388h case   20:*/		cpu::op::li<0>(regs,&regs.R8,0xC);
		/* 8216C388h case   20:*/		return 0x8216C38C;
		  /* 8216C38Ch */ case   21:  		/* divwu R8, R9, R8 */
		/* 8216C38Ch case   21:*/		cpu::op::divwu<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8216C38Ch case   21:*/		return 0x8216C390;
		  /* 8216C390h */ case   22:  		/* mulli R8, R8, 12 */
		/* 8216C390h case   22:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R8,0xC);
		/* 8216C390h case   22:*/		return 0x8216C394;
		  /* 8216C394h */ case   23:  		/* stw R9, <#[R31 + 36]> */
		/* 8216C394h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 8216C394h case   23:*/		return 0x8216C398;
		  /* 8216C398h */ case   24:  		/* subf. R8, R8, R9 */
		/* 8216C398h case   24:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8216C398h case   24:*/		return 0x8216C39C;
		  /* 8216C39Ch */ case   25:  		/* bc 4, CR0_EQ, -192 */
		/* 8216C39Ch case   25:*/		if ( !regs.CR[0].eq ) { return 0x8216C2DC;  }
		/* 8216C39Ch case   25:*/		return 0x8216C3A0;
		  /* 8216C3A0h */ case   26:  		/* cmplwi CR6, R9, 24564 */
		/* 8216C3A0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00005FF4);
		/* 8216C3A0h case   26:*/		return 0x8216C3A4;
		  /* 8216C3A4h */ case   27:  		/* bc 12, CR6_GT, -200 */
		/* 8216C3A4h case   27:*/		if ( regs.CR[6].gt ) { return 0x8216C2DC;  }
		/* 8216C3A4h case   27:*/		return 0x8216C3A8;
		  /* 8216C3A8h */ case   28:  		/* lwz R6, <#[R1 + 88]> */
		/* 8216C3A8h case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 8216C3A8h case   28:*/		return 0x8216C3AC;
		  /* 8216C3ACh */ case   29:  		/* lwz R9, <#[R11]> */
		/* 8216C3ACh case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216C3ACh case   29:*/		return 0x8216C3B0;
		  /* 8216C3B0h */ case   30:  		/* add R5, R9, R6 */
		/* 8216C3B0h case   30:*/		cpu::op::add<0>(regs,&regs.R5,regs.R9,regs.R6);
		/* 8216C3B0h case   30:*/		return 0x8216C3B4;
		  /* 8216C3B4h */ case   31:  		/* subf R9, R6, R5 */
		/* 8216C3B4h case   31:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R5);
		/* 8216C3B4h case   31:*/		return 0x8216C3B8;
		  /* 8216C3B8h */ case   32:  		/* rlwinm. R9, R9, 0, 27, 31 */
		/* 8216C3B8h case   32:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8216C3B8h case   32:*/		return 0x8216C3BC;
		  /* 8216C3BCh */ case   33:  		/* bc 4, CR0_EQ, -224 */
		/* 8216C3BCh case   33:*/		if ( !regs.CR[0].eq ) { return 0x8216C2DC;  }
		/* 8216C3BCh case   33:*/		return 0x8216C3C0;
		  /* 8216C3C0h */ case   34:  		/* stb R4, <#[R31 + 40]> */
		/* 8216C3C0h case   34:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R31 + 0x00000028) );
		/* 8216C3C0h case   34:*/		return 0x8216C3C4;
		  /* 8216C3C4h */ case   35:  		/* addi R9, R11, 32 */
		/* 8216C3C4h case   35:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x20);
		/* 8216C3C4h case   35:*/		return 0x8216C3C8;
		  /* 8216C3C8h */ case   36:  		/* lwz R8, <#[R11 + 20]> */
		/* 8216C3C8h case   36:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 8216C3C8h case   36:*/		return 0x8216C3CC;
		  /* 8216C3CCh */ case   37:  		/* stw R9, <#[R31 + 12]> */
		/* 8216C3CCh case   37:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216C3CCh case   37:*/		return 0x8216C3D0;
		  /* 8216C3D0h */ case   38:  		/* stw R8, <#[R31 + 28]> */
		/* 8216C3D0h case   38:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x0000001C) );
		/* 8216C3D0h case   38:*/		return 0x8216C3D4;
		  /* 8216C3D4h */ case   39:  		/* lwz R9, <#[R11 + 8]> */
		/* 8216C3D4h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8216C3D4h case   39:*/		return 0x8216C3D8;
	}
	return 0x8216C3D8;
} // Block from 8216C338h-8216C3D8h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8216C3D8h
// Function '?ValidateConstantTable@@YAJPBU_UCODE_CONSTANT_TABLE@@PBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C3D8);
		  /* 8216C3D8h */ case    0:  		/* stw R9, <#[R31 + 52]> */
		/* 8216C3D8h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000034) );
		/* 8216C3D8h case    0:*/		return 0x8216C3DC;
		  /* 8216C3DCh */ case    1:  		/* rlwinm R9, R9, 0, 0, 31 */
		/* 8216C3DCh case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R9);
		/* 8216C3DCh case    1:*/		return 0x8216C3E0;
		  /* 8216C3E0h */ case    2:  		/* rlwinm R9, R9, 24, 26, 31 */
		/* 8216C3E0h case    2:*/		cpu::op::rlwinm<0,24,26,31>(regs,&regs.R9,regs.R9);
		/* 8216C3E0h case    2:*/		return 0x8216C3E4;
		  /* 8216C3E4h */ case    3:  		/* b 204 */
		/* 8216C3E4h case    3:*/		return 0x8216C4B0;
		/* 8216C3E4h case    3:*/		return 0x8216C3E8;
	}
	return 0x8216C3E8;
} // Block from 8216C3D8h-8216C3E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216C3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C3E8);
		  /* 8216C3E8h */ case    0:  		/* addi R11, R29, 3 */
		/* 8216C3E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x3);
		/* 8216C3E8h case    0:*/		return 0x8216C3EC;
		  /* 8216C3ECh */ case    1:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8216C3ECh case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8216C3ECh case    1:*/		return 0x8216C3F0;
		  /* 8216C3F0h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8216C3F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8216C3F0h case    2:*/		return 0x8216C3F4;
		  /* 8216C3F4h */ case    3:  		/* add R11, R11, R10 */
		/* 8216C3F4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216C3F4h case    3:*/		return 0x8216C3F8;
		  /* 8216C3F8h */ case    4:  		/* stw R11, <#[R31]> */
		/* 8216C3F8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216C3F8h case    4:*/		return 0x8216C3FC;
		  /* 8216C3FCh */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 8216C3FCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216C3FCh case    5:*/		return 0x8216C400;
		  /* 8216C400h */ case    6:  		/* bc 12, CR6_LT, -292 */
		/* 8216C400h case    6:*/		if ( regs.CR[6].lt ) { return 0x8216C2DC;  }
		/* 8216C400h case    6:*/		return 0x8216C404;
		  /* 8216C404h */ case    7:  		/* rldicl R8, R28, 0, 32 */
		/* 8216C404h case    7:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R28);
		/* 8216C404h case    7:*/		return 0x8216C408;
		  /* 8216C408h */ case    8:  		/* rldicl R7, R10, 0, 32 */
		/* 8216C408h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R10);
		/* 8216C408h case    8:*/		return 0x8216C40C;
		  /* 8216C40Ch */ case    9:  		/* rldicl R9, R11, 0, 32 */
		/* 8216C40Ch case    9:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8216C40Ch case    9:*/		return 0x8216C410;
		  /* 8216C410h */ case   10:  		/* add R8, R8, R7 */
		/* 8216C410h case   10:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8216C410h case   10:*/		return 0x8216C414;
		  /* 8216C414h */ case   11:  		/* addi R9, R9, 36 */
		/* 8216C414h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x24);
		/* 8216C414h case   11:*/		return 0x8216C418;
		  /* 8216C418h */ case   12:  		/* cmpld CR6, R9, R8 */
		/* 8216C418h case   12:*/		cpu::op::cmpld<6>(regs,regs.R9,regs.R8);
		/* 8216C418h case   12:*/		return 0x8216C41C;
		  /* 8216C41Ch */ case   13:  		/* bc 12, CR6_GT, -320 */
		/* 8216C41Ch case   13:*/		if ( regs.CR[6].gt ) { return 0x8216C2DC;  }
		/* 8216C41Ch case   13:*/		return 0x8216C420;
		  /* 8216C420h */ case   14:  		/* lwz R9, <#[R11 + 4]> */
		/* 8216C420h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8216C420h case   14:*/		return 0x8216C424;
		  /* 8216C424h */ case   15:  		/* li R8, 12 */
		/* 8216C424h case   15:*/		cpu::op::li<0>(regs,&regs.R8,0xC);
		/* 8216C424h case   15:*/		return 0x8216C428;
		  /* 8216C428h */ case   16:  		/* divwu R8, R9, R8 */
		/* 8216C428h case   16:*/		cpu::op::divwu<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 8216C428h case   16:*/		return 0x8216C42C;
		  /* 8216C42Ch */ case   17:  		/* mulli R8, R8, 12 */
		/* 8216C42Ch case   17:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R8,0xC);
		/* 8216C42Ch case   17:*/		return 0x8216C430;
		  /* 8216C430h */ case   18:  		/* stw R9, <#[R31 + 36]> */
		/* 8216C430h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 8216C430h case   18:*/		return 0x8216C434;
		  /* 8216C434h */ case   19:  		/* subf. R8, R8, R9 */
		/* 8216C434h case   19:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8216C434h case   19:*/		return 0x8216C438;
		  /* 8216C438h */ case   20:  		/* bc 4, CR0_EQ, -348 */
		/* 8216C438h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8216C2DC;  }
		/* 8216C438h case   20:*/		return 0x8216C43C;
		  /* 8216C43Ch */ case   21:  		/* cmplwi CR6, R9, 24552 */
		/* 8216C43Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00005FE8);
		/* 8216C43Ch case   21:*/		return 0x8216C440;
		  /* 8216C440h */ case   22:  		/* bc 12, CR6_GT, -356 */
		/* 8216C440h case   22:*/		if ( regs.CR[6].gt ) { return 0x8216C2DC;  }
		/* 8216C440h case   22:*/		return 0x8216C444;
		  /* 8216C444h */ case   23:  		/* lwz R6, <#[R1 + 88]> */
		/* 8216C444h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 8216C444h case   23:*/		return 0x8216C448;
		  /* 8216C448h */ case   24:  		/* lwz R9, <#[R11]> */
		/* 8216C448h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216C448h case   24:*/		return 0x8216C44C;
		  /* 8216C44Ch */ case   25:  		/* add R5, R9, R6 */
		/* 8216C44Ch case   25:*/		cpu::op::add<0>(regs,&regs.R5,regs.R9,regs.R6);
		/* 8216C44Ch case   25:*/		return 0x8216C450;
		  /* 8216C450h */ case   26:  		/* subf R9, R6, R5 */
		/* 8216C450h case   26:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R5);
		/* 8216C450h case   26:*/		return 0x8216C454;
		  /* 8216C454h */ case   27:  		/* rlwinm. R9, R9, 0, 27, 31 */
		/* 8216C454h case   27:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8216C454h case   27:*/		return 0x8216C458;
		  /* 8216C458h */ case   28:  		/* bc 4, CR0_EQ, -380 */
		/* 8216C458h case   28:*/		if ( !regs.CR[0].eq ) { return 0x8216C2DC;  }
		/* 8216C458h case   28:*/		return 0x8216C45C;
		  /* 8216C45Ch */ case   29:  		/* stb R3, <#[R31 + 40]> */
		/* 8216C45Ch case   29:*/		cpu::mem::store8( regs, regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8216C45Ch case   29:*/		return 0x8216C460;
		  /* 8216C460h */ case   30:  		/* addi R9, R11, 36 */
		/* 8216C460h case   30:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x24);
		/* 8216C460h case   30:*/		return 0x8216C464;
		  /* 8216C464h */ case   31:  		/* lwz R8, <#[R11 + 20]> */
		/* 8216C464h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 8216C464h case   31:*/		return 0x8216C468;
		  /* 8216C468h */ case   32:  		/* stw R9, <#[R31 + 12]> */
		/* 8216C468h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216C468h case   32:*/		return 0x8216C46C;
		  /* 8216C46Ch */ case   33:  		/* stw R8, <#[R31 + 28]> */
		/* 8216C46Ch case   33:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x0000001C) );
		/* 8216C46Ch case   33:*/		return 0x8216C470;
		  /* 8216C470h */ case   34:  		/* rlwinm R8, R8, 0, 0, 31 */
		/* 8216C470h case   34:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R8,regs.R8);
		/* 8216C470h case   34:*/		return 0x8216C474;
		  /* 8216C474h */ case   35:  		/* rlwinm R8, R8, 29, 25, 29 */
		/* 8216C474h case   35:*/		cpu::op::rlwinm<0,29,25,29>(regs,&regs.R8,regs.R8);
		/* 8216C474h case   35:*/		return 0x8216C478;
		  /* 8216C478h */ case   36:  		/* lwz R7, <#[R11 + 24]> */
		/* 8216C478h case   36:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000018) );
		/* 8216C478h case   36:*/		return 0x8216C47C;
		  /* 8216C47Ch */ case   37:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8216C47Ch case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8216C47Ch case   37:*/		return 0x8216C480;
		  /* 8216C480h */ case   38:  		/* add R9, R7, R9 */
		/* 8216C480h case   38:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8216C480h case   38:*/		return 0x8216C484;
		  /* 8216C484h */ case   39:  		/* stw R9, <#[R31 + 16]> */
		/* 8216C484h case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8216C484h case   39:*/		return 0x8216C488;
		  /* 8216C488h */ case   40:  		/* lwz R7, <#[R11 + 28]> */
		/* 8216C488h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000001C) );
		/* 8216C488h case   40:*/		return 0x8216C48C;
		  /* 8216C48Ch */ case   41:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8216C48Ch case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8216C48Ch case   41:*/		return 0x8216C490;
		  /* 8216C490h */ case   42:  		/* add R9, R7, R9 */
		/* 8216C490h case   42:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8216C490h case   42:*/		return 0x8216C494;
		  /* 8216C494h */ case   43:  		/* add R8, R8, R9 */
		/* 8216C494h case   43:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8216C494h case   43:*/		return 0x8216C498;
		  /* 8216C498h */ case   44:  		/* stw R9, <#[R31 + 20]> */
		/* 8216C498h case   44:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8216C498h case   44:*/		return 0x8216C49C;
		  /* 8216C49Ch */ case   45:  		/* stw R8, <#[R31 + 24]> */
		/* 8216C49Ch case   45:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 8216C49Ch case   45:*/		return 0x8216C4A0;
		  /* 8216C4A0h */ case   46:  		/* lwz R9, <#[R11 + 8]> */
		/* 8216C4A0h case   46:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8216C4A0h case   46:*/		return 0x8216C4A4;
		  /* 8216C4A4h */ case   47:  		/* stw R9, <#[R31 + 52]> */
		/* 8216C4A4h case   47:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000034) );
		/* 8216C4A4h case   47:*/		return 0x8216C4A8;
		  /* 8216C4A8h */ case   48:  		/* rlwinm R9, R9, 0, 0, 31 */
		/* 8216C4A8h case   48:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R9);
		/* 8216C4A8h case   48:*/		return 0x8216C4AC;
		  /* 8216C4ACh */ case   49:  		/* rlwinm R9, R9, 0, 26, 31 */
		/* 8216C4ACh case   49:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R9,regs.R9);
		/* 8216C4ACh case   49:*/		return 0x8216C4B0;
	}
	return 0x8216C4B0;
} // Block from 8216C3E8h-8216C4B0h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8216C4B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C4B0);
		  /* 8216C4B0h */ case    0:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216C4B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216C4B0h case    0:*/		return 0x8216C4B4;
		  /* 8216C4B4h */ case    1:  		/* rldicl R7, R5, 0, 32 */
		/* 8216C4B4h case    1:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R5);
		/* 8216C4B4h case    1:*/		return 0x8216C4B8;
		  /* 8216C4B8h */ case    2:  		/* stw R9, <#[R31 + 32]> */
		/* 8216C4B8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 8216C4B8h case    2:*/		return 0x8216C4BC;
		  /* 8216C4BCh */ case    3:  		/* rldicl R9, R6, 0, 32 */
		/* 8216C4BCh case    3:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R6);
		/* 8216C4BCh case    3:*/		return 0x8216C4C0;
		  /* 8216C4C0h */ case    4:  		/* lwz R4, <#[R1 + 92]> */
		/* 8216C4C0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 8216C4C0h case    4:*/		return 0x8216C4C4;
		  /* 8216C4C4h */ case    5:  		/* lwz R8, <#[R31 + 36]> */
		/* 8216C4C4h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000024) );
		/* 8216C4C4h case    5:*/		return 0x8216C4C8;
		  /* 8216C4C8h */ case    6:  		/* stw R11, <#[R31 + 56]> */
		/* 8216C4C8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8216C4C8h case    6:*/		return 0x8216C4CC;
		  /* 8216C4CCh */ case    7:  		/* add R8, R8, R7 */
		/* 8216C4CCh case    7:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8216C4CCh case    7:*/		return 0x8216C4D0;
		  /* 8216C4D0h */ case    8:  		/* add R11, R4, R9 */
		/* 8216C4D0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R9);
		/* 8216C4D0h case    8:*/		return 0x8216C4D4;
		  /* 8216C4D4h */ case    9:  		/* cmpld CR6, R8, R11 */
		/* 8216C4D4h case    9:*/		cpu::op::cmpld<6>(regs,regs.R8,regs.R11);
		/* 8216C4D4h case    9:*/		return 0x8216C4D8;
		  /* 8216C4D8h */ case   10:  		/* bc 12, CR6_GT, -508 */
		/* 8216C4D8h case   10:*/		if ( regs.CR[6].gt ) { return 0x8216C2DC;  }
		/* 8216C4D8h case   10:*/		return 0x8216C4DC;
		  /* 8216C4DCh */ case   11:  		/* cntlzw R11, R27 */
		/* 8216C4DCh case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R27);
		/* 8216C4DCh case   11:*/		return 0x8216C4E0;
	}
	return 0x8216C4E0;
} // Block from 8216C4B0h-8216C4E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216C4E0h
// Function '?ValidateLiteralConstants@@YAJPBU_UCODE_DEFINITION_TABLE@@PBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C4E0);
		  /* 8216C4E0h */ case    0:  		/* lbz R9, <#[R31 + 40]> */
		/* 8216C4E0h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000028) );
		/* 8216C4E0h case    0:*/		return 0x8216C4E4;
		  /* 8216C4E4h */ case    1:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8216C4E4h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8216C4E4h case    1:*/		return 0x8216C4E8;
		  /* 8216C4E8h */ case    2:  		/* cmpw CR6, R9, R11 */
		/* 8216C4E8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 8216C4E8h case    2:*/		return 0x8216C4EC;
		  /* 8216C4ECh */ case    3:  		/* bc 4, CR6_EQ, -528 */
		/* 8216C4ECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216C2DC;  }
		/* 8216C4ECh case    3:*/		return 0x8216C4F0;
		  /* 8216C4F0h */ case    4:  		/* rlwinm R11, R29, 3, 0, 28 */
		/* 8216C4F0h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R29);
		/* 8216C4F0h case    4:*/		return 0x8216C4F4;
		  /* 8216C4F4h */ case    5:  		/* add R11, R11, R10 */
		/* 8216C4F4h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216C4F4h case    5:*/		return 0x8216C4F8;
		  /* 8216C4F8h */ case    6:  		/* lwz R11, <#[R11 + 20]> */
		/* 8216C4F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8216C4F8h case    6:*/		return 0x8216C4FC;
		  /* 8216C4FCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8216C4FCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216C4FCh case    7:*/		return 0x8216C500;
		  /* 8216C500h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 8216C500h case    8:*/		if ( regs.CR[6].eq ) { return 0x8216C510;  }
		/* 8216C500h case    8:*/		return 0x8216C504;
		  /* 8216C504h */ case    9:  		/* add R11, R11, R10 */
		/* 8216C504h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216C504h case    9:*/		return 0x8216C508;
		  /* 8216C508h */ case   10:  		/* stw R11, <#[R31 + 8]> */
		/* 8216C508h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216C508h case   10:*/		return 0x8216C50C;
		  /* 8216C50Ch */ case   11:  		/* b 8 */
		/* 8216C50Ch case   11:*/		return 0x8216C514;
		/* 8216C50Ch case   11:*/		return 0x8216C510;
	}
	return 0x8216C510;
} // Block from 8216C4E0h-8216C510h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216C510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C510);
		  /* 8216C510h */ case    0:  		/* stw R3, <#[R31 + 8]> */
		/* 8216C510h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8216C510h case    0:*/		return 0x8216C514;
	}
	return 0x8216C514;
} // Block from 8216C510h-8216C514h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C514);
		  /* 8216C514h */ case    0:  		/* lwz R11, <#[R10 + 16]> */
		/* 8216C514h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 8216C514h case    0:*/		return 0x8216C518;
		  /* 8216C518h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216C518h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216C518h case    1:*/		return 0x8216C51C;
		  /* 8216C51Ch */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8216C51Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8216C52C;  }
		/* 8216C51Ch case    2:*/		return 0x8216C520;
		  /* 8216C520h */ case    3:  		/* add R11, R11, R10 */
		/* 8216C520h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216C520h case    3:*/		return 0x8216C524;
		  /* 8216C524h */ case    4:  		/* stw R11, <#[R31 + 44]> */
		/* 8216C524h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8216C524h case    4:*/		return 0x8216C528;
		  /* 8216C528h */ case    5:  		/* b 8 */
		/* 8216C528h case    5:*/		return 0x8216C530;
		/* 8216C528h case    5:*/		return 0x8216C52C;
	}
	return 0x8216C52C;
} // Block from 8216C514h-8216C52Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216C52Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C52C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C52C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C52C);
		  /* 8216C52Ch */ case    0:  		/* stw R3, <#[R31 + 44]> */
		/* 8216C52Ch case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8216C52Ch case    0:*/		return 0x8216C530;
	}
	return 0x8216C530;
} // Block from 8216C52Ch-8216C530h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C530);
		  /* 8216C530h */ case    0:  		/* lwz R11, <#[R10 + 12]> */
		/* 8216C530h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8216C530h case    0:*/		return 0x8216C534;
		  /* 8216C534h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216C534h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216C534h case    1:*/		return 0x8216C538;
		  /* 8216C538h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8216C538h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216C548;  }
		/* 8216C538h case    2:*/		return 0x8216C53C;
		  /* 8216C53Ch */ case    3:  		/* add R11, R11, R10 */
		/* 8216C53Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216C53Ch case    3:*/		return 0x8216C540;
		  /* 8216C540h */ case    4:  		/* stw R11, <#[R31 + 48]> */
		/* 8216C540h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8216C540h case    4:*/		return 0x8216C544;
		  /* 8216C544h */ case    5:  		/* b 8 */
		/* 8216C544h case    5:*/		return 0x8216C54C;
		/* 8216C544h case    5:*/		return 0x8216C548;
	}
	return 0x8216C548;
} // Block from 8216C530h-8216C548h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216C548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C548);
		  /* 8216C548h */ case    0:  		/* stw R3, <#[R31 + 48]> */
		/* 8216C548h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8216C548h case    0:*/		return 0x8216C54C;
	}
	return 0x8216C54C;
} // Block from 8216C548h-8216C54Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C54Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C54C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C54C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C54C);
		  /* 8216C54Ch */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 8216C54Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8216C54Ch case    0:*/		return 0x8216C550;
		  /* 8216C550h */ case    1:  		/* li R9, 6 */
		/* 8216C550h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 8216C550h case    1:*/		return 0x8216C554;
		  /* 8216C554h */ case    2:  		/* stw R10, <#[R31 + 68]> */
		/* 8216C554h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000044) );
		/* 8216C554h case    2:*/		return 0x8216C558;
		  /* 8216C558h */ case    3:  		/* li R3, 0 */
		/* 8216C558h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216C558h case    3:*/		return 0x8216C55C;
		  /* 8216C55Ch */ case    4:  		/* divwu R11, R11, R9 */
		/* 8216C55Ch case    4:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216C55Ch case    4:*/		return 0x8216C560;
		  /* 8216C560h */ case    5:  		/* stw R28, <#[R31 + 72]> */
		/* 8216C560h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000048) );
		/* 8216C560h case    5:*/		return 0x8216C564;
		  /* 8216C564h */ case    6:  		/* stw R6, <#[R31 + 76]> */
		/* 8216C564h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x0000004C) );
		/* 8216C564h case    6:*/		return 0x8216C568;
		  /* 8216C568h */ case    7:  		/* stw R11, <#[R31 + 84]> */
		/* 8216C568h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 8216C568h case    7:*/		return 0x8216C56C;
		  /* 8216C56Ch */ case    8:  		/* stw R4, <#[R31 + 80]> */
		/* 8216C56Ch case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000050) );
		/* 8216C56Ch case    8:*/		return 0x8216C570;
		  /* 8216C570h */ case    9:  		/* stw R5, <#[R31 + 4]> */
		/* 8216C570h case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000004) );
		/* 8216C570h case    9:*/		return 0x8216C574;
	}
	return 0x8216C574;
} // Block from 8216C54Ch-8216C574h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216C574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C574);
		  /* 8216C574h */ case    0:  		/* addi R1, R1, 144 */
		/* 8216C574h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216C574h case    0:*/		return 0x8216C578;
		  /* 8216C578h */ case    1:  		/* b -897748 */
		/* 8216C578h case    1:*/		return 0x820912A4;
		/* 8216C578h case    1:*/		return 0x8216C57C;
		  /* 8216C57Ch */ case    2:  		/* nop */
		/* 8216C57Ch case    2:*/		cpu::op::nop();
		/* 8216C57Ch case    2:*/		return 0x8216C580;
	}
	return 0x8216C580;
} // Block from 8216C574h-8216C580h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216C580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C580);
		  /* 8216C580h */ case    0:  		/* mfspr R12, LR */
		/* 8216C580h case    0:*/		regs.R12 = regs.LR;
		/* 8216C580h case    0:*/		return 0x8216C584;
		  /* 8216C584h */ case    1:  		/* bl -897832 */
		/* 8216C584h case    1:*/		regs.LR = 0x8216C588; return 0x8209125C;
		/* 8216C584h case    1:*/		return 0x8216C588;
		  /* 8216C588h */ case    2:  		/* lwz R11, <#[R3 + 68]> */
		/* 8216C588h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 8216C588h case    2:*/		return 0x8216C58C;
		  /* 8216C58Ch */ case    3:  		/* lwz R9, <#[R3 + 72]> */
		/* 8216C58Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000048) );
		/* 8216C58Ch case    3:*/		return 0x8216C590;
		  /* 8216C590h */ case    4:  		/* lwz R10, <#[R3 + 76]> */
		/* 8216C590h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216C590h case    4:*/		return 0x8216C594;
		  /* 8216C594h */ case    5:  		/* add R9, R9, R11 */
		/* 8216C594h case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8216C594h case    5:*/		return 0x8216C598;
		  /* 8216C598h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 8216C598h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8216C598h case    6:*/		return 0x8216C59C;
		  /* 8216C59Ch */ case    7:  		/* bc 4, CR6_LT, 32 */
		/* 8216C59Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x8216C5BC;  }
		/* 8216C59Ch case    7:*/		return 0x8216C5A0;
		  /* 8216C5A0h */ case    8:  		/* lwz R9, <#[R3 + 80]> */
		/* 8216C5A0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000050) );
		/* 8216C5A0h case    8:*/		return 0x8216C5A4;
		  /* 8216C5A4h */ case    9:  		/* add R10, R9, R10 */
		/* 8216C5A4h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8216C5A4h case    9:*/		return 0x8216C5A8;
		  /* 8216C5A8h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 8216C5A8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216C5A8h case   10:*/		return 0x8216C5AC;
		  /* 8216C5ACh */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 8216C5ACh case   11:*/		if ( !regs.CR[6].lt ) { return 0x8216C5BC;  }
		/* 8216C5ACh case   11:*/		return 0x8216C5B0;
		  /* 8216C5B0h */ case   12:  		/* lis R3, -32768 */
		/* 8216C5B0h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216C5B0h case   12:*/		return 0x8216C5B4;
		  /* 8216C5B4h */ case   13:  		/* ori R3, R3, 16389 */
		/* 8216C5B4h case   13:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216C5B4h case   13:*/		return 0x8216C5B8;
		  /* 8216C5B8h */ case   14:  		/* b 648 */
		/* 8216C5B8h case   14:*/		return 0x8216C840;
		/* 8216C5B8h case   14:*/		return 0x8216C5BC;
	}
	return 0x8216C5BC;
} // Block from 8216C580h-8216C5BCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216C5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C5BC);
		  /* 8216C5BCh */ case    0:  		/* cntlzw R10, R5 */
		/* 8216C5BCh case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R5);
		/* 8216C5BCh case    0:*/		return 0x8216C5C0;
		  /* 8216C5C0h */ case    1:  		/* stw R11, <#[R1 - 224]> */
		/* 8216C5C0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFF20) );
		/* 8216C5C0h case    1:*/		return 0x8216C5C4;
		  /* 8216C5C4h */ case    2:  		/* li R31, 36 */
		/* 8216C5C4h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x24);
		/* 8216C5C4h case    2:*/		return 0x8216C5C8;
		  /* 8216C5C8h */ case    3:  		/* stw R4, <#[R1 - 236]> */
		/* 8216C5C8h case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0xFFFFFF14) );
		/* 8216C5C8h case    3:*/		return 0x8216C5CC;
		  /* 8216C5CCh */ case    4:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 8216C5CCh case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 8216C5CCh case    4:*/		return 0x8216C5D0;
		  /* 8216C5D0h */ case    5:  		/* stw R3, <#[R1 - 240]> */
		/* 8216C5D0h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFF10) );
		/* 8216C5D0h case    5:*/		return 0x8216C5D4;
		  /* 8216C5D4h */ case    6:  		/* stw R31, <#[R1 - 128]> */
		/* 8216C5D4h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFF80) );
		/* 8216C5D4h case    6:*/		return 0x8216C5D8;
		  /* 8216C5D8h */ case    7:  		/* li R8, 1 */
		/* 8216C5D8h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8216C5D8h case    7:*/		return 0x8216C5DC;
		  /* 8216C5DCh */ case    8:  		/* xori R11, R10, 1 */
		/* 8216C5DCh case    8:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R10,0x1);
		/* 8216C5DCh case    8:*/		return 0x8216C5E0;
		  /* 8216C5E0h */ case    9:  		/* li R6, 0 */
		/* 8216C5E0h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216C5E0h case    9:*/		return 0x8216C5E4;
		  /* 8216C5E4h */ case   10:  		/* addic. R4, R11, 1 */
		/* 8216C5E4h case   10:*/		cpu::op::addic<1>(regs,&regs.R4,regs.R11,0x1);
		/* 8216C5E4h case   10:*/		return 0x8216C5E8;
		  /* 8216C5E8h */ case   11:  		/* bc 12, CR0_EQ, 356 */
		/* 8216C5E8h case   11:*/		if ( regs.CR[0].eq ) { return 0x8216C74C;  }
		/* 8216C5E8h case   11:*/		return 0x8216C5EC;
		  /* 8216C5ECh */ case   12:  		/* addi R9, R1, -128 */
		/* 8216C5ECh case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF80);
		/* 8216C5ECh case   12:*/		return 0x8216C5F0;
		  /* 8216C5F0h */ case   13:  		/* addi R5, R1, -240 */
		/* 8216C5F0h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xFFFFFF10);
		/* 8216C5F0h case   13:*/		return 0x8216C5F4;
		  /* 8216C5F4h */ case   14:  		/* addi R10, R1, -224 */
		/* 8216C5F4h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFF20);
		/* 8216C5F4h case   14:*/		return 0x8216C5F8;
		  /* 8216C5F8h */ case   15:  		/* lwz R11, <#[R5]> */
		/* 8216C5F8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8216C5F8h case   15:*/		return 0x8216C5FC;
		  /* 8216C5FCh */ case   16:  		/* cmplwi CR6, R8, 21 */
		/* 8216C5FCh case   16:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C5FCh case   16:*/		return 0x8216C600;
		  /* 8216C600h */ case   17:  		/* lbz R7, <#[R11 + 40]> */
		/* 8216C600h case   17:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000028) );
		/* 8216C600h case   17:*/		return 0x8216C604;
		  /* 8216C604h */ case   18:  		/* cmplwi CR0, R7, 0 */
		/* 8216C604h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R7,0x00000000);
		/* 8216C604h case   18:*/		return 0x8216C608;
		  /* 8216C608h */ case   19:  		/* bc 4, CR6_LT, -88 */
		/* 8216C608h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C608h case   19:*/		return 0x8216C60C;
		  /* 8216C60Ch */ case   20:  		/* lwz R7, <#[R11]> */
		/* 8216C60Ch case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8216C60Ch case   20:*/		return 0x8216C610;
		  /* 8216C610h */ case   21:  		/* addi R8, R8, 1 */
		/* 8216C610h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C610h case   21:*/		return 0x8216C614;
		  /* 8216C614h */ case   22:  		/* cmplwi CR6, R8, 21 */
		/* 8216C614h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C614h case   22:*/		return 0x8216C618;
		  /* 8216C618h */ case   23:  		/* stw R7, <#[R10 + 4]> */
		/* 8216C618h case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C618h case   23:*/		return 0x8216C61C;
		  /* 8216C61Ch */ case   24:  		/* addi R10, R10, 4 */
		/* 8216C61Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C61Ch case   24:*/		return 0x8216C620;
		  /* 8216C620h */ case   25:  		/* bc 12, CR0_EQ, 44 */
		/* 8216C620h case   25:*/		if ( regs.CR[0].eq ) { return 0x8216C64C;  }
		/* 8216C620h case   25:*/		return 0x8216C624;
		  /* 8216C624h */ case   26:  		/* li R30, 32 */
		/* 8216C624h case   26:*/		cpu::op::li<0>(regs,&regs.R30,0x20);
		/* 8216C624h case   26:*/		return 0x8216C628;
		  /* 8216C628h */ case   27:  		/* stw R30, <#[R9 + 4]> */
		/* 8216C628h case   27:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C628h case   27:*/		return 0x8216C62C;
		  /* 8216C62Ch */ case   28:  		/* addi R9, R9, 4 */
		/* 8216C62Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216C62Ch case   28:*/		return 0x8216C630;
		  /* 8216C630h */ case   29:  		/* bc 4, CR6_LT, -128 */
		/* 8216C630h case   29:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C630h case   29:*/		return 0x8216C634;
		  /* 8216C634h */ case   30:  		/* lwz R7, <#[R11 + 12]> */
		/* 8216C634h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216C634h case   30:*/		return 0x8216C638;
		  /* 8216C638h */ case   31:  		/* lwz R30, <#[R11 + 28]> */
		/* 8216C638h case   31:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000001C) );
		/* 8216C638h case   31:*/		return 0x8216C63C;
		  /* 8216C63Ch */ case   32:  		/* rlwinm R30, R30, 29, 25, 29 */
		/* 8216C63Ch case   32:*/		cpu::op::rlwinm<0,29,25,29>(regs,&regs.R30,regs.R30);
		/* 8216C63Ch case   32:*/		return 0x8216C640;
		  /* 8216C640h */ case   33:  		/* stw R7, <#[R10 + 4]> */
		/* 8216C640h case   33:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C640h case   33:*/		return 0x8216C644;
		  /* 8216C644h */ case   34:  		/* stw R30, <#[R9 + 4]> */
		/* 8216C644h case   34:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C644h case   34:*/		return 0x8216C648;
		  /* 8216C648h */ case   35:  		/* b 156 */
		/* 8216C648h case   35:*/		return 0x8216C6E4;
		/* 8216C648h case   35:*/		return 0x8216C64C;
	}
	return 0x8216C64C;
} // Block from 8216C5BCh-8216C64Ch (36 instructions)

//////////////////////////////////////////////////////
// Block at 8216C64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C64C);
		  /* 8216C64Ch */ case    0:  		/* stw R31, <#[R9 + 4]> */
		/* 8216C64Ch case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C64Ch case    0:*/		return 0x8216C650;
		  /* 8216C650h */ case    1:  		/* addi R9, R9, 4 */
		/* 8216C650h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216C650h case    1:*/		return 0x8216C654;
		  /* 8216C654h */ case    2:  		/* bc 4, CR6_LT, -164 */
		/* 8216C654h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C654h case    2:*/		return 0x8216C658;
	}
	return 0x8216C658;
} // Block from 8216C64Ch-8216C658h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216C658h
// Function '?ValidateVsInputDecls@@YAJPBT_UCODE_VSINPUTDECLARATION@@PBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C658);
		  /* 8216C658h */ case    0:  		/* lwz R30, <#[R11 + 12]> */
		/* 8216C658h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216C658h case    0:*/		return 0x8216C65C;
		  /* 8216C65Ch */ case    1:  		/* addi R8, R8, 1 */
		/* 8216C65Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C65Ch case    1:*/		return 0x8216C660;
		  /* 8216C660h */ case    2:  		/* lwz R29, <#[R7 + 24]> */
		/* 8216C660h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R7 + 0x00000018) );
		/* 8216C660h case    2:*/		return 0x8216C664;
		  /* 8216C664h */ case    3:  		/* cmplwi CR6, R8, 21 */
		/* 8216C664h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C664h case    3:*/		return 0x8216C668;
		  /* 8216C668h */ case    4:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 8216C668h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 8216C668h case    4:*/		return 0x8216C66C;
		  /* 8216C66Ch */ case    5:  		/* stw R30, <#[R10 + 4]> */
		/* 8216C66Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C66Ch case    5:*/		return 0x8216C670;
		  /* 8216C670h */ case    6:  		/* addi R10, R10, 4 */
		/* 8216C670h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C670h case    6:*/		return 0x8216C674;
		  /* 8216C674h */ case    7:  		/* stw R29, <#[R9 + 4]> */
		/* 8216C674h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C674h case    7:*/		return 0x8216C678;
		  /* 8216C678h */ case    8:  		/* addi R9, R9, 4 */
		/* 8216C678h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216C678h case    8:*/		return 0x8216C67C;
		  /* 8216C67Ch */ case    9:  		/* bc 4, CR6_LT, -204 */
		/* 8216C67Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C67Ch case    9:*/		return 0x8216C680;
		  /* 8216C680h */ case   10:  		/* lwz R30, <#[R11 + 16]> */
		/* 8216C680h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 8216C680h case   10:*/		return 0x8216C684;
		  /* 8216C684h */ case   11:  		/* addi R8, R8, 1 */
		/* 8216C684h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C684h case   11:*/		return 0x8216C688;
		  /* 8216C688h */ case   12:  		/* lwz R29, <#[R7 + 28]> */
		/* 8216C688h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R7 + 0x0000001C) );
		/* 8216C688h case   12:*/		return 0x8216C68C;
		  /* 8216C68Ch */ case   13:  		/* cmplwi CR6, R8, 21 */
		/* 8216C68Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C68Ch case   13:*/		return 0x8216C690;
		  /* 8216C690h */ case   14:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 8216C690h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 8216C690h case   14:*/		return 0x8216C694;
		  /* 8216C694h */ case   15:  		/* stw R30, <#[R10 + 4]> */
		/* 8216C694h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C694h case   15:*/		return 0x8216C698;
		  /* 8216C698h */ case   16:  		/* addi R10, R10, 4 */
		/* 8216C698h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C698h case   16:*/		return 0x8216C69C;
		  /* 8216C69Ch */ case   17:  		/* stw R29, <#[R9 + 4]> */
		/* 8216C69Ch case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C69Ch case   17:*/		return 0x8216C6A0;
		  /* 8216C6A0h */ case   18:  		/* addi R9, R9, 4 */
		/* 8216C6A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216C6A0h case   18:*/		return 0x8216C6A4;
		  /* 8216C6A4h */ case   19:  		/* bc 4, CR6_LT, -244 */
		/* 8216C6A4h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C6A4h case   19:*/		return 0x8216C6A8;
		  /* 8216C6A8h */ case   20:  		/* lwz R30, <#[R11 + 20]> */
		/* 8216C6A8h case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000014) );
		/* 8216C6A8h case   20:*/		return 0x8216C6AC;
		  /* 8216C6ACh */ case   21:  		/* addi R8, R8, 1 */
		/* 8216C6ACh case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C6ACh case   21:*/		return 0x8216C6B0;
		  /* 8216C6B0h */ case   22:  		/* lwz R29, <#[R11 + 28]> */
		/* 8216C6B0h case   22:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x0000001C) );
		/* 8216C6B0h case   22:*/		return 0x8216C6B4;
		  /* 8216C6B4h */ case   23:  		/* cmplwi CR6, R8, 21 */
		/* 8216C6B4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C6B4h case   23:*/		return 0x8216C6B8;
		  /* 8216C6B8h */ case   24:  		/* rlwinm R29, R29, 29, 25, 29 */
		/* 8216C6B8h case   24:*/		cpu::op::rlwinm<0,29,25,29>(regs,&regs.R29,regs.R29);
		/* 8216C6B8h case   24:*/		return 0x8216C6BC;
		  /* 8216C6BCh */ case   25:  		/* stw R30, <#[R10 + 4]> */
		/* 8216C6BCh case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C6BCh case   25:*/		return 0x8216C6C0;
		  /* 8216C6C0h */ case   26:  		/* addi R10, R10, 4 */
		/* 8216C6C0h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C6C0h case   26:*/		return 0x8216C6C4;
		  /* 8216C6C4h */ case   27:  		/* stw R29, <#[R9 + 4]> */
		/* 8216C6C4h case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C6C4h case   27:*/		return 0x8216C6C8;
		  /* 8216C6C8h */ case   28:  		/* addi R9, R9, 4 */
		/* 8216C6C8h case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216C6C8h case   28:*/		return 0x8216C6CC;
		  /* 8216C6CCh */ case   29:  		/* bc 4, CR6_LT, -284 */
		/* 8216C6CCh case   29:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C6CCh case   29:*/		return 0x8216C6D0;
		  /* 8216C6D0h */ case   30:  		/* lwz R30, <#[R11 + 24]> */
		/* 8216C6D0h case   30:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000018) );
		/* 8216C6D0h case   30:*/		return 0x8216C6D4;
		  /* 8216C6D4h */ case   31:  		/* lwz R7, <#[R7 + 32]> */
		/* 8216C6D4h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000020) );
		/* 8216C6D4h case   31:*/		return 0x8216C6D8;
		  /* 8216C6D8h */ case   32:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8216C6D8h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8216C6D8h case   32:*/		return 0x8216C6DC;
		  /* 8216C6DCh */ case   33:  		/* stw R30, <#[R10 + 4]> */
		/* 8216C6DCh case   33:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C6DCh case   33:*/		return 0x8216C6E0;
		  /* 8216C6E0h */ case   34:  		/* stw R7, <#[R9 + 4]> */
		/* 8216C6E0h case   34:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C6E0h case   34:*/		return 0x8216C6E4;
	}
	return 0x8216C6E4;
} // Block from 8216C658h-8216C6E4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8216C6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C6E4);
		  /* 8216C6E4h */ case    0:  		/* lwz R7, <#[R11 + 8]> */
		/* 8216C6E4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 8216C6E4h case    0:*/		return 0x8216C6E8;
		  /* 8216C6E8h */ case    1:  		/* addi R9, R9, 4 */
		/* 8216C6E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216C6E8h case    1:*/		return 0x8216C6EC;
		  /* 8216C6ECh */ case    2:  		/* addi R10, R10, 4 */
		/* 8216C6ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C6ECh case    2:*/		return 0x8216C6F0;
		  /* 8216C6F0h */ case    3:  		/* addi R8, R8, 1 */
		/* 8216C6F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C6F0h case    3:*/		return 0x8216C6F4;
		  /* 8216C6F4h */ case    4:  		/* cmplwi CR6, R7, 0 */
		/* 8216C6F4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8216C6F4h case    4:*/		return 0x8216C6F8;
		  /* 8216C6F8h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 8216C6F8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216C720;  }
		/* 8216C6F8h case    5:*/		return 0x8216C6FC;
		  /* 8216C6FCh */ case    6:  		/* cmplwi CR6, R8, 21 */
		/* 8216C6FCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C6FCh case    6:*/		return 0x8216C700;
		  /* 8216C700h */ case    7:  		/* bc 4, CR6_LT, -336 */
		/* 8216C700h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C700h case    7:*/		return 0x8216C704;
		  /* 8216C704h */ case    8:  		/* rlwinm R7, R7, 0, 0, 31 */
		/* 8216C704h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R7);
		/* 8216C704h case    8:*/		return 0x8216C708;
		  /* 8216C708h */ case    9:  		/* addi R8, R8, 1 */
		/* 8216C708h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C708h case    9:*/		return 0x8216C70C;
		  /* 8216C70Ch */ case   10:  		/* stw R7, <#[R10 + 4]> */
		/* 8216C70Ch case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C70Ch case   10:*/		return 0x8216C710;
		  /* 8216C710h */ case   11:  		/* addi R10, R10, 4 */
		/* 8216C710h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C710h case   11:*/		return 0x8216C714;
		  /* 8216C714h */ case   12:  		/* lwz R30, <#[R7 + 16]> */
		/* 8216C714h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + 0x00000010) );
		/* 8216C714h case   12:*/		return 0x8216C718;
		  /* 8216C718h */ case   13:  		/* stw R30, <#[R9 + 4]> */
		/* 8216C718h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 8216C718h case   13:*/		return 0x8216C71C;
		  /* 8216C71Ch */ case   14:  		/* addi R9, R9, 4 */
		/* 8216C71Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216C71Ch case   14:*/		return 0x8216C720;
	}
	return 0x8216C720;
} // Block from 8216C6E4h-8216C720h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216C720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C720);
		  /* 8216C720h */ case    0:  		/* cmplwi CR6, R8, 21 */
		/* 8216C720h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C720h case    0:*/		return 0x8216C724;
		  /* 8216C724h */ case    1:  		/* bc 4, CR6_LT, -372 */
		/* 8216C724h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C724h case    1:*/		return 0x8216C728;
		  /* 8216C728h */ case    2:  		/* lwz R7, <#[R11 + 4]> */
		/* 8216C728h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8216C728h case    2:*/		return 0x8216C72C;
		  /* 8216C72Ch */ case    3:  		/* addi R6, R6, 1 */
		/* 8216C72Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8216C72Ch case    3:*/		return 0x8216C730;
		  /* 8216C730h */ case    4:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216C730h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216C730h case    4:*/		return 0x8216C734;
		  /* 8216C734h */ case    5:  		/* addi R8, R8, 1 */
		/* 8216C734h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C734h case    5:*/		return 0x8216C738;
		  /* 8216C738h */ case    6:  		/* addi R5, R5, 4 */
		/* 8216C738h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 8216C738h case    6:*/		return 0x8216C73C;
		  /* 8216C73Ch */ case    7:  		/* cmplw CR6, R6, R4 */
		/* 8216C73Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 8216C73Ch case    7:*/		return 0x8216C740;
		  /* 8216C740h */ case    8:  		/* stwu R7, <#[R10 + 4]> */
		/* 8216C740h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8216C740h case    8:*/		return 0x8216C744;
		  /* 8216C744h */ case    9:  		/* stwu R11, <#[R9 + 4]> */
		/* 8216C744h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8216C744h case    9:*/		return 0x8216C748;
		  /* 8216C748h */ case   10:  		/* bc 12, CR6_LT, -336 */
		/* 8216C748h case   10:*/		if ( regs.CR[6].lt ) { return 0x8216C5F8;  }
		/* 8216C748h case   10:*/		return 0x8216C74C;
	}
	return 0x8216C74C;
} // Block from 8216C720h-8216C74Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216C74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C74C);
		  /* 8216C74Ch */ case    0:  		/* lwz R11, <#[R3 + 44]> */
		/* 8216C74Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 8216C74Ch case    0:*/		return 0x8216C750;
	}
	return 0x8216C750;
} // Block from 8216C74Ch-8216C750h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C750h
// Function '?ValidateVsOutputPatches@@YAJPBT_UCODE_VSOUTPUTPATCH@@PBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C750);
		  /* 8216C750h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8216C750h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216C750h case    0:*/		return 0x8216C754;
		  /* 8216C754h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 8216C754h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216C780;  }
		/* 8216C754h case    1:*/		return 0x8216C758;
		  /* 8216C758h */ case    2:  		/* cmplwi CR6, R8, 21 */
		/* 8216C758h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C758h case    2:*/		return 0x8216C75C;
		  /* 8216C75Ch */ case    3:  		/* bc 4, CR6_LT, -428 */
		/* 8216C75Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C75Ch case    3:*/		return 0x8216C760;
		  /* 8216C760h */ case    4:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8216C760h case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8216C760h case    4:*/		return 0x8216C764;
		  /* 8216C764h */ case    5:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 8216C764h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 8216C764h case    5:*/		return 0x8216C768;
		  /* 8216C768h */ case    6:  		/* addi R9, R1, -224 */
		/* 8216C768h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF20);
		/* 8216C768h case    6:*/		return 0x8216C76C;
		  /* 8216C76Ch */ case    7:  		/* addi R7, R1, -128 */
		/* 8216C76Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF80);
		/* 8216C76Ch case    7:*/		return 0x8216C770;
		  /* 8216C770h */ case    8:  		/* addi R8, R8, 1 */
		/* 8216C770h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C770h case    8:*/		return 0x8216C774;
		  /* 8216C774h */ case    9:  		/* lwz R6, <#[R11]> */
		/* 8216C774h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216C774h case    9:*/		return 0x8216C778;
		  /* 8216C778h */ case   10:  		/* stwx R11, <#[R10 + R9]> */
		/* 8216C778h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8216C778h case   10:*/		return 0x8216C77C;
		  /* 8216C77Ch */ case   11:  		/* stwx R6, <#[R10 + R7]> */
		/* 8216C77Ch case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8216C77Ch case   11:*/		return 0x8216C780;
	}
	return 0x8216C780;
} // Block from 8216C750h-8216C780h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216C780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C780);
		  /* 8216C780h */ case    0:  		/* lwz R11, <#[R3 + 48]> */
		/* 8216C780h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8216C780h case    0:*/		return 0x8216C784;
		  /* 8216C784h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216C784h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216C784h case    1:*/		return 0x8216C788;
		  /* 8216C788h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 8216C788h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216C7C0;  }
		/* 8216C788h case    2:*/		return 0x8216C78C;
		  /* 8216C78Ch */ case    3:  		/* cmplwi CR6, R8, 21 */
		/* 8216C78Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000015);
		/* 8216C78Ch case    3:*/		return 0x8216C790;
		  /* 8216C790h */ case    4:  		/* bc 4, CR6_LT, -480 */
		/* 8216C790h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C790h case    4:*/		return 0x8216C794;
		  /* 8216C794h */ case    5:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 8216C794h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 8216C794h case    5:*/		return 0x8216C798;
		  /* 8216C798h */ case    6:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 8216C798h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 8216C798h case    6:*/		return 0x8216C79C;
		  /* 8216C79Ch */ case    7:  		/* addi R7, R1, -224 */
		/* 8216C79Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF20);
		/* 8216C79Ch case    7:*/		return 0x8216C7A0;
		  /* 8216C7A0h */ case    8:  		/* addi R6, R1, -128 */
		/* 8216C7A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xFFFFFF80);
		/* 8216C7A0h case    8:*/		return 0x8216C7A4;
		  /* 8216C7A4h */ case    9:  		/* addi R8, R8, 1 */
		/* 8216C7A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216C7A4h case    9:*/		return 0x8216C7A8;
		  /* 8216C7A8h */ case   10:  		/* lwz R11, <#[R10 + 4]> */
		/* 8216C7A8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8216C7A8h case   10:*/		return 0x8216C7AC;
		  /* 8216C7ACh */ case   11:  		/* addi R11, R11, 3 */
		/* 8216C7ACh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8216C7ACh case   11:*/		return 0x8216C7B0;
		  /* 8216C7B0h */ case   12:  		/* stwx R10, <#[R9 + R7]> */
		/* 8216C7B0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8216C7B0h case   12:*/		return 0x8216C7B4;
		  /* 8216C7B4h */ case   13:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8216C7B4h case   13:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8216C7B4h case   13:*/		return 0x8216C7B8;
		  /* 8216C7B8h */ case   14:  		/* addi R11, R11, 8 */
		/* 8216C7B8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8216C7B8h case   14:*/		return 0x8216C7BC;
		  /* 8216C7BCh */ case   15:  		/* stwx R11, <#[R9 + R6]> */
		/* 8216C7BCh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 8216C7BCh case   15:*/		return 0x8216C7C0;
	}
	return 0x8216C7C0;
} // Block from 8216C780h-8216C7C0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216C7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C7C0);
		  /* 8216C7C0h */ case    0:  		/* addic. R3, R8, -1 */
		/* 8216C7C0h case    0:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R8,0xFFFFFFFF);
		/* 8216C7C0h case    0:*/		return 0x8216C7C4;
		  /* 8216C7C4h */ case    1:  		/* li R10, 0 */
		/* 8216C7C4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216C7C4h case    1:*/		return 0x8216C7C8;
		  /* 8216C7C8h */ case    2:  		/* bc 12, CR0_EQ, 116 */
		/* 8216C7C8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216C83C;  }
		/* 8216C7C8h case    2:*/		return 0x8216C7CC;
		  /* 8216C7CCh */ case    3:  		/* li R11, 0 */
		/* 8216C7CCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216C7CCh case    3:*/		return 0x8216C7D0;
		  /* 8216C7D0h */ case    4:  		/* addi R5, R10, 1 */
		/* 8216C7D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1);
		/* 8216C7D0h case    4:*/		return 0x8216C7D4;
		  /* 8216C7D4h */ case    5:  		/* mr R4, R5 */
		/* 8216C7D4h case    5:*/		regs.R4 = regs.R5;
		/* 8216C7D4h case    5:*/		return 0x8216C7D8;
		  /* 8216C7D8h */ case    6:  		/* cmplw CR6, R5, R8 */
		/* 8216C7D8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 8216C7D8h case    6:*/		return 0x8216C7DC;
		  /* 8216C7DCh */ case    7:  		/* bc 4, CR6_LT, 80 */
		/* 8216C7DCh case    7:*/		if ( !regs.CR[6].lt ) { return 0x8216C82C;  }
		/* 8216C7DCh case    7:*/		return 0x8216C7E0;
		  /* 8216C7E0h */ case    8:  		/* addi R10, R11, 4 */
		/* 8216C7E0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8216C7E0h case    8:*/		return 0x8216C7E4;
		  /* 8216C7E4h */ case    9:  		/* addi R7, R1, -128 */
		/* 8216C7E4h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFF80);
		/* 8216C7E4h case    9:*/		return 0x8216C7E8;
		  /* 8216C7E8h */ case   10:  		/* addi R9, R1, -224 */
		/* 8216C7E8h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFF20);
		/* 8216C7E8h case   10:*/		return 0x8216C7EC;
		  /* 8216C7ECh */ case   11:  		/* addi R31, R1, -224 */
		/* 8216C7ECh case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF20);
		/* 8216C7ECh case   11:*/		return 0x8216C7F0;
		  /* 8216C7F0h */ case   12:  		/* lwzx R6, <#[R10 + R7]> */
		/* 8216C7F0h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8216C7F0h case   12:*/		return 0x8216C7F4;
		  /* 8216C7F4h */ case   13:  		/* lwzx R9, <#[R10 + R9]> */
		/* 8216C7F4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8216C7F4h case   13:*/		return 0x8216C7F8;
		  /* 8216C7F8h */ case   14:  		/* lwzx R7, <#[R11 + R31]> */
		/* 8216C7F8h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8216C7F8h case   14:*/		return 0x8216C7FC;
		  /* 8216C7FCh */ case   15:  		/* add R6, R6, R9 */
		/* 8216C7FCh case   15:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 8216C7FCh case   15:*/		return 0x8216C800;
		  /* 8216C800h */ case   16:  		/* cmplw CR6, R7, R6 */
		/* 8216C800h case   16:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8216C800h case   16:*/		return 0x8216C804;
		  /* 8216C804h */ case   17:  		/* bc 4, CR6_LT, 24 */
		/* 8216C804h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8216C81C;  }
		/* 8216C804h case   17:*/		return 0x8216C808;
		  /* 8216C808h */ case   18:  		/* addi R6, R1, -128 */
		/* 8216C808h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xFFFFFF80);
		/* 8216C808h case   18:*/		return 0x8216C80C;
		  /* 8216C80Ch */ case   19:  		/* lwzx R6, <#[R11 + R6]> */
		/* 8216C80Ch case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8216C80Ch case   19:*/		return 0x8216C810;
		  /* 8216C810h */ case   20:  		/* add R7, R6, R7 */
		/* 8216C810h case   20:*/		cpu::op::add<0>(regs,&regs.R7,regs.R6,regs.R7);
		/* 8216C810h case   20:*/		return 0x8216C814;
		  /* 8216C814h */ case   21:  		/* cmplw CR6, R9, R7 */
		/* 8216C814h case   21:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8216C814h case   21:*/		return 0x8216C818;
		  /* 8216C818h */ case   22:  		/* bc 12, CR6_LT, -616 */
		/* 8216C818h case   22:*/		if ( regs.CR[6].lt ) { return 0x8216C5B0;  }
		/* 8216C818h case   22:*/		return 0x8216C81C;
	}
	return 0x8216C81C;
} // Block from 8216C7C0h-8216C81Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8216C81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C81C);
		  /* 8216C81Ch */ case    0:  		/* addi R4, R4, 1 */
		/* 8216C81Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8216C81Ch case    0:*/		return 0x8216C820;
		  /* 8216C820h */ case    1:  		/* addi R10, R10, 4 */
		/* 8216C820h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8216C820h case    1:*/		return 0x8216C824;
		  /* 8216C824h */ case    2:  		/* cmplw CR6, R4, R8 */
		/* 8216C824h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 8216C824h case    2:*/		return 0x8216C828;
		  /* 8216C828h */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 8216C828h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216C7E4;  }
		/* 8216C828h case    3:*/		return 0x8216C82C;
	}
	return 0x8216C82C;
} // Block from 8216C81Ch-8216C82Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216C82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C82C);
		  /* 8216C82Ch */ case    0:  		/* mr R10, R5 */
		/* 8216C82Ch case    0:*/		regs.R10 = regs.R5;
		/* 8216C82Ch case    0:*/		return 0x8216C830;
	}
	return 0x8216C830;
} // Block from 8216C82Ch-8216C830h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C830h
// Function '?ValidateVsOutputDecls@@YAJPBT_UCODE_VSOUTPUTDECLARATION@@PBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C830);
		  /* 8216C830h */ case    0:  		/* addi R11, R11, 4 */
		/* 8216C830h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216C830h case    0:*/		return 0x8216C834;
		  /* 8216C834h */ case    1:  		/* cmplw CR6, R5, R3 */
		/* 8216C834h case    1:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R3);
		/* 8216C834h case    1:*/		return 0x8216C838;
		  /* 8216C838h */ case    2:  		/* bc 12, CR6_LT, -104 */
		/* 8216C838h case    2:*/		if ( regs.CR[6].lt ) { return 0x8216C7D0;  }
		/* 8216C838h case    2:*/		return 0x8216C83C;
	}
	return 0x8216C83C;
} // Block from 8216C830h-8216C83Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216C83Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C83C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C83C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C83C);
		  /* 8216C83Ch */ case    0:  		/* li R3, 0 */
		/* 8216C83Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216C83Ch case    0:*/		return 0x8216C840;
	}
	return 0x8216C840;
} // Block from 8216C83Ch-8216C840h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C840);
		  /* 8216C840h */ case    0:  		/* b -898452 */
		/* 8216C840h case    0:*/		return 0x820912AC;
		/* 8216C840h case    0:*/		return 0x8216C844;
		  /* 8216C844h */ case    1:  		/* nop */
		/* 8216C844h case    1:*/		cpu::op::nop();
		/* 8216C844h case    1:*/		return 0x8216C848;
		  /* 8216C848h */ case    2:  		/* lwz R17, <#[R6 - 11576]> */
		/* 8216C848h case    2:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 8216C848h case    2:*/		return 0x8216C84C;
		  /* 8216C84Ch */ case    3:  		/* lwz R16, <#[R4 - 14888]> */
		/* 8216C84Ch case    3:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC5D8) );
		/* 8216C84Ch case    3:*/		return 0x8216C850;
	}
	return 0x8216C850;
} // Block from 8216C840h-8216C850h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216C850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C850);
		  /* 8216C850h */ case    0:  		/* mfspr R12, LR */
		/* 8216C850h case    0:*/		regs.R12 = regs.LR;
		/* 8216C850h case    0:*/		return 0x8216C854;
		  /* 8216C854h */ case    1:  		/* bl -898564 */
		/* 8216C854h case    1:*/		regs.LR = 0x8216C858; return 0x82091250;
		/* 8216C854h case    1:*/		return 0x8216C858;
		  /* 8216C858h */ case    2:  		/* addi R31, R1, -144 */
		/* 8216C858h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFF70);
		/* 8216C858h case    2:*/		return 0x8216C85C;
		  /* 8216C85Ch */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216C85Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216C85Ch case    3:*/		return 0x8216C860;
		  /* 8216C860h */ case    4:  		/* mr R28, R3 */
		/* 8216C860h case    4:*/		regs.R28 = regs.R3;
		/* 8216C860h case    4:*/		return 0x8216C864;
		  /* 8216C864h */ case    5:  		/* mr R27, R4 */
		/* 8216C864h case    5:*/		regs.R27 = regs.R4;
		/* 8216C864h case    5:*/		return 0x8216C868;
		  /* 8216C868h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 8216C868h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8216C868h case    6:*/		return 0x8216C86C;
		  /* 8216C86Ch */ case    7:  		/* bc 12, CR6_EQ, 312 */
		/* 8216C86Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8216C9A4;  }
		/* 8216C86Ch case    7:*/		return 0x8216C870;
		  /* 8216C870h */ case    8:  		/* lis R3, 1 */
		/* 8216C870h case    8:*/		cpu::op::lis<0>(regs,&regs.R3,0x1);
		/* 8216C870h case    8:*/		return 0x8216C874;
		  /* 8216C874h */ case    9:  		/* lis R4, 9351 */
		/* 8216C874h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2487);
		/* 8216C874h case    9:*/		return 0x8216C878;
		  /* 8216C878h */ case   10:  		/* ori R3, R3, 208 */
		/* 8216C878h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xD0);
		/* 8216C878h case   10:*/		return 0x8216C87C;
		  /* 8216C87Ch */ case   11:  		/* bl -935548 */
		/* 8216C87Ch case   11:*/		regs.LR = 0x8216C880; return 0x82088200;
		/* 8216C87Ch case   11:*/		return 0x8216C880;
		  /* 8216C880h */ case   12:  		/* or. R30, R3, R3 */
		/* 8216C880h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8216C880h case   12:*/		return 0x8216C884;
		  /* 8216C884h */ case   13:  		/* stw R30, <#[R31 + 84]> */
		/* 8216C884h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000054) );
		/* 8216C884h case   13:*/		return 0x8216C888;
		  /* 8216C888h */ case   14:  		/* bc 12, CR0_EQ, 264 */
		/* 8216C888h case   14:*/		if ( regs.CR[0].eq ) { return 0x8216C990;  }
		/* 8216C888h case   14:*/		return 0x8216C88C;
		  /* 8216C88Ch */ case   15:  		/* lis R5, 1 */
		/* 8216C88Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 8216C88Ch case   15:*/		return 0x8216C890;
		  /* 8216C890h */ case   16:  		/* li R4, 0 */
		/* 8216C890h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216C890h case   16:*/		return 0x8216C894;
		  /* 8216C894h */ case   17:  		/* ori R5, R5, 208 */
		/* 8216C894h case   17:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0xD0);
		/* 8216C894h case   17:*/		return 0x8216C898;
		  /* 8216C898h */ case   18:  		/* mr R3, R30 */
		/* 8216C898h case   18:*/		regs.R3 = regs.R30;
		/* 8216C898h case   18:*/		return 0x8216C89C;
		  /* 8216C89Ch */ case   19:  		/* bl -898396 */
		/* 8216C89Ch case   19:*/		regs.LR = 0x8216C8A0; return 0x82091340;
		/* 8216C89Ch case   19:*/		return 0x8216C8A0;
		  /* 8216C8A0h */ case   20:  		/* li R26, 1 */
		/* 8216C8A0h case   20:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8216C8A0h case   20:*/		return 0x8216C8A4;
		  /* 8216C8A4h */ case   21:  		/* nop */
		/* 8216C8A4h case   21:*/		cpu::op::nop();
		/* 8216C8A4h case   21:*/		return 0x8216C8A8;
		  /* 8216C8A8h */ case   22:  		/* nop */
		/* 8216C8A8h case   22:*/		cpu::op::nop();
		/* 8216C8A8h case   22:*/		return 0x8216C8AC;
	}
	return 0x8216C8AC;
} // Block from 8216C850h-8216C8ACh (23 instructions)

//////////////////////////////////////////////////////
// Block at 8216C8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C8AC);
		  /* 8216C8ACh */ case    0:  		/* mr R6, R30 */
		/* 8216C8ACh case    0:*/		regs.R6 = regs.R30;
		/* 8216C8ACh case    0:*/		return 0x8216C8B0;
		  /* 8216C8B0h */ case    1:  		/* mr R5, R27 */
		/* 8216C8B0h case    1:*/		regs.R5 = regs.R27;
		/* 8216C8B0h case    1:*/		return 0x8216C8B4;
		  /* 8216C8B4h */ case    2:  		/* li R4, 0 */
		/* 8216C8B4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216C8B4h case    2:*/		return 0x8216C8B8;
		  /* 8216C8B8h */ case    3:  		/* mr R3, R28 */
		/* 8216C8B8h case    3:*/		regs.R3 = regs.R28;
		/* 8216C8B8h case    3:*/		return 0x8216C8BC;
		  /* 8216C8BCh */ case    4:  		/* bl -1540 */
		/* 8216C8BCh case    4:*/		regs.LR = 0x8216C8C0; return 0x8216C2B8;
		/* 8216C8BCh case    4:*/		return 0x8216C8C0;
		  /* 8216C8C0h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8216C8C0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C8C0h case    5:*/		return 0x8216C8C4;
		  /* 8216C8C4h */ case    6:  		/* bc 4, CR0_LT, 12 */
		/* 8216C8C4h case    6:*/		if ( !regs.CR[0].lt ) { return 0x8216C8D0;  }
		/* 8216C8C4h case    6:*/		return 0x8216C8C8;
		  /* 8216C8C8h */ case    7:  		/* nop */
		/* 8216C8C8h case    7:*/		cpu::op::nop();
		/* 8216C8C8h case    7:*/		return 0x8216C8CC;
		  /* 8216C8CCh */ case    8:  		/* b 196 */
		/* 8216C8CCh case    8:*/		return 0x8216C990;
		/* 8216C8CCh case    8:*/		return 0x8216C8D0;
	}
	return 0x8216C8D0;
} // Block from 8216C8ACh-8216C8D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216C8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C8D0);
		  /* 8216C8D0h */ case    0:  		/* lbz R11, <#[R30 + 41]> */
		/* 8216C8D0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000029) );
		/* 8216C8D0h case    0:*/		return 0x8216C8D4;
		  /* 8216C8D4h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8216C8D4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216C8D4h case    1:*/		return 0x8216C8D8;
		  /* 8216C8D8h */ case    2:  		/* lis R11, 0 */
		/* 8216C8D8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 8216C8D8h case    2:*/		return 0x8216C8DC;
		  /* 8216C8DCh */ case    3:  		/* ori R29, R11, 32872 */
		/* 8216C8DCh case    3:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R11,0x8068);
		/* 8216C8DCh case    3:*/		return 0x8216C8E0;
		  /* 8216C8E0h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 8216C8E0h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216C90C;  }
		/* 8216C8E0h case    4:*/		return 0x8216C8E4;
		  /* 8216C8E4h */ case    5:  		/* mr R5, R27 */
		/* 8216C8E4h case    5:*/		regs.R5 = regs.R27;
		/* 8216C8E4h case    5:*/		return 0x8216C8E8;
		  /* 8216C8E8h */ case    6:  		/* li R4, 1 */
		/* 8216C8E8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216C8E8h case    6:*/		return 0x8216C8EC;
		  /* 8216C8ECh */ case    7:  		/* add R6, R30, R29 */
		/* 8216C8ECh case    7:*/		cpu::op::add<0>(regs,&regs.R6,regs.R30,regs.R29);
		/* 8216C8ECh case    7:*/		return 0x8216C8F0;
		  /* 8216C8F0h */ case    8:  		/* mr R3, R28 */
		/* 8216C8F0h case    8:*/		regs.R3 = regs.R28;
		/* 8216C8F0h case    8:*/		return 0x8216C8F4;
		  /* 8216C8F4h */ case    9:  		/* li R26, 2 */
		/* 8216C8F4h case    9:*/		cpu::op::li<0>(regs,&regs.R26,0x2);
		/* 8216C8F4h case    9:*/		return 0x8216C8F8;
		  /* 8216C8F8h */ case   10:  		/* bl -1600 */
		/* 8216C8F8h case   10:*/		regs.LR = 0x8216C8FC; return 0x8216C2B8;
		/* 8216C8F8h case   10:*/		return 0x8216C8FC;
		  /* 8216C8FCh */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 8216C8FCh case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C8FCh case   11:*/		return 0x8216C900;
		  /* 8216C900h */ case   12:  		/* bc 4, CR0_LT, 12 */
		/* 8216C900h case   12:*/		if ( !regs.CR[0].lt ) { return 0x8216C90C;  }
		/* 8216C900h case   12:*/		return 0x8216C904;
		  /* 8216C904h */ case   13:  		/* nop */
		/* 8216C904h case   13:*/		cpu::op::nop();
		/* 8216C904h case   13:*/		return 0x8216C908;
		  /* 8216C908h */ case   14:  		/* b 136 */
		/* 8216C908h case   14:*/		return 0x8216C990;
		/* 8216C908h case   14:*/		return 0x8216C90C;
	}
	return 0x8216C90C;
} // Block from 8216C8D0h-8216C90Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216C90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C90C);
		  /* 8216C90Ch */ case    0:  		/* li R28, 0 */
		/* 8216C90Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8216C90Ch case    0:*/		return 0x8216C910;
		  /* 8216C910h */ case    1:  		/* stw R28, <#[R31 + 80]> */
		/* 8216C910h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000050) );
		/* 8216C910h case    1:*/		return 0x8216C914;
		  /* 8216C914h */ case    2:  		/* cmplw CR6, R28, R26 */
		/* 8216C914h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R26);
		/* 8216C914h case    2:*/		return 0x8216C918;
		  /* 8216C918h */ case    3:  		/* bc 4, CR6_LT, 36 */
		/* 8216C918h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8216C93C;  }
		/* 8216C918h case    3:*/		return 0x8216C91C;
		  /* 8216C91Ch */ case    4:  		/* mullw R11, R28, R29 */
		/* 8216C91Ch case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R28,regs.R29);
		/* 8216C91Ch case    4:*/		return 0x8216C920;
		  /* 8216C920h */ case    5:  		/* add R3, R11, R30 */
		/* 8216C920h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 8216C920h case    5:*/		return 0x8216C924;
		  /* 8216C924h */ case    6:  		/* bl -2212 */
		/* 8216C924h case    6:*/		regs.LR = 0x8216C928; return 0x8216C080;
		/* 8216C924h case    6:*/		return 0x8216C928;
		  /* 8216C928h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8216C928h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C928h case    7:*/		return 0x8216C92C;
		  /* 8216C92Ch */ case    8:  		/* nop */
		/* 8216C92Ch case    8:*/		cpu::op::nop();
		/* 8216C92Ch case    8:*/		return 0x8216C930;
		  /* 8216C930h */ case    9:  		/* bc 12, CR0_LT, 96 */
		/* 8216C930h case    9:*/		if ( regs.CR[0].lt ) { return 0x8216C990;  }
		/* 8216C930h case    9:*/		return 0x8216C934;
		  /* 8216C934h */ case   10:  		/* addi R28, R28, 1 */
		/* 8216C934h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8216C934h case   10:*/		return 0x8216C938;
	}
	return 0x8216C938;
} // Block from 8216C90Ch-8216C938h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216C938h
// Function '?ValidateMicrocodeInstructions@@YAJPAUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C938);
		  /* 8216C938h */ case    0:  		/* b -40 */
		/* 8216C938h case    0:*/		return 0x8216C910;
		/* 8216C938h case    0:*/		return 0x8216C93C;
	}
	return 0x8216C93C;
} // Block from 8216C938h-8216C93Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C93C);
		  /* 8216C93Ch */ case    0:  		/* mr R3, R30 */
		/* 8216C93Ch case    0:*/		regs.R3 = regs.R30;
		/* 8216C93Ch case    0:*/		return 0x8216C940;
		  /* 8216C940h */ case    1:  		/* lbz R5, <#[R30 + 41]> */
		/* 8216C940h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000029) );
		/* 8216C940h case    1:*/		return 0x8216C944;
		  /* 8216C944h */ case    2:  		/* add R4, R30, R29 */
		/* 8216C944h case    2:*/		cpu::op::add<0>(regs,&regs.R4,regs.R30,regs.R29);
		/* 8216C944h case    2:*/		return 0x8216C948;
		  /* 8216C948h */ case    3:  		/* bl -968 */
		/* 8216C948h case    3:*/		regs.LR = 0x8216C94C; return 0x8216C580;
		/* 8216C948h case    3:*/		return 0x8216C94C;
		  /* 8216C94Ch */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8216C94Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216C94Ch case    4:*/		return 0x8216C950;
		  /* 8216C950h */ case    5:  		/* bc 4, CR0_LT, 12 */
		/* 8216C950h case    5:*/		if ( !regs.CR[0].lt ) { return 0x8216C95C;  }
		/* 8216C950h case    5:*/		return 0x8216C954;
		  /* 8216C954h */ case    6:  		/* nop */
		/* 8216C954h case    6:*/		cpu::op::nop();
		/* 8216C954h case    6:*/		return 0x8216C958;
		  /* 8216C958h */ case    7:  		/* b 56 */
		/* 8216C958h case    7:*/		return 0x8216C990;
		/* 8216C958h case    7:*/		return 0x8216C95C;
	}
	return 0x8216C95C;
} // Block from 8216C93Ch-8216C95Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216C95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C95C);
		  /* 8216C95Ch */ case    0:  		/* nop */
		/* 8216C95Ch case    0:*/		cpu::op::nop();
		/* 8216C95Ch case    0:*/		return 0x8216C960;
		  /* 8216C960h */ case    1:  		/* nop */
		/* 8216C960h case    1:*/		cpu::op::nop();
		/* 8216C960h case    1:*/		return 0x8216C964;
		  /* 8216C964h */ case    2:  		/* nop */
		/* 8216C964h case    2:*/		cpu::op::nop();
		/* 8216C964h case    2:*/		return 0x8216C968;
		  /* 8216C968h */ case    3:  		/* b 12 */
		/* 8216C968h case    3:*/		return 0x8216C974;
		/* 8216C968h case    3:*/		return 0x8216C96C;
	}
	return 0x8216C96C;
} // Block from 8216C95Ch-8216C96Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216C96Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C96C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C96C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C96C);
		  /* 8216C96Ch */ case    0:  		/* lwz R30, <#[R31 + 84]> */
		/* 8216C96Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000054) );
		/* 8216C96Ch case    0:*/		return 0x8216C970;
		  /* 8216C970h */ case    1:  		/* b 32 */
		/* 8216C970h case    1:*/		return 0x8216C990;
		/* 8216C970h case    1:*/		return 0x8216C974;
	}
	return 0x8216C974;
} // Block from 8216C96Ch-8216C974h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216C974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C974);
		  /* 8216C974h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8216C974h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216C974h case    0:*/		return 0x8216C978;
		  /* 8216C978h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8216C978h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216C988;  }
		/* 8216C978h case    1:*/		return 0x8216C97C;
		  /* 8216C97Ch */ case    2:  		/* lis R4, 9351 */
		/* 8216C97Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2487);
		/* 8216C97Ch case    2:*/		return 0x8216C980;
		  /* 8216C980h */ case    3:  		/* mr R3, R30 */
		/* 8216C980h case    3:*/		regs.R3 = regs.R30;
		/* 8216C980h case    3:*/		return 0x8216C984;
		  /* 8216C984h */ case    4:  		/* bl -935500 */
		/* 8216C984h case    4:*/		regs.LR = 0x8216C988; return 0x82088338;
		/* 8216C984h case    4:*/		return 0x8216C988;
	}
	return 0x8216C988;
} // Block from 8216C974h-8216C988h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216C988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C988);
		  /* 8216C988h */ case    0:  		/* li R3, 1 */
		/* 8216C988h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216C988h case    0:*/		return 0x8216C98C;
		  /* 8216C98Ch */ case    1:  		/* b 28 */
		/* 8216C98Ch case    1:*/		return 0x8216C9A8;
		/* 8216C98Ch case    1:*/		return 0x8216C990;
	}
	return 0x8216C990;
} // Block from 8216C988h-8216C990h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216C990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C990);
		  /* 8216C990h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8216C990h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216C990h case    0:*/		return 0x8216C994;
		  /* 8216C994h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8216C994h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216C9A4;  }
		/* 8216C994h case    1:*/		return 0x8216C998;
		  /* 8216C998h */ case    2:  		/* lis R4, 9351 */
		/* 8216C998h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2487);
		/* 8216C998h case    2:*/		return 0x8216C99C;
		  /* 8216C99Ch */ case    3:  		/* mr R3, R30 */
		/* 8216C99Ch case    3:*/		regs.R3 = regs.R30;
		/* 8216C99Ch case    3:*/		return 0x8216C9A0;
		  /* 8216C9A0h */ case    4:  		/* bl -935528 */
		/* 8216C9A0h case    4:*/		regs.LR = 0x8216C9A4; return 0x82088338;
		/* 8216C9A0h case    4:*/		return 0x8216C9A4;
	}
	return 0x8216C9A4;
} // Block from 8216C990h-8216C9A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216C9A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C9A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C9A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C9A4);
		  /* 8216C9A4h */ case    0:  		/* li R3, 0 */
		/* 8216C9A4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216C9A4h case    0:*/		return 0x8216C9A8;
	}
	return 0x8216C9A8;
} // Block from 8216C9A4h-8216C9A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C9A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C9A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C9A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C9A8);
		  /* 8216C9A8h */ case    0:  		/* addi R1, R31, 144 */
		/* 8216C9A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x90);
		/* 8216C9A8h case    0:*/		return 0x8216C9AC;
		  /* 8216C9ACh */ case    1:  		/* b -898828 */
		/* 8216C9ACh case    1:*/		return 0x820912A0;
		/* 8216C9ACh case    1:*/		return 0x8216C9B0;
	}
	return 0x8216C9B0;
} // Block from 8216C9A8h-8216C9B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216C9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C9B0);
		  /* 8216C9B0h */ case    0:  		/* li R3, 1 */
		/* 8216C9B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216C9B0h case    0:*/		return 0x8216C9B4;
		  /* 8216C9B4h */ case    1:  		/* nop */
		/* 8216C9B4h case    1:*/		cpu::op::nop();
		/* 8216C9B4h case    1:*/		return 0x8216C9B8;
		  /* 8216C9B8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216C9B8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216C9B8h case    2:*/		return 0x8216C9BC;
	}
	return 0x8216C9BC;
} // Block from 8216C9B0h-8216C9BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216C9BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C9BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C9BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C9BC);
		  /* 8216C9BCh */ case    0:  		/* nop */
		/* 8216C9BCh case    0:*/		cpu::op::nop();
		/* 8216C9BCh case    0:*/		return 0x8216C9C0;
	}
	return 0x8216C9C0;
} // Block from 8216C9BCh-8216C9C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216C9C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C9C0);
		  /* 8216C9C0h */ case    0:  		/* li R4, 1 */
		/* 8216C9C0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216C9C0h case    0:*/		return 0x8216C9C4;
		  /* 8216C9C4h */ case    1:  		/* b -372 */
		/* 8216C9C4h case    1:*/		return 0x8216C850;
		/* 8216C9C4h case    1:*/		return 0x8216C9C8;
	}
	return 0x8216C9C8;
} // Block from 8216C9C0h-8216C9C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216C9C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C9C8);
		  /* 8216C9C8h */ case    0:  		/* li R4, 0 */
		/* 8216C9C8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216C9C8h case    0:*/		return 0x8216C9CC;
		  /* 8216C9CCh */ case    1:  		/* b -380 */
		/* 8216C9CCh case    1:*/		return 0x8216C850;
		/* 8216C9CCh case    1:*/		return 0x8216C9D0;
	}
	return 0x8216C9D0;
} // Block from 8216C9C8h-8216C9D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216C9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216C9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216C9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216C9D0);
		  /* 8216C9D0h */ case    0:  		/* mfspr R12, LR */
		/* 8216C9D0h case    0:*/		regs.R12 = regs.LR;
		/* 8216C9D0h case    0:*/		return 0x8216C9D4;
		  /* 8216C9D4h */ case    1:  		/* bl -898936 */
		/* 8216C9D4h case    1:*/		regs.LR = 0x8216C9D8; return 0x8209125C;
		/* 8216C9D4h case    1:*/		return 0x8216C9D8;
		  /* 8216C9D8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216C9D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216C9D8h case    2:*/		return 0x8216C9DC;
		  /* 8216C9DCh */ case    3:  		/* addi R11, R4, 23 */
		/* 8216C9DCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x17);
		/* 8216C9DCh case    3:*/		return 0x8216C9E0;
		  /* 8216C9E0h */ case    4:  		/* mr R31, R5 */
		/* 8216C9E0h case    4:*/		regs.R31 = regs.R5;
		/* 8216C9E0h case    4:*/		return 0x8216C9E4;
		  /* 8216C9E4h */ case    5:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 8216C9E4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 8216C9E4h case    5:*/		return 0x8216C9E8;
		  /* 8216C9E8h */ case    6:  		/* mr R29, R3 */
		/* 8216C9E8h case    6:*/		regs.R29 = regs.R3;
		/* 8216C9E8h case    6:*/		return 0x8216C9EC;
		  /* 8216C9ECh */ case    7:  		/* lwzx R5, <#[R30 + R3]> */
		/* 8216C9ECh case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + regs.R3 + 0x00000000) );
		/* 8216C9ECh case    7:*/		return 0x8216C9F0;
		  /* 8216C9F0h */ case    8:  		/* cmplwi CR6, R5, 0 */
		/* 8216C9F0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8216C9F0h case    8:*/		return 0x8216C9F4;
		  /* 8216C9F4h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 8216C9F4h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216CA00;  }
		/* 8216C9F4h case    9:*/		return 0x8216C9F8;
		  /* 8216C9F8h */ case   10:  		/* mr R3, R31 */
		/* 8216C9F8h case   10:*/		regs.R3 = regs.R31;
		/* 8216C9F8h case   10:*/		return 0x8216C9FC;
		  /* 8216C9FCh */ case   11:  		/* bl 49020 */
		/* 8216C9FCh case   11:*/		regs.LR = 0x8216CA00; return 0x82178978;
		/* 8216C9FCh case   11:*/		return 0x8216CA00;
	}
	return 0x8216CA00;
} // Block from 8216C9D0h-8216CA00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216CA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CA00);
		  /* 8216CA00h */ case    0:  		/* stwx R31, <#[R30 + R29]> */
		/* 8216CA00h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 8216CA00h case    0:*/		return 0x8216CA04;
		  /* 8216CA04h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216CA04h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216CA04h case    1:*/		return 0x8216CA08;
		  /* 8216CA08h */ case    2:  		/* oris R11, R11, 512 */
		/* 8216CA08h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8216CA08h case    2:*/		return 0x8216CA0C;
		  /* 8216CA0Ch */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 8216CA0Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216CA0Ch case    3:*/		return 0x8216CA10;
		  /* 8216CA10h */ case    4:  		/* addi R1, R1, 112 */
		/* 8216CA10h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216CA10h case    4:*/		return 0x8216CA14;
		  /* 8216CA14h */ case    5:  		/* b -898920 */
		/* 8216CA14h case    5:*/		return 0x820912AC;
		/* 8216CA14h case    5:*/		return 0x8216CA18;
		  /* 8216CA18h */ case    6:  		/* lwz R11, <#[R4 + 48]> */
		/* 8216CA18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 8216CA18h case    6:*/		return 0x8216CA1C;
		  /* 8216CA1Ch */ case    7:  		/* lwz R10, <#[R3 + 48]> */
		/* 8216CA1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 8216CA1Ch case    7:*/		return 0x8216CA20;
		  /* 8216CA20h */ case    8:  		/* xor R11, R11, R10 */
		/* 8216CA20h case    8:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216CA20h case    8:*/		return 0x8216CA24;
		  /* 8216CA24h */ case    9:  		/* rlwinm. R11, R11, 0, 8, 8 */
		/* 8216CA24h case    9:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R11);
		/* 8216CA24h case    9:*/		return 0x8216CA28;
		  /* 8216CA28h */ case   10:  		/* bc 4, CR0_EQ, 128 */
		/* 8216CA28h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216CAA8;  }
		/* 8216CA28h case   10:*/		return 0x8216CA2C;
		  /* 8216CA2Ch */ case   11:  		/* lwz R10, <#[R4 + 76]> */
		/* 8216CA2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000004C) );
		/* 8216CA2Ch case   11:*/		return 0x8216CA30;
		  /* 8216CA30h */ case   12:  		/* lwz R11, <#[R3 + 76]> */
		/* 8216CA30h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216CA30h case   12:*/		return 0x8216CA34;
		  /* 8216CA34h */ case   13:  		/* rlwinm R8, R10, 8, 31, 31 */
		/* 8216CA34h case   13:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R8,regs.R10);
		/* 8216CA34h case   13:*/		return 0x8216CA38;
		  /* 8216CA38h */ case   14:  		/* rlwinm R9, R11, 8, 31, 31 */
		/* 8216CA38h case   14:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R9,regs.R11);
		/* 8216CA38h case   14:*/		return 0x8216CA3C;
		  /* 8216CA3Ch */ case   15:  		/* cmplw CR6, R9, R8 */
		/* 8216CA3Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8216CA3Ch case   15:*/		return 0x8216CA40;
		  /* 8216CA40h */ case   16:  		/* bc 4, CR6_EQ, 104 */
		/* 8216CA40h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8216CAA8;  }
		/* 8216CA40h case   16:*/		return 0x8216CA44;
		  /* 8216CA44h */ case   17:  		/* cmplwi CR6, R9, 0 */
		/* 8216CA44h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8216CA44h case   17:*/		return 0x8216CA48;
		  /* 8216CA48h */ case   18:  		/* bc 12, CR6_EQ, 68 */
		/* 8216CA48h case   18:*/		if ( regs.CR[6].eq ) { return 0x8216CA8C;  }
		/* 8216CA48h case   18:*/		return 0x8216CA4C;
		  /* 8216CA4Ch */ case   19:  		/* xor R8, R11, R10 */
		/* 8216CA4Ch case   19:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8216CA4Ch case   19:*/		return 0x8216CA50;
		  /* 8216CA50h */ case   20:  		/* rlwinm. R8, R8, 0, 6, 6 */
		/* 8216CA50h case   20:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R8,regs.R8);
		/* 8216CA50h case   20:*/		return 0x8216CA54;
		  /* 8216CA54h */ case   21:  		/* bc 4, CR0_EQ, 84 */
		/* 8216CA54h case   21:*/		if ( !regs.CR[0].eq ) { return 0x8216CAA8;  }
		/* 8216CA54h case   21:*/		return 0x8216CA58;
		  /* 8216CA58h */ case   22:  		/* lwz R8, <#[R3 + 108]> */
		/* 8216CA58h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000006C) );
		/* 8216CA58h case   22:*/		return 0x8216CA5C;
		  /* 8216CA5Ch */ case   23:  		/* lwz R7, <#[R4 + 108]> */
		/* 8216CA5Ch case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x0000006C) );
		/* 8216CA5Ch case   23:*/		return 0x8216CA60;
		  /* 8216CA60h */ case   24:  		/* cmplw CR6, R8, R7 */
		/* 8216CA60h case   24:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8216CA60h case   24:*/		return 0x8216CA64;
		  /* 8216CA64h */ case   25:  		/* bc 4, CR6_EQ, 68 */
		/* 8216CA64h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8216CAA8;  }
		/* 8216CA64h case   25:*/		return 0x8216CA68;
		  /* 8216CA68h */ case   26:  		/* lwz R8, <#[R4 + 72]> */
		/* 8216CA68h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000048) );
		/* 8216CA68h case   26:*/		return 0x8216CA6C;
		  /* 8216CA6Ch */ case   27:  		/* lwz R7, <#[R3 + 72]> */
		/* 8216CA6Ch case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000048) );
		/* 8216CA6Ch case   27:*/		return 0x8216CA70;
		  /* 8216CA70h */ case   28:  		/* lwz R8, <#[R8]> */
		/* 8216CA70h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 8216CA70h case   28:*/		return 0x8216CA74;
		  /* 8216CA74h */ case   29:  		/* lwz R7, <#[R7]> */
		/* 8216CA74h case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 8216CA74h case   29:*/		return 0x8216CA78;
		  /* 8216CA78h */ case   30:  		/* xor R8, R8, R7 */
		/* 8216CA78h case   30:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8216CA78h case   30:*/		return 0x8216CA7C;
		  /* 8216CA7Ch */ case   31:  		/* rlwinm. R8, R8, 0, 7, 18 */
		/* 8216CA7Ch case   31:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R8,regs.R8);
		/* 8216CA7Ch case   31:*/		return 0x8216CA80;
		  /* 8216CA80h */ case   32:  		/* bc 4, CR0_EQ, 40 */
		/* 8216CA80h case   32:*/		if ( !regs.CR[0].eq ) { return 0x8216CAA8;  }
		/* 8216CA80h case   32:*/		return 0x8216CA84;
		  /* 8216CA84h */ case   33:  		/* cmplwi CR6, R9, 0 */
		/* 8216CA84h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8216CA84h case   33:*/		return 0x8216CA88;
		  /* 8216CA88h */ case   34:  		/* bc 4, CR6_EQ, 24 */
		/* 8216CA88h case   34:*/		if ( !regs.CR[6].eq ) { return 0x8216CAA0;  }
		/* 8216CA88h case   34:*/		return 0x8216CA8C;
	}
	return 0x8216CA8C;
} // Block from 8216CA00h-8216CA8Ch (35 instructions)

//////////////////////////////////////////////////////
// Block at 8216CA8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CA8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CA8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CA8C);
		  /* 8216CA8Ch */ case    0:  		/* rlwinm. R9, R11, 0, 9, 9 */
		/* 8216CA8Ch case    0:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R9,regs.R11);
		/* 8216CA8Ch case    0:*/		return 0x8216CA90;
		  /* 8216CA90h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8216CA90h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216CAA0;  }
		/* 8216CA90h case    1:*/		return 0x8216CA94;
		  /* 8216CA94h */ case    2:  		/* xor R11, R11, R10 */
		/* 8216CA94h case    2:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216CA94h case    2:*/		return 0x8216CA98;
		  /* 8216CA98h */ case    3:  		/* rlwinm. R11, R11, 0, 8, 8 */
		/* 8216CA98h case    3:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R11);
		/* 8216CA98h case    3:*/		return 0x8216CA9C;
		  /* 8216CA9Ch */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 8216CA9Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216CAA8;  }
		/* 8216CA9Ch case    4:*/		return 0x8216CAA0;
	}
	return 0x8216CAA0;
} // Block from 8216CA8Ch-8216CAA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CAA0);
		  /* 8216CAA0h */ case    0:  		/* li R3, 1 */
		/* 8216CAA0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216CAA0h case    0:*/		return 0x8216CAA4;
		  /* 8216CAA4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216CAA4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CAA4h case    1:*/		return 0x8216CAA8;
	}
	return 0x8216CAA8;
} // Block from 8216CAA0h-8216CAA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CAA8);
		  /* 8216CAA8h */ case    0:  		/* li R3, 0 */
		/* 8216CAA8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216CAA8h case    0:*/		return 0x8216CAAC;
		  /* 8216CAACh */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216CAACh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CAACh case    1:*/		return 0x8216CAB0;
	}
	return 0x8216CAB0;
} // Block from 8216CAA8h-8216CAB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CAB0);
		  /* 8216CAB0h */ case    0:  		/* mfspr R12, LR */
		/* 8216CAB0h case    0:*/		regs.R12 = regs.LR;
		/* 8216CAB0h case    0:*/		return 0x8216CAB4;
		  /* 8216CAB4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216CAB4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CAB4h case    1:*/		return 0x8216CAB8;
		  /* 8216CAB8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8216CAB8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216CAB8h case    2:*/		return 0x8216CABC;
		  /* 8216CABCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216CABCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216CABCh case    3:*/		return 0x8216CAC0;
		  /* 8216CAC0h */ case    4:  		/* li R11, 0 */
		/* 8216CAC0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216CAC0h case    4:*/		return 0x8216CAC4;
		  /* 8216CAC4h */ case    5:  		/* stw R4, <#[R3]> */
		/* 8216CAC4h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8216CAC4h case    5:*/		return 0x8216CAC8;
		  /* 8216CAC8h */ case    6:  		/* stb R5, <#[R3 + 24]> */
		/* 8216CAC8h case    6:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 8216CAC8h case    6:*/		return 0x8216CACC;
		  /* 8216CACCh */ case    7:  		/* mr R31, R3 */
		/* 8216CACCh case    7:*/		regs.R31 = regs.R3;
		/* 8216CACCh case    7:*/		return 0x8216CAD0;
		  /* 8216CAD0h */ case    8:  		/* stw R11, <#[R3 + 8]> */
		/* 8216CAD0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216CAD0h case    8:*/		return 0x8216CAD4;
		  /* 8216CAD4h */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 8216CAD4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8216CAD4h case    9:*/		return 0x8216CAD8;
		  /* 8216CAD8h */ case   10:  		/* stw R11, <#[R3 + 20]> */
		/* 8216CAD8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8216CAD8h case   10:*/		return 0x8216CADC;
		  /* 8216CADCh */ case   11:  		/* lwz R4, <#[R4 + 8]> */
		/* 8216CADCh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000008) );
		/* 8216CADCh case   11:*/		return 0x8216CAE0;
		  /* 8216CAE0h */ case   12:  		/* bl 798432 */
		/* 8216CAE0h case   12:*/		regs.LR = 0x8216CAE4; return 0x8222F9C0;
		/* 8216CAE0h case   12:*/		return 0x8216CAE4;
		  /* 8216CAE4h */ case   13:  		/* mr R3, R31 */
		/* 8216CAE4h case   13:*/		regs.R3 = regs.R31;
		/* 8216CAE4h case   13:*/		return 0x8216CAE8;
		  /* 8216CAE8h */ case   14:  		/* addi R1, R1, 96 */
		/* 8216CAE8h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216CAE8h case   14:*/		return 0x8216CAEC;
		  /* 8216CAECh */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216CAECh case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CAECh case   15:*/		return 0x8216CAF0;
	}
	return 0x8216CAF0;
} // Block from 8216CAB0h-8216CAF0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216CAF0h
// Function '?XGValidateMicrocodeLite2@@YAJPAUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CAF0);
		  /* 8216CAF0h */ case    0:  		/* mtspr LR, R12 */
		/* 8216CAF0h case    0:*/		regs.LR = regs.R12;
		/* 8216CAF0h case    0:*/		return 0x8216CAF4;
		  /* 8216CAF4h */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 8216CAF4h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216CAF4h case    1:*/		return 0x8216CAF8;
		  /* 8216CAF8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216CAF8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CAF8h case    2:*/		return 0x8216CAFC;
	}
	return 0x8216CAFC;
} // Block from 8216CAF0h-8216CAFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216CAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CAFC);
		  /* 8216CAFCh */ case    0:  		/* nop */
		/* 8216CAFCh case    0:*/		cpu::op::nop();
		/* 8216CAFCh case    0:*/		return 0x8216CB00;
	}
	return 0x8216CB00;
} // Block from 8216CAFCh-8216CB00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CB00);
		  /* 8216CB00h */ case    0:  		/* mfspr R12, LR */
		/* 8216CB00h case    0:*/		regs.R12 = regs.LR;
		/* 8216CB00h case    0:*/		return 0x8216CB04;
		  /* 8216CB04h */ case    1:  		/* bl -899244 */
		/* 8216CB04h case    1:*/		regs.LR = 0x8216CB08; return 0x82091258;
		/* 8216CB04h case    1:*/		return 0x8216CB08;
		  /* 8216CB08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216CB08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216CB08h case    2:*/		return 0x8216CB0C;
		  /* 8216CB0Ch */ case    3:  		/* mr R31, R3 */
		/* 8216CB0Ch case    3:*/		regs.R31 = regs.R3;
		/* 8216CB0Ch case    3:*/		return 0x8216CB10;
		  /* 8216CB10h */ case    4:  		/* li R30, 0 */
		/* 8216CB10h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216CB10h case    4:*/		return 0x8216CB14;
		  /* 8216CB14h */ case    5:  		/* b 56 */
		/* 8216CB14h case    5:*/		return 0x8216CB4C;
		/* 8216CB14h case    5:*/		return 0x8216CB18;
		  /* 8216CB18h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 8216CB18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8216CB18h case    6:*/		return 0x8216CB1C;
		  /* 8216CB1Ch */ case    7:  		/* stw R30, <#[R31 + 16]> */
		/* 8216CB1Ch case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 8216CB1Ch case    7:*/		return 0x8216CB20;
		  /* 8216CB20h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8216CB20h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216CB20h case    8:*/		return 0x8216CB24;
		  /* 8216CB24h */ case    9:  		/* stw R30, <#[R31 + 20]> */
		/* 8216CB24h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 8216CB24h case    9:*/		return 0x8216CB28;
		  /* 8216CB28h */ case   10:  		/* bc 12, CR6_EQ, 112 */
		/* 8216CB28h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216CB98;  }
		/* 8216CB28h case   10:*/		return 0x8216CB2C;
		  /* 8216CB2Ch */ case   11:  		/* lwz R29, <#[R11 + 4]> */
		/* 8216CB2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CB2Ch case   11:*/		return 0x8216CB30;
		  /* 8216CB30h */ case   12:  		/* mr R3, R31 */
		/* 8216CB30h case   12:*/		regs.R3 = regs.R31;
		/* 8216CB30h case   12:*/		return 0x8216CB34;
		  /* 8216CB34h */ case   13:  		/* stw R11, <#[R31 + 12]> */
		/* 8216CB34h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216CB34h case   13:*/		return 0x8216CB38;
		  /* 8216CB38h */ case   14:  		/* lbz R28, <#[R31 + 25]> */
		/* 8216CB38h case   14:*/		cpu::mem::load8z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000019) );
		/* 8216CB38h case   14:*/		return 0x8216CB3C;
		  /* 8216CB3Ch */ case   15:  		/* lwz R4, <#[R11 + 12]> */
		/* 8216CB3Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216CB3Ch case   15:*/		return 0x8216CB40;
		  /* 8216CB40h */ case   16:  		/* bl 798336 */
		/* 8216CB40h case   16:*/		regs.LR = 0x8216CB44; return 0x8222F9C0;
		/* 8216CB40h case   16:*/		return 0x8216CB44;
		  /* 8216CB44h */ case   17:  		/* cmplwi CR0, R28, 0 */
		/* 8216CB44h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R28,0x00000000);
		/* 8216CB44h case   17:*/		return 0x8216CB48;
		  /* 8216CB48h */ case   18:  		/* bc 12, CR0_EQ, 72 */
		/* 8216CB48h case   18:*/		if ( regs.CR[0].eq ) { return 0x8216CB90;  }
		/* 8216CB48h case   18:*/		return 0x8216CB4C;
	}
	return 0x8216CB4C;
} // Block from 8216CB00h-8216CB4Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216CB4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CB4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CB4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CB4C);
		  /* 8216CB4Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216CB4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216CB4Ch case    0:*/		return 0x8216CB50;
		  /* 8216CB50h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216CB50h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216CB50h case    1:*/		return 0x8216CB54;
		  /* 8216CB54h */ case    2:  		/* bc 12, CR6_EQ, -60 */
		/* 8216CB54h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216CB18;  }
		/* 8216CB54h case    2:*/		return 0x8216CB58;
		  /* 8216CB58h */ case    3:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8216CB58h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8216CB58h case    3:*/		return 0x8216CB5C;
		  /* 8216CB5Ch */ case    4:  		/* lwz R3, <#[R11]> */
		/* 8216CB5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CB5Ch case    4:*/		return 0x8216CB60;
		  /* 8216CB60h */ case    5:  		/* stw R30, <#[R31 + 12]> */
		/* 8216CB60h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216CB60h case    5:*/		return 0x8216CB64;
		  /* 8216CB64h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216CB64h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CB64h case    6:*/		return 0x8216CB68;
		  /* 8216CB68h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8216CB68h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216CB68h case    7:*/		return 0x8216CB6C;
		  /* 8216CB6Ch */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 8216CB6Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216CB6Ch case    8:*/		return 0x8216CB70;
		  /* 8216CB70h */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 8216CB70h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216CB9C;  }
		/* 8216CB70h case    9:*/		return 0x8216CB74;
		  /* 8216CB74h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 8216CB74h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CB74h case   10:*/		return 0x8216CB78;
		  /* 8216CB78h */ case   11:  		/* lwz R10, <#[R10 + 48]> */
		/* 8216CB78h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 8216CB78h case   11:*/		return 0x8216CB7C;
		  /* 8216CB7Ch */ case   12:  		/* rlwinm. R9, R10, 10, 31, 31 */
		/* 8216CB7Ch case   12:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R9,regs.R10);
		/* 8216CB7Ch case   12:*/		return 0x8216CB80;
		  /* 8216CB80h */ case   13:  		/* bc 4, CR0_EQ, -28 */
		/* 8216CB80h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8216CB64;  }
		/* 8216CB80h case   13:*/		return 0x8216CB84;
		  /* 8216CB84h */ case   14:  		/* rlwinm. R10, R10, 12, 31, 31 */
		/* 8216CB84h case   14:*/		cpu::op::rlwinm<1,12,31,31>(regs,&regs.R10,regs.R10);
		/* 8216CB84h case   14:*/		return 0x8216CB88;
		  /* 8216CB88h */ case   15:  		/* bc 12, CR0_EQ, -36 */
		/* 8216CB88h case   15:*/		if ( regs.CR[0].eq ) { return 0x8216CB64;  }
		/* 8216CB88h case   15:*/		return 0x8216CB8C;
		  /* 8216CB8Ch */ case   16:  		/* b 16 */
		/* 8216CB8Ch case   16:*/		return 0x8216CB9C;
		/* 8216CB8Ch case   16:*/		return 0x8216CB90;
	}
	return 0x8216CB90;
} // Block from 8216CB4Ch-8216CB90h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216CB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CB90);
		  /* 8216CB90h */ case    0:  		/* mr R3, R29 */
		/* 8216CB90h case    0:*/		regs.R3 = regs.R29;
		/* 8216CB90h case    0:*/		return 0x8216CB94;
		  /* 8216CB94h */ case    1:  		/* b 8 */
		/* 8216CB94h case    1:*/		return 0x8216CB9C;
		/* 8216CB94h case    1:*/		return 0x8216CB98;
	}
	return 0x8216CB98;
} // Block from 8216CB90h-8216CB98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CB98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CB98);
		  /* 8216CB98h */ case    0:  		/* li R3, 0 */
		/* 8216CB98h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216CB98h case    0:*/		return 0x8216CB9C;
	}
	return 0x8216CB9C;
} // Block from 8216CB98h-8216CB9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CB9C);
		  /* 8216CB9Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8216CB9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216CB9Ch case    0:*/		return 0x8216CBA0;
		  /* 8216CBA0h */ case    1:  		/* b -899320 */
		/* 8216CBA0h case    1:*/		return 0x820912A8;
		/* 8216CBA0h case    1:*/		return 0x8216CBA4;
		  /* 8216CBA4h */ case    2:  		/* nop */
		/* 8216CBA4h case    2:*/		cpu::op::nop();
		/* 8216CBA4h case    2:*/		return 0x8216CBA8;
	}
	return 0x8216CBA8;
} // Block from 8216CB9Ch-8216CBA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216CBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CBA8);
		  /* 8216CBA8h */ case    0:  		/* mfspr R12, LR */
		/* 8216CBA8h case    0:*/		regs.R12 = regs.LR;
		/* 8216CBA8h case    0:*/		return 0x8216CBAC;
		  /* 8216CBACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216CBACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CBACh case    1:*/		return 0x8216CBB0;
		  /* 8216CBB0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8216CBB0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216CBB0h case    2:*/		return 0x8216CBB4;
		  /* 8216CBB4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216CBB4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216CBB4h case    3:*/		return 0x8216CBB8;
		  /* 8216CBB8h */ case    4:  		/* lwz R9, <#[R3 + 952]> */
		/* 8216CBB8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x000003B8) );
		/* 8216CBB8h case    4:*/		return 0x8216CBBC;
		  /* 8216CBBCh */ case    5:  		/* addi R11, R3, 812 */
		/* 8216CBBCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x32C);
		/* 8216CBBCh case    5:*/		return 0x8216CBC0;
		  /* 8216CBC0h */ case    6:  		/* lwz R10, <#[R3 + 956]> */
		/* 8216CBC0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000003BC) );
		/* 8216CBC0h case    6:*/		return 0x8216CBC4;
		  /* 8216CBC4h */ case    7:  		/* subf R9, R10, R9 */
		/* 8216CBC4h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8216CBC4h case    7:*/		return 0x8216CBC8;
		  /* 8216CBC8h */ case    8:  		/* addi R9, R9, 4096 */
		/* 8216CBC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 8216CBC8h case    8:*/		return 0x8216CBCC;
		  /* 8216CBCCh */ case    9:  		/* cmplw CR6, R9, R4 */
		/* 8216CBCCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 8216CBCCh case    9:*/		return 0x8216CBD0;
		  /* 8216CBD0h */ case   10:  		/* bc 12, CR6_LT, 20 */
		/* 8216CBD0h case   10:*/		if ( regs.CR[6].lt ) { return 0x8216CBE4;  }
		/* 8216CBD0h case   10:*/		return 0x8216CBD4;
		  /* 8216CBD4h */ case   11:  		/* add R9, R10, R4 */
		/* 8216CBD4h case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 8216CBD4h case   11:*/		return 0x8216CBD8;
		  /* 8216CBD8h */ case   12:  		/* mr R3, R10 */
		/* 8216CBD8h case   12:*/		regs.R3 = regs.R10;
		/* 8216CBD8h case   12:*/		return 0x8216CBDC;
		  /* 8216CBDCh */ case   13:  		/* stw R9, <#[R11 + 144]> */
		/* 8216CBDCh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000090) );
		/* 8216CBDCh case   13:*/		return 0x8216CBE0;
		  /* 8216CBE0h */ case   14:  		/* b 68 */
		/* 8216CBE0h case   14:*/		return 0x8216CC24;
		/* 8216CBE0h case   14:*/		return 0x8216CBE4;
	}
	return 0x8216CBE4;
} // Block from 8216CBA8h-8216CBE4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216CBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CBE4);
		  /* 8216CBE4h */ case    0:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 8216CBE4h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 8216CBE4h case    0:*/		return 0x8216CBE8;
		  /* 8216CBE8h */ case    1:  		/* addi R10, R10, -1 */
		/* 8216CBE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216CBE8h case    1:*/		return 0x8216CBEC;
		  /* 8216CBECh */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216CBECh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216CBECh case    2:*/		return 0x8216CBF0;
		  /* 8216CBF0h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 8216CBF0h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8216CBF0h case    3:*/		return 0x8216CBF4;
		  /* 8216CBF4h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216CBF4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216CBF4h case    4:*/		return 0x8216CBF8;
		  /* 8216CBF8h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 8216CBF8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216CC1C;  }
		/* 8216CBF8h case    5:*/		return 0x8216CBFC;
		  /* 8216CBFCh */ case    6:  		/* lwz R9, <#[R31]> */
		/* 8216CBFCh case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216CBFCh case    6:*/		return 0x8216CC00;
		  /* 8216CC00h */ case    7:  		/* mr R5, R4 */
		/* 8216CC00h case    7:*/		regs.R5 = regs.R4;
		/* 8216CC00h case    7:*/		return 0x8216CC04;
		  /* 8216CC04h */ case    8:  		/* li R4, 0 */
		/* 8216CC04h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216CC04h case    8:*/		return 0x8216CC08;
		  /* 8216CC08h */ case    9:  		/* mr R3, R31 */
		/* 8216CC08h case    9:*/		regs.R3 = regs.R31;
		/* 8216CC08h case    9:*/		return 0x8216CC0C;
		  /* 8216CC0Ch */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 8216CC0Ch case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8216CC0Ch case   10:*/		return 0x8216CC10;
		  /* 8216CC10h */ case   11:  		/* bl -899280 */
		/* 8216CC10h case   11:*/		regs.LR = 0x8216CC14; return 0x82091340;
		/* 8216CC10h case   11:*/		return 0x8216CC14;
		  /* 8216CC14h */ case   12:  		/* mr R3, R31 */
		/* 8216CC14h case   12:*/		regs.R3 = regs.R31;
		/* 8216CC14h case   12:*/		return 0x8216CC18;
		  /* 8216CC18h */ case   13:  		/* b 12 */
		/* 8216CC18h case   13:*/		return 0x8216CC24;
		/* 8216CC18h case   13:*/		return 0x8216CC1C;
	}
	return 0x8216CC1C;
} // Block from 8216CBE4h-8216CC1Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC1C);
		  /* 8216CC1Ch */ case    0:  		/* mr R3, R11 */
		/* 8216CC1Ch case    0:*/		regs.R3 = regs.R11;
		/* 8216CC1Ch case    0:*/		return 0x8216CC20;
		  /* 8216CC20h */ case    1:  		/* bl -34352 */
		/* 8216CC20h case    1:*/		regs.LR = 0x8216CC24; return 0x821645F0;
		/* 8216CC20h case    1:*/		return 0x8216CC24;
	}
	return 0x8216CC24;
} // Block from 8216CC1Ch-8216CC24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC24);
		  /* 8216CC24h */ case    0:  		/* addi R1, R1, 96 */
		/* 8216CC24h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216CC24h case    0:*/		return 0x8216CC28;
		  /* 8216CC28h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216CC28h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CC28h case    1:*/		return 0x8216CC2C;
		  /* 8216CC2Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8216CC2Ch case    2:*/		regs.LR = regs.R12;
		/* 8216CC2Ch case    2:*/		return 0x8216CC30;
		  /* 8216CC30h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8216CC30h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216CC30h case    3:*/		return 0x8216CC34;
		  /* 8216CC34h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216CC34h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CC34h case    4:*/		return 0x8216CC38;
	}
	return 0x8216CC38;
} // Block from 8216CC24h-8216CC38h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC38);
		  /* 8216CC38h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8216CC38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8216CC38h case    0:*/		return 0x8216CC3C;
		  /* 8216CC3Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216CC3Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216CC3Ch case    1:*/		return 0x8216CC40;
		  /* 8216CC40h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 8216CC40h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216CC7C;  }
		/* 8216CC40h case    2:*/		return 0x8216CC44;
		  /* 8216CC44h */ case    3:  		/* lwz R9, <#[R11]> */
		/* 8216CC44h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CC44h case    3:*/		return 0x8216CC48;
		  /* 8216CC48h */ case    4:  		/* rlwinm. R10, R9, 0, 1, 1 */
		/* 8216CC48h case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R9);
		/* 8216CC48h case    4:*/		return 0x8216CC4C;
		  /* 8216CC4Ch */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 8216CC4Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8216CC5C;  }
		/* 8216CC4Ch case    5:*/		return 0x8216CC50;
		  /* 8216CC50h */ case    6:  		/* rlwinm. R10, R9, 0, 4, 6 */
		/* 8216CC50h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R9);
		/* 8216CC50h case    6:*/		return 0x8216CC54;
		  /* 8216CC54h */ case    7:  		/* li R10, 1 */
		/* 8216CC54h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216CC54h case    7:*/		return 0x8216CC58;
		  /* 8216CC58h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 8216CC58h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216CC60;  }
		/* 8216CC58h case    8:*/		return 0x8216CC5C;
	}
	return 0x8216CC5C;
} // Block from 8216CC38h-8216CC5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC5C);
		  /* 8216CC5Ch */ case    0:  		/* li R10, 0 */
		/* 8216CC5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216CC5Ch case    0:*/		return 0x8216CC60;
	}
	return 0x8216CC60;
} // Block from 8216CC5Ch-8216CC60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC60);
		  /* 8216CC60h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8216CC60h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8216CC60h case    0:*/		return 0x8216CC64;
		  /* 8216CC64h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8216CC64h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216CC74;  }
		/* 8216CC64h case    1:*/		return 0x8216CC68;
		  /* 8216CC68h */ case    2:  		/* rlwinm R10, R9, 0, 7, 18 */
		/* 8216CC68h case    2:*/		cpu::op::rlwinm<0,0,7,18>(regs,&regs.R10,regs.R9);
		/* 8216CC68h case    2:*/		return 0x8216CC6C;
		  /* 8216CC6Ch */ case    3:  		/* cmplwi CR6, R10, 57344 */
		/* 8216CC6Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000E000);
		/* 8216CC6Ch case    3:*/		return 0x8216CC70;
		  /* 8216CC70h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 8216CC70h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216CC90;  }
		/* 8216CC70h case    4:*/		return 0x8216CC74;
	}
	return 0x8216CC74;
} // Block from 8216CC60h-8216CC74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC74);
		  /* 8216CC74h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216CC74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CC74h case    0:*/		return 0x8216CC78;
		  /* 8216CC78h */ case    1:  		/* b -60 */
		/* 8216CC78h case    1:*/		return 0x8216CC3C;
		/* 8216CC78h case    1:*/		return 0x8216CC7C;
	}
	return 0x8216CC7C;
} // Block from 8216CC74h-8216CC7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC7C);
		  /* 8216CC7Ch */ case    0:  		/* rlwinm R11, R3, 0, 0, 19 */
		/* 8216CC7Ch case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R3);
		/* 8216CC7Ch case    0:*/		return 0x8216CC80;
		  /* 8216CC80h */ case    1:  		/* li R4, 4800 */
		/* 8216CC80h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8216CC80h case    1:*/		return 0x8216CC84;
		  /* 8216CC84h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8216CC84h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CC84h case    2:*/		return 0x8216CC88;
		  /* 8216CC88h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 8216CC88h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 8216CC88h case    3:*/		return 0x8216CC8C;
		  /* 8216CC8Ch */ case    4:  		/* b -110116 */
		/* 8216CC8Ch case    4:*/		return 0x82151E68;
		/* 8216CC8Ch case    4:*/		return 0x8216CC90;
	}
	return 0x8216CC90;
} // Block from 8216CC7Ch-8216CC90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC90);
		  /* 8216CC90h */ case    0:  		/* mr R3, R11 */
		/* 8216CC90h case    0:*/		regs.R3 = regs.R11;
		/* 8216CC90h case    0:*/		return 0x8216CC94;
		  /* 8216CC94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216CC94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CC94h case    1:*/		return 0x8216CC98;
	}
	return 0x8216CC98;
} // Block from 8216CC90h-8216CC98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CC98);
		  /* 8216CC98h */ case    0:  		/* mfspr R12, LR */
		/* 8216CC98h case    0:*/		regs.R12 = regs.LR;
		/* 8216CC98h case    0:*/		return 0x8216CC9C;
		  /* 8216CC9Ch */ case    1:  		/* bl -899660 */
		/* 8216CC9Ch case    1:*/		regs.LR = 0x8216CCA0; return 0x82091250;
		/* 8216CC9Ch case    1:*/		return 0x8216CCA0;
		  /* 8216CCA0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216CCA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216CCA0h case    2:*/		return 0x8216CCA4;
		  /* 8216CCA4h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8216CCA4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8216CCA4h case    3:*/		return 0x8216CCA8;
		  /* 8216CCA8h */ case    4:  		/* mr R27, R3 */
		/* 8216CCA8h case    4:*/		regs.R27 = regs.R3;
		/* 8216CCA8h case    4:*/		return 0x8216CCAC;
		  /* 8216CCACh */ case    5:  		/* mr R29, R5 */
		/* 8216CCACh case    5:*/		regs.R29 = regs.R5;
		/* 8216CCACh case    5:*/		return 0x8216CCB0;
		  /* 8216CCB0h */ case    6:  		/* mr R26, R6 */
		/* 8216CCB0h case    6:*/		regs.R26 = regs.R6;
		/* 8216CCB0h case    6:*/		return 0x8216CCB4;
		  /* 8216CCB4h */ case    7:  		/* li R30, 0 */
		/* 8216CCB4h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216CCB4h case    7:*/		return 0x8216CCB8;
		  /* 8216CCB8h */ case    8:  		/* rlwinm. R11, R11, 15, 31, 31 */
		/* 8216CCB8h case    8:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R11);
		/* 8216CCB8h case    8:*/		return 0x8216CCBC;
		  /* 8216CCBCh */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 8216CCBCh case    9:*/		if ( regs.CR[0].eq ) { return 0x8216CCCC;  }
		/* 8216CCBCh case    9:*/		return 0x8216CCC0;
		  /* 8216CCC0h */ case   10:  		/* mr R3, R4 */
		/* 8216CCC0h case   10:*/		regs.R3 = regs.R4;
		/* 8216CCC0h case   10:*/		return 0x8216CCC4;
		  /* 8216CCC4h */ case   11:  		/* bl -140 */
		/* 8216CCC4h case   11:*/		regs.LR = 0x8216CCC8; return 0x8216CC38;
		/* 8216CCC4h case   11:*/		return 0x8216CCC8;
		  /* 8216CCC8h */ case   12:  		/* lwz R30, <#[R3 + 12]> */
		/* 8216CCC8h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 8216CCC8h case   12:*/		return 0x8216CCCC;
	}
	return 0x8216CCCC;
} // Block from 8216CC98h-8216CCCCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216CCCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CCCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CCCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CCCC);
		  /* 8216CCCCh */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8216CCCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216CCCCh case    0:*/		return 0x8216CCD0;
		  /* 8216CCD0h */ case    1:  		/* li R28, 1 */
		/* 8216CCD0h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8216CCD0h case    1:*/		return 0x8216CCD4;
		  /* 8216CCD4h */ case    2:  		/* rlwinm. R10, R11, 0, 30, 31 */
		/* 8216CCD4h case    2:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R11);
		/* 8216CCD4h case    2:*/		return 0x8216CCD8;
		  /* 8216CCD8h */ case    3:  		/* bc 4, CR0_EQ, 160 */
		/* 8216CCD8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216CD78;  }
		/* 8216CCD8h case    3:*/		return 0x8216CCDC;
		  /* 8216CCDCh */ case    4:  		/* rlwinm R10, R11, 30, 28, 31 */
		/* 8216CCDCh case    4:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R10,regs.R11);
		/* 8216CCDCh case    4:*/		return 0x8216CCE0;
		  /* 8216CCE0h */ case    5:  		/* cmpwi CR6, R10, 1 */
		/* 8216CCE0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 8216CCE0h case    5:*/		return 0x8216CCE4;
		  /* 8216CCE4h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8216CCE4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216CCF8;  }
		/* 8216CCE4h case    6:*/		return 0x8216CCE8;
		  /* 8216CCE8h */ case    7:  		/* cmpwi CR6, R10, 8 */
		/* 8216CCE8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000008);
		/* 8216CCE8h case    7:*/		return 0x8216CCEC;
		  /* 8216CCECh */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 8216CCECh case    8:*/		if ( regs.CR[6].eq ) { return 0x8216CCF8;  }
		/* 8216CCECh case    8:*/		return 0x8216CCF0;
		  /* 8216CCF0h */ case    9:  		/* cmpwi CR6, R10, 9 */
		/* 8216CCF0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 8216CCF0h case    9:*/		return 0x8216CCF4;
		  /* 8216CCF4h */ case   10:  		/* bc 4, CR6_EQ, 132 */
		/* 8216CCF4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8216CD78;  }
		/* 8216CCF4h case   10:*/		return 0x8216CCF8;
	}
	return 0x8216CCF8;
} // Block from 8216CCCCh-8216CCF8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216CCF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CCF8);
		  /* 8216CCF8h */ case    0:  		/* nor R10, R11, R11 */
		/* 8216CCF8h case    0:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8216CCF8h case    0:*/		return 0x8216CCFC;
		  /* 8216CCFCh */ case    1:  		/* rlwinm. R31, R10, 25, 31, 31 */
		/* 8216CCFCh case    1:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R31,regs.R10);
		/* 8216CCFCh case    1:*/		return 0x8216CD00;
		  /* 8216CD00h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8216CD00h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216CD0C;  }
		/* 8216CD00h case    2:*/		return 0x8216CD04;
		  /* 8216CD04h */ case    3:  		/* rlwinm. R11, R11, 24, 31, 31 */
		/* 8216CD04h case    3:*/		cpu::op::rlwinm<1,24,31,31>(regs,&regs.R11,regs.R11);
		/* 8216CD04h case    3:*/		return 0x8216CD08;
		  /* 8216CD08h */ case    4:  		/* bc 12, CR0_EQ, 112 */
		/* 8216CD08h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216CD78;  }
		/* 8216CD08h case    4:*/		return 0x8216CD0C;
	}
	return 0x8216CD0C;
} // Block from 8216CCF8h-8216CD0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD0C);
		  /* 8216CD0Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8216CD0Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216CD0Ch case    0:*/		return 0x8216CD10;
		  /* 8216CD10h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 8216CD10h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216CD54;  }
		/* 8216CD10h case    1:*/		return 0x8216CD14;
		  /* 8216CD14h */ case    2:  		/* mr R3, R30 */
		/* 8216CD14h case    2:*/		regs.R3 = regs.R30;
		/* 8216CD14h case    2:*/		return 0x8216CD18;
		  /* 8216CD18h */ case    3:  		/* bl -35800 */
		/* 8216CD18h case    3:*/		regs.LR = 0x8216CD1C; return 0x82164140;
		/* 8216CD18h case    3:*/		return 0x8216CD1C;
		  /* 8216CD1Ch */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216CD1Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216CD1Ch case    4:*/		return 0x8216CD20;
		  /* 8216CD20h */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 8216CD20h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216CD4C;  }
		/* 8216CD20h case    5:*/		return 0x8216CD24;
		  /* 8216CD24h */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 8216CD24h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8216CD24h case    6:*/		return 0x8216CD28;
	}
	return 0x8216CD28;
} // Block from 8216CD0Ch-8216CD28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD28h
// Function '?GetR500UCodeInfo@@YAJPBXKHPAUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD28);
		  /* 8216CD28h */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216CD28h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216CD28h case    0:*/		return 0x8216CD2C;
		  /* 8216CD2Ch */ case    1:  		/* cmplwi CR6, R11, 21 */
		/* 8216CD2Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8216CD2Ch case    1:*/		return 0x8216CD30;
		  /* 8216CD30h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 8216CD30h case    2:*/		if ( regs.CR[6].lt ) { return 0x8216CD40;  }
		/* 8216CD30h case    2:*/		return 0x8216CD34;
		  /* 8216CD34h */ case    3:  		/* cmplwi CR6, R11, 24 */
		/* 8216CD34h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8216CD34h case    3:*/		return 0x8216CD38;
		  /* 8216CD38h */ case    4:  		/* li R11, 1 */
		/* 8216CD38h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216CD38h case    4:*/		return 0x8216CD3C;
		  /* 8216CD3Ch */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 8216CD3Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x8216CD44;  }
		/* 8216CD3Ch case    5:*/		return 0x8216CD40;
	}
	return 0x8216CD40;
} // Block from 8216CD28h-8216CD40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD40);
		  /* 8216CD40h */ case    0:  		/* li R11, 0 */
		/* 8216CD40h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216CD40h case    0:*/		return 0x8216CD44;
	}
	return 0x8216CD44;
} // Block from 8216CD40h-8216CD44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD44);
		  /* 8216CD44h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216CD44h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216CD44h case    0:*/		return 0x8216CD48;
		  /* 8216CD48h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8216CD48h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216CD54;  }
		/* 8216CD48h case    1:*/		return 0x8216CD4C;
	}
	return 0x8216CD4C;
} // Block from 8216CD44h-8216CD4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD4C);
		  /* 8216CD4Ch */ case    0:  		/* li R28, 0 */
		/* 8216CD4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8216CD4Ch case    0:*/		return 0x8216CD50;
		  /* 8216CD50h */ case    1:  		/* b 40 */
		/* 8216CD50h case    1:*/		return 0x8216CD78;
		/* 8216CD50h case    1:*/		return 0x8216CD54;
	}
	return 0x8216CD54;
} // Block from 8216CD4Ch-8216CD54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD54);
		  /* 8216CD54h */ case    0:  		/* rlwinm. R11, R31, 0, 24, 31 */
		/* 8216CD54h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R31);
		/* 8216CD54h case    0:*/		return 0x8216CD58;
		  /* 8216CD58h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8216CD58h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216CD68;  }
		/* 8216CD58h case    1:*/		return 0x8216CD5C;
		  /* 8216CD5Ch */ case    2:  		/* li R4, 3607 */
		/* 8216CD5Ch case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xE17);
		/* 8216CD5Ch case    2:*/		return 0x8216CD60;
		  /* 8216CD60h */ case    3:  		/* mr R3, R27 */
		/* 8216CD60h case    3:*/		regs.R3 = regs.R27;
		/* 8216CD60h case    3:*/		return 0x8216CD64;
		  /* 8216CD64h */ case    4:  		/* bl -110572 */
		/* 8216CD64h case    4:*/		regs.LR = 0x8216CD68; return 0x82151D78;
		/* 8216CD64h case    4:*/		return 0x8216CD68;
	}
	return 0x8216CD68;
} // Block from 8216CD54h-8216CD68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD68);
		  /* 8216CD68h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8216CD68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216CD68h case    0:*/		return 0x8216CD6C;
		  /* 8216CD6Ch */ case    1:  		/* li R10, 3 */
		/* 8216CD6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8216CD6Ch case    1:*/		return 0x8216CD70;
		  /* 8216CD70h */ case    2:  		/* rlwimi R11, R10, 6, 23, 31 */
		/* 8216CD70h case    2:*/		cpu::op::rlwimi<0,6,23,31>(regs,&regs.R11,regs.R10);
		/* 8216CD70h case    2:*/		return 0x8216CD74;
		  /* 8216CD74h */ case    3:  		/* stw R11, <#[R29 + 8]> */
		/* 8216CD74h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216CD74h case    3:*/		return 0x8216CD78;
	}
	return 0x8216CD78;
} // Block from 8216CD68h-8216CD78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD78);
		  /* 8216CD78h */ case    0:  		/* stw R30, <#[R26]> */
		/* 8216CD78h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 8216CD78h case    0:*/		return 0x8216CD7C;
		  /* 8216CD7Ch */ case    1:  		/* mr R3, R28 */
		/* 8216CD7Ch case    1:*/		regs.R3 = regs.R28;
		/* 8216CD7Ch case    1:*/		return 0x8216CD80;
		  /* 8216CD80h */ case    2:  		/* addi R1, R1, 144 */
		/* 8216CD80h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216CD80h case    2:*/		return 0x8216CD84;
		  /* 8216CD84h */ case    3:  		/* b -899812 */
		/* 8216CD84h case    3:*/		return 0x820912A0;
		/* 8216CD84h case    3:*/		return 0x8216CD88;
	}
	return 0x8216CD88;
} // Block from 8216CD78h-8216CD88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216CD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CD88);
		  /* 8216CD88h */ case    0:  		/* mfspr R12, LR */
		/* 8216CD88h case    0:*/		regs.R12 = regs.LR;
		/* 8216CD88h case    0:*/		return 0x8216CD8C;
		  /* 8216CD8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216CD8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CD8Ch case    1:*/		return 0x8216CD90;
		  /* 8216CD90h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8216CD90h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216CD90h case    2:*/		return 0x8216CD94;
		  /* 8216CD94h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216CD94h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216CD94h case    3:*/		return 0x8216CD98;
		  /* 8216CD98h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 8216CD98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216CD98h case    4:*/		return 0x8216CD9C;
		  /* 8216CD9Ch */ case    5:  		/* mr R31, R3 */
		/* 8216CD9Ch case    5:*/		regs.R31 = regs.R3;
		/* 8216CD9Ch case    5:*/		return 0x8216CDA0;
		  /* 8216CDA0h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216CDA0h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216CDA0h case    6:*/		return 0x8216CDA4;
		  /* 8216CDA4h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 8216CDA4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216CDA4h case    7:*/		return 0x8216CDA8;
		  /* 8216CDA8h */ case    8:  		/* bc 12, CR6_LT, 16 */
		/* 8216CDA8h case    8:*/		if ( regs.CR[6].lt ) { return 0x8216CDB8;  }
		/* 8216CDA8h case    8:*/		return 0x8216CDAC;
		  /* 8216CDACh */ case    9:  		/* cmplwi CR6, R11, 102 */
		/* 8216CDACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 8216CDACh case    9:*/		return 0x8216CDB0;
		  /* 8216CDB0h */ case   10:  		/* li R10, 1 */
		/* 8216CDB0h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216CDB0h case   10:*/		return 0x8216CDB4;
		  /* 8216CDB4h */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 8216CDB4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8216CDBC;  }
		/* 8216CDB4h case   11:*/		return 0x8216CDB8;
	}
	return 0x8216CDB8;
} // Block from 8216CD88h-8216CDB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216CDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CDB8);
		  /* 8216CDB8h */ case    0:  		/* li R10, 0 */
		/* 8216CDB8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216CDB8h case    0:*/		return 0x8216CDBC;
	}
	return 0x8216CDBC;
} // Block from 8216CDB8h-8216CDBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CDBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CDBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CDBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CDBC);
		  /* 8216CDBCh */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8216CDBCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8216CDBCh case    0:*/		return 0x8216CDC0;
		  /* 8216CDC0h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8216CDC0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216CDCC;  }
		/* 8216CDC0h case    1:*/		return 0x8216CDC4;
		  /* 8216CDC4h */ case    2:  		/* li R3, 1 */
		/* 8216CDC4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216CDC4h case    2:*/		return 0x8216CDC8;
		  /* 8216CDC8h */ case    3:  		/* b 112 */
		/* 8216CDC8h case    3:*/		return 0x8216CE38;
		/* 8216CDC8h case    3:*/		return 0x8216CDCC;
	}
	return 0x8216CDCC;
} // Block from 8216CDBCh-8216CDCCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216CDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CDCC);
		  /* 8216CDCCh */ case    0:  		/* cmplwi CR6, R11, 105 */
		/* 8216CDCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000069);
		/* 8216CDCCh case    0:*/		return 0x8216CDD0;
		  /* 8216CDD0h */ case    1:  		/* bc 12, CR6_LT, 100 */
		/* 8216CDD0h case    1:*/		if ( regs.CR[6].lt ) { return 0x8216CE34;  }
		/* 8216CDD0h case    1:*/		return 0x8216CDD4;
		  /* 8216CDD4h */ case    2:  		/* cmplwi CR6, R11, 109 */
		/* 8216CDD4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006D);
		/* 8216CDD4h case    2:*/		return 0x8216CDD8;
		  /* 8216CDD8h */ case    3:  		/* bc 4, CR6_GT, -20 */
		/* 8216CDD8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8216CDC4;  }
		/* 8216CDD8h case    3:*/		return 0x8216CDDC;
		  /* 8216CDDCh */ case    4:  		/* cmplwi CR6, R11, 117 */
		/* 8216CDDCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 8216CDDCh case    4:*/		return 0x8216CDE0;
		  /* 8216CDE0h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8216CDE0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216CDEC;  }
		/* 8216CDE0h case    5:*/		return 0x8216CDE4;
		  /* 8216CDE4h */ case    6:  		/* cmplwi CR6, R11, 123 */
		/* 8216CDE4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007B);
		/* 8216CDE4h case    6:*/		return 0x8216CDE8;
		  /* 8216CDE8h */ case    7:  		/* b 72 */
		/* 8216CDE8h case    7:*/		return 0x8216CE30;
		/* 8216CDE8h case    7:*/		return 0x8216CDEC;
	}
	return 0x8216CDEC;
} // Block from 8216CDCCh-8216CDECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216CDECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CDEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CDEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CDEC);
		  /* 8216CDECh */ case    0:  		/* rlwinm R11, R31, 0, 0, 19 */
		/* 8216CDECh case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R31);
		/* 8216CDECh case    0:*/		return 0x8216CDF0;
		  /* 8216CDF0h */ case    1:  		/* li R6, 0 */
		/* 8216CDF0h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216CDF0h case    1:*/		return 0x8216CDF4;
		  /* 8216CDF4h */ case    2:  		/* li R5, 0 */
		/* 8216CDF4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216CDF4h case    2:*/		return 0x8216CDF8;
		  /* 8216CDF8h */ case    3:  		/* li R4, 117 */
		/* 8216CDF8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 8216CDF8h case    3:*/		return 0x8216CDFC;
		  /* 8216CDFCh */ case    4:  		/* lwz R11, <#[R11]> */
		/* 8216CDFCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CDFCh case    4:*/		return 0x8216CE00;
		  /* 8216CE00h */ case    5:  		/* lwz R3, <#[R11 + 148]> */
		/* 8216CE00h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 8216CE00h case    5:*/		return 0x8216CE04;
		  /* 8216CE04h */ case    6:  		/* bl -35284 */
		/* 8216CE04h case    6:*/		regs.LR = 0x8216CE08; return 0x82164430;
		/* 8216CE04h case    6:*/		return 0x8216CE08;
		  /* 8216CE08h */ case    7:  		/* addi R11, R31, -16 */
		/* 8216CE08h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8216CE08h case    7:*/		return 0x8216CE0C;
		  /* 8216CE0Ch */ case    8:  		/* add R11, R3, R11 */
		/* 8216CE0Ch case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8216CE0Ch case    8:*/		return 0x8216CE10;
		  /* 8216CE10h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 8216CE10h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CE10h case    9:*/		return 0x8216CE14;
		  /* 8216CE14h */ case   10:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 8216CE14h case   10:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 8216CE14h case   10:*/		return 0x8216CE18;
		  /* 8216CE18h */ case   11:  		/* cmplwi CR6, R10, 7 */
		/* 8216CE18h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 8216CE18h case   11:*/		return 0x8216CE1C;
		  /* 8216CE1Ch */ case   12:  		/* bc 4, CR6_EQ, 24 */
		/* 8216CE1Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x8216CE34;  }
		/* 8216CE1Ch case   12:*/		return 0x8216CE20;
		  /* 8216CE20h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216CE20h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CE20h case   13:*/		return 0x8216CE24;
		  /* 8216CE24h */ case   14:  		/* cmpwi CR6, R11, 2 */
		/* 8216CE24h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8216CE24h case   14:*/		return 0x8216CE28;
		  /* 8216CE28h */ case   15:  		/* bc 12, CR6_EQ, -100 */
		/* 8216CE28h case   15:*/		if ( regs.CR[6].eq ) { return 0x8216CDC4;  }
		/* 8216CE28h case   15:*/		return 0x8216CE2C;
		  /* 8216CE2Ch */ case   16:  		/* cmpwi CR6, R11, 3 */
		/* 8216CE2Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8216CE2Ch case   16:*/		return 0x8216CE30;
	}
	return 0x8216CE30;
} // Block from 8216CDECh-8216CE30h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216CE30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CE30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CE30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CE30);
		  /* 8216CE30h */ case    0:  		/* bc 12, CR6_EQ, -108 */
		/* 8216CE30h case    0:*/		if ( regs.CR[6].eq ) { return 0x8216CDC4;  }
		/* 8216CE30h case    0:*/		return 0x8216CE34;
	}
	return 0x8216CE34;
} // Block from 8216CE30h-8216CE34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CE34);
		  /* 8216CE34h */ case    0:  		/* li R3, 0 */
		/* 8216CE34h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216CE34h case    0:*/		return 0x8216CE38;
	}
	return 0x8216CE38;
} // Block from 8216CE34h-8216CE38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CE38);
		  /* 8216CE38h */ case    0:  		/* addi R1, R1, 96 */
		/* 8216CE38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216CE38h case    0:*/		return 0x8216CE3C;
		  /* 8216CE3Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216CE3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CE3Ch case    1:*/		return 0x8216CE40;
		  /* 8216CE40h */ case    2:  		/* mtspr LR, R12 */
		/* 8216CE40h case    2:*/		regs.LR = regs.R12;
		/* 8216CE40h case    2:*/		return 0x8216CE44;
		  /* 8216CE44h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8216CE44h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216CE44h case    3:*/		return 0x8216CE48;
		  /* 8216CE48h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216CE48h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CE48h case    4:*/		return 0x8216CE4C;
	}
	return 0x8216CE4C;
} // Block from 8216CE38h-8216CE4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CE4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CE4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CE4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CE4C);
		  /* 8216CE4Ch */ case    0:  		/* nop */
		/* 8216CE4Ch case    0:*/		cpu::op::nop();
		/* 8216CE4Ch case    0:*/		return 0x8216CE50;
		  /* 8216CE50h */ case    1:  		/* addi R10, R3, 972 */
		/* 8216CE50h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x3CC);
		/* 8216CE50h case    1:*/		return 0x8216CE54;
		  /* 8216CE54h */ case    2:  		/* cmplwi CR6, R5, 132 */
		/* 8216CE54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000084);
		/* 8216CE54h case    2:*/		return 0x8216CE58;
		  /* 8216CE58h */ case    3:  		/* bc 4, CR6_GT, 52 */
		/* 8216CE58h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8216CE8C;  }
		/* 8216CE58h case    3:*/		return 0x8216CE5C;
		  /* 8216CE5Ch */ case    4:  		/* addi R3, R4, -12 */
		/* 8216CE5Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R4,0xFFFFFFF4);
		/* 8216CE5Ch case    4:*/		return 0x8216CE60;
		  /* 8216CE60h */ case    5:  		/* lis R4, 24973 */
		/* 8216CE60h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x618D);
		/* 8216CE60h case    5:*/		return 0x8216CE64;
		  /* 8216CE64h */ case    6:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8216CE64h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8216CE64h case    6:*/		return 0x8216CE68;
		  /* 8216CE68h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 8216CE68h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CE68h case    7:*/		return 0x8216CE6C;
		  /* 8216CE6Ch */ case    8:  		/* lwz R9, <#[R11]> */
		/* 8216CE6Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CE6Ch case    8:*/		return 0x8216CE70;
		  /* 8216CE70h */ case    9:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8216CE70h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8216CE70h case    9:*/		return 0x8216CE74;
		  /* 8216CE74h */ case   10:  		/* stw R9, <#[R10]> */
		/* 8216CE74h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216CE74h case   10:*/		return 0x8216CE78;
		  /* 8216CE78h */ case   11:  		/* lwz R10, <#[R11 + 4]> */
		/* 8216CE78h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CE78h case   11:*/		return 0x8216CE7C;
		  /* 8216CE7Ch */ case   12:  		/* lwz R11, <#[R11]> */
		/* 8216CE7Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CE7Ch case   12:*/		return 0x8216CE80;
		  /* 8216CE80h */ case   13:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216CE80h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216CE80h case   13:*/		return 0x8216CE84;
		  /* 8216CE84h */ case   14:  		/* stw R10, <#[R11]> */
		/* 8216CE84h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CE84h case   14:*/		return 0x8216CE88;
		  /* 8216CE88h */ case   15:  		/* b -936784 */
		/* 8216CE88h case   15:*/		return 0x82088338;
		/* 8216CE88h case   15:*/		return 0x8216CE8C;
	}
	return 0x8216CE8C;
} // Block from 8216CE4Ch-8216CE8Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216CE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CE8C);
		  /* 8216CE8Ch */ case    0:  		/* rlwinm R11, R5, 30, 2, 31 */
		/* 8216CE8Ch case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R5);
		/* 8216CE8Ch case    0:*/		return 0x8216CE90;
		  /* 8216CE90h */ case    1:  		/* addi R11, R11, -1 */
		/* 8216CE90h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8216CE90h case    1:*/		return 0x8216CE94;
		  /* 8216CE94h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216CE94h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216CE94h case    2:*/		return 0x8216CE98;
		  /* 8216CE98h */ case    3:  		/* lwzx R9, <#[R11 + R10]> */
		/* 8216CE98h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8216CE98h case    3:*/		return 0x8216CE9C;
		  /* 8216CE9Ch */ case    4:  		/* stw R9, <#[R4]> */
		/* 8216CE9Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 8216CE9Ch case    4:*/		return 0x8216CEA0;
		  /* 8216CEA0h */ case    5:  		/* stwx R4, <#[R11 + R10]> */
		/* 8216CEA0h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8216CEA0h case    5:*/		return 0x8216CEA4;
		  /* 8216CEA4h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8216CEA4h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CEA4h case    6:*/		return 0x8216CEA8;
	}
	return 0x8216CEA8;
} // Block from 8216CE8Ch-8216CEA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216CEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CEA8);
		  /* 8216CEA8h */ case    0:  		/* cmplwi CR6, R5, 1 */
		/* 8216CEA8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 8216CEA8h case    0:*/		return 0x8216CEAC;
		  /* 8216CEACh */ case    1:  		/* bc 12, CR6_LT, 76 */
		/* 8216CEACh case    1:*/		if ( regs.CR[6].lt ) { return 0x8216CEF8;  }
		/* 8216CEACh case    1:*/		return 0x8216CEB0;
		  /* 8216CEB0h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8216CEB0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216CEBC;  }
		/* 8216CEB0h case    2:*/		return 0x8216CEB4;
		  /* 8216CEB4h */ case    3:  		/* li R4, 4800 */
		/* 8216CEB4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8216CEB4h case    3:*/		return 0x8216CEB8;
		  /* 8216CEB8h */ case    4:  		/* b -110672 */
		/* 8216CEB8h case    4:*/		return 0x82151E68;
		/* 8216CEB8h case    4:*/		return 0x8216CEBC;
	}
	return 0x8216CEBC;
} // Block from 8216CEA8h-8216CEBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216CEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CEBC);
		  /* 8216CEBCh */ case    0:  		/* rlwinm R11, R6, 0, 0, 30 */
		/* 8216CEBCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R6);
		/* 8216CEBCh case    0:*/		return 0x8216CEC0;
		  /* 8216CEC0h */ case    1:  		/* rlwinm R10, R4, 0, 0, 30 */
		/* 8216CEC0h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R4);
		/* 8216CEC0h case    1:*/		return 0x8216CEC4;
		  /* 8216CEC4h */ case    2:  		/* addi R11, R11, 36 */
		/* 8216CEC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8216CEC4h case    2:*/		return 0x8216CEC8;
		  /* 8216CEC8h */ case    3:  		/* addi R10, R10, 36 */
		/* 8216CEC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 8216CEC8h case    3:*/		return 0x8216CECC;
		  /* 8216CECCh */ case    4:  		/* addi R9, R11, 4 */
		/* 8216CECCh case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8216CECCh case    4:*/		return 0x8216CED0;
		  /* 8216CED0h */ case    5:  		/* addi R8, R10, 4 */
		/* 8216CED0h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 8216CED0h case    5:*/		return 0x8216CED4;
		  /* 8216CED4h */ case    6:  		/* addi R7, R10, -36 */
		/* 8216CED4h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 8216CED4h case    6:*/		return 0x8216CED8;
		  /* 8216CED8h */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 8216CED8h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CED8h case    7:*/		return 0x8216CEDC;
		  /* 8216CEDCh */ case    8:  		/* stw R6, <#[R10 + 4]> */
		/* 8216CEDCh case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8216CEDCh case    8:*/		return 0x8216CEE0;
		  /* 8216CEE0h */ case    9:  		/* lwz R6, <#[R11 + 4]> */
		/* 8216CEE0h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CEE0h case    9:*/		return 0x8216CEE4;
		  /* 8216CEE4h */ case   10:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8216CEE4h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8216CEE4h case   10:*/		return 0x8216CEE8;
		  /* 8216CEE8h */ case   11:  		/* stw R8, <#[R6 + 36]> */
		/* 8216CEE8h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 8216CEE8h case   11:*/		return 0x8216CEEC;
		  /* 8216CEECh */ case   12:  		/* stw R9, <#[R10]> */
		/* 8216CEECh case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216CEECh case   12:*/		return 0x8216CEF0;
		  /* 8216CEF0h */ case   13:  		/* stw R7, <#[R11 + 4]> */
		/* 8216CEF0h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8216CEF0h case   13:*/		return 0x8216CEF4;
		  /* 8216CEF4h */ case   14:  		/* bclr 20, CR0_LT */
		/* 8216CEF4h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CEF4h case   14:*/		return 0x8216CEF8;
	}
	return 0x8216CEF8;
} // Block from 8216CEBCh-8216CEF8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216CEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CEF8);
		  /* 8216CEF8h */ case    0:  		/* rlwinm R11, R6, 0, 0, 30 */
		/* 8216CEF8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R6);
		/* 8216CEF8h case    0:*/		return 0x8216CEFC;
		  /* 8216CEFCh */ case    1:  		/* rlwinm R10, R4, 0, 0, 30 */
		/* 8216CEFCh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R4);
		/* 8216CEFCh case    1:*/		return 0x8216CF00;
		  /* 8216CF00h */ case    2:  		/* addi R11, R11, 36 */
		/* 8216CF00h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8216CF00h case    2:*/		return 0x8216CF04;
		  /* 8216CF04h */ case    3:  		/* addi R10, R10, 36 */
		/* 8216CF04h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 8216CF04h case    3:*/		return 0x8216CF08;
		  /* 8216CF08h */ case    4:  		/* addi R8, R11, -36 */
		/* 8216CF08h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 8216CF08h case    4:*/		return 0x8216CF0C;
		  /* 8216CF0Ch */ case    5:  		/* addi R7, R10, -36 */
		/* 8216CF0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 8216CF0Ch case    5:*/		return 0x8216CF10;
		  /* 8216CF10h */ case    6:  		/* addi R9, R10, 4 */
		/* 8216CF10h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8216CF10h case    6:*/		return 0x8216CF14;
		  /* 8216CF14h */ case    7:  		/* lwz R6, <#[R11]> */
		/* 8216CF14h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CF14h case    7:*/		return 0x8216CF18;
		  /* 8216CF18h */ case    8:  		/* stw R6, <#[R10]> */
		/* 8216CF18h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8216CF18h case    8:*/		return 0x8216CF1C;
		  /* 8216CF1Ch */ case    9:  		/* lwz R6, <#[R11]> */
		/* 8216CF1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CF1Ch case    9:*/		return 0x8216CF20;
		  /* 8216CF20h */ case   10:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8216CF20h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8216CF20h case   10:*/		return 0x8216CF24;
		  /* 8216CF24h */ case   11:  		/* stw R7, <#[R6]> */
		/* 8216CF24h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8216CF24h case   11:*/		return 0x8216CF28;
		  /* 8216CF28h */ case   12:  		/* stw R8, <#[R10 + 4]> */
		/* 8216CF28h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 8216CF28h case   12:*/		return 0x8216CF2C;
		  /* 8216CF2Ch */ case   13:  		/* stw R9, <#[R11]> */
		/* 8216CF2Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216CF2Ch case   13:*/		return 0x8216CF30;
		  /* 8216CF30h */ case   14:  		/* bclr 20, CR0_LT */
		/* 8216CF30h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216CF30h case   14:*/		return 0x8216CF34;
	}
	return 0x8216CF34;
} // Block from 8216CEF8h-8216CF34h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216CF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CF34);
		  /* 8216CF34h */ case    0:  		/* nop */
		/* 8216CF34h case    0:*/		cpu::op::nop();
		/* 8216CF34h case    0:*/		return 0x8216CF38;
	}
	return 0x8216CF38;
} // Block from 8216CF34h-8216CF38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216CF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CF38);
		  /* 8216CF38h */ case    0:  		/* mfspr R12, LR */
		/* 8216CF38h case    0:*/		regs.R12 = regs.LR;
		/* 8216CF38h case    0:*/		return 0x8216CF3C;
		  /* 8216CF3Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216CF3Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CF3Ch case    1:*/		return 0x8216CF40;
		  /* 8216CF40h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8216CF40h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216CF40h case    2:*/		return 0x8216CF44;
		  /* 8216CF44h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216CF44h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216CF44h case    3:*/		return 0x8216CF48;
		  /* 8216CF48h */ case    4:  		/* li R5, 5 */
		/* 8216CF48h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 8216CF48h case    4:*/		return 0x8216CF4C;
		  /* 8216CF4Ch */ case    5:  		/* li R4, 116 */
		/* 8216CF4Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x74);
		/* 8216CF4Ch case    5:*/		return 0x8216CF50;
		  /* 8216CF50h */ case    6:  		/* mr R31, R3 */
		/* 8216CF50h case    6:*/		regs.R31 = regs.R3;
		/* 8216CF50h case    6:*/		return 0x8216CF54;
		  /* 8216CF54h */ case    7:  		/* bl -940 */
		/* 8216CF54h case    7:*/		regs.LR = 0x8216CF58; return 0x8216CBA8;
		/* 8216CF54h case    7:*/		return 0x8216CF58;
		  /* 8216CF58h */ case    8:  		/* addi R11, R3, 16 */
		/* 8216CF58h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 8216CF58h case    8:*/		return 0x8216CF5C;
		  /* 8216CF5Ch */ case    9:  		/* addi R10, R3, 24 */
		/* 8216CF5Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x18);
		/* 8216CF5Ch case    9:*/		return 0x8216CF60;
		  /* 8216CF60h */ case   10:  		/* addi R8, R11, 4 */
		/* 8216CF60h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 8216CF60h case   10:*/		return 0x8216CF64;
		  /* 8216CF64h */ case   11:  		/* addi R6, R11, -36 */
		/* 8216CF64h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 8216CF64h case   11:*/		return 0x8216CF68;
		  /* 8216CF68h */ case   12:  		/* addi R11, R10, 4 */
		/* 8216CF68h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 8216CF68h case   12:*/		return 0x8216CF6C;
		  /* 8216CF6Ch */ case   13:  		/* addi R9, R3, 32 */
		/* 8216CF6Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x20);
		/* 8216CF6Ch case   13:*/		return 0x8216CF70;
		  /* 8216CF70h */ case   14:  		/* addi R5, R10, -36 */
		/* 8216CF70h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFFFDC);
		/* 8216CF70h case   14:*/		return 0x8216CF74;
		  /* 8216CF74h */ case   15:  		/* ori R6, R6, 1 */
		/* 8216CF74h case   15:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8216CF74h case   15:*/		return 0x8216CF78;
		  /* 8216CF78h */ case   16:  		/* ori R8, R8, 1 */
		/* 8216CF78h case   16:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216CF78h case   16:*/		return 0x8216CF7C;
		  /* 8216CF7Ch */ case   17:  		/* ori R11, R11, 1 */
		/* 8216CF7Ch case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216CF7Ch case   17:*/		return 0x8216CF80;
		  /* 8216CF80h */ case   18:  		/* stw R6, <#[R3 + 20]> */
		/* 8216CF80h case   18:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 8216CF80h case   18:*/		return 0x8216CF84;
		  /* 8216CF84h */ case   19:  		/* addi R10, R9, 4 */
		/* 8216CF84h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 8216CF84h case   19:*/		return 0x8216CF88;
		  /* 8216CF88h */ case   20:  		/* stw R8, <#[R3 + 16]> */
		/* 8216CF88h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 8216CF88h case   20:*/		return 0x8216CF8C;
		  /* 8216CF8Ch */ case   21:  		/* addi R9, R9, -36 */
		/* 8216CF8Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFDC);
		/* 8216CF8Ch case   21:*/		return 0x8216CF90;
		  /* 8216CF90h */ case   22:  		/* stw R11, <#[R3 + 24]> */
		/* 8216CF90h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8216CF90h case   22:*/		return 0x8216CF94;
		  /* 8216CF94h */ case   23:  		/* ori R6, R5, 1 */
		/* 8216CF94h case   23:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R5,0x1);
		/* 8216CF94h case   23:*/		return 0x8216CF98;
		  /* 8216CF98h */ case   24:  		/* ori R11, R10, 1 */
		/* 8216CF98h case   24:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0x1);
		/* 8216CF98h case   24:*/		return 0x8216CF9C;
		  /* 8216CF9Ch */ case   25:  		/* ori R9, R9, 1 */
		/* 8216CF9Ch case   25:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216CF9Ch case   25:*/		return 0x8216CFA0;
		  /* 8216CFA0h */ case   26:  		/* stw R6, <#[R3 + 28]> */
		/* 8216CFA0h case   26:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x0000001C) );
		/* 8216CFA0h case   26:*/		return 0x8216CFA4;
		  /* 8216CFA4h */ case   27:  		/* li R7, 1 */
		/* 8216CFA4h case   27:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8216CFA4h case   27:*/		return 0x8216CFA8;
		  /* 8216CFA8h */ case   28:  		/* stw R11, <#[R3 + 32]> */
		/* 8216CFA8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 8216CFA8h case   28:*/		return 0x8216CFAC;
		  /* 8216CFACh */ case   29:  		/* stw R9, <#[R3 + 36]> */
		/* 8216CFACh case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000024) );
		/* 8216CFACh case   29:*/		return 0x8216CFB0;
		  /* 8216CFB0h */ case   30:  		/* lwz R11, <#[R3 + 68]> */
		/* 8216CFB0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 8216CFB0h case   30:*/		return 0x8216CFB4;
		  /* 8216CFB4h */ case   31:  		/* rlwimi R11, R7, 0, 4, 31 */
		/* 8216CFB4h case   31:*/		cpu::op::rlwimi<0,0,4,31>(regs,&regs.R11,regs.R7);
		/* 8216CFB4h case   31:*/		return 0x8216CFB8;
		  /* 8216CFB8h */ case   32:  		/* stw R11, <#[R3 + 68]> */
		/* 8216CFB8h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 8216CFB8h case   32:*/		return 0x8216CFBC;
		  /* 8216CFBCh */ case   33:  		/* lwz R11, <#[R31 + 92]> */
		/* 8216CFBCh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8216CFBCh case   33:*/		return 0x8216CFC0;
		  /* 8216CFC0h */ case   34:  		/* addi R10, R11, 1 */
		/* 8216CFC0h case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 8216CFC0h case   34:*/		return 0x8216CFC4;
		  /* 8216CFC4h */ case   35:  		/* stw R10, <#[R31 + 92]> */
		/* 8216CFC4h case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 8216CFC4h case   35:*/		return 0x8216CFC8;
		  /* 8216CFC8h */ case   36:  		/* lwz R10, <#[R3 + 76]> */
		/* 8216CFC8h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216CFC8h case   36:*/		return 0x8216CFCC;
		  /* 8216CFCCh */ case   37:  		/* lwz R9, <#[R3 + 48]> */
		/* 8216CFCCh case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000030) );
		/* 8216CFCCh case   37:*/		return 0x8216CFD0;
		  /* 8216CFD0h */ case   38:  		/* rlwimi R9, R11, 0, 13, 31 */
		/* 8216CFD0h case   38:*/		cpu::op::rlwimi<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 8216CFD0h case   38:*/		return 0x8216CFD4;
		  /* 8216CFD4h */ case   39:  		/* stw R9, <#[R3 + 48]> */
		/* 8216CFD4h case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000030) );
		/* 8216CFD4h case   39:*/		return 0x8216CFD8;
		  /* 8216CFD8h */ case   40:  		/* lwz R11, <#[R31 + 32]> */
		/* 8216CFD8h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8216CFD8h case   40:*/		return 0x8216CFDC;
		  /* 8216CFDCh */ case   41:  		/* rlwimi R11, R10, 0, 0, 12 */
		/* 8216CFDCh case   41:*/		cpu::op::rlwimi<0,0,0,12>(regs,&regs.R11,regs.R10);
		/* 8216CFDCh case   41:*/		return 0x8216CFE0;
		  /* 8216CFE0h */ case   42:  		/* stw R11, <#[R3 + 76]> */
		/* 8216CFE0h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216CFE0h case   42:*/		return 0x8216CFE4;
		  /* 8216CFE4h */ case   43:  		/* lwz R10, <#[R31 + 40]> */
		/* 8216CFE4h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 8216CFE4h case   43:*/		return 0x8216CFE8;
		  /* 8216CFE8h */ case   44:  		/* rlwinm. R10, R10, 0, 2, 2 */
		/* 8216CFE8h case   44:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R10);
		/* 8216CFE8h case   44:*/		return 0x8216CFEC;
		  /* 8216CFECh */ case   45:  		/* bc 12, CR0_EQ, 12 */
		/* 8216CFECh case   45:*/		if ( regs.CR[0].eq ) { return 0x8216CFF8;  }
		/* 8216CFECh case   45:*/		return 0x8216CFF0;
	}
	return 0x8216CFF0;
} // Block from 8216CF38h-8216CFF0h (46 instructions)

//////////////////////////////////////////////////////
// Block at 8216CFF0h
// Function '?ValidateMemoryRanges@@YAJPAUR500StuffLite@@0H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CFF0);
		  /* 8216CFF0h */ case    0:  		/* oris R11, R11, 8 */
		/* 8216CFF0h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8216CFF0h case    0:*/		return 0x8216CFF4;
		  /* 8216CFF4h */ case    1:  		/* stw R11, <#[R3 + 76]> */
		/* 8216CFF4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216CFF4h case    1:*/		return 0x8216CFF8;
	}
	return 0x8216CFF8;
} // Block from 8216CFF0h-8216CFF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216CFF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216CFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216CFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216CFF8);
		  /* 8216CFF8h */ case    0:  		/* addi R1, R1, 96 */
		/* 8216CFF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216CFF8h case    0:*/		return 0x8216CFFC;
		  /* 8216CFFCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216CFFCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216CFFCh case    1:*/		return 0x8216D000;
		  /* 8216D000h */ case    2:  		/* mtspr LR, R12 */
		/* 8216D000h case    2:*/		regs.LR = regs.R12;
		/* 8216D000h case    2:*/		return 0x8216D004;
		  /* 8216D004h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8216D004h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216D004h case    3:*/		return 0x8216D008;
		  /* 8216D008h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216D008h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216D008h case    4:*/		return 0x8216D00C;
	}
	return 0x8216D00C;
} // Block from 8216CFF8h-8216D00Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216D00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D00C);
		  /* 8216D00Ch */ case    0:  		/* nop */
		/* 8216D00Ch case    0:*/		cpu::op::nop();
		/* 8216D00Ch case    0:*/		return 0x8216D010;
	}
	return 0x8216D010;
} // Block from 8216D00Ch-8216D010h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D010);
		  /* 8216D010h */ case    0:  		/* mfspr R12, LR */
		/* 8216D010h case    0:*/		regs.R12 = regs.LR;
		/* 8216D010h case    0:*/		return 0x8216D014;
		  /* 8216D014h */ case    1:  		/* bl -900540 */
		/* 8216D014h case    1:*/		regs.LR = 0x8216D018; return 0x82091258;
		/* 8216D014h case    1:*/		return 0x8216D018;
		  /* 8216D018h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216D018h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216D018h case    2:*/		return 0x8216D01C;
		  /* 8216D01Ch */ case    3:  		/* mr R30, R4 */
		/* 8216D01Ch case    3:*/		regs.R30 = regs.R4;
		/* 8216D01Ch case    3:*/		return 0x8216D020;
		  /* 8216D020h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8216D020h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8216D020h case    4:*/		return 0x8216D024;
		  /* 8216D024h */ case    5:  		/* mr R29, R5 */
		/* 8216D024h case    5:*/		regs.R29 = regs.R5;
		/* 8216D024h case    5:*/		return 0x8216D028;
		  /* 8216D028h */ case    6:  		/* li R5, 0 */
		/* 8216D028h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216D028h case    6:*/		return 0x8216D02C;
		  /* 8216D02Ch */ case    7:  		/* mr R31, R3 */
		/* 8216D02Ch case    7:*/		regs.R31 = regs.R3;
		/* 8216D02Ch case    7:*/		return 0x8216D030;
		  /* 8216D030h */ case    8:  		/* bl 751976 */
		/* 8216D030h case    8:*/		regs.LR = 0x8216D034; return 0x82224998;
		/* 8216D030h case    8:*/		return 0x8216D034;
		  /* 8216D034h */ case    9:  		/* mr R28, R3 */
		/* 8216D034h case    9:*/		regs.R28 = regs.R3;
		/* 8216D034h case    9:*/		return 0x8216D038;
		  /* 8216D038h */ case   10:  		/* mr R4, R3 */
		/* 8216D038h case   10:*/		regs.R4 = regs.R3;
		/* 8216D038h case   10:*/		return 0x8216D03C;
		  /* 8216D03Ch */ case   11:  		/* mr R6, R29 */
		/* 8216D03Ch case   11:*/		regs.R6 = regs.R29;
		/* 8216D03Ch case   11:*/		return 0x8216D040;
		  /* 8216D040h */ case   12:  		/* mr R5, R30 */
		/* 8216D040h case   12:*/		regs.R5 = regs.R30;
		/* 8216D040h case   12:*/		return 0x8216D044;
		  /* 8216D044h */ case   13:  		/* mr R3, R31 */
		/* 8216D044h case   13:*/		regs.R3 = regs.R31;
		/* 8216D044h case   13:*/		return 0x8216D048;
		  /* 8216D048h */ case   14:  		/* bl -416 */
		/* 8216D048h case   14:*/		regs.LR = 0x8216D04C; return 0x8216CEA8;
		/* 8216D048h case   14:*/		return 0x8216D04C;
		  /* 8216D04Ch */ case   15:  		/* mr R3, R28 */
		/* 8216D04Ch case   15:*/		regs.R3 = regs.R28;
		/* 8216D04Ch case   15:*/		return 0x8216D050;
		  /* 8216D050h */ case   16:  		/* addi R1, R1, 128 */
		/* 8216D050h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216D050h case   16:*/		return 0x8216D054;
		  /* 8216D054h */ case   17:  		/* b -900524 */
		/* 8216D054h case   17:*/		return 0x820912A8;
		/* 8216D054h case   17:*/		return 0x8216D058;
	}
	return 0x8216D058;
} // Block from 8216D010h-8216D058h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8216D058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D058);
		  /* 8216D058h */ case    0:  		/* mfspr R12, LR */
		/* 8216D058h case    0:*/		regs.R12 = regs.LR;
		/* 8216D058h case    0:*/		return 0x8216D05C;
		  /* 8216D05Ch */ case    1:  		/* bl -900624 */
		/* 8216D05Ch case    1:*/		regs.LR = 0x8216D060; return 0x8209124C;
		/* 8216D05Ch case    1:*/		return 0x8216D060;
		  /* 8216D060h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216D060h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216D060h case    2:*/		return 0x8216D064;
		  /* 8216D064h */ case    3:  		/* lwz R26, <#[R3 + 4]> */
		/* 8216D064h case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x00000004) );
		/* 8216D064h case    3:*/		return 0x8216D068;
		  /* 8216D068h */ case    4:  		/* mr R27, R3 */
		/* 8216D068h case    4:*/		regs.R27 = regs.R3;
		/* 8216D068h case    4:*/		return 0x8216D06C;
		  /* 8216D06Ch */ case    5:  		/* mr R28, R4 */
		/* 8216D06Ch case    5:*/		regs.R28 = regs.R4;
		/* 8216D06Ch case    5:*/		return 0x8216D070;
		  /* 8216D070h */ case    6:  		/* rlwinm. R25, R26, 0, 31, 31 */
		/* 8216D070h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R25,regs.R26);
		/* 8216D070h case    6:*/		return 0x8216D074;
		  /* 8216D074h */ case    7:  		/* bc 12, CR0_EQ, 76 */
		/* 8216D074h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216D0C0;  }
		/* 8216D074h case    7:*/		return 0x8216D078;
		  /* 8216D078h */ case    8:  		/* li R30, 0 */
		/* 8216D078h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216D078h case    8:*/		return 0x8216D07C;
		  /* 8216D07Ch */ case    9:  		/* cmplwi CR6, R30, 0 */
		/* 8216D07Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216D07Ch case    9:*/		return 0x8216D080;
		  /* 8216D080h */ case   10:  		/* bc 12, CR6_EQ, 304 */
		/* 8216D080h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216D1B0;  }
		/* 8216D080h case   10:*/		return 0x8216D084;
		  /* 8216D084h */ case   11:  		/* lwz R11, <#[R30 + 48]> */
		/* 8216D084h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8216D084h case   11:*/		return 0x8216D088;
		  /* 8216D088h */ case   12:  		/* li R10, 1 */
		/* 8216D088h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216D088h case   12:*/		return 0x8216D08C;
		  /* 8216D08Ch */ case   13:  		/* lwz R3, <#[R28 + 52]> */
		/* 8216D08Ch case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 8216D08Ch case   13:*/		return 0x8216D090;
		  /* 8216D090h */ case   14:  		/* rlwinm R9, R11, 0, 13, 31 */
		/* 8216D090h case   14:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 8216D090h case   14:*/		return 0x8216D094;
		  /* 8216D094h */ case   15:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 8216D094h case   15:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 8216D094h case   15:*/		return 0x8216D098;
		  /* 8216D098h */ case   16:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8216D098h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8216D098h case   16:*/		return 0x8216D09C;
		  /* 8216D09Ch */ case   17:  		/* addi R11, R11, 1 */
		/* 8216D09Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216D09Ch case   17:*/		return 0x8216D0A0;
		  /* 8216D0A0h */ case   18:  		/* lwz R8, <#[R3 + 40]> */
		/* 8216D0A0h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000028) );
		/* 8216D0A0h case   18:*/		return 0x8216D0A4;
		  /* 8216D0A4h */ case   19:  		/* slw R10, R10, R9 */
		/* 8216D0A4h case   19:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216D0A4h case   19:*/		return 0x8216D0A8;
		  /* 8216D0A8h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216D0A8h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216D0A8h case   20:*/		return 0x8216D0AC;
		  /* 8216D0ACh */ case   21:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8216D0ACh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8216D0ACh case   21:*/		return 0x8216D0B0;
		  /* 8216D0B0h */ case   22:  		/* and. R11, R11, R10 */
		/* 8216D0B0h case   22:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216D0B0h case   22:*/		return 0x8216D0B4;
		  /* 8216D0B4h */ case   23:  		/* bc 12, CR0_EQ, 296 */
		/* 8216D0B4h case   23:*/		if ( regs.CR[0].eq ) { return 0x8216D1DC;  }
		/* 8216D0B4h case   23:*/		return 0x8216D0B8;
		  /* 8216D0B8h */ case   24:  		/* mr R3, R30 */
		/* 8216D0B8h case   24:*/		regs.R3 = regs.R30;
		/* 8216D0B8h case   24:*/		return 0x8216D0BC;
		  /* 8216D0BCh */ case   25:  		/* b 288 */
		/* 8216D0BCh case   25:*/		return 0x8216D1DC;
		/* 8216D0BCh case   25:*/		return 0x8216D0C0;
	}
	return 0x8216D0C0;
} // Block from 8216D058h-8216D0C0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216D0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D0C0);
		  /* 8216D0C0h */ case    0:  		/* mr R30, R26 */
		/* 8216D0C0h case    0:*/		regs.R30 = regs.R26;
		/* 8216D0C0h case    0:*/		return 0x8216D0C4;
		  /* 8216D0C4h */ case    1:  		/* cmplwi CR0, R26, 0 */
		/* 8216D0C4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R26,0x00000000);
		/* 8216D0C4h case    1:*/		return 0x8216D0C8;
		  /* 8216D0C8h */ case    2:  		/* bc 12, CR0_EQ, -76 */
		/* 8216D0C8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216D07C;  }
		/* 8216D0C8h case    2:*/		return 0x8216D0CC;
		  /* 8216D0CCh */ case    3:  		/* lwz R11, <#[R30 + 28]> */
		/* 8216D0CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8216D0CCh case    3:*/		return 0x8216D0D0;
		  /* 8216D0D0h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216D0D0h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D0D0h case    4:*/		return 0x8216D0D4;
		  /* 8216D0D4h */ case    5:  		/* bc 4, CR0_EQ, 192 */
		/* 8216D0D4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216D194;  }
		/* 8216D0D4h case    5:*/		return 0x8216D0D8;
		  /* 8216D0D8h */ case    6:  		/* lwz R11, <#[R30 + 24]> */
		/* 8216D0D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8216D0D8h case    6:*/		return 0x8216D0DC;
		  /* 8216D0DCh */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D0DCh case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D0DCh case    7:*/		return 0x8216D0E0;
		  /* 8216D0E0h */ case    8:  		/* addic. R31, R11, -40 */
		/* 8216D0E0h case    8:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216D0E0h case    8:*/		return 0x8216D0E4;
		  /* 8216D0E4h */ case    9:  		/* bc 12, CR0_EQ, 176 */
		/* 8216D0E4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216D194;  }
		/* 8216D0E4h case    9:*/		return 0x8216D0E8;
		  /* 8216D0E8h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216D0E8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216D0E8h case   10:*/		return 0x8216D0EC;
		  /* 8216D0ECh */ case   11:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216D0ECh case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216D0ECh case   11:*/		return 0x8216D0F0;
		  /* 8216D0F0h */ case   12:  		/* cmplwi CR6, R11, 86 */
		/* 8216D0F0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 8216D0F0h case   12:*/		return 0x8216D0F4;
		  /* 8216D0F4h */ case   13:  		/* bc 12, CR6_EQ, 48 */
		/* 8216D0F4h case   13:*/		if ( regs.CR[6].eq ) { return 0x8216D124;  }
		/* 8216D0F4h case   13:*/		return 0x8216D0F8;
		  /* 8216D0F8h */ case   14:  		/* cmplwi CR6, R11, 87 */
		/* 8216D0F8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 8216D0F8h case   14:*/		return 0x8216D0FC;
		  /* 8216D0FCh */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 8216D0FCh case   15:*/		if ( regs.CR[6].eq ) { return 0x8216D124;  }
		/* 8216D0FCh case   15:*/		return 0x8216D100;
		  /* 8216D100h */ case   16:  		/* cmplwi CR6, R11, 89 */
		/* 8216D100h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 8216D100h case   16:*/		return 0x8216D104;
		  /* 8216D104h */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 8216D104h case   17:*/		if ( regs.CR[6].eq ) { return 0x8216D124;  }
		/* 8216D104h case   17:*/		return 0x8216D108;
		  /* 8216D108h */ case   18:  		/* cmplwi CR6, R11, 90 */
		/* 8216D108h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 8216D108h case   18:*/		return 0x8216D10C;
		  /* 8216D10Ch */ case   19:  		/* bc 12, CR6_EQ, 24 */
		/* 8216D10Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x8216D124;  }
		/* 8216D10Ch case   19:*/		return 0x8216D110;
		  /* 8216D110h */ case   20:  		/* cmplwi CR6, R11, 84 */
		/* 8216D110h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000054);
		/* 8216D110h case   20:*/		return 0x8216D114;
		  /* 8216D114h */ case   21:  		/* bc 12, CR6_EQ, 16 */
		/* 8216D114h case   21:*/		if ( regs.CR[6].eq ) { return 0x8216D124;  }
		/* 8216D114h case   21:*/		return 0x8216D118;
		  /* 8216D118h */ case   22:  		/* cmplwi CR6, R11, 85 */
		/* 8216D118h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000055);
		/* 8216D118h case   22:*/		return 0x8216D11C;
		  /* 8216D11Ch */ case   23:  		/* li R11, 0 */
		/* 8216D11Ch case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216D11Ch case   23:*/		return 0x8216D120;
		  /* 8216D120h */ case   24:  		/* bc 4, CR6_EQ, 8 */
		/* 8216D120h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8216D128;  }
		/* 8216D120h case   24:*/		return 0x8216D124;
	}
	return 0x8216D124;
} // Block from 8216D0C0h-8216D124h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8216D124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D124);
		  /* 8216D124h */ case    0:  		/* li R11, 1 */
		/* 8216D124h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216D124h case    0:*/		return 0x8216D128;
	}
	return 0x8216D128;
} // Block from 8216D124h-8216D128h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D128);
		  /* 8216D128h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216D128h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D128h case    0:*/		return 0x8216D12C;
		  /* 8216D12Ch */ case    1:  		/* bc 12, CR0_EQ, 104 */
		/* 8216D12Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8216D194;  }
		/* 8216D12Ch case    1:*/		return 0x8216D130;
		  /* 8216D130h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216D130h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216D130h case    2:*/		return 0x8216D134;
		  /* 8216D134h */ case    3:  		/* mr R3, R27 */
		/* 8216D134h case    3:*/		regs.R3 = regs.R27;
		/* 8216D134h case    3:*/		return 0x8216D138;
		  /* 8216D138h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216D138h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216D138h case    4:*/		return 0x8216D13C;
		  /* 8216D13Ch */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8216D13Ch case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8216D13Ch case    5:*/		return 0x8216D140;
		  /* 8216D140h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216D140h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216D140h case    6:*/		return 0x8216D144;
		  /* 8216D144h */ case    7:  		/* bl -36116 */
		/* 8216D144h case    7:*/		regs.LR = 0x8216D148; return 0x82164430;
		/* 8216D144h case    7:*/		return 0x8216D148;
		  /* 8216D148h */ case    8:  		/* addi R11, R31, -16 */
		/* 8216D148h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8216D148h case    8:*/		return 0x8216D14C;
		  /* 8216D14Ch */ case    9:  		/* lwzx R11, <#[R3 + R11]> */
		/* 8216D14Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 8216D14Ch case    9:*/		return 0x8216D150;
		  /* 8216D150h */ case   10:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8216D150h case   10:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8216D150h case   10:*/		return 0x8216D154;
		  /* 8216D154h */ case   11:  		/* lwz R11, <#[R11 + 28]> */
		/* 8216D154h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8216D154h case   11:*/		return 0x8216D158;
		  /* 8216D158h */ case   12:  		/* cmplw CR6, R11, R28 */
		/* 8216D158h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8216D158h case   12:*/		return 0x8216D15C;
		  /* 8216D15Ch */ case   13:  		/* bc 12, CR6_EQ, -224 */
		/* 8216D15Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8216D07C;  }
		/* 8216D15Ch case   13:*/		return 0x8216D160;
		  /* 8216D160h */ case   14:  		/* lwz R11, <#[R28 + 8]> */
		/* 8216D160h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8216D160h case   14:*/		return 0x8216D164;
		  /* 8216D164h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 8216D164h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216D164h case   15:*/		return 0x8216D168;
		  /* 8216D168h */ case   16:  		/* bc 12, CR6_EQ, 32 */
		/* 8216D168h case   16:*/		if ( regs.CR[6].eq ) { return 0x8216D188;  }
		/* 8216D168h case   16:*/		return 0x8216D16C;
		  /* 8216D16Ch */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 8216D16Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D16Ch case   17:*/		return 0x8216D170;
		  /* 8216D170h */ case   18:  		/* cmplw CR6, R30, R10 */
		/* 8216D170h case   18:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 8216D170h case   18:*/		return 0x8216D174;
		  /* 8216D174h */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 8216D174h case   19:*/		if ( regs.CR[6].eq ) { return 0x8216D180;  }
		/* 8216D174h case   19:*/		return 0x8216D178;
		  /* 8216D178h */ case   20:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216D178h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216D178h case   20:*/		return 0x8216D17C;
		  /* 8216D17Ch */ case   21:  		/* b -24 */
		/* 8216D17Ch case   21:*/		return 0x8216D164;
		/* 8216D17Ch case   21:*/		return 0x8216D180;
	}
	return 0x8216D180;
} // Block from 8216D128h-8216D180h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8216D180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D180);
		  /* 8216D180h */ case    0:  		/* li R11, 1 */
		/* 8216D180h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216D180h case    0:*/		return 0x8216D184;
		  /* 8216D184h */ case    1:  		/* b 8 */
		/* 8216D184h case    1:*/		return 0x8216D18C;
		/* 8216D184h case    1:*/		return 0x8216D188;
	}
	return 0x8216D188;
} // Block from 8216D180h-8216D188h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216D188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D188);
		  /* 8216D188h */ case    0:  		/* li R11, 0 */
		/* 8216D188h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216D188h case    0:*/		return 0x8216D18C;
	}
	return 0x8216D18C;
} // Block from 8216D188h-8216D18Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D18Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D18C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D18C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D18C);
		  /* 8216D18Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216D18Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D18Ch case    0:*/		return 0x8216D190;
		  /* 8216D190h */ case    1:  		/* bc 4, CR0_EQ, -276 */
		/* 8216D190h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216D07C;  }
		/* 8216D190h case    1:*/		return 0x8216D194;
	}
	return 0x8216D194;
} // Block from 8216D18Ch-8216D194h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216D194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D194);
		  /* 8216D194h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8216D194h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8216D194h case    0:*/		return 0x8216D198;
		  /* 8216D198h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216D198h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D198h case    1:*/		return 0x8216D19C;
		  /* 8216D19Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D19Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D19Ch case    2:*/		return 0x8216D1A0;
		  /* 8216D1A0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216D1A0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216D1B0;  }
		/* 8216D1A0h case    3:*/		return 0x8216D1A4;
		  /* 8216D1A4h */ case    4:  		/* mr R30, R11 */
		/* 8216D1A4h case    4:*/		regs.R30 = regs.R11;
		/* 8216D1A4h case    4:*/		return 0x8216D1A8;
		  /* 8216D1A8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216D1A8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216D1A8h case    5:*/		return 0x8216D1AC;
		  /* 8216D1ACh */ case    6:  		/* bc 4, CR6_EQ, -224 */
		/* 8216D1ACh case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216D0CC;  }
		/* 8216D1ACh case    6:*/		return 0x8216D1B0;
	}
	return 0x8216D1B0;
} // Block from 8216D194h-8216D1B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216D1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D1B0);
		  /* 8216D1B0h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8216D1B0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8216D1B0h case    0:*/		return 0x8216D1B4;
		  /* 8216D1B4h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 8216D1B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D1B4h case    1:*/		return 0x8216D1B8;
		  /* 8216D1B8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D1B8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D1B8h case    2:*/		return 0x8216D1BC;
		  /* 8216D1BCh */ case    3:  		/* bc 4, CR0_EQ, 332 */
		/* 8216D1BCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216D308;  }
		/* 8216D1BCh case    3:*/		return 0x8216D1C0;
		  /* 8216D1C0h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D1C0h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D1C0h case    4:*/		return 0x8216D1C4;
		  /* 8216D1C4h */ case    5:  		/* addic. R3, R11, -4 */
		/* 8216D1C4h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 8216D1C4h case    5:*/		return 0x8216D1C8;
		  /* 8216D1C8h */ case    6:  		/* bc 12, CR0_EQ, 320 */
		/* 8216D1C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216D308;  }
		/* 8216D1C8h case    6:*/		return 0x8216D1CC;
		  /* 8216D1CCh */ case    7:  		/* lwz R11, <#[R3 + 48]> */
		/* 8216D1CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8216D1CCh case    7:*/		return 0x8216D1D0;
		  /* 8216D1D0h */ case    8:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8216D1D0h case    8:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D1D0h case    8:*/		return 0x8216D1D4;
		  /* 8216D1D4h */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 8216D1D4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8216D1DC;  }
		/* 8216D1D4h case    9:*/		return 0x8216D1D8;
		  /* 8216D1D8h */ case   10:  		/* lwz R3, <#[R28 + 52]> */
		/* 8216D1D8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 8216D1D8h case   10:*/		return 0x8216D1DC;
	}
	return 0x8216D1DC;
} // Block from 8216D1B0h-8216D1DCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216D1DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D1DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D1DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D1DC);
		  /* 8216D1DCh */ case    0:  		/* lwz R10, <#[R3 + 28]> */
		/* 8216D1DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000001C) );
		/* 8216D1DCh case    0:*/		return 0x8216D1E0;
		  /* 8216D1E0h */ case    1:  		/* li R29, 0 */
		/* 8216D1E0h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8216D1E0h case    1:*/		return 0x8216D1E4;
		  /* 8216D1E4h */ case    2:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 8216D1E4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8216D1E4h case    2:*/		return 0x8216D1E8;
		  /* 8216D1E8h */ case    3:  		/* bc 4, CR0_EQ, 292 */
		/* 8216D1E8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216D30C;  }
		/* 8216D1E8h case    3:*/		return 0x8216D1EC;
		  /* 8216D1ECh */ case    4:  		/* mr R11, R10 */
		/* 8216D1ECh case    4:*/		regs.R11 = regs.R10;
		/* 8216D1ECh case    4:*/		return 0x8216D1F0;
		  /* 8216D1F0h */ case    5:  		/* cmplwi CR0, R10, 0 */
		/* 8216D1F0h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8216D1F0h case    5:*/		return 0x8216D1F4;
		  /* 8216D1F4h */ case    6:  		/* bc 12, CR0_EQ, 280 */
		/* 8216D1F4h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216D30C;  }
		/* 8216D1F4h case    6:*/		return 0x8216D1F8;
		  /* 8216D1F8h */ case    7:  		/* lwz R8, <#[R11 + 8]> */
		/* 8216D1F8h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 8216D1F8h case    7:*/		return 0x8216D1FC;
		  /* 8216D1FCh */ case    8:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 8216D1FCh case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 8216D1FCh case    8:*/		return 0x8216D200;
		  /* 8216D200h */ case    9:  		/* cmplwi CR6, R8, 16128 */
		/* 8216D200h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00003F00);
		/* 8216D200h case    9:*/		return 0x8216D204;
		  /* 8216D204h */ case   10:  		/* bc 4, CR6_EQ, 36 */
		/* 8216D204h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8216D228;  }
		/* 8216D204h case   10:*/		return 0x8216D208;
		  /* 8216D208h */ case   11:  		/* addic R8, R9, -1 */
		/* 8216D208h case   11:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 8216D208h case   11:*/		return 0x8216D20C;
		  /* 8216D20Ch */ case   12:  		/* subfe R8, R8, R8 */
		/* 8216D20Ch case   12:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 8216D20Ch case   12:*/		return 0x8216D210;
		  /* 8216D210h */ case   13:  		/* and R8, R8, R10 */
		/* 8216D210h case   13:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 8216D210h case   13:*/		return 0x8216D214;
		  /* 8216D214h */ case   14:  		/* cmplw CR6, R11, R8 */
		/* 8216D214h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8216D214h case   14:*/		return 0x8216D218;
		  /* 8216D218h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 8216D218h case   15:*/		if ( regs.CR[6].eq ) { return 0x8216D228;  }
		/* 8216D218h case   15:*/		return 0x8216D21C;
		  /* 8216D21Ch */ case   16:  		/* cmplwi CR6, R29, 0 */
		/* 8216D21Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8216D21Ch case   16:*/		return 0x8216D220;
		  /* 8216D220h */ case   17:  		/* bc 4, CR6_EQ, 232 */
		/* 8216D220h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216D308;  }
		/* 8216D220h case   17:*/		return 0x8216D224;
		  /* 8216D224h */ case   18:  		/* mr R29, R11 */
		/* 8216D224h case   18:*/		regs.R29 = regs.R11;
		/* 8216D224h case   18:*/		return 0x8216D228;
	}
	return 0x8216D228;
} // Block from 8216D1DCh-8216D228h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216D228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D228);
		  /* 8216D228h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D228h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D228h case    0:*/		return 0x8216D22C;
		  /* 8216D22Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216D22Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216D22Ch case    1:*/		return 0x8216D230;
		  /* 8216D230h */ case    2:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 8216D230h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 8216D230h case    2:*/		return 0x8216D234;
		  /* 8216D234h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8216D234h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216D240;  }
		/* 8216D234h case    3:*/		return 0x8216D238;
		  /* 8216D238h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8216D238h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216D238h case    4:*/		return 0x8216D23C;
		  /* 8216D23Ch */ case    5:  		/* bc 4, CR6_EQ, -68 */
		/* 8216D23Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216D1F8;  }
		/* 8216D23Ch case    5:*/		return 0x8216D240;
	}
	return 0x8216D240;
} // Block from 8216D228h-8216D240h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216D240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D240);
		  /* 8216D240h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8216D240h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8216D240h case    0:*/		return 0x8216D244;
		  /* 8216D244h */ case    1:  		/* bc 12, CR6_EQ, 200 */
		/* 8216D244h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216D30C;  }
		/* 8216D244h case    1:*/		return 0x8216D248;
		  /* 8216D248h */ case    2:  		/* addic R11, R25, -1 */
		/* 8216D248h case    2:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R25,0xFFFFFFFF);
		/* 8216D248h case    2:*/		return 0x8216D24C;
		  /* 8216D24Ch */ case    3:  		/* subfe R11, R11, R11 */
		/* 8216D24Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8216D24Ch case    3:*/		return 0x8216D250;
		  /* 8216D250h */ case    4:  		/* and R30, R11, R26 */
		/* 8216D250h case    4:*/		cpu::op::and<0>(regs,&regs.R30,regs.R11,regs.R26);
		/* 8216D250h case    4:*/		return 0x8216D254;
		  /* 8216D254h */ case    5:  		/* cmplwi CR6, R30, 0 */
		/* 8216D254h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216D254h case    5:*/		return 0x8216D258;
		  /* 8216D258h */ case    6:  		/* bc 12, CR6_EQ, 176 */
		/* 8216D258h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216D308;  }
		/* 8216D258h case    6:*/		return 0x8216D25C;
		  /* 8216D25Ch */ case    7:  		/* lwz R11, <#[R30 + 28]> */
		/* 8216D25Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8216D25Ch case    7:*/		return 0x8216D260;
		  /* 8216D260h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216D260h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D260h case    8:*/		return 0x8216D264;
		  /* 8216D264h */ case    9:  		/* bc 4, CR0_EQ, 136 */
		/* 8216D264h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8216D2EC;  }
		/* 8216D264h case    9:*/		return 0x8216D268;
		  /* 8216D268h */ case   10:  		/* lwz R11, <#[R30 + 24]> */
		/* 8216D268h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8216D268h case   10:*/		return 0x8216D26C;
		  /* 8216D26Ch */ case   11:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D26Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D26Ch case   11:*/		return 0x8216D270;
		  /* 8216D270h */ case   12:  		/* addic. R31, R11, -40 */
		/* 8216D270h case   12:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216D270h case   12:*/		return 0x8216D274;
		  /* 8216D274h */ case   13:  		/* bc 12, CR0_EQ, 120 */
		/* 8216D274h case   13:*/		if ( regs.CR[0].eq ) { return 0x8216D2EC;  }
		/* 8216D274h case   13:*/		return 0x8216D278;
		  /* 8216D278h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216D278h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216D278h case   14:*/		return 0x8216D27C;
		  /* 8216D27Ch */ case   15:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216D27Ch case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216D27Ch case   15:*/		return 0x8216D280;
		  /* 8216D280h */ case   16:  		/* cmplwi CR6, R11, 86 */
		/* 8216D280h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 8216D280h case   16:*/		return 0x8216D284;
		  /* 8216D284h */ case   17:  		/* bc 12, CR6_EQ, 48 */
		/* 8216D284h case   17:*/		if ( regs.CR[6].eq ) { return 0x8216D2B4;  }
		/* 8216D284h case   17:*/		return 0x8216D288;
		  /* 8216D288h */ case   18:  		/* cmplwi CR6, R11, 87 */
		/* 8216D288h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 8216D288h case   18:*/		return 0x8216D28C;
		  /* 8216D28Ch */ case   19:  		/* bc 12, CR6_EQ, 40 */
		/* 8216D28Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x8216D2B4;  }
		/* 8216D28Ch case   19:*/		return 0x8216D290;
		  /* 8216D290h */ case   20:  		/* cmplwi CR6, R11, 89 */
		/* 8216D290h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 8216D290h case   20:*/		return 0x8216D294;
		  /* 8216D294h */ case   21:  		/* bc 12, CR6_EQ, 32 */
		/* 8216D294h case   21:*/		if ( regs.CR[6].eq ) { return 0x8216D2B4;  }
		/* 8216D294h case   21:*/		return 0x8216D298;
		  /* 8216D298h */ case   22:  		/* cmplwi CR6, R11, 90 */
		/* 8216D298h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 8216D298h case   22:*/		return 0x8216D29C;
		  /* 8216D29Ch */ case   23:  		/* bc 12, CR6_EQ, 24 */
		/* 8216D29Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x8216D2B4;  }
		/* 8216D29Ch case   23:*/		return 0x8216D2A0;
		  /* 8216D2A0h */ case   24:  		/* cmplwi CR6, R11, 84 */
		/* 8216D2A0h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000054);
		/* 8216D2A0h case   24:*/		return 0x8216D2A4;
		  /* 8216D2A4h */ case   25:  		/* bc 12, CR6_EQ, 16 */
		/* 8216D2A4h case   25:*/		if ( regs.CR[6].eq ) { return 0x8216D2B4;  }
		/* 8216D2A4h case   25:*/		return 0x8216D2A8;
		  /* 8216D2A8h */ case   26:  		/* cmplwi CR6, R11, 85 */
		/* 8216D2A8h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000055);
		/* 8216D2A8h case   26:*/		return 0x8216D2AC;
		  /* 8216D2ACh */ case   27:  		/* li R11, 0 */
		/* 8216D2ACh case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216D2ACh case   27:*/		return 0x8216D2B0;
		  /* 8216D2B0h */ case   28:  		/* bc 4, CR6_EQ, 8 */
		/* 8216D2B0h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8216D2B8;  }
		/* 8216D2B0h case   28:*/		return 0x8216D2B4;
	}
	return 0x8216D2B4;
} // Block from 8216D240h-8216D2B4h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8216D2B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D2B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D2B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D2B4);
		  /* 8216D2B4h */ case    0:  		/* li R11, 1 */
		/* 8216D2B4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216D2B4h case    0:*/		return 0x8216D2B8;
	}
	return 0x8216D2B8;
} // Block from 8216D2B4h-8216D2B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D2B8);
		  /* 8216D2B8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216D2B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D2B8h case    0:*/		return 0x8216D2BC;
		  /* 8216D2BCh */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8216D2BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8216D2EC;  }
		/* 8216D2BCh case    1:*/		return 0x8216D2C0;
	}
	return 0x8216D2C0;
} // Block from 8216D2B8h-8216D2C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216D2C0h
// Function '?XGValidateMicrocodeLite@@YAHPBKH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D2C0);
		  /* 8216D2C0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216D2C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216D2C0h case    0:*/		return 0x8216D2C4;
		  /* 8216D2C4h */ case    1:  		/* mr R3, R27 */
		/* 8216D2C4h case    1:*/		regs.R3 = regs.R27;
		/* 8216D2C4h case    1:*/		return 0x8216D2C8;
		  /* 8216D2C8h */ case    2:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216D2C8h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216D2C8h case    2:*/		return 0x8216D2CC;
		  /* 8216D2CCh */ case    3:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8216D2CCh case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8216D2CCh case    3:*/		return 0x8216D2D0;
		  /* 8216D2D0h */ case    4:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216D2D0h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216D2D0h case    4:*/		return 0x8216D2D4;
		  /* 8216D2D4h */ case    5:  		/* bl -36516 */
		/* 8216D2D4h case    5:*/		regs.LR = 0x8216D2D8; return 0x82164430;
		/* 8216D2D4h case    5:*/		return 0x8216D2D8;
		  /* 8216D2D8h */ case    6:  		/* addi R11, R31, -16 */
		/* 8216D2D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8216D2D8h case    6:*/		return 0x8216D2DC;
		  /* 8216D2DCh */ case    7:  		/* lwzx R11, <#[R3 + R11]> */
		/* 8216D2DCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 8216D2DCh case    7:*/		return 0x8216D2E0;
		  /* 8216D2E0h */ case    8:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8216D2E0h case    8:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8216D2E0h case    8:*/		return 0x8216D2E4;
		  /* 8216D2E4h */ case    9:  		/* cmplw CR6, R11, R29 */
		/* 8216D2E4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8216D2E4h case    9:*/		return 0x8216D2E8;
		  /* 8216D2E8h */ case   10:  		/* bc 12, CR6_EQ, -620 */
		/* 8216D2E8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216D07C;  }
		/* 8216D2E8h case   10:*/		return 0x8216D2EC;
	}
	return 0x8216D2EC;
} // Block from 8216D2C0h-8216D2ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216D2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D2EC);
		  /* 8216D2ECh */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8216D2ECh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8216D2ECh case    0:*/		return 0x8216D2F0;
		  /* 8216D2F0h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216D2F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D2F0h case    1:*/		return 0x8216D2F4;
		  /* 8216D2F4h */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216D2F4h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D2F4h case    2:*/		return 0x8216D2F8;
		  /* 8216D2F8h */ case    3:  		/* addic R10, R10, -1 */
		/* 8216D2F8h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216D2F8h case    3:*/		return 0x8216D2FC;
		  /* 8216D2FCh */ case    4:  		/* subfe R10, R10, R10 */
		/* 8216D2FCh case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216D2FCh case    4:*/		return 0x8216D300;
		  /* 8216D300h */ case    5:  		/* and R30, R10, R11 */
		/* 8216D300h case    5:*/		cpu::op::and<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 8216D300h case    5:*/		return 0x8216D304;
		  /* 8216D304h */ case    6:  		/* b -176 */
		/* 8216D304h case    6:*/		return 0x8216D254;
		/* 8216D304h case    6:*/		return 0x8216D308;
	}
	return 0x8216D308;
} // Block from 8216D2ECh-8216D308h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216D308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D308);
		  /* 8216D308h */ case    0:  		/* li R3, 0 */
		/* 8216D308h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216D308h case    0:*/		return 0x8216D30C;
	}
	return 0x8216D30C;
} // Block from 8216D308h-8216D30Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D30C);
		  /* 8216D30Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8216D30Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216D30Ch case    0:*/		return 0x8216D310;
		  /* 8216D310h */ case    1:  		/* b -901236 */
		/* 8216D310h case    1:*/		return 0x8209129C;
		/* 8216D310h case    1:*/		return 0x8216D314;
		  /* 8216D314h */ case    2:  		/* nop */
		/* 8216D314h case    2:*/		cpu::op::nop();
		/* 8216D314h case    2:*/		return 0x8216D318;
	}
	return 0x8216D318;
} // Block from 8216D30Ch-8216D318h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216D318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D318);
		  /* 8216D318h */ case    0:  		/* mfspr R12, LR */
		/* 8216D318h case    0:*/		regs.R12 = regs.LR;
		/* 8216D318h case    0:*/		return 0x8216D31C;
		  /* 8216D31Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216D31Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216D31Ch case    1:*/		return 0x8216D320;
		  /* 8216D320h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8216D320h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216D320h case    2:*/		return 0x8216D324;
		  /* 8216D324h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216D324h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216D324h case    3:*/		return 0x8216D328;
		  /* 8216D328h */ case    4:  		/* addi R11, R4, 24 */
		/* 8216D328h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x18);
		/* 8216D328h case    4:*/		return 0x8216D32C;
		  /* 8216D32Ch */ case    5:  		/* lwz R10, <#[R4 + 28]> */
		/* 8216D32Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 8216D32Ch case    5:*/		return 0x8216D330;
		  /* 8216D330h */ case    6:  		/* addi R31, R11, 4 */
		/* 8216D330h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4);
		/* 8216D330h case    6:*/		return 0x8216D334;
		  /* 8216D334h */ case    7:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 8216D334h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8216D334h case    7:*/		return 0x8216D338;
		  /* 8216D338h */ case    8:  		/* bc 4, CR0_EQ, 28 */
		/* 8216D338h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8216D354;  }
		/* 8216D338h case    8:*/		return 0x8216D33C;
		  /* 8216D33Ch */ case    9:  		/* cmplwi CR0, R10, 0 */
		/* 8216D33Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8216D33Ch case    9:*/		return 0x8216D340;
		  /* 8216D340h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 8216D340h case   10:*/		if ( regs.CR[0].eq ) { return 0x8216D354;  }
		/* 8216D340h case   10:*/		return 0x8216D344;
		  /* 8216D344h */ case   11:  		/* lwz R11, <#[R10 + 8]> */
		/* 8216D344h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8216D344h case   11:*/		return 0x8216D348;
		  /* 8216D348h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216D348h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216D348h case   12:*/		return 0x8216D34C;
		  /* 8216D34Ch */ case   13:  		/* cmplwi CR6, R11, 16128 */
		/* 8216D34Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003F00);
		/* 8216D34Ch case   13:*/		return 0x8216D350;
		  /* 8216D350h */ case   14:  		/* bc 12, CR6_EQ, 76 */
		/* 8216D350h case   14:*/		if ( regs.CR[6].eq ) { return 0x8216D39C;  }
		/* 8216D350h case   14:*/		return 0x8216D354;
	}
	return 0x8216D354;
} // Block from 8216D318h-8216D354h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216D354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D354);
		  /* 8216D354h */ case    0:  		/* li R8, 0 */
		/* 8216D354h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216D354h case    0:*/		return 0x8216D358;
		  /* 8216D358h */ case    1:  		/* li R7, 0 */
		/* 8216D358h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216D358h case    1:*/		return 0x8216D35C;
		  /* 8216D35Ch */ case    2:  		/* li R6, 126 */
		/* 8216D35Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x7E);
		/* 8216D35Ch case    2:*/		return 0x8216D360;
		  /* 8216D360h */ case    3:  		/* li R5, 0 */
		/* 8216D360h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216D360h case    3:*/		return 0x8216D364;
		  /* 8216D364h */ case    4:  		/* bl 751156 */
		/* 8216D364h case    4:*/		regs.LR = 0x8216D368; return 0x82224998;
		/* 8216D364h case    4:*/		return 0x8216D368;
		  /* 8216D368h */ case    5:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8216D368h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8216D368h case    5:*/		return 0x8216D36C;
		  /* 8216D36Ch */ case    6:  		/* lwz R8, <#[R31]> */
		/* 8216D36Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8216D36Ch case    6:*/		return 0x8216D370;
		  /* 8216D370h */ case    7:  		/* ori R7, R31, 1 */
		/* 8216D370h case    7:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R31,0x1);
		/* 8216D370h case    7:*/		return 0x8216D374;
		  /* 8216D374h */ case    8:  		/* addi R11, R11, 36 */
		/* 8216D374h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8216D374h case    8:*/		return 0x8216D378;
		  /* 8216D378h */ case    9:  		/* mr R10, R3 */
		/* 8216D378h case    9:*/		regs.R10 = regs.R3;
		/* 8216D378h case    9:*/		return 0x8216D37C;
		  /* 8216D37Ch */ case   10:  		/* addi R9, R11, 4 */
		/* 8216D37Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8216D37Ch case   10:*/		return 0x8216D380;
		  /* 8216D380h */ case   11:  		/* addi R6, R11, -36 */
		/* 8216D380h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 8216D380h case   11:*/		return 0x8216D384;
		  /* 8216D384h */ case   12:  		/* stw R8, <#[R11 + 4]> */
		/* 8216D384h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D384h case   12:*/		return 0x8216D388;
		  /* 8216D388h */ case   13:  		/* lwz R8, <#[R31]> */
		/* 8216D388h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8216D388h case   13:*/		return 0x8216D38C;
		  /* 8216D38Ch */ case   14:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 8216D38Ch case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 8216D38Ch case   14:*/		return 0x8216D390;
		  /* 8216D390h */ case   15:  		/* stw R9, <#[R8 + 36]> */
		/* 8216D390h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000024) );
		/* 8216D390h case   15:*/		return 0x8216D394;
		  /* 8216D394h */ case   16:  		/* stw R7, <#[R11]> */
		/* 8216D394h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D394h case   16:*/		return 0x8216D398;
		  /* 8216D398h */ case   17:  		/* stw R6, <#[R31]> */
		/* 8216D398h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 8216D398h case   17:*/		return 0x8216D39C;
	}
	return 0x8216D39C;
} // Block from 8216D354h-8216D39Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8216D39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D39C);
		  /* 8216D39Ch */ case    0:  		/* lwz R11, <#[R10 + 20]> */
		/* 8216D39Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 8216D39Ch case    0:*/		return 0x8216D3A0;
		  /* 8216D3A0h */ case    1:  		/* mr R3, R10 */
		/* 8216D3A0h case    1:*/		regs.R3 = regs.R10;
		/* 8216D3A0h case    1:*/		return 0x8216D3A4;
		  /* 8216D3A4h */ case    2:  		/* oris R11, R11, 1 */
		/* 8216D3A4h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216D3A4h case    2:*/		return 0x8216D3A8;
		  /* 8216D3A8h */ case    3:  		/* stw R11, <#[R10 + 20]> */
		/* 8216D3A8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 8216D3A8h case    3:*/		return 0x8216D3AC;
		  /* 8216D3ACh */ case    4:  		/* addi R1, R1, 96 */
		/* 8216D3ACh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216D3ACh case    4:*/		return 0x8216D3B0;
		  /* 8216D3B0h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216D3B0h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216D3B0h case    5:*/		return 0x8216D3B4;
		  /* 8216D3B4h */ case    6:  		/* mtspr LR, R12 */
		/* 8216D3B4h case    6:*/		regs.LR = regs.R12;
		/* 8216D3B4h case    6:*/		return 0x8216D3B8;
		  /* 8216D3B8h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 8216D3B8h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216D3B8h case    7:*/		return 0x8216D3BC;
		  /* 8216D3BCh */ case    8:  		/* bclr 20, CR0_LT */
		/* 8216D3BCh case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216D3BCh case    8:*/		return 0x8216D3C0;
	}
	return 0x8216D3C0;
} // Block from 8216D39Ch-8216D3C0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216D3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D3C0);
		  /* 8216D3C0h */ case    0:  		/* mfspr R12, LR */
		/* 8216D3C0h case    0:*/		regs.R12 = regs.LR;
		/* 8216D3C0h case    0:*/		return 0x8216D3C4;
		  /* 8216D3C4h */ case    1:  		/* bl -901480 */
		/* 8216D3C4h case    1:*/		regs.LR = 0x8216D3C8; return 0x8209125C;
		/* 8216D3C4h case    1:*/		return 0x8216D3C8;
		  /* 8216D3C8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216D3C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216D3C8h case    2:*/		return 0x8216D3CC;
		  /* 8216D3CCh */ case    3:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 8216D3CCh case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 8216D3CCh case    3:*/		return 0x8216D3D0;
		  /* 8216D3D0h */ case    4:  		/* mr R29, R3 */
		/* 8216D3D0h case    4:*/		regs.R29 = regs.R3;
		/* 8216D3D0h case    4:*/		return 0x8216D3D4;
		  /* 8216D3D4h */ case    5:  		/* mr R30, R4 */
		/* 8216D3D4h case    5:*/		regs.R30 = regs.R4;
		/* 8216D3D4h case    5:*/		return 0x8216D3D8;
		  /* 8216D3D8h */ case    6:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216D3D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216D3D8h case    6:*/		return 0x8216D3DC;
		  /* 8216D3DCh */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D3DCh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D3DCh case    7:*/		return 0x8216D3E0;
		  /* 8216D3E0h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 8216D3E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216D3EC;  }
		/* 8216D3E0h case    8:*/		return 0x8216D3E4;
		  /* 8216D3E4h */ case    9:  		/* li R31, 0 */
		/* 8216D3E4h case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8216D3E4h case    9:*/		return 0x8216D3E8;
		  /* 8216D3E8h */ case   10:  		/* b 160 */
		/* 8216D3E8h case   10:*/		return 0x8216D488;
		/* 8216D3E8h case   10:*/		return 0x8216D3EC;
	}
	return 0x8216D3EC;
} // Block from 8216D3C0h-8216D3ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216D3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D3EC);
		  /* 8216D3ECh */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D3ECh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D3ECh case    0:*/		return 0x8216D3F0;
		  /* 8216D3F0h */ case    1:  		/* addic. R31, R11, -40 */
		/* 8216D3F0h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216D3F0h case    1:*/		return 0x8216D3F4;
		  /* 8216D3F4h */ case    2:  		/* bc 12, CR0_EQ, 148 */
		/* 8216D3F4h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216D488;  }
		/* 8216D3F4h case    2:*/		return 0x8216D3F8;
		  /* 8216D3F8h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216D3F8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216D3F8h case    3:*/		return 0x8216D3FC;
		  /* 8216D3FCh */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216D3FCh case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216D3FCh case    4:*/		return 0x8216D400;
		  /* 8216D400h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 8216D400h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216D400h case    5:*/		return 0x8216D404;
		  /* 8216D404h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 8216D404h case    6:*/		if ( regs.CR[6].lt ) { return 0x8216D414;  }
		/* 8216D404h case    6:*/		return 0x8216D408;
		  /* 8216D408h */ case    7:  		/* cmplwi CR6, R11, 31 */
		/* 8216D408h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 8216D408h case    7:*/		return 0x8216D40C;
		  /* 8216D40Ch */ case    8:  		/* li R11, 1 */
		/* 8216D40Ch case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216D40Ch case    8:*/		return 0x8216D410;
		  /* 8216D410h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8216D410h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8216D418;  }
		/* 8216D410h case    9:*/		return 0x8216D414;
	}
	return 0x8216D414;
} // Block from 8216D3ECh-8216D414h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216D414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D414);
		  /* 8216D414h */ case    0:  		/* li R11, 0 */
		/* 8216D414h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216D414h case    0:*/		return 0x8216D418;
	}
	return 0x8216D418;
} // Block from 8216D414h-8216D418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D418);
		  /* 8216D418h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216D418h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D418h case    0:*/		return 0x8216D41C;
		  /* 8216D41Ch */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 8216D41Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8216D470;  }
		/* 8216D41Ch case    1:*/		return 0x8216D420;
		  /* 8216D420h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8216D420h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8216D420h case    2:*/		return 0x8216D424;
		  /* 8216D424h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216D424h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216D424h case    3:*/		return 0x8216D428;
		  /* 8216D428h */ case    4:  		/* cmplwi CR6, R11, 32 */
		/* 8216D428h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 8216D428h case    4:*/		return 0x8216D42C;
		  /* 8216D42Ch */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 8216D42Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8216D43C;  }
		/* 8216D42Ch case    5:*/		return 0x8216D430;
	}
	return 0x8216D430;
} // Block from 8216D418h-8216D430h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216D430h
// Function 'XGValidateVertexShaderMicrocodeLite'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D430);
		  /* 8216D430h */ case    0:  		/* cmplwi CR6, R11, 82 */
		/* 8216D430h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 8216D430h case    0:*/		return 0x8216D434;
		  /* 8216D434h */ case    1:  		/* li R11, 1 */
		/* 8216D434h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216D434h case    1:*/		return 0x8216D438;
	}
	return 0x8216D438;
} // Block from 8216D430h-8216D438h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216D438h
// Function 'XGValidatePixelShaderMicrocodeLite'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D438);
		  /* 8216D438h */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 8216D438h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8216D440;  }
		/* 8216D438h case    0:*/		return 0x8216D43C;
	}
	return 0x8216D43C;
} // Block from 8216D438h-8216D43Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D43C);
		  /* 8216D43Ch */ case    0:  		/* li R11, 0 */
		/* 8216D43Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216D43Ch case    0:*/		return 0x8216D440;
	}
	return 0x8216D440;
} // Block from 8216D43Ch-8216D440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D440h
// Function '?AddSideEffect@Block@D3DXShader@@QAAXW4SideEffect@2@PAVInstruction@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D440);
		  /* 8216D440h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216D440h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D440h case    0:*/		return 0x8216D444;
		  /* 8216D444h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 8216D444h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216D470;  }
		/* 8216D444h case    1:*/		return 0x8216D448;
		  /* 8216D448h */ case    2:  		/* mr R3, R31 */
		/* 8216D448h case    2:*/		regs.R3 = regs.R31;
		/* 8216D448h case    2:*/		return 0x8216D44C;
		  /* 8216D44Ch */ case    3:  		/* bl -34524 */
		/* 8216D44Ch case    3:*/		regs.LR = 0x8216D450; return 0x82164D70;
		/* 8216D44Ch case    3:*/		return 0x8216D450;
		  /* 8216D450h */ case    4:  		/* cmplw CR6, R30, R3 */
		/* 8216D450h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R3);
		/* 8216D450h case    4:*/		return 0x8216D454;
		  /* 8216D454h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 8216D454h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216D470;  }
		/* 8216D454h case    5:*/		return 0x8216D458;
		  /* 8216D458h */ case    6:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216D458h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216D458h case    6:*/		return 0x8216D45C;
		  /* 8216D45Ch */ case    7:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216D45Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216D45Ch case    7:*/		return 0x8216D460;
		  /* 8216D460h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D460h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D460h case    8:*/		return 0x8216D464;
		  /* 8216D464h */ case    9:  		/* bc 4, CR0_EQ, -128 */
		/* 8216D464h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8216D3E4;  }
		/* 8216D464h case    9:*/		return 0x8216D468;
		  /* 8216D468h */ case   10:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D468h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D468h case   10:*/		return 0x8216D46C;
		  /* 8216D46Ch */ case   11:  		/* addi R31, R11, -40 */
		/* 8216D46Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216D46Ch case   11:*/		return 0x8216D470;
	}
	return 0x8216D470;
} // Block from 8216D440h-8216D470h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216D470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D470);
		  /* 8216D470h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8216D470h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216D470h case    0:*/		return 0x8216D474;
		  /* 8216D474h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8216D474h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216D488;  }
		/* 8216D474h case    1:*/		return 0x8216D478;
		  /* 8216D478h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216D478h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216D478h case    2:*/		return 0x8216D47C;
		  /* 8216D47Ch */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216D47Ch case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216D47Ch case    3:*/		return 0x8216D480;
		  /* 8216D480h */ case    4:  		/* cmplwi CR6, R11, 16128 */
		/* 8216D480h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003F00);
		/* 8216D480h case    4:*/		return 0x8216D484;
		  /* 8216D484h */ case    5:  		/* bc 12, CR6_EQ, 152 */
		/* 8216D484h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216D51C;  }
		/* 8216D484h case    5:*/		return 0x8216D488;
	}
	return 0x8216D488;
} // Block from 8216D470h-8216D488h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216D488h
// Function '?HasCompatiblePredicateState@Block@D3DXShader@@QAA_NPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D488);
		  /* 8216D488h */ case    0:  		/* li R8, 0 */
		/* 8216D488h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216D488h case    0:*/		return 0x8216D48C;
		  /* 8216D48Ch */ case    1:  		/* lwz R4, <#[R30 + 28]> */
		/* 8216D48Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000001C) );
		/* 8216D48Ch case    1:*/		return 0x8216D490;
		  /* 8216D490h */ case    2:  		/* li R7, 0 */
		/* 8216D490h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216D490h case    2:*/		return 0x8216D494;
		  /* 8216D494h */ case    3:  		/* li R6, 126 */
		/* 8216D494h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x7E);
		/* 8216D494h case    3:*/		return 0x8216D498;
		  /* 8216D498h */ case    4:  		/* li R5, 0 */
		/* 8216D498h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216D498h case    4:*/		return 0x8216D49C;
		  /* 8216D49Ch */ case    5:  		/* mr R3, R29 */
		/* 8216D49Ch case    5:*/		regs.R3 = regs.R29;
		/* 8216D49Ch case    5:*/		return 0x8216D4A0;
		  /* 8216D4A0h */ case    6:  		/* bl 750840 */
		/* 8216D4A0h case    6:*/		regs.LR = 0x8216D4A4; return 0x82224998;
		/* 8216D4A0h case    6:*/		return 0x8216D4A4;
		  /* 8216D4A4h */ case    7:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 8216D4A4h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 8216D4A4h case    7:*/		return 0x8216D4A8;
		  /* 8216D4A8h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 8216D4A8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216D4A8h case    8:*/		return 0x8216D4AC;
		  /* 8216D4ACh */ case    9:  		/* addi R10, R10, 36 */
		/* 8216D4ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 8216D4ACh case    9:*/		return 0x8216D4B0;
		  /* 8216D4B0h */ case   10:  		/* addi R8, R10, 4 */
		/* 8216D4B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 8216D4B0h case   10:*/		return 0x8216D4B4;
		  /* 8216D4B4h */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 8216D4B4h case   11:*/		if ( regs.CR[6].eq ) { return 0x8216D4E8;  }
		/* 8216D4B4h case   11:*/		return 0x8216D4B8;
		  /* 8216D4B8h */ case   12:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216D4B8h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216D4B8h case   12:*/		return 0x8216D4BC;
		  /* 8216D4BCh */ case   13:  		/* addi R7, R10, -36 */
		/* 8216D4BCh case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 8216D4BCh case   13:*/		return 0x8216D4C0;
		  /* 8216D4C0h */ case   14:  		/* addi R11, R11, 36 */
		/* 8216D4C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8216D4C0h case   14:*/		return 0x8216D4C4;
		  /* 8216D4C4h */ case   15:  		/* addi R9, R11, 4 */
		/* 8216D4C4h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8216D4C4h case   15:*/		return 0x8216D4C8;
		  /* 8216D4C8h */ case   16:  		/* lwz R6, <#[R11 + 4]> */
		/* 8216D4C8h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D4C8h case   16:*/		return 0x8216D4CC;
		  /* 8216D4CCh */ case   17:  		/* stw R6, <#[R10 + 4]> */
		/* 8216D4CCh case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8216D4CCh case   17:*/		return 0x8216D4D0;
		  /* 8216D4D0h */ case   18:  		/* lwz R6, <#[R11 + 4]> */
		/* 8216D4D0h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D4D0h case   18:*/		return 0x8216D4D4;
		  /* 8216D4D4h */ case   19:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8216D4D4h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8216D4D4h case   19:*/		return 0x8216D4D8;
		  /* 8216D4D8h */ case   20:  		/* stw R8, <#[R6 + 36]> */
		/* 8216D4D8h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 8216D4D8h case   20:*/		return 0x8216D4DC;
		  /* 8216D4DCh */ case   21:  		/* stw R9, <#[R10]> */
		/* 8216D4DCh case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216D4DCh case   21:*/		return 0x8216D4E0;
		  /* 8216D4E0h */ case   22:  		/* stw R7, <#[R11 + 4]> */
		/* 8216D4E0h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D4E0h case   22:*/		return 0x8216D4E4;
		  /* 8216D4E4h */ case   23:  		/* b 52 */
		/* 8216D4E4h case   23:*/		return 0x8216D518;
		/* 8216D4E4h case   23:*/		return 0x8216D4E8;
	}
	return 0x8216D4E8;
} // Block from 8216D488h-8216D4E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8216D4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D4E8);
		  /* 8216D4E8h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8216D4E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8216D4E8h case    0:*/		return 0x8216D4EC;
		  /* 8216D4ECh */ case    1:  		/* addi R6, R10, -36 */
		/* 8216D4ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 8216D4ECh case    1:*/		return 0x8216D4F0;
		  /* 8216D4F0h */ case    2:  		/* addi R11, R11, 24 */
		/* 8216D4F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8216D4F0h case    2:*/		return 0x8216D4F4;
		  /* 8216D4F4h */ case    3:  		/* addi R9, R11, 4 */
		/* 8216D4F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8216D4F4h case    3:*/		return 0x8216D4F8;
		  /* 8216D4F8h */ case    4:  		/* ori R9, R9, 1 */
		/* 8216D4F8h case    4:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216D4F8h case    4:*/		return 0x8216D4FC;
		  /* 8216D4FCh */ case    5:  		/* lwz R7, <#[R11 + 4]> */
		/* 8216D4FCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D4FCh case    5:*/		return 0x8216D500;
		  /* 8216D500h */ case    6:  		/* stw R7, <#[R10 + 4]> */
		/* 8216D500h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8216D500h case    6:*/		return 0x8216D504;
		  /* 8216D504h */ case    7:  		/* lwz R7, <#[R11 + 4]> */
		/* 8216D504h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D504h case    7:*/		return 0x8216D508;
		  /* 8216D508h */ case    8:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 8216D508h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 8216D508h case    8:*/		return 0x8216D50C;
		  /* 8216D50Ch */ case    9:  		/* stw R8, <#[R7 + 36]> */
		/* 8216D50Ch case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 8216D50Ch case    9:*/		return 0x8216D510;
		  /* 8216D510h */ case   10:  		/* stw R9, <#[R10]> */
		/* 8216D510h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216D510h case   10:*/		return 0x8216D514;
		  /* 8216D514h */ case   11:  		/* stw R6, <#[R11 + 4]> */
		/* 8216D514h case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D514h case   11:*/		return 0x8216D518;
	}
	return 0x8216D518;
} // Block from 8216D4E8h-8216D518h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216D518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D518);
		  /* 8216D518h */ case    0:  		/* mr R31, R3 */
		/* 8216D518h case    0:*/		regs.R31 = regs.R3;
		/* 8216D518h case    0:*/		return 0x8216D51C;
	}
	return 0x8216D51C;
} // Block from 8216D518h-8216D51Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D51C);
		  /* 8216D51Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8216D51Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216D51Ch case    0:*/		return 0x8216D520;
	}
	return 0x8216D520;
} // Block from 8216D51Ch-8216D520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D520h
// Function '??0DataFlowPredecessorEnumerator@D3DXShader@@QAA@PAVBlock@1@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D520);
		  /* 8216D520h */ case    0:  		/* mr R3, R31 */
		/* 8216D520h case    0:*/		regs.R3 = regs.R31;
		/* 8216D520h case    0:*/		return 0x8216D524;
		  /* 8216D524h */ case    1:  		/* oris R11, R11, 1 */
		/* 8216D524h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216D524h case    1:*/		return 0x8216D528;
		  /* 8216D528h */ case    2:  		/* stw R11, <#[R31 + 20]> */
		/* 8216D528h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216D528h case    2:*/		return 0x8216D52C;
		  /* 8216D52Ch */ case    3:  		/* addi R1, R1, 112 */
		/* 8216D52Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216D52Ch case    3:*/		return 0x8216D530;
		  /* 8216D530h */ case    4:  		/* b -901764 */
		/* 8216D530h case    4:*/		return 0x820912AC;
		/* 8216D530h case    4:*/		return 0x8216D534;
		  /* 8216D534h */ case    5:  		/* nop */
		/* 8216D534h case    5:*/		cpu::op::nop();
		/* 8216D534h case    5:*/		return 0x8216D538;
	}
	return 0x8216D538;
} // Block from 8216D520h-8216D538h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216D538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D538);
		  /* 8216D538h */ case    0:  		/* mfspr R12, LR */
		/* 8216D538h case    0:*/		regs.R12 = regs.LR;
		/* 8216D538h case    0:*/		return 0x8216D53C;
		  /* 8216D53Ch */ case    1:  		/* bl -901868 */
		/* 8216D53Ch case    1:*/		regs.LR = 0x8216D540; return 0x82091250;
		/* 8216D53Ch case    1:*/		return 0x8216D540;
		  /* 8216D540h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216D540h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216D540h case    2:*/		return 0x8216D544;
		  /* 8216D544h */ case    3:  		/* mr R29, R4 */
		/* 8216D544h case    3:*/		regs.R29 = regs.R4;
		/* 8216D544h case    3:*/		return 0x8216D548;
		  /* 8216D548h */ case    4:  		/* mr R30, R5 */
		/* 8216D548h case    4:*/		regs.R30 = regs.R5;
		/* 8216D548h case    4:*/		return 0x8216D54C;
		  /* 8216D54Ch */ case    5:  		/* li R5, 6 */
		/* 8216D54Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 8216D54Ch case    5:*/		return 0x8216D550;
		  /* 8216D550h */ case    6:  		/* li R4, 8 */
		/* 8216D550h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 8216D550h case    6:*/		return 0x8216D554;
		  /* 8216D554h */ case    7:  		/* mr R27, R3 */
		/* 8216D554h case    7:*/		regs.R27 = regs.R3;
		/* 8216D554h case    7:*/		return 0x8216D558;
		  /* 8216D558h */ case    8:  		/* bl -35944 */
		/* 8216D558h case    8:*/		regs.LR = 0x8216D55C; return 0x821648F0;
		/* 8216D558h case    8:*/		return 0x8216D55C;
		  /* 8216D55Ch */ case    9:  		/* addi R26, R3, 4 */
		/* 8216D55Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0x4);
		/* 8216D55Ch case    9:*/		return 0x8216D560;
		  /* 8216D560h */ case   10:  		/* ori R11, R3, 1 */
		/* 8216D560h case   10:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216D560h case   10:*/		return 0x8216D564;
		  /* 8216D564h */ case   11:  		/* ori R10, R26, 1 */
		/* 8216D564h case   11:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R26,0x1);
		/* 8216D564h case   11:*/		return 0x8216D568;
		  /* 8216D568h */ case   12:  		/* stw R11, <#[R3 + 4]> */
		/* 8216D568h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8216D568h case   12:*/		return 0x8216D56C;
		  /* 8216D56Ch */ case   13:  		/* mr R31, R3 */
		/* 8216D56Ch case   13:*/		regs.R31 = regs.R3;
		/* 8216D56Ch case   13:*/		return 0x8216D570;
	}
	return 0x8216D570;
} // Block from 8216D538h-8216D570h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216D570h
// Function '?GetNextPredecessor@DataFlowPredecessorEnumerator@D3DXShader@@QAAPAVBlock@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D570);
		  /* 8216D570h */ case    0:  		/* stw R10, <#[R3]> */
		/* 8216D570h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8216D570h case    0:*/		return 0x8216D574;
		  /* 8216D574h */ case    1:  		/* lwz R10, <#[R29 + 76]> */
		/* 8216D574h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000004C) );
		/* 8216D574h case    1:*/		return 0x8216D578;
		  /* 8216D578h */ case    2:  		/* lwz R11, <#[R29 + 48]> */
		/* 8216D578h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8216D578h case    2:*/		return 0x8216D57C;
		  /* 8216D57Ch */ case    3:  		/* oris R11, R11, 16384 */
		/* 8216D57Ch case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 8216D57Ch case    3:*/		return 0x8216D580;
		  /* 8216D580h */ case    4:  		/* rlwinm R10, R10, 0, 3, 1 */
		/* 8216D580h case    4:*/		cpu::op::rlwinm<0,0,3,1>(regs,&regs.R10,regs.R10);
		/* 8216D580h case    4:*/		return 0x8216D584;
		  /* 8216D584h */ case    5:  		/* stw R11, <#[R29 + 48]> */
		/* 8216D584h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8216D584h case    5:*/		return 0x8216D588;
		  /* 8216D588h */ case    6:  		/* stw R10, <#[R29 + 76]> */
		/* 8216D588h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x0000004C) );
		/* 8216D588h case    6:*/		return 0x8216D58C;
		  /* 8216D58Ch */ case    7:  		/* lwz R11, <#[R30 + 76]> */
		/* 8216D58Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 8216D58Ch case    7:*/		return 0x8216D590;
		  /* 8216D590h */ case    8:  		/* lwz R10, <#[R30 + 48]> */
		/* 8216D590h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8216D590h case    8:*/		return 0x8216D594;
		  /* 8216D594h */ case    9:  		/* rlwinm R11, R11, 0, 3, 1 */
		/* 8216D594h case    9:*/		cpu::op::rlwinm<0,0,3,1>(regs,&regs.R11,regs.R11);
		/* 8216D594h case    9:*/		return 0x8216D598;
		  /* 8216D598h */ case   10:  		/* lwz R28, <#[R30 + 8]> */
		/* 8216D598h case   10:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000008) );
		/* 8216D598h case   10:*/		return 0x8216D59C;
		  /* 8216D59Ch */ case   11:  		/* oris R10, R10, 16384 */
		/* 8216D59Ch case   11:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4000);
		/* 8216D59Ch case   11:*/		return 0x8216D5A0;
		  /* 8216D5A0h */ case   12:  		/* stw R11, <#[R30 + 76]> */
		/* 8216D5A0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 8216D5A0h case   12:*/		return 0x8216D5A4;
		  /* 8216D5A4h */ case   13:  		/* stw R10, <#[R30 + 48]> */
		/* 8216D5A4h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8216D5A4h case   13:*/		return 0x8216D5A8;
		  /* 8216D5A8h */ case   14:  		/* cmplwi CR6, R28, 0 */
		/* 8216D5A8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8216D5A8h case   14:*/		return 0x8216D5AC;
		  /* 8216D5ACh */ case   15:  		/* bc 12, CR6_EQ, 160 */
		/* 8216D5ACh case   15:*/		if ( regs.CR[6].eq ) { return 0x8216D64C;  }
		/* 8216D5ACh case   15:*/		return 0x8216D5B0;
		  /* 8216D5B0h */ case   16:  		/* lwz R11, <#[R29 + 48]> */
		/* 8216D5B0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 8216D5B0h case   16:*/		return 0x8216D5B4;
		  /* 8216D5B4h */ case   17:  		/* li R10, 1 */
		/* 8216D5B4h case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216D5B4h case   17:*/		return 0x8216D5B8;
		  /* 8216D5B8h */ case   18:  		/* lwz R30, <#[R28 + 4]> */
		/* 8216D5B8h case   18:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000004) );
		/* 8216D5B8h case   18:*/		return 0x8216D5BC;
		  /* 8216D5BCh */ case   19:  		/* rlwinm R9, R11, 0, 13, 31 */
		/* 8216D5BCh case   19:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 8216D5BCh case   19:*/		return 0x8216D5C0;
		  /* 8216D5C0h */ case   20:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 8216D5C0h case   20:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 8216D5C0h case   20:*/		return 0x8216D5C4;
		  /* 8216D5C4h */ case   21:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8216D5C4h case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8216D5C4h case   21:*/		return 0x8216D5C8;
		  /* 8216D5C8h */ case   22:  		/* addi R11, R11, 1 */
		/* 8216D5C8h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216D5C8h case   22:*/		return 0x8216D5CC;
		  /* 8216D5CCh */ case   23:  		/* lwz R8, <#[R30 + 40]> */
		/* 8216D5CCh case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000028) );
		/* 8216D5CCh case   23:*/		return 0x8216D5D0;
		  /* 8216D5D0h */ case   24:  		/* slw R10, R10, R9 */
		/* 8216D5D0h case   24:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216D5D0h case   24:*/		return 0x8216D5D4;
		  /* 8216D5D4h */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216D5D4h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216D5D4h case   25:*/		return 0x8216D5D8;
		  /* 8216D5D8h */ case   26:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8216D5D8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8216D5D8h case   26:*/		return 0x8216D5DC;
		  /* 8216D5DCh */ case   27:  		/* and. R11, R11, R10 */
		/* 8216D5DCh case   27:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216D5DCh case   27:*/		return 0x8216D5E0;
		  /* 8216D5E0h */ case   28:  		/* bc 12, CR0_EQ, 100 */
		/* 8216D5E0h case   28:*/		if ( regs.CR[0].eq ) { return 0x8216D644;  }
		/* 8216D5E0h case   28:*/		return 0x8216D5E4;
		  /* 8216D5E4h */ case   29:  		/* lwz R11, <#[R30 + 48]> */
		/* 8216D5E4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8216D5E4h case   29:*/		return 0x8216D5E8;
		  /* 8216D5E8h */ case   30:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 8216D5E8h case   30:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D5E8h case   30:*/		return 0x8216D5EC;
		  /* 8216D5ECh */ case   31:  		/* bc 4, CR0_EQ, 88 */
		/* 8216D5ECh case   31:*/		if ( !regs.CR[0].eq ) { return 0x8216D644;  }
		/* 8216D5ECh case   31:*/		return 0x8216D5F0;
		  /* 8216D5F0h */ case   32:  		/* lwz R11, <#[R26]> */
		/* 8216D5F0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8216D5F0h case   32:*/		return 0x8216D5F4;
		  /* 8216D5F4h */ case   33:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216D5F4h case   33:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D5F4h case   33:*/		return 0x8216D5F8;
		  /* 8216D5F8h */ case   34:  		/* bc 4, CR0_EQ, 40 */
		/* 8216D5F8h case   34:*/		if ( !regs.CR[0].eq ) { return 0x8216D620;  }
		/* 8216D5F8h case   34:*/		return 0x8216D5FC;
		  /* 8216D5FCh */ case   35:  		/* lwz R11, <#[R31]> */
		/* 8216D5FCh case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216D5FCh case   35:*/		return 0x8216D600;
		  /* 8216D600h */ case   36:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D600h case   36:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D600h case   36:*/		return 0x8216D604;
		  /* 8216D604h */ case   37:  		/* addic. R3, R11, -4 */
		/* 8216D604h case   37:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 8216D604h case   37:*/		return 0x8216D608;
		  /* 8216D608h */ case   38:  		/* bc 12, CR0_EQ, 24 */
		/* 8216D608h case   38:*/		if ( regs.CR[0].eq ) { return 0x8216D620;  }
		/* 8216D608h case   38:*/		return 0x8216D60C;
		  /* 8216D60Ch */ case   39:  		/* lwz R11, <#[R3 + 8]> */
		/* 8216D60Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216D60Ch case   39:*/		return 0x8216D610;
		  /* 8216D610h */ case   40:  		/* lwz R10, <#[R3 + 12]> */
		/* 8216D610h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8216D610h case   40:*/		return 0x8216D614;
		  /* 8216D614h */ case   41:  		/* addi R11, R11, 1 */
		/* 8216D614h case   41:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216D614h case   41:*/		return 0x8216D618;
	}
	return 0x8216D618;
} // Block from 8216D570h-8216D618h (42 instructions)

//////////////////////////////////////////////////////
// Block at 8216D618h
// Function '?AllocSmallFunctionMem@Compiler@D3DXShader@@QAAPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D618);
		  /* 8216D618h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 8216D618h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216D618h case    0:*/		return 0x8216D61C;
		  /* 8216D61Ch */ case    1:  		/* bc 4, CR6_GT, 16 */
		/* 8216D61Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216D62C;  }
		/* 8216D61Ch case    1:*/		return 0x8216D620;
	}
	return 0x8216D620;
} // Block from 8216D618h-8216D620h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216D620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D620);
		  /* 8216D620h */ case    0:  		/* li R4, 1 */
		/* 8216D620h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216D620h case    0:*/		return 0x8216D624;
		  /* 8216D624h */ case    1:  		/* mr R3, R31 */
		/* 8216D624h case    1:*/		regs.R3 = regs.R31;
		/* 8216D624h case    1:*/		return 0x8216D628;
		  /* 8216D628h */ case    2:  		/* bl 129696 */
		/* 8216D628h case    2:*/		regs.LR = 0x8216D62C; return 0x8218D0C8;
		/* 8216D628h case    2:*/		return 0x8216D62C;
	}
	return 0x8216D62C;
} // Block from 8216D620h-8216D62Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216D62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D62C);
		  /* 8216D62Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8216D62Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216D62Ch case    0:*/		return 0x8216D630;
		  /* 8216D630h */ case    1:  		/* addi R10, R11, 4 */
		/* 8216D630h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8216D630h case    1:*/		return 0x8216D634;
		  /* 8216D634h */ case    2:  		/* addi R9, R11, 1 */
		/* 8216D634h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 8216D634h case    2:*/		return 0x8216D638;
		  /* 8216D638h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8216D638h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8216D638h case    3:*/		return 0x8216D63C;
		  /* 8216D63Ch */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 8216D63Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8216D63Ch case    4:*/		return 0x8216D640;
		  /* 8216D640h */ case    5:  		/* stwx R30, <#[R11 + R3]> */
		/* 8216D640h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216D640h case    5:*/		return 0x8216D644;
	}
	return 0x8216D644;
} // Block from 8216D62Ch-8216D644h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216D644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D644);
		  /* 8216D644h */ case    0:  		/* lwz R28, <#[R28 + 12]> */
		/* 8216D644h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x0000000C) );
		/* 8216D644h case    0:*/		return 0x8216D648;
		  /* 8216D648h */ case    1:  		/* b -160 */
		/* 8216D648h case    1:*/		return 0x8216D5A8;
		/* 8216D648h case    1:*/		return 0x8216D64C;
	}
	return 0x8216D64C;
} // Block from 8216D644h-8216D64Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216D64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D64C);
		  /* 8216D64Ch */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8216D64Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8216D64Ch case    0:*/		return 0x8216D650;
		  /* 8216D650h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D650h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D650h case    1:*/		return 0x8216D654;
		  /* 8216D654h */ case    2:  		/* bc 4, CR0_EQ, 112 */
		/* 8216D654h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216D6C4;  }
		/* 8216D654h case    2:*/		return 0x8216D658;
		  /* 8216D658h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8216D658h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216D658h case    3:*/		return 0x8216D65C;
		  /* 8216D65Ch */ case    4:  		/* bc 12, CR0_EQ, 104 */
		/* 8216D65Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8216D6C4;  }
		/* 8216D65Ch case    4:*/		return 0x8216D660;
		  /* 8216D660h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 8216D660h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216D660h case    5:*/		return 0x8216D664;
		  /* 8216D664h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D664h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D664h case    6:*/		return 0x8216D668;
		  /* 8216D668h */ case    7:  		/* addi R4, R11, -4 */
		/* 8216D668h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8216D668h case    7:*/		return 0x8216D66C;
		  /* 8216D66Ch */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216D66Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D66Ch case    8:*/		return 0x8216D670;
		  /* 8216D670h */ case    9:  		/* addi R10, R11, 3 */
		/* 8216D670h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 8216D670h case    9:*/		return 0x8216D674;
		  /* 8216D674h */ case   10:  		/* addic. R11, R11, -1 */
		/* 8216D674h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8216D674h case   10:*/		return 0x8216D678;
		  /* 8216D678h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216D678h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216D678h case   11:*/		return 0x8216D67C;
		  /* 8216D67Ch */ case   12:  		/* lwzx R30, <#[R10 + R4]> */
		/* 8216D67Ch case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8216D67Ch case   12:*/		return 0x8216D680;
		  /* 8216D680h */ case   13:  		/* stw R11, <#[R4 + 8]> */
		/* 8216D680h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8216D680h case   13:*/		return 0x8216D684;
		  /* 8216D684h */ case   14:  		/* bc 4, CR0_EQ, -248 */
		/* 8216D684h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8216D58C;  }
		/* 8216D684h case   14:*/		return 0x8216D688;
		  /* 8216D688h */ case   15:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 8216D688h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 8216D688h case   15:*/		return 0x8216D68C;
		  /* 8216D68Ch */ case   16:  		/* mr R3, R31 */
		/* 8216D68Ch case   16:*/		regs.R3 = regs.R31;
		/* 8216D68Ch case   16:*/		return 0x8216D690;
		  /* 8216D690h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 8216D690h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D690h case   17:*/		return 0x8216D694;
		  /* 8216D694h */ case   18:  		/* lwz R9, <#[R11]> */
		/* 8216D694h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D694h case   18:*/		return 0x8216D698;
		  /* 8216D698h */ case   19:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8216D698h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8216D698h case   19:*/		return 0x8216D69C;
		  /* 8216D69Ch */ case   20:  		/* stw R9, <#[R10]> */
		/* 8216D69Ch case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216D69Ch case   20:*/		return 0x8216D6A0;
		  /* 8216D6A0h */ case   21:  		/* lwz R10, <#[R11 + 4]> */
		/* 8216D6A0h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D6A0h case   21:*/		return 0x8216D6A4;
		  /* 8216D6A4h */ case   22:  		/* lwz R11, <#[R11]> */
		/* 8216D6A4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D6A4h case   22:*/		return 0x8216D6A8;
	}
	return 0x8216D6A8;
} // Block from 8216D64Ch-8216D6A8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8216D6A8h
// Function '?FindPredicateDep@Instruction@D3DXShader@@QAAPAVDependency@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D6A8);
		  /* 8216D6A8h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D6A8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D6A8h case    0:*/		return 0x8216D6AC;
		  /* 8216D6ACh */ case    1:  		/* stw R10, <#[R11]> */
		/* 8216D6ACh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D6ACh case    1:*/		return 0x8216D6B0;
		  /* 8216D6B0h */ case    2:  		/* lwz R11, <#[R4 + 12]> */
		/* 8216D6B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8216D6B0h case    2:*/		return 0x8216D6B4;
		  /* 8216D6B4h */ case    3:  		/* addi R11, R11, 4 */
		/* 8216D6B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216D6B4h case    3:*/		return 0x8216D6B8;
		  /* 8216D6B8h */ case    4:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8216D6B8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8216D6B8h case    4:*/		return 0x8216D6BC;
		  /* 8216D6BCh */ case    5:  		/* bl -112820 */
		/* 8216D6BCh case    5:*/		regs.LR = 0x8216D6C0; return 0x82151E08;
		/* 8216D6BCh case    5:*/		return 0x8216D6C0;
		  /* 8216D6C0h */ case    6:  		/* b -308 */
		/* 8216D6C0h case    6:*/		return 0x8216D58C;
		/* 8216D6C0h case    6:*/		return 0x8216D6C4;
	}
	return 0x8216D6C4;
} // Block from 8216D6A8h-8216D6C4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216D6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D6C4);
		  /* 8216D6C4h */ case    0:  		/* lwz R10, <#[R27 + 976]> */
		/* 8216D6C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x000003D0) );
		/* 8216D6C4h case    0:*/		return 0x8216D6C8;
		  /* 8216D6C8h */ case    1:  		/* addi R11, R27, 972 */
		/* 8216D6C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x3CC);
		/* 8216D6C8h case    1:*/		return 0x8216D6CC;
		  /* 8216D6CCh */ case    2:  		/* stw R10, <#[R31]> */
		/* 8216D6CCh case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8216D6CCh case    2:*/		return 0x8216D6D0;
		  /* 8216D6D0h */ case    3:  		/* stw R31, <#[R27 + 976]> */
		/* 8216D6D0h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x000003D0) );
		/* 8216D6D0h case    3:*/		return 0x8216D6D4;
		  /* 8216D6D4h */ case    4:  		/* lwz R11, <#[R27 + 4]> */
		/* 8216D6D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8216D6D4h case    4:*/		return 0x8216D6D8;
		  /* 8216D6D8h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D6D8h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D6D8h case    5:*/		return 0x8216D6DC;
		  /* 8216D6DCh */ case    6:  		/* bc 4, CR0_EQ, 48 */
		/* 8216D6DCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216D70C;  }
		/* 8216D6DCh case    6:*/		return 0x8216D6E0;
		  /* 8216D6E0h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 8216D6E0h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216D6E0h case    7:*/		return 0x8216D6E4;
		  /* 8216D6E4h */ case    8:  		/* bc 12, CR0_EQ, 40 */
		/* 8216D6E4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216D70C;  }
		/* 8216D6E4h case    8:*/		return 0x8216D6E8;
		  /* 8216D6E8h */ case    9:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216D6E8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216D6E8h case    9:*/		return 0x8216D6EC;
		  /* 8216D6ECh */ case   10:  		/* rlwinm R9, R11, 0, 0, 30 */
		/* 8216D6ECh case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R11);
		/* 8216D6ECh case   10:*/		return 0x8216D6F0;
		  /* 8216D6F0h */ case   11:  		/* rlwinm R10, R10, 0, 2, 0 */
		/* 8216D6F0h case   11:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R10,regs.R10);
		/* 8216D6F0h case   11:*/		return 0x8216D6F4;
		  /* 8216D6F4h */ case   12:  		/* stw R10, <#[R11 + 48]> */
		/* 8216D6F4h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216D6F4h case   12:*/		return 0x8216D6F8;
		  /* 8216D6F8h */ case   13:  		/* lwz R11, <#[R9 + 4]> */
		/* 8216D6F8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8216D6F8h case   13:*/		return 0x8216D6FC;
		  /* 8216D6FCh */ case   14:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D6FCh case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D6FCh case   14:*/		return 0x8216D700;
		  /* 8216D700h */ case   15:  		/* bc 4, CR0_EQ, 12 */
		/* 8216D700h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8216D70C;  }
		/* 8216D700h case   15:*/		return 0x8216D704;
		  /* 8216D704h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8216D704h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216D704h case   16:*/		return 0x8216D708;
	}
	return 0x8216D708;
} // Block from 8216D6C4h-8216D708h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216D708h
// Function '?ShouldRemoveFakeBranch@Compiler@D3DXShader@@AAA_NPAVInstruction@2@PAUInstruction_ControlTransfer@2@PAPAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D708);
		  /* 8216D708h */ case    0:  		/* bc 4, CR6_EQ, -32 */
		/* 8216D708h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8216D6E8;  }
		/* 8216D708h case    0:*/		return 0x8216D70C;
	}
	return 0x8216D70C;
} // Block from 8216D708h-8216D70Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D70Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D70C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D70C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D70C);
		  /* 8216D70Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8216D70Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216D70Ch case    0:*/		return 0x8216D710;
		  /* 8216D710h */ case    1:  		/* b -902256 */
		/* 8216D710h case    1:*/		return 0x820912A0;
		/* 8216D710h case    1:*/		return 0x8216D714;
		  /* 8216D714h */ case    2:  		/* nop */
		/* 8216D714h case    2:*/		cpu::op::nop();
		/* 8216D714h case    2:*/		return 0x8216D718;
	}
	return 0x8216D718;
} // Block from 8216D70Ch-8216D718h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216D718h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D718);
		  /* 8216D718h */ case    0:  		/* mfspr R12, LR */
		/* 8216D718h case    0:*/		regs.R12 = regs.LR;
		/* 8216D718h case    0:*/		return 0x8216D71C;
		  /* 8216D71Ch */ case    1:  		/* bl -902372 */
		/* 8216D71Ch case    1:*/		regs.LR = 0x8216D720; return 0x82091238;
		/* 8216D71Ch case    1:*/		return 0x8216D720;
		  /* 8216D720h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 8216D720h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 8216D720h case    2:*/		return 0x8216D724;
		  /* 8216D724h */ case    3:  		/* lwz R11, <#[R3 + 40]> */
		/* 8216D724h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 8216D724h case    3:*/		return 0x8216D728;
		  /* 8216D728h */ case    4:  		/* li R21, 0 */
		/* 8216D728h case    4:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8216D728h case    4:*/		return 0x8216D72C;
		  /* 8216D72Ch */ case    5:  		/* mr R24, R3 */
		/* 8216D72Ch case    5:*/		regs.R24 = regs.R3;
		/* 8216D72Ch case    5:*/		return 0x8216D730;
		  /* 8216D730h */ case    6:  		/* li R20, 1 */
		/* 8216D730h case    6:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 8216D730h case    6:*/		return 0x8216D734;
		  /* 8216D734h */ case    7:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 8216D734h case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 8216D734h case    7:*/		return 0x8216D738;
		  /* 8216D738h */ case    8:  		/* mr R23, R21 */
		/* 8216D738h case    8:*/		regs.R23 = regs.R21;
		/* 8216D738h case    8:*/		return 0x8216D73C;
		  /* 8216D73Ch */ case    9:  		/* mr R22, R21 */
		/* 8216D73Ch case    9:*/		regs.R22 = regs.R21;
		/* 8216D73Ch case    9:*/		return 0x8216D740;
		  /* 8216D740h */ case   10:  		/* bc 12, CR0_EQ, 428 */
		/* 8216D740h case   10:*/		if ( regs.CR[0].eq ) { return 0x8216D8EC;  }
		/* 8216D740h case   10:*/		return 0x8216D744;
		  /* 8216D744h */ case   11:  		/* lwz R11, <#[R3 + 4]> */
		/* 8216D744h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8216D744h case   11:*/		return 0x8216D748;
		  /* 8216D748h */ case   12:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D748h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D748h case   12:*/		return 0x8216D74C;
		  /* 8216D74Ch */ case   13:  		/* bc 4, CR0_EQ, 416 */
		/* 8216D74Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x8216D8EC;  }
		/* 8216D74Ch case   13:*/		return 0x8216D750;
		  /* 8216D750h */ case   14:  		/* mr R29, R11 */
		/* 8216D750h case   14:*/		regs.R29 = regs.R11;
		/* 8216D750h case   14:*/		return 0x8216D754;
		  /* 8216D754h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 8216D754h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216D754h case   15:*/		return 0x8216D758;
		  /* 8216D758h */ case   16:  		/* bc 12, CR0_EQ, 404 */
		/* 8216D758h case   16:*/		if ( regs.CR[0].eq ) { return 0x8216D8EC;  }
		/* 8216D758h case   16:*/		return 0x8216D75C;
		  /* 8216D75Ch */ case   17:  		/* lwz R11, <#[R29 + 28]> */
		/* 8216D75Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 8216D75Ch case   17:*/		return 0x8216D760;
		  /* 8216D760h */ case   18:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216D760h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D760h case   18:*/		return 0x8216D764;
		  /* 8216D764h */ case   19:  		/* bc 4, CR0_EQ, 364 */
		/* 8216D764h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8216D8D0;  }
		/* 8216D764h case   19:*/		return 0x8216D768;
		  /* 8216D768h */ case   20:  		/* lwz R11, <#[R29 + 24]> */
		/* 8216D768h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 8216D768h case   20:*/		return 0x8216D76C;
		  /* 8216D76Ch */ case   21:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216D76Ch case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216D76Ch case   21:*/		return 0x8216D770;
		  /* 8216D770h */ case   22:  		/* addic. R30, R11, -40 */
		/* 8216D770h case   22:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 8216D770h case   22:*/		return 0x8216D774;
		  /* 8216D774h */ case   23:  		/* bc 12, CR0_EQ, 348 */
		/* 8216D774h case   23:*/		if ( regs.CR[0].eq ) { return 0x8216D8D0;  }
		/* 8216D774h case   23:*/		return 0x8216D778;
		  /* 8216D778h */ case   24:  		/* lwz R31, <#[R30 + 8]> */
		/* 8216D778h case   24:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000008) );
		/* 8216D778h case   24:*/		return 0x8216D77C;
		  /* 8216D77Ch */ case   25:  		/* rlwinm R4, R31, 25, 25, 31 */
		/* 8216D77Ch case   25:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R31);
		/* 8216D77Ch case   25:*/		return 0x8216D780;
		  /* 8216D780h */ case   26:  		/* cmplwi CR6, R4, 86 */
		/* 8216D780h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000056);
		/* 8216D780h case   26:*/		return 0x8216D784;
		  /* 8216D784h */ case   27:  		/* bc 12, CR6_EQ, 48 */
		/* 8216D784h case   27:*/		if ( regs.CR[6].eq ) { return 0x8216D7B4;  }
		/* 8216D784h case   27:*/		return 0x8216D788;
		  /* 8216D788h */ case   28:  		/* cmplwi CR6, R4, 87 */
		/* 8216D788h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000057);
		/* 8216D788h case   28:*/		return 0x8216D78C;
		  /* 8216D78Ch */ case   29:  		/* bc 12, CR6_EQ, 40 */
		/* 8216D78Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x8216D7B4;  }
		/* 8216D78Ch case   29:*/		return 0x8216D790;
		  /* 8216D790h */ case   30:  		/* cmplwi CR6, R4, 89 */
		/* 8216D790h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000059);
		/* 8216D790h case   30:*/		return 0x8216D794;
		  /* 8216D794h */ case   31:  		/* bc 12, CR6_EQ, 32 */
		/* 8216D794h case   31:*/		if ( regs.CR[6].eq ) { return 0x8216D7B4;  }
		/* 8216D794h case   31:*/		return 0x8216D798;
		  /* 8216D798h */ case   32:  		/* cmplwi CR6, R4, 90 */
		/* 8216D798h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000005A);
		/* 8216D798h case   32:*/		return 0x8216D79C;
		  /* 8216D79Ch */ case   33:  		/* bc 12, CR6_EQ, 24 */
		/* 8216D79Ch case   33:*/		if ( regs.CR[6].eq ) { return 0x8216D7B4;  }
		/* 8216D79Ch case   33:*/		return 0x8216D7A0;
		  /* 8216D7A0h */ case   34:  		/* cmplwi CR6, R4, 84 */
		/* 8216D7A0h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000054);
		/* 8216D7A0h case   34:*/		return 0x8216D7A4;
		  /* 8216D7A4h */ case   35:  		/* bc 12, CR6_EQ, 16 */
		/* 8216D7A4h case   35:*/		if ( regs.CR[6].eq ) { return 0x8216D7B4;  }
		/* 8216D7A4h case   35:*/		return 0x8216D7A8;
		  /* 8216D7A8h */ case   36:  		/* cmplwi CR6, R4, 85 */
		/* 8216D7A8h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000055);
		/* 8216D7A8h case   36:*/		return 0x8216D7AC;
		  /* 8216D7ACh */ case   37:  		/* mr R11, R21 */
		/* 8216D7ACh case   37:*/		regs.R11 = regs.R21;
		/* 8216D7ACh case   37:*/		return 0x8216D7B0;
		  /* 8216D7B0h */ case   38:  		/* bc 4, CR6_EQ, 8 */
		/* 8216D7B0h case   38:*/		if ( !regs.CR[6].eq ) { return 0x8216D7B8;  }
		/* 8216D7B0h case   38:*/		return 0x8216D7B4;
	}
	return 0x8216D7B4;
} // Block from 8216D718h-8216D7B4h (39 instructions)

//////////////////////////////////////////////////////
// Block at 8216D7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D7B4);
		  /* 8216D7B4h */ case    0:  		/* mr R11, R20 */
		/* 8216D7B4h case    0:*/		regs.R11 = regs.R20;
		/* 8216D7B4h case    0:*/		return 0x8216D7B8;
	}
	return 0x8216D7B8;
} // Block from 8216D7B4h-8216D7B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D7B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D7B8);
		  /* 8216D7B8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216D7B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D7B8h case    0:*/		return 0x8216D7BC;
		  /* 8216D7BCh */ case    1:  		/* bc 12, CR0_EQ, 276 */
		/* 8216D7BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8216D8D0;  }
		/* 8216D7BCh case    1:*/		return 0x8216D7C0;
		  /* 8216D7C0h */ case    2:  		/* rlwinm R6, R31, 18, 29, 31 */
		/* 8216D7C0h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R31);
		/* 8216D7C0h case    2:*/		return 0x8216D7C4;
		  /* 8216D7C4h */ case    3:  		/* rlwinm R5, R31, 13, 29, 31 */
		/* 8216D7C4h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R31);
		/* 8216D7C4h case    3:*/		return 0x8216D7C8;
		  /* 8216D7C8h */ case    4:  		/* mr R3, R24 */
		/* 8216D7C8h case    4:*/		regs.R3 = regs.R24;
		/* 8216D7C8h case    4:*/		return 0x8216D7CC;
		  /* 8216D7CCh */ case    5:  		/* bl -37788 */
		/* 8216D7CCh case    5:*/		regs.LR = 0x8216D7D0; return 0x82164430;
		/* 8216D7CCh case    5:*/		return 0x8216D7D0;
		  /* 8216D7D0h */ case    6:  		/* addi R11, R30, -16 */
		/* 8216D7D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF0);
		/* 8216D7D0h case    6:*/		return 0x8216D7D4;
		  /* 8216D7D4h */ case    7:  		/* add R11, R3, R11 */
		/* 8216D7D4h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8216D7D4h case    7:*/		return 0x8216D7D8;
		  /* 8216D7D8h */ case    8:  		/* lwz R10, <#[R11 + 8]> */
		/* 8216D7D8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8216D7D8h case    8:*/		return 0x8216D7DC;
		  /* 8216D7DCh */ case    9:  		/* rlwinm. R9, R10, 0, 30, 31 */
		/* 8216D7DCh case    9:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R10);
		/* 8216D7DCh case    9:*/		return 0x8216D7E0;
		  /* 8216D7E0h */ case   10:  		/* bc 4, CR0_EQ, 240 */
		/* 8216D7E0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216D8D0;  }
		/* 8216D7E0h case   10:*/		return 0x8216D7E4;
		  /* 8216D7E4h */ case   11:  		/* rlwinm R5, R10, 30, 28, 31 */
		/* 8216D7E4h case   11:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R5,regs.R10);
		/* 8216D7E4h case   11:*/		return 0x8216D7E8;
		  /* 8216D7E8h */ case   12:  		/* cmpwi CR6, R5, 9 */
		/* 8216D7E8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000009);
		/* 8216D7E8h case   12:*/		return 0x8216D7EC;
		  /* 8216D7ECh */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 8216D7ECh case   13:*/		if ( regs.CR[6].eq ) { return 0x8216D7F8;  }
		/* 8216D7ECh case   13:*/		return 0x8216D7F0;
		  /* 8216D7F0h */ case   14:  		/* cmpwi CR6, R5, 8 */
		/* 8216D7F0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000008);
		/* 8216D7F0h case   14:*/		return 0x8216D7F4;
		  /* 8216D7F4h */ case   15:  		/* bc 4, CR6_EQ, 220 */
		/* 8216D7F4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8216D8D0;  }
		/* 8216D7F4h case   15:*/		return 0x8216D7F8;
	}
	return 0x8216D7F8;
} // Block from 8216D7B8h-8216D7F8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216D7F8h
// Function '?IsConvertedToMicrocode@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D7F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D7F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D7F8);
		  /* 8216D7F8h */ case    0:  		/* lwz R10, <#[R29 + 12]> */
		/* 8216D7F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8216D7F8h case    0:*/		return 0x8216D7FC;
		  /* 8216D7FCh */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8216D7FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216D7FCh case    1:*/		return 0x8216D800;
		  /* 8216D800h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8216D800h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216D81C;  }
		/* 8216D800h case    2:*/		return 0x8216D804;
		  /* 8216D804h */ case    3:  		/* lwz R8, <#[R10]> */
		/* 8216D804h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8216D804h case    3:*/		return 0x8216D808;
		  /* 8216D808h */ case    4:  		/* lwz R9, <#[R11]> */
		/* 8216D808h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D808h case    4:*/		return 0x8216D80C;
		  /* 8216D80Ch */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 8216D80Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8216D80Ch case    5:*/		return 0x8216D810;
		  /* 8216D810h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 8216D810h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216D820;  }
		/* 8216D810h case    6:*/		return 0x8216D814;
		  /* 8216D814h */ case    7:  		/* lwz R10, <#[R10 + 8]> */
		/* 8216D814h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8216D814h case    7:*/		return 0x8216D818;
		  /* 8216D818h */ case    8:  		/* b -28 */
		/* 8216D818h case    8:*/		return 0x8216D7FC;
		/* 8216D818h case    8:*/		return 0x8216D81C;
	}
	return 0x8216D81C;
} // Block from 8216D7F8h-8216D81Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216D81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D81C);
		  /* 8216D81Ch */ case    0:  		/* mr R8, R21 */
		/* 8216D81Ch case    0:*/		regs.R8 = regs.R21;
		/* 8216D81Ch case    0:*/		return 0x8216D820;
	}
	return 0x8216D820;
} // Block from 8216D81Ch-8216D820h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D820);
		  /* 8216D820h */ case    0:  		/* lwz R9, <#[R11 + 12]> */
		/* 8216D820h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216D820h case    0:*/		return 0x8216D824;
		  /* 8216D824h */ case    1:  		/* mr R7, R8 */
		/* 8216D824h case    1:*/		regs.R7 = regs.R8;
		/* 8216D824h case    1:*/		return 0x8216D828;
		  /* 8216D828h */ case    2:  		/* lwz R6, <#[R11]> */
		/* 8216D828h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D828h case    2:*/		return 0x8216D82C;
		  /* 8216D82Ch */ case    3:  		/* rlwinm. R4, R9, 0, 30, 30 */
		/* 8216D82Ch case    3:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R4,regs.R9);
		/* 8216D82Ch case    3:*/		return 0x8216D830;
		  /* 8216D830h */ case    4:  		/* mr R10, R6 */
		/* 8216D830h case    4:*/		regs.R10 = regs.R6;
		/* 8216D830h case    4:*/		return 0x8216D834;
		  /* 8216D834h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8216D834h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216D840;  }
		/* 8216D834h case    5:*/		return 0x8216D838;
		  /* 8216D838h */ case    6:  		/* mr R7, R6 */
		/* 8216D838h case    6:*/		regs.R7 = regs.R6;
		/* 8216D838h case    6:*/		return 0x8216D83C;
		  /* 8216D83Ch */ case    7:  		/* mr R10, R8 */
		/* 8216D83Ch case    7:*/		regs.R10 = regs.R8;
		/* 8216D83Ch case    7:*/		return 0x8216D840;
	}
	return 0x8216D840;
} // Block from 8216D820h-8216D840h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216D840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D840);
		  /* 8216D840h */ case    0:  		/* rlwinm R9, R9, 30, 31, 31 */
		/* 8216D840h case    0:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R9,regs.R9);
		/* 8216D840h case    0:*/		return 0x8216D844;
		  /* 8216D844h */ case    1:  		/* cmpwi CR6, R5, 9 */
		/* 8216D844h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000009);
		/* 8216D844h case    1:*/		return 0x8216D848;
		  /* 8216D848h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8216D848h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216D858;  }
		/* 8216D848h case    2:*/		return 0x8216D84C;
		  /* 8216D84Ch */ case    3:  		/* rlwinm R9, R9, 0, 24, 31 */
		/* 8216D84Ch case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R9);
		/* 8216D84Ch case    3:*/		return 0x8216D850;
		  /* 8216D850h */ case    4:  		/* cntlzw R9, R9 */
		/* 8216D850h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 8216D850h case    4:*/		return 0x8216D854;
		  /* 8216D854h */ case    5:  		/* rlwinm R9, R9, 27, 31, 31 */
		/* 8216D854h case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R9,regs.R9);
		/* 8216D854h case    5:*/		return 0x8216D858;
	}
	return 0x8216D858;
} // Block from 8216D840h-8216D858h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216D858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D858);
		  /* 8216D858h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 8216D858h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 8216D858h case    0:*/		return 0x8216D85C;
		  /* 8216D85Ch */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 8216D85Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216D864;  }
		/* 8216D85Ch case    1:*/		return 0x8216D860;
		  /* 8216D860h */ case    2:  		/* mr R10, R7 */
		/* 8216D860h case    2:*/		regs.R10 = regs.R7;
		/* 8216D860h case    2:*/		return 0x8216D864;
	}
	return 0x8216D864;
} // Block from 8216D858h-8216D864h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216D864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D864);
		  /* 8216D864h */ case    0:  		/* cmplw CR6, R10, R6 */
		/* 8216D864h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8216D864h case    0:*/		return 0x8216D868;
		  /* 8216D868h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8216D868h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216D88C;  }
		/* 8216D868h case    1:*/		return 0x8216D86C;
		  /* 8216D86Ch */ case    2:  		/* nor R10, R31, R31 */
		/* 8216D86Ch case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R31,regs.R31);
		/* 8216D86Ch case    2:*/		return 0x8216D870;
		  /* 8216D870h */ case    3:  		/* rlwimi R10, R31, 0, 14, 12 */
		/* 8216D870h case    3:*/		cpu::op::rlwimi<0,0,14,12>(regs,&regs.R10,regs.R31);
		/* 8216D870h case    3:*/		return 0x8216D874;
		  /* 8216D874h */ case    4:  		/* stw R10, <#[R30 + 8]> */
		/* 8216D874h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8216D874h case    4:*/		return 0x8216D878;
		  /* 8216D878h */ case    5:  		/* lwz R10, <#[R11 + 12]> */
		/* 8216D878h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216D878h case    5:*/		return 0x8216D87C;
		  /* 8216D87Ch */ case    6:  		/* nor R9, R10, R10 */
		/* 8216D87Ch case    6:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R10,regs.R10);
		/* 8216D87Ch case    6:*/		return 0x8216D880;
		  /* 8216D880h */ case    7:  		/* rlwimi R9, R10, 0, 31, 29 */
		/* 8216D880h case    7:*/		cpu::op::rlwimi<0,0,31,29>(regs,&regs.R9,regs.R10);
		/* 8216D880h case    7:*/		return 0x8216D884;
		  /* 8216D884h */ case    8:  		/* stw R8, <#[R11]> */
		/* 8216D884h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D884h case    8:*/		return 0x8216D888;
		  /* 8216D888h */ case    9:  		/* stw R9, <#[R11 + 12]> */
		/* 8216D888h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216D888h case    9:*/		return 0x8216D88C;
	}
	return 0x8216D88C;
} // Block from 8216D864h-8216D88Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216D88Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D88C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D88C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D88C);
		  /* 8216D88Ch */ case    0:  		/* lwz R11, <#[R29 + 76]> */
		/* 8216D88Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000004C) );
		/* 8216D88Ch case    0:*/		return 0x8216D890;
		  /* 8216D890h */ case    1:  		/* rlwinm. R10, R11, 10, 31, 31 */
		/* 8216D890h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D890h case    1:*/		return 0x8216D894;
		  /* 8216D894h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 8216D894h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216D8D0;  }
		/* 8216D894h case    2:*/		return 0x8216D898;
		  /* 8216D898h */ case    3:  		/* lwz R10, <#[R30 + 8]> */
		/* 8216D898h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8216D898h case    3:*/		return 0x8216D89C;
		  /* 8216D89Ch */ case    4:  		/* rlwinm R11, R11, 9, 24, 31 */
		/* 8216D89Ch case    4:*/		cpu::op::rlwinm<0,9,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D89Ch case    4:*/		return 0x8216D8A0;
		  /* 8216D8A0h */ case    5:  		/* rlwinm R10, R10, 14, 18, 31 */
		/* 8216D8A0h case    5:*/		cpu::op::rlwinm<0,14,18,31>(regs,&regs.R10,regs.R10);
		/* 8216D8A0h case    5:*/		return 0x8216D8A4;
		  /* 8216D8A4h */ case    6:  		/* xor R11, R11, R10 */
		/* 8216D8A4h case    6:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216D8A4h case    6:*/		return 0x8216D8A8;
		  /* 8216D8A8h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216D8A8h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D8A8h case    7:*/		return 0x8216D8AC;
		  /* 8216D8ACh */ case    8:  		/* bc 12, CR0_EQ, 36 */
		/* 8216D8ACh case    8:*/		if ( regs.CR[0].eq ) { return 0x8216D8D0;  }
		/* 8216D8ACh case    8:*/		return 0x8216D8B0;
		  /* 8216D8B0h */ case    9:  		/* lwz R11, <#[R30 + 44]> */
		/* 8216D8B0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 8216D8B0h case    9:*/		return 0x8216D8B4;
		  /* 8216D8B4h */ case   10:  		/* mr R4, R24 */
		/* 8216D8B4h case   10:*/		regs.R4 = regs.R24;
		/* 8216D8B4h case   10:*/		return 0x8216D8B8;
		  /* 8216D8B8h */ case   11:  		/* lwz R3, <#[R11 + 12]> */
		/* 8216D8B8h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216D8B8h case   11:*/		return 0x8216D8BC;
		  /* 8216D8BCh */ case   12:  		/* bl 737388 */
		/* 8216D8BCh case   12:*/		regs.LR = 0x8216D8C0; return 0x82221928;
		/* 8216D8BCh case   12:*/		return 0x8216D8C0;
	}
	return 0x8216D8C0;
} // Block from 8216D88Ch-8216D8C0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216D8C0h
// Function '?FreePhaseMem@Compiler@D3DXShader@@QAAXPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D8C0);
		  /* 8216D8C0h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8216D8C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8216D8C0h case    0:*/		return 0x8216D8C4;
		  /* 8216D8C4h */ case    1:  		/* nor R10, R11, R11 */
		/* 8216D8C4h case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8216D8C4h case    1:*/		return 0x8216D8C8;
		  /* 8216D8C8h */ case    2:  		/* rlwimi R10, R11, 0, 14, 12 */
		/* 8216D8C8h case    2:*/		cpu::op::rlwimi<0,0,14,12>(regs,&regs.R10,regs.R11);
		/* 8216D8C8h case    2:*/		return 0x8216D8CC;
		  /* 8216D8CCh */ case    3:  		/* stw R10, <#[R30 + 8]> */
		/* 8216D8CCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8216D8CCh case    3:*/		return 0x8216D8D0;
	}
	return 0x8216D8D0;
} // Block from 8216D8C0h-8216D8D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216D8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D8D0);
		  /* 8216D8D0h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 8216D8D0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 8216D8D0h case    0:*/		return 0x8216D8D4;
		  /* 8216D8D4h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216D8D4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D8D4h case    1:*/		return 0x8216D8D8;
		  /* 8216D8D8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D8D8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D8D8h case    2:*/		return 0x8216D8DC;
		  /* 8216D8DCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216D8DCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216D8EC;  }
		/* 8216D8DCh case    3:*/		return 0x8216D8E0;
		  /* 8216D8E0h */ case    4:  		/* mr R29, R11 */
		/* 8216D8E0h case    4:*/		regs.R29 = regs.R11;
		/* 8216D8E0h case    4:*/		return 0x8216D8E4;
		  /* 8216D8E4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216D8E4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216D8E4h case    5:*/		return 0x8216D8E8;
		  /* 8216D8E8h */ case    6:  		/* bc 4, CR6_EQ, -396 */
		/* 8216D8E8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216D75C;  }
		/* 8216D8E8h case    6:*/		return 0x8216D8EC;
	}
	return 0x8216D8EC;
} // Block from 8216D8D0h-8216D8ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216D8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D8EC);
		  /* 8216D8ECh */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216D8ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216D8ECh case    0:*/		return 0x8216D8F0;
		  /* 8216D8F0h */ case    1:  		/* mr R25, R21 */
		/* 8216D8F0h case    1:*/		regs.R25 = regs.R21;
		/* 8216D8F0h case    1:*/		return 0x8216D8F4;
		  /* 8216D8F4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D8F4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D8F4h case    2:*/		return 0x8216D8F8;
		  /* 8216D8F8h */ case    3:  		/* bc 4, CR0_EQ, 2488 */
		/* 8216D8F8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E2B0;  }
		/* 8216D8F8h case    3:*/		return 0x8216D8FC;
		  /* 8216D8FCh */ case    4:  		/* mr R26, R11 */
		/* 8216D8FCh case    4:*/		regs.R26 = regs.R11;
		/* 8216D8FCh case    4:*/		return 0x8216D900;
		  /* 8216D900h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8216D900h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216D900h case    5:*/		return 0x8216D904;
		  /* 8216D904h */ case    6:  		/* bc 12, CR0_EQ, 2476 */
		/* 8216D904h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216E2B0;  }
		/* 8216D904h case    6:*/		return 0x8216D908;
		  /* 8216D908h */ case    7:  		/* lwz R11, <#[R26 + 28]> */
		/* 8216D908h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 8216D908h case    7:*/		return 0x8216D90C;
		  /* 8216D90Ch */ case    8:  		/* addi R29, R26, 24 */
		/* 8216D90Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R26,0x18);
		/* 8216D90Ch case    8:*/		return 0x8216D910;
		  /* 8216D910h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216D910h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216D910h case    9:*/		return 0x8216D914;
		  /* 8216D914h */ case   10:  		/* addi R30, R29, 4 */
		/* 8216D914h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x4);
		/* 8216D914h case   10:*/		return 0x8216D918;
	}
	return 0x8216D918;
} // Block from 8216D8ECh-8216D918h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216D918h
// Function '?PlaceInstruction@Compiler@D3DXShader@@QAAXPAVInstruction@2@W4PlacementMethod@12@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D918);
		  /* 8216D918h */ case    0:  		/* bc 4, CR0_EQ, 32 */
		/* 8216D918h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8216D938;  }
		/* 8216D918h case    0:*/		return 0x8216D91C;
		  /* 8216D91Ch */ case    1:  		/* mr R3, R11 */
		/* 8216D91Ch case    1:*/		regs.R3 = regs.R11;
		/* 8216D91Ch case    1:*/		return 0x8216D920;
		  /* 8216D920h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 8216D920h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216D920h case    2:*/		return 0x8216D924;
		  /* 8216D924h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 8216D924h case    3:*/		if ( regs.CR[0].eq ) { return 0x8216D938;  }
		/* 8216D924h case    3:*/		return 0x8216D928;
		  /* 8216D928h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216D928h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216D928h case    4:*/		return 0x8216D92C;
		  /* 8216D92Ch */ case    5:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216D92Ch case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216D92Ch case    5:*/		return 0x8216D930;
		  /* 8216D930h */ case    6:  		/* cmplwi CR6, R11, 16128 */
		/* 8216D930h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003F00);
		/* 8216D930h case    6:*/		return 0x8216D934;
		  /* 8216D934h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 8216D934h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216D984;  }
		/* 8216D934h case    7:*/		return 0x8216D938;
	}
	return 0x8216D938;
} // Block from 8216D918h-8216D938h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216D938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D938);
		  /* 8216D938h */ case    0:  		/* li R8, 0 */
		/* 8216D938h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216D938h case    0:*/		return 0x8216D93C;
		  /* 8216D93Ch */ case    1:  		/* li R7, 0 */
		/* 8216D93Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216D93Ch case    1:*/		return 0x8216D940;
		  /* 8216D940h */ case    2:  		/* li R6, 126 */
		/* 8216D940h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x7E);
		/* 8216D940h case    2:*/		return 0x8216D944;
		  /* 8216D944h */ case    3:  		/* li R5, 0 */
		/* 8216D944h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216D944h case    3:*/		return 0x8216D948;
		  /* 8216D948h */ case    4:  		/* mr R4, R26 */
		/* 8216D948h case    4:*/		regs.R4 = regs.R26;
		/* 8216D948h case    4:*/		return 0x8216D94C;
		  /* 8216D94Ch */ case    5:  		/* mr R3, R24 */
		/* 8216D94Ch case    5:*/		regs.R3 = regs.R24;
		/* 8216D94Ch case    5:*/		return 0x8216D950;
		  /* 8216D950h */ case    6:  		/* bl 749640 */
		/* 8216D950h case    6:*/		regs.LR = 0x8216D954; return 0x82224998;
		/* 8216D950h case    6:*/		return 0x8216D954;
		  /* 8216D954h */ case    7:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8216D954h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8216D954h case    7:*/		return 0x8216D958;
		  /* 8216D958h */ case    8:  		/* lwz R9, <#[R30]> */
		/* 8216D958h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8216D958h case    8:*/		return 0x8216D95C;
		  /* 8216D95Ch */ case    9:  		/* ori R8, R30, 1 */
		/* 8216D95Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R30,0x1);
		/* 8216D95Ch case    9:*/		return 0x8216D960;
		  /* 8216D960h */ case   10:  		/* addi R11, R11, 36 */
		/* 8216D960h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8216D960h case   10:*/		return 0x8216D964;
		  /* 8216D964h */ case   11:  		/* addi R10, R11, 4 */
		/* 8216D964h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8216D964h case   11:*/		return 0x8216D968;
		  /* 8216D968h */ case   12:  		/* addi R7, R11, -36 */
		/* 8216D968h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8216D968h case   12:*/		return 0x8216D96C;
		  /* 8216D96Ch */ case   13:  		/* stw R9, <#[R11 + 4]> */
		/* 8216D96Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8216D96Ch case   13:*/		return 0x8216D970;
		  /* 8216D970h */ case   14:  		/* lwz R9, <#[R30]> */
		/* 8216D970h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8216D970h case   14:*/		return 0x8216D974;
		  /* 8216D974h */ case   15:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 8216D974h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 8216D974h case   15:*/		return 0x8216D978;
		  /* 8216D978h */ case   16:  		/* stw R10, <#[R9 + 36]> */
		/* 8216D978h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000024) );
		/* 8216D978h case   16:*/		return 0x8216D97C;
		  /* 8216D97Ch */ case   17:  		/* stw R8, <#[R11]> */
		/* 8216D97Ch case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8216D97Ch case   17:*/		return 0x8216D980;
		  /* 8216D980h */ case   18:  		/* stw R7, <#[R30]> */
		/* 8216D980h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 8216D980h case   18:*/		return 0x8216D984;
	}
	return 0x8216D984;
} // Block from 8216D938h-8216D984h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216D984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D984);
		  /* 8216D984h */ case    0:  		/* lwz R11, <#[R26 + 68]> */
		/* 8216D984h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000044) );
		/* 8216D984h case    0:*/		return 0x8216D988;
		  /* 8216D988h */ case    1:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8216D988h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8216D988h case    1:*/		return 0x8216D98C;
		  /* 8216D98Ch */ case    2:  		/* bc 12, CR0_EQ, 300 */
		/* 8216D98Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8216DAB8;  }
		/* 8216D98Ch case    2:*/		return 0x8216D990;
		  /* 8216D990h */ case    3:  		/* lwz R11, <#[R26 + 12]> */
		/* 8216D990h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216D990h case    3:*/		return 0x8216D994;
		  /* 8216D994h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8216D994h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216D994h case    4:*/		return 0x8216D998;
		  /* 8216D998h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 8216D998h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216D9AC;  }
		/* 8216D998h case    5:*/		return 0x8216D99C;
		  /* 8216D99Ch */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216D99Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216D99Ch case    6:*/		return 0x8216D9A0;
		  /* 8216D9A0h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8216D9A0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216D9A0h case    7:*/		return 0x8216D9A4;
		  /* 8216D9A4h */ case    8:  		/* mr R11, R20 */
		/* 8216D9A4h case    8:*/		regs.R11 = regs.R20;
		/* 8216D9A4h case    8:*/		return 0x8216D9A8;
	}
	return 0x8216D9A8;
} // Block from 8216D984h-8216D9A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216D9A8h
// Function '?CreateUnlinkedBlock@Compiler@D3DXShader@@AAAPAVBlock@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D9A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D9A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D9A8);
		  /* 8216D9A8h */ case    0:  		/* bc 4, CR6_EQ, 8 */
		/* 8216D9A8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8216D9B0;  }
		/* 8216D9A8h case    0:*/		return 0x8216D9AC;
	}
	return 0x8216D9AC;
} // Block from 8216D9A8h-8216D9ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D9AC);
		  /* 8216D9ACh */ case    0:  		/* mr R11, R21 */
		/* 8216D9ACh case    0:*/		regs.R11 = regs.R21;
		/* 8216D9ACh case    0:*/		return 0x8216D9B0;
	}
	return 0x8216D9B0;
} // Block from 8216D9ACh-8216D9B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216D9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216D9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216D9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216D9B0);
		  /* 8216D9B0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216D9B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216D9B0h case    0:*/		return 0x8216D9B4;
		  /* 8216D9B4h */ case    1:  		/* bc 4, CR0_EQ, 260 */
		/* 8216D9B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216DAB8;  }
		/* 8216D9B4h case    1:*/		return 0x8216D9B8;
		  /* 8216D9B8h */ case    2:  		/* lwz R11, <#[R3 + 20]> */
		/* 8216D9B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8216D9B8h case    2:*/		return 0x8216D9BC;
		  /* 8216D9BCh */ case    3:  		/* oris R11, R11, 1 */
		/* 8216D9BCh case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216D9BCh case    3:*/		return 0x8216D9C0;
		  /* 8216D9C0h */ case    4:  		/* stw R11, <#[R3 + 20]> */
		/* 8216D9C0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8216D9C0h case    4:*/		return 0x8216D9C4;
		  /* 8216D9C4h */ case    5:  		/* lwz R11, <#[R30]> */
		/* 8216D9C4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216D9C4h case    5:*/		return 0x8216D9C8;
		  /* 8216D9C8h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216D9C8h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D9C8h case    6:*/		return 0x8216D9CC;
		  /* 8216D9CCh */ case    7:  		/* bc 4, CR0_EQ, 320 */
		/* 8216D9CCh case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216DB0C;  }
		/* 8216D9CCh case    7:*/		return 0x8216D9D0;
		  /* 8216D9D0h */ case    8:  		/* lwz R11, <#[R29]> */
		/* 8216D9D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216D9D0h case    8:*/		return 0x8216D9D4;
		  /* 8216D9D4h */ case    9:  		/* b 100 */
		/* 8216D9D4h case    9:*/		return 0x8216DA38;
		/* 8216D9D4h case    9:*/		return 0x8216D9D8;
		  /* 8216D9D8h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216D9D8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216D9D8h case   10:*/		return 0x8216D9DC;
		  /* 8216D9DCh */ case   11:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 8216D9DCh case   11:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 8216D9DCh case   11:*/		return 0x8216D9E0;
		  /* 8216D9E0h */ case   12:  		/* cmplwi CR6, R10, 14976 */
		/* 8216D9E0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003A80);
		/* 8216D9E0h case   12:*/		return 0x8216D9E4;
		  /* 8216D9E4h */ case   13:  		/* bc 4, CR6_EQ, 68 */
		/* 8216D9E4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8216DA28;  }
		/* 8216D9E4h case   13:*/		return 0x8216D9E8;
		  /* 8216D9E8h */ case   14:  		/* rlwinm. R11, R11, 15, 31, 31 */
		/* 8216D9E8h case   14:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R11);
		/* 8216D9E8h case   14:*/		return 0x8216D9EC;
		  /* 8216D9ECh */ case   15:  		/* bc 12, CR0_EQ, 60 */
		/* 8216D9ECh case   15:*/		if ( regs.CR[0].eq ) { return 0x8216DA28;  }
		/* 8216D9ECh case   15:*/		return 0x8216D9F0;
		  /* 8216D9F0h */ case   16:  		/* li R6, 0 */
		/* 8216D9F0h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216D9F0h case   16:*/		return 0x8216D9F4;
		  /* 8216D9F4h */ case   17:  		/* li R5, 0 */
		/* 8216D9F4h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216D9F4h case   17:*/		return 0x8216D9F8;
		  /* 8216D9F8h */ case   18:  		/* li R4, 117 */
		/* 8216D9F8h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 8216D9F8h case   18:*/		return 0x8216D9FC;
		  /* 8216D9FCh */ case   19:  		/* mr R3, R24 */
		/* 8216D9FCh case   19:*/		regs.R3 = regs.R24;
		/* 8216D9FCh case   19:*/		return 0x8216DA00;
		  /* 8216DA00h */ case   20:  		/* bl -38352 */
		/* 8216DA00h case   20:*/		regs.LR = 0x8216DA04; return 0x82164430;
		/* 8216DA00h case   20:*/		return 0x8216DA04;
		  /* 8216DA04h */ case   21:  		/* addi R11, R31, -16 */
		/* 8216DA04h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8216DA04h case   21:*/		return 0x8216DA08;
		  /* 8216DA08h */ case   22:  		/* add R11, R3, R11 */
		/* 8216DA08h case   22:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8216DA08h case   22:*/		return 0x8216DA0C;
		  /* 8216DA0Ch */ case   23:  		/* lwz R10, <#[R11]> */
		/* 8216DA0Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216DA0Ch case   23:*/		return 0x8216DA10;
		  /* 8216DA10h */ case   24:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 8216DA10h case   24:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 8216DA10h case   24:*/		return 0x8216DA14;
		  /* 8216DA14h */ case   25:  		/* cmplwi CR6, R10, 7 */
		/* 8216DA14h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 8216DA14h case   25:*/		return 0x8216DA18;
		  /* 8216DA18h */ case   26:  		/* bc 4, CR6_EQ, 16 */
		/* 8216DA18h case   26:*/		if ( !regs.CR[6].eq ) { return 0x8216DA28;  }
		/* 8216DA18h case   26:*/		return 0x8216DA1C;
		  /* 8216DA1Ch */ case   27:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216DA1Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216DA1Ch case   27:*/		return 0x8216DA20;
		  /* 8216DA20h */ case   28:  		/* cmpwi CR6, R11, 2 */
		/* 8216DA20h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8216DA20h case   28:*/		return 0x8216DA24;
		  /* 8216DA24h */ case   29:  		/* bc 12, CR6_EQ, 36 */
		/* 8216DA24h case   29:*/		if ( regs.CR[6].eq ) { return 0x8216DA48;  }
		/* 8216DA24h case   29:*/		return 0x8216DA28;
	}
	return 0x8216DA28;
} // Block from 8216D9B0h-8216DA28h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8216DA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DA28);
		  /* 8216DA28h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216DA28h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216DA28h case    0:*/		return 0x8216DA2C;
		  /* 8216DA2Ch */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216DA2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216DA2Ch case    1:*/		return 0x8216DA30;
		  /* 8216DA30h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216DA30h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216DA30h case    2:*/		return 0x8216DA34;
		  /* 8216DA34h */ case    3:  		/* bc 4, CR0_EQ, 216 */
		/* 8216DA34h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216DB0C;  }
		/* 8216DA34h case    3:*/		return 0x8216DA38;
	}
	return 0x8216DA38;
} // Block from 8216DA28h-8216DA38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216DA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DA38);
		  /* 8216DA38h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216DA38h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216DA38h case    0:*/		return 0x8216DA3C;
		  /* 8216DA3Ch */ case    1:  		/* addic. R31, R11, -40 */
		/* 8216DA3Ch case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216DA3Ch case    1:*/		return 0x8216DA40;
		  /* 8216DA40h */ case    2:  		/* bc 4, CR0_EQ, -104 */
		/* 8216DA40h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216D9D8;  }
		/* 8216DA40h case    2:*/		return 0x8216DA44;
		  /* 8216DA44h */ case    3:  		/* b 200 */
		/* 8216DA44h case    3:*/		return 0x8216DB0C;
		/* 8216DA44h case    3:*/		return 0x8216DA48;
	}
	return 0x8216DA48;
} // Block from 8216DA38h-8216DA48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216DA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DA48);
		  /* 8216DA48h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 8216DA48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216DA48h case    0:*/		return 0x8216DA4C;
		  /* 8216DA4Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216DA4Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DA4Ch case    1:*/		return 0x8216DA50;
		  /* 8216DA50h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 8216DA50h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216DA5C;  }
		/* 8216DA50h case    2:*/		return 0x8216DA54;
		  /* 8216DA54h */ case    3:  		/* mr R11, R21 */
		/* 8216DA54h case    3:*/		regs.R11 = regs.R21;
		/* 8216DA54h case    3:*/		return 0x8216DA58;
		  /* 8216DA58h */ case    4:  		/* b 8 */
		/* 8216DA58h case    4:*/		return 0x8216DA60;
		/* 8216DA58h case    4:*/		return 0x8216DA5C;
	}
	return 0x8216DA5C;
} // Block from 8216DA48h-8216DA5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216DA5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DA5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DA5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DA5C);
		  /* 8216DA5Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8216DA5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216DA5Ch case    0:*/		return 0x8216DA60;
	}
	return 0x8216DA60;
} // Block from 8216DA5Ch-8216DA60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216DA60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DA60);
		  /* 8216DA60h */ case    0:  		/* lwz R10, <#[R11 + 68]> */
		/* 8216DA60h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000044) );
		/* 8216DA60h case    0:*/		return 0x8216DA64;
		  /* 8216DA64h */ case    1:  		/* nor R10, R10, R10 */
		/* 8216DA64h case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216DA64h case    1:*/		return 0x8216DA68;
		  /* 8216DA68h */ case    2:  		/* rlwinm. R10, R10, 2, 31, 31 */
		/* 8216DA68h case    2:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R10);
		/* 8216DA68h case    2:*/		return 0x8216DA6C;
		  /* 8216DA6Ch */ case    3:  		/* bc 4, CR0_EQ, 2316 */
		/* 8216DA6Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E378;  }
		/* 8216DA6Ch case    3:*/		return 0x8216DA70;
		  /* 8216DA70h */ case    4:  		/* lwz R11, <#[R11 + 28]> */
		/* 8216DA70h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8216DA70h case    4:*/		return 0x8216DA74;
		  /* 8216DA74h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216DA74h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216DA74h case    5:*/		return 0x8216DA78;
		  /* 8216DA78h */ case    6:  		/* bc 4, CR0_EQ, 148 */
		/* 8216DA78h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216DB0C;  }
		/* 8216DA78h case    6:*/		return 0x8216DA7C;
		  /* 8216DA7Ch */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 8216DA7Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216DA7Ch case    7:*/		return 0x8216DA80;
	}
	return 0x8216DA80;
} // Block from 8216DA60h-8216DA80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216DA80h
// Function '?MakeInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@W4Opcode@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DA80);
		  /* 8216DA80h */ case    0:  		/* bc 12, CR0_EQ, 140 */
		/* 8216DA80h case    0:*/		if ( regs.CR[0].eq ) { return 0x8216DB0C;  }
		/* 8216DA80h case    0:*/		return 0x8216DA84;
		  /* 8216DA84h */ case    1:  		/* lwz R10, <#[R11 + 8]> */
		/* 8216DA84h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8216DA84h case    1:*/		return 0x8216DA88;
		  /* 8216DA88h */ case    2:  		/* rlwinm. R9, R10, 15, 31, 31 */
		/* 8216DA88h case    2:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R9,regs.R10);
		/* 8216DA88h case    2:*/		return 0x8216DA8C;
		  /* 8216DA8Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8216DA8Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8216DA9C;  }
		/* 8216DA8Ch case    3:*/		return 0x8216DA90;
		  /* 8216DA90h */ case    4:  		/* lwz R9, <#[R31 + 8]> */
		/* 8216DA90h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DA90h case    4:*/		return 0x8216DA94;
		  /* 8216DA94h */ case    5:  		/* rlwimi R9, R10, 0, 14, 12 */
		/* 8216DA94h case    5:*/		cpu::op::rlwimi<0,0,14,12>(regs,&regs.R9,regs.R10);
		/* 8216DA94h case    5:*/		return 0x8216DA98;
		  /* 8216DA98h */ case    6:  		/* stw R9, <#[R11 + 8]> */
		/* 8216DA98h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8216DA98h case    6:*/		return 0x8216DA9C;
	}
	return 0x8216DA9C;
} // Block from 8216DA80h-8216DA9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216DA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DA9C);
		  /* 8216DA9Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216DA9Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216DA9Ch case    0:*/		return 0x8216DAA0;
		  /* 8216DAA0h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216DAA0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216DAA0h case    1:*/		return 0x8216DAA4;
		  /* 8216DAA4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216DAA4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216DAA4h case    2:*/		return 0x8216DAA8;
		  /* 8216DAA8h */ case    3:  		/* bc 4, CR0_EQ, 100 */
		/* 8216DAA8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216DB0C;  }
		/* 8216DAA8h case    3:*/		return 0x8216DAAC;
		  /* 8216DAACh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8216DAACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DAACh case    4:*/		return 0x8216DAB0;
		  /* 8216DAB0h */ case    5:  		/* bc 4, CR6_EQ, -44 */
		/* 8216DAB0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216DA84;  }
		/* 8216DAB0h case    5:*/		return 0x8216DAB4;
		  /* 8216DAB4h */ case    6:  		/* b 88 */
		/* 8216DAB4h case    6:*/		return 0x8216DB0C;
		/* 8216DAB4h case    6:*/		return 0x8216DAB8;
	}
	return 0x8216DAB8;
} // Block from 8216DA9Ch-8216DAB8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216DAB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DAB8);
		  /* 8216DAB8h */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216DAB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216DAB8h case    0:*/		return 0x8216DABC;
		  /* 8216DABCh */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216DABCh case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216DABCh case    1:*/		return 0x8216DAC0;
		  /* 8216DAC0h */ case    2:  		/* addic R10, R10, -1 */
		/* 8216DAC0h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216DAC0h case    2:*/		return 0x8216DAC4;
		  /* 8216DAC4h */ case    3:  		/* subfe R10, R10, R10 */
		/* 8216DAC4h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216DAC4h case    3:*/		return 0x8216DAC8;
	}
	return 0x8216DAC8;
} // Block from 8216DAB8h-8216DAC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216DAC8h
// Function '?GetExecPredecessor@Compiler@D3DXShader@@AAAPAVBlock@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DAC8);
		  /* 8216DAC8h */ case    0:  		/* and R11, R10, R11 */
		/* 8216DAC8h case    0:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216DAC8h case    0:*/		return 0x8216DACC;
		  /* 8216DACCh */ case    1:  		/* cmplw CR6, R26, R11 */
		/* 8216DACCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8216DACCh case    1:*/		return 0x8216DAD0;
		  /* 8216DAD0h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8216DAD0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216DB00;  }
		/* 8216DAD0h case    2:*/		return 0x8216DAD4;
		  /* 8216DAD4h */ case    3:  		/* lwz R11, <#[R26 + 76]> */
		/* 8216DAD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 8216DAD4h case    3:*/		return 0x8216DAD8;
		  /* 8216DAD8h */ case    4:  		/* rlwinm. R10, R11, 0, 10, 10 */
		/* 8216DAD8h case    4:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R10,regs.R11);
		/* 8216DAD8h case    4:*/		return 0x8216DADC;
		  /* 8216DADCh */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 8216DADCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216DB00;  }
		/* 8216DADCh case    5:*/		return 0x8216DAE0;
		  /* 8216DAE0h */ case    6:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 8216DAE0h case    6:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 8216DAE0h case    6:*/		return 0x8216DAE4;
		  /* 8216DAE4h */ case    7:  		/* bc 12, CR0_EQ, 40 */
		/* 8216DAE4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216DB0C;  }
		/* 8216DAE4h case    7:*/		return 0x8216DAE8;
		  /* 8216DAE8h */ case    8:  		/* lwz R11, <#[R24 + 56]> */
		/* 8216DAE8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 8216DAE8h case    8:*/		return 0x8216DAEC;
		  /* 8216DAECh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8216DAECh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DAECh case    9:*/		return 0x8216DAF0;
		  /* 8216DAF0h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 8216DAF0h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216DB0C;  }
		/* 8216DAF0h case   10:*/		return 0x8216DAF4;
		  /* 8216DAF4h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 8216DAF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216DAF4h case   11:*/		return 0x8216DAF8;
		  /* 8216DAF8h */ case   12:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 8216DAF8h case   12:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8216DAF8h case   12:*/		return 0x8216DAFC;
		  /* 8216DAFCh */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 8216DAFCh case   13:*/		if ( regs.CR[0].eq ) { return 0x8216DB0C;  }
		/* 8216DAFCh case   13:*/		return 0x8216DB00;
	}
	return 0x8216DB00;
} // Block from 8216DAC8h-8216DB00h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216DB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DB00);
		  /* 8216DB00h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 8216DB00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8216DB00h case    0:*/		return 0x8216DB04;
		  /* 8216DB04h */ case    1:  		/* oris R11, R11, 1 */
		/* 8216DB04h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216DB04h case    1:*/		return 0x8216DB08;
		  /* 8216DB08h */ case    2:  		/* stw R11, <#[R3 + 20]> */
		/* 8216DB08h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8216DB08h case    2:*/		return 0x8216DB0C;
	}
	return 0x8216DB0C;
} // Block from 8216DB00h-8216DB0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216DB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DB0C);
		  /* 8216DB0Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8216DB0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216DB0Ch case    0:*/		return 0x8216DB10;
		  /* 8216DB10h */ case    1:  		/* mr R27, R21 */
		/* 8216DB10h case    1:*/		regs.R27 = regs.R21;
		/* 8216DB10h case    1:*/		return 0x8216DB14;
		  /* 8216DB14h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216DB14h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216DB14h case    2:*/		return 0x8216DB18;
		  /* 8216DB18h */ case    3:  		/* bc 4, CR0_EQ, 1516 */
		/* 8216DB18h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E104;  }
		/* 8216DB18h case    3:*/		return 0x8216DB1C;
		  /* 8216DB1Ch */ case    4:  		/* lwz R11, <#[R29]> */
		/* 8216DB1Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216DB1Ch case    4:*/		return 0x8216DB20;
		  /* 8216DB20h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216DB20h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216DB20h case    5:*/		return 0x8216DB24;
		  /* 8216DB24h */ case    6:  		/* addic. R29, R11, -40 */
		/* 8216DB24h case    6:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R11,0xFFFFFFD8);
		/* 8216DB24h case    6:*/		return 0x8216DB28;
		  /* 8216DB28h */ case    7:  		/* bc 12, CR0_EQ, 1500 */
		/* 8216DB28h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216E104;  }
		/* 8216DB28h case    7:*/		return 0x8216DB2C;
		  /* 8216DB2Ch */ case    8:  		/* lwz R11, <#[R29 + 8]> */
		/* 8216DB2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216DB2Ch case    8:*/		return 0x8216DB30;
		  /* 8216DB30h */ case    9:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8216DB30h case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8216DB30h case    9:*/		return 0x8216DB34;
		  /* 8216DB34h */ case   10:  		/* cmplwi CR6, R10, 86 */
		/* 8216DB34h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000056);
		/* 8216DB34h case   10:*/		return 0x8216DB38;
		  /* 8216DB38h */ case   11:  		/* bc 12, CR6_EQ, 48 */
		/* 8216DB38h case   11:*/		if ( regs.CR[6].eq ) { return 0x8216DB68;  }
		/* 8216DB38h case   11:*/		return 0x8216DB3C;
		  /* 8216DB3Ch */ case   12:  		/* cmplwi CR6, R10, 87 */
		/* 8216DB3Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000057);
		/* 8216DB3Ch case   12:*/		return 0x8216DB40;
		  /* 8216DB40h */ case   13:  		/* bc 12, CR6_EQ, 40 */
		/* 8216DB40h case   13:*/		if ( regs.CR[6].eq ) { return 0x8216DB68;  }
		/* 8216DB40h case   13:*/		return 0x8216DB44;
		  /* 8216DB44h */ case   14:  		/* cmplwi CR6, R10, 89 */
		/* 8216DB44h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000059);
		/* 8216DB44h case   14:*/		return 0x8216DB48;
		  /* 8216DB48h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 8216DB48h case   15:*/		if ( regs.CR[6].eq ) { return 0x8216DB68;  }
		/* 8216DB48h case   15:*/		return 0x8216DB4C;
		  /* 8216DB4Ch */ case   16:  		/* cmplwi CR6, R10, 90 */
		/* 8216DB4Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005A);
		/* 8216DB4Ch case   16:*/		return 0x8216DB50;
		  /* 8216DB50h */ case   17:  		/* bc 12, CR6_EQ, 24 */
		/* 8216DB50h case   17:*/		if ( regs.CR[6].eq ) { return 0x8216DB68;  }
		/* 8216DB50h case   17:*/		return 0x8216DB54;
		  /* 8216DB54h */ case   18:  		/* cmplwi CR6, R10, 84 */
		/* 8216DB54h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000054);
		/* 8216DB54h case   18:*/		return 0x8216DB58;
		  /* 8216DB58h */ case   19:  		/* bc 12, CR6_EQ, 16 */
		/* 8216DB58h case   19:*/		if ( regs.CR[6].eq ) { return 0x8216DB68;  }
		/* 8216DB58h case   19:*/		return 0x8216DB5C;
		  /* 8216DB5Ch */ case   20:  		/* cmplwi CR6, R10, 85 */
		/* 8216DB5Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000055);
		/* 8216DB5Ch case   20:*/		return 0x8216DB60;
		  /* 8216DB60h */ case   21:  		/* mr R11, R21 */
		/* 8216DB60h case   21:*/		regs.R11 = regs.R21;
		/* 8216DB60h case   21:*/		return 0x8216DB64;
		  /* 8216DB64h */ case   22:  		/* bc 4, CR6_EQ, 8 */
		/* 8216DB64h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8216DB6C;  }
		/* 8216DB64h case   22:*/		return 0x8216DB68;
	}
	return 0x8216DB68;
} // Block from 8216DB0Ch-8216DB68h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8216DB68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DB68);
		  /* 8216DB68h */ case    0:  		/* mr R11, R20 */
		/* 8216DB68h case    0:*/		regs.R11 = regs.R20;
		/* 8216DB68h case    0:*/		return 0x8216DB6C;
	}
	return 0x8216DB6C;
} // Block from 8216DB68h-8216DB6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216DB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DB6C);
		  /* 8216DB6Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216DB6Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216DB6Ch case    0:*/		return 0x8216DB70;
		  /* 8216DB70h */ case    1:  		/* bc 12, CR0_EQ, 1032 */
		/* 8216DB70h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216DF78;  }
		/* 8216DB70h case    1:*/		return 0x8216DB74;
		  /* 8216DB74h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 8216DB74h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216DB74h case    2:*/		return 0x8216DB78;
		  /* 8216DB78h */ case    3:  		/* mr R3, R24 */
		/* 8216DB78h case    3:*/		regs.R3 = regs.R24;
		/* 8216DB78h case    3:*/		return 0x8216DB7C;
		  /* 8216DB7Ch */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216DB7Ch case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216DB7Ch case    4:*/		return 0x8216DB80;
		  /* 8216DB80h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8216DB80h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8216DB80h case    5:*/		return 0x8216DB84;
		  /* 8216DB84h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216DB84h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216DB84h case    6:*/		return 0x8216DB88;
		  /* 8216DB88h */ case    7:  		/* bl -38744 */
		/* 8216DB88h case    7:*/		regs.LR = 0x8216DB8C; return 0x82164430;
		/* 8216DB88h case    7:*/		return 0x8216DB8C;
		  /* 8216DB8Ch */ case    8:  		/* addi R11, R29, -16 */
		/* 8216DB8Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFF0);
		/* 8216DB8Ch case    8:*/		return 0x8216DB90;
		  /* 8216DB90h */ case    9:  		/* add R30, R3, R11 */
		/* 8216DB90h case    9:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R11);
		/* 8216DB90h case    9:*/		return 0x8216DB94;
		  /* 8216DB94h */ case   10:  		/* lwz R11, <#[R30]> */
		/* 8216DB94h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216DB94h case   10:*/		return 0x8216DB98;
		  /* 8216DB98h */ case   11:  		/* rlwinm. R11, R11, 0, 30, 31 */
		/* 8216DB98h case   11:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8216DB98h case   11:*/		return 0x8216DB9C;
		  /* 8216DB9Ch */ case   12:  		/* bc 4, CR0_EQ, 1384 */
		/* 8216DB9Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x8216E104;  }
		/* 8216DB9Ch case   12:*/		return 0x8216DBA0;
		  /* 8216DBA0h */ case   13:  		/* mr R4, R24 */
		/* 8216DBA0h case   13:*/		regs.R4 = regs.R24;
		/* 8216DBA0h case   13:*/		return 0x8216DBA4;
		  /* 8216DBA4h */ case   14:  		/* mr R3, R29 */
		/* 8216DBA4h case   14:*/		regs.R3 = regs.R29;
		/* 8216DBA4h case   14:*/		return 0x8216DBA8;
		  /* 8216DBA8h */ case   15:  		/* bl -37920 */
		/* 8216DBA8h case   15:*/		regs.LR = 0x8216DBAC; return 0x82164788;
		/* 8216DBA8h case   15:*/		return 0x8216DBAC;
		  /* 8216DBACh */ case   16:  		/* cmpwi CR6, R3, 4 */
		/* 8216DBACh case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 8216DBACh case   16:*/		return 0x8216DBB0;
		  /* 8216DBB0h */ case   17:  		/* bc 4, CR6_EQ, 16 */
		/* 8216DBB0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216DBC0;  }
		/* 8216DBB0h case   17:*/		return 0x8216DBB4;
		  /* 8216DBB4h */ case   18:  		/* lwz R11, <#[R26 + 76]> */
		/* 8216DBB4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 8216DBB4h case   18:*/		return 0x8216DBB8;
		  /* 8216DBB8h */ case   19:  		/* oris R11, R11, 1024 */
		/* 8216DBB8h case   19:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 8216DBB8h case   19:*/		return 0x8216DBBC;
		  /* 8216DBBCh */ case   20:  		/* stw R11, <#[R26 + 76]> */
		/* 8216DBBCh case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 8216DBBCh case   20:*/		return 0x8216DBC0;
	}
	return 0x8216DBC0;
} // Block from 8216DB6Ch-8216DBC0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216DBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DBC0);
		  /* 8216DBC0h */ case    0:  		/* lwz R11, <#[R26 + 48]> */
		/* 8216DBC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 8216DBC0h case    0:*/		return 0x8216DBC4;
		  /* 8216DBC4h */ case    1:  		/* mr R3, R24 */
		/* 8216DBC4h case    1:*/		regs.R3 = regs.R24;
		/* 8216DBC4h case    1:*/		return 0x8216DBC8;
		  /* 8216DBC8h */ case    2:  		/* lwz R27, <#[R30]> */
		/* 8216DBC8h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x00000000) );
		/* 8216DBC8h case    2:*/		return 0x8216DBCC;
		  /* 8216DBCCh */ case    3:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 8216DBCCh case    3:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 8216DBCCh case    3:*/		return 0x8216DBD0;
		  /* 8216DBD0h */ case    4:  		/* bc 4, CR0_EQ, 48 */
		/* 8216DBD0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216DC00;  }
		/* 8216DBD0h case    4:*/		return 0x8216DBD4;
		  /* 8216DBD4h */ case    5:  		/* mr R4, R27 */
		/* 8216DBD4h case    5:*/		regs.R4 = regs.R27;
		/* 8216DBD4h case    5:*/		return 0x8216DBD8;
		  /* 8216DBD8h */ case    6:  		/* bl -2240 */
		/* 8216DBD8h case    6:*/		regs.LR = 0x8216DBDC; return 0x8216D318;
		/* 8216DBD8h case    6:*/		return 0x8216DBDC;
		  /* 8216DBDCh */ case    7:  		/* ori R11, R3, 1 */
		/* 8216DBDCh case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216DBDCh case    7:*/		return 0x8216DBE0;
		  /* 8216DBE0h */ case    8:  		/* stw R11, <#[R30]> */
		/* 8216DBE0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216DBE0h case    8:*/		return 0x8216DBE4;
		  /* 8216DBE4h */ case    9:  		/* lwz R11, <#[R29 + 8]> */
		/* 8216DBE4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216DBE4h case    9:*/		return 0x8216DBE8;
		  /* 8216DBE8h */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216DBE8h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216DBE8h case   10:*/		return 0x8216DBEC;
		  /* 8216DBECh */ case   11:  		/* cmplwi CR6, R11, 10752 */
		/* 8216DBECh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002A00);
		/* 8216DBECh case   11:*/		return 0x8216DBF0;
		  /* 8216DBF0h */ case   12:  		/* bc 4, CR6_EQ, 1300 */
		/* 8216DBF0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8216E104;  }
		/* 8216DBF0h case   12:*/		return 0x8216DBF4;
		  /* 8216DBF4h */ case   13:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 8216DBF4h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 8216DBF4h case   13:*/		return 0x8216DBF8;
		  /* 8216DBF8h */ case   14:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216DBF8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216DBF8h case   14:*/		return 0x8216DBFC;
		  /* 8216DBFCh */ case   15:  		/* b 1264 */
		/* 8216DBFCh case   15:*/		return 0x8216E0EC;
		/* 8216DBFCh case   15:*/		return 0x8216DC00;
	}
	return 0x8216DC00;
} // Block from 8216DBC0h-8216DC00h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216DC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DC00);
		  /* 8216DC00h */ case    0:  		/* addi R6, R1, 84 */
		/* 8216DC00h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 8216DC00h case    0:*/		return 0x8216DC04;
		  /* 8216DC04h */ case    1:  		/* mr R5, R30 */
		/* 8216DC04h case    1:*/		regs.R5 = regs.R30;
		/* 8216DC04h case    1:*/		return 0x8216DC08;
		  /* 8216DC08h */ case    2:  		/* mr R4, R29 */
		/* 8216DC08h case    2:*/		regs.R4 = regs.R29;
		/* 8216DC08h case    2:*/		return 0x8216DC0C;
		  /* 8216DC0Ch */ case    3:  		/* bl -3956 */
		/* 8216DC0Ch case    3:*/		regs.LR = 0x8216DC10; return 0x8216CC98;
		/* 8216DC0Ch case    3:*/		return 0x8216DC10;
		  /* 8216DC10h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216DC10h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216DC10h case    4:*/		return 0x8216DC14;
		  /* 8216DC14h */ case    5:  		/* bc 12, CR0_EQ, 116 */
		/* 8216DC14h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216DC88;  }
		/* 8216DC14h case    5:*/		return 0x8216DC18;
		  /* 8216DC18h */ case    6:  		/* li R6, 1 */
		/* 8216DC18h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216DC18h case    6:*/		return 0x8216DC1C;
		  /* 8216DC1Ch */ case    7:  		/* li R5, 0 */
		/* 8216DC1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216DC1Ch case    7:*/		return 0x8216DC20;
		  /* 8216DC20h */ case    8:  		/* mr R4, R29 */
		/* 8216DC20h case    8:*/		regs.R4 = regs.R29;
		/* 8216DC20h case    8:*/		return 0x8216DC24;
		  /* 8216DC24h */ case    9:  		/* mr R3, R24 */
		/* 8216DC24h case    9:*/		regs.R3 = regs.R24;
		/* 8216DC24h case    9:*/		return 0x8216DC28;
		  /* 8216DC28h */ case   10:  		/* bl 776096 */
		/* 8216DC28h case   10:*/		regs.LR = 0x8216DC2C; return 0x8222B3C8;
		/* 8216DC28h case   10:*/		return 0x8216DC2C;
		  /* 8216DC2Ch */ case   11:  		/* lwz R31, <#[R1 + 84]> */
		/* 8216DC2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8216DC2Ch case   11:*/		return 0x8216DC30;
		  /* 8216DC30h */ case   12:  		/* cmplwi CR6, R31, 0 */
		/* 8216DC30h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216DC30h case   12:*/		return 0x8216DC34;
		  /* 8216DC34h */ case   13:  		/* bc 12, CR6_EQ, 1232 */
		/* 8216DC34h case   13:*/		if ( regs.CR[6].eq ) { return 0x8216E104;  }
		/* 8216DC34h case   13:*/		return 0x8216DC38;
		  /* 8216DC38h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216DC38h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DC38h case   14:*/		return 0x8216DC3C;
		  /* 8216DC3Ch */ case   15:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 8216DC3Ch case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 8216DC3Ch case   15:*/		return 0x8216DC40;
		  /* 8216DC40h */ case   16:  		/* cmplwi CR6, R10, 15360 */
		/* 8216DC40h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003C00);
		/* 8216DC40h case   16:*/		return 0x8216DC44;
		  /* 8216DC44h */ case   17:  		/* bc 4, CR6_EQ, 12 */
		/* 8216DC44h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216DC50;  }
		/* 8216DC44h case   17:*/		return 0x8216DC48;
		  /* 8216DC48h */ case   18:  		/* mr R4, R31 */
		/* 8216DC48h case   18:*/		regs.R4 = regs.R31;
		/* 8216DC48h case   18:*/		return 0x8216DC4C;
		  /* 8216DC4Ch */ case   19:  		/* b 1140 */
		/* 8216DC4Ch case   19:*/		return 0x8216E0C0;
		/* 8216DC4Ch case   19:*/		return 0x8216DC50;
	}
	return 0x8216DC50;
} // Block from 8216DC00h-8216DC50h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216DC50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DC50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DC50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DC50);
		  /* 8216DC50h */ case    0:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 8216DC50h case    0:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 8216DC50h case    0:*/		return 0x8216DC54;
		  /* 8216DC54h */ case    1:  		/* bc 4, CR0_EQ, 1200 */
		/* 8216DC54h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216E104;  }
		/* 8216DC54h case    1:*/		return 0x8216DC58;
		  /* 8216DC58h */ case    2:  		/* lwz R5, <#[R26 + 96]> */
		/* 8216DC58h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000060) );
		/* 8216DC58h case    2:*/		return 0x8216DC5C;
		  /* 8216DC5Ch */ case    3:  		/* cmplwi CR6, R5, 0 */
		/* 8216DC5Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8216DC5Ch case    3:*/		return 0x8216DC60;
		  /* 8216DC60h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 8216DC60h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216DC74;  }
		/* 8216DC60h case    4:*/		return 0x8216DC64;
		  /* 8216DC64h */ case    5:  		/* mr R6, R24 */
		/* 8216DC64h case    5:*/		regs.R6 = regs.R24;
		/* 8216DC64h case    5:*/		return 0x8216DC68;
		  /* 8216DC68h */ case    6:  		/* li R4, 1 */
		/* 8216DC68h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216DC68h case    6:*/		return 0x8216DC6C;
		  /* 8216DC6Ch */ case    7:  		/* mr R3, R31 */
		/* 8216DC6Ch case    7:*/		regs.R3 = regs.R31;
		/* 8216DC6Ch case    7:*/		return 0x8216DC70;
		  /* 8216DC70h */ case    8:  		/* bl 44296 */
		/* 8216DC70h case    8:*/		regs.LR = 0x8216DC74; return 0x82178978;
		/* 8216DC70h case    8:*/		return 0x8216DC74;
	}
	return 0x8216DC74;
} // Block from 8216DC50h-8216DC74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216DC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DC74);
		  /* 8216DC74h */ case    0:  		/* stw R31, <#[R26 + 96]> */
		/* 8216DC74h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + 0x00000060) );
		/* 8216DC74h case    0:*/		return 0x8216DC78;
		  /* 8216DC78h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216DC78h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DC78h case    1:*/		return 0x8216DC7C;
		  /* 8216DC7Ch */ case    2:  		/* oris R11, R11, 512 */
		/* 8216DC7Ch case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8216DC7Ch case    2:*/		return 0x8216DC80;
		  /* 8216DC80h */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 8216DC80h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DC80h case    3:*/		return 0x8216DC84;
		  /* 8216DC84h */ case    4:  		/* b 1152 */
		/* 8216DC84h case    4:*/		return 0x8216E104;
		/* 8216DC84h case    4:*/		return 0x8216DC88;
	}
	return 0x8216DC88;
} // Block from 8216DC74h-8216DC88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216DC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DC88);
		  /* 8216DC88h */ case    0:  		/* lwz R11, <#[R24 + 44]> */
		/* 8216DC88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000002C) );
		/* 8216DC88h case    0:*/		return 0x8216DC8C;
		  /* 8216DC8Ch */ case    1:  		/* lwz R31, <#[R1 + 84]> */
		/* 8216DC8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8216DC8Ch case    1:*/		return 0x8216DC90;
		  /* 8216DC90h */ case    2:  		/* ori R11, R11, 8192 */
		/* 8216DC90h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 8216DC90h case    2:*/		return 0x8216DC94;
		  /* 8216DC94h */ case    3:  		/* stw R11, <#[R24 + 44]> */
		/* 8216DC94h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x0000002C) );
		/* 8216DC94h case    3:*/		return 0x8216DC98;
		  /* 8216DC98h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216DC98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DC98h case    4:*/		return 0x8216DC9C;
		  /* 8216DC9Ch */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216DC9Ch case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216DC9Ch case    5:*/		return 0x8216DCA0;
		  /* 8216DCA0h */ case    6:  		/* cmplwi CR6, R11, 21 */
		/* 8216DCA0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8216DCA0h case    6:*/		return 0x8216DCA4;
		  /* 8216DCA4h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 8216DCA4h case    7:*/		if ( regs.CR[6].lt ) { return 0x8216DCB4;  }
		/* 8216DCA4h case    7:*/		return 0x8216DCA8;
		  /* 8216DCA8h */ case    8:  		/* cmplwi CR6, R11, 24 */
		/* 8216DCA8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8216DCA8h case    8:*/		return 0x8216DCAC;
		  /* 8216DCACh */ case    9:  		/* mr R11, R20 */
		/* 8216DCACh case    9:*/		regs.R11 = regs.R20;
		/* 8216DCACh case    9:*/		return 0x8216DCB0;
		  /* 8216DCB0h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 8216DCB0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8216DCB8;  }
		/* 8216DCB0h case   10:*/		return 0x8216DCB4;
	}
	return 0x8216DCB4;
} // Block from 8216DC88h-8216DCB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216DCB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DCB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DCB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DCB4);
		  /* 8216DCB4h */ case    0:  		/* mr R11, R21 */
		/* 8216DCB4h case    0:*/		regs.R11 = regs.R21;
		/* 8216DCB4h case    0:*/		return 0x8216DCB8;
	}
	return 0x8216DCB8;
} // Block from 8216DCB4h-8216DCB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216DCB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DCB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DCB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DCB8);
		  /* 8216DCB8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216DCB8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216DCB8h case    0:*/		return 0x8216DCBC;
		  /* 8216DCBCh */ case    1:  		/* mr R3, R24 */
		/* 8216DCBCh case    1:*/		regs.R3 = regs.R24;
		/* 8216DCBCh case    1:*/		return 0x8216DCC0;
		  /* 8216DCC0h */ case    2:  		/* bc 4, CR0_EQ, 428 */
		/* 8216DCC0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216DE6C;  }
		/* 8216DCC0h case    2:*/		return 0x8216DCC4;
		  /* 8216DCC4h */ case    3:  		/* mr R4, R27 */
		/* 8216DCC4h case    3:*/		regs.R4 = regs.R27;
		/* 8216DCC4h case    3:*/		return 0x8216DCC8;
		  /* 8216DCC8h */ case    4:  		/* bl -2480 */
		/* 8216DCC8h case    4:*/		regs.LR = 0x8216DCCC; return 0x8216D318;
		/* 8216DCC8h case    4:*/		return 0x8216DCCC;
		  /* 8216DCCCh */ case    5:  		/* ori R11, R3, 1 */
		/* 8216DCCCh case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216DCCCh case    5:*/		return 0x8216DCD0;
		  /* 8216DCD0h */ case    6:  		/* stw R11, <#[R30]> */
		/* 8216DCD0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216DCD0h case    6:*/		return 0x8216DCD4;
		  /* 8216DCD4h */ case    7:  		/* lwz R11, <#[R27 + 76]> */
		/* 8216DCD4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000004C) );
		/* 8216DCD4h case    7:*/		return 0x8216DCD8;
		  /* 8216DCD8h */ case    8:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8216DCD8h case    8:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8216DCD8h case    8:*/		return 0x8216DCDC;
		  /* 8216DCDCh */ case    9:  		/* bc 12, CR0_EQ, 1064 */
		/* 8216DCDCh case    9:*/		if ( regs.CR[0].eq ) { return 0x8216E104;  }
		/* 8216DCDCh case    9:*/		return 0x8216DCE0;
		  /* 8216DCE0h */ case   10:  		/* lwz R11, <#[R27 + 112]> */
		/* 8216DCE0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000070) );
		/* 8216DCE0h case   10:*/		return 0x8216DCE4;
		  /* 8216DCE4h */ case   11:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216DCE4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216DCE4h case   11:*/		return 0x8216DCE8;
		  /* 8216DCE8h */ case   12:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 8216DCE8h case   12:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 8216DCE8h case   12:*/		return 0x8216DCEC;
		  /* 8216DCECh */ case   13:  		/* bc 12, CR0_EQ, 48 */
		/* 8216DCECh case   13:*/		if ( regs.CR[0].eq ) { return 0x8216DD1C;  }
		/* 8216DCECh case   13:*/		return 0x8216DCF0;
		  /* 8216DCF0h */ case   14:  		/* b 16 */
		/* 8216DCF0h case   14:*/		return 0x8216DD00;
		/* 8216DCF0h case   14:*/		return 0x8216DCF4;
		  /* 8216DCF4h */ case   15:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216DCF4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216DCF4h case   15:*/		return 0x8216DCF8;
		  /* 8216DCF8h */ case   16:  		/* rlwinm. R10, R10, 0, 9, 9 */
		/* 8216DCF8h case   16:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R10,regs.R10);
		/* 8216DCF8h case   16:*/		return 0x8216DCFC;
		  /* 8216DCFCh */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 8216DCFCh case   17:*/		if ( regs.CR[0].eq ) { return 0x8216DD0C;  }
		/* 8216DCFCh case   17:*/		return 0x8216DD00;
	}
	return 0x8216DD00;
} // Block from 8216DCB8h-8216DD00h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8216DD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DD00);
		  /* 8216DD00h */ case    0:  		/* lwz R11, <#[R11 + 80]> */
		/* 8216DD00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8216DD00h case    0:*/		return 0x8216DD04;
		  /* 8216DD04h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216DD04h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DD04h case    1:*/		return 0x8216DD08;
		  /* 8216DD08h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 8216DD08h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216DCF4;  }
		/* 8216DD08h case    2:*/		return 0x8216DD0C;
	}
	return 0x8216DD0C;
} // Block from 8216DD00h-8216DD0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216DD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DD0C);
		  /* 8216DD0Ch */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216DD0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216DD0Ch case    0:*/		return 0x8216DD10;
		  /* 8216DD10h */ case    1:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 8216DD10h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 8216DD10h case    1:*/		return 0x8216DD14;
		  /* 8216DD14h */ case    2:  		/* bc 4, CR0_EQ, -20 */
		/* 8216DD14h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216DD00;  }
		/* 8216DD14h case    2:*/		return 0x8216DD18;
		  /* 8216DD18h */ case    3:  		/* stw R11, <#[R27 + 112]> */
		/* 8216DD18h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000070) );
		/* 8216DD18h case    3:*/		return 0x8216DD1C;
	}
	return 0x8216DD1C;
} // Block from 8216DD0Ch-8216DD1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216DD1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DD1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DD1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DD1C);
		  /* 8216DD1Ch */ case    0:  		/* lwz R11, <#[R27 + 112]> */
		/* 8216DD1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000070) );
		/* 8216DD1Ch case    0:*/		return 0x8216DD20;
		  /* 8216DD20h */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 8216DD20h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8216DD20h case    1:*/		return 0x8216DD24;
		  /* 8216DD24h */ case    2:  		/* bc 4, CR6_EQ, 992 */
		/* 8216DD24h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216E104;  }
		/* 8216DD24h case    2:*/		return 0x8216DD28;
		  /* 8216DD28h */ case    3:  		/* lwz R11, <#[R30 + 12]> */
		/* 8216DD28h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8216DD28h case    3:*/		return 0x8216DD2C;
		  /* 8216DD2Ch */ case    4:  		/* mr R30, R20 */
		/* 8216DD2Ch case    4:*/		regs.R30 = regs.R20;
		/* 8216DD2Ch case    4:*/		return 0x8216DD30;
		  /* 8216DD30h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216DD30h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216DD30h case    5:*/		return 0x8216DD34;
		  /* 8216DD34h */ case    6:  		/* bc 4, CR0_EQ, 136 */
		/* 8216DD34h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216DDBC;  }
		/* 8216DD34h case    6:*/		return 0x8216DD38;
		  /* 8216DD38h */ case    7:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8216DD38h case    7:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8216DD38h case    7:*/		return 0x8216DD3C;
		  /* 8216DD3Ch */ case    8:  		/* bc 12, CR0_EQ, 124 */
		/* 8216DD3Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8216DDB8;  }
		/* 8216DD3Ch case    8:*/		return 0x8216DD40;
		  /* 8216DD40h */ case    9:  		/* li R6, 1 */
		/* 8216DD40h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216DD40h case    9:*/		return 0x8216DD44;
		  /* 8216DD44h */ case   10:  		/* li R5, 0 */
		/* 8216DD44h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216DD44h case   10:*/		return 0x8216DD48;
		  /* 8216DD48h */ case   11:  		/* mr R4, R29 */
		/* 8216DD48h case   11:*/		regs.R4 = regs.R29;
		/* 8216DD48h case   11:*/		return 0x8216DD4C;
		  /* 8216DD4Ch */ case   12:  		/* mr R3, R24 */
		/* 8216DD4Ch case   12:*/		regs.R3 = regs.R24;
		/* 8216DD4Ch case   12:*/		return 0x8216DD50;
		  /* 8216DD50h */ case   13:  		/* bl 775800 */
		/* 8216DD50h case   13:*/		regs.LR = 0x8216DD54; return 0x8222B3C8;
		/* 8216DD50h case   13:*/		return 0x8216DD54;
		  /* 8216DD54h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216DD54h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DD54h case   14:*/		return 0x8216DD58;
		  /* 8216DD58h */ case   15:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 8216DD58h case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 8216DD58h case   15:*/		return 0x8216DD5C;
		  /* 8216DD5Ch */ case   16:  		/* cmplwi CR6, R10, 15360 */
		/* 8216DD5Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003C00);
		/* 8216DD5Ch case   16:*/		return 0x8216DD60;
		  /* 8216DD60h */ case   17:  		/* bc 4, CR6_EQ, 32 */
		/* 8216DD60h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216DD80;  }
		/* 8216DD60h case   17:*/		return 0x8216DD64;
		  /* 8216DD64h */ case   18:  		/* li R6, 1 */
		/* 8216DD64h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216DD64h case   18:*/		return 0x8216DD68;
		  /* 8216DD68h */ case   19:  		/* li R5, 0 */
		/* 8216DD68h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216DD68h case   19:*/		return 0x8216DD6C;
		  /* 8216DD6Ch */ case   20:  		/* mr R4, R31 */
		/* 8216DD6Ch case   20:*/		regs.R4 = regs.R31;
		/* 8216DD6Ch case   20:*/		return 0x8216DD70;
		  /* 8216DD70h */ case   21:  		/* mr R3, R24 */
		/* 8216DD70h case   21:*/		regs.R3 = regs.R24;
		/* 8216DD70h case   21:*/		return 0x8216DD74;
		  /* 8216DD74h */ case   22:  		/* bl 775764 */
		/* 8216DD74h case   22:*/		regs.LR = 0x8216DD78; return 0x8222B3C8;
		/* 8216DD74h case   22:*/		return 0x8216DD78;
		  /* 8216DD78h */ case   23:  		/* stw R21, <#[R1 + 84]> */
		/* 8216DD78h case   23:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 8216DD78h case   23:*/		return 0x8216DD7C;
		  /* 8216DD7Ch */ case   24:  		/* b 64 */
		/* 8216DD7Ch case   24:*/		return 0x8216DDBC;
		/* 8216DD7Ch case   24:*/		return 0x8216DD80;
	}
	return 0x8216DD80;
} // Block from 8216DD1Ch-8216DD80h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8216DD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DD80);
		  /* 8216DD80h */ case    0:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 8216DD80h case    0:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 8216DD80h case    0:*/		return 0x8216DD84;
		  /* 8216DD84h */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 8216DD84h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216DDBC;  }
		/* 8216DD84h case    1:*/		return 0x8216DD88;
	}
	return 0x8216DD88;
} // Block from 8216DD80h-8216DD88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216DD88h
// Function '?EnsureExecBoundary@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DD88);
		  /* 8216DD88h */ case    0:  		/* lwz R5, <#[R26 + 96]> */
		/* 8216DD88h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000060) );
		/* 8216DD88h case    0:*/		return 0x8216DD8C;
		  /* 8216DD8Ch */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 8216DD8Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8216DD8Ch case    1:*/		return 0x8216DD90;
		  /* 8216DD90h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8216DD90h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216DDA4;  }
		/* 8216DD90h case    2:*/		return 0x8216DD94;
		  /* 8216DD94h */ case    3:  		/* mr R6, R24 */
		/* 8216DD94h case    3:*/		regs.R6 = regs.R24;
		/* 8216DD94h case    3:*/		return 0x8216DD98;
		  /* 8216DD98h */ case    4:  		/* li R4, 1 */
		/* 8216DD98h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216DD98h case    4:*/		return 0x8216DD9C;
		  /* 8216DD9Ch */ case    5:  		/* mr R3, R31 */
		/* 8216DD9Ch case    5:*/		regs.R3 = regs.R31;
		/* 8216DD9Ch case    5:*/		return 0x8216DDA0;
		  /* 8216DDA0h */ case    6:  		/* bl 43992 */
		/* 8216DDA0h case    6:*/		regs.LR = 0x8216DDA4; return 0x82178978;
		/* 8216DDA0h case    6:*/		return 0x8216DDA4;
	}
	return 0x8216DDA4;
} // Block from 8216DD88h-8216DDA4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216DDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DDA4);
		  /* 8216DDA4h */ case    0:  		/* stw R31, <#[R26 + 96]> */
		/* 8216DDA4h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + 0x00000060) );
		/* 8216DDA4h case    0:*/		return 0x8216DDA8;
		  /* 8216DDA8h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216DDA8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DDA8h case    1:*/		return 0x8216DDAC;
		  /* 8216DDACh */ case    2:  		/* oris R11, R11, 512 */
		/* 8216DDACh case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8216DDACh case    2:*/		return 0x8216DDB0;
		  /* 8216DDB0h */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 8216DDB0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DDB0h case    3:*/		return 0x8216DDB4;
		  /* 8216DDB4h */ case    4:  		/* b 8 */
		/* 8216DDB4h case    4:*/		return 0x8216DDBC;
		/* 8216DDB4h case    4:*/		return 0x8216DDB8;
	}
	return 0x8216DDB8;
} // Block from 8216DDA4h-8216DDB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216DDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DDB8);
		  /* 8216DDB8h */ case    0:  		/* mr R30, R21 */
		/* 8216DDB8h case    0:*/		regs.R30 = regs.R21;
		/* 8216DDB8h case    0:*/		return 0x8216DDBC;
	}
	return 0x8216DDBC;
} // Block from 8216DDB8h-8216DDBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216DDBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DDBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DDBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DDBC);
		  /* 8216DDBCh */ case    0:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 8216DDBCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 8216DDBCh case    0:*/		return 0x8216DDC0;
		  /* 8216DDC0h */ case    1:  		/* bc 12, CR0_EQ, 836 */
		/* 8216DDC0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216E104;  }
		/* 8216DDC0h case    1:*/		return 0x8216DDC4;
		  /* 8216DDC4h */ case    2:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 8216DDC4h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 8216DDC4h case    2:*/		return 0x8216DDC8;
		  /* 8216DDC8h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8216DDC8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216DDC8h case    3:*/		return 0x8216DDCC;
		  /* 8216DDCCh */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216DDCCh case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216DDCCh case    4:*/		return 0x8216DDD0;
		  /* 8216DDD0h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8216DDD0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216DDDC;  }
		/* 8216DDD0h case    5:*/		return 0x8216DDD4;
		  /* 8216DDD4h */ case    6:  		/* mr R30, R21 */
		/* 8216DDD4h case    6:*/		regs.R30 = regs.R21;
		/* 8216DDD4h case    6:*/		return 0x8216DDD8;
		  /* 8216DDD8h */ case    7:  		/* b 12 */
		/* 8216DDD8h case    7:*/		return 0x8216DDE4;
		/* 8216DDD8h case    7:*/		return 0x8216DDDC;
	}
	return 0x8216DDDC;
} // Block from 8216DDBCh-8216DDDCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216DDDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DDDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DDDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DDDC);
		  /* 8216DDDCh */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216DDDCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216DDDCh case    0:*/		return 0x8216DDE0;
		  /* 8216DDE0h */ case    1:  		/* addi R30, R11, -4 */
		/* 8216DDE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFC);
		/* 8216DDE0h case    1:*/		return 0x8216DDE4;
	}
	return 0x8216DDE4;
} // Block from 8216DDDCh-8216DDE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216DDE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DDE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DDE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DDE4);
		  /* 8216DDE4h */ case    0:  		/* cmplw CR6, R30, R26 */
		/* 8216DDE4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R26);
		/* 8216DDE4h case    0:*/		return 0x8216DDE8;
		  /* 8216DDE8h */ case    1:  		/* bc 12, CR6_EQ, 796 */
		/* 8216DDE8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216E104;  }
		/* 8216DDE8h case    1:*/		return 0x8216DDEC;
		  /* 8216DDECh */ case    2:  		/* li R8, 0 */
		/* 8216DDECh case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216DDECh case    2:*/		return 0x8216DDF0;
		  /* 8216DDF0h */ case    3:  		/* li R7, 0 */
		/* 8216DDF0h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216DDF0h case    3:*/		return 0x8216DDF4;
		  /* 8216DDF4h */ case    4:  		/* li R6, 90 */
		/* 8216DDF4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x5A);
		/* 8216DDF4h case    4:*/		return 0x8216DDF8;
		  /* 8216DDF8h */ case    5:  		/* addi R5, R30, 24 */
		/* 8216DDF8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0x18);
		/* 8216DDF8h case    5:*/		return 0x8216DDFC;
		  /* 8216DDFCh */ case    6:  		/* mr R4, R30 */
		/* 8216DDFCh case    6:*/		regs.R4 = regs.R30;
		/* 8216DDFCh case    6:*/		return 0x8216DE00;
		  /* 8216DE00h */ case    7:  		/* mr R3, R24 */
		/* 8216DE00h case    7:*/		regs.R3 = regs.R24;
		/* 8216DE00h case    7:*/		return 0x8216DE04;
		  /* 8216DE04h */ case    8:  		/* bl 748436 */
		/* 8216DE04h case    8:*/		regs.LR = 0x8216DE08; return 0x82224998;
		/* 8216DE04h case    8:*/		return 0x8216DE08;
		  /* 8216DE08h */ case    9:  		/* mr R31, R3 */
		/* 8216DE08h case    9:*/		regs.R31 = regs.R3;
		/* 8216DE08h case    9:*/		return 0x8216DE0C;
		  /* 8216DE0Ch */ case   10:  		/* mr R3, R24 */
		/* 8216DE0Ch case   10:*/		regs.R3 = regs.R24;
		/* 8216DE0Ch case   10:*/		return 0x8216DE10;
		  /* 8216DE10h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216DE10h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DE10h case   11:*/		return 0x8216DE14;
		  /* 8216DE14h */ case   12:  		/* oris R11, R11, 2 */
		/* 8216DE14h case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8216DE14h case   12:*/		return 0x8216DE18;
		  /* 8216DE18h */ case   13:  		/* stw R11, <#[R31 + 8]> */
		/* 8216DE18h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DE18h case   13:*/		return 0x8216DE1C;
		  /* 8216DE1Ch */ case   14:  		/* lwz R10, <#[R30 + 76]> */
		/* 8216DE1Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000004C) );
		/* 8216DE1Ch case   14:*/		return 0x8216DE20;
		  /* 8216DE20h */ case   15:  		/* rlwinm R10, R10, 9, 24, 31 */
		/* 8216DE20h case   15:*/		cpu::op::rlwinm<0,9,24,31>(regs,&regs.R10,regs.R10);
		/* 8216DE20h case   15:*/		return 0x8216DE24;
		  /* 8216DE24h */ case   16:  		/* rlwimi R11, R10, 18, 13, 13 */
		/* 8216DE24h case   16:*/		cpu::op::rlwimi<0,18,13,13>(regs,&regs.R11,regs.R10);
		/* 8216DE24h case   16:*/		return 0x8216DE28;
		  /* 8216DE28h */ case   17:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216DE28h case   17:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216DE28h case   17:*/		return 0x8216DE2C;
		  /* 8216DE2Ch */ case   18:  		/* stw R11, <#[R31 + 8]> */
		/* 8216DE2Ch case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216DE2Ch case   18:*/		return 0x8216DE30;
	}
	return 0x8216DE30;
} // Block from 8216DDE4h-8216DE30h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216DE30h
// Function '?EnsureExecBoundary@Compiler@D3DXShader@@AAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DE30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DE30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DE30);
		  /* 8216DE30h */ case    0:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8216DE30h case    0:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8216DE30h case    0:*/		return 0x8216DE34;
		  /* 8216DE34h */ case    1:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216DE34h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216DE34h case    1:*/		return 0x8216DE38;
		  /* 8216DE38h */ case    2:  		/* bl -39432 */
		/* 8216DE38h case    2:*/		regs.LR = 0x8216DE3C; return 0x82164430;
		/* 8216DE38h case    2:*/		return 0x8216DE3C;
		  /* 8216DE3Ch */ case    3:  		/* lwz R11, <#[R30 + 12]> */
		/* 8216DE3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8216DE3Ch case    3:*/		return 0x8216DE40;
		  /* 8216DE40h */ case    4:  		/* addi R10, R31, -16 */
		/* 8216DE40h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFF0);
		/* 8216DE40h case    4:*/		return 0x8216DE44;
		  /* 8216DE44h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216DE44h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DE44h case    5:*/		return 0x8216DE48;
		  /* 8216DE48h */ case    6:  		/* add R31, R3, R10 */
		/* 8216DE48h case    6:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R10);
		/* 8216DE48h case    6:*/		return 0x8216DE4C;
		  /* 8216DE4Ch */ case    7:  		/* mr R4, R21 */
		/* 8216DE4Ch case    7:*/		regs.R4 = regs.R21;
		/* 8216DE4Ch case    7:*/		return 0x8216DE50;
		  /* 8216DE50h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 8216DE50h case    8:*/		if ( regs.CR[6].eq ) { return 0x8216DE58;  }
		/* 8216DE50h case    8:*/		return 0x8216DE54;
		  /* 8216DE54h */ case    9:  		/* lwz R4, <#[R11]> */
		/* 8216DE54h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 8216DE54h case    9:*/		return 0x8216DE58;
	}
	return 0x8216DE58;
} // Block from 8216DE30h-8216DE58h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216DE58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DE58);
		  /* 8216DE58h */ case    0:  		/* mr R3, R24 */
		/* 8216DE58h case    0:*/		regs.R3 = regs.R24;
		/* 8216DE58h case    0:*/		return 0x8216DE5C;
		  /* 8216DE5Ch */ case    1:  		/* bl -2884 */
		/* 8216DE5Ch case    1:*/		regs.LR = 0x8216DE60; return 0x8216D318;
		/* 8216DE5Ch case    1:*/		return 0x8216DE60;
		  /* 8216DE60h */ case    2:  		/* ori R11, R3, 1 */
		/* 8216DE60h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216DE60h case    2:*/		return 0x8216DE64;
		  /* 8216DE64h */ case    3:  		/* stw R11, <#[R31]> */
		/* 8216DE64h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216DE64h case    3:*/		return 0x8216DE68;
		  /* 8216DE68h */ case    4:  		/* b 668 */
		/* 8216DE68h case    4:*/		return 0x8216E104;
		/* 8216DE68h case    4:*/		return 0x8216DE6C;
	}
	return 0x8216DE6C;
} // Block from 8216DE58h-8216DE6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216DE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DE6C);
		  /* 8216DE6Ch */ case    0:  		/* stw R21, <#[R1 + 80]> */
		/* 8216DE6Ch case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 8216DE6Ch case    0:*/		return 0x8216DE70;
		  /* 8216DE70h */ case    1:  		/* addi R6, R1, 88 */
		/* 8216DE70h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 8216DE70h case    1:*/		return 0x8216DE74;
		  /* 8216DE74h */ case    2:  		/* stw R21, <#[R1 + 88]> */
		/* 8216DE74h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000058) );
		/* 8216DE74h case    2:*/		return 0x8216DE78;
		  /* 8216DE78h */ case    3:  		/* addi R5, R1, 80 */
		/* 8216DE78h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8216DE78h case    3:*/		return 0x8216DE7C;
		  /* 8216DE7Ch */ case    4:  		/* mr R4, R31 */
		/* 8216DE7Ch case    4:*/		regs.R4 = regs.R31;
		/* 8216DE7Ch case    4:*/		return 0x8216DE80;
		  /* 8216DE80h */ case    5:  		/* bl 40640 */
		/* 8216DE80h case    5:*/		regs.LR = 0x8216DE84; return 0x82177D40;
		/* 8216DE80h case    5:*/		return 0x8216DE84;
		  /* 8216DE84h */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 8216DE84h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8216DE84h case    6:*/		return 0x8216DE88;
		  /* 8216DE88h */ case    7:  		/* lwz R4, <#[R1 + 88]> */
		/* 8216DE88h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8216DE88h case    7:*/		return 0x8216DE8C;
		  /* 8216DE8Ch */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8216DE8Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DE8Ch case    8:*/		return 0x8216DE90;
		  /* 8216DE90h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 8216DE90h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8216DEB0;  }
		/* 8216DE90h case    9:*/		return 0x8216DE94;
		  /* 8216DE94h */ case   10:  		/* cmplwi CR6, R4, 0 */
		/* 8216DE94h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8216DE94h case   10:*/		return 0x8216DE98;
		  /* 8216DE98h */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 8216DE98h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8216DEB0;  }
		/* 8216DE98h case   11:*/		return 0x8216DE9C;
		  /* 8216DE9Ch */ case   12:  		/* mr R4, R27 */
		/* 8216DE9Ch case   12:*/		regs.R4 = regs.R27;
		/* 8216DE9Ch case   12:*/		return 0x8216DEA0;
		  /* 8216DEA0h */ case   13:  		/* mr R3, R24 */
		/* 8216DEA0h case   13:*/		regs.R3 = regs.R24;
		/* 8216DEA0h case   13:*/		return 0x8216DEA4;
		  /* 8216DEA4h */ case   14:  		/* bl -2956 */
		/* 8216DEA4h case   14:*/		regs.LR = 0x8216DEA8; return 0x8216D318;
		/* 8216DEA4h case   14:*/		return 0x8216DEA8;
		  /* 8216DEA8h */ case   15:  		/* ori R11, R3, 1 */
		/* 8216DEA8h case   15:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216DEA8h case   15:*/		return 0x8216DEAC;
		  /* 8216DEACh */ case   16:  		/* b 196 */
		/* 8216DEACh case   16:*/		return 0x8216DF70;
		/* 8216DEACh case   16:*/		return 0x8216DEB0;
	}
	return 0x8216DEB0;
} // Block from 8216DE6Ch-8216DEB0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216DEB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DEB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DEB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DEB0);
		  /* 8216DEB0h */ case    0:  		/* mr R31, R21 */
		/* 8216DEB0h case    0:*/		regs.R31 = regs.R21;
		/* 8216DEB0h case    0:*/		return 0x8216DEB4;
		  /* 8216DEB4h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 8216DEB4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8216DEB4h case    1:*/		return 0x8216DEB8;
		  /* 8216DEB8h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8216DEB8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216DECC;  }
		/* 8216DEB8h case    2:*/		return 0x8216DEBC;
		  /* 8216DEBCh */ case    3:  		/* mr R3, R24 */
		/* 8216DEBCh case    3:*/		regs.R3 = regs.R24;
		/* 8216DEBCh case    3:*/		return 0x8216DEC0;
		  /* 8216DEC0h */ case    4:  		/* bl -2816 */
		/* 8216DEC0h case    4:*/		regs.LR = 0x8216DEC4; return 0x8216D3C0;
		/* 8216DEC0h case    4:*/		return 0x8216DEC4;
		  /* 8216DEC4h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 8216DEC4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8216DEC4h case    5:*/		return 0x8216DEC8;
		  /* 8216DEC8h */ case    6:  		/* mr R31, R3 */
		/* 8216DEC8h case    6:*/		regs.R31 = regs.R3;
		/* 8216DEC8h case    6:*/		return 0x8216DECC;
	}
	return 0x8216DECC;
} // Block from 8216DEB0h-8216DECCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216DECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DECC);
		  /* 8216DECCh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8216DECCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DECCh case    0:*/		return 0x8216DED0;
		  /* 8216DED0h */ case    1:  		/* bc 12, CR6_EQ, 156 */
		/* 8216DED0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216DF6C;  }
		/* 8216DED0h case    1:*/		return 0x8216DED4;
		  /* 8216DED4h */ case    2:  		/* mr R4, R11 */
		/* 8216DED4h case    2:*/		regs.R4 = regs.R11;
		/* 8216DED4h case    2:*/		return 0x8216DED8;
		  /* 8216DED8h */ case    3:  		/* mr R3, R24 */
		/* 8216DED8h case    3:*/		regs.R3 = regs.R24;
		/* 8216DED8h case    3:*/		return 0x8216DEDC;
		  /* 8216DEDCh */ case    4:  		/* bl -2844 */
		/* 8216DEDCh case    4:*/		regs.LR = 0x8216DEE0; return 0x8216D3C0;
		/* 8216DEDCh case    4:*/		return 0x8216DEE0;
		  /* 8216DEE0h */ case    5:  		/* ori R11, R3, 1 */
		/* 8216DEE0h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216DEE0h case    5:*/		return 0x8216DEE4;
		  /* 8216DEE4h */ case    6:  		/* lwz R10, <#[R1 + 80]> */
		/* 8216DEE4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8216DEE4h case    6:*/		return 0x8216DEE8;
		  /* 8216DEE8h */ case    7:  		/* li R8, 0 */
		/* 8216DEE8h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216DEE8h case    7:*/		return 0x8216DEEC;
		  /* 8216DEECh */ case    8:  		/* stw R11, <#[R30]> */
		/* 8216DEECh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216DEECh case    8:*/		return 0x8216DEF0;
		  /* 8216DEF0h */ case    9:  		/* li R7, 0 */
		/* 8216DEF0h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216DEF0h case    9:*/		return 0x8216DEF4;
		  /* 8216DEF4h */ case   10:  		/* li R6, 90 */
		/* 8216DEF4h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x5A);
		/* 8216DEF4h case   10:*/		return 0x8216DEF8;
		  /* 8216DEF8h */ case   11:  		/* mr R3, R24 */
		/* 8216DEF8h case   11:*/		regs.R3 = regs.R24;
		/* 8216DEF8h case   11:*/		return 0x8216DEFC;
		  /* 8216DEFCh */ case   12:  		/* lwz R4, <#[R10 + 28]> */
		/* 8216DEFCh case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000001C) );
		/* 8216DEFCh case   12:*/		return 0x8216DF00;
		  /* 8216DF00h */ case   13:  		/* addi R5, R4, 24 */
		/* 8216DF00h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 8216DF00h case   13:*/		return 0x8216DF04;
		  /* 8216DF04h */ case   14:  		/* bl 748180 */
		/* 8216DF04h case   14:*/		regs.LR = 0x8216DF08; return 0x82224998;
		/* 8216DF04h case   14:*/		return 0x8216DF08;
		  /* 8216DF08h */ case   15:  		/* mr R30, R3 */
		/* 8216DF08h case   15:*/		regs.R30 = regs.R3;
		/* 8216DF08h case   15:*/		return 0x8216DF0C;
		  /* 8216DF0Ch */ case   16:  		/* cmplwi CR6, R31, 0 */
		/* 8216DF0Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216DF0Ch case   16:*/		return 0x8216DF10;
		  /* 8216DF10h */ case   17:  		/* bc 4, CR6_EQ, 44 */
		/* 8216DF10h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216DF3C;  }
		/* 8216DF10h case   17:*/		return 0x8216DF14;
		  /* 8216DF14h */ case   18:  		/* lwz R11, <#[R1 + 80]> */
		/* 8216DF14h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8216DF14h case   18:*/		return 0x8216DF18;
		  /* 8216DF18h */ case   19:  		/* mr R4, R21 */
		/* 8216DF18h case   19:*/		regs.R4 = regs.R21;
		/* 8216DF18h case   19:*/		return 0x8216DF1C;
		  /* 8216DF1Ch */ case   20:  		/* lwz R11, <#[R11 + 28]> */
		/* 8216DF1Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8216DF1Ch case   20:*/		return 0x8216DF20;
		  /* 8216DF20h */ case   21:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216DF20h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216DF20h case   21:*/		return 0x8216DF24;
		  /* 8216DF24h */ case   22:  		/* cmplwi CR6, R11, 0 */
		/* 8216DF24h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DF24h case   22:*/		return 0x8216DF28;
		  /* 8216DF28h */ case   23:  		/* bc 12, CR6_EQ, 8 */
		/* 8216DF28h case   23:*/		if ( regs.CR[6].eq ) { return 0x8216DF30;  }
		/* 8216DF28h case   23:*/		return 0x8216DF2C;
		  /* 8216DF2Ch */ case   24:  		/* lwz R4, <#[R11]> */
		/* 8216DF2Ch case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 8216DF2Ch case   24:*/		return 0x8216DF30;
	}
	return 0x8216DF30;
} // Block from 8216DECCh-8216DF30h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8216DF30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DF30);
		  /* 8216DF30h */ case    0:  		/* mr R3, R24 */
		/* 8216DF30h case    0:*/		regs.R3 = regs.R24;
		/* 8216DF30h case    0:*/		return 0x8216DF34;
		  /* 8216DF34h */ case    1:  		/* bl -3100 */
		/* 8216DF34h case    1:*/		regs.LR = 0x8216DF38; return 0x8216D318;
		/* 8216DF34h case    1:*/		return 0x8216DF38;
		  /* 8216DF38h */ case    2:  		/* mr R31, R3 */
		/* 8216DF38h case    2:*/		regs.R31 = regs.R3;
		/* 8216DF38h case    2:*/		return 0x8216DF3C;
	}
	return 0x8216DF3C;
} // Block from 8216DF30h-8216DF3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216DF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DF3C);
		  /* 8216DF3Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8216DF3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8216DF3Ch case    0:*/		return 0x8216DF40;
		  /* 8216DF40h */ case    1:  		/* mr R3, R24 */
		/* 8216DF40h case    1:*/		regs.R3 = regs.R24;
		/* 8216DF40h case    1:*/		return 0x8216DF44;
		  /* 8216DF44h */ case    2:  		/* rlwimi R11, R20, 17, 13, 14 */
		/* 8216DF44h case    2:*/		cpu::op::rlwimi<0,17,13,14>(regs,&regs.R11,regs.R20);
		/* 8216DF44h case    2:*/		return 0x8216DF48;
		  /* 8216DF48h */ case    3:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216DF48h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216DF48h case    3:*/		return 0x8216DF4C;
		  /* 8216DF4Ch */ case    4:  		/* stw R11, <#[R30 + 8]> */
		/* 8216DF4Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8216DF4Ch case    4:*/		return 0x8216DF50;
		  /* 8216DF50h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8216DF50h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8216DF50h case    5:*/		return 0x8216DF54;
		  /* 8216DF54h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216DF54h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216DF54h case    6:*/		return 0x8216DF58;
		  /* 8216DF58h */ case    7:  		/* bl -39720 */
		/* 8216DF58h case    7:*/		regs.LR = 0x8216DF5C; return 0x82164430;
		/* 8216DF58h case    7:*/		return 0x8216DF5C;
		  /* 8216DF5Ch */ case    8:  		/* addi R11, R30, -16 */
		/* 8216DF5Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF0);
		/* 8216DF5Ch case    8:*/		return 0x8216DF60;
		  /* 8216DF60h */ case    9:  		/* ori R10, R31, 1 */
		/* 8216DF60h case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R31,0x1);
		/* 8216DF60h case    9:*/		return 0x8216DF64;
		  /* 8216DF64h */ case   10:  		/* stwx R10, <#[R3 + R11]> */
		/* 8216DF64h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 8216DF64h case   10:*/		return 0x8216DF68;
		  /* 8216DF68h */ case   11:  		/* b 412 */
		/* 8216DF68h case   11:*/		return 0x8216E104;
		/* 8216DF68h case   11:*/		return 0x8216DF6C;
	}
	return 0x8216DF6C;
} // Block from 8216DF3Ch-8216DF6Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216DF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DF6C);
		  /* 8216DF6Ch */ case    0:  		/* ori R11, R31, 1 */
		/* 8216DF6Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R31,0x1);
		/* 8216DF6Ch case    0:*/		return 0x8216DF70;
	}
	return 0x8216DF70;
} // Block from 8216DF6Ch-8216DF70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216DF70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DF70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DF70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DF70);
		  /* 8216DF70h */ case    0:  		/* stw R11, <#[R30]> */
		/* 8216DF70h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216DF70h case    0:*/		return 0x8216DF74;
		  /* 8216DF74h */ case    1:  		/* b 400 */
		/* 8216DF74h case    1:*/		return 0x8216E104;
		/* 8216DF74h case    1:*/		return 0x8216DF78;
	}
	return 0x8216DF78;
} // Block from 8216DF70h-8216DF78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216DF78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DF78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DF78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DF78);
		  /* 8216DF78h */ case    0:  		/* cmplwi CR6, R10, 83 */
		/* 8216DF78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000053);
		/* 8216DF78h case    0:*/		return 0x8216DF7C;
		  /* 8216DF7Ch */ case    1:  		/* bc 4, CR6_EQ, 392 */
		/* 8216DF7Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216E104;  }
		/* 8216DF7Ch case    1:*/		return 0x8216DF80;
		  /* 8216DF80h */ case    2:  		/* lwz R11, <#[R26 + 76]> */
		/* 8216DF80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 8216DF80h case    2:*/		return 0x8216DF84;
		  /* 8216DF84h */ case    3:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8216DF84h case    3:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8216DF84h case    3:*/		return 0x8216DF88;
		  /* 8216DF88h */ case    4:  		/* bc 12, CR0_EQ, 332 */
		/* 8216DF88h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216E0D4;  }
		/* 8216DF88h case    4:*/		return 0x8216DF8C;
		  /* 8216DF8Ch */ case    5:  		/* lwz R11, <#[R26 + 112]> */
		/* 8216DF8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 8216DF8Ch case    5:*/		return 0x8216DF90;
		  /* 8216DF90h */ case    6:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216DF90h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216DF90h case    6:*/		return 0x8216DF94;
		  /* 8216DF94h */ case    7:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 8216DF94h case    7:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 8216DF94h case    7:*/		return 0x8216DF98;
		  /* 8216DF98h */ case    8:  		/* bc 12, CR0_EQ, 48 */
		/* 8216DF98h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216DFC8;  }
		/* 8216DF98h case    8:*/		return 0x8216DF9C;
		  /* 8216DF9Ch */ case    9:  		/* b 16 */
		/* 8216DF9Ch case    9:*/		return 0x8216DFAC;
		/* 8216DF9Ch case    9:*/		return 0x8216DFA0;
		  /* 8216DFA0h */ case   10:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216DFA0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216DFA0h case   10:*/		return 0x8216DFA4;
		  /* 8216DFA4h */ case   11:  		/* rlwinm. R10, R10, 0, 9, 9 */
		/* 8216DFA4h case   11:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R10,regs.R10);
		/* 8216DFA4h case   11:*/		return 0x8216DFA8;
	}
	return 0x8216DFA8;
} // Block from 8216DF78h-8216DFA8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216DFA8h
// Function '?MarkAllocColorsExclusion@Compiler@D3DXShader@@AAAXPAVBlock@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DFA8);
		  /* 8216DFA8h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 8216DFA8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8216DFB8;  }
		/* 8216DFA8h case    0:*/		return 0x8216DFAC;
	}
	return 0x8216DFAC;
} // Block from 8216DFA8h-8216DFACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216DFACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DFAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DFAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DFAC);
		  /* 8216DFACh */ case    0:  		/* lwz R11, <#[R11 + 80]> */
		/* 8216DFACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8216DFACh case    0:*/		return 0x8216DFB0;
		  /* 8216DFB0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216DFB0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DFB0h case    1:*/		return 0x8216DFB4;
		  /* 8216DFB4h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 8216DFB4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216DFA0;  }
		/* 8216DFB4h case    2:*/		return 0x8216DFB8;
	}
	return 0x8216DFB8;
} // Block from 8216DFACh-8216DFB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216DFB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DFB8);
		  /* 8216DFB8h */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216DFB8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216DFB8h case    0:*/		return 0x8216DFBC;
		  /* 8216DFBCh */ case    1:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 8216DFBCh case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 8216DFBCh case    1:*/		return 0x8216DFC0;
		  /* 8216DFC0h */ case    2:  		/* bc 4, CR0_EQ, -20 */
		/* 8216DFC0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216DFAC;  }
		/* 8216DFC0h case    2:*/		return 0x8216DFC4;
		  /* 8216DFC4h */ case    3:  		/* stw R11, <#[R26 + 112]> */
		/* 8216DFC4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 8216DFC4h case    3:*/		return 0x8216DFC8;
	}
	return 0x8216DFC8;
} // Block from 8216DFB8h-8216DFC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216DFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DFC8);
		  /* 8216DFC8h */ case    0:  		/* lwz R11, <#[R26 + 112]> */
		/* 8216DFC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 8216DFC8h case    0:*/		return 0x8216DFCC;
		  /* 8216DFCCh */ case    1:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216DFCCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216DFCCh case    1:*/		return 0x8216DFD0;
		  /* 8216DFD0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8216DFD0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DFD0h case    2:*/		return 0x8216DFD4;
		  /* 8216DFD4h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 8216DFD4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216DFE8;  }
		/* 8216DFD4h case    3:*/		return 0x8216DFD8;
		  /* 8216DFD8h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216DFD8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216DFD8h case    4:*/		return 0x8216DFDC;
		  /* 8216DFDCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216DFDCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216DFDCh case    5:*/		return 0x8216DFE0;
		  /* 8216DFE0h */ case    6:  		/* mr R11, R20 */
		/* 8216DFE0h case    6:*/		regs.R11 = regs.R20;
		/* 8216DFE0h case    6:*/		return 0x8216DFE4;
		  /* 8216DFE4h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 8216DFE4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8216DFEC;  }
		/* 8216DFE4h case    7:*/		return 0x8216DFE8;
	}
	return 0x8216DFE8;
} // Block from 8216DFC8h-8216DFE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216DFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DFE8);
		  /* 8216DFE8h */ case    0:  		/* mr R11, R21 */
		/* 8216DFE8h case    0:*/		regs.R11 = regs.R21;
		/* 8216DFE8h case    0:*/		return 0x8216DFEC;
	}
	return 0x8216DFEC;
} // Block from 8216DFE8h-8216DFECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216DFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216DFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216DFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216DFEC);
		  /* 8216DFECh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216DFECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216DFECh case    0:*/		return 0x8216DFF0;
		  /* 8216DFF0h */ case    1:  		/* bc 12, CR0_EQ, 228 */
		/* 8216DFF0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216E0D4;  }
		/* 8216DFF0h case    1:*/		return 0x8216DFF4;
		  /* 8216DFF4h */ case    2:  		/* lwz R11, <#[R29]> */
		/* 8216DFF4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216DFF4h case    2:*/		return 0x8216DFF8;
		  /* 8216DFF8h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8216DFF8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216DFF8h case    3:*/		return 0x8216DFFC;
		  /* 8216DFFCh */ case    4:  		/* bc 12, CR6_EQ, 192 */
		/* 8216DFFCh case    4:*/		if ( regs.CR[6].eq ) { return 0x8216E0BC;  }
		/* 8216DFFCh case    4:*/		return 0x8216E000;
		  /* 8216E000h */ case    5:  		/* li R8, 0 */
		/* 8216E000h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216E000h case    5:*/		return 0x8216E004;
		  /* 8216E004h */ case    6:  		/* lwz R4, <#[R29 + 28]> */
		/* 8216E004h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000001C) );
		/* 8216E004h case    6:*/		return 0x8216E008;
		  /* 8216E008h */ case    7:  		/* li R7, 0 */
		/* 8216E008h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216E008h case    7:*/		return 0x8216E00C;
		  /* 8216E00Ch */ case    8:  		/* li R6, 117 */
		/* 8216E00Ch case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 8216E00Ch case    8:*/		return 0x8216E010;
		  /* 8216E010h */ case    9:  		/* li R5, 0 */
		/* 8216E010h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216E010h case    9:*/		return 0x8216E014;
		  /* 8216E014h */ case   10:  		/* mr R3, R24 */
		/* 8216E014h case   10:*/		regs.R3 = regs.R24;
		/* 8216E014h case   10:*/		return 0x8216E018;
		  /* 8216E018h */ case   11:  		/* bl 747904 */
		/* 8216E018h case   11:*/		regs.LR = 0x8216E01C; return 0x82224998;
		/* 8216E018h case   11:*/		return 0x8216E01C;
		  /* 8216E01Ch */ case   12:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 8216E01Ch case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 8216E01Ch case   12:*/		return 0x8216E020;
		  /* 8216E020h */ case   13:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 8216E020h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 8216E020h case   13:*/		return 0x8216E024;
		  /* 8216E024h */ case   14:  		/* addi R11, R11, 36 */
		/* 8216E024h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8216E024h case   14:*/		return 0x8216E028;
		  /* 8216E028h */ case   15:  		/* addi R10, R10, 36 */
		/* 8216E028h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 8216E028h case   15:*/		return 0x8216E02C;
		  /* 8216E02Ch */ case   16:  		/* addi R7, R11, -36 */
		/* 8216E02Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8216E02Ch case   16:*/		return 0x8216E030;
		  /* 8216E030h */ case   17:  		/* addi R5, R10, -36 */
		/* 8216E030h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFFFDC);
		/* 8216E030h case   17:*/		return 0x8216E034;
		  /* 8216E034h */ case   18:  		/* addi R9, R10, 4 */
		/* 8216E034h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8216E034h case   18:*/		return 0x8216E038;
		  /* 8216E038h */ case   19:  		/* lwz R6, <#[R11]> */
		/* 8216E038h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216E038h case   19:*/		return 0x8216E03C;
		  /* 8216E03Ch */ case   20:  		/* mr R8, R29 */
		/* 8216E03Ch case   20:*/		regs.R8 = regs.R29;
		/* 8216E03Ch case   20:*/		return 0x8216E040;
		  /* 8216E040h */ case   21:  		/* stw R6, <#[R10]> */
		/* 8216E040h case   21:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8216E040h case   21:*/		return 0x8216E044;
		  /* 8216E044h */ case   22:  		/* lwz R6, <#[R11]> */
		/* 8216E044h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8216E044h case   22:*/		return 0x8216E048;
		  /* 8216E048h */ case   23:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8216E048h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8216E048h case   23:*/		return 0x8216E04C;
		  /* 8216E04Ch */ case   24:  		/* stw R5, <#[R6]> */
		/* 8216E04Ch case   24:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x00000000) );
		/* 8216E04Ch case   24:*/		return 0x8216E050;
		  /* 8216E050h */ case   25:  		/* stw R7, <#[R10 + 4]> */
		/* 8216E050h case   25:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8216E050h case   25:*/		return 0x8216E054;
		  /* 8216E054h */ case   26:  		/* stw R9, <#[R11]> */
		/* 8216E054h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216E054h case   26:*/		return 0x8216E058;
		  /* 8216E058h */ case   27:  		/* lwz R11, <#[R3 + 8]> */
		/* 8216E058h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216E058h case   27:*/		return 0x8216E05C;
		  /* 8216E05Ch */ case   28:  		/* oris R11, R11, 768 */
		/* 8216E05Ch case   28:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x300);
		/* 8216E05Ch case   28:*/		return 0x8216E060;
		  /* 8216E060h */ case   29:  		/* stw R11, <#[R3 + 8]> */
		/* 8216E060h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216E060h case   29:*/		return 0x8216E064;
		  /* 8216E064h */ case   30:  		/* lwz R11, <#[R8]> */
		/* 8216E064h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8216E064h case   30:*/		return 0x8216E068;
		  /* 8216E068h */ case   31:  		/* cmplwi CR6, R11, 0 */
		/* 8216E068h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E068h case   31:*/		return 0x8216E06C;
		  /* 8216E06Ch */ case   32:  		/* bc 12, CR6_EQ, 80 */
		/* 8216E06Ch case   32:*/		if ( regs.CR[6].eq ) { return 0x8216E0BC;  }
		/* 8216E06Ch case   32:*/		return 0x8216E070;
		  /* 8216E070h */ case   33:  		/* lwz R9, <#[R11 + 16]> */
		/* 8216E070h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8216E070h case   33:*/		return 0x8216E074;
		  /* 8216E074h */ case   34:  		/* lwz R10, <#[R9]> */
		/* 8216E074h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8216E074h case   34:*/		return 0x8216E078;
		  /* 8216E078h */ case   35:  		/* b 12 */
		/* 8216E078h case   35:*/		return 0x8216E084;
		/* 8216E078h case   35:*/		return 0x8216E07C;
		  /* 8216E07Ch */ case   36:  		/* addi R9, R10, 4 */
		/* 8216E07Ch case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8216E07Ch case   36:*/		return 0x8216E080;
		  /* 8216E080h */ case   37:  		/* lwz R10, <#[R10 + 4]> */
		/* 8216E080h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8216E080h case   37:*/		return 0x8216E084;
	}
	return 0x8216E084;
} // Block from 8216DFECh-8216E084h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8216E084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E084);
		  /* 8216E084h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 8216E084h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216E084h case    0:*/		return 0x8216E088;
		  /* 8216E088h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8216E088h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216E07C;  }
		/* 8216E088h case    1:*/		return 0x8216E08C;
		  /* 8216E08Ch */ case    2:  		/* lwz R7, <#[R11 + 4]> */
		/* 8216E08Ch case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E08Ch case    2:*/		return 0x8216E090;
		  /* 8216E090h */ case    3:  		/* addi R10, R11, 4 */
		/* 8216E090h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8216E090h case    3:*/		return 0x8216E094;
		  /* 8216E094h */ case    4:  		/* stw R7, <#[R9]> */
		/* 8216E094h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8216E094h case    4:*/		return 0x8216E098;
		  /* 8216E098h */ case    5:  		/* lwz R9, <#[R3]> */
		/* 8216E098h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8216E098h case    5:*/		return 0x8216E09C;
		  /* 8216E09Ch */ case    6:  		/* stw R9, <#[R11 + 4]> */
		/* 8216E09Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E09Ch case    6:*/		return 0x8216E0A0;
		  /* 8216E0A0h */ case    7:  		/* stw R11, <#[R3]> */
		/* 8216E0A0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8216E0A0h case    7:*/		return 0x8216E0A4;
		  /* 8216E0A4h */ case    8:  		/* stw R3, <#[R11 + 16]> */
		/* 8216E0A4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000010) );
		/* 8216E0A4h case    8:*/		return 0x8216E0A8;
		  /* 8216E0A8h */ case    9:  		/* lwz R9, <#[R8]> */
		/* 8216E0A8h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8216E0A8h case    9:*/		return 0x8216E0AC;
		  /* 8216E0ACh */ case   10:  		/* cmplw CR6, R9, R11 */
		/* 8216E0ACh case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8216E0ACh case   10:*/		return 0x8216E0B0;
		  /* 8216E0B0h */ case   11:  		/* bc 4, CR6_EQ, -76 */
		/* 8216E0B0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8216E064;  }
		/* 8216E0B0h case   11:*/		return 0x8216E0B4;
		  /* 8216E0B4h */ case   12:  		/* mr R8, R10 */
		/* 8216E0B4h case   12:*/		regs.R8 = regs.R10;
		/* 8216E0B4h case   12:*/		return 0x8216E0B8;
		  /* 8216E0B8h */ case   13:  		/* b -84 */
		/* 8216E0B8h case   13:*/		return 0x8216E064;
		/* 8216E0B8h case   13:*/		return 0x8216E0BC;
	}
	return 0x8216E0BC;
} // Block from 8216E084h-8216E0BCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216E0BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E0BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E0BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E0BC);
		  /* 8216E0BCh */ case    0:  		/* mr R4, R29 */
		/* 8216E0BCh case    0:*/		regs.R4 = regs.R29;
		/* 8216E0BCh case    0:*/		return 0x8216E0C0;
	}
	return 0x8216E0C0;
} // Block from 8216E0BCh-8216E0C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E0C0);
		  /* 8216E0C0h */ case    0:  		/* li R5, 0 */
		/* 8216E0C0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216E0C0h case    0:*/		return 0x8216E0C4;
		  /* 8216E0C4h */ case    1:  		/* li R6, 1 */
		/* 8216E0C4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216E0C4h case    1:*/		return 0x8216E0C8;
		  /* 8216E0C8h */ case    2:  		/* mr R3, R24 */
		/* 8216E0C8h case    2:*/		regs.R3 = regs.R24;
		/* 8216E0C8h case    2:*/		return 0x8216E0CC;
		  /* 8216E0CCh */ case    3:  		/* bl 774908 */
		/* 8216E0CCh case    3:*/		regs.LR = 0x8216E0D0; return 0x8222B3C8;
		/* 8216E0CCh case    3:*/		return 0x8216E0D0;
		  /* 8216E0D0h */ case    4:  		/* b 52 */
		/* 8216E0D0h case    4:*/		return 0x8216E104;
		/* 8216E0D0h case    4:*/		return 0x8216E0D4;
	}
	return 0x8216E0D4;
} // Block from 8216E0C0h-8216E0D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216E0D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E0D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E0D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E0D4);
		  /* 8216E0D4h */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 8216E0D4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 8216E0D4h case    0:*/		return 0x8216E0D8;
		  /* 8216E0D8h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216E0D8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E0D8h case    1:*/		return 0x8216E0DC;
		  /* 8216E0DCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E0DCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E0DCh case    2:*/		return 0x8216E0E0;
		  /* 8216E0E0h */ case    3:  		/* bc 4, CR0_EQ, 36 */
		/* 8216E0E0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E104;  }
		/* 8216E0E0h case    3:*/		return 0x8216E0E4;
		  /* 8216E0E4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8216E0E4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E0E4h case    4:*/		return 0x8216E0E8;
		  /* 8216E0E8h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 8216E0E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216E104;  }
		/* 8216E0E8h case    5:*/		return 0x8216E0EC;
	}
	return 0x8216E0EC;
} // Block from 8216E0D4h-8216E0ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216E0ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E0EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E0EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E0EC);
		  /* 8216E0ECh */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216E0ECh case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E0ECh case    0:*/		return 0x8216E0F0;
		  /* 8216E0F0h */ case    1:  		/* mr R3, R24 */
		/* 8216E0F0h case    1:*/		regs.R3 = regs.R24;
		/* 8216E0F0h case    1:*/		return 0x8216E0F4;
		  /* 8216E0F4h */ case    2:  		/* addic R10, R10, -1 */
		/* 8216E0F4h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216E0F4h case    2:*/		return 0x8216E0F8;
		  /* 8216E0F8h */ case    3:  		/* subfe R10, R10, R10 */
		/* 8216E0F8h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216E0F8h case    3:*/		return 0x8216E0FC;
		  /* 8216E0FCh */ case    4:  		/* and R4, R10, R11 */
		/* 8216E0FCh case    4:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8216E0FCh case    4:*/		return 0x8216E100;
		  /* 8216E100h */ case    5:  		/* bl -3560 */
		/* 8216E100h case    5:*/		regs.LR = 0x8216E104; return 0x8216D318;
		/* 8216E100h case    5:*/		return 0x8216E104;
	}
	return 0x8216E104;
} // Block from 8216E0ECh-8216E104h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216E104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E104);
		  /* 8216E104h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 8216E104h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216E104h case    0:*/		return 0x8216E108;
		  /* 8216E108h */ case    1:  		/* addi R29, R26, 12 */
		/* 8216E108h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R26,0xC);
		/* 8216E108h case    1:*/		return 0x8216E10C;
		  /* 8216E10Ch */ case    2:  		/* mr R28, R21 */
		/* 8216E10Ch case    2:*/		regs.R28 = regs.R21;
		/* 8216E10Ch case    2:*/		return 0x8216E110;
		  /* 8216E110h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8216E110h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E110h case    3:*/		return 0x8216E114;
		  /* 8216E114h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 8216E114h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216E130;  }
		/* 8216E114h case    4:*/		return 0x8216E118;
		  /* 8216E118h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 8216E118h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216E118h case    5:*/		return 0x8216E11C;
		  /* 8216E11Ch */ case    6:  		/* cmplw CR6, R10, R27 */
		/* 8216E11Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R27);
		/* 8216E11Ch case    6:*/		return 0x8216E120;
		  /* 8216E120h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 8216E120h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216E128;  }
		/* 8216E120h case    7:*/		return 0x8216E124;
		  /* 8216E124h */ case    8:  		/* mr R28, R10 */
		/* 8216E124h case    8:*/		regs.R28 = regs.R10;
		/* 8216E124h case    8:*/		return 0x8216E128;
	}
	return 0x8216E128;
} // Block from 8216E104h-8216E128h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216E128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E128);
		  /* 8216E128h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216E128h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216E128h case    0:*/		return 0x8216E12C;
		  /* 8216E12Ch */ case    1:  		/* b -28 */
		/* 8216E12Ch case    1:*/		return 0x8216E110;
		/* 8216E12Ch case    1:*/		return 0x8216E130;
	}
	return 0x8216E130;
} // Block from 8216E128h-8216E130h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E130);
		  /* 8216E130h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8216E130h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8216E130h case    0:*/		return 0x8216E134;
		  /* 8216E134h */ case    1:  		/* bc 12, CR6_EQ, 304 */
		/* 8216E134h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216E264;  }
		/* 8216E134h case    1:*/		return 0x8216E138;
		  /* 8216E138h */ case    2:  		/* rlwinm R31, R26, 0, 0, 30 */
		/* 8216E138h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R31,regs.R26);
		/* 8216E138h case    2:*/		return 0x8216E13C;
		  /* 8216E13Ch */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 8216E13Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8216E13Ch case    3:*/		return 0x8216E140;
		  /* 8216E140h */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216E140h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E140h case    4:*/		return 0x8216E144;
		  /* 8216E144h */ case    5:  		/* addic R10, R10, -1 */
		/* 8216E144h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216E144h case    5:*/		return 0x8216E148;
		  /* 8216E148h */ case    6:  		/* subfe R10, R10, R10 */
		/* 8216E148h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216E148h case    6:*/		return 0x8216E14C;
		  /* 8216E14Ch */ case    7:  		/* and R10, R10, R11 */
		/* 8216E14Ch case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8216E14Ch case    7:*/		return 0x8216E150;
		  /* 8216E150h */ case    8:  		/* cmplw CR6, R28, R10 */
		/* 8216E150h case    8:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 8216E150h case    8:*/		return 0x8216E154;
		  /* 8216E154h */ case    9:  		/* bc 12, CR6_EQ, 272 */
		/* 8216E154h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216E264;  }
		/* 8216E154h case    9:*/		return 0x8216E158;
		  /* 8216E158h */ case   10:  		/* lwz R10, <#[R26 + 48]> */
		/* 8216E158h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000030) );
		/* 8216E158h case   10:*/		return 0x8216E15C;
		  /* 8216E15Ch */ case   11:  		/* rlwinm. R9, R10, 5, 31, 31 */
		/* 8216E15Ch case   11:*/		cpu::op::rlwinm<1,5,31,31>(regs,&regs.R9,regs.R10);
		/* 8216E15Ch case   11:*/		return 0x8216E160;
		  /* 8216E160h */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 8216E160h case   12:*/		if ( regs.CR[0].eq ) { return 0x8216E180;  }
		/* 8216E160h case   12:*/		return 0x8216E164;
		  /* 8216E164h */ case   13:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 8216E164h case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8216E164h case   13:*/		return 0x8216E168;
		  /* 8216E168h */ case   14:  		/* addic R9, R9, -1 */
		/* 8216E168h case   14:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8216E168h case   14:*/		return 0x8216E16C;
		  /* 8216E16Ch */ case   15:  		/* subfe R9, R9, R9 */
		/* 8216E16Ch case   15:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8216E16Ch case   15:*/		return 0x8216E170;
		  /* 8216E170h */ case   16:  		/* and R11, R9, R11 */
		/* 8216E170h case   16:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8216E170h case   16:*/		return 0x8216E174;
		  /* 8216E174h */ case   17:  		/* lwz R11, <#[R11 + 48]> */
		/* 8216E174h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8216E174h case   17:*/		return 0x8216E178;
		  /* 8216E178h */ case   18:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8216E178h case   18:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E178h case   18:*/		return 0x8216E17C;
		  /* 8216E17Ch */ case   19:  		/* bc 4, CR0_EQ, 232 */
		/* 8216E17Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x8216E264;  }
		/* 8216E17Ch case   19:*/		return 0x8216E180;
	}
	return 0x8216E180;
} // Block from 8216E130h-8216E180h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216E180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E180);
		  /* 8216E180h */ case    0:  		/* rlwinm. R11, R10, 9, 31, 31 */
		/* 8216E180h case    0:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R10);
		/* 8216E180h case    0:*/		return 0x8216E184;
		  /* 8216E184h */ case    1:  		/* mr R30, R26 */
		/* 8216E184h case    1:*/		regs.R30 = regs.R26;
		/* 8216E184h case    1:*/		return 0x8216E188;
	}
	return 0x8216E188;
} // Block from 8216E180h-8216E188h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E188h
// Function '?OptimizeSQInstructions@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E188);
		  /* 8216E188h */ case    0:  		/* bc 12, CR0_EQ, 136 */
		/* 8216E188h case    0:*/		if ( regs.CR[0].eq ) { return 0x8216E210;  }
		/* 8216E188h case    0:*/		return 0x8216E18C;
		  /* 8216E18Ch */ case    1:  		/* mr R3, R24 */
		/* 8216E18Ch case    1:*/		regs.R3 = regs.R24;
		/* 8216E18Ch case    1:*/		return 0x8216E190;
		  /* 8216E190h */ case    2:  		/* bl -4696 */
		/* 8216E190h case    2:*/		regs.LR = 0x8216E194; return 0x8216CF38;
		/* 8216E190h case    2:*/		return 0x8216E194;
		  /* 8216E194h */ case    3:  		/* lwz R8, <#[R31 + 4]> */
		/* 8216E194h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8216E194h case    3:*/		return 0x8216E198;
		  /* 8216E198h */ case    4:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8216E198h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8216E198h case    4:*/		return 0x8216E19C;
		  /* 8216E19Ch */ case    5:  		/* addi R10, R31, 4 */
		/* 8216E19Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x4);
		/* 8216E19Ch case    5:*/		return 0x8216E1A0;
		  /* 8216E1A0h */ case    6:  		/* addi R9, R11, 4 */
		/* 8216E1A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8216E1A0h case    6:*/		return 0x8216E1A4;
		  /* 8216E1A4h */ case    7:  		/* mr R30, R3 */
		/* 8216E1A4h case    7:*/		regs.R30 = regs.R3;
		/* 8216E1A4h case    7:*/		return 0x8216E1A8;
		  /* 8216E1A8h */ case    8:  		/* stw R8, <#[R11 + 4]> */
		/* 8216E1A8h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E1A8h case    8:*/		return 0x8216E1AC;
		  /* 8216E1ACh */ case    9:  		/* lwz R8, <#[R31 + 4]> */
		/* 8216E1ACh case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8216E1ACh case    9:*/		return 0x8216E1B0;
		  /* 8216E1B0h */ case   10:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 8216E1B0h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 8216E1B0h case   10:*/		return 0x8216E1B4;
		  /* 8216E1B4h */ case   11:  		/* stw R9, <#[R8]> */
		/* 8216E1B4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8216E1B4h case   11:*/		return 0x8216E1B8;
		  /* 8216E1B8h */ case   12:  		/* stw R10, <#[R11]> */
		/* 8216E1B8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216E1B8h case   12:*/		return 0x8216E1BC;
		  /* 8216E1BCh */ case   13:  		/* stw R11, <#[R31 + 4]> */
		/* 8216E1BCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8216E1BCh case   13:*/		return 0x8216E1C0;
		  /* 8216E1C0h */ case   14:  		/* lwz R31, <#[R29]> */
		/* 8216E1C0h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 8216E1C0h case   14:*/		return 0x8216E1C4;
		  /* 8216E1C4h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 8216E1C4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E1C4h case   15:*/		return 0x8216E1C8;
		  /* 8216E1C8h */ case   16:  		/* bc 12, CR6_EQ, 52 */
		/* 8216E1C8h case   16:*/		if ( regs.CR[6].eq ) { return 0x8216E1FC;  }
		/* 8216E1C8h case   16:*/		return 0x8216E1CC;
		  /* 8216E1CCh */ case   17:  		/* lwz R11, <#[R31]> */
		/* 8216E1CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216E1CCh case   17:*/		return 0x8216E1D0;
		  /* 8216E1D0h */ case   18:  		/* cmplw CR6, R11, R28 */
		/* 8216E1D0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8216E1D0h case   18:*/		return 0x8216E1D4;
		  /* 8216E1D4h */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 8216E1D4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8216E1E8;  }
		/* 8216E1D4h case   19:*/		return 0x8216E1D8;
		  /* 8216E1D8h */ case   20:  		/* mr R5, R30 */
		/* 8216E1D8h case   20:*/		regs.R5 = regs.R30;
		/* 8216E1D8h case   20:*/		return 0x8216E1DC;
		  /* 8216E1DCh */ case   21:  		/* mr R4, R31 */
		/* 8216E1DCh case   21:*/		regs.R4 = regs.R31;
		/* 8216E1DCh case   21:*/		return 0x8216E1E0;
		  /* 8216E1E0h */ case   22:  		/* mr R3, R26 */
		/* 8216E1E0h case   22:*/		regs.R3 = regs.R26;
		/* 8216E1E0h case   22:*/		return 0x8216E1E4;
		  /* 8216E1E4h */ case   23:  		/* bl 792388 */
		/* 8216E1E4h case   23:*/		regs.LR = 0x8216E1E8; return 0x8222F928;
		/* 8216E1E4h case   23:*/		return 0x8216E1E8;
	}
	return 0x8216E1E8;
} // Block from 8216E188h-8216E1E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8216E1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E1E8);
		  /* 8216E1E8h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8216E1E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216E1E8h case    0:*/		return 0x8216E1EC;
		  /* 8216E1ECh */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 8216E1ECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8216E1ECh case    1:*/		return 0x8216E1F0;
		  /* 8216E1F0h */ case    2:  		/* bc 4, CR6_EQ, -48 */
		/* 8216E1F0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216E1C0;  }
		/* 8216E1F0h case    2:*/		return 0x8216E1F4;
		  /* 8216E1F4h */ case    3:  		/* addi R29, R31, 8 */
		/* 8216E1F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8);
		/* 8216E1F4h case    3:*/		return 0x8216E1F8;
		  /* 8216E1F8h */ case    4:  		/* b -56 */
		/* 8216E1F8h case    4:*/		return 0x8216E1C0;
		/* 8216E1F8h case    4:*/		return 0x8216E1FC;
	}
	return 0x8216E1FC;
} // Block from 8216E1E8h-8216E1FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216E1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E1FC);
		  /* 8216E1FCh */ case    0:  		/* mr R5, R24 */
		/* 8216E1FCh case    0:*/		regs.R5 = regs.R24;
		/* 8216E1FCh case    0:*/		return 0x8216E200;
		  /* 8216E200h */ case    1:  		/* mr R4, R28 */
		/* 8216E200h case    1:*/		regs.R4 = regs.R28;
		/* 8216E200h case    1:*/		return 0x8216E204;
		  /* 8216E204h */ case    2:  		/* mr R3, R30 */
		/* 8216E204h case    2:*/		regs.R3 = regs.R30;
		/* 8216E204h case    2:*/		return 0x8216E208;
		  /* 8216E208h */ case    3:  		/* bl 792792 */
		/* 8216E208h case    3:*/		regs.LR = 0x8216E20C; return 0x8222FAE0;
		/* 8216E208h case    3:*/		return 0x8216E20C;
		  /* 8216E20Ch */ case    4:  		/* mr R22, R20 */
		/* 8216E20Ch case    4:*/		regs.R22 = regs.R20;
		/* 8216E20Ch case    4:*/		return 0x8216E210;
	}
	return 0x8216E210;
} // Block from 8216E1FCh-8216E210h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216E210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E210);
		  /* 8216E210h */ case    0:  		/* li R8, 0 */
		/* 8216E210h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216E210h case    0:*/		return 0x8216E214;
		  /* 8216E214h */ case    1:  		/* li R7, 0 */
		/* 8216E214h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216E214h case    1:*/		return 0x8216E218;
		  /* 8216E218h */ case    2:  		/* li R6, 89 */
		/* 8216E218h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x59);
		/* 8216E218h case    2:*/		return 0x8216E21C;
		  /* 8216E21Ch */ case    3:  		/* addi R5, R30, 24 */
		/* 8216E21Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0x18);
		/* 8216E21Ch case    3:*/		return 0x8216E220;
		  /* 8216E220h */ case    4:  		/* mr R4, R30 */
		/* 8216E220h case    4:*/		regs.R4 = regs.R30;
		/* 8216E220h case    4:*/		return 0x8216E224;
		  /* 8216E224h */ case    5:  		/* mr R3, R24 */
		/* 8216E224h case    5:*/		regs.R3 = regs.R24;
		/* 8216E224h case    5:*/		return 0x8216E228;
		  /* 8216E228h */ case    6:  		/* bl 747376 */
		/* 8216E228h case    6:*/		regs.LR = 0x8216E22C; return 0x82224998;
		/* 8216E228h case    6:*/		return 0x8216E22C;
		  /* 8216E22Ch */ case    7:  		/* mr R31, R3 */
		/* 8216E22Ch case    7:*/		regs.R31 = regs.R3;
		/* 8216E22Ch case    7:*/		return 0x8216E230;
		  /* 8216E230h */ case    8:  		/* mr R3, R24 */
		/* 8216E230h case    8:*/		regs.R3 = regs.R24;
		/* 8216E230h case    8:*/		return 0x8216E234;
		  /* 8216E234h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216E234h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216E234h case    9:*/		return 0x8216E238;
		  /* 8216E238h */ case   10:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216E238h case   10:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216E238h case   10:*/		return 0x8216E23C;
		  /* 8216E23Ch */ case   11:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8216E23Ch case   11:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8216E23Ch case   11:*/		return 0x8216E240;
		  /* 8216E240h */ case   12:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216E240h case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216E240h case   12:*/		return 0x8216E244;
		  /* 8216E244h */ case   13:  		/* bl -40468 */
		/* 8216E244h case   13:*/		regs.LR = 0x8216E248; return 0x82164430;
		/* 8216E244h case   13:*/		return 0x8216E248;
		  /* 8216E248h */ case   14:  		/* addi R11, R31, -16 */
		/* 8216E248h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8216E248h case   14:*/		return 0x8216E24C;
		  /* 8216E24Ch */ case   15:  		/* mr R4, R28 */
		/* 8216E24Ch case   15:*/		regs.R4 = regs.R28;
		/* 8216E24Ch case   15:*/		return 0x8216E250;
		  /* 8216E250h */ case   16:  		/* add R31, R3, R11 */
		/* 8216E250h case   16:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R11);
		/* 8216E250h case   16:*/		return 0x8216E254;
		  /* 8216E254h */ case   17:  		/* mr R3, R24 */
		/* 8216E254h case   17:*/		regs.R3 = regs.R24;
		/* 8216E254h case   17:*/		return 0x8216E258;
		  /* 8216E258h */ case   18:  		/* bl -3904 */
		/* 8216E258h case   18:*/		regs.LR = 0x8216E25C; return 0x8216D318;
		/* 8216E258h case   18:*/		return 0x8216E25C;
		  /* 8216E25Ch */ case   19:  		/* ori R11, R3, 1 */
		/* 8216E25Ch case   19:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8216E25Ch case   19:*/		return 0x8216E260;
		  /* 8216E260h */ case   20:  		/* stw R11, <#[R31]> */
		/* 8216E260h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216E260h case   20:*/		return 0x8216E264;
	}
	return 0x8216E264;
} // Block from 8216E210h-8216E264h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216E264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E264);
		  /* 8216E264h */ case    0:  		/* lbz R11, <#[R26 + 48]> */
		/* 8216E264h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 8216E264h case    0:*/		return 0x8216E268;
		  /* 8216E268h */ case    1:  		/* rlwinm R10, R23, 0, 24, 31 */
		/* 8216E268h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R23);
		/* 8216E268h case    1:*/		return 0x8216E26C;
		  /* 8216E26Ch */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 8216E26Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8216E26Ch case    2:*/		return 0x8216E270;
		  /* 8216E270h */ case    3:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8216E270h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E270h case    3:*/		return 0x8216E274;
		  /* 8216E274h */ case    4:  		/* or R23, R11, R10 */
		/* 8216E274h case    4:*/		cpu::op::or<0>(regs,&regs.R23,regs.R11,regs.R10);
		/* 8216E274h case    4:*/		return 0x8216E278;
		  /* 8216E278h */ case    5:  		/* bc 12, CR6_EQ, 204 */
		/* 8216E278h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216E344;  }
		/* 8216E278h case    5:*/		return 0x8216E27C;
		  /* 8216E27Ch */ case    6:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 8216E27Ch case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 8216E27Ch case    6:*/		return 0x8216E280;
		  /* 8216E280h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216E280h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E280h case    7:*/		return 0x8216E284;
		  /* 8216E284h */ case    8:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216E284h case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E284h case    8:*/		return 0x8216E288;
		  /* 8216E288h */ case    9:  		/* addic R10, R10, -1 */
		/* 8216E288h case    9:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216E288h case    9:*/		return 0x8216E28C;
		  /* 8216E28Ch */ case   10:  		/* subfe R10, R10, R10 */
		/* 8216E28Ch case   10:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216E28Ch case   10:*/		return 0x8216E290;
		  /* 8216E290h */ case   11:  		/* and R10, R10, R11 */
		/* 8216E290h case   11:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8216E290h case   11:*/		return 0x8216E294;
		  /* 8216E294h */ case   12:  		/* cmplw CR6, R26, R10 */
		/* 8216E294h case   12:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 8216E294h case   12:*/		return 0x8216E298;
		  /* 8216E298h */ case   13:  		/* bc 4, CR6_EQ, 16 */
		/* 8216E298h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8216E2A8;  }
		/* 8216E298h case   13:*/		return 0x8216E29C;
		  /* 8216E29Ch */ case   14:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 8216E29Ch case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 8216E29Ch case   14:*/		return 0x8216E2A0;
		  /* 8216E2A0h */ case   15:  		/* mr R25, R26 */
		/* 8216E2A0h case   15:*/		regs.R25 = regs.R26;
		/* 8216E2A0h case   15:*/		return 0x8216E2A4;
		  /* 8216E2A4h */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216E2A4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E2A4h case   16:*/		return 0x8216E2A8;
	}
	return 0x8216E2A8;
} // Block from 8216E264h-8216E2A8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216E2A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E2A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E2A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E2A8);
		  /* 8216E2A8h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E2A8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E2A8h case    0:*/		return 0x8216E2AC;
		  /* 8216E2ACh */ case    1:  		/* bc 12, CR0_EQ, 188 */
		/* 8216E2ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x8216E368;  }
		/* 8216E2ACh case    1:*/		return 0x8216E2B0;
	}
	return 0x8216E2B0;
} // Block from 8216E2A8h-8216E2B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E2B0);
		  /* 8216E2B0h */ case    0:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8216E2B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8216E2B0h case    0:*/		return 0x8216E2B4;
		  /* 8216E2B4h */ case    1:  		/* bc 12, CR0_EQ, 288 */
		/* 8216E2B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216E3D4;  }
		/* 8216E2B4h case    1:*/		return 0x8216E2B8;
		  /* 8216E2B8h */ case    2:  		/* lwz R30, <#[R24 + 4]> */
		/* 8216E2B8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E2B8h case    2:*/		return 0x8216E2BC;
		  /* 8216E2BCh */ case    3:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8216E2BCh case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8216E2BCh case    3:*/		return 0x8216E2C0;
		  /* 8216E2C0h */ case    4:  		/* bc 4, CR0_EQ, 276 */
		/* 8216E2C0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216E3D4;  }
		/* 8216E2C0h case    4:*/		return 0x8216E2C4;
		  /* 8216E2C4h */ case    5:  		/* cmplwi CR0, R30, 0 */
		/* 8216E2C4h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 8216E2C4h case    5:*/		return 0x8216E2C8;
		  /* 8216E2C8h */ case    6:  		/* bc 12, CR0_EQ, 268 */
		/* 8216E2C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216E3D4;  }
		/* 8216E2C8h case    6:*/		return 0x8216E2CC;
		  /* 8216E2CCh */ case    7:  		/* lbz R11, <#[R30 + 48]> */
		/* 8216E2CCh case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8216E2CCh case    7:*/		return 0x8216E2D0;
		  /* 8216E2D0h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216E2D0h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E2D0h case    8:*/		return 0x8216E2D4;
		  /* 8216E2D4h */ case    9:  		/* bc 12, CR0_EQ, 232 */
		/* 8216E2D4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216E3BC;  }
		/* 8216E2D4h case    9:*/		return 0x8216E2D8;
		  /* 8216E2D8h */ case   10:  		/* mr R4, R30 */
		/* 8216E2D8h case   10:*/		regs.R4 = regs.R30;
		/* 8216E2D8h case   10:*/		return 0x8216E2DC;
		  /* 8216E2DCh */ case   11:  		/* mr R3, R24 */
		/* 8216E2DCh case   11:*/		regs.R3 = regs.R24;
		/* 8216E2DCh case   11:*/		return 0x8216E2E0;
		  /* 8216E2E0h */ case   12:  		/* bl -4040 */
		/* 8216E2E0h case   12:*/		regs.LR = 0x8216E2E4; return 0x8216D318;
		/* 8216E2E0h case   12:*/		return 0x8216E2E4;
		  /* 8216E2E4h */ case   13:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8216E2E4h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8216E2E4h case   13:*/		return 0x8216E2E8;
		  /* 8216E2E8h */ case   14:  		/* lwz R31, <#[R11 + 4]> */
		/* 8216E2E8h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E2E8h case   14:*/		return 0x8216E2EC;
		  /* 8216E2ECh */ case   15:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216E2ECh case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216E2ECh case   15:*/		return 0x8216E2F0;
		  /* 8216E2F0h */ case   16:  		/* bc 4, CR0_EQ, 228 */
		/* 8216E2F0h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8216E3D4;  }
		/* 8216E2F0h case   16:*/		return 0x8216E2F4;
		  /* 8216E2F4h */ case   17:  		/* cmplwi CR6, R31, 0 */
		/* 8216E2F4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E2F4h case   17:*/		return 0x8216E2F8;
		  /* 8216E2F8h */ case   18:  		/* bc 12, CR6_EQ, 220 */
		/* 8216E2F8h case   18:*/		if ( regs.CR[6].eq ) { return 0x8216E3D4;  }
		/* 8216E2F8h case   18:*/		return 0x8216E2FC;
		  /* 8216E2FCh */ case   19:  		/* lbz R11, <#[R31 + 48]> */
		/* 8216E2FCh case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8216E2FCh case   19:*/		return 0x8216E300;
		  /* 8216E300h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216E300h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E300h case   20:*/		return 0x8216E304;
		  /* 8216E304h */ case   21:  		/* bc 12, CR0_EQ, 132 */
		/* 8216E304h case   21:*/		if ( regs.CR[0].eq ) { return 0x8216E388;  }
		/* 8216E304h case   21:*/		return 0x8216E308;
		  /* 8216E308h */ case   22:  		/* mr R4, R30 */
		/* 8216E308h case   22:*/		regs.R4 = regs.R30;
		/* 8216E308h case   22:*/		return 0x8216E30C;
		  /* 8216E30Ch */ case   23:  		/* mr R3, R31 */
		/* 8216E30Ch case   23:*/		regs.R3 = regs.R31;
		/* 8216E30Ch case   23:*/		return 0x8216E310;
		  /* 8216E310h */ case   24:  		/* bl -6392 */
		/* 8216E310h case   24:*/		regs.LR = 0x8216E314; return 0x8216CA18;
		/* 8216E310h case   24:*/		return 0x8216E314;
		  /* 8216E314h */ case   25:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216E314h case   25:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216E314h case   25:*/		return 0x8216E318;
		  /* 8216E318h */ case   26:  		/* bc 12, CR0_EQ, 112 */
		/* 8216E318h case   26:*/		if ( regs.CR[0].eq ) { return 0x8216E388;  }
		/* 8216E318h case   26:*/		return 0x8216E31C;
		  /* 8216E31Ch */ case   27:  		/* lwz R11, <#[R31 + 76]> */
		/* 8216E31Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8216E31Ch case   27:*/		return 0x8216E320;
		  /* 8216E320h */ case   28:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 8216E320h case   28:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 8216E320h case   28:*/		return 0x8216E324;
		  /* 8216E324h */ case   29:  		/* bc 4, CR0_EQ, 96 */
		/* 8216E324h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8216E384;  }
		/* 8216E324h case   29:*/		return 0x8216E328;
		  /* 8216E328h */ case   30:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216E328h case   30:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216E328h case   30:*/		return 0x8216E32C;
		  /* 8216E32Ch */ case   31:  		/* lwz R31, <#[R11 + 4]> */
		/* 8216E32Ch case   31:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E32Ch case   31:*/		return 0x8216E330;
		  /* 8216E330h */ case   32:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216E330h case   32:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216E330h case   32:*/		return 0x8216E334;
		  /* 8216E334h */ case   33:  		/* bc 4, CR0_EQ, 160 */
		/* 8216E334h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8216E3D4;  }
		/* 8216E334h case   33:*/		return 0x8216E338;
		  /* 8216E338h */ case   34:  		/* cmplwi CR6, R31, 0 */
		/* 8216E338h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E338h case   34:*/		return 0x8216E33C;
		  /* 8216E33Ch */ case   35:  		/* bc 4, CR6_EQ, -64 */
		/* 8216E33Ch case   35:*/		if ( !regs.CR[6].eq ) { return 0x8216E2FC;  }
		/* 8216E33Ch case   35:*/		return 0x8216E340;
		  /* 8216E340h */ case   36:  		/* b 72 */
		/* 8216E340h case   36:*/		return 0x8216E388;
		/* 8216E340h case   36:*/		return 0x8216E344;
	}
	return 0x8216E344;
} // Block from 8216E2B0h-8216E344h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8216E344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E344);
		  /* 8216E344h */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216E344h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E344h case    0:*/		return 0x8216E348;
		  /* 8216E348h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216E348h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E348h case    1:*/		return 0x8216E34C;
		  /* 8216E34Ch */ case    2:  		/* addic R9, R10, -1 */
		/* 8216E34Ch case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 8216E34Ch case    2:*/		return 0x8216E350;
		  /* 8216E350h */ case    3:  		/* subfe R9, R9, R9 */
		/* 8216E350h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8216E350h case    3:*/		return 0x8216E354;
		  /* 8216E354h */ case    4:  		/* and R9, R9, R11 */
		/* 8216E354h case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8216E354h case    4:*/		return 0x8216E358;
		  /* 8216E358h */ case    5:  		/* cmplw CR6, R26, R9 */
		/* 8216E358h case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R9);
		/* 8216E358h case    5:*/		return 0x8216E35C;
		  /* 8216E35Ch */ case    6:  		/* bc 12, CR6_EQ, -192 */
		/* 8216E35Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8216E29C;  }
		/* 8216E35Ch case    6:*/		return 0x8216E360;
		  /* 8216E360h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8216E360h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216E360h case    7:*/		return 0x8216E364;
		  /* 8216E364h */ case    8:  		/* bc 4, CR6_EQ, -180 */
		/* 8216E364h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8216E2B0;  }
		/* 8216E364h case    8:*/		return 0x8216E368;
	}
	return 0x8216E368;
} // Block from 8216E344h-8216E368h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216E368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E368);
		  /* 8216E368h */ case    0:  		/* mr R26, R11 */
		/* 8216E368h case    0:*/		regs.R26 = regs.R11;
		/* 8216E368h case    0:*/		return 0x8216E36C;
		  /* 8216E36Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216E36Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E36Ch case    1:*/		return 0x8216E370;
		  /* 8216E370h */ case    2:  		/* bc 4, CR6_EQ, -2664 */
		/* 8216E370h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216D908;  }
		/* 8216E370h case    2:*/		return 0x8216E374;
		  /* 8216E374h */ case    3:  		/* b -196 */
		/* 8216E374h case    3:*/		return 0x8216E2B0;
		/* 8216E374h case    3:*/		return 0x8216E378;
	}
	return 0x8216E378;
} // Block from 8216E368h-8216E378h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E378);
		  /* 8216E378h */ case    0:  		/* li R4, 4800 */
		/* 8216E378h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8216E378h case    0:*/		return 0x8216E37C;
		  /* 8216E37Ch */ case    1:  		/* mr R3, R24 */
		/* 8216E37Ch case    1:*/		regs.R3 = regs.R24;
		/* 8216E37Ch case    1:*/		return 0x8216E380;
		  /* 8216E380h */ case    2:  		/* bl -115992 */
		/* 8216E380h case    2:*/		regs.LR = 0x8216E384; return 0x82151E68;
		/* 8216E380h case    2:*/		return 0x8216E384;
	}
	return 0x8216E384;
} // Block from 8216E378h-8216E384h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216E384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E384);
		  /* 8216E384h */ case    0:  		/* mr R31, R21 */
		/* 8216E384h case    0:*/		regs.R31 = regs.R21;
		/* 8216E384h case    0:*/		return 0x8216E388;
	}
	return 0x8216E388;
} // Block from 8216E384h-8216E388h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E388);
		  /* 8216E388h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8216E388h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E388h case    0:*/		return 0x8216E38C;
		  /* 8216E38Ch */ case    1:  		/* bc 12, CR6_EQ, 72 */
		/* 8216E38Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8216E3D4;  }
		/* 8216E38Ch case    1:*/		return 0x8216E390;
		  /* 8216E390h */ case    2:  		/* mr R4, R31 */
		/* 8216E390h case    2:*/		regs.R4 = regs.R31;
		/* 8216E390h case    2:*/		return 0x8216E394;
		  /* 8216E394h */ case    3:  		/* mr R3, R24 */
		/* 8216E394h case    3:*/		regs.R3 = regs.R24;
		/* 8216E394h case    3:*/		return 0x8216E398;
		  /* 8216E398h */ case    4:  		/* bl -4224 */
		/* 8216E398h case    4:*/		regs.LR = 0x8216E39C; return 0x8216D318;
		/* 8216E398h case    4:*/		return 0x8216E39C;
		  /* 8216E39Ch */ case    5:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216E39Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216E39Ch case    5:*/		return 0x8216E3A0;
		  /* 8216E3A0h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8216E3A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216E3A0h case    6:*/		return 0x8216E3A4;
		  /* 8216E3A4h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E3A4h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E3A4h case    7:*/		return 0x8216E3A8;
		  /* 8216E3A8h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 8216E3A8h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216E3B4;  }
		/* 8216E3A8h case    8:*/		return 0x8216E3AC;
		  /* 8216E3ACh */ case    9:  		/* mr R30, R21 */
		/* 8216E3ACh case    9:*/		regs.R30 = regs.R21;
		/* 8216E3ACh case    9:*/		return 0x8216E3B0;
		  /* 8216E3B0h */ case   10:  		/* b 12 */
		/* 8216E3B0h case   10:*/		return 0x8216E3BC;
		/* 8216E3B0h case   10:*/		return 0x8216E3B4;
	}
	return 0x8216E3B4;
} // Block from 8216E388h-8216E3B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216E3B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E3B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E3B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E3B4);
		  /* 8216E3B4h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216E3B4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216E3B4h case    0:*/		return 0x8216E3B8;
		  /* 8216E3B8h */ case    1:  		/* addi R30, R11, -4 */
		/* 8216E3B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFC);
		/* 8216E3B8h case    1:*/		return 0x8216E3BC;
	}
	return 0x8216E3BC;
} // Block from 8216E3B4h-8216E3BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E3BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E3BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E3BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E3BC);
		  /* 8216E3BCh */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8216E3BCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8216E3BCh case    0:*/		return 0x8216E3C0;
		  /* 8216E3C0h */ case    1:  		/* lwz R30, <#[R11 + 4]> */
		/* 8216E3C0h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E3C0h case    1:*/		return 0x8216E3C4;
		  /* 8216E3C4h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8216E3C4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8216E3C4h case    2:*/		return 0x8216E3C8;
		  /* 8216E3C8h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8216E3C8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E3D4;  }
		/* 8216E3C8h case    3:*/		return 0x8216E3CC;
		  /* 8216E3CCh */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8216E3CCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216E3CCh case    4:*/		return 0x8216E3D0;
		  /* 8216E3D0h */ case    5:  		/* bc 4, CR6_EQ, -260 */
		/* 8216E3D0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216E2CC;  }
		/* 8216E3D0h case    5:*/		return 0x8216E3D4;
	}
	return 0x8216E3D4;
} // Block from 8216E3BCh-8216E3D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216E3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E3D4);
		  /* 8216E3D4h */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216E3D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E3D4h case    0:*/		return 0x8216E3D8;
		  /* 8216E3D8h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E3D8h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E3D8h case    1:*/		return 0x8216E3DC;
		  /* 8216E3DCh */ case    2:  		/* bc 4, CR0_EQ, 396 */
		/* 8216E3DCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216E568;  }
		/* 8216E3DCh case    2:*/		return 0x8216E3E0;
		  /* 8216E3E0h */ case    3:  		/* mr R26, R11 */
		/* 8216E3E0h case    3:*/		regs.R26 = regs.R11;
		/* 8216E3E0h case    3:*/		return 0x8216E3E4;
		  /* 8216E3E4h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 8216E3E4h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E3E4h case    4:*/		return 0x8216E3E8;
		  /* 8216E3E8h */ case    5:  		/* bc 12, CR0_EQ, 384 */
		/* 8216E3E8h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216E568;  }
		/* 8216E3E8h case    5:*/		return 0x8216E3EC;
		  /* 8216E3ECh */ case    6:  		/* lwz R11, <#[R26 + 28]> */
		/* 8216E3ECh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 8216E3ECh case    6:*/		return 0x8216E3F0;
		  /* 8216E3F0h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216E3F0h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E3F0h case    7:*/		return 0x8216E3F4;
		  /* 8216E3F4h */ case    8:  		/* bc 4, CR0_EQ, 344 */
		/* 8216E3F4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8216E54C;  }
		/* 8216E3F4h case    8:*/		return 0x8216E3F8;
		  /* 8216E3F8h */ case    9:  		/* lwz R11, <#[R26 + 24]> */
		/* 8216E3F8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 8216E3F8h case    9:*/		return 0x8216E3FC;
		  /* 8216E3FCh */ case   10:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216E3FCh case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216E3FCh case   10:*/		return 0x8216E400;
		  /* 8216E400h */ case   11:  		/* addic. R28, R11, -40 */
		/* 8216E400h case   11:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R11,0xFFFFFFD8);
		/* 8216E400h case   11:*/		return 0x8216E404;
		  /* 8216E404h */ case   12:  		/* bc 12, CR0_EQ, 328 */
		/* 8216E404h case   12:*/		if ( regs.CR[0].eq ) { return 0x8216E54C;  }
		/* 8216E404h case   12:*/		return 0x8216E408;
		  /* 8216E408h */ case   13:  		/* lwz R11, <#[R28 + 8]> */
		/* 8216E408h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8216E408h case   13:*/		return 0x8216E40C;
		  /* 8216E40Ch */ case   14:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216E40Ch case   14:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216E40Ch case   14:*/		return 0x8216E410;
		  /* 8216E410h */ case   15:  		/* cmplwi CR6, R11, 90 */
		/* 8216E410h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 8216E410h case   15:*/		return 0x8216E414;
		  /* 8216E414h */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 8216E414h case   16:*/		if ( regs.CR[6].eq ) { return 0x8216E420;  }
		/* 8216E414h case   16:*/		return 0x8216E418;
		  /* 8216E418h */ case   17:  		/* cmplwi CR6, R11, 89 */
		/* 8216E418h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 8216E418h case   17:*/		return 0x8216E41C;
		  /* 8216E41Ch */ case   18:  		/* bc 4, CR6_EQ, 304 */
		/* 8216E41Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x8216E54C;  }
		/* 8216E41Ch case   18:*/		return 0x8216E420;
	}
	return 0x8216E420;
} // Block from 8216E3D4h-8216E420h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216E420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E420);
		  /* 8216E420h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8216E420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8216E420h case    0:*/		return 0x8216E424;
		  /* 8216E424h */ case    1:  		/* mr R3, R24 */
		/* 8216E424h case    1:*/		regs.R3 = regs.R24;
		/* 8216E424h case    1:*/		return 0x8216E428;
		  /* 8216E428h */ case    2:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216E428h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216E428h case    2:*/		return 0x8216E42C;
		  /* 8216E42Ch */ case    3:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8216E42Ch case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8216E42Ch case    3:*/		return 0x8216E430;
		  /* 8216E430h */ case    4:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216E430h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216E430h case    4:*/		return 0x8216E434;
		  /* 8216E434h */ case    5:  		/* bl -40964 */
		/* 8216E434h case    5:*/		regs.LR = 0x8216E438; return 0x82164430;
		/* 8216E434h case    5:*/		return 0x8216E438;
		  /* 8216E438h */ case    6:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 8216E438h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 8216E438h case    6:*/		return 0x8216E43C;
		  /* 8216E43Ch */ case    7:  		/* addi R10, R28, -16 */
		/* 8216E43Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFF0);
		/* 8216E43Ch case    7:*/		return 0x8216E440;
		  /* 8216E440h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216E440h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E440h case    8:*/		return 0x8216E444;
		  /* 8216E444h */ case    9:  		/* lwzx R10, <#[R3 + R10]> */
		/* 8216E444h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 8216E444h case    9:*/		return 0x8216E448;
		  /* 8216E448h */ case   10:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8216E448h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8216E448h case   10:*/		return 0x8216E44C;
		  /* 8216E44Ch */ case   11:  		/* rlwinm R27, R10, 0, 0, 29 */
		/* 8216E44Ch case   11:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R27,regs.R10);
		/* 8216E44Ch case   11:*/		return 0x8216E450;
		  /* 8216E450h */ case   12:  		/* bc 4, CR0_EQ, 252 */
		/* 8216E450h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8216E54C;  }
		/* 8216E450h case   12:*/		return 0x8216E454;
		  /* 8216E454h */ case   13:  		/* mr R30, R11 */
		/* 8216E454h case   13:*/		regs.R30 = regs.R11;
		/* 8216E454h case   13:*/		return 0x8216E458;
		  /* 8216E458h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 8216E458h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E458h case   14:*/		return 0x8216E45C;
		  /* 8216E45Ch */ case   15:  		/* bc 12, CR6_EQ, 240 */
		/* 8216E45Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8216E54C;  }
		/* 8216E45Ch case   15:*/		return 0x8216E460;
		  /* 8216E460h */ case   16:  		/* lwz R11, <#[R30 + 76]> */
		/* 8216E460h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 8216E460h case   16:*/		return 0x8216E464;
		  /* 8216E464h */ case   17:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 8216E464h case   17:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 8216E464h case   17:*/		return 0x8216E468;
		  /* 8216E468h */ case   18:  		/* bc 4, CR0_EQ, 204 */
		/* 8216E468h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8216E534;  }
		/* 8216E468h case   18:*/		return 0x8216E46C;
		  /* 8216E46Ch */ case   19:  		/* lwz R11, <#[R30 + 20]> */
		/* 8216E46Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8216E46Ch case   19:*/		return 0x8216E470;
		  /* 8216E470h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216E470h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E470h case   20:*/		return 0x8216E474;
		  /* 8216E474h */ case   21:  		/* bc 12, CR0_EQ, 32 */
		/* 8216E474h case   21:*/		if ( regs.CR[0].eq ) { return 0x8216E494;  }
		/* 8216E474h case   21:*/		return 0x8216E478;
		  /* 8216E478h */ case   22:  		/* lwz R11, <#[R30 + 28]> */
		/* 8216E478h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8216E478h case   22:*/		return 0x8216E47C;
		  /* 8216E47Ch */ case   23:  		/* addi R29, R30, 24 */
		/* 8216E47Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x18);
		/* 8216E47Ch case   23:*/		return 0x8216E480;
		  /* 8216E480h */ case   24:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216E480h case   24:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E480h case   24:*/		return 0x8216E484;
		  /* 8216E484h */ case   25:  		/* addic R10, R10, -1 */
		/* 8216E484h case   25:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216E484h case   25:*/		return 0x8216E488;
		  /* 8216E488h */ case   26:  		/* subfe R10, R10, R10 */
		/* 8216E488h case   26:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216E488h case   26:*/		return 0x8216E48C;
		  /* 8216E48Ch */ case   27:  		/* and R31, R10, R11 */
		/* 8216E48Ch case   27:*/		cpu::op::and<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 8216E48Ch case   27:*/		return 0x8216E490;
		  /* 8216E490h */ case   28:  		/* b 28 */
		/* 8216E490h case   28:*/		return 0x8216E4AC;
		/* 8216E490h case   28:*/		return 0x8216E494;
	}
	return 0x8216E494;
} // Block from 8216E420h-8216E494h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8216E494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E494);
		  /* 8216E494h */ case    0:  		/* lwz R10, <#[R30 + 20]> */
		/* 8216E494h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 8216E494h case    0:*/		return 0x8216E498;
		  /* 8216E498h */ case    1:  		/* addi R29, R30, 16 */
		/* 8216E498h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x10);
		/* 8216E498h case    1:*/		return 0x8216E49C;
		  /* 8216E49Ch */ case    2:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 8216E49Ch case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8216E49Ch case    2:*/		return 0x8216E4A0;
		  /* 8216E4A0h */ case    3:  		/* addic R11, R9, -1 */
		/* 8216E4A0h case    3:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8216E4A0h case    3:*/		return 0x8216E4A4;
		  /* 8216E4A4h */ case    4:  		/* subfe R11, R11, R11 */
		/* 8216E4A4h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8216E4A4h case    4:*/		return 0x8216E4A8;
		  /* 8216E4A8h */ case    5:  		/* and R31, R11, R10 */
		/* 8216E4A8h case    5:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 8216E4A8h case    5:*/		return 0x8216E4AC;
	}
	return 0x8216E4AC;
} // Block from 8216E494h-8216E4ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216E4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E4AC);
		  /* 8216E4ACh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8216E4ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E4ACh case    0:*/		return 0x8216E4B0;
		  /* 8216E4B0h */ case    1:  		/* bc 12, CR6_EQ, 104 */
		/* 8216E4B0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216E518;  }
		/* 8216E4B0h case    1:*/		return 0x8216E4B4;
		  /* 8216E4B4h */ case    2:  		/* cmplw CR6, R31, R27 */
		/* 8216E4B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R27);
		/* 8216E4B4h case    2:*/		return 0x8216E4B8;
		  /* 8216E4B8h */ case    3:  		/* bc 12, CR6_EQ, 84 */
		/* 8216E4B8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216E50C;  }
		/* 8216E4B8h case    3:*/		return 0x8216E4BC;
		  /* 8216E4BCh */ case    4:  		/* mr R3, R31 */
		/* 8216E4BCh case    4:*/		regs.R3 = regs.R31;
		/* 8216E4BCh case    4:*/		return 0x8216E4C0;
		  /* 8216E4C0h */ case    5:  		/* bl -5944 */
		/* 8216E4C0h case    5:*/		regs.LR = 0x8216E4C4; return 0x8216CD88;
		/* 8216E4C0h case    5:*/		return 0x8216E4C4;
		  /* 8216E4C4h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216E4C4h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216E4C4h case    6:*/		return 0x8216E4C8;
		  /* 8216E4C8h */ case    7:  		/* bc 4, CR0_EQ, 72 */
		/* 8216E4C8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216E510;  }
		/* 8216E4C8h case    7:*/		return 0x8216E4CC;
		  /* 8216E4CCh */ case    8:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216E4CCh case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216E4CCh case    8:*/		return 0x8216E4D0;
		  /* 8216E4D0h */ case    9:  		/* lwz R31, <#[R11 + 40]> */
		/* 8216E4D0h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8216E4D0h case    9:*/		return 0x8216E4D4;
		  /* 8216E4D4h */ case   10:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216E4D4h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216E4D4h case   10:*/		return 0x8216E4D8;
		  /* 8216E4D8h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 8216E4D8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8216E4E4;  }
		/* 8216E4D8h case   11:*/		return 0x8216E4DC;
		  /* 8216E4DCh */ case   12:  		/* cmplwi CR6, R31, 0 */
		/* 8216E4DCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E4DCh case   12:*/		return 0x8216E4E0;
		  /* 8216E4E0h */ case   13:  		/* bc 4, CR6_EQ, -44 */
		/* 8216E4E0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8216E4B4;  }
		/* 8216E4E0h case   13:*/		return 0x8216E4E4;
	}
	return 0x8216E4E4;
} // Block from 8216E4ACh-8216E4E4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216E4E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E4E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E4E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E4E4);
		  /* 8216E4E4h */ case    0:  		/* addi R11, R30, 24 */
		/* 8216E4E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x18);
		/* 8216E4E4h case    0:*/		return 0x8216E4E8;
		  /* 8216E4E8h */ case    1:  		/* cmplw CR6, R29, R11 */
		/* 8216E4E8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8216E4E8h case    1:*/		return 0x8216E4EC;
		  /* 8216E4ECh */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 8216E4ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x8216E518;  }
		/* 8216E4ECh case    2:*/		return 0x8216E4F0;
		  /* 8216E4F0h */ case    3:  		/* lwz R31, <#[R11 + 4]> */
		/* 8216E4F0h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E4F0h case    3:*/		return 0x8216E4F4;
		  /* 8216E4F4h */ case    4:  		/* mr R29, R11 */
		/* 8216E4F4h case    4:*/		regs.R29 = regs.R11;
		/* 8216E4F4h case    4:*/		return 0x8216E4F8;
		  /* 8216E4F8h */ case    5:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216E4F8h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216E4F8h case    5:*/		return 0x8216E4FC;
		  /* 8216E4FCh */ case    6:  		/* bc 4, CR0_EQ, 28 */
		/* 8216E4FCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216E518;  }
		/* 8216E4FCh case    6:*/		return 0x8216E500;
		  /* 8216E500h */ case    7:  		/* cmplwi CR0, R31, 0 */
		/* 8216E500h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 8216E500h case    7:*/		return 0x8216E504;
		  /* 8216E504h */ case    8:  		/* bc 4, CR0_EQ, -80 */
		/* 8216E504h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8216E4B4;  }
		/* 8216E504h case    8:*/		return 0x8216E508;
		  /* 8216E508h */ case    9:  		/* b 16 */
		/* 8216E508h case    9:*/		return 0x8216E518;
		/* 8216E508h case    9:*/		return 0x8216E50C;
	}
	return 0x8216E50C;
} // Block from 8216E4E4h-8216E50Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216E50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E50C);
		  /* 8216E50Ch */ case    0:  		/* mr R30, R21 */
		/* 8216E50Ch case    0:*/		regs.R30 = regs.R21;
		/* 8216E50Ch case    0:*/		return 0x8216E510;
	}
	return 0x8216E510;
} // Block from 8216E50Ch-8216E510h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E510);
		  /* 8216E510h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8216E510h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E510h case    0:*/		return 0x8216E514;
		  /* 8216E514h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 8216E514h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216E534;  }
		/* 8216E514h case    1:*/		return 0x8216E518;
	}
	return 0x8216E518;
} // Block from 8216E510h-8216E518h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E518);
		  /* 8216E518h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8216E518h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8216E518h case    0:*/		return 0x8216E51C;
		  /* 8216E51Ch */ case    1:  		/* lwz R30, <#[R11 + 4]> */
		/* 8216E51Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E51Ch case    1:*/		return 0x8216E520;
		  /* 8216E520h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8216E520h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8216E520h case    2:*/		return 0x8216E524;
		  /* 8216E524h */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 8216E524h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E53C;  }
		/* 8216E524h case    3:*/		return 0x8216E528;
		  /* 8216E528h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8216E528h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216E528h case    4:*/		return 0x8216E52C;
		  /* 8216E52Ch */ case    5:  		/* bc 4, CR6_EQ, -204 */
		/* 8216E52Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216E460;  }
		/* 8216E52Ch case    5:*/		return 0x8216E530;
		  /* 8216E530h */ case    6:  		/* b 12 */
		/* 8216E530h case    6:*/		return 0x8216E53C;
		/* 8216E530h case    6:*/		return 0x8216E534;
	}
	return 0x8216E534;
} // Block from 8216E518h-8216E534h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216E534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E534);
		  /* 8216E534h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8216E534h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216E534h case    0:*/		return 0x8216E538;
		  /* 8216E538h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 8216E538h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216E54C;  }
		/* 8216E538h case    1:*/		return 0x8216E53C;
	}
	return 0x8216E53C;
} // Block from 8216E534h-8216E53Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E53C);
		  /* 8216E53Ch */ case    0:  		/* mr R4, R28 */
		/* 8216E53Ch case    0:*/		regs.R4 = regs.R28;
		/* 8216E53Ch case    0:*/		return 0x8216E540;
		  /* 8216E540h */ case    1:  		/* mr R3, R24 */
		/* 8216E540h case    1:*/		regs.R3 = regs.R24;
		/* 8216E540h case    1:*/		return 0x8216E544;
		  /* 8216E544h */ case    2:  		/* bl 774412 */
		/* 8216E544h case    2:*/		regs.LR = 0x8216E548; return 0x8222B650;
		/* 8216E544h case    2:*/		return 0x8216E548;
		  /* 8216E548h */ case    3:  		/* b -348 */
		/* 8216E548h case    3:*/		return 0x8216E3EC;
		/* 8216E548h case    3:*/		return 0x8216E54C;
	}
	return 0x8216E54C;
} // Block from 8216E53Ch-8216E54Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E54Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E54C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E54C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E54C);
		  /* 8216E54Ch */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 8216E54Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 8216E54Ch case    0:*/		return 0x8216E550;
		  /* 8216E550h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216E550h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E550h case    1:*/		return 0x8216E554;
		  /* 8216E554h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E554h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E554h case    2:*/		return 0x8216E558;
		  /* 8216E558h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216E558h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E568;  }
		/* 8216E558h case    3:*/		return 0x8216E55C;
		  /* 8216E55Ch */ case    4:  		/* mr R26, R11 */
		/* 8216E55Ch case    4:*/		regs.R26 = regs.R11;
		/* 8216E55Ch case    4:*/		return 0x8216E560;
		  /* 8216E560h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216E560h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E560h case    5:*/		return 0x8216E564;
		  /* 8216E564h */ case    6:  		/* bc 4, CR6_EQ, -376 */
		/* 8216E564h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216E3EC;  }
		/* 8216E564h case    6:*/		return 0x8216E568;
	}
	return 0x8216E568;
} // Block from 8216E54Ch-8216E568h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216E568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E568);
		  /* 8216E568h */ case    0:  		/* lwz R11, <#[R24 + 44]> */
		/* 8216E568h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000002C) );
		/* 8216E568h case    0:*/		return 0x8216E56C;
		  /* 8216E56Ch */ case    1:  		/* rlwinm. R10, R22, 0, 24, 31 */
		/* 8216E56Ch case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R22);
		/* 8216E56Ch case    1:*/		return 0x8216E570;
		  /* 8216E570h */ case    2:  		/* ori R11, R11, 16384 */
		/* 8216E570h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 8216E570h case    2:*/		return 0x8216E574;
		  /* 8216E574h */ case    3:  		/* stw R11, <#[R24 + 44]> */
		/* 8216E574h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x0000002C) );
		/* 8216E574h case    3:*/		return 0x8216E578;
		  /* 8216E578h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8216E578h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216E584;  }
		/* 8216E578h case    4:*/		return 0x8216E57C;
		  /* 8216E57Ch */ case    5:  		/* mr R3, R24 */
		/* 8216E57Ch case    5:*/		regs.R3 = regs.R24;
		/* 8216E57Ch case    5:*/		return 0x8216E580;
		  /* 8216E580h */ case    6:  		/* bl 511392 */
		/* 8216E580h case    6:*/		regs.LR = 0x8216E584; return 0x821EB320;
		/* 8216E580h case    6:*/		return 0x8216E584;
	}
	return 0x8216E584;
} // Block from 8216E568h-8216E584h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216E584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E584);
		  /* 8216E584h */ case    0:  		/* lwz R11, <#[R24 + 48]> */
		/* 8216E584h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000030) );
		/* 8216E584h case    0:*/		return 0x8216E588;
		  /* 8216E588h */ case    1:  		/* lis R10, -1 */
		/* 8216E588h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8216E588h case    1:*/		return 0x8216E58C;
		  /* 8216E58Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8216E58Ch case    2:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8216E58Ch case    2:*/		return 0x8216E590;
		  /* 8216E590h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8216E590h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216E590h case    3:*/		return 0x8216E594;
		  /* 8216E594h */ case    4:  		/* bc 4, CR6_EQ, 1864 */
		/* 8216E594h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8216ECDC;  }
		/* 8216E594h case    4:*/		return 0x8216E598;
		  /* 8216E598h */ case    5:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216E598h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E598h case    5:*/		return 0x8216E59C;
		  /* 8216E59Ch */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E59Ch case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E59Ch case    6:*/		return 0x8216E5A0;
		  /* 8216E5A0h */ case    7:  		/* bc 4, CR0_EQ, 60 */
		/* 8216E5A0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216E5DC;  }
		/* 8216E5A0h case    7:*/		return 0x8216E5A4;
		  /* 8216E5A4h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 8216E5A4h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E5A4h case    8:*/		return 0x8216E5A8;
		  /* 8216E5A8h */ case    9:  		/* bc 12, CR0_EQ, 52 */
		/* 8216E5A8h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216E5DC;  }
		/* 8216E5A8h case    9:*/		return 0x8216E5AC;
		  /* 8216E5ACh */ case   10:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216E5ACh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216E5ACh case   10:*/		return 0x8216E5B0;
		  /* 8216E5B0h */ case   11:  		/* rlwinm R9, R11, 0, 0, 30 */
		/* 8216E5B0h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R11);
		/* 8216E5B0h case   11:*/		return 0x8216E5B4;
		  /* 8216E5B4h */ case   12:  		/* lwz R8, <#[R11 + 76]> */
		/* 8216E5B4h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000004C) );
		/* 8216E5B4h case   12:*/		return 0x8216E5B8;
		  /* 8216E5B8h */ case   13:  		/* rlwinm R10, R10, 0, 2, 0 */
		/* 8216E5B8h case   13:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R10,regs.R10);
		/* 8216E5B8h case   13:*/		return 0x8216E5BC;
		  /* 8216E5BCh */ case   14:  		/* rlwimi R8, R20, 29, 1, 2 */
		/* 8216E5BCh case   14:*/		cpu::op::rlwimi<0,29,1,2>(regs,&regs.R8,regs.R20);
		/* 8216E5BCh case   14:*/		return 0x8216E5C0;
		  /* 8216E5C0h */ case   15:  		/* stw R10, <#[R11 + 48]> */
		/* 8216E5C0h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216E5C0h case   15:*/		return 0x8216E5C4;
		  /* 8216E5C4h */ case   16:  		/* stw R8, <#[R11 + 76]> */
		/* 8216E5C4h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000004C) );
		/* 8216E5C4h case   16:*/		return 0x8216E5C8;
		  /* 8216E5C8h */ case   17:  		/* lwz R11, <#[R9 + 4]> */
		/* 8216E5C8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8216E5C8h case   17:*/		return 0x8216E5CC;
		  /* 8216E5CCh */ case   18:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E5CCh case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E5CCh case   18:*/		return 0x8216E5D0;
		  /* 8216E5D0h */ case   19:  		/* bc 4, CR0_EQ, 12 */
		/* 8216E5D0h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8216E5DC;  }
		/* 8216E5D0h case   19:*/		return 0x8216E5D4;
		  /* 8216E5D4h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 8216E5D4h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E5D4h case   20:*/		return 0x8216E5D8;
		  /* 8216E5D8h */ case   21:  		/* bc 4, CR6_EQ, -44 */
		/* 8216E5D8h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8216E5AC;  }
		/* 8216E5D8h case   21:*/		return 0x8216E5DC;
	}
	return 0x8216E5DC;
} // Block from 8216E584h-8216E5DCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 8216E5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E5DC);
		  /* 8216E5DCh */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216E5DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E5DCh case    0:*/		return 0x8216E5E0;
		  /* 8216E5E0h */ case    1:  		/* mr R29, R21 */
		/* 8216E5E0h case    1:*/		regs.R29 = regs.R21;
		/* 8216E5E0h case    1:*/		return 0x8216E5E4;
		  /* 8216E5E4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E5E4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E5E4h case    2:*/		return 0x8216E5E8;
		  /* 8216E5E8h */ case    3:  		/* bc 4, CR0_EQ, 400 */
		/* 8216E5E8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E778;  }
		/* 8216E5E8h case    3:*/		return 0x8216E5EC;
		  /* 8216E5ECh */ case    4:  		/* mr R31, R11 */
		/* 8216E5ECh case    4:*/		regs.R31 = regs.R11;
		/* 8216E5ECh case    4:*/		return 0x8216E5F0;
		  /* 8216E5F0h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8216E5F0h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E5F0h case    5:*/		return 0x8216E5F4;
		  /* 8216E5F4h */ case    6:  		/* bc 12, CR0_EQ, 388 */
		/* 8216E5F4h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216E778;  }
		/* 8216E5F4h case    6:*/		return 0x8216E5F8;
		  /* 8216E5F8h */ case    7:  		/* lwz R11, <#[R31 + 76]> */
		/* 8216E5F8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8216E5F8h case    7:*/		return 0x8216E5FC;
		  /* 8216E5FCh */ case    8:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8216E5FCh case    8:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8216E5FCh case    8:*/		return 0x8216E600;
		  /* 8216E600h */ case    9:  		/* bc 12, CR0_EQ, 352 */
		/* 8216E600h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216E760;  }
		/* 8216E600h case    9:*/		return 0x8216E604;
		  /* 8216E604h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216E604h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216E604h case   10:*/		return 0x8216E608;
		  /* 8216E608h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8216E608h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E608h case   11:*/		return 0x8216E60C;
		  /* 8216E60Ch */ case   12:  		/* bc 12, CR6_EQ, 76 */
		/* 8216E60Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8216E658;  }
		/* 8216E60Ch case   12:*/		return 0x8216E610;
		  /* 8216E610h */ case   13:  		/* lwz R10, <#[R31 + 48]> */
		/* 8216E610h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8216E610h case   13:*/		return 0x8216E614;
		  /* 8216E614h */ case   14:  		/* lwz R5, <#[R11 + 4]> */
		/* 8216E614h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E614h case   14:*/		return 0x8216E618;
		  /* 8216E618h */ case   15:  		/* rlwinm R9, R10, 0, 13, 31 */
		/* 8216E618h case   15:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R10);
		/* 8216E618h case   15:*/		return 0x8216E61C;
		  /* 8216E61Ch */ case   16:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8216E61Ch case   16:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8216E61Ch case   16:*/		return 0x8216E620;
		  /* 8216E620h */ case   17:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8216E620h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8216E620h case   17:*/		return 0x8216E624;
		  /* 8216E624h */ case   18:  		/* addi R10, R10, 1 */
		/* 8216E624h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216E624h case   18:*/		return 0x8216E628;
		  /* 8216E628h */ case   19:  		/* lwz R8, <#[R5 + 40]> */
		/* 8216E628h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000028) );
		/* 8216E628h case   19:*/		return 0x8216E62C;
		  /* 8216E62Ch */ case   20:  		/* slw R9, R20, R9 */
		/* 8216E62Ch case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R20,regs.R9);
		/* 8216E62Ch case   20:*/		return 0x8216E630;
		  /* 8216E630h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216E630h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216E630h case   21:*/		return 0x8216E634;
		  /* 8216E634h */ case   22:  		/* lwzx R10, <#[R10 + R8]> */
		/* 8216E634h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8216E634h case   22:*/		return 0x8216E638;
		  /* 8216E638h */ case   23:  		/* and. R10, R10, R9 */
		/* 8216E638h case   23:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216E638h case   23:*/		return 0x8216E63C;
		  /* 8216E63Ch */ case   24:  		/* bc 4, CR0_EQ, 12 */
		/* 8216E63Ch case   24:*/		if ( !regs.CR[0].eq ) { return 0x8216E648;  }
		/* 8216E63Ch case   24:*/		return 0x8216E640;
		  /* 8216E640h */ case   25:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216E640h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216E640h case   25:*/		return 0x8216E644;
		  /* 8216E644h */ case   26:  		/* b -60 */
		/* 8216E644h case   26:*/		return 0x8216E608;
		/* 8216E644h case   26:*/		return 0x8216E648;
	}
	return 0x8216E648;
} // Block from 8216E5DCh-8216E648h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8216E648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E648);
		  /* 8216E648h */ case    0:  		/* mr R4, R31 */
		/* 8216E648h case    0:*/		regs.R4 = regs.R31;
		/* 8216E648h case    0:*/		return 0x8216E64C;
		  /* 8216E64Ch */ case    1:  		/* mr R3, R24 */
		/* 8216E64Ch case    1:*/		regs.R3 = regs.R24;
		/* 8216E64Ch case    1:*/		return 0x8216E650;
		  /* 8216E650h */ case    2:  		/* bl -4376 */
		/* 8216E650h case    2:*/		regs.LR = 0x8216E654; return 0x8216D538;
		/* 8216E650h case    2:*/		return 0x8216E654;
		  /* 8216E654h */ case    3:  		/* mr R29, R20 */
		/* 8216E654h case    3:*/		regs.R29 = regs.R20;
		/* 8216E654h case    3:*/		return 0x8216E658;
	}
	return 0x8216E658;
} // Block from 8216E648h-8216E658h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E658);
		  /* 8216E658h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 8216E658h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8216E658h case    0:*/		return 0x8216E65C;
		  /* 8216E65Ch */ case    1:  		/* rlwinm. R11, R11, 13, 31, 31 */
		/* 8216E65Ch case    1:*/		cpu::op::rlwinm<1,13,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E65Ch case    1:*/		return 0x8216E660;
		  /* 8216E660h */ case    2:  		/* bc 12, CR0_EQ, 136 */
		/* 8216E660h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216E6E8;  }
		/* 8216E660h case    2:*/		return 0x8216E664;
		  /* 8216E664h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216E664h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216E664h case    3:*/		return 0x8216E668;
		  /* 8216E668h */ case    4:  		/* mr R10, R21 */
		/* 8216E668h case    4:*/		regs.R10 = regs.R21;
		/* 8216E668h case    4:*/		return 0x8216E66C;
		  /* 8216E66Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216E66Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E66Ch case    5:*/		return 0x8216E670;
		  /* 8216E670h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 8216E670h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216E694;  }
		/* 8216E670h case    6:*/		return 0x8216E674;
		  /* 8216E674h */ case    7:  		/* lwz R9, <#[R11 + 4]> */
		/* 8216E674h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E674h case    7:*/		return 0x8216E678;
		  /* 8216E678h */ case    8:  		/* addi R10, R10, 1 */
		/* 8216E678h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216E678h case    8:*/		return 0x8216E67C;
		  /* 8216E67Ch */ case    9:  		/* lwz R9, <#[R9 + 76]> */
		/* 8216E67Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000004C) );
		/* 8216E67Ch case    9:*/		return 0x8216E680;
		  /* 8216E680h */ case   10:  		/* rlwinm. R9, R9, 0, 2, 2 */
		/* 8216E680h case   10:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R9,regs.R9);
		/* 8216E680h case   10:*/		return 0x8216E684;
		  /* 8216E684h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 8216E684h case   11:*/		if ( regs.CR[0].eq ) { return 0x8216E690;  }
		/* 8216E684h case   11:*/		return 0x8216E688;
		  /* 8216E688h */ case   12:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216E688h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216E688h case   12:*/		return 0x8216E68C;
		  /* 8216E68Ch */ case   13:  		/* b -32 */
		/* 8216E68Ch case   13:*/		return 0x8216E66C;
		/* 8216E68Ch case   13:*/		return 0x8216E690;
	}
	return 0x8216E690;
} // Block from 8216E658h-8216E690h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216E690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E690);
		  /* 8216E690h */ case    0:  		/* li R10, 2 */
		/* 8216E690h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8216E690h case    0:*/		return 0x8216E694;
	}
	return 0x8216E694;
} // Block from 8216E690h-8216E694h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E694);
		  /* 8216E694h */ case    0:  		/* cmplwi CR6, R10, 1 */
		/* 8216E694h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8216E694h case    0:*/		return 0x8216E698;
		  /* 8216E698h */ case    1:  		/* bc 4, CR6_GT, 80 */
		/* 8216E698h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216E6E8;  }
		/* 8216E698h case    1:*/		return 0x8216E69C;
		  /* 8216E69Ch */ case    2:  		/* lwz R11, <#[R31 + 116]> */
		/* 8216E69Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 8216E69Ch case    2:*/		return 0x8216E6A0;
		  /* 8216E6A0h */ case    3:  		/* addi R30, R11, 16 */
		/* 8216E6A0h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x10);
		/* 8216E6A0h case    3:*/		return 0x8216E6A4;
		  /* 8216E6A4h */ case    4:  		/* lwz R11, <#[R11 + 16]> */
		/* 8216E6A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8216E6A4h case    4:*/		return 0x8216E6A8;
		  /* 8216E6A8h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 8216E6A8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216E6A8h case    5:*/		return 0x8216E6AC;
		  /* 8216E6ACh */ case    6:  		/* bc 12, CR6_EQ, 60 */
		/* 8216E6ACh case    6:*/		if ( regs.CR[6].eq ) { return 0x8216E6E8;  }
		/* 8216E6ACh case    6:*/		return 0x8216E6B0;
		  /* 8216E6B0h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 8216E6B0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216E6B0h case    7:*/		return 0x8216E6B4;
		  /* 8216E6B4h */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 8216E6B4h case    8:*/		if ( regs.CR[6].eq ) { return 0x8216E6E8;  }
		/* 8216E6B4h case    8:*/		return 0x8216E6B8;
		  /* 8216E6B8h */ case    9:  		/* lwz R5, <#[R30]> */
		/* 8216E6B8h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000000) );
		/* 8216E6B8h case    9:*/		return 0x8216E6BC;
		  /* 8216E6BCh */ case   10:  		/* lwz R11, <#[R5 + 48]> */
		/* 8216E6BCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000030) );
		/* 8216E6BCh case   10:*/		return 0x8216E6C0;
		  /* 8216E6C0h */ case   11:  		/* rlwinm. R10, R11, 10, 31, 31 */
		/* 8216E6C0h case   11:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E6C0h case   11:*/		return 0x8216E6C4;
		  /* 8216E6C4h */ case   12:  		/* bc 4, CR0_EQ, 28 */
		/* 8216E6C4h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8216E6E0;  }
		/* 8216E6C4h case   12:*/		return 0x8216E6C8;
		  /* 8216E6C8h */ case   13:  		/* rlwinm. R11, R11, 12, 31, 31 */
		/* 8216E6C8h case   13:*/		cpu::op::rlwinm<1,12,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E6C8h case   13:*/		return 0x8216E6CC;
		  /* 8216E6CCh */ case   14:  		/* bc 12, CR0_EQ, 20 */
		/* 8216E6CCh case   14:*/		if ( regs.CR[0].eq ) { return 0x8216E6E0;  }
		/* 8216E6CCh case   14:*/		return 0x8216E6D0;
		  /* 8216E6D0h */ case   15:  		/* mr R4, R31 */
		/* 8216E6D0h case   15:*/		regs.R4 = regs.R31;
		/* 8216E6D0h case   15:*/		return 0x8216E6D4;
		  /* 8216E6D4h */ case   16:  		/* mr R3, R24 */
		/* 8216E6D4h case   16:*/		regs.R3 = regs.R24;
		/* 8216E6D4h case   16:*/		return 0x8216E6D8;
		  /* 8216E6D8h */ case   17:  		/* bl -4512 */
		/* 8216E6D8h case   17:*/		regs.LR = 0x8216E6DC; return 0x8216D538;
		/* 8216E6D8h case   17:*/		return 0x8216E6DC;
		  /* 8216E6DCh */ case   18:  		/* mr R29, R20 */
		/* 8216E6DCh case   18:*/		regs.R29 = regs.R20;
		/* 8216E6DCh case   18:*/		return 0x8216E6E0;
	}
	return 0x8216E6E0;
} // Block from 8216E694h-8216E6E0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216E6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E6E0);
		  /* 8216E6E0h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 8216E6E0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8216E6E0h case    0:*/		return 0x8216E6E4;
		  /* 8216E6E4h */ case    1:  		/* b -52 */
		/* 8216E6E4h case    1:*/		return 0x8216E6B0;
		/* 8216E6E4h case    1:*/		return 0x8216E6E8;
	}
	return 0x8216E6E8;
} // Block from 8216E6E0h-8216E6E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E6E8);
		  /* 8216E6E8h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 8216E6E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8216E6E8h case    0:*/		return 0x8216E6EC;
		  /* 8216E6ECh */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E6ECh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E6ECh case    1:*/		return 0x8216E6F0;
		  /* 8216E6F0h */ case    2:  		/* bc 4, CR0_EQ, 112 */
		/* 8216E6F0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216E760;  }
		/* 8216E6F0h case    2:*/		return 0x8216E6F4;
		  /* 8216E6F4h */ case    3:  		/* mr R10, R11 */
		/* 8216E6F4h case    3:*/		regs.R10 = regs.R11;
		/* 8216E6F4h case    3:*/		return 0x8216E6F8;
		  /* 8216E6F8h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 8216E6F8h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E6F8h case    4:*/		return 0x8216E6FC;
		  /* 8216E6FCh */ case    5:  		/* bc 12, CR0_EQ, 100 */
		/* 8216E6FCh case    5:*/		if ( regs.CR[0].eq ) { return 0x8216E760;  }
		/* 8216E6FCh case    5:*/		return 0x8216E700;
		  /* 8216E700h */ case    6:  		/* lwz R11, <#[R10 + 8]> */
		/* 8216E700h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8216E700h case    6:*/		return 0x8216E704;
		  /* 8216E704h */ case    7:  		/* rlwinm R9, R11, 25, 25, 31 */
		/* 8216E704h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R11);
		/* 8216E704h case    7:*/		return 0x8216E708;
		  /* 8216E708h */ case    8:  		/* cmplwi CR6, R9, 91 */
		/* 8216E708h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000005B);
		/* 8216E708h case    8:*/		return 0x8216E70C;
		  /* 8216E70Ch */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 8216E70Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x8216E71C;  }
		/* 8216E70Ch case    9:*/		return 0x8216E710;
		  /* 8216E710h */ case   10:  		/* cmplwi CR6, R9, 94 */
		/* 8216E710h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000005E);
		/* 8216E710h case   10:*/		return 0x8216E714;
		  /* 8216E714h */ case   11:  		/* mr R11, R20 */
		/* 8216E714h case   11:*/		regs.R11 = regs.R20;
		/* 8216E714h case   11:*/		return 0x8216E718;
		  /* 8216E718h */ case   12:  		/* bc 4, CR6_GT, 8 */
		/* 8216E718h case   12:*/		if ( !regs.CR[6].gt ) { return 0x8216E720;  }
		/* 8216E718h case   12:*/		return 0x8216E71C;
	}
	return 0x8216E71C;
} // Block from 8216E6E8h-8216E71Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216E71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E71C);
		  /* 8216E71Ch */ case    0:  		/* mr R11, R21 */
		/* 8216E71Ch case    0:*/		regs.R11 = regs.R21;
		/* 8216E71Ch case    0:*/		return 0x8216E720;
	}
	return 0x8216E720;
} // Block from 8216E71Ch-8216E720h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E720);
		  /* 8216E720h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216E720h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216E720h case    0:*/		return 0x8216E724;
		  /* 8216E724h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8216E724h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216E730;  }
		/* 8216E724h case    1:*/		return 0x8216E728;
		  /* 8216E728h */ case    2:  		/* cmplwi CR6, R9, 93 */
		/* 8216E728h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000005D);
		/* 8216E728h case    2:*/		return 0x8216E72C;
		  /* 8216E72Ch */ case    3:  		/* bc 4, CR6_EQ, 36 */
		/* 8216E72Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216E750;  }
		/* 8216E72Ch case    3:*/		return 0x8216E730;
	}
	return 0x8216E730;
} // Block from 8216E720h-8216E730h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E730);
		  /* 8216E730h */ case    0:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 8216E730h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 8216E730h case    0:*/		return 0x8216E734;
		  /* 8216E734h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216E734h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216E734h case    1:*/		return 0x8216E738;
		  /* 8216E738h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E738h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E738h case    2:*/		return 0x8216E73C;
		  /* 8216E73Ch */ case    3:  		/* bc 4, CR0_EQ, 36 */
		/* 8216E73Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E760;  }
		/* 8216E73Ch case    3:*/		return 0x8216E740;
		  /* 8216E740h */ case    4:  		/* mr R10, R11 */
		/* 8216E740h case    4:*/		regs.R10 = regs.R11;
		/* 8216E740h case    4:*/		return 0x8216E744;
		  /* 8216E744h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216E744h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E744h case    5:*/		return 0x8216E748;
		  /* 8216E748h */ case    6:  		/* bc 4, CR6_EQ, -72 */
		/* 8216E748h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216E700;  }
		/* 8216E748h case    6:*/		return 0x8216E74C;
		  /* 8216E74Ch */ case    7:  		/* b 20 */
		/* 8216E74Ch case    7:*/		return 0x8216E760;
		/* 8216E74Ch case    7:*/		return 0x8216E750;
	}
	return 0x8216E750;
} // Block from 8216E730h-8216E750h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216E750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E750);
		  /* 8216E750h */ case    0:  		/* lwz R11, <#[R31 + 76]> */
		/* 8216E750h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8216E750h case    0:*/		return 0x8216E754;
		  /* 8216E754h */ case    1:  		/* mr R29, R20 */
		/* 8216E754h case    1:*/		regs.R29 = regs.R20;
		/* 8216E754h case    1:*/		return 0x8216E758;
		  /* 8216E758h */ case    2:  		/* rlwimi R11, R20, 30, 1, 2 */
		/* 8216E758h case    2:*/		cpu::op::rlwimi<0,30,1,2>(regs,&regs.R11,regs.R20);
		/* 8216E758h case    2:*/		return 0x8216E75C;
		  /* 8216E75Ch */ case    3:  		/* stw R11, <#[R31 + 76]> */
		/* 8216E75Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8216E75Ch case    3:*/		return 0x8216E760;
	}
	return 0x8216E760;
} // Block from 8216E750h-8216E760h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E760);
		  /* 8216E760h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216E760h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216E760h case    0:*/		return 0x8216E764;
		  /* 8216E764h */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 8216E764h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8216E764h case    1:*/		return 0x8216E768;
		  /* 8216E768h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216E768h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216E768h case    2:*/		return 0x8216E76C;
		  /* 8216E76Ch */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8216E76Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E778;  }
		/* 8216E76Ch case    3:*/		return 0x8216E770;
		  /* 8216E770h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216E770h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216E770h case    4:*/		return 0x8216E774;
		  /* 8216E774h */ case    5:  		/* bc 4, CR6_EQ, -380 */
		/* 8216E774h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216E5F8;  }
		/* 8216E774h case    5:*/		return 0x8216E778;
	}
	return 0x8216E778;
} // Block from 8216E760h-8216E778h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216E778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E778);
		  /* 8216E778h */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216E778h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E778h case    0:*/		return 0x8216E77C;
		  /* 8216E77Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216E77Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E77Ch case    1:*/		return 0x8216E780;
		  /* 8216E780h */ case    2:  		/* bc 4, CR0_EQ, 172 */
		/* 8216E780h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216E82C;  }
		/* 8216E780h case    2:*/		return 0x8216E784;
		  /* 8216E784h */ case    3:  		/* lwz R11, <#[R24]> */
		/* 8216E784h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8216E784h case    3:*/		return 0x8216E788;
		  /* 8216E788h */ case    4:  		/* b 152 */
		/* 8216E788h case    4:*/		return 0x8216E820;
		/* 8216E788h case    4:*/		return 0x8216E78C;
		  /* 8216E78Ch */ case    5:  		/* lwz R11, <#[R31 + 76]> */
		/* 8216E78Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8216E78Ch case    5:*/		return 0x8216E790;
		  /* 8216E790h */ case    6:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8216E790h case    6:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8216E790h case    6:*/		return 0x8216E794;
		  /* 8216E794h */ case    7:  		/* bc 12, CR0_EQ, 124 */
		/* 8216E794h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216E810;  }
		/* 8216E794h case    7:*/		return 0x8216E798;
		  /* 8216E798h */ case    8:  		/* mr R4, R31 */
		/* 8216E798h case    8:*/		regs.R4 = regs.R31;
		/* 8216E798h case    8:*/		return 0x8216E79C;
		  /* 8216E79Ch */ case    9:  		/* mr R3, R24 */
		/* 8216E79Ch case    9:*/		regs.R3 = regs.R24;
		/* 8216E79Ch case    9:*/		return 0x8216E7A0;
		  /* 8216E7A0h */ case   10:  		/* bl -5960 */
		/* 8216E7A0h case   10:*/		regs.LR = 0x8216E7A4; return 0x8216D058;
		/* 8216E7A0h case   10:*/		return 0x8216E7A4;
		  /* 8216E7A4h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 8216E7A4h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8216E7A4h case   11:*/		return 0x8216E7A8;
		  /* 8216E7A8h */ case   12:  		/* bc 12, CR0_EQ, 28 */
		/* 8216E7A8h case   12:*/		if ( regs.CR[0].eq ) { return 0x8216E7C4;  }
		/* 8216E7A8h case   12:*/		return 0x8216E7AC;
		  /* 8216E7ACh */ case   13:  		/* lwz R11, <#[R3 + 76]> */
		/* 8216E7ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216E7ACh case   13:*/		return 0x8216E7B0;
		  /* 8216E7B0h */ case   14:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8216E7B0h case   14:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8216E7B0h case   14:*/		return 0x8216E7B4;
		  /* 8216E7B4h */ case   15:  		/* bc 4, CR0_EQ, 16 */
		/* 8216E7B4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8216E7C4;  }
		/* 8216E7B4h case   15:*/		return 0x8216E7B8;
		  /* 8216E7B8h */ case   16:  		/* rlwimi R11, R20, 30, 1, 2 */
		/* 8216E7B8h case   16:*/		cpu::op::rlwimi<0,30,1,2>(regs,&regs.R11,regs.R20);
		/* 8216E7B8h case   16:*/		return 0x8216E7BC;
		  /* 8216E7BCh */ case   17:  		/* mr R29, R20 */
		/* 8216E7BCh case   17:*/		regs.R29 = regs.R20;
		/* 8216E7BCh case   17:*/		return 0x8216E7C0;
		  /* 8216E7C0h */ case   18:  		/* stw R11, <#[R3 + 76]> */
		/* 8216E7C0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216E7C0h case   18:*/		return 0x8216E7C4;
	}
	return 0x8216E7C4;
} // Block from 8216E778h-8216E7C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216E7C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E7C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E7C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E7C4);
		  /* 8216E7C4h */ case    0:  		/* stw R21, <#[R1 + 112]> */
		/* 8216E7C4h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000070) );
		/* 8216E7C4h case    0:*/		return 0x8216E7C8;
		  /* 8216E7C8h */ case    1:  		/* addi R3, R1, 96 */
		/* 8216E7C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216E7C8h case    1:*/		return 0x8216E7CC;
		  /* 8216E7CCh */ case    2:  		/* stw R21, <#[R1 + 116]> */
		/* 8216E7CCh case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000074) );
		/* 8216E7CCh case    2:*/		return 0x8216E7D0;
		  /* 8216E7D0h */ case    3:  		/* stw R31, <#[R1 + 96]> */
		/* 8216E7D0h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 8216E7D0h case    3:*/		return 0x8216E7D4;
		  /* 8216E7D4h */ case    4:  		/* stb R20, <#[R1 + 120]> */
		/* 8216E7D4h case    4:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x00000078) );
		/* 8216E7D4h case    4:*/		return 0x8216E7D8;
		  /* 8216E7D8h */ case    5:  		/* stw R21, <#[R1 + 104]> */
		/* 8216E7D8h case    5:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000068) );
		/* 8216E7D8h case    5:*/		return 0x8216E7DC;
		  /* 8216E7DCh */ case    6:  		/* lwz R4, <#[R31 + 8]> */
		/* 8216E7DCh case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8216E7DCh case    6:*/		return 0x8216E7E0;
		  /* 8216E7E0h */ case    7:  		/* bl 791008 */
		/* 8216E7E0h case    7:*/		regs.LR = 0x8216E7E4; return 0x8222F9C0;
		/* 8216E7E0h case    7:*/		return 0x8216E7E4;
		  /* 8216E7E4h */ case    8:  		/* b 28 */
		/* 8216E7E4h case    8:*/		return 0x8216E800;
		/* 8216E7E4h case    8:*/		return 0x8216E7E8;
		  /* 8216E7E8h */ case    9:  		/* lwz R11, <#[R3 + 76]> */
		/* 8216E7E8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216E7E8h case    9:*/		return 0x8216E7EC;
		  /* 8216E7ECh */ case   10:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8216E7ECh case   10:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8216E7ECh case   10:*/		return 0x8216E7F0;
		  /* 8216E7F0h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 8216E7F0h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8216E800;  }
		/* 8216E7F0h case   11:*/		return 0x8216E7F4;
		  /* 8216E7F4h */ case   12:  		/* rlwimi R11, R20, 30, 1, 2 */
		/* 8216E7F4h case   12:*/		cpu::op::rlwimi<0,30,1,2>(regs,&regs.R11,regs.R20);
		/* 8216E7F4h case   12:*/		return 0x8216E7F8;
		  /* 8216E7F8h */ case   13:  		/* mr R29, R20 */
		/* 8216E7F8h case   13:*/		regs.R29 = regs.R20;
		/* 8216E7F8h case   13:*/		return 0x8216E7FC;
		  /* 8216E7FCh */ case   14:  		/* stw R11, <#[R3 + 76]> */
		/* 8216E7FCh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 8216E7FCh case   14:*/		return 0x8216E800;
	}
	return 0x8216E800;
} // Block from 8216E7C4h-8216E800h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216E800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E800);
		  /* 8216E800h */ case    0:  		/* addi R3, R1, 96 */
		/* 8216E800h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216E800h case    0:*/		return 0x8216E804;
		  /* 8216E804h */ case    1:  		/* bl -7428 */
		/* 8216E804h case    1:*/		regs.LR = 0x8216E808; return 0x8216CB00;
		/* 8216E804h case    1:*/		return 0x8216E808;
		  /* 8216E808h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 8216E808h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8216E808h case    2:*/		return 0x8216E80C;
		  /* 8216E80Ch */ case    3:  		/* bc 4, CR0_EQ, -36 */
		/* 8216E80Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E7E8;  }
		/* 8216E80Ch case    3:*/		return 0x8216E810;
	}
	return 0x8216E810;
} // Block from 8216E800h-8216E810h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E810);
		  /* 8216E810h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216E810h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216E810h case    0:*/		return 0x8216E814;
		  /* 8216E814h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 8216E814h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216E814h case    1:*/		return 0x8216E818;
		  /* 8216E818h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E818h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E818h case    2:*/		return 0x8216E81C;
		  /* 8216E81Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216E81Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216E82C;  }
		/* 8216E81Ch case    3:*/		return 0x8216E820;
	}
	return 0x8216E820;
} // Block from 8216E810h-8216E820h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E820);
		  /* 8216E820h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216E820h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216E820h case    0:*/		return 0x8216E824;
		  /* 8216E824h */ case    1:  		/* addic. R31, R11, -4 */
		/* 8216E824h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFFC);
		/* 8216E824h case    1:*/		return 0x8216E828;
		  /* 8216E828h */ case    2:  		/* bc 4, CR0_EQ, -156 */
		/* 8216E828h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216E78C;  }
		/* 8216E828h case    2:*/		return 0x8216E82C;
	}
	return 0x8216E82C;
} // Block from 8216E820h-8216E82Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216E82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E82C);
		  /* 8216E82Ch */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 8216E82Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 8216E82Ch case    0:*/		return 0x8216E830;
		  /* 8216E830h */ case    1:  		/* bc 4, CR0_EQ, -596 */
		/* 8216E830h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216E5DC;  }
		/* 8216E830h case    1:*/		return 0x8216E834;
		  /* 8216E834h */ case    2:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216E834h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E834h case    2:*/		return 0x8216E838;
		  /* 8216E838h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E838h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E838h case    3:*/		return 0x8216E83C;
		  /* 8216E83Ch */ case    4:  		/* bc 4, CR0_EQ, 1184 */
		/* 8216E83Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216ECDC;  }
		/* 8216E83Ch case    4:*/		return 0x8216E840;
		  /* 8216E840h */ case    5:  		/* mr R25, R11 */
		/* 8216E840h case    5:*/		regs.R25 = regs.R11;
		/* 8216E840h case    5:*/		return 0x8216E844;
		  /* 8216E844h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 8216E844h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E844h case    6:*/		return 0x8216E848;
		  /* 8216E848h */ case    7:  		/* bc 12, CR0_EQ, 1172 */
		/* 8216E848h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216ECDC;  }
		/* 8216E848h case    7:*/		return 0x8216E84C;
		  /* 8216E84Ch */ case    8:  		/* lwz R11, <#[R25 + 28]> */
		/* 8216E84Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000001C) );
		/* 8216E84Ch case    8:*/		return 0x8216E850;
		  /* 8216E850h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E850h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E850h case    9:*/		return 0x8216E854;
		  /* 8216E854h */ case   10:  		/* bc 4, CR0_EQ, 1132 */
		/* 8216E854h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216ECC0;  }
		/* 8216E854h case   10:*/		return 0x8216E858;
		  /* 8216E858h */ case   11:  		/* mr R27, R11 */
		/* 8216E858h case   11:*/		regs.R27 = regs.R11;
		/* 8216E858h case   11:*/		return 0x8216E85C;
		  /* 8216E85Ch */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 8216E85Ch case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E85Ch case   12:*/		return 0x8216E860;
		  /* 8216E860h */ case   13:  		/* bc 12, CR0_EQ, 1120 */
		/* 8216E860h case   13:*/		if ( regs.CR[0].eq ) { return 0x8216ECC0;  }
		/* 8216E860h case   13:*/		return 0x8216E864;
		  /* 8216E864h */ case   14:  		/* lwz R11, <#[R27 + 8]> */
		/* 8216E864h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8216E864h case   14:*/		return 0x8216E868;
		  /* 8216E868h */ case   15:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216E868h case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216E868h case   15:*/		return 0x8216E86C;
		  /* 8216E86Ch */ case   16:  		/* cmplwi CR6, R11, 11904 */
		/* 8216E86Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002E80);
		/* 8216E86Ch case   16:*/		return 0x8216E870;
		  /* 8216E870h */ case   17:  		/* bc 4, CR6_EQ, 16 */
		/* 8216E870h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216E880;  }
		/* 8216E870h case   17:*/		return 0x8216E874;
		  /* 8216E874h */ case   18:  		/* lwz R11, <#[R27]> */
		/* 8216E874h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8216E874h case   18:*/		return 0x8216E878;
		  /* 8216E878h */ case   19:  		/* cmpwi CR6, R11, 0 */
		/* 8216E878h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216E878h case   19:*/		return 0x8216E87C;
		  /* 8216E87Ch */ case   20:  		/* bc 12, CR6_EQ, 36 */
		/* 8216E87Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x8216E8A0;  }
		/* 8216E87Ch case   20:*/		return 0x8216E880;
	}
	return 0x8216E880;
} // Block from 8216E82Ch-8216E880h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216E880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E880);
		  /* 8216E880h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 8216E880h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 8216E880h case    0:*/		return 0x8216E884;
		  /* 8216E884h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216E884h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216E884h case    1:*/		return 0x8216E888;
		  /* 8216E888h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E888h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E888h case    2:*/		return 0x8216E88C;
		  /* 8216E88Ch */ case    3:  		/* bc 4, CR0_EQ, 1076 */
		/* 8216E88Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216ECC0;  }
		/* 8216E88Ch case    3:*/		return 0x8216E890;
		  /* 8216E890h */ case    4:  		/* mr R27, R11 */
		/* 8216E890h case    4:*/		regs.R27 = regs.R11;
		/* 8216E890h case    4:*/		return 0x8216E894;
		  /* 8216E894h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216E894h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216E894h case    5:*/		return 0x8216E898;
		  /* 8216E898h */ case    6:  		/* bc 4, CR6_EQ, -52 */
		/* 8216E898h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216E864;  }
		/* 8216E898h case    6:*/		return 0x8216E89C;
		  /* 8216E89Ch */ case    7:  		/* b 1060 */
		/* 8216E89Ch case    7:*/		return 0x8216ECC0;
		/* 8216E89Ch case    7:*/		return 0x8216E8A0;
	}
	return 0x8216E8A0;
} // Block from 8216E880h-8216E8A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216E8A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E8A0);
		  /* 8216E8A0h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 8216E8A0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 8216E8A0h case    0:*/		return 0x8216E8A4;
		  /* 8216E8A4h */ case    1:  		/* mr R26, R25 */
		/* 8216E8A4h case    1:*/		regs.R26 = regs.R25;
		/* 8216E8A4h case    1:*/		return 0x8216E8A8;
		  /* 8216E8A8h */ case    2:  		/* addi R30, R11, 36 */
		/* 8216E8A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x24);
		/* 8216E8A8h case    2:*/		return 0x8216E8AC;
		  /* 8216E8ACh */ case    3:  		/* b 180 */
		/* 8216E8ACh case    3:*/		return 0x8216E960;
		/* 8216E8ACh case    3:*/		return 0x8216E8B0;
		  /* 8216E8B0h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216E8B0h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216E8B0h case    4:*/		return 0x8216E8B4;
		  /* 8216E8B4h */ case    5:  		/* addi R28, R11, -40 */
		/* 8216E8B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFD8);
		/* 8216E8B4h case    5:*/		return 0x8216E8B8;
		  /* 8216E8B8h */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 8216E8B8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8216E8B8h case    6:*/		return 0x8216E8BC;
		  /* 8216E8BCh */ case    7:  		/* bc 4, CR6_EQ, 88 */
		/* 8216E8BCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8216E914;  }
		/* 8216E8BCh case    7:*/		return 0x8216E8C0;
		  /* 8216E8C0h */ case    8:  		/* mr R4, R26 */
		/* 8216E8C0h case    8:*/		regs.R4 = regs.R26;
		/* 8216E8C0h case    8:*/		return 0x8216E8C4;
		  /* 8216E8C4h */ case    9:  		/* mr R3, R24 */
		/* 8216E8C4h case    9:*/		regs.R3 = regs.R24;
		/* 8216E8C4h case    9:*/		return 0x8216E8C8;
		  /* 8216E8C8h */ case   10:  		/* bl -6256 */
		/* 8216E8C8h case   10:*/		regs.LR = 0x8216E8CC; return 0x8216D058;
		/* 8216E8C8h case   10:*/		return 0x8216E8CC;
		  /* 8216E8CCh */ case   11:  		/* or. R26, R3, R3 */
		/* 8216E8CCh case   11:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 8216E8CCh case   11:*/		return 0x8216E8D0;
		  /* 8216E8D0h */ case   12:  		/* bc 12, CR0_EQ, 1008 */
		/* 8216E8D0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8216ECC0;  }
		/* 8216E8D0h case   12:*/		return 0x8216E8D4;
		  /* 8216E8D4h */ case   13:  		/* lwz R11, <#[R26 + 76]> */
		/* 8216E8D4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 8216E8D4h case   13:*/		return 0x8216E8D8;
		  /* 8216E8D8h */ case   14:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8216E8D8h case   14:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8216E8D8h case   14:*/		return 0x8216E8DC;
		  /* 8216E8DCh */ case   15:  		/* bc 4, CR0_EQ, 16 */
		/* 8216E8DCh case   15:*/		if ( !regs.CR[0].eq ) { return 0x8216E8EC;  }
		/* 8216E8DCh case   15:*/		return 0x8216E8E0;
		  /* 8216E8E0h */ case   16:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8216E8E0h case   16:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8216E8E0h case   16:*/		return 0x8216E8E4;
		  /* 8216E8E4h */ case   17:  		/* bc 12, CR0_EQ, -36 */
		/* 8216E8E4h case   17:*/		if ( regs.CR[0].eq ) { return 0x8216E8C0;  }
		/* 8216E8E4h case   17:*/		return 0x8216E8E8;
		  /* 8216E8E8h */ case   18:  		/* b 8 */
		/* 8216E8E8h case   18:*/		return 0x8216E8F0;
		/* 8216E8E8h case   18:*/		return 0x8216E8EC;
	}
	return 0x8216E8EC;
} // Block from 8216E8A0h-8216E8ECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216E8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E8EC);
		  /* 8216E8ECh */ case    0:  		/* mr R26, R21 */
		/* 8216E8ECh case    0:*/		regs.R26 = regs.R21;
		/* 8216E8ECh case    0:*/		return 0x8216E8F0;
	}
	return 0x8216E8F0;
} // Block from 8216E8ECh-8216E8F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E8F0);
		  /* 8216E8F0h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8216E8F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8216E8F0h case    0:*/		return 0x8216E8F4;
		  /* 8216E8F4h */ case    1:  		/* bc 12, CR6_EQ, 972 */
		/* 8216E8F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216ECC0;  }
		/* 8216E8F4h case    1:*/		return 0x8216E8F8;
		  /* 8216E8F8h */ case    2:  		/* lwz R11, <#[R26 + 28]> */
		/* 8216E8F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 8216E8F8h case    2:*/		return 0x8216E8FC;
		  /* 8216E8FCh */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216E8FCh case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216E8FCh case    3:*/		return 0x8216E900;
		  /* 8216E900h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8216E900h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216E90C;  }
		/* 8216E900h case    4:*/		return 0x8216E904;
		  /* 8216E904h */ case    5:  		/* mr R28, R21 */
		/* 8216E904h case    5:*/		regs.R28 = regs.R21;
		/* 8216E904h case    5:*/		return 0x8216E908;
		  /* 8216E908h */ case    6:  		/* b -80 */
		/* 8216E908h case    6:*/		return 0x8216E8B8;
		/* 8216E908h case    6:*/		return 0x8216E90C;
	}
	return 0x8216E90C;
} // Block from 8216E8F0h-8216E90Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216E90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E90C);
		  /* 8216E90Ch */ case    0:  		/* lwz R11, <#[R26 + 24]> */
		/* 8216E90Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 8216E90Ch case    0:*/		return 0x8216E910;
		  /* 8216E910h */ case    1:  		/* b -96 */
		/* 8216E910h case    1:*/		return 0x8216E8B0;
		/* 8216E910h case    1:*/		return 0x8216E914;
	}
	return 0x8216E914;
} // Block from 8216E90Ch-8216E914h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216E914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E914);
		  /* 8216E914h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8216E914h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8216E914h case    0:*/		return 0x8216E918;
		  /* 8216E918h */ case    1:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8216E918h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8216E918h case    1:*/		return 0x8216E91C;
		  /* 8216E91Ch */ case    2:  		/* cmplwi CR6, R10, 96 */
		/* 8216E91Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 8216E91Ch case    2:*/		return 0x8216E920;
		  /* 8216E920h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8216E920h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216E930;  }
		/* 8216E920h case    3:*/		return 0x8216E924;
		  /* 8216E924h */ case    4:  		/* cmplwi CR6, R10, 102 */
		/* 8216E924h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 8216E924h case    4:*/		return 0x8216E928;
		  /* 8216E928h */ case    5:  		/* mr R11, R20 */
		/* 8216E928h case    5:*/		regs.R11 = regs.R20;
		/* 8216E928h case    5:*/		return 0x8216E92C;
		  /* 8216E92Ch */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8216E92Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x8216E934;  }
		/* 8216E92Ch case    6:*/		return 0x8216E930;
	}
	return 0x8216E930;
} // Block from 8216E914h-8216E930h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216E930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E930);
		  /* 8216E930h */ case    0:  		/* mr R11, R21 */
		/* 8216E930h case    0:*/		regs.R11 = regs.R21;
		/* 8216E930h case    0:*/		return 0x8216E934;
	}
	return 0x8216E934;
} // Block from 8216E930h-8216E934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E934);
		  /* 8216E934h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216E934h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216E934h case    0:*/		return 0x8216E938;
		  /* 8216E938h */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 8216E938h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216E970;  }
		/* 8216E938h case    1:*/		return 0x8216E93C;
		  /* 8216E93Ch */ case    2:  		/* cmplwi CR6, R10, 91 */
		/* 8216E93Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005B);
		/* 8216E93Ch case    2:*/		return 0x8216E940;
		  /* 8216E940h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8216E940h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216E950;  }
		/* 8216E940h case    3:*/		return 0x8216E944;
		  /* 8216E944h */ case    4:  		/* cmplwi CR6, R10, 94 */
		/* 8216E944h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005E);
		/* 8216E944h case    4:*/		return 0x8216E948;
		  /* 8216E948h */ case    5:  		/* mr R11, R20 */
		/* 8216E948h case    5:*/		regs.R11 = regs.R20;
		/* 8216E948h case    5:*/		return 0x8216E94C;
		  /* 8216E94Ch */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8216E94Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x8216E954;  }
		/* 8216E94Ch case    6:*/		return 0x8216E950;
	}
	return 0x8216E950;
} // Block from 8216E934h-8216E950h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216E950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E950);
		  /* 8216E950h */ case    0:  		/* mr R11, R21 */
		/* 8216E950h case    0:*/		regs.R11 = regs.R21;
		/* 8216E950h case    0:*/		return 0x8216E954;
	}
	return 0x8216E954;
} // Block from 8216E950h-8216E954h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216E954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E954);
		  /* 8216E954h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216E954h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216E954h case    0:*/		return 0x8216E958;
		  /* 8216E958h */ case    1:  		/* bc 4, CR0_EQ, 872 */
		/* 8216E958h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216ECC0;  }
		/* 8216E958h case    1:*/		return 0x8216E95C;
		  /* 8216E95Ch */ case    2:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8216E95Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8216E95Ch case    2:*/		return 0x8216E960;
	}
	return 0x8216E960;
} // Block from 8216E954h-8216E960h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216E960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E960);
		  /* 8216E960h */ case    0:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216E960h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216E960h case    0:*/		return 0x8216E964;
		  /* 8216E964h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E964h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E964h case    1:*/		return 0x8216E968;
		  /* 8216E968h */ case    2:  		/* bc 12, CR0_EQ, -184 */
		/* 8216E968h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216E8B0;  }
		/* 8216E968h case    2:*/		return 0x8216E96C;
		  /* 8216E96Ch */ case    3:  		/* b -104 */
		/* 8216E96Ch case    3:*/		return 0x8216E904;
		/* 8216E96Ch case    3:*/		return 0x8216E970;
	}
	return 0x8216E970;
} // Block from 8216E960h-8216E970h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216E970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216E970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216E970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216E970);
		  /* 8216E970h */ case    0:  		/* lwz R11, <#[R26 + 48]> */
		/* 8216E970h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 8216E970h case    0:*/		return 0x8216E974;
		  /* 8216E974h */ case    1:  		/* li R4, 1 */
		/* 8216E974h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216E974h case    1:*/		return 0x8216E978;
		  /* 8216E978h */ case    2:  		/* mr R3, R24 */
		/* 8216E978h case    2:*/		regs.R3 = regs.R24;
		/* 8216E978h case    2:*/		return 0x8216E97C;
		  /* 8216E97Ch */ case    3:  		/* oris R11, R11, 16384 */
		/* 8216E97Ch case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 8216E97Ch case    3:*/		return 0x8216E980;
		  /* 8216E980h */ case    4:  		/* stw R11, <#[R26 + 48]> */
		/* 8216E980h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 8216E980h case    4:*/		return 0x8216E984;
		  /* 8216E984h */ case    5:  		/* bl 331316 */
		/* 8216E984h case    5:*/		regs.LR = 0x8216E988; return 0x821BF7B8;
		/* 8216E984h case    5:*/		return 0x8216E988;
		  /* 8216E988h */ case    6:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216E988h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216E988h case    6:*/		return 0x8216E98C;
		  /* 8216E98Ch */ case    7:  		/* mr R29, R21 */
		/* 8216E98Ch case    7:*/		regs.R29 = regs.R21;
		/* 8216E98Ch case    7:*/		return 0x8216E990;
		  /* 8216E990h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E990h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E990h case    8:*/		return 0x8216E994;
		  /* 8216E994h */ case    9:  		/* bc 4, CR0_EQ, 224 */
		/* 8216E994h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8216EA74;  }
		/* 8216E994h case    9:*/		return 0x8216E998;
		  /* 8216E998h */ case   10:  		/* mr R31, R11 */
		/* 8216E998h case   10:*/		regs.R31 = regs.R11;
		/* 8216E998h case   10:*/		return 0x8216E99C;
		  /* 8216E99Ch */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 8216E99Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E99Ch case   11:*/		return 0x8216E9A0;
		  /* 8216E9A0h */ case   12:  		/* bc 12, CR0_EQ, 212 */
		/* 8216E9A0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8216EA74;  }
		/* 8216E9A0h case   12:*/		return 0x8216E9A4;
		  /* 8216E9A4h */ case   13:  		/* lwz R11, <#[R31 + 48]> */
		/* 8216E9A4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8216E9A4h case   13:*/		return 0x8216E9A8;
		  /* 8216E9A8h */ case   14:  		/* rlwinm. R10, R11, 2, 31, 31 */
		/* 8216E9A8h case   14:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E9A8h case   14:*/		return 0x8216E9AC;
		  /* 8216E9ACh */ case   15:  		/* bc 12, CR0_EQ, 168 */
		/* 8216E9ACh case   15:*/		if ( regs.CR[0].eq ) { return 0x8216EA54;  }
		/* 8216E9ACh case   15:*/		return 0x8216E9B0;
		  /* 8216E9B0h */ case   16:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 8216E9B0h case   16:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 8216E9B0h case   16:*/		return 0x8216E9B4;
		  /* 8216E9B4h */ case   17:  		/* cmplw CR6, R25, R31 */
		/* 8216E9B4h case   17:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R31);
		/* 8216E9B4h case   17:*/		return 0x8216E9B8;
		  /* 8216E9B8h */ case   18:  		/* stw R11, <#[R31 + 48]> */
		/* 8216E9B8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8216E9B8h case   18:*/		return 0x8216E9BC;
		  /* 8216E9BCh */ case   19:  		/* bc 12, CR6_EQ, 152 */
		/* 8216E9BCh case   19:*/		if ( regs.CR[6].eq ) { return 0x8216EA54;  }
		/* 8216E9BCh case   19:*/		return 0x8216E9C0;
		  /* 8216E9C0h */ case   20:  		/* lwz R11, <#[R26 + 48]> */
		/* 8216E9C0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 8216E9C0h case   20:*/		return 0x8216E9C4;
		  /* 8216E9C4h */ case   21:  		/* lwz R10, <#[R31 + 40]> */
		/* 8216E9C4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 8216E9C4h case   21:*/		return 0x8216E9C8;
		  /* 8216E9C8h */ case   22:  		/* rlwinm R9, R11, 0, 13, 31 */
		/* 8216E9C8h case   22:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 8216E9C8h case   22:*/		return 0x8216E9CC;
		  /* 8216E9CCh */ case   23:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 8216E9CCh case   23:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 8216E9CCh case   23:*/		return 0x8216E9D0;
		  /* 8216E9D0h */ case   24:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8216E9D0h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8216E9D0h case   24:*/		return 0x8216E9D4;
		  /* 8216E9D4h */ case   25:  		/* addi R11, R11, 1 */
		/* 8216E9D4h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216E9D4h case   25:*/		return 0x8216E9D8;
		  /* 8216E9D8h */ case   26:  		/* slw R9, R20, R9 */
		/* 8216E9D8h case   26:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R20,regs.R9);
		/* 8216E9D8h case   26:*/		return 0x8216E9DC;
		  /* 8216E9DCh */ case   27:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216E9DCh case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216E9DCh case   27:*/		return 0x8216E9E0;
		  /* 8216E9E0h */ case   28:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8216E9E0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8216E9E0h case   28:*/		return 0x8216E9E4;
		  /* 8216E9E4h */ case   29:  		/* and. R11, R11, R9 */
		/* 8216E9E4h case   29:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216E9E4h case   29:*/		return 0x8216E9E8;
		  /* 8216E9E8h */ case   30:  		/* bc 4, CR0_EQ, 108 */
		/* 8216E9E8h case   30:*/		if ( !regs.CR[0].eq ) { return 0x8216EA54;  }
		/* 8216E9E8h case   30:*/		return 0x8216E9EC;
		  /* 8216E9ECh */ case   31:  		/* lwz R11, <#[R31 + 28]> */
		/* 8216E9ECh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8216E9ECh case   31:*/		return 0x8216E9F0;
		  /* 8216E9F0h */ case   32:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216E9F0h case   32:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216E9F0h case   32:*/		return 0x8216E9F4;
		  /* 8216E9F4h */ case   33:  		/* bc 4, CR0_EQ, 96 */
		/* 8216E9F4h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8216EA54;  }
		/* 8216E9F4h case   33:*/		return 0x8216E9F8;
		  /* 8216E9F8h */ case   34:  		/* cmplwi CR0, R11, 0 */
		/* 8216E9F8h case   34:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216E9F8h case   34:*/		return 0x8216E9FC;
		  /* 8216E9FCh */ case   35:  		/* bc 12, CR0_EQ, 88 */
		/* 8216E9FCh case   35:*/		if ( regs.CR[0].eq ) { return 0x8216EA54;  }
		/* 8216E9FCh case   35:*/		return 0x8216EA00;
		  /* 8216EA00h */ case   36:  		/* lwz R10, <#[R11 + 8]> */
		/* 8216EA00h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8216EA00h case   36:*/		return 0x8216EA04;
		  /* 8216EA04h */ case   37:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8216EA04h case   37:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8216EA04h case   37:*/		return 0x8216EA08;
		  /* 8216EA08h */ case   38:  		/* cmplwi CR6, R10, 11904 */
		/* 8216EA08h case   38:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002E80);
		/* 8216EA08h case   38:*/		return 0x8216EA0C;
		  /* 8216EA0Ch */ case   39:  		/* bc 12, CR6_EQ, 32 */
		/* 8216EA0Ch case   39:*/		if ( regs.CR[6].eq ) { return 0x8216EA2C;  }
		/* 8216EA0Ch case   39:*/		return 0x8216EA10;
		  /* 8216EA10h */ case   40:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216EA10h case   40:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216EA10h case   40:*/		return 0x8216EA14;
		  /* 8216EA14h */ case   41:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216EA14h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216EA14h case   41:*/		return 0x8216EA18;
		  /* 8216EA18h */ case   42:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216EA18h case   42:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216EA18h case   42:*/		return 0x8216EA1C;
		  /* 8216EA1Ch */ case   43:  		/* bc 4, CR0_EQ, 56 */
		/* 8216EA1Ch case   43:*/		if ( !regs.CR[0].eq ) { return 0x8216EA54;  }
		/* 8216EA1Ch case   43:*/		return 0x8216EA20;
		  /* 8216EA20h */ case   44:  		/* cmplwi CR6, R11, 0 */
		/* 8216EA20h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216EA20h case   44:*/		return 0x8216EA24;
		  /* 8216EA24h */ case   45:  		/* bc 4, CR6_EQ, -36 */
		/* 8216EA24h case   45:*/		if ( !regs.CR[6].eq ) { return 0x8216EA00;  }
		/* 8216EA24h case   45:*/		return 0x8216EA28;
		  /* 8216EA28h */ case   46:  		/* b 44 */
		/* 8216EA28h case   46:*/		return 0x8216EA54;
		/* 8216EA28h case   46:*/		return 0x8216EA2C;
	}
	return 0x8216EA2C;
} // Block from 8216E970h-8216EA2Ch (47 instructions)

//////////////////////////////////////////////////////
// Block at 8216EA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EA2C);
		  /* 8216EA2Ch */ case    0:  		/* mr R4, R31 */
		/* 8216EA2Ch case    0:*/		regs.R4 = regs.R31;
		/* 8216EA2Ch case    0:*/		return 0x8216EA30;
		  /* 8216EA30h */ case    1:  		/* mr R3, R24 */
		/* 8216EA30h case    1:*/		regs.R3 = regs.R24;
		/* 8216EA30h case    1:*/		return 0x8216EA34;
		  /* 8216EA34h */ case    2:  		/* bl -6620 */
		/* 8216EA34h case    2:*/		regs.LR = 0x8216EA38; return 0x8216D058;
		/* 8216EA34h case    2:*/		return 0x8216EA38;
		  /* 8216EA38h */ case    3:  		/* or. R4, R3, R3 */
		/* 8216EA38h case    3:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 8216EA38h case    3:*/		return 0x8216EA3C;
		  /* 8216EA3Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8216EA3Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8216EA48;  }
		/* 8216EA3Ch case    4:*/		return 0x8216EA40;
		  /* 8216EA40h */ case    5:  		/* cmplw CR6, R4, R26 */
		/* 8216EA40h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R26);
		/* 8216EA40h case    5:*/		return 0x8216EA44;
		  /* 8216EA44h */ case    6:  		/* bc 4, CR6_EQ, -20 */
		/* 8216EA44h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216EA30;  }
		/* 8216EA44h case    6:*/		return 0x8216EA48;
	}
	return 0x8216EA48;
} // Block from 8216EA2Ch-8216EA48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216EA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EA48);
		  /* 8216EA48h */ case    0:  		/* cmplw CR6, R4, R26 */
		/* 8216EA48h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R26);
		/* 8216EA48h case    0:*/		return 0x8216EA4C;
		  /* 8216EA4Ch */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8216EA4Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8216EA54;  }
		/* 8216EA4Ch case    1:*/		return 0x8216EA50;
		  /* 8216EA50h */ case    2:  		/* mr R29, R31 */
		/* 8216EA50h case    2:*/		regs.R29 = regs.R31;
		/* 8216EA50h case    2:*/		return 0x8216EA54;
	}
	return 0x8216EA54;
} // Block from 8216EA48h-8216EA54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216EA54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EA54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EA54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EA54);
		  /* 8216EA54h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216EA54h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216EA54h case    0:*/		return 0x8216EA58;
		  /* 8216EA58h */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 8216EA58h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8216EA58h case    1:*/		return 0x8216EA5C;
		  /* 8216EA5Ch */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216EA5Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216EA5Ch case    2:*/		return 0x8216EA60;
		  /* 8216EA60h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8216EA60h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216EA6C;  }
		/* 8216EA60h case    3:*/		return 0x8216EA64;
		  /* 8216EA64h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216EA64h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216EA64h case    4:*/		return 0x8216EA68;
		  /* 8216EA68h */ case    5:  		/* bc 4, CR6_EQ, -196 */
		/* 8216EA68h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216E9A4;  }
		/* 8216EA68h case    5:*/		return 0x8216EA6C;
	}
	return 0x8216EA6C;
} // Block from 8216EA54h-8216EA6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216EA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EA6C);
		  /* 8216EA6Ch */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8216EA6Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8216EA6Ch case    0:*/		return 0x8216EA70;
		  /* 8216EA70h */ case    1:  		/* bc 4, CR6_EQ, 592 */
		/* 8216EA70h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216ECC0;  }
		/* 8216EA70h case    1:*/		return 0x8216EA74;
	}
	return 0x8216EA74;
} // Block from 8216EA6Ch-8216EA74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216EA74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EA74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EA74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EA74);
		  /* 8216EA74h */ case    0:  		/* lwz R9, <#[R30 + 4]> */
		/* 8216EA74h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 8216EA74h case    0:*/		return 0x8216EA78;
		  /* 8216EA78h */ case    1:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8216EA78h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8216EA78h case    1:*/		return 0x8216EA7C;
		  /* 8216EA7Ch */ case    2:  		/* lwz R8, <#[R30]> */
		/* 8216EA7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 8216EA7Ch case    2:*/		return 0x8216EA80;
		  /* 8216EA80h */ case    3:  		/* addi R10, R30, 4 */
		/* 8216EA80h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x4);
		/* 8216EA80h case    3:*/		return 0x8216EA84;
		  /* 8216EA84h */ case    4:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 8216EA84h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 8216EA84h case    4:*/		return 0x8216EA88;
		  /* 8216EA88h */ case    5:  		/* addi R11, R11, 36 */
		/* 8216EA88h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8216EA88h case    5:*/		return 0x8216EA8C;
		  /* 8216EA8Ch */ case    6:  		/* addi R6, R30, -36 */
		/* 8216EA8Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R30,0xFFFFFFDC);
		/* 8216EA8Ch case    6:*/		return 0x8216EA90;
		  /* 8216EA90h */ case    7:  		/* addi R9, R11, 4 */
		/* 8216EA90h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8216EA90h case    7:*/		return 0x8216EA94;
		  /* 8216EA94h */ case    8:  		/* cmplw CR6, R25, R26 */
		/* 8216EA94h case    8:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R26);
		/* 8216EA94h case    8:*/		return 0x8216EA98;
		  /* 8216EA98h */ case    9:  		/* stw R8, <#[R7 + 36]> */
		/* 8216EA98h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 8216EA98h case    9:*/		return 0x8216EA9C;
		  /* 8216EA9Ch */ case   10:  		/* lwz R8, <#[R30]> */
		/* 8216EA9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 8216EA9Ch case   10:*/		return 0x8216EAA0;
		  /* 8216EAA0h */ case   11:  		/* lwz R7, <#[R30 + 4]> */
		/* 8216EAA0h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000004) );
		/* 8216EAA0h case   11:*/		return 0x8216EAA4;
		  /* 8216EAA4h */ case   12:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 8216EAA4h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 8216EAA4h case   12:*/		return 0x8216EAA8;
		  /* 8216EAA8h */ case   13:  		/* stw R7, <#[R8]> */
		/* 8216EAA8h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 8216EAA8h case   13:*/		return 0x8216EAAC;
		  /* 8216EAACh */ case   14:  		/* lwz R8, <#[R11 + 4]> */
		/* 8216EAACh case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8216EAACh case   14:*/		return 0x8216EAB0;
		  /* 8216EAB0h */ case   15:  		/* stw R8, <#[R30 + 4]> */
		/* 8216EAB0h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		/* 8216EAB0h case   15:*/		return 0x8216EAB4;
		  /* 8216EAB4h */ case   16:  		/* lwz R8, <#[R11 + 4]> */
		/* 8216EAB4h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8216EAB4h case   16:*/		return 0x8216EAB8;
		  /* 8216EAB8h */ case   17:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 8216EAB8h case   17:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 8216EAB8h case   17:*/		return 0x8216EABC;
		  /* 8216EABCh */ case   18:  		/* stw R10, <#[R8 + 36]> */
		/* 8216EABCh case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000024) );
		/* 8216EABCh case   18:*/		return 0x8216EAC0;
		  /* 8216EAC0h */ case   19:  		/* stw R9, <#[R30]> */
		/* 8216EAC0h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8216EAC0h case   19:*/		return 0x8216EAC4;
		  /* 8216EAC4h */ case   20:  		/* stw R6, <#[R11 + 4]> */
		/* 8216EAC4h case   20:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8216EAC4h case   20:*/		return 0x8216EAC8;
		  /* 8216EAC8h */ case   21:  		/* stw R26, <#[R27 + 28]> */
		/* 8216EAC8h case   21:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R27 + 0x0000001C) );
		/* 8216EAC8h case   21:*/		return 0x8216EACC;
		  /* 8216EACCh */ case   22:  		/* bc 12, CR6_EQ, 120 */
		/* 8216EACCh case   22:*/		if ( regs.CR[6].eq ) { return 0x8216EB44;  }
		/* 8216EACCh case   22:*/		return 0x8216EAD0;
		  /* 8216EAD0h */ case   23:  		/* addi R29, R27, 4 */
		/* 8216EAD0h case   23:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x4);
		/* 8216EAD0h case   23:*/		return 0x8216EAD4;
		  /* 8216EAD4h */ case   24:  		/* lwz R30, <#[R29]> */
		/* 8216EAD4h case   24:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 8216EAD4h case   24:*/		return 0x8216EAD8;
		  /* 8216EAD8h */ case   25:  		/* cmplwi CR6, R30, 0 */
		/* 8216EAD8h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216EAD8h case   25:*/		return 0x8216EADC;
		  /* 8216EADCh */ case   26:  		/* bc 12, CR6_EQ, 104 */
		/* 8216EADCh case   26:*/		if ( regs.CR[6].eq ) { return 0x8216EB44;  }
		/* 8216EADCh case   26:*/		return 0x8216EAE0;
		  /* 8216EAE0h */ case   27:  		/* lwz R31, <#[R30 + 16]> */
		/* 8216EAE0h case   27:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 8216EAE0h case   27:*/		return 0x8216EAE4;
		  /* 8216EAE4h */ case   28:  		/* cmplwi CR6, R31, 0 */
		/* 8216EAE4h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216EAE4h case   28:*/		return 0x8216EAE8;
		  /* 8216EAE8h */ case   29:  		/* bc 12, CR6_EQ, 72 */
		/* 8216EAE8h case   29:*/		if ( regs.CR[6].eq ) { return 0x8216EB30;  }
		/* 8216EAE8h case   29:*/		return 0x8216EAEC;
		  /* 8216EAECh */ case   30:  		/* mr R5, R24 */
		/* 8216EAECh case   30:*/		regs.R5 = regs.R24;
		/* 8216EAECh case   30:*/		return 0x8216EAF0;
		  /* 8216EAF0h */ case   31:  		/* mr R4, R30 */
		/* 8216EAF0h case   31:*/		regs.R4 = regs.R30;
		/* 8216EAF0h case   31:*/		return 0x8216EAF4;
		  /* 8216EAF4h */ case   32:  		/* mr R3, R31 */
		/* 8216EAF4h case   32:*/		regs.R3 = regs.R31;
		/* 8216EAF4h case   32:*/		return 0x8216EAF8;
		  /* 8216EAF8h */ case   33:  		/* bl 40472 */
		/* 8216EAF8h case   33:*/		regs.LR = 0x8216EAFC; return 0x82178910;
		/* 8216EAF8h case   33:*/		return 0x8216EAFC;
		  /* 8216EAFCh */ case   34:  		/* mr R3, R31 */
		/* 8216EAFCh case   34:*/		regs.R3 = regs.R31;
		/* 8216EAFCh case   34:*/		return 0x8216EB00;
		  /* 8216EB00h */ case   35:  		/* bl -41344 */
		/* 8216EB00h case   35:*/		regs.LR = 0x8216EB04; return 0x82164980;
		/* 8216EB00h case   35:*/		return 0x8216EB04;
		  /* 8216EB04h */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216EB04h case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216EB04h case   36:*/		return 0x8216EB08;
		  /* 8216EB08h */ case   37:  		/* bc 12, CR0_EQ, 40 */
		/* 8216EB08h case   37:*/		if ( regs.CR[0].eq ) { return 0x8216EB30;  }
		/* 8216EB08h case   37:*/		return 0x8216EB0C;
		  /* 8216EB0Ch */ case   38:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216EB0Ch case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216EB0Ch case   38:*/		return 0x8216EB10;
		  /* 8216EB10h */ case   39:  		/* mr R3, R24 */
		/* 8216EB10h case   39:*/		regs.R3 = regs.R24;
		/* 8216EB10h case   39:*/		return 0x8216EB14;
		  /* 8216EB14h */ case   40:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216EB14h case   40:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216EB14h case   40:*/		return 0x8216EB18;
		  /* 8216EB18h */ case   41:  		/* cmplwi CR6, R11, 14976 */
		/* 8216EB18h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 8216EB18h case   41:*/		return 0x8216EB1C;
		  /* 8216EB1Ch */ case   42:  		/* bc 4, CR6_EQ, 456 */
		/* 8216EB1Ch case   42:*/		if ( !regs.CR[6].eq ) { return 0x8216ECE4;  }
		/* 8216EB1Ch case   42:*/		return 0x8216EB20;
		  /* 8216EB20h */ case   43:  		/* li R6, 1 */
		/* 8216EB20h case   43:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216EB20h case   43:*/		return 0x8216EB24;
		  /* 8216EB24h */ case   44:  		/* li R5, 0 */
		/* 8216EB24h case   44:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216EB24h case   44:*/		return 0x8216EB28;
		  /* 8216EB28h */ case   45:  		/* mr R4, R31 */
		/* 8216EB28h case   45:*/		regs.R4 = regs.R31;
		/* 8216EB28h case   45:*/		return 0x8216EB2C;
		  /* 8216EB2Ch */ case   46:  		/* bl 772252 */
		/* 8216EB2Ch case   46:*/		regs.LR = 0x8216EB30; return 0x8222B3C8;
		/* 8216EB2Ch case   46:*/		return 0x8216EB30;
	}
	return 0x8216EB30;
} // Block from 8216EA74h-8216EB30h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8216EB30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EB30);
		  /* 8216EB30h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8216EB30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216EB30h case    0:*/		return 0x8216EB34;
		  /* 8216EB34h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 8216EB34h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8216EB34h case    1:*/		return 0x8216EB38;
		  /* 8216EB38h */ case    2:  		/* bc 4, CR6_EQ, -100 */
		/* 8216EB38h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216EAD4;  }
		/* 8216EB38h case    2:*/		return 0x8216EB3C;
		  /* 8216EB3Ch */ case    3:  		/* addi R29, R30, 8 */
		/* 8216EB3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x8);
		/* 8216EB3Ch case    3:*/		return 0x8216EB40;
		  /* 8216EB40h */ case    4:  		/* b -108 */
		/* 8216EB40h case    4:*/		return 0x8216EAD4;
		/* 8216EB40h case    4:*/		return 0x8216EB44;
	}
	return 0x8216EB44;
} // Block from 8216EB30h-8216EB44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216EB44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EB44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EB44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EB44);
		  /* 8216EB44h */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216EB44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216EB44h case    0:*/		return 0x8216EB48;
		  /* 8216EB48h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216EB48h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216EB48h case    1:*/		return 0x8216EB4C;
		  /* 8216EB4Ch */ case    2:  		/* bc 4, CR0_EQ, 340 */
		/* 8216EB4Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216ECA0;  }
		/* 8216EB4Ch case    2:*/		return 0x8216EB50;
		  /* 8216EB50h */ case    3:  		/* mr R28, R11 */
		/* 8216EB50h case    3:*/		regs.R28 = regs.R11;
		/* 8216EB50h case    3:*/		return 0x8216EB54;
		  /* 8216EB54h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 8216EB54h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216EB54h case    4:*/		return 0x8216EB58;
		  /* 8216EB58h */ case    5:  		/* bc 12, CR0_EQ, 328 */
		/* 8216EB58h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216ECA0;  }
		/* 8216EB58h case    5:*/		return 0x8216EB5C;
		  /* 8216EB5Ch */ case    6:  		/* cmplw CR6, R26, R28 */
		/* 8216EB5Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R28);
		/* 8216EB5Ch case    6:*/		return 0x8216EB60;
		  /* 8216EB60h */ case    7:  		/* bc 12, CR6_EQ, 292 */
		/* 8216EB60h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216EC84;  }
		/* 8216EB60h case    7:*/		return 0x8216EB64;
		  /* 8216EB64h */ case    8:  		/* lwz R11, <#[R28 + 28]> */
		/* 8216EB64h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000001C) );
		/* 8216EB64h case    8:*/		return 0x8216EB68;
		  /* 8216EB68h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216EB68h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216EB68h case    9:*/		return 0x8216EB6C;
		  /* 8216EB6Ch */ case   10:  		/* bc 4, CR0_EQ, 280 */
		/* 8216EB6Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216EC84;  }
		/* 8216EB6Ch case   10:*/		return 0x8216EB70;
		  /* 8216EB70h */ case   11:  		/* mr R27, R11 */
		/* 8216EB70h case   11:*/		regs.R27 = regs.R11;
		/* 8216EB70h case   11:*/		return 0x8216EB74;
		  /* 8216EB74h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 8216EB74h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216EB74h case   12:*/		return 0x8216EB78;
		  /* 8216EB78h */ case   13:  		/* bc 12, CR0_EQ, 268 */
		/* 8216EB78h case   13:*/		if ( regs.CR[0].eq ) { return 0x8216EC84;  }
		/* 8216EB78h case   13:*/		return 0x8216EB7C;
		  /* 8216EB7Ch */ case   14:  		/* lwz R11, <#[R27 + 8]> */
		/* 8216EB7Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8216EB7Ch case   14:*/		return 0x8216EB80;
		  /* 8216EB80h */ case   15:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216EB80h case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216EB80h case   15:*/		return 0x8216EB84;
		  /* 8216EB84h */ case   16:  		/* cmplwi CR6, R11, 11904 */
		/* 8216EB84h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002E80);
		/* 8216EB84h case   16:*/		return 0x8216EB88;
		  /* 8216EB88h */ case   17:  		/* bc 12, CR6_EQ, 36 */
		/* 8216EB88h case   17:*/		if ( regs.CR[6].eq ) { return 0x8216EBAC;  }
		/* 8216EB88h case   17:*/		return 0x8216EB8C;
		  /* 8216EB8Ch */ case   18:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 8216EB8Ch case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 8216EB8Ch case   18:*/		return 0x8216EB90;
		  /* 8216EB90h */ case   19:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216EB90h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216EB90h case   19:*/		return 0x8216EB94;
		  /* 8216EB94h */ case   20:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216EB94h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216EB94h case   20:*/		return 0x8216EB98;
		  /* 8216EB98h */ case   21:  		/* bc 4, CR0_EQ, 236 */
		/* 8216EB98h case   21:*/		if ( !regs.CR[0].eq ) { return 0x8216EC84;  }
		/* 8216EB98h case   21:*/		return 0x8216EB9C;
		  /* 8216EB9Ch */ case   22:  		/* mr R27, R11 */
		/* 8216EB9Ch case   22:*/		regs.R27 = regs.R11;
		/* 8216EB9Ch case   22:*/		return 0x8216EBA0;
		  /* 8216EBA0h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 8216EBA0h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216EBA0h case   23:*/		return 0x8216EBA4;
		  /* 8216EBA4h */ case   24:  		/* bc 4, CR6_EQ, -40 */
		/* 8216EBA4h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8216EB7C;  }
		/* 8216EBA4h case   24:*/		return 0x8216EBA8;
		  /* 8216EBA8h */ case   25:  		/* b 220 */
		/* 8216EBA8h case   25:*/		return 0x8216EC84;
		/* 8216EBA8h case   25:*/		return 0x8216EBAC;
	}
	return 0x8216EBAC;
} // Block from 8216EB44h-8216EBACh (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216EBACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EBAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EBAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EBAC);
		  /* 8216EBACh */ case    0:  		/* lwz R11, <#[R26 + 48]> */
		/* 8216EBACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 8216EBACh case    0:*/		return 0x8216EBB0;
		  /* 8216EBB0h */ case    1:  		/* lwz R10, <#[R28 + 40]> */
		/* 8216EBB0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000028) );
		/* 8216EBB0h case    1:*/		return 0x8216EBB4;
		  /* 8216EBB4h */ case    2:  		/* rlwinm R9, R11, 0, 13, 31 */
		/* 8216EBB4h case    2:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 8216EBB4h case    2:*/		return 0x8216EBB8;
		  /* 8216EBB8h */ case    3:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 8216EBB8h case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 8216EBB8h case    3:*/		return 0x8216EBBC;
		  /* 8216EBBCh */ case    4:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8216EBBCh case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8216EBBCh case    4:*/		return 0x8216EBC0;
		  /* 8216EBC0h */ case    5:  		/* addi R11, R11, 1 */
		/* 8216EBC0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216EBC0h case    5:*/		return 0x8216EBC4;
		  /* 8216EBC4h */ case    6:  		/* slw R9, R20, R9 */
		/* 8216EBC4h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R20,regs.R9);
		/* 8216EBC4h case    6:*/		return 0x8216EBC8;
		  /* 8216EBC8h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216EBC8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216EBC8h case    7:*/		return 0x8216EBCC;
		  /* 8216EBCCh */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8216EBCCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8216EBCCh case    8:*/		return 0x8216EBD0;
		  /* 8216EBD0h */ case    9:  		/* and. R11, R11, R9 */
		/* 8216EBD0h case    9:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216EBD0h case    9:*/		return 0x8216EBD4;
		  /* 8216EBD4h */ case   10:  		/* bc 4, CR0_EQ, 40 */
		/* 8216EBD4h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216EBFC;  }
		/* 8216EBD4h case   10:*/		return 0x8216EBD8;
		  /* 8216EBD8h */ case   11:  		/* mr R4, R28 */
		/* 8216EBD8h case   11:*/		regs.R4 = regs.R28;
		/* 8216EBD8h case   11:*/		return 0x8216EBDC;
		  /* 8216EBDCh */ case   12:  		/* mr R3, R24 */
		/* 8216EBDCh case   12:*/		regs.R3 = regs.R24;
		/* 8216EBDCh case   12:*/		return 0x8216EBE0;
		  /* 8216EBE0h */ case   13:  		/* bl -7048 */
		/* 8216EBE0h case   13:*/		regs.LR = 0x8216EBE4; return 0x8216D058;
		/* 8216EBE0h case   13:*/		return 0x8216EBE4;
		  /* 8216EBE4h */ case   14:  		/* or. R4, R3, R3 */
		/* 8216EBE4h case   14:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 8216EBE4h case   14:*/		return 0x8216EBE8;
		  /* 8216EBE8h */ case   15:  		/* bc 12, CR0_EQ, 12 */
		/* 8216EBE8h case   15:*/		if ( regs.CR[0].eq ) { return 0x8216EBF4;  }
		/* 8216EBE8h case   15:*/		return 0x8216EBEC;
		  /* 8216EBECh */ case   16:  		/* cmplw CR6, R4, R26 */
		/* 8216EBECh case   16:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R26);
		/* 8216EBECh case   16:*/		return 0x8216EBF0;
		  /* 8216EBF0h */ case   17:  		/* bc 4, CR6_EQ, -20 */
		/* 8216EBF0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216EBDC;  }
		/* 8216EBF0h case   17:*/		return 0x8216EBF4;
	}
	return 0x8216EBF4;
} // Block from 8216EBACh-8216EBF4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8216EBF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EBF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EBF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EBF4);
		  /* 8216EBF4h */ case    0:  		/* cmplw CR6, R4, R26 */
		/* 8216EBF4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R26);
		/* 8216EBF4h case    0:*/		return 0x8216EBF8;
		  /* 8216EBF8h */ case    1:  		/* bc 4, CR6_EQ, 140 */
		/* 8216EBF8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216EC84;  }
		/* 8216EBF8h case    1:*/		return 0x8216EBFC;
	}
	return 0x8216EBFC;
} // Block from 8216EBF4h-8216EBFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216EBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EBFC);
		  /* 8216EBFCh */ case    0:  		/* addi R29, R27, 4 */
		/* 8216EBFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x4);
		/* 8216EBFCh case    0:*/		return 0x8216EC00;
		  /* 8216EC00h */ case    1:  		/* lwz R30, <#[R29]> */
		/* 8216EC00h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 8216EC00h case    1:*/		return 0x8216EC04;
		  /* 8216EC04h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 8216EC04h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216EC04h case    2:*/		return 0x8216EC08;
		  /* 8216EC08h */ case    3:  		/* bc 12, CR6_EQ, 104 */
		/* 8216EC08h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216EC70;  }
		/* 8216EC08h case    3:*/		return 0x8216EC0C;
		  /* 8216EC0Ch */ case    4:  		/* lwz R31, <#[R30 + 16]> */
		/* 8216EC0Ch case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 8216EC0Ch case    4:*/		return 0x8216EC10;
		  /* 8216EC10h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 8216EC10h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216EC10h case    5:*/		return 0x8216EC14;
		  /* 8216EC14h */ case    6:  		/* bc 12, CR6_EQ, 72 */
		/* 8216EC14h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216EC5C;  }
		/* 8216EC14h case    6:*/		return 0x8216EC18;
		  /* 8216EC18h */ case    7:  		/* mr R5, R24 */
		/* 8216EC18h case    7:*/		regs.R5 = regs.R24;
		/* 8216EC18h case    7:*/		return 0x8216EC1C;
		  /* 8216EC1Ch */ case    8:  		/* mr R4, R30 */
		/* 8216EC1Ch case    8:*/		regs.R4 = regs.R30;
		/* 8216EC1Ch case    8:*/		return 0x8216EC20;
		  /* 8216EC20h */ case    9:  		/* mr R3, R31 */
		/* 8216EC20h case    9:*/		regs.R3 = regs.R31;
		/* 8216EC20h case    9:*/		return 0x8216EC24;
		  /* 8216EC24h */ case   10:  		/* bl 40172 */
		/* 8216EC24h case   10:*/		regs.LR = 0x8216EC28; return 0x82178910;
		/* 8216EC24h case   10:*/		return 0x8216EC28;
		  /* 8216EC28h */ case   11:  		/* mr R3, R31 */
		/* 8216EC28h case   11:*/		regs.R3 = regs.R31;
		/* 8216EC28h case   11:*/		return 0x8216EC2C;
		  /* 8216EC2Ch */ case   12:  		/* bl -41644 */
		/* 8216EC2Ch case   12:*/		regs.LR = 0x8216EC30; return 0x82164980;
		/* 8216EC2Ch case   12:*/		return 0x8216EC30;
		  /* 8216EC30h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216EC30h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216EC30h case   13:*/		return 0x8216EC34;
		  /* 8216EC34h */ case   14:  		/* bc 12, CR0_EQ, 40 */
		/* 8216EC34h case   14:*/		if ( regs.CR[0].eq ) { return 0x8216EC5C;  }
		/* 8216EC34h case   14:*/		return 0x8216EC38;
		  /* 8216EC38h */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216EC38h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216EC38h case   15:*/		return 0x8216EC3C;
		  /* 8216EC3Ch */ case   16:  		/* mr R3, R24 */
		/* 8216EC3Ch case   16:*/		regs.R3 = regs.R24;
		/* 8216EC3Ch case   16:*/		return 0x8216EC40;
		  /* 8216EC40h */ case   17:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216EC40h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216EC40h case   17:*/		return 0x8216EC44;
		  /* 8216EC44h */ case   18:  		/* cmplwi CR6, R11, 14976 */
		/* 8216EC44h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 8216EC44h case   18:*/		return 0x8216EC48;
		  /* 8216EC48h */ case   19:  		/* bc 4, CR6_EQ, 164 */
		/* 8216EC48h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8216ECEC;  }
		/* 8216EC48h case   19:*/		return 0x8216EC4C;
		  /* 8216EC4Ch */ case   20:  		/* li R6, 1 */
		/* 8216EC4Ch case   20:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216EC4Ch case   20:*/		return 0x8216EC50;
		  /* 8216EC50h */ case   21:  		/* li R5, 0 */
		/* 8216EC50h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216EC50h case   21:*/		return 0x8216EC54;
		  /* 8216EC54h */ case   22:  		/* mr R4, R31 */
		/* 8216EC54h case   22:*/		regs.R4 = regs.R31;
		/* 8216EC54h case   22:*/		return 0x8216EC58;
		  /* 8216EC58h */ case   23:  		/* bl 771952 */
		/* 8216EC58h case   23:*/		regs.LR = 0x8216EC5C; return 0x8222B3C8;
		/* 8216EC58h case   23:*/		return 0x8216EC5C;
	}
	return 0x8216EC5C;
} // Block from 8216EBFCh-8216EC5Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8216EC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EC5C);
		  /* 8216EC5Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8216EC5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216EC5Ch case    0:*/		return 0x8216EC60;
		  /* 8216EC60h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 8216EC60h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8216EC60h case    1:*/		return 0x8216EC64;
		  /* 8216EC64h */ case    2:  		/* bc 4, CR6_EQ, -100 */
		/* 8216EC64h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216EC00;  }
		/* 8216EC64h case    2:*/		return 0x8216EC68;
		  /* 8216EC68h */ case    3:  		/* addi R29, R30, 8 */
		/* 8216EC68h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x8);
		/* 8216EC68h case    3:*/		return 0x8216EC6C;
		  /* 8216EC6Ch */ case    4:  		/* b -108 */
		/* 8216EC6Ch case    4:*/		return 0x8216EC00;
		/* 8216EC6Ch case    4:*/		return 0x8216EC70;
	}
	return 0x8216EC70;
} // Block from 8216EC5Ch-8216EC70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216EC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EC70);
		  /* 8216EC70h */ case    0:  		/* li R6, 1 */
		/* 8216EC70h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216EC70h case    0:*/		return 0x8216EC74;
		  /* 8216EC74h */ case    1:  		/* li R5, 0 */
		/* 8216EC74h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216EC74h case    1:*/		return 0x8216EC78;
		  /* 8216EC78h */ case    2:  		/* mr R4, R27 */
		/* 8216EC78h case    2:*/		regs.R4 = regs.R27;
		/* 8216EC78h case    2:*/		return 0x8216EC7C;
		  /* 8216EC7Ch */ case    3:  		/* mr R3, R24 */
		/* 8216EC7Ch case    3:*/		regs.R3 = regs.R24;
		/* 8216EC7Ch case    3:*/		return 0x8216EC80;
		  /* 8216EC80h */ case    4:  		/* bl 771912 */
		/* 8216EC80h case    4:*/		regs.LR = 0x8216EC84; return 0x8222B3C8;
		/* 8216EC80h case    4:*/		return 0x8216EC84;
	}
	return 0x8216EC84;
} // Block from 8216EC70h-8216EC84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216EC84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EC84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EC84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EC84);
		  /* 8216EC84h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8216EC84h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8216EC84h case    0:*/		return 0x8216EC88;
		  /* 8216EC88h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216EC88h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216EC88h case    1:*/		return 0x8216EC8C;
		  /* 8216EC8Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216EC8Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216EC8Ch case    2:*/		return 0x8216EC90;
		  /* 8216EC90h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216EC90h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216ECA0;  }
		/* 8216EC90h case    3:*/		return 0x8216EC94;
		  /* 8216EC94h */ case    4:  		/* mr R28, R11 */
		/* 8216EC94h case    4:*/		regs.R28 = regs.R11;
		/* 8216EC94h case    4:*/		return 0x8216EC98;
		  /* 8216EC98h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216EC98h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216EC98h case    5:*/		return 0x8216EC9C;
		  /* 8216EC9Ch */ case    6:  		/* bc 4, CR6_EQ, -320 */
		/* 8216EC9Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216EB5C;  }
		/* 8216EC9Ch case    6:*/		return 0x8216ECA0;
	}
	return 0x8216ECA0;
} // Block from 8216EC84h-8216ECA0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216ECA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ECA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ECA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ECA0);
		  /* 8216ECA0h */ case    0:  		/* li R5, 0 */
		/* 8216ECA0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216ECA0h case    0:*/		return 0x8216ECA4;
		  /* 8216ECA4h */ case    1:  		/* mr R4, R25 */
		/* 8216ECA4h case    1:*/		regs.R4 = regs.R25;
		/* 8216ECA4h case    1:*/		return 0x8216ECA8;
		  /* 8216ECA8h */ case    2:  		/* mr R3, R24 */
		/* 8216ECA8h case    2:*/		regs.R3 = regs.R24;
		/* 8216ECA8h case    2:*/		return 0x8216ECAC;
		  /* 8216ECACh */ case    3:  		/* bl 12220 */
		/* 8216ECACh case    3:*/		regs.LR = 0x8216ECB0; return 0x82171C68;
		/* 8216ECACh case    3:*/		return 0x8216ECB0;
		  /* 8216ECB0h */ case    4:  		/* li R5, 0 */
		/* 8216ECB0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216ECB0h case    4:*/		return 0x8216ECB4;
		  /* 8216ECB4h */ case    5:  		/* mr R4, R26 */
		/* 8216ECB4h case    5:*/		regs.R4 = regs.R26;
		/* 8216ECB4h case    5:*/		return 0x8216ECB8;
		  /* 8216ECB8h */ case    6:  		/* mr R3, R24 */
		/* 8216ECB8h case    6:*/		regs.R3 = regs.R24;
		/* 8216ECB8h case    6:*/		return 0x8216ECBC;
		  /* 8216ECBCh */ case    7:  		/* bl 12204 */
		/* 8216ECBCh case    7:*/		regs.LR = 0x8216ECC0; return 0x82171C68;
		/* 8216ECBCh case    7:*/		return 0x8216ECC0;
	}
	return 0x8216ECC0;
} // Block from 8216ECA0h-8216ECC0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216ECC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ECC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ECC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ECC0);
		  /* 8216ECC0h */ case    0:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 8216ECC0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 8216ECC0h case    0:*/		return 0x8216ECC4;
		  /* 8216ECC4h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216ECC4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216ECC4h case    1:*/		return 0x8216ECC8;
		  /* 8216ECC8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216ECC8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216ECC8h case    2:*/		return 0x8216ECCC;
		  /* 8216ECCCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216ECCCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216ECDC;  }
		/* 8216ECCCh case    3:*/		return 0x8216ECD0;
		  /* 8216ECD0h */ case    4:  		/* mr R25, R11 */
		/* 8216ECD0h case    4:*/		regs.R25 = regs.R11;
		/* 8216ECD0h case    4:*/		return 0x8216ECD4;
		  /* 8216ECD4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216ECD4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216ECD4h case    5:*/		return 0x8216ECD8;
		  /* 8216ECD8h */ case    6:  		/* bc 4, CR6_EQ, -1164 */
		/* 8216ECD8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216E84C;  }
		/* 8216ECD8h case    6:*/		return 0x8216ECDC;
	}
	return 0x8216ECDC;
} // Block from 8216ECC0h-8216ECDCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216ECDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ECDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ECDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ECDC);
		  /* 8216ECDCh */ case    0:  		/* addi R1, R1, 240 */
		/* 8216ECDCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 8216ECDCh case    0:*/		return 0x8216ECE0;
		  /* 8216ECE0h */ case    1:  		/* b -907864 */
		/* 8216ECE0h case    1:*/		return 0x82091288;
		/* 8216ECE0h case    1:*/		return 0x8216ECE4;
	}
	return 0x8216ECE4;
} // Block from 8216ECDCh-8216ECE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216ECE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ECE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ECE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ECE4);
		  /* 8216ECE4h */ case    0:  		/* li R4, 4800 */
		/* 8216ECE4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8216ECE4h case    0:*/		return 0x8216ECE8;
		  /* 8216ECE8h */ case    1:  		/* bl -118400 */
		/* 8216ECE8h case    1:*/		regs.LR = 0x8216ECEC; return 0x82151E68;
		/* 8216ECE8h case    1:*/		return 0x8216ECEC;
	}
	return 0x8216ECEC;
} // Block from 8216ECE4h-8216ECECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216ECECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ECEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ECEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ECEC);
		  /* 8216ECECh */ case    0:  		/* li R4, 4800 */
		/* 8216ECECh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8216ECECh case    0:*/		return 0x8216ECF0;
		  /* 8216ECF0h */ case    1:  		/* bl -118408 */
		/* 8216ECF0h case    1:*/		regs.LR = 0x8216ECF4; return 0x82151E68;
		/* 8216ECF0h case    1:*/		return 0x8216ECF4;
		  /* 8216ECF4h */ case    2:  		/* nop */
		/* 8216ECF4h case    2:*/		cpu::op::nop();
		/* 8216ECF4h case    2:*/		return 0x8216ECF8;
		  /* 8216ECF8h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 8216ECF8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216ECF8h case    3:*/		return 0x8216ECFC;
		  /* 8216ECFCh */ case    4:  		/* li R3, 0 */
		/* 8216ECFCh case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216ECFCh case    4:*/		return 0x8216ED00;
		  /* 8216ED00h */ case    5:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8216ED00h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8216ED00h case    5:*/		return 0x8216ED04;
		  /* 8216ED04h */ case    6:  		/* cmplwi CR6, R10, 1 */
		/* 8216ED04h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8216ED04h case    6:*/		return 0x8216ED08;
		  /* 8216ED08h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 8216ED08h case    7:*/		if ( regs.CR[6].lt ) { return 0x8216ED18;  }
		/* 8216ED08h case    7:*/		return 0x8216ED0C;
		  /* 8216ED0Ch */ case    8:  		/* cmplwi CR6, R10, 82 */
		/* 8216ED0Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 8216ED0Ch case    8:*/		return 0x8216ED10;
		  /* 8216ED10h */ case    9:  		/* li R11, 1 */
		/* 8216ED10h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216ED10h case    9:*/		return 0x8216ED14;
		  /* 8216ED14h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 8216ED14h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8216ED1C;  }
		/* 8216ED14h case   10:*/		return 0x8216ED18;
	}
	return 0x8216ED18;
} // Block from 8216ECECh-8216ED18h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED18);
		  /* 8216ED18h */ case    0:  		/* li R11, 0 */
		/* 8216ED18h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216ED18h case    0:*/		return 0x8216ED1C;
	}
	return 0x8216ED1C;
} // Block from 8216ED18h-8216ED1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED1C);
		  /* 8216ED1Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216ED1Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216ED1Ch case    0:*/		return 0x8216ED20;
		  /* 8216ED20h */ case    1:  		/* bc 4, CR0_EQ, 104 */
		/* 8216ED20h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216ED88;  }
		/* 8216ED20h case    1:*/		return 0x8216ED24;
		  /* 8216ED24h */ case    2:  		/* cmplwi CR6, R10, 96 */
		/* 8216ED24h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 8216ED24h case    2:*/		return 0x8216ED28;
		  /* 8216ED28h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8216ED28h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216ED34;  }
		/* 8216ED28h case    3:*/		return 0x8216ED2C;
		  /* 8216ED2Ch */ case    4:  		/* li R3, 3 */
		/* 8216ED2Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 8216ED2Ch case    4:*/		return 0x8216ED30;
		  /* 8216ED30h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8216ED30h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216ED30h case    5:*/		return 0x8216ED34;
	}
	return 0x8216ED34;
} // Block from 8216ED1Ch-8216ED34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED34);
		  /* 8216ED34h */ case    0:  		/* bc 12, CR6_LT, 16 */
		/* 8216ED34h case    0:*/		if ( regs.CR[6].lt ) { return 0x8216ED44;  }
		/* 8216ED34h case    0:*/		return 0x8216ED38;
		  /* 8216ED38h */ case    1:  		/* cmplwi CR6, R10, 102 */
		/* 8216ED38h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 8216ED38h case    1:*/		return 0x8216ED3C;
		  /* 8216ED3Ch */ case    2:  		/* li R11, 1 */
		/* 8216ED3Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216ED3Ch case    2:*/		return 0x8216ED40;
		  /* 8216ED40h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 8216ED40h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8216ED48;  }
		/* 8216ED40h case    3:*/		return 0x8216ED44;
	}
	return 0x8216ED44;
} // Block from 8216ED34h-8216ED44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED44);
		  /* 8216ED44h */ case    0:  		/* li R11, 0 */
		/* 8216ED44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216ED44h case    0:*/		return 0x8216ED48;
	}
	return 0x8216ED48;
} // Block from 8216ED44h-8216ED48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED48);
		  /* 8216ED48h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216ED48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216ED48h case    0:*/		return 0x8216ED4C;
		  /* 8216ED4Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8216ED4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8216ED58;  }
		/* 8216ED4Ch case    1:*/		return 0x8216ED50;
		  /* 8216ED50h */ case    2:  		/* li R3, 2 */
		/* 8216ED50h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8216ED50h case    2:*/		return 0x8216ED54;
		  /* 8216ED54h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8216ED54h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216ED54h case    3:*/		return 0x8216ED58;
	}
	return 0x8216ED58;
} // Block from 8216ED48h-8216ED58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED58);
		  /* 8216ED58h */ case    0:  		/* cmplwi CR6, R10, 83 */
		/* 8216ED58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000053);
		/* 8216ED58h case    0:*/		return 0x8216ED5C;
		  /* 8216ED5Ch */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 8216ED5Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8216ED6C;  }
		/* 8216ED5Ch case    1:*/		return 0x8216ED60;
		  /* 8216ED60h */ case    2:  		/* cmplwi CR6, R10, 95 */
		/* 8216ED60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005F);
		/* 8216ED60h case    2:*/		return 0x8216ED64;
		  /* 8216ED64h */ case    3:  		/* li R11, 1 */
		/* 8216ED64h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216ED64h case    3:*/		return 0x8216ED68;
		  /* 8216ED68h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 8216ED68h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8216ED70;  }
		/* 8216ED68h case    4:*/		return 0x8216ED6C;
	}
	return 0x8216ED6C;
} // Block from 8216ED58h-8216ED6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED6C);
		  /* 8216ED6Ch */ case    0:  		/* li R11, 0 */
		/* 8216ED6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216ED6Ch case    0:*/		return 0x8216ED70;
	}
	return 0x8216ED70;
} // Block from 8216ED6Ch-8216ED70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED70);
		  /* 8216ED70h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216ED70h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216ED70h case    0:*/		return 0x8216ED74;
		  /* 8216ED74h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 8216ED74h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216ED90;  }
		/* 8216ED74h case    1:*/		return 0x8216ED78;
		  /* 8216ED78h */ case    2:  		/* cmplwi CR6, R10, 106 */
		/* 8216ED78h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006A);
		/* 8216ED78h case    2:*/		return 0x8216ED7C;
		  /* 8216ED7Ch */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 8216ED7Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8216ED90;  }
		/* 8216ED7Ch case    3:*/		return 0x8216ED80;
		  /* 8216ED80h */ case    4:  		/* cmplwi CR6, R10, 110 */
		/* 8216ED80h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006E);
		/* 8216ED80h case    4:*/		return 0x8216ED84;
		  /* 8216ED84h */ case    5:  		/* bclr 4, CR6_EQ */
		/* 8216ED84h case    5:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8216ED84h case    5:*/		return 0x8216ED88;
	}
	return 0x8216ED88;
} // Block from 8216ED70h-8216ED88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED88);
		  /* 8216ED88h */ case    0:  		/* li R3, 1 */
		/* 8216ED88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216ED88h case    0:*/		return 0x8216ED8C;
		  /* 8216ED8Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216ED8Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216ED8Ch case    1:*/		return 0x8216ED90;
	}
	return 0x8216ED90;
} // Block from 8216ED88h-8216ED90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED90);
		  /* 8216ED90h */ case    0:  		/* li R3, 4 */
		/* 8216ED90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 8216ED90h case    0:*/		return 0x8216ED94;
		  /* 8216ED94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216ED94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216ED94h case    1:*/		return 0x8216ED98;
	}
	return 0x8216ED98;
} // Block from 8216ED90h-8216ED98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216ED98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ED98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ED98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ED98);
		  /* 8216ED98h */ case    0:  		/* lwz R8, <#[R3]> */
		/* 8216ED98h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 8216ED98h case    0:*/		return 0x8216ED9C;
		  /* 8216ED9Ch */ case    1:  		/* li R11, 0 */
		/* 8216ED9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216ED9Ch case    1:*/		return 0x8216EDA0;
		  /* 8216EDA0h */ case    2:  		/* li R10, 0 */
		/* 8216EDA0h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216EDA0h case    2:*/		return 0x8216EDA4;
		  /* 8216EDA4h */ case    3:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 8216EDA4h case    3:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 8216EDA4h case    3:*/		return 0x8216EDA8;
		  /* 8216EDA8h */ case    4:  		/* bc 12, CR0_EQ, 48 */
		/* 8216EDA8h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216EDD8;  }
		/* 8216EDA8h case    4:*/		return 0x8216EDAC;
		  /* 8216EDACh */ case    5:  		/* li R9, 0 */
		/* 8216EDACh case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8216EDACh case    5:*/		return 0x8216EDB0;
		  /* 8216EDB0h */ case    6:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 8216EDB0h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 8216EDB0h case    6:*/		return 0x8216EDB4;
		  /* 8216EDB4h */ case    7:  		/* li R5, 1 */
		/* 8216EDB4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8216EDB4h case    7:*/		return 0x8216EDB8;
		  /* 8216EDB8h */ case    8:  		/* srw R6, R6, R9 */
		/* 8216EDB8h case    8:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 8216EDB8h case    8:*/		return 0x8216EDBC;
		  /* 8216EDBCh */ case    9:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 8216EDBCh case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 8216EDBCh case    9:*/		return 0x8216EDC0;
		  /* 8216EDC0h */ case   10:  		/* addi R10, R10, 1 */
		/* 8216EDC0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216EDC0h case   10:*/		return 0x8216EDC4;
		  /* 8216EDC4h */ case   11:  		/* slw R6, R5, R6 */
		/* 8216EDC4h case   11:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 8216EDC4h case   11:*/		return 0x8216EDC8;
		  /* 8216EDC8h */ case   12:  		/* or R11, R6, R11 */
		/* 8216EDC8h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 8216EDC8h case   12:*/		return 0x8216EDCC;
		  /* 8216EDCCh */ case   13:  		/* addi R9, R9, 2 */
		/* 8216EDCCh case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 8216EDCCh case   13:*/		return 0x8216EDD0;
		  /* 8216EDD0h */ case   14:  		/* cmplw CR6, R10, R7 */
		/* 8216EDD0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8216EDD0h case   14:*/		return 0x8216EDD4;
		  /* 8216EDD4h */ case   15:  		/* bc 12, CR6_LT, -36 */
		/* 8216EDD4h case   15:*/		if ( regs.CR[6].lt ) { return 0x8216EDB0;  }
		/* 8216EDD4h case   15:*/		return 0x8216EDD8;
	}
	return 0x8216EDD8;
} // Block from 8216ED98h-8216EDD8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216EDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EDD8);
		  /* 8216EDD8h */ case    0:  		/* rlwimi R11, R8, 19, 20, 27 */
		/* 8216EDD8h case    0:*/		cpu::op::rlwimi<0,19,20,27>(regs,&regs.R11,regs.R8);
		/* 8216EDD8h case    0:*/		return 0x8216EDDC;
		  /* 8216EDDCh */ case    1:  		/* rlwinm R3, R11, 0, 20, 31 */
		/* 8216EDDCh case    1:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R3,regs.R11);
		/* 8216EDDCh case    1:*/		return 0x8216EDE0;
		  /* 8216EDE0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216EDE0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216EDE0h case    2:*/		return 0x8216EDE4;
	}
	return 0x8216EDE4;
} // Block from 8216EDD8h-8216EDE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216EDE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EDE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EDE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EDE4);
		  /* 8216EDE4h */ case    0:  		/* nop */
		/* 8216EDE4h case    0:*/		cpu::op::nop();
		/* 8216EDE4h case    0:*/		return 0x8216EDE8;
	}
	return 0x8216EDE8;
} // Block from 8216EDE4h-8216EDE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216EDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EDE8);
		  /* 8216EDE8h */ case    0:  		/* mfspr R12, LR */
		/* 8216EDE8h case    0:*/		regs.R12 = regs.LR;
		/* 8216EDE8h case    0:*/		return 0x8216EDEC;
		  /* 8216EDECh */ case    1:  		/* bl -908176 */
		/* 8216EDECh case    1:*/		regs.LR = 0x8216EDF0; return 0x8209125C;
		/* 8216EDECh case    1:*/		return 0x8216EDF0;
		  /* 8216EDF0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216EDF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216EDF0h case    2:*/		return 0x8216EDF4;
		  /* 8216EDF4h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8216EDF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8216EDF4h case    3:*/		return 0x8216EDF8;
		  /* 8216EDF8h */ case    4:  		/* mr R30, R3 */
		/* 8216EDF8h case    4:*/		regs.R30 = regs.R3;
		/* 8216EDF8h case    4:*/		return 0x8216EDFC;
		  /* 8216EDFCh */ case    5:  		/* mr R31, R4 */
		/* 8216EDFCh case    5:*/		regs.R31 = regs.R4;
		/* 8216EDFCh case    5:*/		return 0x8216EE00;
		  /* 8216EE00h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216EE00h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216EE00h case    6:*/		return 0x8216EE04;
		  /* 8216EE04h */ case    7:  		/* li R29, 0 */
		/* 8216EE04h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8216EE04h case    7:*/		return 0x8216EE08;
		  /* 8216EE08h */ case    8:  		/* cmplwi CR6, R11, 91 */
		/* 8216EE08h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005B);
		/* 8216EE08h case    8:*/		return 0x8216EE0C;
		  /* 8216EE0Ch */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 8216EE0Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x8216EE1C;  }
		/* 8216EE0Ch case    9:*/		return 0x8216EE10;
		  /* 8216EE10h */ case   10:  		/* cmplwi CR6, R11, 94 */
		/* 8216EE10h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005E);
		/* 8216EE10h case   10:*/		return 0x8216EE14;
		  /* 8216EE14h */ case   11:  		/* li R10, 1 */
		/* 8216EE14h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216EE14h case   11:*/		return 0x8216EE18;
		  /* 8216EE18h */ case   12:  		/* bc 4, CR6_GT, 8 */
		/* 8216EE18h case   12:*/		if ( !regs.CR[6].gt ) { return 0x8216EE20;  }
		/* 8216EE18h case   12:*/		return 0x8216EE1C;
	}
	return 0x8216EE1C;
} // Block from 8216EDE8h-8216EE1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216EE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EE1C);
		  /* 8216EE1Ch */ case    0:  		/* li R10, 0 */
		/* 8216EE1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216EE1Ch case    0:*/		return 0x8216EE20;
	}
	return 0x8216EE20;
} // Block from 8216EE1Ch-8216EE20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216EE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EE20);
		  /* 8216EE20h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8216EE20h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8216EE20h case    0:*/		return 0x8216EE24;
		  /* 8216EE24h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 8216EE24h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216EE34;  }
		/* 8216EE24h case    1:*/		return 0x8216EE28;
		  /* 8216EE28h */ case    2:  		/* cmplwi CR6, R11, 123 */
		/* 8216EE28h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007B);
		/* 8216EE28h case    2:*/		return 0x8216EE2C;
		  /* 8216EE2Ch */ case    3:  		/* li R11, 0 */
		/* 8216EE2Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216EE2Ch case    3:*/		return 0x8216EE30;
		  /* 8216EE30h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 8216EE30h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8216EE38;  }
		/* 8216EE30h case    4:*/		return 0x8216EE34;
	}
	return 0x8216EE34;
} // Block from 8216EE20h-8216EE34h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216EE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EE34);
		  /* 8216EE34h */ case    0:  		/* li R11, 1 */
		/* 8216EE34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216EE34h case    0:*/		return 0x8216EE38;
	}
	return 0x8216EE38;
} // Block from 8216EE34h-8216EE38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216EE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EE38);
		  /* 8216EE38h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216EE38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216EE38h case    0:*/		return 0x8216EE3C;
		  /* 8216EE3Ch */ case    1:  		/* bc 4, CR0_EQ, 180 */
		/* 8216EE3Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216EEF0;  }
		/* 8216EE3Ch case    1:*/		return 0x8216EE40;
		  /* 8216EE40h */ case    2:  		/* mr R3, R31 */
		/* 8216EE40h case    2:*/		regs.R3 = regs.R31;
		/* 8216EE40h case    2:*/		return 0x8216EE44;
		  /* 8216EE44h */ case    3:  		/* bl -332 */
		/* 8216EE44h case    3:*/		regs.LR = 0x8216EE48; return 0x8216ECF8;
		/* 8216EE44h case    3:*/		return 0x8216EE48;
		  /* 8216EE48h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8216EE48h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216EE48h case    4:*/		return 0x8216EE4C;
		  /* 8216EE4Ch */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 8216EE4Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8216EE6C;  }
		/* 8216EE4Ch case    5:*/		return 0x8216EE50;
		  /* 8216EE50h */ case    6:  		/* cmpwi CR6, R3, 4 */
		/* 8216EE50h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 8216EE50h case    6:*/		return 0x8216EE54;
		  /* 8216EE54h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 8216EE54h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216EE6C;  }
		/* 8216EE54h case    7:*/		return 0x8216EE58;
		  /* 8216EE58h */ case    8:  		/* lwz R11, <#[R30 + 40]> */
		/* 8216EE58h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 8216EE58h case    8:*/		return 0x8216EE5C;
		  /* 8216EE5Ch */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 8216EE5Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216EE5Ch case    9:*/		return 0x8216EE60;
		  /* 8216EE60h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 8216EE60h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216EE6C;  }
		/* 8216EE60h case   10:*/		return 0x8216EE64;
		  /* 8216EE64h */ case   11:  		/* cmpw CR6, R11, R3 */
		/* 8216EE64h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 8216EE64h case   11:*/		return 0x8216EE68;
		  /* 8216EE68h */ case   12:  		/* bc 4, CR6_EQ, 136 */
		/* 8216EE68h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8216EEF0;  }
		/* 8216EE68h case   12:*/		return 0x8216EE6C;
	}
	return 0x8216EE6C;
} // Block from 8216EE38h-8216EE6Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216EE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EE6C);
		  /* 8216EE6Ch */ case    0:  		/* cmpwi CR6, R3, 2 */
		/* 8216EE6Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8216EE6Ch case    0:*/		return 0x8216EE70;
		  /* 8216EE70h */ case    1:  		/* bc 4, CR6_EQ, 132 */
		/* 8216EE70h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216EEF4;  }
		/* 8216EE70h case    1:*/		return 0x8216EE74;
		  /* 8216EE74h */ case    2:  		/* lwz R9, <#[R31]> */
		/* 8216EE74h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216EE74h case    2:*/		return 0x8216EE78;
		  /* 8216EE78h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 8216EE78h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8216EE78h case    3:*/		return 0x8216EE7C;
		  /* 8216EE7Ch */ case    4:  		/* bc 12, CR6_EQ, 120 */
		/* 8216EE7Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8216EEF4;  }
		/* 8216EE7Ch case    4:*/		return 0x8216EE80;
		  /* 8216EE80h */ case    5:  		/* lwz R10, <#[R9]> */
		/* 8216EE80h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8216EE80h case    5:*/		return 0x8216EE84;
		  /* 8216EE84h */ case    6:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 8216EE84h case    6:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 8216EE84h case    6:*/		return 0x8216EE88;
		  /* 8216EE88h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8216EE88h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216EE98;  }
		/* 8216EE88h case    7:*/		return 0x8216EE8C;
		  /* 8216EE8Ch */ case    8:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 8216EE8Ch case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 8216EE8Ch case    8:*/		return 0x8216EE90;
		  /* 8216EE90h */ case    9:  		/* li R11, 1 */
		/* 8216EE90h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216EE90h case    9:*/		return 0x8216EE94;
		  /* 8216EE94h */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 8216EE94h case   10:*/		if ( regs.CR[0].eq ) { return 0x8216EE9C;  }
		/* 8216EE94h case   10:*/		return 0x8216EE98;
	}
	return 0x8216EE98;
} // Block from 8216EE6Ch-8216EE98h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216EE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EE98);
		  /* 8216EE98h */ case    0:  		/* li R11, 0 */
		/* 8216EE98h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216EE98h case    0:*/		return 0x8216EE9C;
	}
	return 0x8216EE9C;
} // Block from 8216EE98h-8216EE9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216EE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EE9C);
		  /* 8216EE9Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216EE9Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216EE9Ch case    0:*/		return 0x8216EEA0;
		  /* 8216EEA0h */ case    1:  		/* bc 12, CR0_EQ, 72 */
		/* 8216EEA0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216EEE8;  }
		/* 8216EEA0h case    1:*/		return 0x8216EEA4;
		  /* 8216EEA4h */ case    2:  		/* lwz R11, <#[R9 + 12]> */
		/* 8216EEA4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 8216EEA4h case    2:*/		return 0x8216EEA8;
		  /* 8216EEA8h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216EEA8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216EEA8h case    3:*/		return 0x8216EEAC;
		  /* 8216EEACh */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216EEACh case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216EEACh case    4:*/		return 0x8216EEB0;
		  /* 8216EEB0h */ case    5:  		/* cmplwi CR6, R11, 96 */
		/* 8216EEB0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 8216EEB0h case    5:*/		return 0x8216EEB4;
		  /* 8216EEB4h */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 8216EEB4h case    6:*/		if ( regs.CR[6].lt ) { return 0x8216EEC4;  }
		/* 8216EEB4h case    6:*/		return 0x8216EEB8;
		  /* 8216EEB8h */ case    7:  		/* cmplwi CR6, R11, 102 */
		/* 8216EEB8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 8216EEB8h case    7:*/		return 0x8216EEBC;
		  /* 8216EEBCh */ case    8:  		/* li R11, 1 */
		/* 8216EEBCh case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216EEBCh case    8:*/		return 0x8216EEC0;
		  /* 8216EEC0h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8216EEC0h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8216EEC8;  }
		/* 8216EEC0h case    9:*/		return 0x8216EEC4;
	}
	return 0x8216EEC4;
} // Block from 8216EE9Ch-8216EEC4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216EEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EEC4);
		  /* 8216EEC4h */ case    0:  		/* li R11, 0 */
		/* 8216EEC4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216EEC4h case    0:*/		return 0x8216EEC8;
	}
	return 0x8216EEC8;
} // Block from 8216EEC4h-8216EEC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216EEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EEC8);
		  /* 8216EEC8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216EEC8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216EEC8h case    0:*/		return 0x8216EECC;
		  /* 8216EECCh */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8216EECCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8216EEE8;  }
		/* 8216EECCh case    1:*/		return 0x8216EED0;
		  /* 8216EED0h */ case    2:  		/* rlwinm R11, R10, 19, 20, 31 */
		/* 8216EED0h case    2:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R10);
		/* 8216EED0h case    2:*/		return 0x8216EED4;
		  /* 8216EED4h */ case    3:  		/* lwz R10, <#[R30 + 48]> */
		/* 8216EED4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8216EED4h case    3:*/		return 0x8216EED8;
		  /* 8216EED8h */ case    4:  		/* li R8, 1 */
		/* 8216EED8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8216EED8h case    4:*/		return 0x8216EEDC;
		  /* 8216EEDCh */ case    5:  		/* slw R11, R8, R11 */
		/* 8216EEDCh case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8216EEDCh case    5:*/		return 0x8216EEE0;
		  /* 8216EEE0h */ case    6:  		/* and. R11, R11, R10 */
		/* 8216EEE0h case    6:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216EEE0h case    6:*/		return 0x8216EEE4;
		  /* 8216EEE4h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 8216EEE4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216EEF0;  }
		/* 8216EEE4h case    7:*/		return 0x8216EEE8;
	}
	return 0x8216EEE8;
} // Block from 8216EEC8h-8216EEE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216EEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EEE8);
		  /* 8216EEE8h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 8216EEE8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8216EEE8h case    0:*/		return 0x8216EEEC;
		  /* 8216EEECh */ case    1:  		/* b -116 */
		/* 8216EEECh case    1:*/		return 0x8216EE78;
		/* 8216EEECh case    1:*/		return 0x8216EEF0;
	}
	return 0x8216EEF0;
} // Block from 8216EEE8h-8216EEF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216EEF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EEF0);
		  /* 8216EEF0h */ case    0:  		/* li R29, 1 */
		/* 8216EEF0h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 8216EEF0h case    0:*/		return 0x8216EEF4;
	}
	return 0x8216EEF4;
} // Block from 8216EEF0h-8216EEF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216EEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EEF4);
		  /* 8216EEF4h */ case    0:  		/* mr R3, R29 */
		/* 8216EEF4h case    0:*/		regs.R3 = regs.R29;
		/* 8216EEF4h case    0:*/		return 0x8216EEF8;
		  /* 8216EEF8h */ case    1:  		/* addi R1, R1, 112 */
		/* 8216EEF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216EEF8h case    1:*/		return 0x8216EEFC;
		  /* 8216EEFCh */ case    2:  		/* b -908368 */
		/* 8216EEFCh case    2:*/		return 0x820912AC;
		/* 8216EEFCh case    2:*/		return 0x8216EF00;
	}
	return 0x8216EF00;
} // Block from 8216EEF4h-8216EF00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216EF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EF00);
		  /* 8216EF00h */ case    0:  		/* mfspr R12, LR */
		/* 8216EF00h case    0:*/		regs.R12 = regs.LR;
		/* 8216EF00h case    0:*/		return 0x8216EF04;
		  /* 8216EF04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216EF04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216EF04h case    1:*/		return 0x8216EF08;
		  /* 8216EF08h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8216EF08h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216EF08h case    2:*/		return 0x8216EF0C;
		  /* 8216EF0Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216EF0Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216EF0Ch case    3:*/		return 0x8216EF10;
		  /* 8216EF10h */ case    4:  		/* mr R31, R3 */
		/* 8216EF10h case    4:*/		regs.R31 = regs.R3;
		/* 8216EF10h case    4:*/		return 0x8216EF14;
		  /* 8216EF14h */ case    5:  		/* mr R3, R4 */
		/* 8216EF14h case    5:*/		regs.R3 = regs.R4;
		/* 8216EF14h case    5:*/		return 0x8216EF18;
		  /* 8216EF18h */ case    6:  		/* bl -544 */
		/* 8216EF18h case    6:*/		regs.LR = 0x8216EF1C; return 0x8216ECF8;
		/* 8216EF18h case    6:*/		return 0x8216EF1C;
		  /* 8216EF1Ch */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 8216EF1Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216EF1Ch case    7:*/		return 0x8216EF20;
		  /* 8216EF20h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 8216EF20h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216EF3C;  }
		/* 8216EF20h case    8:*/		return 0x8216EF24;
		  /* 8216EF24h */ case    9:  		/* lwz R11, <#[R31 + 40]> */
		/* 8216EF24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8216EF24h case    9:*/		return 0x8216EF28;
		  /* 8216EF28h */ case   10:  		/* cmpw CR6, R11, R3 */
		/* 8216EF28h case   10:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 8216EF28h case   10:*/		return 0x8216EF2C;
		  /* 8216EF2Ch */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 8216EF2Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8216EF3C;  }
		/* 8216EF2Ch case   11:*/		return 0x8216EF30;
		  /* 8216EF30h */ case   12:  		/* stw R3, <#[R31 + 40]> */
		/* 8216EF30h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 8216EF30h case   12:*/		return 0x8216EF34;
		  /* 8216EF34h */ case   13:  		/* li R3, 1 */
		/* 8216EF34h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216EF34h case   13:*/		return 0x8216EF38;
		  /* 8216EF38h */ case   14:  		/* b 8 */
		/* 8216EF38h case   14:*/		return 0x8216EF40;
		/* 8216EF38h case   14:*/		return 0x8216EF3C;
	}
	return 0x8216EF3C;
} // Block from 8216EF00h-8216EF3Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216EF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EF3C);
		  /* 8216EF3Ch */ case    0:  		/* li R3, 0 */
		/* 8216EF3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216EF3Ch case    0:*/		return 0x8216EF40;
	}
	return 0x8216EF40;
} // Block from 8216EF3Ch-8216EF40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216EF40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EF40);
		  /* 8216EF40h */ case    0:  		/* addi R1, R1, 96 */
		/* 8216EF40h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216EF40h case    0:*/		return 0x8216EF44;
		  /* 8216EF44h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216EF44h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216EF44h case    1:*/		return 0x8216EF48;
		  /* 8216EF48h */ case    2:  		/* mtspr LR, R12 */
		/* 8216EF48h case    2:*/		regs.LR = regs.R12;
		/* 8216EF48h case    2:*/		return 0x8216EF4C;
		  /* 8216EF4Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8216EF4Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216EF4Ch case    3:*/		return 0x8216EF50;
		  /* 8216EF50h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216EF50h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216EF50h case    4:*/		return 0x8216EF54;
	}
	return 0x8216EF54;
} // Block from 8216EF40h-8216EF54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216EF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EF54);
		  /* 8216EF54h */ case    0:  		/* nop */
		/* 8216EF54h case    0:*/		cpu::op::nop();
		/* 8216EF54h case    0:*/		return 0x8216EF58;
		  /* 8216EF58h */ case    1:  		/* rlwinm R11, R5, 3, 0, 28 */
		/* 8216EF58h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R5);
		/* 8216EF58h case    1:*/		return 0x8216EF5C;
		  /* 8216EF5Ch */ case    2:  		/* rlwinm R9, R4, 29, 3, 28 */
		/* 8216EF5Ch case    2:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R9,regs.R4);
		/* 8216EF5Ch case    2:*/		return 0x8216EF60;
		  /* 8216EF60h */ case    3:  		/* add R11, R11, R3 */
		/* 8216EF60h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8216EF60h case    3:*/		return 0x8216EF64;
		  /* 8216EF64h */ case    4:  		/* li R8, -1 */
		/* 8216EF64h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8216EF64h case    4:*/		return 0x8216EF68;
		  /* 8216EF68h */ case    5:  		/* addi R10, R11, -8 */
		/* 8216EF68h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFF8);
		/* 8216EF68h case    5:*/		return 0x8216EF6C;
		  /* 8216EF6Ch */ case    6:  		/* add R11, R9, R3 */
		/* 8216EF6Ch case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R3);
		/* 8216EF6Ch case    6:*/		return 0x8216EF70;
		  /* 8216EF70h */ case    7:  		/* rldicl R9, R4, 0, 58 */
		/* 8216EF70h case    7:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R4);
		/* 8216EF70h case    7:*/		return 0x8216EF74;
		  /* 8216EF74h */ case    8:  		/* sld R9, R8, R9 */
		/* 8216EF74h case    8:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8216EF74h case    8:*/		return 0x8216EF78;
		  /* 8216EF78h */ case    9:  		/* b 28 */
		/* 8216EF78h case    9:*/		return 0x8216EF94;
		/* 8216EF78h case    9:*/		return 0x8216EF7C;
		  /* 8216EF7Ch */ case   10:  		/* ld R8, <#[R11]> */
		/* 8216EF7Ch case   10:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8216EF7Ch case   10:*/		return 0x8216EF80;
		  /* 8216EF80h */ case   11:  		/* and R9, R9, R8 */
		/* 8216EF80h case   11:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216EF80h case   11:*/		return 0x8216EF84;
		  /* 8216EF84h */ case   12:  		/* cmpldi CR6, R9, 0 */
		/* 8216EF84h case   12:*/		cpu::op::cmpldi<6>(regs,regs.R9,0x00000000);
		/* 8216EF84h case   12:*/		return 0x8216EF88;
		  /* 8216EF88h */ case   13:  		/* bc 4, CR6_EQ, 44 */
		/* 8216EF88h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8216EFB4;  }
		/* 8216EF88h case   13:*/		return 0x8216EF8C;
		  /* 8216EF8Ch */ case   14:  		/* addi R11, R11, 8 */
		/* 8216EF8Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8216EF8Ch case   14:*/		return 0x8216EF90;
		  /* 8216EF90h */ case   15:  		/* li R9, -1 */
		/* 8216EF90h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8216EF90h case   15:*/		return 0x8216EF94;
	}
	return 0x8216EF94;
} // Block from 8216EF54h-8216EF94h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216EF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EF94);
		  /* 8216EF94h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 8216EF94h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216EF94h case    0:*/		return 0x8216EF98;
		  /* 8216EF98h */ case    1:  		/* bc 12, CR6_LT, -28 */
		/* 8216EF98h case    1:*/		if ( regs.CR[6].lt ) { return 0x8216EF7C;  }
		/* 8216EF98h case    1:*/		return 0x8216EF9C;
		  /* 8216EF9Ch */ case    2:  		/* ld R11, <#[R10]> */
		/* 8216EF9Ch case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8216EF9Ch case    2:*/		return 0x8216EFA0;
		  /* 8216EFA0h */ case    3:  		/* and R11, R11, R9 */
		/* 8216EFA0h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216EFA0h case    3:*/		return 0x8216EFA4;
		  /* 8216EFA4h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 8216EFA4h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 8216EFA4h case    4:*/		return 0x8216EFA8;
		  /* 8216EFA8h */ case    5:  		/* bc 4, CR6_EQ, 44 */
		/* 8216EFA8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216EFD4;  }
		/* 8216EFA8h case    5:*/		return 0x8216EFAC;
		  /* 8216EFACh */ case    6:  		/* li R3, -1 */
		/* 8216EFACh case    6:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8216EFACh case    6:*/		return 0x8216EFB0;
		  /* 8216EFB0h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8216EFB0h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216EFB0h case    7:*/		return 0x8216EFB4;
	}
	return 0x8216EFB4;
} // Block from 8216EF94h-8216EFB4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216EFB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EFB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EFB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EFB4);
		  /* 8216EFB4h */ case    0:  		/* subf R11, R3, R11 */
		/* 8216EFB4h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8216EFB4h case    0:*/		return 0x8216EFB8;
		  /* 8216EFB8h */ case    1:  		/* addi R10, R9, -1 */
		/* 8216EFB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8216EFB8h case    1:*/		return 0x8216EFBC;
		  /* 8216EFBCh */ case    2:  		/* srawi R11, R11, 3 */
		/* 8216EFBCh case    2:*/		cpu::op::srawi<0,3>(regs,&regs.R11,regs.R11);
		/* 8216EFBCh case    2:*/		return 0x8216EFC0;
		  /* 8216EFC0h */ case    3:  		/* andc R10, R9, R10 */
		/* 8216EFC0h case    3:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8216EFC0h case    3:*/		return 0x8216EFC4;
		  /* 8216EFC4h */ case    4:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 8216EFC4h case    4:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 8216EFC4h case    4:*/		return 0x8216EFC8;
		  /* 8216EFC8h */ case    5:  		/* cntlzd R10, R10 */
		/* 8216EFC8h case    5:*/		cpu::op::cntlzd<0>(regs,&regs.R10,regs.R10);
		/* 8216EFC8h case    5:*/		return 0x8216EFCC;
		  /* 8216EFCCh */ case    6:  		/* subf R11, R10, R11 */
		/* 8216EFCCh case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216EFCCh case    6:*/		return 0x8216EFD0;
		  /* 8216EFD0h */ case    7:  		/* b 32 */
		/* 8216EFD0h case    7:*/		return 0x8216EFF0;
		/* 8216EFD0h case    7:*/		return 0x8216EFD4;
	}
	return 0x8216EFD4;
} // Block from 8216EFB4h-8216EFD4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216EFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EFD4);
		  /* 8216EFD4h */ case    0:  		/* addi R9, R11, -1 */
		/* 8216EFD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 8216EFD4h case    0:*/		return 0x8216EFD8;
		  /* 8216EFD8h */ case    1:  		/* subf R10, R3, R10 */
		/* 8216EFD8h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 8216EFD8h case    1:*/		return 0x8216EFDC;
		  /* 8216EFDCh */ case    2:  		/* andc R11, R11, R9 */
		/* 8216EFDCh case    2:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216EFDCh case    2:*/		return 0x8216EFE0;
		  /* 8216EFE0h */ case    3:  		/* srawi R10, R10, 3 */
		/* 8216EFE0h case    3:*/		cpu::op::srawi<0,3>(regs,&regs.R10,regs.R10);
		/* 8216EFE0h case    3:*/		return 0x8216EFE4;
		  /* 8216EFE4h */ case    4:  		/* cntlzd R11, R11 */
		/* 8216EFE4h case    4:*/		cpu::op::cntlzd<0>(regs,&regs.R11,regs.R11);
		/* 8216EFE4h case    4:*/		return 0x8216EFE8;
		  /* 8216EFE8h */ case    5:  		/* rlwinm R10, R10, 6, 0, 25 */
		/* 8216EFE8h case    5:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R10,regs.R10);
		/* 8216EFE8h case    5:*/		return 0x8216EFEC;
		  /* 8216EFECh */ case    6:  		/* subf R11, R11, R10 */
		/* 8216EFECh case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216EFECh case    6:*/		return 0x8216EFF0;
	}
	return 0x8216EFF0;
} // Block from 8216EFD4h-8216EFF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216EFF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EFF0);
		  /* 8216EFF0h */ case    0:  		/* addi R3, R11, 63 */
		/* 8216EFF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3F);
		/* 8216EFF0h case    0:*/		return 0x8216EFF4;
		  /* 8216EFF4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216EFF4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216EFF4h case    1:*/		return 0x8216EFF8;
	}
	return 0x8216EFF8;
} // Block from 8216EFF0h-8216EFF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216EFF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216EFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216EFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216EFF8);
		  /* 8216EFF8h */ case    0:  		/* mfspr R12, LR */
		/* 8216EFF8h case    0:*/		regs.R12 = regs.LR;
		/* 8216EFF8h case    0:*/		return 0x8216EFFC;
		  /* 8216EFFCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216EFFCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216EFFCh case    1:*/		return 0x8216F000;
		  /* 8216F000h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8216F000h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216F000h case    2:*/		return 0x8216F004;
		  /* 8216F004h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8216F004h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F004h case    3:*/		return 0x8216F008;
		  /* 8216F008h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216F008h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216F008h case    4:*/		return 0x8216F00C;
		  /* 8216F00Ch */ case    5:  		/* lwz R30, <#[R3]> */
		/* 8216F00Ch case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8216F00Ch case    5:*/		return 0x8216F010;
		  /* 8216F010h */ case    6:  		/* mr R31, R4 */
		/* 8216F010h case    6:*/		regs.R31 = regs.R4;
		/* 8216F010h case    6:*/		return 0x8216F014;
		  /* 8216F014h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 8216F014h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216F014h case    7:*/		return 0x8216F018;
		  /* 8216F018h */ case    8:  		/* bc 12, CR6_EQ, 140 */
		/* 8216F018h case    8:*/		if ( regs.CR[6].eq ) { return 0x8216F0A4;  }
		/* 8216F018h case    8:*/		return 0x8216F01C;
		  /* 8216F01Ch */ case    9:  		/* mr R3, R30 */
		/* 8216F01Ch case    9:*/		regs.R3 = regs.R30;
		/* 8216F01Ch case    9:*/		return 0x8216F020;
		  /* 8216F020h */ case   10:  		/* bl -42992 */
		/* 8216F020h case   10:*/		regs.LR = 0x8216F024; return 0x82164830;
		/* 8216F020h case   10:*/		return 0x8216F024;
		  /* 8216F024h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F024h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F024h case   11:*/		return 0x8216F028;
		  /* 8216F028h */ case   12:  		/* bc 12, CR0_EQ, 108 */
		/* 8216F028h case   12:*/		if ( regs.CR[0].eq ) { return 0x8216F094;  }
		/* 8216F028h case   12:*/		return 0x8216F02C;
		  /* 8216F02Ch */ case   13:  		/* lwz R8, <#[R30]> */
		/* 8216F02Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 8216F02Ch case   13:*/		return 0x8216F030;
		  /* 8216F030h */ case   14:  		/* rlwinm R11, R8, 19, 20, 31 */
		/* 8216F030h case   14:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R8);
		/* 8216F030h case   14:*/		return 0x8216F034;
		  /* 8216F034h */ case   15:  		/* xor R10, R11, R31 */
		/* 8216F034h case   15:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 8216F034h case   15:*/		return 0x8216F038;
		  /* 8216F038h */ case   16:  		/* rlwinm. R10, R10, 0, 0, 27 */
		/* 8216F038h case   16:*/		cpu::op::rlwinm<1,0,0,27>(regs,&regs.R10,regs.R10);
		/* 8216F038h case   16:*/		return 0x8216F03C;
		  /* 8216F03Ch */ case   17:  		/* bc 4, CR0_EQ, 88 */
		/* 8216F03Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x8216F094;  }
		/* 8216F03Ch case   17:*/		return 0x8216F040;
		  /* 8216F040h */ case   18:  		/* and R11, R11, R31 */
		/* 8216F040h case   18:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8216F040h case   18:*/		return 0x8216F044;
		  /* 8216F044h */ case   19:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 8216F044h case   19:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8216F044h case   19:*/		return 0x8216F048;
		  /* 8216F048h */ case   20:  		/* bc 12, CR0_EQ, 76 */
		/* 8216F048h case   20:*/		if ( regs.CR[0].eq ) { return 0x8216F094;  }
		/* 8216F048h case   20:*/		return 0x8216F04C;
		  /* 8216F04Ch */ case   21:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 8216F04Ch case   21:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 8216F04Ch case   21:*/		return 0x8216F050;
		  /* 8216F050h */ case   22:  		/* li R9, 0 */
		/* 8216F050h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8216F050h case   22:*/		return 0x8216F054;
		  /* 8216F054h */ case   23:  		/* li R11, 0 */
		/* 8216F054h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216F054h case   23:*/		return 0x8216F058;
		  /* 8216F058h */ case   24:  		/* bc 12, CR0_EQ, 48 */
		/* 8216F058h case   24:*/		if ( regs.CR[0].eq ) { return 0x8216F088;  }
		/* 8216F058h case   24:*/		return 0x8216F05C;
		  /* 8216F05Ch */ case   25:  		/* li R10, 0 */
		/* 8216F05Ch case   25:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216F05Ch case   25:*/		return 0x8216F060;
		  /* 8216F060h */ case   26:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 8216F060h case   26:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 8216F060h case   26:*/		return 0x8216F064;
		  /* 8216F064h */ case   27:  		/* li R5, 1 */
		/* 8216F064h case   27:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8216F064h case   27:*/		return 0x8216F068;
		  /* 8216F068h */ case   28:  		/* srw R6, R6, R10 */
		/* 8216F068h case   28:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 8216F068h case   28:*/		return 0x8216F06C;
		  /* 8216F06Ch */ case   29:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 8216F06Ch case   29:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 8216F06Ch case   29:*/		return 0x8216F070;
		  /* 8216F070h */ case   30:  		/* addi R11, R11, 1 */
		/* 8216F070h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216F070h case   30:*/		return 0x8216F074;
		  /* 8216F074h */ case   31:  		/* slw R6, R5, R6 */
		/* 8216F074h case   31:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 8216F074h case   31:*/		return 0x8216F078;
		  /* 8216F078h */ case   32:  		/* or R9, R6, R9 */
		/* 8216F078h case   32:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8216F078h case   32:*/		return 0x8216F07C;
		  /* 8216F07Ch */ case   33:  		/* addi R10, R10, 2 */
		/* 8216F07Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8216F07Ch case   33:*/		return 0x8216F080;
		  /* 8216F080h */ case   34:  		/* cmplw CR6, R11, R7 */
		/* 8216F080h case   34:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8216F080h case   34:*/		return 0x8216F084;
		  /* 8216F084h */ case   35:  		/* bc 12, CR6_LT, -36 */
		/* 8216F084h case   35:*/		if ( regs.CR[6].lt ) { return 0x8216F060;  }
		/* 8216F084h case   35:*/		return 0x8216F088;
	}
	return 0x8216F088;
} // Block from 8216EFF8h-8216F088h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8216F088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F088);
		  /* 8216F088h */ case    0:  		/* and R11, R9, R31 */
		/* 8216F088h case    0:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R31);
		/* 8216F088h case    0:*/		return 0x8216F08C;
		  /* 8216F08Ch */ case    1:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 8216F08Ch case    1:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8216F08Ch case    1:*/		return 0x8216F090;
		  /* 8216F090h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8216F090h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216F09C;  }
		/* 8216F090h case    2:*/		return 0x8216F094;
	}
	return 0x8216F094;
} // Block from 8216F088h-8216F094h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F094);
		  /* 8216F094h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 8216F094h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8216F094h case    0:*/		return 0x8216F098;
		  /* 8216F098h */ case    1:  		/* b -132 */
		/* 8216F098h case    1:*/		return 0x8216F014;
		/* 8216F098h case    1:*/		return 0x8216F09C;
	}
	return 0x8216F09C;
} // Block from 8216F094h-8216F09Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F09Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F09C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F09C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F09C);
		  /* 8216F09Ch */ case    0:  		/* li R3, 1 */
		/* 8216F09Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216F09Ch case    0:*/		return 0x8216F0A0;
		  /* 8216F0A0h */ case    1:  		/* b 8 */
		/* 8216F0A0h case    1:*/		return 0x8216F0A8;
		/* 8216F0A0h case    1:*/		return 0x8216F0A4;
	}
	return 0x8216F0A4;
} // Block from 8216F09Ch-8216F0A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F0A4);
		  /* 8216F0A4h */ case    0:  		/* li R3, 0 */
		/* 8216F0A4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216F0A4h case    0:*/		return 0x8216F0A8;
	}
	return 0x8216F0A8;
} // Block from 8216F0A4h-8216F0A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F0A8);
		  /* 8216F0A8h */ case    0:  		/* addi R1, R1, 112 */
		/* 8216F0A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216F0A8h case    0:*/		return 0x8216F0AC;
		  /* 8216F0ACh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216F0ACh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216F0ACh case    1:*/		return 0x8216F0B0;
		  /* 8216F0B0h */ case    2:  		/* mtspr LR, R12 */
		/* 8216F0B0h case    2:*/		regs.LR = regs.R12;
		/* 8216F0B0h case    2:*/		return 0x8216F0B4;
		  /* 8216F0B4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8216F0B4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216F0B4h case    3:*/		return 0x8216F0B8;
		  /* 8216F0B8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8216F0B8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F0B8h case    4:*/		return 0x8216F0BC;
		  /* 8216F0BCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 8216F0BCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F0BCh case    5:*/		return 0x8216F0C0;
	}
	return 0x8216F0C0;
} // Block from 8216F0A8h-8216F0C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216F0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F0C0);
		  /* 8216F0C0h */ case    0:  		/* mfspr R12, LR */
		/* 8216F0C0h case    0:*/		regs.R12 = regs.LR;
		/* 8216F0C0h case    0:*/		return 0x8216F0C4;
		  /* 8216F0C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216F0C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216F0C4h case    1:*/		return 0x8216F0C8;
		  /* 8216F0C8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8216F0C8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216F0C8h case    2:*/		return 0x8216F0CC;
		  /* 8216F0CCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8216F0CCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F0CCh case    3:*/		return 0x8216F0D0;
		  /* 8216F0D0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216F0D0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216F0D0h case    4:*/		return 0x8216F0D4;
		  /* 8216F0D4h */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 8216F0D4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216F0D4h case    5:*/		return 0x8216F0D8;
		  /* 8216F0D8h */ case    6:  		/* mr R30, R4 */
		/* 8216F0D8h case    6:*/		regs.R30 = regs.R4;
		/* 8216F0D8h case    6:*/		return 0x8216F0DC;
		  /* 8216F0DCh */ case    7:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 8216F0DCh case    7:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 8216F0DCh case    7:*/		return 0x8216F0E0;
		  /* 8216F0E0h */ case    8:  		/* and R11, R11, R4 */
		/* 8216F0E0h case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8216F0E0h case    8:*/		return 0x8216F0E4;
		  /* 8216F0E4h */ case    9:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 8216F0E4h case    9:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8216F0E4h case    9:*/		return 0x8216F0E8;
		  /* 8216F0E8h */ case   10:  		/* bc 12, CR0_EQ, 80 */
		/* 8216F0E8h case   10:*/		if ( regs.CR[0].eq ) { return 0x8216F138;  }
		/* 8216F0E8h case   10:*/		return 0x8216F0EC;
		  /* 8216F0ECh */ case   11:  		/* lwz R31, <#[R3 + 4]> */
		/* 8216F0ECh case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 8216F0ECh case   11:*/		return 0x8216F0F0;
		  /* 8216F0F0h */ case   12:  		/* cmplwi CR6, R31, 0 */
		/* 8216F0F0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216F0F0h case   12:*/		return 0x8216F0F4;
		  /* 8216F0F4h */ case   13:  		/* bc 12, CR6_EQ, 68 */
		/* 8216F0F4h case   13:*/		if ( regs.CR[6].eq ) { return 0x8216F138;  }
		/* 8216F0F4h case   13:*/		return 0x8216F0F8;
		  /* 8216F0F8h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 8216F0F8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8216F0F8h case   14:*/		return 0x8216F0FC;
		  /* 8216F0FCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 8216F0FCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216F0FCh case   15:*/		return 0x8216F100;
		  /* 8216F100h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 8216F100h case   16:*/		if ( regs.CR[6].eq ) { return 0x8216F128;  }
		/* 8216F100h case   16:*/		return 0x8216F104;
		  /* 8216F104h */ case   17:  		/* mr R3, R31 */
		/* 8216F104h case   17:*/		regs.R3 = regs.R31;
		/* 8216F104h case   17:*/		return 0x8216F108;
		  /* 8216F108h */ case   18:  		/* bl -43224 */
		/* 8216F108h case   18:*/		regs.LR = 0x8216F10C; return 0x82164830;
		/* 8216F108h case   18:*/		return 0x8216F10C;
		  /* 8216F10Ch */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F10Ch case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F10Ch case   19:*/		return 0x8216F110;
		  /* 8216F110h */ case   20:  		/* bc 12, CR0_EQ, 24 */
		/* 8216F110h case   20:*/		if ( regs.CR[0].eq ) { return 0x8216F128;  }
		/* 8216F110h case   20:*/		return 0x8216F114;
		  /* 8216F114h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 8216F114h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216F114h case   21:*/		return 0x8216F118;
		  /* 8216F118h */ case   22:  		/* rlwinm R11, R11, 19, 20, 27 */
		/* 8216F118h case   22:*/		cpu::op::rlwinm<0,19,20,27>(regs,&regs.R11,regs.R11);
		/* 8216F118h case   22:*/		return 0x8216F11C;
		  /* 8216F11Ch */ case   23:  		/* xor R11, R11, R30 */
		/* 8216F11Ch case   23:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8216F11Ch case   23:*/		return 0x8216F120;
		  /* 8216F120h */ case   24:  		/* rlwinm. R11, R11, 0, 0, 27 */
		/* 8216F120h case   24:*/		cpu::op::rlwinm<1,0,0,27>(regs,&regs.R11,regs.R11);
		/* 8216F120h case   24:*/		return 0x8216F124;
		  /* 8216F124h */ case   25:  		/* bc 12, CR0_EQ, 12 */
		/* 8216F124h case   25:*/		if ( regs.CR[0].eq ) { return 0x8216F130;  }
		/* 8216F124h case   25:*/		return 0x8216F128;
	}
	return 0x8216F128;
} // Block from 8216F0C0h-8216F128h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216F128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F128);
		  /* 8216F128h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8216F128h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8216F128h case    0:*/		return 0x8216F12C;
		  /* 8216F12Ch */ case    1:  		/* b -60 */
		/* 8216F12Ch case    1:*/		return 0x8216F0F0;
		/* 8216F12Ch case    1:*/		return 0x8216F130;
	}
	return 0x8216F130;
} // Block from 8216F128h-8216F130h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F130);
		  /* 8216F130h */ case    0:  		/* li R3, 1 */
		/* 8216F130h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216F130h case    0:*/		return 0x8216F134;
		  /* 8216F134h */ case    1:  		/* b 8 */
		/* 8216F134h case    1:*/		return 0x8216F13C;
		/* 8216F134h case    1:*/		return 0x8216F138;
	}
	return 0x8216F138;
} // Block from 8216F130h-8216F138h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F138);
		  /* 8216F138h */ case    0:  		/* li R3, 0 */
		/* 8216F138h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216F138h case    0:*/		return 0x8216F13C;
	}
	return 0x8216F13C;
} // Block from 8216F138h-8216F13Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F13C);
		  /* 8216F13Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8216F13Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216F13Ch case    0:*/		return 0x8216F140;
		  /* 8216F140h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216F140h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216F140h case    1:*/		return 0x8216F144;
		  /* 8216F144h */ case    2:  		/* mtspr LR, R12 */
		/* 8216F144h case    2:*/		regs.LR = regs.R12;
		/* 8216F144h case    2:*/		return 0x8216F148;
		  /* 8216F148h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8216F148h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216F148h case    3:*/		return 0x8216F14C;
		  /* 8216F14Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8216F14Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F14Ch case    4:*/		return 0x8216F150;
		  /* 8216F150h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8216F150h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F150h case    5:*/		return 0x8216F154;
	}
	return 0x8216F154;
} // Block from 8216F13Ch-8216F154h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216F154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F154);
		  /* 8216F154h */ case    0:  		/* nop */
		/* 8216F154h case    0:*/		cpu::op::nop();
		/* 8216F154h case    0:*/		return 0x8216F158;
	}
	return 0x8216F158;
} // Block from 8216F154h-8216F158h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F158);
		  /* 8216F158h */ case    0:  		/* mfspr R12, LR */
		/* 8216F158h case    0:*/		regs.R12 = regs.LR;
		/* 8216F158h case    0:*/		return 0x8216F15C;
		  /* 8216F15Ch */ case    1:  		/* bl -909060 */
		/* 8216F15Ch case    1:*/		regs.LR = 0x8216F160; return 0x82091258;
		/* 8216F15Ch case    1:*/		return 0x8216F160;
		  /* 8216F160h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216F160h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216F160h case    2:*/		return 0x8216F164;
		  /* 8216F164h */ case    3:  		/* mr R28, R3 */
		/* 8216F164h case    3:*/		regs.R28 = regs.R3;
		/* 8216F164h case    3:*/		return 0x8216F168;
		  /* 8216F168h */ case    4:  		/* mr R29, R4 */
		/* 8216F168h case    4:*/		regs.R29 = regs.R4;
		/* 8216F168h case    4:*/		return 0x8216F16C;
		  /* 8216F16Ch */ case    5:  		/* li R3, 0 */
		/* 8216F16Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216F16Ch case    5:*/		return 0x8216F170;
		  /* 8216F170h */ case    6:  		/* li R30, 0 */
		/* 8216F170h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216F170h case    6:*/		return 0x8216F174;
		  /* 8216F174h */ case    7:  		/* addi R31, R28, 4 */
		/* 8216F174h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R28,0x4);
		/* 8216F174h case    7:*/		return 0x8216F178;
		  /* 8216F178h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 8216F178h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216F178h case    8:*/		return 0x8216F17C;
		  /* 8216F17Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8216F17Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216F17Ch case    9:*/		return 0x8216F180;
		  /* 8216F180h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 8216F180h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216F1A0;  }
		/* 8216F180h case   10:*/		return 0x8216F184;
		  /* 8216F184h */ case   11:  		/* cmplw CR6, R11, R29 */
		/* 8216F184h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8216F184h case   11:*/		return 0x8216F188;
		  /* 8216F188h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 8216F188h case   12:*/		if ( regs.CR[6].eq ) { return 0x8216F1A0;  }
		/* 8216F188h case   12:*/		return 0x8216F18C;
		  /* 8216F18Ch */ case   13:  		/* mr R4, R29 */
		/* 8216F18Ch case   13:*/		regs.R4 = regs.R29;
		/* 8216F18Ch case   13:*/		return 0x8216F190;
		  /* 8216F190h */ case   14:  		/* mr R3, R28 */
		/* 8216F190h case   14:*/		regs.R3 = regs.R28;
		/* 8216F190h case   14:*/		return 0x8216F194;
		  /* 8216F194h */ case   15:  		/* bl -940 */
		/* 8216F194h case   15:*/		regs.LR = 0x8216F198; return 0x8216EDE8;
		/* 8216F194h case   15:*/		return 0x8216F198;
		  /* 8216F198h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F198h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F198h case   16:*/		return 0x8216F19C;
		  /* 8216F19Ch */ case   17:  		/* bc 4, CR0_EQ, 20 */
		/* 8216F19Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x8216F1B0;  }
		/* 8216F19Ch case   17:*/		return 0x8216F1A0;
	}
	return 0x8216F1A0;
} // Block from 8216F158h-8216F1A0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8216F1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F1A0);
		  /* 8216F1A0h */ case    0:  		/* addi R30, R30, 1 */
		/* 8216F1A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8216F1A0h case    0:*/		return 0x8216F1A4;
		  /* 8216F1A4h */ case    1:  		/* addi R31, R31, 4 */
		/* 8216F1A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8216F1A4h case    1:*/		return 0x8216F1A8;
		  /* 8216F1A8h */ case    2:  		/* cmplwi CR6, R30, 6 */
		/* 8216F1A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000006);
		/* 8216F1A8h case    2:*/		return 0x8216F1AC;
		  /* 8216F1ACh */ case    3:  		/* bc 4, CR6_GT, -52 */
		/* 8216F1ACh case    3:*/		if ( !regs.CR[6].gt ) { return 0x8216F178;  }
		/* 8216F1ACh case    3:*/		return 0x8216F1B0;
	}
	return 0x8216F1B0;
} // Block from 8216F1A0h-8216F1B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216F1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F1B0);
		  /* 8216F1B0h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F1B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F1B0h case    0:*/		return 0x8216F1B4;
		  /* 8216F1B4h */ case    1:  		/* bc 4, CR0_EQ, 68 */
		/* 8216F1B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216F1F8;  }
		/* 8216F1B4h case    1:*/		return 0x8216F1B8;
		  /* 8216F1B8h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 8216F1B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216F1B8h case    2:*/		return 0x8216F1BC;
		  /* 8216F1BCh */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216F1BCh case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216F1BCh case    3:*/		return 0x8216F1C0;
		  /* 8216F1C0h */ case    4:  		/* cmplwi CR6, R11, 32 */
		/* 8216F1C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 8216F1C0h case    4:*/		return 0x8216F1C4;
		  /* 8216F1C4h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 8216F1C4h case    5:*/		if ( regs.CR[6].lt ) { return 0x8216F1D4;  }
		/* 8216F1C4h case    5:*/		return 0x8216F1C8;
		  /* 8216F1C8h */ case    6:  		/* cmplwi CR6, R11, 82 */
		/* 8216F1C8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 8216F1C8h case    6:*/		return 0x8216F1CC;
		  /* 8216F1CCh */ case    7:  		/* li R11, 1 */
		/* 8216F1CCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216F1CCh case    7:*/		return 0x8216F1D0;
		  /* 8216F1D0h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8216F1D0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8216F1D8;  }
		/* 8216F1D0h case    8:*/		return 0x8216F1D4;
	}
	return 0x8216F1D4;
} // Block from 8216F1B0h-8216F1D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216F1D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F1D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F1D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F1D4);
		  /* 8216F1D4h */ case    0:  		/* li R11, 0 */
		/* 8216F1D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216F1D4h case    0:*/		return 0x8216F1D8;
	}
	return 0x8216F1D8;
} // Block from 8216F1D4h-8216F1D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F1D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F1D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F1D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F1D8);
		  /* 8216F1D8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216F1D8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216F1D8h case    0:*/		return 0x8216F1DC;
		  /* 8216F1DCh */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8216F1DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8216F1F8;  }
		/* 8216F1DCh case    1:*/		return 0x8216F1E0;
		  /* 8216F1E0h */ case    2:  		/* lwz R11, <#[R28 + 28]> */
		/* 8216F1E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000001C) );
		/* 8216F1E0h case    2:*/		return 0x8216F1E4;
		  /* 8216F1E4h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8216F1E4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216F1E4h case    3:*/		return 0x8216F1E8;
		  /* 8216F1E8h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8216F1E8h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216F1F8;  }
		/* 8216F1E8h case    4:*/		return 0x8216F1EC;
		  /* 8216F1ECh */ case    5:  		/* cmplw CR6, R11, R29 */
		/* 8216F1ECh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8216F1ECh case    5:*/		return 0x8216F1F0;
		  /* 8216F1F0h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 8216F1F0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216F1F8;  }
		/* 8216F1F0h case    6:*/		return 0x8216F1F4;
		  /* 8216F1F4h */ case    7:  		/* li R3, 1 */
		/* 8216F1F4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216F1F4h case    7:*/		return 0x8216F1F8;
	}
	return 0x8216F1F8;
} // Block from 8216F1D8h-8216F1F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216F1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F1F8);
		  /* 8216F1F8h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F1F8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F1F8h case    0:*/		return 0x8216F1FC;
		  /* 8216F1FCh */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 8216F1FCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216F214;  }
		/* 8216F1FCh case    1:*/		return 0x8216F200;
		  /* 8216F200h */ case    2:  		/* lwz R11, <#[R28 + 28]> */
		/* 8216F200h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000001C) );
		/* 8216F200h case    2:*/		return 0x8216F204;
		  /* 8216F204h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8216F204h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216F204h case    3:*/		return 0x8216F208;
		  /* 8216F208h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 8216F208h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216F214;  }
		/* 8216F208h case    4:*/		return 0x8216F20C;
		  /* 8216F20Ch */ case    5:  		/* mr R3, R29 */
		/* 8216F20Ch case    5:*/		regs.R3 = regs.R29;
		/* 8216F20Ch case    5:*/		return 0x8216F210;
		  /* 8216F210h */ case    6:  		/* bl 133128 */
		/* 8216F210h case    6:*/		regs.LR = 0x8216F214; return 0x8218FA18;
		/* 8216F210h case    6:*/		return 0x8216F214;
	}
	return 0x8216F214;
} // Block from 8216F1F8h-8216F214h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216F214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F214);
		  /* 8216F214h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F214h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F214h case    0:*/		return 0x8216F218;
		  /* 8216F218h */ case    1:  		/* bc 4, CR0_EQ, 60 */
		/* 8216F218h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216F254;  }
		/* 8216F218h case    1:*/		return 0x8216F21C;
		  /* 8216F21Ch */ case    2:  		/* lwz R11, <#[R28 + 20]> */
		/* 8216F21Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8216F21Ch case    2:*/		return 0x8216F220;
		  /* 8216F220h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8216F220h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216F220h case    3:*/		return 0x8216F224;
		  /* 8216F224h */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 8216F224h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216F254;  }
		/* 8216F224h case    4:*/		return 0x8216F228;
		  /* 8216F228h */ case    5:  		/* cmplw CR6, R11, R29 */
		/* 8216F228h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8216F228h case    5:*/		return 0x8216F22C;
		  /* 8216F22Ch */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 8216F22Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8216F254;  }
		/* 8216F22Ch case    6:*/		return 0x8216F230;
		  /* 8216F230h */ case    7:  		/* lwz R11, <#[R29 + 8]> */
		/* 8216F230h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8216F230h case    7:*/		return 0x8216F234;
		  /* 8216F234h */ case    8:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 8216F234h case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 8216F234h case    8:*/		return 0x8216F238;
		  /* 8216F238h */ case    9:  		/* cmplwi CR6, R10, 12288 */
		/* 8216F238h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003000);
		/* 8216F238h case    9:*/		return 0x8216F23C;
		  /* 8216F23Ch */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8216F23Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x8216F24C;  }
		/* 8216F23Ch case   10:*/		return 0x8216F240;
		  /* 8216F240h */ case   11:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 8216F240h case   11:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 8216F240h case   11:*/		return 0x8216F244;
		  /* 8216F244h */ case   12:  		/* li R11, 1 */
		/* 8216F244h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216F244h case   12:*/		return 0x8216F248;
		  /* 8216F248h */ case   13:  		/* bc 4, CR0_EQ, 8 */
		/* 8216F248h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8216F250;  }
		/* 8216F248h case   13:*/		return 0x8216F24C;
	}
	return 0x8216F24C;
} // Block from 8216F214h-8216F24Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216F24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F24C);
		  /* 8216F24Ch */ case    0:  		/* li R11, 0 */
		/* 8216F24Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216F24Ch case    0:*/		return 0x8216F250;
	}
	return 0x8216F250;
} // Block from 8216F24Ch-8216F250h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F250);
		  /* 8216F250h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8216F250h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8216F250h case    0:*/		return 0x8216F254;
	}
	return 0x8216F254;
} // Block from 8216F250h-8216F254h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F254);
		  /* 8216F254h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F254h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F254h case    0:*/		return 0x8216F258;
		  /* 8216F258h */ case    1:  		/* bc 4, CR0_EQ, 108 */
		/* 8216F258h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216F2C4;  }
		/* 8216F258h case    1:*/		return 0x8216F25C;
		  /* 8216F25Ch */ case    2:  		/* lwz R9, <#[R29]> */
		/* 8216F25Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 8216F25Ch case    2:*/		return 0x8216F260;
		  /* 8216F260h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 8216F260h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8216F260h case    3:*/		return 0x8216F264;
		  /* 8216F264h */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 8216F264h case    4:*/		if ( regs.CR[6].eq ) { return 0x8216F2C4;  }
		/* 8216F264h case    4:*/		return 0x8216F268;
		  /* 8216F268h */ case    5:  		/* lwz R10, <#[R9]> */
		/* 8216F268h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8216F268h case    5:*/		return 0x8216F26C;
		  /* 8216F26Ch */ case    6:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 8216F26Ch case    6:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 8216F26Ch case    6:*/		return 0x8216F270;
		  /* 8216F270h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8216F270h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216F280;  }
		/* 8216F270h case    7:*/		return 0x8216F274;
		  /* 8216F274h */ case    8:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 8216F274h case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 8216F274h case    8:*/		return 0x8216F278;
		  /* 8216F278h */ case    9:  		/* li R11, 1 */
		/* 8216F278h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216F278h case    9:*/		return 0x8216F27C;
		  /* 8216F27Ch */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 8216F27Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x8216F284;  }
		/* 8216F27Ch case   10:*/		return 0x8216F280;
	}
	return 0x8216F280;
} // Block from 8216F254h-8216F280h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216F280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F280);
		  /* 8216F280h */ case    0:  		/* li R11, 0 */
		/* 8216F280h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216F280h case    0:*/		return 0x8216F284;
	}
	return 0x8216F284;
} // Block from 8216F280h-8216F284h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F284);
		  /* 8216F284h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216F284h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216F284h case    0:*/		return 0x8216F288;
		  /* 8216F288h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8216F288h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216F2B8;  }
		/* 8216F288h case    1:*/		return 0x8216F28C;
		  /* 8216F28Ch */ case    2:  		/* rlwinm R11, R10, 19, 20, 31 */
		/* 8216F28Ch case    2:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R10);
		/* 8216F28Ch case    2:*/		return 0x8216F290;
		  /* 8216F290h */ case    3:  		/* addi R11, R11, 1 */
		/* 8216F290h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216F290h case    3:*/		return 0x8216F294;
		  /* 8216F294h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216F294h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216F294h case    4:*/		return 0x8216F298;
		  /* 8216F298h */ case    5:  		/* lwzx R11, <#[R11 + R28]> */
		/* 8216F298h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8216F298h case    5:*/		return 0x8216F29C;
		  /* 8216F29Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8216F29Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216F29Ch case    6:*/		return 0x8216F2A0;
		  /* 8216F2A0h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 8216F2A0h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216F2B8;  }
		/* 8216F2A0h case    7:*/		return 0x8216F2A4;
		  /* 8216F2A4h */ case    8:  		/* cmplw CR6, R11, R29 */
		/* 8216F2A4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8216F2A4h case    8:*/		return 0x8216F2A8;
		  /* 8216F2A8h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 8216F2A8h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216F2B8;  }
		/* 8216F2A8h case    9:*/		return 0x8216F2AC;
		  /* 8216F2ACh */ case   10:  		/* lwz R10, <#[R9 + 12]> */
		/* 8216F2ACh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000C) );
		/* 8216F2ACh case   10:*/		return 0x8216F2B0;
		  /* 8216F2B0h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 8216F2B0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216F2B0h case   11:*/		return 0x8216F2B4;
		  /* 8216F2B4h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 8216F2B4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8216F2C0;  }
		/* 8216F2B4h case   12:*/		return 0x8216F2B8;
	}
	return 0x8216F2B8;
} // Block from 8216F284h-8216F2B8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216F2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F2B8);
		  /* 8216F2B8h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 8216F2B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8216F2B8h case    0:*/		return 0x8216F2BC;
		  /* 8216F2BCh */ case    1:  		/* b -92 */
		/* 8216F2BCh case    1:*/		return 0x8216F260;
		/* 8216F2BCh case    1:*/		return 0x8216F2C0;
	}
	return 0x8216F2C0;
} // Block from 8216F2B8h-8216F2C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F2C0);
		  /* 8216F2C0h */ case    0:  		/* li R3, 1 */
		/* 8216F2C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216F2C0h case    0:*/		return 0x8216F2C4;
	}
	return 0x8216F2C4;
} // Block from 8216F2C0h-8216F2C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F2C4);
		  /* 8216F2C4h */ case    0:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 8216F2C4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F2C4h case    0:*/		return 0x8216F2C8;
		  /* 8216F2C8h */ case    1:  		/* cntlzw R11, R11 */
		/* 8216F2C8h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8216F2C8h case    1:*/		return 0x8216F2CC;
		  /* 8216F2CCh */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8216F2CCh case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8216F2CCh case    2:*/		return 0x8216F2D0;
		  /* 8216F2D0h */ case    3:  		/* addi R1, R1, 128 */
		/* 8216F2D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216F2D0h case    3:*/		return 0x8216F2D4;
		  /* 8216F2D4h */ case    4:  		/* b -909356 */
		/* 8216F2D4h case    4:*/		return 0x820912A8;
		/* 8216F2D4h case    4:*/		return 0x8216F2D8;
		  /* 8216F2D8h */ case    5:  		/* rldicl R9, R5, 0, 58 */
		/* 8216F2D8h case    5:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R5);
		/* 8216F2D8h case    5:*/		return 0x8216F2DC;
		  /* 8216F2DCh */ case    6:  		/* li R8, 2 */
		/* 8216F2DCh case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8216F2DCh case    6:*/		return 0x8216F2E0;
		  /* 8216F2E0h */ case    7:  		/* rlwinm R10, R5, 29, 3, 28 */
		/* 8216F2E0h case    7:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R10,regs.R5);
		/* 8216F2E0h case    7:*/		return 0x8216F2E4;
		  /* 8216F2E4h */ case    8:  		/* rlwinm R6, R5, 26, 6, 31 */
		/* 8216F2E4h case    8:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R6,regs.R5);
		/* 8216F2E4h case    8:*/		return 0x8216F2E8;
		  /* 8216F2E8h */ case    9:  		/* rlwinm R7, R4, 26, 6, 31 */
		/* 8216F2E8h case    9:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R7,regs.R4);
		/* 8216F2E8h case    9:*/		return 0x8216F2EC;
		  /* 8216F2ECh */ case   10:  		/* rlwinm R11, R4, 29, 3, 28 */
		/* 8216F2ECh case   10:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R11,regs.R4);
		/* 8216F2ECh case   10:*/		return 0x8216F2F0;
		  /* 8216F2F0h */ case   11:  		/* rldicl R5, R4, 0, 58 */
		/* 8216F2F0h case   11:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R5,regs.R4);
		/* 8216F2F0h case   11:*/		return 0x8216F2F4;
		  /* 8216F2F4h */ case   12:  		/* sld R9, R8, R9 */
		/* 8216F2F4h case   12:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8216F2F4h case   12:*/		return 0x8216F2F8;
		  /* 8216F2F8h */ case   13:  		/* li R4, -1 */
		/* 8216F2F8h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 8216F2F8h case   13:*/		return 0x8216F2FC;
		  /* 8216F2FCh */ case   14:  		/* add R8, R10, R3 */
		/* 8216F2FCh case   14:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R3);
		/* 8216F2FCh case   14:*/		return 0x8216F300;
		  /* 8216F300h */ case   15:  		/* add R11, R11, R3 */
		/* 8216F300h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8216F300h case   15:*/		return 0x8216F304;
		  /* 8216F304h */ case   16:  		/* sld R10, R4, R5 */
		/* 8216F304h case   16:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R4,regs.R5);
		/* 8216F304h case   16:*/		return 0x8216F308;
		  /* 8216F308h */ case   17:  		/* addi R9, R9, -1 */
		/* 8216F308h case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8216F308h case   17:*/		return 0x8216F30C;
		  /* 8216F30Ch */ case   18:  		/* cmplw CR6, R7, R6 */
		/* 8216F30Ch case   18:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8216F30Ch case   18:*/		return 0x8216F310;
		  /* 8216F310h */ case   19:  		/* bc 4, CR6_EQ, 40 */
		/* 8216F310h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8216F338;  }
		/* 8216F310h case   19:*/		return 0x8216F314;
		  /* 8216F314h */ case   20:  		/* ld R11, <#[R11]> */
		/* 8216F314h case   20:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216F314h case   20:*/		return 0x8216F318;
		  /* 8216F318h */ case   21:  		/* and R11, R11, R9 */
		/* 8216F318h case   21:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216F318h case   21:*/		return 0x8216F31C;
		  /* 8216F31Ch */ case   22:  		/* and R11, R11, R10 */
		/* 8216F31Ch case   22:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216F31Ch case   22:*/		return 0x8216F320;
		  /* 8216F320h */ case   23:  		/* cmpldi CR6, R11, 0 */
		/* 8216F320h case   23:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 8216F320h case   23:*/		return 0x8216F324;
		  /* 8216F324h */ case   24:  		/* li R11, 1 */
		/* 8216F324h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216F324h case   24:*/		return 0x8216F328;
		  /* 8216F328h */ case   25:  		/* bc 4, CR6_EQ, 8 */
		/* 8216F328h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8216F330;  }
		/* 8216F328h case   25:*/		return 0x8216F32C;
		  /* 8216F32Ch */ case   26:  		/* li R11, 0 */
		/* 8216F32Ch case   26:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216F32Ch case   26:*/		return 0x8216F330;
	}
	return 0x8216F330;
} // Block from 8216F2C4h-8216F330h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8216F330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F330);
		  /* 8216F330h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8216F330h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8216F330h case    0:*/		return 0x8216F334;
		  /* 8216F334h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216F334h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F334h case    1:*/		return 0x8216F338;
	}
	return 0x8216F338;
} // Block from 8216F330h-8216F338h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F338);
		  /* 8216F338h */ case    0:  		/* ld R7, <#[R11]> */
		/* 8216F338h case    0:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8216F338h case    0:*/		return 0x8216F33C;
		  /* 8216F33Ch */ case    1:  		/* and R10, R7, R10 */
		/* 8216F33Ch case    1:*/		cpu::op::and<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 8216F33Ch case    1:*/		return 0x8216F340;
		  /* 8216F340h */ case    2:  		/* b 16 */
		/* 8216F340h case    2:*/		return 0x8216F350;
		/* 8216F340h case    2:*/		return 0x8216F344;
		  /* 8216F344h */ case    3:  		/* li R3, 1 */
		/* 8216F344h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216F344h case    3:*/		return 0x8216F348;
		  /* 8216F348h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216F348h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F348h case    4:*/		return 0x8216F34C;
	}
	return 0x8216F34C;
} // Block from 8216F338h-8216F34Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216F34Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F34C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F34C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F34C);
		  /* 8216F34Ch */ case    0:  		/* ld R10, <#[R11]> */
		/* 8216F34Ch case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216F34Ch case    0:*/		return 0x8216F350;
	}
	return 0x8216F350;
} // Block from 8216F34Ch-8216F350h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F350);
		  /* 8216F350h */ case    0:  		/* cmpldi CR6, R10, 0 */
		/* 8216F350h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 8216F350h case    0:*/		return 0x8216F354;
		  /* 8216F354h */ case    1:  		/* bc 4, CR6_EQ, -16 */
		/* 8216F354h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216F344;  }
		/* 8216F354h case    1:*/		return 0x8216F358;
		  /* 8216F358h */ case    2:  		/* addi R11, R11, 8 */
		/* 8216F358h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8216F358h case    2:*/		return 0x8216F35C;
		  /* 8216F35Ch */ case    3:  		/* cmplw CR6, R11, R8 */
		/* 8216F35Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8216F35Ch case    3:*/		return 0x8216F360;
		  /* 8216F360h */ case    4:  		/* bc 12, CR6_LT, -20 */
		/* 8216F360h case    4:*/		if ( regs.CR[6].lt ) { return 0x8216F34C;  }
		/* 8216F360h case    4:*/		return 0x8216F364;
		  /* 8216F364h */ case    5:  		/* ld R11, <#[R8]> */
		/* 8216F364h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8216F364h case    5:*/		return 0x8216F368;
		  /* 8216F368h */ case    6:  		/* li R3, 1 */
		/* 8216F368h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216F368h case    6:*/		return 0x8216F36C;
		  /* 8216F36Ch */ case    7:  		/* and R11, R11, R9 */
		/* 8216F36Ch case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8216F36Ch case    7:*/		return 0x8216F370;
		  /* 8216F370h */ case    8:  		/* cmpldi CR6, R11, 0 */
		/* 8216F370h case    8:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 8216F370h case    8:*/		return 0x8216F374;
		  /* 8216F374h */ case    9:  		/* bclr 4, CR6_EQ */
		/* 8216F374h case    9:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8216F374h case    9:*/		return 0x8216F378;
	}
	return 0x8216F378;
} // Block from 8216F350h-8216F378h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216F378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F378);
		  /* 8216F378h */ case    0:  		/* li R3, 0 */
		/* 8216F378h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216F378h case    0:*/		return 0x8216F37C;
		  /* 8216F37Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216F37Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F37Ch case    1:*/		return 0x8216F380;
	}
	return 0x8216F380;
} // Block from 8216F378h-8216F380h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F380);
		  /* 8216F380h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 8216F380h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8216F380h case    0:*/		return 0x8216F384;
		  /* 8216F384h */ case    1:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8216F384h case    1:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8216F384h case    1:*/		return 0x8216F388;
		  /* 8216F388h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8216F388h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216F398;  }
		/* 8216F388h case    2:*/		return 0x8216F38C;
		  /* 8216F38Ch */ case    3:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 8216F38Ch case    3:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 8216F38Ch case    3:*/		return 0x8216F390;
		  /* 8216F390h */ case    4:  		/* li R10, 1 */
		/* 8216F390h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216F390h case    4:*/		return 0x8216F394;
		  /* 8216F394h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 8216F394h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216F39C;  }
		/* 8216F394h case    5:*/		return 0x8216F398;
	}
	return 0x8216F398;
} // Block from 8216F380h-8216F398h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216F398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F398);
		  /* 8216F398h */ case    0:  		/* li R10, 0 */
		/* 8216F398h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216F398h case    0:*/		return 0x8216F39C;
	}
	return 0x8216F39C;
} // Block from 8216F398h-8216F39Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F39C);
		  /* 8216F39Ch */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8216F39Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8216F39Ch case    0:*/		return 0x8216F3A0;
		  /* 8216F3A0h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 8216F3A0h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8216F3A0h case    1:*/		return 0x8216F3A4;
	}
	return 0x8216F3A4;
} // Block from 8216F39Ch-8216F3A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F3A4);
		  /* 8216F3A4h */ case    0:  		/* rlwinm R11, R11, 19, 20, 31 */
		/* 8216F3A4h case    0:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R11);
		/* 8216F3A4h case    0:*/		return 0x8216F3A8;
		  /* 8216F3A8h */ case    1:  		/* addi R11, R11, 1 */
		/* 8216F3A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216F3A8h case    1:*/		return 0x8216F3AC;
		  /* 8216F3ACh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216F3ACh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216F3ACh case    2:*/		return 0x8216F3B0;
		  /* 8216F3B0h */ case    3:  		/* lwzx R10, <#[R11 + R3]> */
		/* 8216F3B0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216F3B0h case    3:*/		return 0x8216F3B4;
		  /* 8216F3B4h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 8216F3B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216F3B4h case    4:*/		return 0x8216F3B8;
		  /* 8216F3B8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 8216F3B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216F3D0;  }
		/* 8216F3B8h case    5:*/		return 0x8216F3BC;
		  /* 8216F3BCh */ case    6:  		/* cmplw CR6, R10, R6 */
		/* 8216F3BCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8216F3BCh case    6:*/		return 0x8216F3C0;
		  /* 8216F3C0h */ case    7:  		/* bclr 12, CR6_EQ */
		/* 8216F3C0h case    7:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8216F3C0h case    7:*/		return 0x8216F3C4;
	}
	return 0x8216F3C4;
} // Block from 8216F3A4h-8216F3C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216F3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F3C4);
		  /* 8216F3C4h */ case    0:  		/* lwz R3, <#[R3]> */
		/* 8216F3C4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8216F3C4h case    0:*/		return 0x8216F3C8;
		  /* 8216F3C8h */ case    1:  		/* li R4, 4800 */
		/* 8216F3C8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8216F3C8h case    1:*/		return 0x8216F3CC;
		  /* 8216F3CCh */ case    2:  		/* b -120164 */
		/* 8216F3CCh case    2:*/		return 0x82151E68;
		/* 8216F3CCh case    2:*/		return 0x8216F3D0;
	}
	return 0x8216F3D0;
} // Block from 8216F3C4h-8216F3D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F3D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F3D0);
		  /* 8216F3D0h */ case    0:  		/* stwx R6, <#[R11 + R3]> */
		/* 8216F3D0h case    0:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216F3D0h case    0:*/		return 0x8216F3D4;
		  /* 8216F3D4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216F3D4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F3D4h case    1:*/		return 0x8216F3D8;
	}
	return 0x8216F3D8;
} // Block from 8216F3D0h-8216F3D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F3D8);
		  /* 8216F3D8h */ case    0:  		/* mfspr R12, LR */
		/* 8216F3D8h case    0:*/		regs.R12 = regs.LR;
		/* 8216F3D8h case    0:*/		return 0x8216F3DC;
		  /* 8216F3DCh */ case    1:  		/* bl -909696 */
		/* 8216F3DCh case    1:*/		regs.LR = 0x8216F3E0; return 0x8209125C;
		/* 8216F3DCh case    1:*/		return 0x8216F3E0;
		  /* 8216F3E0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216F3E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216F3E0h case    2:*/		return 0x8216F3E4;
		  /* 8216F3E4h */ case    3:  		/* li R31, 0 */
		/* 8216F3E4h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8216F3E4h case    3:*/		return 0x8216F3E8;
		  /* 8216F3E8h */ case    4:  		/* mr R30, R3 */
		/* 8216F3E8h case    4:*/		regs.R30 = regs.R3;
		/* 8216F3E8h case    4:*/		return 0x8216F3EC;
		  /* 8216F3ECh */ case    5:  		/* mr R29, R4 */
		/* 8216F3ECh case    5:*/		regs.R29 = regs.R4;
		/* 8216F3ECh case    5:*/		return 0x8216F3F0;
		  /* 8216F3F0h */ case    6:  		/* addi R11, R3, 4 */
		/* 8216F3F0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 8216F3F0h case    6:*/		return 0x8216F3F4;
		  /* 8216F3F4h */ case    7:  		/* mr R10, R31 */
		/* 8216F3F4h case    7:*/		regs.R10 = regs.R31;
		/* 8216F3F4h case    7:*/		return 0x8216F3F8;
		  /* 8216F3F8h */ case    8:  		/* lwz R9, <#[R11]> */
		/* 8216F3F8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216F3F8h case    8:*/		return 0x8216F3FC;
		  /* 8216F3FCh */ case    9:  		/* cmplw CR6, R29, R9 */
		/* 8216F3FCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R9);
		/* 8216F3FCh case    9:*/		return 0x8216F400;
		  /* 8216F400h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 8216F400h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8216F408;  }
		/* 8216F400h case   10:*/		return 0x8216F404;
		  /* 8216F404h */ case   11:  		/* stw R31, <#[R11]> */
		/* 8216F404h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8216F404h case   11:*/		return 0x8216F408;
	}
	return 0x8216F408;
} // Block from 8216F3D8h-8216F408h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216F408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F408);
		  /* 8216F408h */ case    0:  		/* addi R10, R10, 1 */
		/* 8216F408h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216F408h case    0:*/		return 0x8216F40C;
		  /* 8216F40Ch */ case    1:  		/* addi R11, R11, 4 */
		/* 8216F40Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216F40Ch case    1:*/		return 0x8216F410;
		  /* 8216F410h */ case    2:  		/* cmplwi CR6, R10, 9 */
		/* 8216F410h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000009);
		/* 8216F410h case    2:*/		return 0x8216F414;
		  /* 8216F414h */ case    3:  		/* bc 12, CR6_LT, -28 */
		/* 8216F414h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216F3F8;  }
		/* 8216F414h case    3:*/		return 0x8216F418;
		  /* 8216F418h */ case    4:  		/* mr R4, R29 */
		/* 8216F418h case    4:*/		regs.R4 = regs.R29;
		/* 8216F418h case    4:*/		return 0x8216F41C;
		  /* 8216F41Ch */ case    5:  		/* mr R3, R30 */
		/* 8216F41Ch case    5:*/		regs.R3 = regs.R30;
		/* 8216F41Ch case    5:*/		return 0x8216F420;
		  /* 8216F420h */ case    6:  		/* bl -1312 */
		/* 8216F420h case    6:*/		regs.LR = 0x8216F424; return 0x8216EF00;
		/* 8216F420h case    6:*/		return 0x8216F424;
		  /* 8216F424h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F424h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F424h case    7:*/		return 0x8216F428;
		  /* 8216F428h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 8216F428h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216F430;  }
		/* 8216F428h case    8:*/		return 0x8216F42C;
		  /* 8216F42Ch */ case    9:  		/* stw R31, <#[R30 + 48]> */
		/* 8216F42Ch case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000030) );
		/* 8216F42Ch case    9:*/		return 0x8216F430;
	}
	return 0x8216F430;
} // Block from 8216F408h-8216F430h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216F430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F430);
		  /* 8216F430h */ case    0:  		/* lwz R31, <#[R29]> */
		/* 8216F430h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 8216F430h case    0:*/		return 0x8216F434;
		  /* 8216F434h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8216F434h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216F434h case    1:*/		return 0x8216F438;
		  /* 8216F438h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8216F438h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216F458;  }
		/* 8216F438h case    2:*/		return 0x8216F43C;
		  /* 8216F43Ch */ case    3:  		/* mr R5, R29 */
		/* 8216F43Ch case    3:*/		regs.R5 = regs.R29;
		/* 8216F43Ch case    3:*/		return 0x8216F440;
		  /* 8216F440h */ case    4:  		/* lwz R6, <#[R31 + 12]> */
		/* 8216F440h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216F440h case    4:*/		return 0x8216F444;
		  /* 8216F444h */ case    5:  		/* mr R4, R31 */
		/* 8216F444h case    5:*/		regs.R4 = regs.R31;
		/* 8216F444h case    5:*/		return 0x8216F448;
		  /* 8216F448h */ case    6:  		/* mr R3, R30 */
		/* 8216F448h case    6:*/		regs.R3 = regs.R30;
		/* 8216F448h case    6:*/		return 0x8216F44C;
		  /* 8216F44Ch */ case    7:  		/* bl -204 */
		/* 8216F44Ch case    7:*/		regs.LR = 0x8216F450; return 0x8216F380;
		/* 8216F44Ch case    7:*/		return 0x8216F450;
		  /* 8216F450h */ case    8:  		/* lwz R31, <#[R31 + 4]> */
		/* 8216F450h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8216F450h case    8:*/		return 0x8216F454;
		  /* 8216F454h */ case    9:  		/* b -32 */
		/* 8216F454h case    9:*/		return 0x8216F434;
		/* 8216F454h case    9:*/		return 0x8216F458;
	}
	return 0x8216F458;
} // Block from 8216F430h-8216F458h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216F458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F458);
		  /* 8216F458h */ case    0:  		/* addi R1, R1, 112 */
		/* 8216F458h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216F458h case    0:*/		return 0x8216F45C;
		  /* 8216F45Ch */ case    1:  		/* b -909744 */
		/* 8216F45Ch case    1:*/		return 0x820912AC;
		/* 8216F45Ch case    1:*/		return 0x8216F460;
		  /* 8216F460h */ case    2:  		/* rlwinm R11, R4, 30, 2, 29 */
		/* 8216F460h case    2:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R11,regs.R4);
		/* 8216F460h case    2:*/		return 0x8216F464;
		  /* 8216F464h */ case    3:  		/* rlwinm R10, R4, 24, 8, 31 */
		/* 8216F464h case    3:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R10,regs.R4);
		/* 8216F464h case    3:*/		return 0x8216F468;
		  /* 8216F468h */ case    4:  		/* addi R9, R11, 3 */
		/* 8216F468h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 8216F468h case    4:*/		return 0x8216F46C;
		  /* 8216F46Ch */ case    5:  		/* addi R8, R10, 1 */
		/* 8216F46Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 8216F46Ch case    5:*/		return 0x8216F470;
		  /* 8216F470h */ case    6:  		/* rldicl R10, R9, 0, 58 */
		/* 8216F470h case    6:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R9);
		/* 8216F470h case    6:*/		return 0x8216F474;
		  /* 8216F474h */ case    7:  		/* li R9, 2 */
		/* 8216F474h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8216F474h case    7:*/		return 0x8216F478;
		  /* 8216F478h */ case    8:  		/* rldicl R11, R11, 0, 58 */
		/* 8216F478h case    8:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R11,regs.R11);
		/* 8216F478h case    8:*/		return 0x8216F47C;
		  /* 8216F47Ch */ case    9:  		/* sld R10, R9, R10 */
		/* 8216F47Ch case    9:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8216F47Ch case    9:*/		return 0x8216F480;
		  /* 8216F480h */ case   10:  		/* rlwinm R9, R8, 3, 0, 28 */
		/* 8216F480h case   10:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R8);
		/* 8216F480h case   10:*/		return 0x8216F484;
		  /* 8216F484h */ case   11:  		/* li R8, -1 */
		/* 8216F484h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8216F484h case   11:*/		return 0x8216F488;
		  /* 8216F488h */ case   12:  		/* addi R10, R10, -1 */
		/* 8216F488h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216F488h case   12:*/		return 0x8216F48C;
		  /* 8216F48Ch */ case   13:  		/* sld R8, R8, R11 */
		/* 8216F48Ch case   13:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8216F48Ch case   13:*/		return 0x8216F490;
		  /* 8216F490h */ case   14:  		/* ldx R7, <#[R9 + R3]> */
		/* 8216F490h case   14:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8216F490h case   14:*/		return 0x8216F494;
		  /* 8216F494h */ case   15:  		/* and R8, R10, R8 */
		/* 8216F494h case   15:*/		cpu::op::and<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 8216F494h case   15:*/		return 0x8216F498;
		  /* 8216F498h */ case   16:  		/* rlwinm R10, R4, 0, 28, 31 */
		/* 8216F498h case   16:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R4);
		/* 8216F498h case   16:*/		return 0x8216F49C;
		  /* 8216F49Ch */ case   17:  		/* and R8, R8, R7 */
		/* 8216F49Ch case   17:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8216F49Ch case   17:*/		return 0x8216F4A0;
		  /* 8216F4A0h */ case   18:  		/* rlwinm R5, R4, 28, 4, 31 */
		/* 8216F4A0h case   18:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R5,regs.R4);
		/* 8216F4A0h case   18:*/		return 0x8216F4A4;
		  /* 8216F4A4h */ case   19:  		/* srd R8, R8, R11 */
		/* 8216F4A4h case   19:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8216F4A4h case   19:*/		return 0x8216F4A8;
		  /* 8216F4A8h */ case   20:  		/* and R8, R8, R10 */
		/* 8216F4A8h case   20:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 8216F4A8h case   20:*/		return 0x8216F4AC;
		  /* 8216F4ACh */ case   21:  		/* cmpldi CR6, R8, 0 */
		/* 8216F4ACh case   21:*/		cpu::op::cmpldi<6>(regs,regs.R8,0x00000000);
		/* 8216F4ACh case   21:*/		return 0x8216F4B0;
		  /* 8216F4B0h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 8216F4B0h case   22:*/		if ( regs.CR[6].eq ) { return 0x8216F4C0;  }
		/* 8216F4B0h case   22:*/		return 0x8216F4B4;
		  /* 8216F4B4h */ case   23:  		/* lwz R3, <#[R3]> */
		/* 8216F4B4h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8216F4B4h case   23:*/		return 0x8216F4B8;
		  /* 8216F4B8h */ case   24:  		/* li R4, 3526 */
		/* 8216F4B8h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0xDC6);
		/* 8216F4B8h case   24:*/		return 0x8216F4BC;
		  /* 8216F4BCh */ case   25:  		/* b -120404 */
		/* 8216F4BCh case   25:*/		return 0x82151E68;
		/* 8216F4BCh case   25:*/		return 0x8216F4C0;
	}
	return 0x8216F4C0;
} // Block from 8216F458h-8216F4C0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216F4C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F4C0);
		  /* 8216F4C0h */ case    0:  		/* ldx R8, <#[R9 + R3]> */
		/* 8216F4C0h case    0:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8216F4C0h case    0:*/		return 0x8216F4C4;
		  /* 8216F4C4h */ case    1:  		/* sld R11, R10, R11 */
		/* 8216F4C4h case    1:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216F4C4h case    1:*/		return 0x8216F4C8;
		  /* 8216F4C8h */ case    2:  		/* or R11, R11, R8 */
		/* 8216F4C8h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8216F4C8h case    2:*/		return 0x8216F4CC;
		  /* 8216F4CCh */ case    3:  		/* stdx R11, <#[R9 + R3]> */
		/* 8216F4CCh case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8216F4CCh case    3:*/		return 0x8216F4D0;
		  /* 8216F4D0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216F4D0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F4D0h case    4:*/		return 0x8216F4D4;
	}
	return 0x8216F4D4;
} // Block from 8216F4C0h-8216F4D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216F4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F4D4);
		  /* 8216F4D4h */ case    0:  		/* nop */
		/* 8216F4D4h case    0:*/		cpu::op::nop();
		/* 8216F4D4h case    0:*/		return 0x8216F4D8;
	}
	return 0x8216F4D8;
} // Block from 8216F4D4h-8216F4D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F4D8);
		  /* 8216F4D8h */ case    0:  		/* mfspr R12, LR */
		/* 8216F4D8h case    0:*/		regs.R12 = regs.LR;
		/* 8216F4D8h case    0:*/		return 0x8216F4DC;
		  /* 8216F4DCh */ case    1:  		/* bl -909960 */
		/* 8216F4DCh case    1:*/		regs.LR = 0x8216F4E0; return 0x82091254;
		/* 8216F4DCh case    1:*/		return 0x8216F4E0;
		  /* 8216F4E0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216F4E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216F4E0h case    2:*/		return 0x8216F4E4;
		  /* 8216F4E4h */ case    3:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 8216F4E4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 8216F4E4h case    3:*/		return 0x8216F4E8;
		  /* 8216F4E8h */ case    4:  		/* rlwinm R31, R4, 2, 0, 29 */
		/* 8216F4E8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R4);
		/* 8216F4E8h case    4:*/		return 0x8216F4EC;
		  /* 8216F4ECh */ case    5:  		/* addi R30, R3, 8 */
		/* 8216F4ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x8);
		/* 8216F4ECh case    5:*/		return 0x8216F4F0;
		  /* 8216F4F0h */ case    6:  		/* add R11, R11, R31 */
		/* 8216F4F0h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8216F4F0h case    6:*/		return 0x8216F4F4;
		  /* 8216F4F4h */ case    7:  		/* mr R28, R3 */
		/* 8216F4F4h case    7:*/		regs.R28 = regs.R3;
		/* 8216F4F4h case    7:*/		return 0x8216F4F8;
		  /* 8216F4F8h */ case    8:  		/* addi R29, R11, -1 */
		/* 8216F4F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFF);
		/* 8216F4F8h case    8:*/		return 0x8216F4FC;
		  /* 8216F4FCh */ case    9:  		/* mr R27, R4 */
		/* 8216F4FCh case    9:*/		regs.R27 = regs.R4;
		/* 8216F4FCh case    9:*/		return 0x8216F500;
		  /* 8216F500h */ case   10:  		/* mr R4, R31 */
		/* 8216F500h case   10:*/		regs.R4 = regs.R31;
		/* 8216F500h case   10:*/		return 0x8216F504;
		  /* 8216F504h */ case   11:  		/* mr R3, R30 */
		/* 8216F504h case   11:*/		regs.R3 = regs.R30;
		/* 8216F504h case   11:*/		return 0x8216F508;
		  /* 8216F508h */ case   12:  		/* mr R5, R29 */
		/* 8216F508h case   12:*/		regs.R5 = regs.R29;
		/* 8216F508h case   12:*/		return 0x8216F50C;
		  /* 8216F50Ch */ case   13:  		/* bl -564 */
		/* 8216F50Ch case   13:*/		regs.LR = 0x8216F510; return 0x8216F2D8;
		/* 8216F50Ch case   13:*/		return 0x8216F510;
		  /* 8216F510h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F510h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F510h case   14:*/		return 0x8216F514;
		  /* 8216F514h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 8216F514h case   15:*/		if ( regs.CR[0].eq ) { return 0x8216F528;  }
		/* 8216F514h case   15:*/		return 0x8216F518;
		  /* 8216F518h */ case   16:  		/* mr R5, R27 */
		/* 8216F518h case   16:*/		regs.R5 = regs.R27;
		/* 8216F518h case   16:*/		return 0x8216F51C;
		  /* 8216F51Ch */ case   17:  		/* lwz R3, <#[R28]> */
		/* 8216F51Ch case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 8216F51Ch case   17:*/		return 0x8216F520;
		  /* 8216F520h */ case   18:  		/* li R4, 3526 */
		/* 8216F520h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0xDC6);
		/* 8216F520h case   18:*/		return 0x8216F524;
		  /* 8216F524h */ case   19:  		/* bl -120508 */
		/* 8216F524h case   19:*/		regs.LR = 0x8216F528; return 0x82151E68;
		/* 8216F524h case   19:*/		return 0x8216F528;
	}
	return 0x8216F528;
} // Block from 8216F4D8h-8216F528h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216F528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F528);
		  /* 8216F528h */ case    0:  		/* mr R5, R29 */
		/* 8216F528h case    0:*/		regs.R5 = regs.R29;
		/* 8216F528h case    0:*/		return 0x8216F52C;
		  /* 8216F52Ch */ case    1:  		/* mr R4, R31 */
		/* 8216F52Ch case    1:*/		regs.R4 = regs.R31;
		/* 8216F52Ch case    1:*/		return 0x8216F530;
		  /* 8216F530h */ case    2:  		/* mr R3, R30 */
		/* 8216F530h case    2:*/		regs.R3 = regs.R30;
		/* 8216F530h case    2:*/		return 0x8216F534;
		  /* 8216F534h */ case    3:  		/* bl 116628 */
		/* 8216F534h case    3:*/		regs.LR = 0x8216F538; return 0x8218BCC8;
		/* 8216F534h case    3:*/		return 0x8216F538;
		  /* 8216F538h */ case    4:  		/* addi R1, R1, 128 */
		/* 8216F538h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216F538h case    4:*/		return 0x8216F53C;
		  /* 8216F53Ch */ case    5:  		/* b -909976 */
		/* 8216F53Ch case    5:*/		return 0x820912A4;
		/* 8216F53Ch case    5:*/		return 0x8216F540;
	}
	return 0x8216F540;
} // Block from 8216F528h-8216F540h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216F540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F540);
		  /* 8216F540h */ case    0:  		/* mfspr R12, LR */
		/* 8216F540h case    0:*/		regs.R12 = regs.LR;
		/* 8216F540h case    0:*/		return 0x8216F544;
		  /* 8216F544h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216F544h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216F544h case    1:*/		return 0x8216F548;
		  /* 8216F548h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8216F548h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F548h case    2:*/		return 0x8216F54C;
		  /* 8216F54Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216F54Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216F54Ch case    3:*/		return 0x8216F550;
		  /* 8216F550h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 8216F550h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8216F550h case    4:*/		return 0x8216F554;
		  /* 8216F554h */ case    5:  		/* mr R31, R4 */
		/* 8216F554h case    5:*/		regs.R31 = regs.R4;
		/* 8216F554h case    5:*/		return 0x8216F558;
		  /* 8216F558h */ case    6:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8216F558h case    6:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8216F558h case    6:*/		return 0x8216F55C;
		  /* 8216F55Ch */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8216F55Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8216F568;  }
		/* 8216F55Ch case    7:*/		return 0x8216F560;
		  /* 8216F560h */ case    8:  		/* li R3, 0 */
		/* 8216F560h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216F560h case    8:*/		return 0x8216F564;
		  /* 8216F564h */ case    9:  		/* b 168 */
		/* 8216F564h case    9:*/		return 0x8216F60C;
		/* 8216F564h case    9:*/		return 0x8216F568;
	}
	return 0x8216F568;
} // Block from 8216F540h-8216F568h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216F568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F568);
		  /* 8216F568h */ case    0:  		/* mr R3, R31 */
		/* 8216F568h case    0:*/		regs.R3 = regs.R31;
		/* 8216F568h case    0:*/		return 0x8216F56C;
		  /* 8216F56Ch */ case    1:  		/* bl 131924 */
		/* 8216F56Ch case    1:*/		regs.LR = 0x8216F570; return 0x8218F8C0;
		/* 8216F56Ch case    1:*/		return 0x8216F570;
		  /* 8216F570h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F570h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F570h case    2:*/		return 0x8216F574;
		  /* 8216F574h */ case    3:  		/* bc 12, CR0_EQ, -20 */
		/* 8216F574h case    3:*/		if ( regs.CR[0].eq ) { return 0x8216F560;  }
		/* 8216F574h case    3:*/		return 0x8216F578;
		  /* 8216F578h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216F578h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216F578h case    4:*/		return 0x8216F57C;
		  /* 8216F57Ch */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216F57Ch case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216F57Ch case    5:*/		return 0x8216F580;
		  /* 8216F580h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 8216F580h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216F580h case    6:*/		return 0x8216F584;
		  /* 8216F584h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 8216F584h case    7:*/		if ( regs.CR[6].lt ) { return 0x8216F594;  }
		/* 8216F584h case    7:*/		return 0x8216F588;
		  /* 8216F588h */ case    8:  		/* cmplwi CR6, R11, 31 */
		/* 8216F588h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 8216F588h case    8:*/		return 0x8216F58C;
		  /* 8216F58Ch */ case    9:  		/* li R11, 1 */
		/* 8216F58Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216F58Ch case    9:*/		return 0x8216F590;
		  /* 8216F590h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 8216F590h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8216F598;  }
		/* 8216F590h case   10:*/		return 0x8216F594;
	}
	return 0x8216F594;
} // Block from 8216F568h-8216F594h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216F594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F594);
		  /* 8216F594h */ case    0:  		/* li R11, 0 */
		/* 8216F594h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216F594h case    0:*/		return 0x8216F598;
	}
	return 0x8216F598;
} // Block from 8216F594h-8216F598h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F598);
		  /* 8216F598h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216F598h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216F598h case    0:*/		return 0x8216F59C;
		  /* 8216F59Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8216F59Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8216F5B4;  }
		/* 8216F59Ch case    1:*/		return 0x8216F5A0;
		  /* 8216F5A0h */ case    2:  		/* mr R3, R31 */
		/* 8216F5A0h case    2:*/		regs.R3 = regs.R31;
		/* 8216F5A0h case    2:*/		return 0x8216F5A4;
		  /* 8216F5A4h */ case    3:  		/* bl -43060 */
		/* 8216F5A4h case    3:*/		regs.LR = 0x8216F5A8; return 0x82164D70;
		/* 8216F5A4h case    3:*/		return 0x8216F5A8;
		  /* 8216F5A8h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8216F5A8h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8216F5A8h case    4:*/		return 0x8216F5AC;
		  /* 8216F5ACh */ case    5:  		/* bc 12, CR0_EQ, 92 */
		/* 8216F5ACh case    5:*/		if ( regs.CR[0].eq ) { return 0x8216F608;  }
		/* 8216F5ACh case    5:*/		return 0x8216F5B0;
		  /* 8216F5B0h */ case    6:  		/* b -80 */
		/* 8216F5B0h case    6:*/		return 0x8216F560;
		/* 8216F5B0h case    6:*/		return 0x8216F5B4;
	}
	return 0x8216F5B4;
} // Block from 8216F598h-8216F5B4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216F5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F5B4);
		  /* 8216F5B4h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216F5B4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216F5B4h case    0:*/		return 0x8216F5B8;
		  /* 8216F5B8h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216F5B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216F5B8h case    1:*/		return 0x8216F5BC;
		  /* 8216F5BCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216F5BCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216F5BCh case    2:*/		return 0x8216F5C0;
		  /* 8216F5C0h */ case    3:  		/* bc 4, CR0_EQ, 72 */
		/* 8216F5C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216F608;  }
		/* 8216F5C0h case    3:*/		return 0x8216F5C4;
		  /* 8216F5C4h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216F5C4h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216F5C4h case    4:*/		return 0x8216F5C8;
		  /* 8216F5C8h */ case    5:  		/* addic. R3, R11, -40 */
		/* 8216F5C8h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFD8);
		/* 8216F5C8h case    5:*/		return 0x8216F5CC;
		  /* 8216F5CCh */ case    6:  		/* bc 12, CR0_EQ, 60 */
		/* 8216F5CCh case    6:*/		if ( regs.CR[0].eq ) { return 0x8216F608;  }
		/* 8216F5CCh case    6:*/		return 0x8216F5D0;
		  /* 8216F5D0h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 8216F5D0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216F5D0h case    7:*/		return 0x8216F5D4;
		  /* 8216F5D4h */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216F5D4h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216F5D4h case    8:*/		return 0x8216F5D8;
		  /* 8216F5D8h */ case    9:  		/* cmplwi CR6, R11, 1 */
		/* 8216F5D8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216F5D8h case    9:*/		return 0x8216F5DC;
		  /* 8216F5DCh */ case   10:  		/* bc 12, CR6_LT, 16 */
		/* 8216F5DCh case   10:*/		if ( regs.CR[6].lt ) { return 0x8216F5EC;  }
		/* 8216F5DCh case   10:*/		return 0x8216F5E0;
		  /* 8216F5E0h */ case   11:  		/* cmplwi CR6, R11, 31 */
		/* 8216F5E0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 8216F5E0h case   11:*/		return 0x8216F5E4;
		  /* 8216F5E4h */ case   12:  		/* li R11, 1 */
		/* 8216F5E4h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216F5E4h case   12:*/		return 0x8216F5E8;
		  /* 8216F5E8h */ case   13:  		/* bc 4, CR6_GT, 8 */
		/* 8216F5E8h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8216F5F0;  }
		/* 8216F5E8h case   13:*/		return 0x8216F5EC;
	}
	return 0x8216F5EC;
} // Block from 8216F5B4h-8216F5ECh (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216F5ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F5EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F5EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F5EC);
		  /* 8216F5ECh */ case    0:  		/* li R11, 0 */
		/* 8216F5ECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216F5ECh case    0:*/		return 0x8216F5F0;
	}
	return 0x8216F5F0;
} // Block from 8216F5ECh-8216F5F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F5F0);
		  /* 8216F5F0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216F5F0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216F5F0h case    0:*/		return 0x8216F5F4;
		  /* 8216F5F4h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8216F5F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216F608;  }
		/* 8216F5F4h case    1:*/		return 0x8216F5F8;
		  /* 8216F5F8h */ case    2:  		/* bl -43144 */
		/* 8216F5F8h case    2:*/		regs.LR = 0x8216F5FC; return 0x82164D70;
		/* 8216F5F8h case    2:*/		return 0x8216F5FC;
		  /* 8216F5FCh */ case    3:  		/* cmplw CR6, R31, R3 */
		/* 8216F5FCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R3);
		/* 8216F5FCh case    3:*/		return 0x8216F600;
		  /* 8216F600h */ case    4:  		/* li R3, 0 */
		/* 8216F600h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216F600h case    4:*/		return 0x8216F604;
		  /* 8216F604h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 8216F604h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216F60C;  }
		/* 8216F604h case    5:*/		return 0x8216F608;
	}
	return 0x8216F608;
} // Block from 8216F5F0h-8216F608h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216F608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F608);
		  /* 8216F608h */ case    0:  		/* li R3, 1 */
		/* 8216F608h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216F608h case    0:*/		return 0x8216F60C;
	}
	return 0x8216F60C;
} // Block from 8216F608h-8216F60Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F60Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F60C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F60C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F60C);
		  /* 8216F60Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 8216F60Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216F60Ch case    0:*/		return 0x8216F610;
		  /* 8216F610h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216F610h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216F610h case    1:*/		return 0x8216F614;
		  /* 8216F614h */ case    2:  		/* mtspr LR, R12 */
		/* 8216F614h case    2:*/		regs.LR = regs.R12;
		/* 8216F614h case    2:*/		return 0x8216F618;
		  /* 8216F618h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8216F618h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F618h case    3:*/		return 0x8216F61C;
		  /* 8216F61Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216F61Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F61Ch case    4:*/		return 0x8216F620;
	}
	return 0x8216F620;
} // Block from 8216F60Ch-8216F620h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216F620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F620);
		  /* 8216F620h */ case    0:  		/* mfspr R12, LR */
		/* 8216F620h case    0:*/		regs.R12 = regs.LR;
		/* 8216F620h case    0:*/		return 0x8216F624;
		  /* 8216F624h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216F624h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216F624h case    1:*/		return 0x8216F628;
		  /* 8216F628h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8216F628h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216F628h case    2:*/		return 0x8216F62C;
		  /* 8216F62Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8216F62Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F62Ch case    3:*/		return 0x8216F630;
		  /* 8216F630h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216F630h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216F630h case    4:*/		return 0x8216F634;
		  /* 8216F634h */ case    5:  		/* li R30, 0 */
		/* 8216F634h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216F634h case    5:*/		return 0x8216F638;
		  /* 8216F638h */ case    6:  		/* stw R4, <#[R3]> */
		/* 8216F638h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8216F638h case    6:*/		return 0x8216F63C;
		  /* 8216F63Ch */ case    7:  		/* mr R31, R3 */
		/* 8216F63Ch case    7:*/		regs.R31 = regs.R3;
		/* 8216F63Ch case    7:*/		return 0x8216F640;
		  /* 8216F640h */ case    8:  		/* std R30, <#[R3 + 8]> */
		/* 8216F640h case    8:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 8216F640h case    8:*/		return 0x8216F644;
		  /* 8216F644h */ case    9:  		/* std R30, <#[R3 + 16]> */
		/* 8216F644h case    9:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 8216F644h case    9:*/		return 0x8216F648;
		  /* 8216F648h */ case   10:  		/* std R30, <#[R3 + 24]> */
		/* 8216F648h case   10:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R3 + 0x00000018) );
		/* 8216F648h case   10:*/		return 0x8216F64C;
		  /* 8216F64Ch */ case   11:  		/* std R30, <#[R3 + 32]> */
		/* 8216F64Ch case   11:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R3 + 0x00000020) );
		/* 8216F64Ch case   11:*/		return 0x8216F650;
		  /* 8216F650h */ case   12:  		/* lwz R4, <#[R4 + 792]> */
		/* 8216F650h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000318) );
		/* 8216F650h case   12:*/		return 0x8216F654;
		  /* 8216F654h */ case   13:  		/* cmplwi CR6, R4, 0 */
		/* 8216F654h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8216F654h case   13:*/		return 0x8216F658;
		  /* 8216F658h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 8216F658h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8216F660;  }
		/* 8216F658h case   14:*/		return 0x8216F65C;
		  /* 8216F65Ch */ case   15:  		/* li R4, 32 */
		/* 8216F65Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 8216F65Ch case   15:*/		return 0x8216F660;
	}
	return 0x8216F660;
} // Block from 8216F620h-8216F660h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216F660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F660);
		  /* 8216F660h */ case    0:  		/* cmplwi CR6, R4, 64 */
		/* 8216F660h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000040);
		/* 8216F660h case    0:*/		return 0x8216F664;
		  /* 8216F664h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 8216F664h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8216F674;  }
		/* 8216F664h case    1:*/		return 0x8216F668;
		  /* 8216F668h */ case    2:  		/* subfic R5, R4, 64 */
		/* 8216F668h case    2:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R4,0x40);
		/* 8216F668h case    2:*/		return 0x8216F66C;
		  /* 8216F66Ch */ case    3:  		/* mr R3, R31 */
		/* 8216F66Ch case    3:*/		regs.R3 = regs.R31;
		/* 8216F66Ch case    3:*/		return 0x8216F670;
		  /* 8216F670h */ case    4:  		/* bl -408 */
		/* 8216F670h case    4:*/		regs.LR = 0x8216F674; return 0x8216F4D8;
		/* 8216F670h case    4:*/		return 0x8216F674;
	}
	return 0x8216F674;
} // Block from 8216F660h-8216F674h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216F674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F674);
		  /* 8216F674h */ case    0:  		/* std R30, <#[R31 + 40]> */
		/* 8216F674h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x00000028) );
		/* 8216F674h case    0:*/		return 0x8216F678;
		  /* 8216F678h */ case    1:  		/* std R30, <#[R31 + 48]> */
		/* 8216F678h case    1:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x00000030) );
		/* 8216F678h case    1:*/		return 0x8216F67C;
		  /* 8216F67Ch */ case    2:  		/* std R30, <#[R31 + 56]> */
		/* 8216F67Ch case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x00000038) );
		/* 8216F67Ch case    2:*/		return 0x8216F680;
		  /* 8216F680h */ case    3:  		/* std R30, <#[R31 + 64]> */
		/* 8216F680h case    3:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R31 + 0x00000040) );
		/* 8216F680h case    3:*/		return 0x8216F684;
		  /* 8216F684h */ case    4:  		/* stw R30, <#[R31 + 72]> */
		/* 8216F684h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000048) );
		/* 8216F684h case    4:*/		return 0x8216F688;
		  /* 8216F688h */ case    5:  		/* addi R1, R1, 112 */
		/* 8216F688h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216F688h case    5:*/		return 0x8216F68C;
		  /* 8216F68Ch */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216F68Ch case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216F68Ch case    6:*/		return 0x8216F690;
		  /* 8216F690h */ case    7:  		/* mtspr LR, R12 */
		/* 8216F690h case    7:*/		regs.LR = regs.R12;
		/* 8216F690h case    7:*/		return 0x8216F694;
		  /* 8216F694h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 8216F694h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216F694h case    8:*/		return 0x8216F698;
		  /* 8216F698h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 8216F698h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216F698h case    9:*/		return 0x8216F69C;
		  /* 8216F69Ch */ case   10:  		/* bclr 20, CR0_LT */
		/* 8216F69Ch case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F69Ch case   10:*/		return 0x8216F6A0;
	}
	return 0x8216F6A0;
} // Block from 8216F674h-8216F6A0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216F6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F6A0);
		  /* 8216F6A0h */ case    0:  		/* rlwinm R10, R4, 30, 2, 29 */
		/* 8216F6A0h case    0:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R10,regs.R4);
		/* 8216F6A0h case    0:*/		return 0x8216F6A4;
		  /* 8216F6A4h */ case    1:  		/* rlwinm R9, R4, 24, 8, 31 */
		/* 8216F6A4h case    1:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R9,regs.R4);
		/* 8216F6A4h case    1:*/		return 0x8216F6A8;
		  /* 8216F6A8h */ case    2:  		/* addi R8, R10, 3 */
		/* 8216F6A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x3);
		/* 8216F6A8h case    2:*/		return 0x8216F6AC;
		  /* 8216F6ACh */ case    3:  		/* addi R9, R9, 1 */
		/* 8216F6ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216F6ACh case    3:*/		return 0x8216F6B0;
		  /* 8216F6B0h */ case    4:  		/* rldicl R8, R8, 0, 58 */
		/* 8216F6B0h case    4:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R8,regs.R8);
		/* 8216F6B0h case    4:*/		return 0x8216F6B4;
		  /* 8216F6B4h */ case    5:  		/* rlwinm R6, R9, 3, 0, 28 */
		/* 8216F6B4h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R6,regs.R9);
		/* 8216F6B4h case    5:*/		return 0x8216F6B8;
		  /* 8216F6B8h */ case    6:  		/* li R7, 2 */
		/* 8216F6B8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8216F6B8h case    6:*/		return 0x8216F6BC;
		  /* 8216F6BCh */ case    7:  		/* rldicl R10, R10, 0, 58 */
		/* 8216F6BCh case    7:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R10);
		/* 8216F6BCh case    7:*/		return 0x8216F6C0;
		  /* 8216F6C0h */ case    8:  		/* sld R9, R7, R8 */
		/* 8216F6C0h case    8:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R7,regs.R8);
		/* 8216F6C0h case    8:*/		return 0x8216F6C4;
		  /* 8216F6C4h */ case    9:  		/* ldx R8, <#[R6 + R3]> */
		/* 8216F6C4h case    9:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R6 + regs.R3 + 0x00000000) );
		/* 8216F6C4h case    9:*/		return 0x8216F6C8;
		  /* 8216F6C8h */ case   10:  		/* addi R9, R9, -1 */
		/* 8216F6C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8216F6C8h case   10:*/		return 0x8216F6CC;
		  /* 8216F6CCh */ case   11:  		/* li R7, -1 */
		/* 8216F6CCh case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 8216F6CCh case   11:*/		return 0x8216F6D0;
		  /* 8216F6D0h */ case   12:  		/* and R9, R9, R8 */
		/* 8216F6D0h case   12:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216F6D0h case   12:*/		return 0x8216F6D4;
		  /* 8216F6D4h */ case   13:  		/* sld R8, R7, R10 */
		/* 8216F6D4h case   13:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R7,regs.R10);
		/* 8216F6D4h case   13:*/		return 0x8216F6D8;
		  /* 8216F6D8h */ case   14:  		/* and R9, R9, R8 */
		/* 8216F6D8h case   14:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216F6D8h case   14:*/		return 0x8216F6DC;
		  /* 8216F6DCh */ case   15:  		/* mr R11, R4 */
		/* 8216F6DCh case   15:*/		regs.R11 = regs.R4;
		/* 8216F6DCh case   15:*/		return 0x8216F6E0;
		  /* 8216F6E0h */ case   16:  		/* srd R10, R9, R10 */
		/* 8216F6E0h case   16:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8216F6E0h case   16:*/		return 0x8216F6E4;
		  /* 8216F6E4h */ case   17:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 8216F6E4h case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 8216F6E4h case   17:*/		return 0x8216F6E8;
		  /* 8216F6E8h */ case   18:  		/* andc R10, R4, R10 */
		/* 8216F6E8h case   18:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R4,regs.R10);
		/* 8216F6E8h case   18:*/		return 0x8216F6EC;
		  /* 8216F6ECh */ case   19:  		/* rlwinm. R4, R10, 0, 28, 31 */
		/* 8216F6ECh case   19:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R4,regs.R10);
		/* 8216F6ECh case   19:*/		return 0x8216F6F0;
		  /* 8216F6F0h */ case   20:  		/* bclr 12, CR0_EQ */
		/* 8216F6F0h case   20:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8216F6F0h case   20:*/		return 0x8216F6F4;
	}
	return 0x8216F6F4;
} // Block from 8216F6A0h-8216F6F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216F6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F6F4);
		  /* 8216F6F4h */ case    0:  		/* rlwimi R4, R11, 0, 0, 27 */
		/* 8216F6F4h case    0:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R4,regs.R11);
		/* 8216F6F4h case    0:*/		return 0x8216F6F8;
		  /* 8216F6F8h */ case    1:  		/* b -664 */
		/* 8216F6F8h case    1:*/		return 0x8216F460;
		/* 8216F6F8h case    1:*/		return 0x8216F6FC;
		  /* 8216F6FCh */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216F6FCh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F6FCh case    2:*/		return 0x8216F700;
	}
	return 0x8216F700;
} // Block from 8216F6F4h-8216F700h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F700);
		  /* 8216F700h */ case    0:  		/* rlwinm R11, R4, 30, 2, 29 */
		/* 8216F700h case    0:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R11,regs.R4);
		/* 8216F700h case    0:*/		return 0x8216F704;
		  /* 8216F704h */ case    1:  		/* rlwinm R10, R4, 24, 8, 31 */
		/* 8216F704h case    1:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R10,regs.R4);
		/* 8216F704h case    1:*/		return 0x8216F708;
		  /* 8216F708h */ case    2:  		/* addi R9, R11, 3 */
		/* 8216F708h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 8216F708h case    2:*/		return 0x8216F70C;
		  /* 8216F70Ch */ case    3:  		/* addi R10, R10, 1 */
		/* 8216F70Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216F70Ch case    3:*/		return 0x8216F710;
		  /* 8216F710h */ case    4:  		/* rldicl R9, R9, 0, 58 */
		/* 8216F710h case    4:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R9);
		/* 8216F710h case    4:*/		return 0x8216F714;
		  /* 8216F714h */ case    5:  		/* rlwinm R7, R10, 3, 0, 28 */
		/* 8216F714h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R7,regs.R10);
		/* 8216F714h case    5:*/		return 0x8216F718;
		  /* 8216F718h */ case    6:  		/* li R8, 2 */
		/* 8216F718h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8216F718h case    6:*/		return 0x8216F71C;
		  /* 8216F71Ch */ case    7:  		/* rldicl R11, R11, 0, 58 */
		/* 8216F71Ch case    7:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R11,regs.R11);
		/* 8216F71Ch case    7:*/		return 0x8216F720;
		  /* 8216F720h */ case    8:  		/* sld R10, R8, R9 */
		/* 8216F720h case    8:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 8216F720h case    8:*/		return 0x8216F724;
		  /* 8216F724h */ case    9:  		/* ldx R9, <#[R7 + R3]> */
		/* 8216F724h case    9:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R7 + regs.R3 + 0x00000000) );
		/* 8216F724h case    9:*/		return 0x8216F728;
		  /* 8216F728h */ case   10:  		/* addi R10, R10, -1 */
		/* 8216F728h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216F728h case   10:*/		return 0x8216F72C;
		  /* 8216F72Ch */ case   11:  		/* li R8, -1 */
		/* 8216F72Ch case   11:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8216F72Ch case   11:*/		return 0x8216F730;
		  /* 8216F730h */ case   12:  		/* and R10, R10, R9 */
		/* 8216F730h case   12:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216F730h case   12:*/		return 0x8216F734;
		  /* 8216F734h */ case   13:  		/* sld R9, R8, R11 */
		/* 8216F734h case   13:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R8,regs.R11);
		/* 8216F734h case   13:*/		return 0x8216F738;
		  /* 8216F738h */ case   14:  		/* and R10, R10, R9 */
		/* 8216F738h case   14:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216F738h case   14:*/		return 0x8216F73C;
		  /* 8216F73Ch */ case   15:  		/* srd R11, R10, R11 */
		/* 8216F73Ch case   15:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216F73Ch case   15:*/		return 0x8216F740;
		  /* 8216F740h */ case   16:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8216F740h case   16:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8216F740h case   16:*/		return 0x8216F744;
		  /* 8216F744h */ case   17:  		/* and R11, R11, R4 */
		/* 8216F744h case   17:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8216F744h case   17:*/		return 0x8216F748;
		  /* 8216F748h */ case   18:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 8216F748h case   18:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8216F748h case   18:*/		return 0x8216F74C;
		  /* 8216F74Ch */ case   19:  		/* bclr 12, CR0_EQ */
		/* 8216F74Ch case   19:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8216F74Ch case   19:*/		return 0x8216F750;
	}
	return 0x8216F750;
} // Block from 8216F700h-8216F750h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216F750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F750);
		  /* 8216F750h */ case    0:  		/* rlwimi R11, R4, 0, 0, 27 */
		/* 8216F750h case    0:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R4);
		/* 8216F750h case    0:*/		return 0x8216F754;
		  /* 8216F754h */ case    1:  		/* mr R10, R11 */
		/* 8216F754h case    1:*/		regs.R10 = regs.R11;
		/* 8216F754h case    1:*/		return 0x8216F758;
		  /* 8216F758h */ case    2:  		/* rlwinm R11, R11, 24, 8, 31 */
		/* 8216F758h case    2:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R11,regs.R11);
		/* 8216F758h case    2:*/		return 0x8216F75C;
		  /* 8216F75Ch */ case    3:  		/* rlwinm R9, R10, 30, 2, 29 */
		/* 8216F75Ch case    3:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R9,regs.R10);
		/* 8216F75Ch case    3:*/		return 0x8216F760;
		  /* 8216F760h */ case    4:  		/* addi R11, R11, 1 */
		/* 8216F760h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216F760h case    4:*/		return 0x8216F764;
		  /* 8216F764h */ case    5:  		/* rldicl R9, R9, 0, 58 */
		/* 8216F764h case    5:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R9);
		/* 8216F764h case    5:*/		return 0x8216F768;
	}
	return 0x8216F768;
} // Block from 8216F750h-8216F768h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216F768h
// Function '?GetUnit@Instruction@D3DXShader@@QAA?AW4InstructionUnitType@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F768);
		  /* 8216F768h */ case    0:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8216F768h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8216F768h case    0:*/		return 0x8216F76C;
		  /* 8216F76Ch */ case    1:  		/* rldicl R10, R10, 0, 60 */
		/* 8216F76Ch case    1:*/		cpu::op::rldicl<0,0,60>(regs,&regs.R10,regs.R10);
		/* 8216F76Ch case    1:*/		return 0x8216F770;
		  /* 8216F770h */ case    2:  		/* sld R10, R10, R9 */
		/* 8216F770h case    2:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216F770h case    2:*/		return 0x8216F774;
		  /* 8216F774h */ case    3:  		/* ldx R9, <#[R11 + R3]> */
		/* 8216F774h case    3:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216F774h case    3:*/		return 0x8216F778;
		  /* 8216F778h */ case    4:  		/* subf R10, R10, R9 */
		/* 8216F778h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216F778h case    4:*/		return 0x8216F77C;
		  /* 8216F77Ch */ case    5:  		/* stdx R10, <#[R11 + R3]> */
		/* 8216F77Ch case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216F77Ch case    5:*/		return 0x8216F780;
		  /* 8216F780h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8216F780h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216F780h case    6:*/		return 0x8216F784;
	}
	return 0x8216F784;
} // Block from 8216F768h-8216F784h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216F784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F784);
		  /* 8216F784h */ case    0:  		/* nop */
		/* 8216F784h case    0:*/		cpu::op::nop();
		/* 8216F784h case    0:*/		return 0x8216F788;
	}
	return 0x8216F788;
} // Block from 8216F784h-8216F788h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F788);
		  /* 8216F788h */ case    0:  		/* mfspr R12, LR */
		/* 8216F788h case    0:*/		regs.R12 = regs.LR;
		/* 8216F788h case    0:*/		return 0x8216F78C;
		  /* 8216F78Ch */ case    1:  		/* bl -910640 */
		/* 8216F78Ch case    1:*/		regs.LR = 0x8216F790; return 0x8209125C;
		/* 8216F78Ch case    1:*/		return 0x8216F790;
		  /* 8216F790h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8216F790h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8216F790h case    2:*/		return 0x8216F794;
		  /* 8216F794h */ case    3:  		/* mr R29, R3 */
		/* 8216F794h case    3:*/		regs.R29 = regs.R3;
		/* 8216F794h case    3:*/		return 0x8216F798;
		  /* 8216F798h */ case    4:  		/* mr R30, R4 */
		/* 8216F798h case    4:*/		regs.R30 = regs.R4;
		/* 8216F798h case    4:*/		return 0x8216F79C;
		  /* 8216F79Ch */ case    5:  		/* bl -1604 */
		/* 8216F79Ch case    5:*/		regs.LR = 0x8216F7A0; return 0x8216F158;
		/* 8216F79Ch case    5:*/		return 0x8216F7A0;
		  /* 8216F7A0h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F7A0h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F7A0h case    6:*/		return 0x8216F7A4;
		  /* 8216F7A4h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 8216F7A4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216F7B4;  }
		/* 8216F7A4h case    7:*/		return 0x8216F7A8;
		  /* 8216F7A8h */ case    8:  		/* li R4, 4800 */
		/* 8216F7A8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8216F7A8h case    8:*/		return 0x8216F7AC;
		  /* 8216F7ACh */ case    9:  		/* lwz R3, <#[R29 + 44]> */
		/* 8216F7ACh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 8216F7ACh case    9:*/		return 0x8216F7B0;
		  /* 8216F7B0h */ case   10:  		/* bl -121160 */
		/* 8216F7B0h case   10:*/		regs.LR = 0x8216F7B4; return 0x82151E68;
		/* 8216F7B0h case   10:*/		return 0x8216F7B4;
	}
	return 0x8216F7B4;
} // Block from 8216F788h-8216F7B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216F7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F7B4);
		  /* 8216F7B4h */ case    0:  		/* mr R4, R30 */
		/* 8216F7B4h case    0:*/		regs.R4 = regs.R30;
		/* 8216F7B4h case    0:*/		return 0x8216F7B8;
		  /* 8216F7B8h */ case    1:  		/* mr R3, R29 */
		/* 8216F7B8h case    1:*/		regs.R3 = regs.R29;
		/* 8216F7B8h case    1:*/		return 0x8216F7BC;
		  /* 8216F7BCh */ case    2:  		/* bl -996 */
		/* 8216F7BCh case    2:*/		regs.LR = 0x8216F7C0; return 0x8216F3D8;
		/* 8216F7BCh case    2:*/		return 0x8216F7C0;
		  /* 8216F7C0h */ case    3:  		/* lwz R11, <#[R29 + 52]> */
		/* 8216F7C0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000034) );
		/* 8216F7C0h case    3:*/		return 0x8216F7C4;
		  /* 8216F7C4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8216F7C4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216F7C4h case    4:*/		return 0x8216F7C8;
		  /* 8216F7C8h */ case    5:  		/* bc 12, CR6_EQ, 164 */
		/* 8216F7C8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216F86C;  }
		/* 8216F7C8h case    5:*/		return 0x8216F7CC;
		  /* 8216F7CCh */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 8216F7CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8216F7CCh case    6:*/		return 0x8216F7D0;
		  /* 8216F7D0h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216F7D0h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216F7D0h case    7:*/		return 0x8216F7D4;
		  /* 8216F7D4h */ case    8:  		/* cmplwi CR6, R11, 15360 */
		/* 8216F7D4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 8216F7D4h case    8:*/		return 0x8216F7D8;
		  /* 8216F7D8h */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 8216F7D8h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216F820;  }
		/* 8216F7D8h case    9:*/		return 0x8216F7DC;
		  /* 8216F7DCh */ case   10:  		/* lwz R31, <#[R30 + 4]> */
		/* 8216F7DCh case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8216F7DCh case   10:*/		return 0x8216F7E0;
		  /* 8216F7E0h */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 8216F7E0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216F7E0h case   11:*/		return 0x8216F7E4;
		  /* 8216F7E4h */ case   12:  		/* bc 12, CR6_EQ, 60 */
		/* 8216F7E4h case   12:*/		if ( regs.CR[6].eq ) { return 0x8216F820;  }
		/* 8216F7E4h case   12:*/		return 0x8216F7E8;
		  /* 8216F7E8h */ case   13:  		/* lwz R11, <#[R31 + 16]> */
		/* 8216F7E8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8216F7E8h case   13:*/		return 0x8216F7EC;
		  /* 8216F7ECh */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 8216F7ECh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216F7ECh case   14:*/		return 0x8216F7F0;
		  /* 8216F7F0h */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 8216F7F0h case   15:*/		if ( regs.CR[6].eq ) { return 0x8216F818;  }
		/* 8216F7F0h case   15:*/		return 0x8216F7F4;
		  /* 8216F7F4h */ case   16:  		/* mr R3, R31 */
		/* 8216F7F4h case   16:*/		regs.R3 = regs.R31;
		/* 8216F7F4h case   16:*/		return 0x8216F7F8;
		  /* 8216F7F8h */ case   17:  		/* bl -45000 */
		/* 8216F7F8h case   17:*/		regs.LR = 0x8216F7FC; return 0x82164830;
		/* 8216F7F8h case   17:*/		return 0x8216F7FC;
		  /* 8216F7FCh */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F7FCh case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F7FCh case   18:*/		return 0x8216F800;
		  /* 8216F800h */ case   19:  		/* bc 12, CR0_EQ, 24 */
		/* 8216F800h case   19:*/		if ( regs.CR[0].eq ) { return 0x8216F818;  }
		/* 8216F800h case   19:*/		return 0x8216F804;
		  /* 8216F804h */ case   20:  		/* mr R3, R31 */
		/* 8216F804h case   20:*/		regs.R3 = regs.R31;
		/* 8216F804h case   20:*/		return 0x8216F808;
	}
	return 0x8216F808;
} // Block from 8216F7B4h-8216F808h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216F808h
// Function '?GetSwizzledRegister@Dependency@D3DXShader@@QAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F808);
		  /* 8216F808h */ case    0:  		/* bl -2672 */
		/* 8216F808h case    0:*/		regs.LR = 0x8216F80C; return 0x8216ED98;
		/* 8216F808h case    0:*/		return 0x8216F80C;
		  /* 8216F80Ch */ case    1:  		/* mr R4, R3 */
		/* 8216F80Ch case    1:*/		regs.R4 = regs.R3;
		/* 8216F80Ch case    1:*/		return 0x8216F810;
		  /* 8216F810h */ case    2:  		/* lwz R3, <#[R29 + 52]> */
		/* 8216F810h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 8216F810h case    2:*/		return 0x8216F814;
		  /* 8216F814h */ case    3:  		/* bl -276 */
		/* 8216F814h case    3:*/		regs.LR = 0x8216F818; return 0x8216F700;
		/* 8216F814h case    3:*/		return 0x8216F818;
	}
	return 0x8216F818;
} // Block from 8216F808h-8216F818h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216F818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F818);
		  /* 8216F818h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8216F818h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8216F818h case    0:*/		return 0x8216F81C;
		  /* 8216F81Ch */ case    1:  		/* b -60 */
		/* 8216F81Ch case    1:*/		return 0x8216F7E0;
		/* 8216F81Ch case    1:*/		return 0x8216F820;
	}
	return 0x8216F820;
} // Block from 8216F818h-8216F820h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F820);
		  /* 8216F820h */ case    0:  		/* lwz R31, <#[R30]> */
		/* 8216F820h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8216F820h case    0:*/		return 0x8216F824;
		  /* 8216F824h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8216F824h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216F824h case    1:*/		return 0x8216F828;
		  /* 8216F828h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 8216F828h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216F86C;  }
		/* 8216F828h case    2:*/		return 0x8216F82C;
		  /* 8216F82Ch */ case    3:  		/* mr R3, R31 */
		/* 8216F82Ch case    3:*/		regs.R3 = regs.R31;
		/* 8216F82Ch case    3:*/		return 0x8216F830;
		  /* 8216F830h */ case    4:  		/* bl -45056 */
		/* 8216F830h case    4:*/		regs.LR = 0x8216F834; return 0x82164830;
		/* 8216F830h case    4:*/		return 0x8216F834;
		  /* 8216F834h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216F834h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216F834h case    5:*/		return 0x8216F838;
		  /* 8216F838h */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 8216F838h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216F864;  }
		/* 8216F838h case    6:*/		return 0x8216F83C;
		  /* 8216F83Ch */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 8216F83Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216F83Ch case    7:*/		return 0x8216F840;
		  /* 8216F840h */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216F840h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216F840h case    8:*/		return 0x8216F844;
		  /* 8216F844h */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216F844h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216F844h case    9:*/		return 0x8216F848;
		  /* 8216F848h */ case   10:  		/* cmplwi CR6, R11, 15360 */
		/* 8216F848h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 8216F848h case   10:*/		return 0x8216F84C;
		  /* 8216F84Ch */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 8216F84Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8216F864;  }
		/* 8216F84Ch case   11:*/		return 0x8216F850;
		  /* 8216F850h */ case   12:  		/* mr R3, R31 */
		/* 8216F850h case   12:*/		regs.R3 = regs.R31;
		/* 8216F850h case   12:*/		return 0x8216F854;
		  /* 8216F854h */ case   13:  		/* bl -2748 */
		/* 8216F854h case   13:*/		regs.LR = 0x8216F858; return 0x8216ED98;
		/* 8216F854h case   13:*/		return 0x8216F858;
	}
	return 0x8216F858;
} // Block from 8216F820h-8216F858h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216F858h
// Function '?CanYield@MachineState@D3DXShader@@QAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F858);
		  /* 8216F858h */ case    0:  		/* mr R4, R3 */
		/* 8216F858h case    0:*/		regs.R4 = regs.R3;
		/* 8216F858h case    0:*/		return 0x8216F85C;
		  /* 8216F85Ch */ case    1:  		/* lwz R3, <#[R29 + 52]> */
		/* 8216F85Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 8216F85Ch case    1:*/		return 0x8216F860;
		  /* 8216F860h */ case    2:  		/* bl -448 */
		/* 8216F860h case    2:*/		regs.LR = 0x8216F864; return 0x8216F6A0;
		/* 8216F860h case    2:*/		return 0x8216F864;
	}
	return 0x8216F864;
} // Block from 8216F858h-8216F864h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F864);
		  /* 8216F864h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 8216F864h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8216F864h case    0:*/		return 0x8216F868;
		  /* 8216F868h */ case    1:  		/* b -68 */
		/* 8216F868h case    1:*/		return 0x8216F824;
		/* 8216F868h case    1:*/		return 0x8216F86C;
	}
	return 0x8216F86C;
} // Block from 8216F864h-8216F86Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F86Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F86C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F86C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F86C);
		  /* 8216F86Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8216F86Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8216F86Ch case    0:*/		return 0x8216F870;
		  /* 8216F870h */ case    1:  		/* b -910788 */
		/* 8216F870h case    1:*/		return 0x820912AC;
		/* 8216F870h case    1:*/		return 0x8216F874;
		  /* 8216F874h */ case    2:  		/* nop */
		/* 8216F874h case    2:*/		cpu::op::nop();
		/* 8216F874h case    2:*/		return 0x8216F878;
	}
	return 0x8216F878;
} // Block from 8216F86Ch-8216F878h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F878);
		  /* 8216F878h */ case    0:  		/* mfspr R12, LR */
		/* 8216F878h case    0:*/		regs.R12 = regs.LR;
		/* 8216F878h case    0:*/		return 0x8216F87C;
		  /* 8216F87Ch */ case    1:  		/* bl -910892 */
		/* 8216F87Ch case    1:*/		regs.LR = 0x8216F880; return 0x82091250;
		/* 8216F87Ch case    1:*/		return 0x8216F880;
		  /* 8216F880h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216F880h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216F880h case    2:*/		return 0x8216F884;
		  /* 8216F884h */ case    3:  		/* mr R31, R3 */
		/* 8216F884h case    3:*/		regs.R31 = regs.R3;
		/* 8216F884h case    3:*/		return 0x8216F888;
		  /* 8216F888h */ case    4:  		/* lwz R3, <#[R4 + 88]> */
		/* 8216F888h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000058) );
		/* 8216F888h case    4:*/		return 0x8216F88C;
		  /* 8216F88Ch */ case    5:  		/* mr R27, R4 */
		/* 8216F88Ch case    5:*/		regs.R27 = regs.R4;
		/* 8216F88Ch case    5:*/		return 0x8216F890;
		  /* 8216F890h */ case    6:  		/* mr R26, R5 */
		/* 8216F890h case    6:*/		regs.R26 = regs.R5;
		/* 8216F890h case    6:*/		return 0x8216F894;
		  /* 8216F894h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 8216F894h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8216F894h case    7:*/		return 0x8216F898;
		  /* 8216F898h */ case    8:  		/* bc 12, CR6_EQ, 256 */
		/* 8216F898h case    8:*/		if ( regs.CR[6].eq ) { return 0x8216F998;  }
		/* 8216F898h case    8:*/		return 0x8216F89C;
		  /* 8216F89Ch */ case    9:  		/* li R4, 0 */
		/* 8216F89Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216F89Ch case    9:*/		return 0x8216F8A0;
		  /* 8216F8A0h */ case   10:  		/* lwz R5, <#[R31 + 672]> */
		/* 8216F8A0h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 8216F8A0h case   10:*/		return 0x8216F8A4;
		  /* 8216F8A4h */ case   11:  		/* bl -2380 */
		/* 8216F8A4h case   11:*/		regs.LR = 0x8216F8A8; return 0x8216EF58;
		/* 8216F8A4h case   11:*/		return 0x8216F8A8;
		  /* 8216F8A8h */ case   12:  		/* lwz R11, <#[R31 + 668]> */
		/* 8216F8A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 8216F8A8h case   12:*/		return 0x8216F8AC;
		  /* 8216F8ACh */ case   13:  		/* mr R29, R3 */
		/* 8216F8ACh case   13:*/		regs.R29 = regs.R3;
		/* 8216F8ACh case   13:*/		return 0x8216F8B0;
		  /* 8216F8B0h */ case   14:  		/* addi R11, R11, -1 */
		/* 8216F8B0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8216F8B0h case   14:*/		return 0x8216F8B4;
		  /* 8216F8B4h */ case   15:  		/* cmplw CR6, R3, R11 */
		/* 8216F8B4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8216F8B4h case   15:*/		return 0x8216F8B8;
		  /* 8216F8B8h */ case   16:  		/* bc 12, CR6_GT, 224 */
		/* 8216F8B8h case   16:*/		if ( regs.CR[6].gt ) { return 0x8216F998;  }
		/* 8216F8B8h case   16:*/		return 0x8216F8BC;
		  /* 8216F8BCh */ case   17:  		/* lwz R28, <#[R1 + 80]> */
		/* 8216F8BCh case   17:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 8216F8BCh case   17:*/		return 0x8216F8C0;
		  /* 8216F8C0h */ case   18:  		/* lwz R11, <#[R31 + 708]> */
		/* 8216F8C0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002C4) );
		/* 8216F8C0h case   18:*/		return 0x8216F8C4;
		  /* 8216F8C4h */ case   19:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 8216F8C4h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 8216F8C4h case   19:*/		return 0x8216F8C8;
		  /* 8216F8C8h */ case   20:  		/* lwzx R5, <#[R10 + R11]> */
		/* 8216F8C8h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8216F8C8h case   20:*/		return 0x8216F8CC;
		  /* 8216F8CCh */ case   21:  		/* lwz R11, <#[R5 + 8]> */
		/* 8216F8CCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8216F8CCh case   21:*/		return 0x8216F8D0;
		  /* 8216F8D0h */ case   22:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216F8D0h case   22:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216F8D0h case   22:*/		return 0x8216F8D4;
		  /* 8216F8D4h */ case   23:  		/* cmplwi CR6, R11, 14720 */
		/* 8216F8D4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003980);
		/* 8216F8D4h case   23:*/		return 0x8216F8D8;
		  /* 8216F8D8h */ case   24:  		/* bc 12, CR6_EQ, 140 */
		/* 8216F8D8h case   24:*/		if ( regs.CR[6].eq ) { return 0x8216F964;  }
		/* 8216F8D8h case   24:*/		return 0x8216F8DC;
		  /* 8216F8DCh */ case   25:  		/* lwz R11, <#[R5 + 4]> */
		/* 8216F8DCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 8216F8DCh case   25:*/		return 0x8216F8E0;
		  /* 8216F8E0h */ case   26:  		/* mr R10, R11 */
		/* 8216F8E0h case   26:*/		regs.R10 = regs.R11;
		/* 8216F8E0h case   26:*/		return 0x8216F8E4;
		  /* 8216F8E4h */ case   27:  		/* cmplwi CR6, R10, 0 */
		/* 8216F8E4h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216F8E4h case   27:*/		return 0x8216F8E8;
		  /* 8216F8E8h */ case   28:  		/* bc 12, CR6_EQ, 36 */
		/* 8216F8E8h case   28:*/		if ( regs.CR[6].eq ) { return 0x8216F90C;  }
		/* 8216F8E8h case   28:*/		return 0x8216F8EC;
		  /* 8216F8ECh */ case   29:  		/* lwz R9, <#[R10]> */
		/* 8216F8ECh case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216F8ECh case   29:*/		return 0x8216F8F0;
		  /* 8216F8F0h */ case   30:  		/* rlwinm. R8, R9, 0, 4, 6 */
		/* 8216F8F0h case   30:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R9);
		/* 8216F8F0h case   30:*/		return 0x8216F8F4;
		  /* 8216F8F4h */ case   31:  		/* bc 4, CR0_EQ, 12 */
		/* 8216F8F4h case   31:*/		if ( !regs.CR[0].eq ) { return 0x8216F900;  }
		/* 8216F8F4h case   31:*/		return 0x8216F8F8;
		  /* 8216F8F8h */ case   32:  		/* lwz R10, <#[R10 + 8]> */
		/* 8216F8F8h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8216F8F8h case   32:*/		return 0x8216F8FC;
		  /* 8216F8FCh */ case   33:  		/* b -24 */
		/* 8216F8FCh case   33:*/		return 0x8216F8E4;
		/* 8216F8FCh case   33:*/		return 0x8216F900;
	}
	return 0x8216F900;
} // Block from 8216F878h-8216F900h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8216F900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F900);
		  /* 8216F900h */ case    0:  		/* rlwinm. R10, R9, 2, 31, 31 */
		/* 8216F900h case    0:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R9);
		/* 8216F900h case    0:*/		return 0x8216F904;
		  /* 8216F904h */ case    1:  		/* li R10, 1 */
		/* 8216F904h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216F904h case    1:*/		return 0x8216F908;
		  /* 8216F908h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8216F908h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216F910;  }
		/* 8216F908h case    2:*/		return 0x8216F90C;
	}
	return 0x8216F90C;
} // Block from 8216F900h-8216F90Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F90C);
		  /* 8216F90Ch */ case    0:  		/* li R10, 0 */
		/* 8216F90Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216F90Ch case    0:*/		return 0x8216F910;
	}
	return 0x8216F910;
} // Block from 8216F90Ch-8216F910h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216F910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F910);
		  /* 8216F910h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8216F910h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8216F910h case    0:*/		return 0x8216F914;
		  /* 8216F914h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 8216F914h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216F964;  }
		/* 8216F914h case    1:*/		return 0x8216F918;
		  /* 8216F918h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8216F918h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216F918h case    2:*/		return 0x8216F91C;
		  /* 8216F91Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8216F91Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8216F934;  }
		/* 8216F91Ch case    3:*/		return 0x8216F920;
		  /* 8216F920h */ case    4:  		/* lwz R10, <#[R11]> */
		/* 8216F920h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216F920h case    4:*/		return 0x8216F924;
		  /* 8216F924h */ case    5:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 8216F924h case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 8216F924h case    5:*/		return 0x8216F928;
		  /* 8216F928h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 8216F928h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216F934;  }
		/* 8216F928h case    6:*/		return 0x8216F92C;
		  /* 8216F92Ch */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216F92Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216F92Ch case    7:*/		return 0x8216F930;
		  /* 8216F930h */ case    8:  		/* b -24 */
		/* 8216F930h case    8:*/		return 0x8216F918;
		/* 8216F930h case    8:*/		return 0x8216F934;
	}
	return 0x8216F934;
} // Block from 8216F910h-8216F934h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216F934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F934);
		  /* 8216F934h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8216F934h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216F934h case    0:*/		return 0x8216F938;
		  /* 8216F938h */ case    1:  		/* mr R4, R27 */
		/* 8216F938h case    1:*/		regs.R4 = regs.R27;
		/* 8216F938h case    1:*/		return 0x8216F93C;
		  /* 8216F93Ch */ case    2:  		/* mr R3, R31 */
		/* 8216F93Ch case    2:*/		regs.R3 = regs.R31;
		/* 8216F93Ch case    2:*/		return 0x8216F940;
		  /* 8216F940h */ case    3:  		/* rlwimi R28, R11, 19, 20, 27 */
		/* 8216F940h case    3:*/		cpu::op::rlwimi<0,19,20,27>(regs,&regs.R28,regs.R11);
		/* 8216F940h case    3:*/		return 0x8216F944;
		  /* 8216F944h */ case    4:  		/* rlwinm R30, R28, 0, 20, 31 */
		/* 8216F944h case    4:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R30,regs.R28);
		/* 8216F944h case    4:*/		return 0x8216F948;
		  /* 8216F948h */ case    5:  		/* bl 6176 */
		/* 8216F948h case    5:*/		regs.LR = 0x8216F94C; return 0x82171168;
		/* 8216F948h case    5:*/		return 0x8216F94C;
		  /* 8216F94Ch */ case    6:  		/* mr R11, R3 */
		/* 8216F94Ch case    6:*/		regs.R11 = regs.R3;
		/* 8216F94Ch case    6:*/		return 0x8216F950;
		  /* 8216F950h */ case    7:  		/* mr R3, R26 */
		/* 8216F950h case    7:*/		regs.R3 = regs.R26;
		/* 8216F950h case    7:*/		return 0x8216F954;
		  /* 8216F954h */ case    8:  		/* rlwimi R11, R30, 0, 0, 27 */
		/* 8216F954h case    8:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R30);
		/* 8216F954h case    8:*/		return 0x8216F958;
		  /* 8216F958h */ case    9:  		/* mr R4, R11 */
		/* 8216F958h case    9:*/		regs.R4 = regs.R11;
		/* 8216F958h case    9:*/		return 0x8216F95C;
		  /* 8216F95Ch */ case   10:  		/* mr R28, R11 */
		/* 8216F95Ch case   10:*/		regs.R28 = regs.R11;
		/* 8216F95Ch case   10:*/		return 0x8216F960;
		  /* 8216F960h */ case   11:  		/* bl -704 */
		/* 8216F960h case   11:*/		regs.LR = 0x8216F964; return 0x8216F6A0;
		/* 8216F960h case   11:*/		return 0x8216F964;
	}
	return 0x8216F964;
} // Block from 8216F934h-8216F964h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216F964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F964);
		  /* 8216F964h */ case    0:  		/* lwz R11, <#[R31 + 668]> */
		/* 8216F964h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 8216F964h case    0:*/		return 0x8216F968;
		  /* 8216F968h */ case    1:  		/* addi R30, R11, -1 */
		/* 8216F968h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 8216F968h case    1:*/		return 0x8216F96C;
		  /* 8216F96Ch */ case    2:  		/* cmplw CR6, R29, R30 */
		/* 8216F96Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 8216F96Ch case    2:*/		return 0x8216F970;
	}
	return 0x8216F970;
} // Block from 8216F964h-8216F970h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F970h
// Function '?UpdateCurrentUnit@MachineState@D3DXShader@@QAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F970);
		  /* 8216F970h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 8216F970h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8216F97C;  }
		/* 8216F970h case    0:*/		return 0x8216F974;
		  /* 8216F974h */ case    1:  		/* li R29, -1 */
		/* 8216F974h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 8216F974h case    1:*/		return 0x8216F978;
		  /* 8216F978h */ case    2:  		/* b 24 */
		/* 8216F978h case    2:*/		return 0x8216F990;
		/* 8216F978h case    2:*/		return 0x8216F97C;
	}
	return 0x8216F97C;
} // Block from 8216F970h-8216F97Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216F97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F97C);
		  /* 8216F97Ch */ case    0:  		/* addi R4, R29, 1 */
		/* 8216F97Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x1);
		/* 8216F97Ch case    0:*/		return 0x8216F980;
		  /* 8216F980h */ case    1:  		/* lwz R5, <#[R31 + 672]> */
		/* 8216F980h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 8216F980h case    1:*/		return 0x8216F984;
		  /* 8216F984h */ case    2:  		/* lwz R3, <#[R27 + 88]> */
		/* 8216F984h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000058) );
		/* 8216F984h case    2:*/		return 0x8216F988;
		  /* 8216F988h */ case    3:  		/* bl -2608 */
		/* 8216F988h case    3:*/		regs.LR = 0x8216F98C; return 0x8216EF58;
		/* 8216F988h case    3:*/		return 0x8216F98C;
		  /* 8216F98Ch */ case    4:  		/* mr R29, R3 */
		/* 8216F98Ch case    4:*/		regs.R29 = regs.R3;
		/* 8216F98Ch case    4:*/		return 0x8216F990;
	}
	return 0x8216F990;
} // Block from 8216F97Ch-8216F990h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216F990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F990);
		  /* 8216F990h */ case    0:  		/* cmplw CR6, R29, R30 */
		/* 8216F990h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 8216F990h case    0:*/		return 0x8216F994;
		  /* 8216F994h */ case    1:  		/* bc 4, CR6_GT, -212 */
		/* 8216F994h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216F8C0;  }
		/* 8216F994h case    1:*/		return 0x8216F998;
	}
	return 0x8216F998;
} // Block from 8216F990h-8216F998h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F998);
		  /* 8216F998h */ case    0:  		/* addi R1, R1, 144 */
		/* 8216F998h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216F998h case    0:*/		return 0x8216F99C;
		  /* 8216F99Ch */ case    1:  		/* b -911100 */
		/* 8216F99Ch case    1:*/		return 0x820912A0;
		/* 8216F99Ch case    1:*/		return 0x8216F9A0;
	}
	return 0x8216F9A0;
} // Block from 8216F998h-8216F9A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216F9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F9A0);
		  /* 8216F9A0h */ case    0:  		/* mfspr R12, LR */
		/* 8216F9A0h case    0:*/		regs.R12 = regs.LR;
		/* 8216F9A0h case    0:*/		return 0x8216F9A4;
		  /* 8216F9A4h */ case    1:  		/* bl -911236 */
		/* 8216F9A4h case    1:*/		regs.LR = 0x8216F9A8; return 0x82091220;
		/* 8216F9A4h case    1:*/		return 0x8216F9A8;
		  /* 8216F9A8h */ case    2:  		/* stwu R1, <#[R1 - 368]> */
		/* 8216F9A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE90);
		/* 8216F9A8h case    2:*/		return 0x8216F9AC;
		  /* 8216F9ACh */ case    3:  		/* addic R11, R6, -1 */
		/* 8216F9ACh case    3:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R6,0xFFFFFFFF);
		/* 8216F9ACh case    3:*/		return 0x8216F9B0;
		  /* 8216F9B0h */ case    4:  		/* stb R5, <#[R1 + 407]> */
		/* 8216F9B0h case    4:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R1 + 0x00000197) );
		/* 8216F9B0h case    4:*/		return 0x8216F9B4;
		  /* 8216F9B4h */ case    5:  		/* li R20, 0 */
		/* 8216F9B4h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8216F9B4h case    5:*/		return 0x8216F9B8;
		  /* 8216F9B8h */ case    6:  		/* addi R14, R4, 24 */
		/* 8216F9B8h case    6:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R4,0x18);
		/* 8216F9B8h case    6:*/		return 0x8216F9BC;
		  /* 8216F9BCh */ case    7:  		/* subfe R11, R11, R6 */
		/* 8216F9BCh case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8216F9BCh case    7:*/		return 0x8216F9C0;
		  /* 8216F9C0h */ case    8:  		/* mr R21, R3 */
		/* 8216F9C0h case    8:*/		regs.R21 = regs.R3;
		/* 8216F9C0h case    8:*/		return 0x8216F9C4;
		  /* 8216F9C4h */ case    9:  		/* mr R17, R4 */
		/* 8216F9C4h case    9:*/		regs.R17 = regs.R4;
		/* 8216F9C4h case    9:*/		return 0x8216F9C8;
	}
	return 0x8216F9C8;
} // Block from 8216F9A0h-8216F9C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216F9C8h
// Function '??$FindSetBitInArray@_K@D3DXShader@@YAIPA_KIK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F9C8);
		  /* 8216F9C8h */ case    0:  		/* stb R11, <#[R1 + 80]> */
		/* 8216F9C8h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8216F9C8h case    0:*/		return 0x8216F9CC;
		  /* 8216F9CCh */ case    1:  		/* mr R22, R6 */
		/* 8216F9CCh case    1:*/		regs.R22 = regs.R6;
		/* 8216F9CCh case    1:*/		return 0x8216F9D0;
		  /* 8216F9D0h */ case    2:  		/* mr R16, R20 */
		/* 8216F9D0h case    2:*/		regs.R16 = regs.R20;
		/* 8216F9D0h case    2:*/		return 0x8216F9D4;
		  /* 8216F9D4h */ case    3:  		/* mr R15, R20 */
		/* 8216F9D4h case    3:*/		regs.R15 = regs.R20;
		/* 8216F9D4h case    3:*/		return 0x8216F9D8;
		  /* 8216F9D8h */ case    4:  		/* addi R18, R14, 4 */
		/* 8216F9D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R14,0x4);
		/* 8216F9D8h case    4:*/		return 0x8216F9DC;
		  /* 8216F9DCh */ case    5:  		/* lwz R4, <#[R21 + 732]> */
		/* 8216F9DCh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x000002DC) );
		/* 8216F9DCh case    5:*/		return 0x8216F9E0;
		  /* 8216F9E0h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 8216F9E0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8216F9E0h case    6:*/		return 0x8216F9E4;
		  /* 8216F9E4h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 8216F9E4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216F9FC;  }
		/* 8216F9E4h case    7:*/		return 0x8216F9E8;
		  /* 8216F9E8h */ case    8:  		/* li R6, 0 */
		/* 8216F9E8h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216F9E8h case    8:*/		return 0x8216F9EC;
		  /* 8216F9ECh */ case    9:  		/* mulli R5, R16, 12 */
		/* 8216F9ECh case    9:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R16,0xC);
		/* 8216F9ECh case    9:*/		return 0x8216F9F0;
		  /* 8216F9F0h */ case   10:  		/* mr R3, R21 */
		/* 8216F9F0h case   10:*/		regs.R3 = regs.R21;
		/* 8216F9F0h case   10:*/		return 0x8216F9F4;
		  /* 8216F9F4h */ case   11:  		/* bl -11172 */
		/* 8216F9F4h case   11:*/		regs.LR = 0x8216F9F8; return 0x8216CE50;
		/* 8216F9F4h case   11:*/		return 0x8216F9F8;
		  /* 8216F9F8h */ case   12:  		/* stw R20, <#[R21 + 732]> */
		/* 8216F9F8h case   12:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R21 + 0x000002DC) );
		/* 8216F9F8h case   12:*/		return 0x8216F9FC;
	}
	return 0x8216F9FC;
} // Block from 8216F9C8h-8216F9FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216F9FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216F9FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216F9FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216F9FC);
		  /* 8216F9FCh */ case    0:  		/* mr R4, R17 */
		/* 8216F9FCh case    0:*/		regs.R4 = regs.R17;
		/* 8216F9FCh case    0:*/		return 0x8216FA00;
		  /* 8216FA00h */ case    1:  		/* lbz R5, <#[R1 + 80]> */
		/* 8216FA00h case    1:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8216FA00h case    1:*/		return 0x8216FA04;
		  /* 8216FA04h */ case    2:  		/* mr R3, R21 */
		/* 8216FA04h case    2:*/		regs.R3 = regs.R21;
		/* 8216FA04h case    2:*/		return 0x8216FA08;
		  /* 8216FA08h */ case    3:  		/* bl 8800 */
		/* 8216FA08h case    3:*/		regs.LR = 0x8216FA0C; return 0x82171C68;
		/* 8216FA08h case    3:*/		return 0x8216FA0C;
		  /* 8216FA0Ch */ case    4:  		/* lwz R11, <#[R18]> */
		/* 8216FA0Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8216FA0Ch case    4:*/		return 0x8216FA10;
		  /* 8216FA10h */ case    5:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216FA10h case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216FA10h case    5:*/		return 0x8216FA14;
		  /* 8216FA14h */ case    6:  		/* addic R10, R10, -1 */
		/* 8216FA14h case    6:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216FA14h case    6:*/		return 0x8216FA18;
		  /* 8216FA18h */ case    7:  		/* subfe R10, R10, R10 */
		/* 8216FA18h case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216FA18h case    7:*/		return 0x8216FA1C;
		  /* 8216FA1Ch */ case    8:  		/* and R19, R10, R11 */
		/* 8216FA1Ch case    8:*/		cpu::op::and<0>(regs,&regs.R19,regs.R10,regs.R11);
		/* 8216FA1Ch case    8:*/		return 0x8216FA20;
		  /* 8216FA20h */ case    9:  		/* cmplwi CR6, R19, 0 */
		/* 8216FA20h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 8216FA20h case    9:*/		return 0x8216FA24;
		  /* 8216FA24h */ case   10:  		/* bc 12, CR6_EQ, 2688 */
		/* 8216FA24h case   10:*/		if ( regs.CR[6].eq ) { return 0x821704A4;  }
		/* 8216FA24h case   10:*/		return 0x8216FA28;
		  /* 8216FA28h */ case   11:  		/* mr R4, R19 */
		/* 8216FA28h case   11:*/		regs.R4 = regs.R19;
		/* 8216FA28h case   11:*/		return 0x8216FA2C;
		  /* 8216FA2Ch */ case   12:  		/* mr R3, R21 */
		/* 8216FA2Ch case   12:*/		regs.R3 = regs.R21;
		/* 8216FA2Ch case   12:*/		return 0x8216FA30;
		  /* 8216FA30h */ case   13:  		/* bl -1264 */
		/* 8216FA30h case   13:*/		regs.LR = 0x8216FA34; return 0x8216F540;
		/* 8216FA30h case   13:*/		return 0x8216FA34;
		  /* 8216FA34h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FA34h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FA34h case   14:*/		return 0x8216FA38;
		  /* 8216FA38h */ case   15:  		/* bc 12, CR0_EQ, 2152 */
		/* 8216FA38h case   15:*/		if ( regs.CR[0].eq ) { return 0x821702A0;  }
		/* 8216FA38h case   15:*/		return 0x8216FA3C;
		  /* 8216FA3Ch */ case   16:  		/* lwz R11, <#[R21 + 732]> */
		/* 8216FA3Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x000002DC) );
		/* 8216FA3Ch case   16:*/		return 0x8216FA40;
		  /* 8216FA40h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 8216FA40h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216FA40h case   17:*/		return 0x8216FA44;
		  /* 8216FA44h */ case   18:  		/* bc 4, CR6_EQ, 816 */
		/* 8216FA44h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8216FD74;  }
		/* 8216FA44h case   18:*/		return 0x8216FA48;
		  /* 8216FA48h */ case   19:  		/* lwz R11, <#[R18]> */
		/* 8216FA48h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8216FA48h case   19:*/		return 0x8216FA4C;
		  /* 8216FA4Ch */ case   20:  		/* li R5, 0 */
		/* 8216FA4Ch case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216FA4Ch case   20:*/		return 0x8216FA50;
		  /* 8216FA50h */ case   21:  		/* mr R3, R21 */
		/* 8216FA50h case   21:*/		regs.R3 = regs.R21;
		/* 8216FA50h case   21:*/		return 0x8216FA54;
		  /* 8216FA54h */ case   22:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216FA54h case   22:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216FA54h case   22:*/		return 0x8216FA58;
		  /* 8216FA58h */ case   23:  		/* addic R10, R10, -1 */
		/* 8216FA58h case   23:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216FA58h case   23:*/		return 0x8216FA5C;
		  /* 8216FA5Ch */ case   24:  		/* subfe R10, R10, R10 */
		/* 8216FA5Ch case   24:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216FA5Ch case   24:*/		return 0x8216FA60;
		  /* 8216FA60h */ case   25:  		/* and R11, R10, R11 */
		/* 8216FA60h case   25:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216FA60h case   25:*/		return 0x8216FA64;
		  /* 8216FA64h */ case   26:  		/* lwz R11, <#[R11 + 20]> */
		/* 8216FA64h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8216FA64h case   26:*/		return 0x8216FA68;
	}
	return 0x8216FA68;
} // Block from 8216F9FCh-8216FA68h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8216FA68h
// Function '?ReadsTempRegister@Instruction@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FA68);
		  /* 8216FA68h */ case    0:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FA68h case    0:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FA68h case    0:*/		return 0x8216FA6C;
		  /* 8216FA6Ch */ case    1:  		/* addi R16, R11, 1 */
		/* 8216FA6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R11,0x1);
		/* 8216FA6Ch case    1:*/		return 0x8216FA70;
		  /* 8216FA70h */ case    2:  		/* mulli R4, R16, 12 */
		/* 8216FA70h case    2:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R16,0xC);
		/* 8216FA70h case    2:*/		return 0x8216FA74;
		  /* 8216FA74h */ case    3:  		/* bl -43580 */
		/* 8216FA74h case    3:*/		regs.LR = 0x8216FA78; return 0x82165038;
		/* 8216FA74h case    3:*/		return 0x8216FA78;
		  /* 8216FA78h */ case    4:  		/* stw R3, <#[R21 + 732]> */
		/* 8216FA78h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R21 + 0x000002DC) );
		/* 8216FA78h case    4:*/		return 0x8216FA7C;
		  /* 8216FA7Ch */ case    5:  		/* lwz R11, <#[R18]> */
		/* 8216FA7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8216FA7Ch case    5:*/		return 0x8216FA80;
		  /* 8216FA80h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216FA80h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216FA80h case    6:*/		return 0x8216FA84;
		  /* 8216FA84h */ case    7:  		/* bc 4, CR0_EQ, 752 */
		/* 8216FA84h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216FD74;  }
		/* 8216FA84h case    7:*/		return 0x8216FA88;
		  /* 8216FA88h */ case    8:  		/* mr R28, R11 */
		/* 8216FA88h case    8:*/		regs.R28 = regs.R11;
		/* 8216FA88h case    8:*/		return 0x8216FA8C;
		  /* 8216FA8Ch */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 8216FA8Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216FA8Ch case    9:*/		return 0x8216FA90;
		  /* 8216FA90h */ case   10:  		/* bc 12, CR0_EQ, 740 */
		/* 8216FA90h case   10:*/		if ( regs.CR[0].eq ) { return 0x8216FD74;  }
		/* 8216FA90h case   10:*/		return 0x8216FA94;
		  /* 8216FA94h */ case   11:  		/* mr R4, R28 */
		/* 8216FA94h case   11:*/		regs.R4 = regs.R28;
		/* 8216FA94h case   11:*/		return 0x8216FA98;
		  /* 8216FA98h */ case   12:  		/* mr R3, R21 */
		/* 8216FA98h case   12:*/		regs.R3 = regs.R21;
		/* 8216FA98h case   12:*/		return 0x8216FA9C;
		  /* 8216FA9Ch */ case   13:  		/* bl -1372 */
		/* 8216FA9Ch case   13:*/		regs.LR = 0x8216FAA0; return 0x8216F540;
		/* 8216FA9Ch case   13:*/		return 0x8216FAA0;
		  /* 8216FAA0h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FAA0h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FAA0h case   14:*/		return 0x8216FAA4;
		  /* 8216FAA4h */ case   15:  		/* bc 12, CR0_EQ, 692 */
		/* 8216FAA4h case   15:*/		if ( regs.CR[0].eq ) { return 0x8216FD58;  }
		/* 8216FAA4h case   15:*/		return 0x8216FAA8;
		  /* 8216FAA8h */ case   16:  		/* lwz R10, <#[R28]> */
		/* 8216FAA8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 8216FAA8h case   16:*/		return 0x8216FAAC;
		  /* 8216FAACh */ case   17:  		/* li R25, 8191 */
		/* 8216FAACh case   17:*/		cpu::op::li<0>(regs,&regs.R25,0x1FFF);
		/* 8216FAACh case   17:*/		return 0x8216FAB0;
		  /* 8216FAB0h */ case   18:  		/* cmplwi CR6, R10, 0 */
		/* 8216FAB0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216FAB0h case   18:*/		return 0x8216FAB4;
		  /* 8216FAB4h */ case   19:  		/* bc 12, CR6_EQ, 48 */
		/* 8216FAB4h case   19:*/		if ( regs.CR[6].eq ) { return 0x8216FAE4;  }
		/* 8216FAB4h case   19:*/		return 0x8216FAB8;
		  /* 8216FAB8h */ case   20:  		/* lwz R11, <#[R10 + 12]> */
		/* 8216FAB8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8216FAB8h case   20:*/		return 0x8216FABC;
		  /* 8216FABCh */ case   21:  		/* lbz R9, <#[R11 + 16]> */
		/* 8216FABCh case   21:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8216FABCh case   21:*/		return 0x8216FAC0;
		  /* 8216FAC0h */ case   22:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 8216FAC0h case   22:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 8216FAC0h case   22:*/		return 0x8216FAC4;
		  /* 8216FAC4h */ case   23:  		/* bc 12, CR0_EQ, 24 */
		/* 8216FAC4h case   23:*/		if ( regs.CR[0].eq ) { return 0x8216FADC;  }
		/* 8216FAC4h case   23:*/		return 0x8216FAC8;
		  /* 8216FAC8h */ case   24:  		/* lwz R11, <#[R11 + 20]> */
		/* 8216FAC8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8216FAC8h case   24:*/		return 0x8216FACC;
		  /* 8216FACCh */ case   25:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FACCh case   25:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FACCh case   25:*/		return 0x8216FAD0;
		  /* 8216FAD0h */ case   26:  		/* cmplw CR6, R11, R25 */
		/* 8216FAD0h case   26:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8216FAD0h case   26:*/		return 0x8216FAD4;
		  /* 8216FAD4h */ case   27:  		/* bc 4, CR6_LT, 8 */
		/* 8216FAD4h case   27:*/		if ( !regs.CR[6].lt ) { return 0x8216FADC;  }
		/* 8216FAD4h case   27:*/		return 0x8216FAD8;
		  /* 8216FAD8h */ case   28:  		/* mr R25, R11 */
		/* 8216FAD8h case   28:*/		regs.R25 = regs.R11;
		/* 8216FAD8h case   28:*/		return 0x8216FADC;
	}
	return 0x8216FADC;
} // Block from 8216FA68h-8216FADCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 8216FADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FADC);
		  /* 8216FADCh */ case    0:  		/* lwz R10, <#[R10 + 4]> */
		/* 8216FADCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8216FADCh case    0:*/		return 0x8216FAE0;
		  /* 8216FAE0h */ case    1:  		/* b -48 */
		/* 8216FAE0h case    1:*/		return 0x8216FAB0;
		/* 8216FAE0h case    1:*/		return 0x8216FAE4;
	}
	return 0x8216FAE4;
} // Block from 8216FADCh-8216FAE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216FAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FAE4);
		  /* 8216FAE4h */ case    0:  		/* lwz R11, <#[R17 + 48]> */
		/* 8216FAE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000030) );
		/* 8216FAE4h case    0:*/		return 0x8216FAE8;
		  /* 8216FAE8h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8216FAE8h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8216FAE8h case    1:*/		return 0x8216FAEC;
		  /* 8216FAECh */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 8216FAECh case    2:*/		if ( regs.CR[0].eq ) { return 0x8216FB0C;  }
		/* 8216FAECh case    2:*/		return 0x8216FAF0;
		  /* 8216FAF0h */ case    3:  		/* mr R3, R28 */
		/* 8216FAF0h case    3:*/		regs.R3 = regs.R28;
		/* 8216FAF0h case    3:*/		return 0x8216FAF4;
		  /* 8216FAF4h */ case    4:  		/* bl -47684 */
		/* 8216FAF4h case    4:*/		regs.LR = 0x8216FAF8; return 0x821640B0;
		/* 8216FAF4h case    4:*/		return 0x8216FAF8;
		  /* 8216FAF8h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FAF8h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FAF8h case    5:*/		return 0x8216FAFC;
		  /* 8216FAFCh */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 8216FAFCh case    6:*/		if ( regs.CR[0].eq ) { return 0x8216FB0C;  }
		/* 8216FAFCh case    6:*/		return 0x8216FB00;
		  /* 8216FB00h */ case    7:  		/* lwz R11, <#[R28 + 20]> */
		/* 8216FB00h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8216FB00h case    7:*/		return 0x8216FB04;
		  /* 8216FB04h */ case    8:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FB04h case    8:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FB04h case    8:*/		return 0x8216FB08;
		  /* 8216FB08h */ case    9:  		/* addi R25, R11, 1 */
		/* 8216FB08h case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x1);
		/* 8216FB08h case    9:*/		return 0x8216FB0C;
	}
	return 0x8216FB0C;
} // Block from 8216FAE4h-8216FB0Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB0C);
		  /* 8216FB0Ch */ case    0:  		/* lwz R30, <#[R28 + 4]> */
		/* 8216FB0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000004) );
		/* 8216FB0Ch case    0:*/		return 0x8216FB10;
		  /* 8216FB10h */ case    1:  		/* mr R26, R20 */
		/* 8216FB10h case    1:*/		regs.R26 = regs.R20;
		/* 8216FB10h case    1:*/		return 0x8216FB14;
		  /* 8216FB14h */ case    2:  		/* mr R29, R20 */
		/* 8216FB14h case    2:*/		regs.R29 = regs.R20;
		/* 8216FB14h case    2:*/		return 0x8216FB18;
		  /* 8216FB18h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 8216FB18h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216FB18h case    3:*/		return 0x8216FB1C;
		  /* 8216FB1Ch */ case    4:  		/* bc 12, CR6_EQ, 92 */
		/* 8216FB1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8216FB78;  }
		/* 8216FB1Ch case    4:*/		return 0x8216FB20;
		  /* 8216FB20h */ case    5:  		/* lwz R31, <#[R30 + 16]> */
		/* 8216FB20h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 8216FB20h case    5:*/		return 0x8216FB24;
		  /* 8216FB24h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 8216FB24h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216FB24h case    6:*/		return 0x8216FB28;
		  /* 8216FB28h */ case    7:  		/* bc 12, CR6_EQ, 72 */
		/* 8216FB28h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216FB70;  }
		/* 8216FB28h case    7:*/		return 0x8216FB2C;
		  /* 8216FB2Ch */ case    8:  		/* mr R3, R30 */
		/* 8216FB2Ch case    8:*/		regs.R3 = regs.R30;
		/* 8216FB2Ch case    8:*/		return 0x8216FB30;
	}
	return 0x8216FB30;
} // Block from 8216FB0Ch-8216FB30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB30h
// Function '?WritesTempRegister@Instruction@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB30);
		  /* 8216FB30h */ case    0:  		/* bl -45824 */
		/* 8216FB30h case    0:*/		regs.LR = 0x8216FB34; return 0x82164830;
		/* 8216FB30h case    0:*/		return 0x8216FB34;
		  /* 8216FB34h */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FB34h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FB34h case    1:*/		return 0x8216FB38;
		  /* 8216FB38h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 8216FB38h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216FB40;  }
		/* 8216FB38h case    2:*/		return 0x8216FB3C;
		  /* 8216FB3Ch */ case    3:  		/* mr R29, R30 */
		/* 8216FB3Ch case    3:*/		regs.R29 = regs.R30;
		/* 8216FB3Ch case    3:*/		return 0x8216FB40;
	}
	return 0x8216FB40;
} // Block from 8216FB30h-8216FB40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB40);
		  /* 8216FB40h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8216FB40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216FB40h case    0:*/		return 0x8216FB44;
		  /* 8216FB44h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216FB44h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216FB44h case    1:*/		return 0x8216FB48;
		  /* 8216FB48h */ case    2:  		/* cmplwi CR6, R11, 14336 */
		/* 8216FB48h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8216FB48h case    2:*/		return 0x8216FB4C;
		  /* 8216FB4Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8216FB4Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216FB58;  }
		/* 8216FB4Ch case    3:*/		return 0x8216FB50;
		  /* 8216FB50h */ case    4:  		/* mr R11, R20 */
		/* 8216FB50h case    4:*/		regs.R11 = regs.R20;
		/* 8216FB50h case    4:*/		return 0x8216FB54;
		  /* 8216FB54h */ case    5:  		/* b 12 */
		/* 8216FB54h case    5:*/		return 0x8216FB60;
		/* 8216FB54h case    5:*/		return 0x8216FB58;
	}
	return 0x8216FB58;
} // Block from 8216FB40h-8216FB58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB58);
		  /* 8216FB58h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8216FB58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216FB58h case    0:*/		return 0x8216FB5C;
		  /* 8216FB5Ch */ case    1:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FB5Ch case    1:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FB5Ch case    1:*/		return 0x8216FB60;
	}
	return 0x8216FB60;
} // Block from 8216FB58h-8216FB60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB60);
		  /* 8216FB60h */ case    0:  		/* addi R11, R11, 1 */
		/* 8216FB60h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216FB60h case    0:*/		return 0x8216FB64;
		  /* 8216FB64h */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 8216FB64h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8216FB64h case    1:*/		return 0x8216FB68;
		  /* 8216FB68h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 8216FB68h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8216FB70;  }
		/* 8216FB68h case    2:*/		return 0x8216FB6C;
		  /* 8216FB6Ch */ case    3:  		/* mr R26, R11 */
		/* 8216FB6Ch case    3:*/		regs.R26 = regs.R11;
		/* 8216FB6Ch case    3:*/		return 0x8216FB70;
	}
	return 0x8216FB70;
} // Block from 8216FB60h-8216FB70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB70);
		  /* 8216FB70h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8216FB70h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8216FB70h case    0:*/		return 0x8216FB74;
		  /* 8216FB74h */ case    1:  		/* b -92 */
		/* 8216FB74h case    1:*/		return 0x8216FB18;
		/* 8216FB74h case    1:*/		return 0x8216FB78;
	}
	return 0x8216FB78;
} // Block from 8216FB70h-8216FB78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB78);
		  /* 8216FB78h */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 8216FB78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 8216FB78h case    0:*/		return 0x8216FB7C;
		  /* 8216FB7Ch */ case    1:  		/* rlwinm R27, R11, 0, 19, 31 */
		/* 8216FB7Ch case    1:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R27,regs.R11);
		/* 8216FB7Ch case    1:*/		return 0x8216FB80;
		  /* 8216FB80h */ case    2:  		/* cmplw CR6, R26, R27 */
		/* 8216FB80h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 8216FB80h case    2:*/		return 0x8216FB84;
		  /* 8216FB84h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 8216FB84h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216FB8C;  }
		/* 8216FB84h case    3:*/		return 0x8216FB88;
		  /* 8216FB88h */ case    4:  		/* addi R26, R26, 1 */
		/* 8216FB88h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8216FB88h case    4:*/		return 0x8216FB8C;
	}
	return 0x8216FB8C;
} // Block from 8216FB78h-8216FB8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216FB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FB8C);
		  /* 8216FB8Ch */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8216FB8Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8216FB8Ch case    0:*/		return 0x8216FB90;
		  /* 8216FB90h */ case    1:  		/* bc 12, CR6_EQ, 196 */
		/* 8216FB90h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216FC54;  }
		/* 8216FB90h case    1:*/		return 0x8216FB94;
		  /* 8216FB94h */ case    2:  		/* cmplwi CR6, R22, 0 */
		/* 8216FB94h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8216FB94h case    2:*/		return 0x8216FB98;
		  /* 8216FB98h */ case    3:  		/* bc 12, CR6_EQ, 412 */
		/* 8216FB98h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216FD34;  }
		/* 8216FB98h case    3:*/		return 0x8216FB9C;
		  /* 8216FB9Ch */ case    4:  		/* mr R31, R28 */
		/* 8216FB9Ch case    4:*/		regs.R31 = regs.R28;
		/* 8216FB9Ch case    4:*/		return 0x8216FBA0;
		  /* 8216FBA0h */ case    5:  		/* lbz R11, <#[R31 + 16]> */
		/* 8216FBA0h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8216FBA0h case    5:*/		return 0x8216FBA4;
		  /* 8216FBA4h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216FBA4h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216FBA4h case    6:*/		return 0x8216FBA8;
		  /* 8216FBA8h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 8216FBA8h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216FBBC;  }
		/* 8216FBA8h case    7:*/		return 0x8216FBAC;
		  /* 8216FBACh */ case    8:  		/* lwz R11, <#[R31 + 20]> */
		/* 8216FBACh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216FBACh case    8:*/		return 0x8216FBB0;
		  /* 8216FBB0h */ case    9:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FBB0h case    9:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FBB0h case    9:*/		return 0x8216FBB4;
		  /* 8216FBB4h */ case   10:  		/* cmplw CR6, R11, R27 */
		/* 8216FBB4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8216FBB4h case   10:*/		return 0x8216FBB8;
		  /* 8216FBB8h */ case   11:  		/* bc 4, CR6_EQ, 40 */
		/* 8216FBB8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8216FBE0;  }
		/* 8216FBB8h case   11:*/		return 0x8216FBBC;
	}
	return 0x8216FBBC;
} // Block from 8216FB8Ch-8216FBBCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216FBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FBBC);
		  /* 8216FBBCh */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216FBBCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216FBBCh case    0:*/		return 0x8216FBC0;
		  /* 8216FBC0h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216FBC0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216FBC0h case    1:*/		return 0x8216FBC4;
		  /* 8216FBC4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216FBC4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216FBC4h case    2:*/		return 0x8216FBC8;
	}
	return 0x8216FBC8;
} // Block from 8216FBBCh-8216FBC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216FBC8h
// Function '?CanScheduleInstruction@MachineState@D3DXShader@@QAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FBC8);
		  /* 8216FBC8h */ case    0:  		/* bc 4, CR0_EQ, 20 */
		/* 8216FBC8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8216FBDC;  }
		/* 8216FBC8h case    0:*/		return 0x8216FBCC;
		  /* 8216FBCCh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216FBCCh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216FBCCh case    1:*/		return 0x8216FBD0;
		  /* 8216FBD0h */ case    2:  		/* addic. R31, R11, -40 */
		/* 8216FBD0h case    2:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216FBD0h case    2:*/		return 0x8216FBD4;
		  /* 8216FBD4h */ case    3:  		/* bc 4, CR0_EQ, -52 */
		/* 8216FBD4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216FBA0;  }
		/* 8216FBD4h case    3:*/		return 0x8216FBD8;
		  /* 8216FBD8h */ case    4:  		/* b 8 */
		/* 8216FBD8h case    4:*/		return 0x8216FBE0;
		/* 8216FBD8h case    4:*/		return 0x8216FBDC;
	}
	return 0x8216FBDC;
} // Block from 8216FBC8h-8216FBDCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216FBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FBDC);
		  /* 8216FBDCh */ case    0:  		/* mr R31, R20 */
		/* 8216FBDCh case    0:*/		regs.R31 = regs.R20;
		/* 8216FBDCh case    0:*/		return 0x8216FBE0;
	}
	return 0x8216FBE0;
} // Block from 8216FBDCh-8216FBE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FBE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FBE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FBE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FBE0);
		  /* 8216FBE0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8216FBE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216FBE0h case    0:*/		return 0x8216FBE4;
		  /* 8216FBE4h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8216FBE4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216FBE4h case    1:*/		return 0x8216FBE8;
		  /* 8216FBE8h */ case    2:  		/* lwz R10, <#[R28 + 8]> */
		/* 8216FBE8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 8216FBE8h case    2:*/		return 0x8216FBEC;
		  /* 8216FBECh */ case    3:  		/* rlwimi R10, R11, 20, 19, 26 */
		/* 8216FBECh case    3:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R10,regs.R11);
		/* 8216FBECh case    3:*/		return 0x8216FBF0;
		  /* 8216FBF0h */ case    4:  		/* rlwinm R29, R10, 31, 20, 31 */
		/* 8216FBF0h case    4:*/		cpu::op::rlwinm<0,31,20,31>(regs,&regs.R29,regs.R10);
		/* 8216FBF0h case    4:*/		return 0x8216FBF4;
		  /* 8216FBF4h */ case    5:  		/* bc 12, CR6_EQ, 96 */
		/* 8216FBF4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216FC54;  }
		/* 8216FBF4h case    5:*/		return 0x8216FBF8;
		  /* 8216FBF8h */ case    6:  		/* lwz R11, <#[R31 + 20]> */
		/* 8216FBF8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216FBF8h case    6:*/		return 0x8216FBFC;
		  /* 8216FBFCh */ case    7:  		/* rlwinm R30, R11, 0, 19, 31 */
		/* 8216FBFCh case    7:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R30,regs.R11);
		/* 8216FBFCh case    7:*/		return 0x8216FC00;
		  /* 8216FC00h */ case    8:  		/* cmplw CR6, R30, R25 */
		/* 8216FC00h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R25);
		/* 8216FC00h case    8:*/		return 0x8216FC04;
		  /* 8216FC04h */ case    9:  		/* bc 4, CR6_LT, 80 */
		/* 8216FC04h case    9:*/		if ( !regs.CR[6].lt ) { return 0x8216FC54;  }
		/* 8216FC04h case    9:*/		return 0x8216FC08;
		  /* 8216FC08h */ case   10:  		/* mr R4, R29 */
		/* 8216FC08h case   10:*/		regs.R4 = regs.R29;
		/* 8216FC08h case   10:*/		return 0x8216FC0C;
		  /* 8216FC0Ch */ case   11:  		/* mr R3, R31 */
		/* 8216FC0Ch case   11:*/		regs.R3 = regs.R31;
		/* 8216FC0Ch case   11:*/		return 0x8216FC10;
		  /* 8216FC10h */ case   12:  		/* bl -3096 */
		/* 8216FC10h case   12:*/		regs.LR = 0x8216FC14; return 0x8216EFF8;
		/* 8216FC10h case   12:*/		return 0x8216FC14;
		  /* 8216FC14h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FC14h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FC14h case   13:*/		return 0x8216FC18;
		  /* 8216FC18h */ case   14:  		/* bc 4, CR0_EQ, 56 */
		/* 8216FC18h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8216FC50;  }
		/* 8216FC18h case   14:*/		return 0x8216FC1C;
		  /* 8216FC1Ch */ case   15:  		/* mr R4, R29 */
		/* 8216FC1Ch case   15:*/		regs.R4 = regs.R29;
		/* 8216FC1Ch case   15:*/		return 0x8216FC20;
		  /* 8216FC20h */ case   16:  		/* mr R3, R31 */
		/* 8216FC20h case   16:*/		regs.R3 = regs.R31;
		/* 8216FC20h case   16:*/		return 0x8216FC24;
		  /* 8216FC24h */ case   17:  		/* bl -2916 */
		/* 8216FC24h case   17:*/		regs.LR = 0x8216FC28; return 0x8216F0C0;
		/* 8216FC24h case   17:*/		return 0x8216FC28;
		  /* 8216FC28h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FC28h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FC28h case   18:*/		return 0x8216FC2C;
		  /* 8216FC2Ch */ case   19:  		/* bc 4, CR0_EQ, 36 */
		/* 8216FC2Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x8216FC50;  }
		/* 8216FC2Ch case   19:*/		return 0x8216FC30;
		  /* 8216FC30h */ case   20:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216FC30h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216FC30h case   20:*/		return 0x8216FC34;
		  /* 8216FC34h */ case   21:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216FC34h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216FC34h case   21:*/		return 0x8216FC38;
		  /* 8216FC38h */ case   22:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216FC38h case   22:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216FC38h case   22:*/		return 0x8216FC3C;
		  /* 8216FC3Ch */ case   23:  		/* bc 4, CR0_EQ, 24 */
		/* 8216FC3Ch case   23:*/		if ( !regs.CR[0].eq ) { return 0x8216FC54;  }
		/* 8216FC3Ch case   23:*/		return 0x8216FC40;
		  /* 8216FC40h */ case   24:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216FC40h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216FC40h case   24:*/		return 0x8216FC44;
		  /* 8216FC44h */ case   25:  		/* addic. R31, R11, -40 */
		/* 8216FC44h case   25:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216FC44h case   25:*/		return 0x8216FC48;
		  /* 8216FC48h */ case   26:  		/* bc 4, CR0_EQ, -80 */
		/* 8216FC48h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8216FBF8;  }
		/* 8216FC48h case   26:*/		return 0x8216FC4C;
		  /* 8216FC4Ch */ case   27:  		/* b 8 */
		/* 8216FC4Ch case   27:*/		return 0x8216FC54;
		/* 8216FC4Ch case   27:*/		return 0x8216FC50;
	}
	return 0x8216FC50;
} // Block from 8216FBE0h-8216FC50h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8216FC50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FC50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FC50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FC50);
		  /* 8216FC50h */ case    0:  		/* mr R25, R30 */
		/* 8216FC50h case    0:*/		regs.R25 = regs.R30;
		/* 8216FC50h case    0:*/		return 0x8216FC54;
	}
	return 0x8216FC54;
} // Block from 8216FC50h-8216FC54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FC54);
		  /* 8216FC54h */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 8216FC54h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8216FC54h case    0:*/		return 0x8216FC58;
		  /* 8216FC58h */ case    1:  		/* bc 12, CR6_EQ, 220 */
		/* 8216FC58h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216FD34;  }
		/* 8216FC58h case    1:*/		return 0x8216FC5C;
		  /* 8216FC5Ch */ case    2:  		/* mr R31, R28 */
		/* 8216FC5Ch case    2:*/		regs.R31 = regs.R28;
		/* 8216FC5Ch case    2:*/		return 0x8216FC60;
		  /* 8216FC60h */ case    3:  		/* lbz R11, <#[R31 + 16]> */
		/* 8216FC60h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8216FC60h case    3:*/		return 0x8216FC64;
		  /* 8216FC64h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216FC64h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216FC64h case    4:*/		return 0x8216FC68;
		  /* 8216FC68h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 8216FC68h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216FC7C;  }
		/* 8216FC68h case    5:*/		return 0x8216FC6C;
		  /* 8216FC6Ch */ case    6:  		/* lwz R11, <#[R31 + 20]> */
		/* 8216FC6Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216FC6Ch case    6:*/		return 0x8216FC70;
		  /* 8216FC70h */ case    7:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FC70h case    7:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FC70h case    7:*/		return 0x8216FC74;
		  /* 8216FC74h */ case    8:  		/* cmplw CR6, R11, R27 */
		/* 8216FC74h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8216FC74h case    8:*/		return 0x8216FC78;
		  /* 8216FC78h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 8216FC78h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8216FC98;  }
		/* 8216FC78h case    9:*/		return 0x8216FC7C;
	}
	return 0x8216FC7C;
} // Block from 8216FC54h-8216FC7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216FC7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FC7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FC7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FC7C);
		  /* 8216FC7Ch */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216FC7Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216FC7Ch case    0:*/		return 0x8216FC80;
		  /* 8216FC80h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 8216FC80h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8216FC80h case    1:*/		return 0x8216FC84;
		  /* 8216FC84h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216FC84h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216FC84h case    2:*/		return 0x8216FC88;
		  /* 8216FC88h */ case    3:  		/* bc 4, CR0_EQ, 172 */
		/* 8216FC88h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216FD34;  }
		/* 8216FC88h case    3:*/		return 0x8216FC8C;
		  /* 8216FC8Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216FC8Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216FC8Ch case    4:*/		return 0x8216FC90;
		  /* 8216FC90h */ case    5:  		/* bc 4, CR6_EQ, -48 */
		/* 8216FC90h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216FC60;  }
		/* 8216FC90h case    5:*/		return 0x8216FC94;
		  /* 8216FC94h */ case    6:  		/* b 160 */
		/* 8216FC94h case    6:*/		return 0x8216FD34;
		/* 8216FC94h case    6:*/		return 0x8216FC98;
	}
	return 0x8216FC98;
} // Block from 8216FC7Ch-8216FC98h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216FC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FC98);
		  /* 8216FC98h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8216FC98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216FC98h case    0:*/		return 0x8216FC9C;
		  /* 8216FC9Ch */ case    1:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FC9Ch case    1:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FC9Ch case    1:*/		return 0x8216FCA0;
		  /* 8216FCA0h */ case    2:  		/* addi R29, R11, 1 */
		/* 8216FCA0h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 8216FCA0h case    2:*/		return 0x8216FCA4;
		  /* 8216FCA4h */ case    3:  		/* cmplw CR6, R29, R26 */
		/* 8216FCA4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R26);
		/* 8216FCA4h case    3:*/		return 0x8216FCA8;
		  /* 8216FCA8h */ case    4:  		/* bc 4, CR6_GT, 140 */
		/* 8216FCA8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8216FD34;  }
		/* 8216FCA8h case    4:*/		return 0x8216FCAC;
		  /* 8216FCACh */ case    5:  		/* lwz R30, <#[R31 + 4]> */
		/* 8216FCACh case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8216FCACh case    5:*/		return 0x8216FCB0;
		  /* 8216FCB0h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 8216FCB0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216FCB0h case    6:*/		return 0x8216FCB4;
		  /* 8216FCB4h */ case    7:  		/* bc 12, CR6_EQ, 96 */
		/* 8216FCB4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8216FD14;  }
		/* 8216FCB4h case    7:*/		return 0x8216FCB8;
		  /* 8216FCB8h */ case    8:  		/* lwz R11, <#[R30 + 16]> */
		/* 8216FCB8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8216FCB8h case    8:*/		return 0x8216FCBC;
		  /* 8216FCBCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8216FCBCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216FCBCh case    9:*/		return 0x8216FCC0;
		  /* 8216FCC0h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 8216FCC0h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216FCD4;  }
		/* 8216FCC0h case   10:*/		return 0x8216FCC4;
		  /* 8216FCC4h */ case   11:  		/* mr R3, R30 */
		/* 8216FCC4h case   11:*/		regs.R3 = regs.R30;
		/* 8216FCC4h case   11:*/		return 0x8216FCC8;
		  /* 8216FCC8h */ case   12:  		/* bl -46232 */
		/* 8216FCC8h case   12:*/		regs.LR = 0x8216FCCC; return 0x82164830;
		/* 8216FCC8h case   12:*/		return 0x8216FCCC;
		  /* 8216FCCCh */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FCCCh case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FCCCh case   13:*/		return 0x8216FCD0;
		  /* 8216FCD0h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 8216FCD0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8216FCDC;  }
		/* 8216FCD0h case   14:*/		return 0x8216FCD4;
	}
	return 0x8216FCD4;
} // Block from 8216FC98h-8216FCD4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216FCD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FCD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FCD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FCD4);
		  /* 8216FCD4h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8216FCD4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8216FCD4h case    0:*/		return 0x8216FCD8;
		  /* 8216FCD8h */ case    1:  		/* b -40 */
		/* 8216FCD8h case    1:*/		return 0x8216FCB0;
		/* 8216FCD8h case    1:*/		return 0x8216FCDC;
	}
	return 0x8216FCDC;
} // Block from 8216FCD4h-8216FCDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216FCDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FCDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FCDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FCDC);
		  /* 8216FCDCh */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8216FCDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216FCDCh case    0:*/		return 0x8216FCE0;
		  /* 8216FCE0h */ case    1:  		/* mr R3, R28 */
		/* 8216FCE0h case    1:*/		regs.R3 = regs.R28;
		/* 8216FCE0h case    1:*/		return 0x8216FCE4;
		  /* 8216FCE4h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8216FCE4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8216FCE4h case    2:*/		return 0x8216FCE8;
		  /* 8216FCE8h */ case    3:  		/* rlwimi R10, R11, 20, 19, 26 */
		/* 8216FCE8h case    3:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R10,regs.R11);
		/* 8216FCE8h case    3:*/		return 0x8216FCEC;
		  /* 8216FCECh */ case    4:  		/* rlwinm R30, R10, 31, 20, 31 */
		/* 8216FCECh case    4:*/		cpu::op::rlwinm<0,31,20,31>(regs,&regs.R30,regs.R10);
		/* 8216FCECh case    4:*/		return 0x8216FCF0;
		  /* 8216FCF0h */ case    5:  		/* mr R4, R30 */
		/* 8216FCF0h case    5:*/		regs.R4 = regs.R30;
		/* 8216FCF0h case    5:*/		return 0x8216FCF4;
		  /* 8216FCF4h */ case    6:  		/* bl -3324 */
		/* 8216FCF4h case    6:*/		regs.LR = 0x8216FCF8; return 0x8216EFF8;
		/* 8216FCF4h case    6:*/		return 0x8216FCF8;
		  /* 8216FCF8h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FCF8h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FCF8h case    7:*/		return 0x8216FCFC;
		  /* 8216FCFCh */ case    8:  		/* bc 4, CR0_EQ, 52 */
		/* 8216FCFCh case    8:*/		if ( !regs.CR[0].eq ) { return 0x8216FD30;  }
		/* 8216FCFCh case    8:*/		return 0x8216FD00;
		  /* 8216FD00h */ case    9:  		/* mr R4, R30 */
		/* 8216FD00h case    9:*/		regs.R4 = regs.R30;
		/* 8216FD00h case    9:*/		return 0x8216FD04;
		  /* 8216FD04h */ case   10:  		/* mr R3, R28 */
		/* 8216FD04h case   10:*/		regs.R3 = regs.R28;
		/* 8216FD04h case   10:*/		return 0x8216FD08;
		  /* 8216FD08h */ case   11:  		/* bl -3144 */
		/* 8216FD08h case   11:*/		regs.LR = 0x8216FD0C; return 0x8216F0C0;
		/* 8216FD08h case   11:*/		return 0x8216FD0C;
		  /* 8216FD0Ch */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FD0Ch case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FD0Ch case   12:*/		return 0x8216FD10;
		  /* 8216FD10h */ case   13:  		/* bc 4, CR0_EQ, 32 */
		/* 8216FD10h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8216FD30;  }
		/* 8216FD10h case   13:*/		return 0x8216FD14;
	}
	return 0x8216FD14;
} // Block from 8216FCDCh-8216FD14h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216FD14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FD14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FD14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FD14);
		  /* 8216FD14h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216FD14h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216FD14h case    0:*/		return 0x8216FD18;
		  /* 8216FD18h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 8216FD18h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 8216FD18h case    1:*/		return 0x8216FD1C;
		  /* 8216FD1Ch */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8216FD1Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8216FD1Ch case    2:*/		return 0x8216FD20;
		  /* 8216FD20h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 8216FD20h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216FD34;  }
		/* 8216FD20h case    3:*/		return 0x8216FD24;
		  /* 8216FD24h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216FD24h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216FD24h case    4:*/		return 0x8216FD28;
		  /* 8216FD28h */ case    5:  		/* bc 4, CR6_EQ, -144 */
		/* 8216FD28h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216FC98;  }
		/* 8216FD28h case    5:*/		return 0x8216FD2C;
		  /* 8216FD2Ch */ case    6:  		/* b 8 */
		/* 8216FD2Ch case    6:*/		return 0x8216FD34;
		/* 8216FD2Ch case    6:*/		return 0x8216FD30;
	}
	return 0x8216FD30;
} // Block from 8216FD14h-8216FD30h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216FD30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FD30);
		  /* 8216FD30h */ case    0:  		/* mr R26, R29 */
		/* 8216FD30h case    0:*/		regs.R26 = regs.R29;
		/* 8216FD30h case    0:*/		return 0x8216FD34;
	}
	return 0x8216FD34;
} // Block from 8216FD30h-8216FD34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FD34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FD34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FD34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FD34);
		  /* 8216FD34h */ case    0:  		/* lwz R11, <#[R21 + 732]> */
		/* 8216FD34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x000002DC) );
		/* 8216FD34h case    0:*/		return 0x8216FD38;
		  /* 8216FD38h */ case    1:  		/* mulli R10, R27, 12 */
		/* 8216FD38h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R27,0xC);
		/* 8216FD38h case    1:*/		return 0x8216FD3C;
		  /* 8216FD3Ch */ case    2:  		/* add R11, R10, R11 */
		/* 8216FD3Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216FD3Ch case    2:*/		return 0x8216FD40;
		  /* 8216FD40h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 8216FD40h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8216FD40h case    3:*/		return 0x8216FD44;
		  /* 8216FD44h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 8216FD44h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216FD44h case    4:*/		return 0x8216FD48;
	}
	return 0x8216FD48;
} // Block from 8216FD34h-8216FD48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216FD48h
// Function '?ReserveResources@MachineState@D3DXShader@@QAAXPAVDependency@2@PAVInstruction@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FD48);
		  /* 8216FD48h */ case    0:  		/* bc 4, CR6_EQ, 1860 */
		/* 8216FD48h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8217048C;  }
		/* 8216FD48h case    0:*/		return 0x8216FD4C;
		  /* 8216FD4Ch */ case    1:  		/* stw R28, <#[R11]> */
		/* 8216FD4Ch case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 8216FD4Ch case    1:*/		return 0x8216FD50;
		  /* 8216FD50h */ case    2:  		/* stw R25, <#[R11 + 4]> */
		/* 8216FD50h case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000004) );
		/* 8216FD50h case    2:*/		return 0x8216FD54;
		  /* 8216FD54h */ case    3:  		/* stw R26, <#[R11 + 8]> */
		/* 8216FD54h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000008) );
		/* 8216FD54h case    3:*/		return 0x8216FD58;
	}
	return 0x8216FD58;
} // Block from 8216FD48h-8216FD58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216FD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FD58);
		  /* 8216FD58h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8216FD58h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8216FD58h case    0:*/		return 0x8216FD5C;
		  /* 8216FD5Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216FD5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216FD5Ch case    1:*/		return 0x8216FD60;
		  /* 8216FD60h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216FD60h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216FD60h case    2:*/		return 0x8216FD64;
		  /* 8216FD64h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216FD64h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216FD74;  }
		/* 8216FD64h case    3:*/		return 0x8216FD68;
		  /* 8216FD68h */ case    4:  		/* mr R28, R11 */
		/* 8216FD68h case    4:*/		regs.R28 = regs.R11;
		/* 8216FD68h case    4:*/		return 0x8216FD6C;
		  /* 8216FD6Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216FD6Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216FD6Ch case    5:*/		return 0x8216FD70;
		  /* 8216FD70h */ case    6:  		/* bc 4, CR6_EQ, -732 */
		/* 8216FD70h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216FA94;  }
		/* 8216FD70h case    6:*/		return 0x8216FD74;
	}
	return 0x8216FD74;
} // Block from 8216FD58h-8216FD74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216FD74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FD74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FD74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FD74);
		  /* 8216FD74h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8216FD74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8216FD74h case    0:*/		return 0x8216FD78;
		  /* 8216FD78h */ case    1:  		/* lwz R24, <#[R21 + 732]> */
		/* 8216FD78h case    1:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R21 + 0x000002DC) );
		/* 8216FD78h case    1:*/		return 0x8216FD7C;
		  /* 8216FD7Ch */ case    2:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8216FD7Ch case    2:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8216FD7Ch case    2:*/		return 0x8216FD80;
		  /* 8216FD80h */ case    3:  		/* mulli R11, R11, 12 */
		/* 8216FD80h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8216FD80h case    3:*/		return 0x8216FD84;
		  /* 8216FD84h */ case    4:  		/* add R23, R11, R24 */
		/* 8216FD84h case    4:*/		cpu::op::add<0>(regs,&regs.R23,regs.R11,regs.R24);
		/* 8216FD84h case    4:*/		return 0x8216FD88;
		  /* 8216FD88h */ case    5:  		/* b 896 */
		/* 8216FD88h case    5:*/		return 0x82170108;
		/* 8216FD88h case    5:*/		return 0x8216FD8C;
		  /* 8216FD8Ch */ case    6:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216FD8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216FD8Ch case    6:*/		return 0x8216FD90;
		  /* 8216FD90h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8216FD90h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216FD90h case    7:*/		return 0x8216FD94;
		  /* 8216FD94h */ case    8:  		/* bc 12, CR6_EQ, 880 */
		/* 8216FD94h case    8:*/		if ( regs.CR[6].eq ) { return 0x82170104;  }
		/* 8216FD94h case    8:*/		return 0x8216FD98;
		  /* 8216FD98h */ case    9:  		/* lwz R10, <#[R23 + 8]> */
		/* 8216FD98h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 8216FD98h case    9:*/		return 0x8216FD9C;
		  /* 8216FD9Ch */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 8216FD9Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216FD9Ch case   10:*/		return 0x8216FDA0;
	}
	return 0x8216FDA0;
} // Block from 8216FD74h-8216FDA0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216FDA0h
// Function '?SimulateBackwards@MachineState@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FDA0);
		  /* 8216FDA0h */ case    0:  		/* bc 12, CR6_GT, 868 */
		/* 8216FDA0h case    0:*/		if ( regs.CR[6].gt ) { return 0x82170104;  }
		/* 8216FDA0h case    0:*/		return 0x8216FDA4;
		  /* 8216FDA4h */ case    1:  		/* lwz R11, <#[R19 + 8]> */
		/* 8216FDA4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 8216FDA4h case    1:*/		return 0x8216FDA8;
		  /* 8216FDA8h */ case    2:  		/* lwz R9, <#[R24]> */
		/* 8216FDA8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000000) );
		/* 8216FDA8h case    2:*/		return 0x8216FDAC;
		  /* 8216FDACh */ case    3:  		/* rlwinm R8, R11, 25, 25, 31 */
		/* 8216FDACh case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R11);
		/* 8216FDACh case    3:*/		return 0x8216FDB0;
		  /* 8216FDB0h */ case    4:  		/* cmplwi CR6, R8, 1 */
		/* 8216FDB0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 8216FDB0h case    4:*/		return 0x8216FDB4;
		  /* 8216FDB4h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 8216FDB4h case    5:*/		if ( regs.CR[6].lt ) { return 0x8216FDC4;  }
		/* 8216FDB4h case    5:*/		return 0x8216FDB8;
		  /* 8216FDB8h */ case    6:  		/* cmplwi CR6, R8, 31 */
		/* 8216FDB8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000001F);
		/* 8216FDB8h case    6:*/		return 0x8216FDBC;
		  /* 8216FDBCh */ case    7:  		/* li R10, 1 */
		/* 8216FDBCh case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216FDBCh case    7:*/		return 0x8216FDC0;
		  /* 8216FDC0h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8216FDC0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8216FDC8;  }
		/* 8216FDC0h case    8:*/		return 0x8216FDC4;
	}
	return 0x8216FDC4;
} // Block from 8216FDA0h-8216FDC4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216FDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FDC4);
		  /* 8216FDC4h */ case    0:  		/* mr R10, R20 */
		/* 8216FDC4h case    0:*/		regs.R10 = regs.R20;
		/* 8216FDC4h case    0:*/		return 0x8216FDC8;
	}
	return 0x8216FDC8;
} // Block from 8216FDC4h-8216FDC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FDC8);
		  /* 8216FDC8h */ case    0:  		/* lwz R11, <#[R9 + 8]> */
		/* 8216FDC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8216FDC8h case    0:*/		return 0x8216FDCC;
		  /* 8216FDCCh */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216FDCCh case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216FDCCh case    1:*/		return 0x8216FDD0;
		  /* 8216FDD0h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 8216FDD0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216FDD0h case    2:*/		return 0x8216FDD4;
		  /* 8216FDD4h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8216FDD4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216FDE4;  }
		/* 8216FDD4h case    3:*/		return 0x8216FDD8;
		  /* 8216FDD8h */ case    4:  		/* cmplwi CR6, R11, 31 */
		/* 8216FDD8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 8216FDD8h case    4:*/		return 0x8216FDDC;
		  /* 8216FDDCh */ case    5:  		/* li R11, 1 */
		/* 8216FDDCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216FDDCh case    5:*/		return 0x8216FDE0;
		  /* 8216FDE0h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8216FDE0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8216FDE8;  }
		/* 8216FDE0h case    6:*/		return 0x8216FDE4;
	}
	return 0x8216FDE4;
} // Block from 8216FDC8h-8216FDE4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216FDE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FDE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FDE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FDE4);
		  /* 8216FDE4h */ case    0:  		/* mr R11, R20 */
		/* 8216FDE4h case    0:*/		regs.R11 = regs.R20;
		/* 8216FDE4h case    0:*/		return 0x8216FDE8;
	}
	return 0x8216FDE8;
} // Block from 8216FDE4h-8216FDE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FDE8);
		  /* 8216FDE8h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8216FDE8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216FDE8h case    0:*/		return 0x8216FDEC;
		  /* 8216FDECh */ case    1:  		/* rlwinm R10, R10, 0, 24, 31 */
		/* 8216FDECh case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8216FDECh case    1:*/		return 0x8216FDF0;
		  /* 8216FDF0h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8216FDF0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216FDF0h case    2:*/		return 0x8216FDF4;
		  /* 8216FDF4h */ case    3:  		/* bc 12, CR6_EQ, 784 */
		/* 8216FDF4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82170104;  }
		/* 8216FDF4h case    3:*/		return 0x8216FDF8;
		  /* 8216FDF8h */ case    4:  		/* lwz R11, <#[R19]> */
		/* 8216FDF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8216FDF8h case    4:*/		return 0x8216FDFC;
		  /* 8216FDFCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216FDFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216FDFCh case    5:*/		return 0x8216FE00;
		  /* 8216FE00h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 8216FE00h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216FE20;  }
		/* 8216FE00h case    6:*/		return 0x8216FE04;
		  /* 8216FE04h */ case    7:  		/* lwz R10, <#[R11 + 12]> */
		/* 8216FE04h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216FE04h case    7:*/		return 0x8216FE08;
		  /* 8216FE08h */ case    8:  		/* cmplw CR6, R10, R9 */
		/* 8216FE08h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8216FE08h case    8:*/		return 0x8216FE0C;
		  /* 8216FE0Ch */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 8216FE0Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8216FE18;  }
		/* 8216FE0Ch case    9:*/		return 0x8216FE10;
		  /* 8216FE10h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216FE10h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216FE10h case   10:*/		return 0x8216FE14;
		  /* 8216FE14h */ case   11:  		/* b -24 */
		/* 8216FE14h case   11:*/		return 0x8216FDFC;
		/* 8216FE14h case   11:*/		return 0x8216FE18;
	}
	return 0x8216FE18;
} // Block from 8216FDE8h-8216FE18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE18);
		  /* 8216FE18h */ case    0:  		/* li R11, 1 */
		/* 8216FE18h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216FE18h case    0:*/		return 0x8216FE1C;
		  /* 8216FE1Ch */ case    1:  		/* b 8 */
		/* 8216FE1Ch case    1:*/		return 0x8216FE24;
		/* 8216FE1Ch case    1:*/		return 0x8216FE20;
	}
	return 0x8216FE20;
} // Block from 8216FE18h-8216FE20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE20);
		  /* 8216FE20h */ case    0:  		/* mr R11, R20 */
		/* 8216FE20h case    0:*/		regs.R11 = regs.R20;
		/* 8216FE20h case    0:*/		return 0x8216FE24;
	}
	return 0x8216FE24;
} // Block from 8216FE20h-8216FE24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE24);
		  /* 8216FE24h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216FE24h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216FE24h case    0:*/		return 0x8216FE28;
	}
	return 0x8216FE28;
} // Block from 8216FE24h-8216FE28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE28h
// Function '?IsFinalSchedulingCandidate@Compiler@D3DXShader@@AAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE28);
		  /* 8216FE28h */ case    0:  		/* bc 4, CR0_EQ, 732 */
		/* 8216FE28h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82170104;  }
		/* 8216FE28h case    0:*/		return 0x8216FE2C;
		  /* 8216FE2Ch */ case    1:  		/* lwz R11, <#[R9]> */
		/* 8216FE2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8216FE2Ch case    1:*/		return 0x8216FE30;
		  /* 8216FE30h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8216FE30h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216FE30h case    2:*/		return 0x8216FE34;
		  /* 8216FE34h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8216FE34h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216FE54;  }
		/* 8216FE34h case    3:*/		return 0x8216FE38;
		  /* 8216FE38h */ case    4:  		/* lwz R10, <#[R11 + 12]> */
		/* 8216FE38h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216FE38h case    4:*/		return 0x8216FE3C;
		  /* 8216FE3Ch */ case    5:  		/* cmplw CR6, R10, R19 */
		/* 8216FE3Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 8216FE3Ch case    5:*/		return 0x8216FE40;
		  /* 8216FE40h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8216FE40h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216FE4C;  }
		/* 8216FE40h case    6:*/		return 0x8216FE44;
		  /* 8216FE44h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216FE44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216FE44h case    7:*/		return 0x8216FE48;
		  /* 8216FE48h */ case    8:  		/* b -24 */
		/* 8216FE48h case    8:*/		return 0x8216FE30;
		/* 8216FE48h case    8:*/		return 0x8216FE4C;
	}
	return 0x8216FE4C;
} // Block from 8216FE28h-8216FE4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE4C);
		  /* 8216FE4Ch */ case    0:  		/* li R11, 1 */
		/* 8216FE4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216FE4Ch case    0:*/		return 0x8216FE50;
		  /* 8216FE50h */ case    1:  		/* b 8 */
		/* 8216FE50h case    1:*/		return 0x8216FE58;
		/* 8216FE50h case    1:*/		return 0x8216FE54;
	}
	return 0x8216FE54;
} // Block from 8216FE4Ch-8216FE54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE54);
		  /* 8216FE54h */ case    0:  		/* mr R11, R20 */
		/* 8216FE54h case    0:*/		regs.R11 = regs.R20;
		/* 8216FE54h case    0:*/		return 0x8216FE58;
	}
	return 0x8216FE58;
} // Block from 8216FE54h-8216FE58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE58);
		  /* 8216FE58h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216FE58h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216FE58h case    0:*/		return 0x8216FE5C;
		  /* 8216FE5Ch */ case    1:  		/* bc 4, CR0_EQ, 680 */
		/* 8216FE5Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82170104;  }
		/* 8216FE5Ch case    1:*/		return 0x8216FE60;
		  /* 8216FE60h */ case    2:  		/* cmplwi CR6, R8, 1 */
		/* 8216FE60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 8216FE60h case    2:*/		return 0x8216FE64;
		  /* 8216FE64h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8216FE64h case    3:*/		if ( regs.CR[6].lt ) { return 0x8216FE74;  }
		/* 8216FE64h case    3:*/		return 0x8216FE68;
		  /* 8216FE68h */ case    4:  		/* cmplwi CR6, R8, 31 */
		/* 8216FE68h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000001F);
		/* 8216FE68h case    4:*/		return 0x8216FE6C;
		  /* 8216FE6Ch */ case    5:  		/* li R11, 1 */
		/* 8216FE6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216FE6Ch case    5:*/		return 0x8216FE70;
		  /* 8216FE70h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8216FE70h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8216FE78;  }
		/* 8216FE70h case    6:*/		return 0x8216FE74;
	}
	return 0x8216FE74;
} // Block from 8216FE58h-8216FE74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE74);
		  /* 8216FE74h */ case    0:  		/* mr R11, R20 */
		/* 8216FE74h case    0:*/		regs.R11 = regs.R20;
		/* 8216FE74h case    0:*/		return 0x8216FE78;
	}
	return 0x8216FE78;
} // Block from 8216FE74h-8216FE78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE78);
		  /* 8216FE78h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216FE78h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216FE78h case    0:*/		return 0x8216FE7C;
		  /* 8216FE7Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8216FE7Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8216FE8C;  }
		/* 8216FE7Ch case    1:*/		return 0x8216FE80;
		  /* 8216FE80h */ case    2:  		/* mr R28, R19 */
		/* 8216FE80h case    2:*/		regs.R28 = regs.R19;
		/* 8216FE80h case    2:*/		return 0x8216FE84;
		  /* 8216FE84h */ case    3:  		/* mr R26, R9 */
		/* 8216FE84h case    3:*/		regs.R26 = regs.R9;
		/* 8216FE84h case    3:*/		return 0x8216FE88;
		  /* 8216FE88h */ case    4:  		/* b 12 */
		/* 8216FE88h case    4:*/		return 0x8216FE94;
		/* 8216FE88h case    4:*/		return 0x8216FE8C;
	}
	return 0x8216FE8C;
} // Block from 8216FE78h-8216FE8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE8C);
		  /* 8216FE8Ch */ case    0:  		/* mr R28, R9 */
		/* 8216FE8Ch case    0:*/		regs.R28 = regs.R9;
		/* 8216FE8Ch case    0:*/		return 0x8216FE90;
		  /* 8216FE90h */ case    1:  		/* mr R26, R19 */
		/* 8216FE90h case    1:*/		regs.R26 = regs.R19;
		/* 8216FE90h case    1:*/		return 0x8216FE94;
	}
	return 0x8216FE94;
} // Block from 8216FE8Ch-8216FE94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216FE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FE94);
		  /* 8216FE94h */ case    0:  		/* mr R5, R26 */
		/* 8216FE94h case    0:*/		regs.R5 = regs.R26;
		/* 8216FE94h case    0:*/		return 0x8216FE98;
		  /* 8216FE98h */ case    1:  		/* mr R4, R28 */
		/* 8216FE98h case    1:*/		regs.R4 = regs.R28;
		/* 8216FE98h case    1:*/		return 0x8216FE9C;
		  /* 8216FE9Ch */ case    2:  		/* mr R3, R21 */
		/* 8216FE9Ch case    2:*/		regs.R3 = regs.R21;
		/* 8216FE9Ch case    2:*/		return 0x8216FEA0;
		  /* 8216FEA0h */ case    3:  		/* bl 130616 */
		/* 8216FEA0h case    3:*/		regs.LR = 0x8216FEA4; return 0x8218FCD8;
		/* 8216FEA0h case    3:*/		return 0x8216FEA4;
		  /* 8216FEA4h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FEA4h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FEA4h case    4:*/		return 0x8216FEA8;
		  /* 8216FEA8h */ case    5:  		/* bc 12, CR0_EQ, 604 */
		/* 8216FEA8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82170104;  }
		/* 8216FEA8h case    5:*/		return 0x8216FEAC;
		  /* 8216FEACh */ case    6:  		/* lwz R11, <#[R23 + 4]> */
		/* 8216FEACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8216FEACh case    6:*/		return 0x8216FEB0;
		  /* 8216FEB0h */ case    7:  		/* lwz R10, <#[R24 + 4]> */
		/* 8216FEB0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000004) );
		/* 8216FEB0h case    7:*/		return 0x8216FEB4;
		  /* 8216FEB4h */ case    8:  		/* mr R25, R11 */
		/* 8216FEB4h case    8:*/		regs.R25 = regs.R11;
		/* 8216FEB4h case    8:*/		return 0x8216FEB8;
		  /* 8216FEB8h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 8216FEB8h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216FEB8h case    9:*/		return 0x8216FEBC;
		  /* 8216FEBCh */ case   10:  		/* bc 12, CR6_LT, 8 */
		/* 8216FEBCh case   10:*/		if ( regs.CR[6].lt ) { return 0x8216FEC4;  }
		/* 8216FEBCh case   10:*/		return 0x8216FEC0;
		  /* 8216FEC0h */ case   11:  		/* mr R25, R10 */
		/* 8216FEC0h case   11:*/		regs.R25 = regs.R10;
		/* 8216FEC0h case   11:*/		return 0x8216FEC4;
	}
	return 0x8216FEC4;
} // Block from 8216FE94h-8216FEC4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216FEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FEC4);
		  /* 8216FEC4h */ case    0:  		/* lwz R11, <#[R23 + 8]> */
		/* 8216FEC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8216FEC4h case    0:*/		return 0x8216FEC8;
		  /* 8216FEC8h */ case    1:  		/* lwz R10, <#[R24 + 8]> */
		/* 8216FEC8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 8216FEC8h case    1:*/		return 0x8216FECC;
		  /* 8216FECCh */ case    2:  		/* mr R27, R11 */
		/* 8216FECCh case    2:*/		regs.R27 = regs.R11;
		/* 8216FECCh case    2:*/		return 0x8216FED0;
		  /* 8216FED0h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8216FED0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216FED0h case    3:*/		return 0x8216FED4;
		  /* 8216FED4h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 8216FED4h case    4:*/		if ( regs.CR[6].gt ) { return 0x8216FEDC;  }
		/* 8216FED4h case    4:*/		return 0x8216FED8;
		  /* 8216FED8h */ case    5:  		/* mr R27, R10 */
		/* 8216FED8h case    5:*/		regs.R27 = regs.R10;
		/* 8216FED8h case    5:*/		return 0x8216FEDC;
	}
	return 0x8216FEDC;
} // Block from 8216FEC4h-8216FEDCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216FEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FEDC);
		  /* 8216FEDCh */ case    0:  		/* cmplw CR6, R25, R27 */
		/* 8216FEDCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R27);
		/* 8216FEDCh case    0:*/		return 0x8216FEE0;
		  /* 8216FEE0h */ case    1:  		/* bc 12, CR6_LT, 1464 */
		/* 8216FEE0h case    1:*/		if ( regs.CR[6].lt ) { return 0x82170498;  }
		/* 8216FEE0h case    1:*/		return 0x8216FEE4;
		  /* 8216FEE4h */ case    2:  		/* cmplwi CR6, R22, 0 */
		/* 8216FEE4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8216FEE4h case    2:*/		return 0x8216FEE8;
		  /* 8216FEE8h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 8216FEE8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216FF20;  }
		/* 8216FEE8h case    3:*/		return 0x8216FEEC;
		  /* 8216FEECh */ case    4:  		/* std R20, <#[R22 + 8]> */
		/* 8216FEECh case    4:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000008) );
		/* 8216FEECh case    4:*/		return 0x8216FEF0;
		  /* 8216FEF0h */ case    5:  		/* mr R5, R22 */
		/* 8216FEF0h case    5:*/		regs.R5 = regs.R22;
		/* 8216FEF0h case    5:*/		return 0x8216FEF4;
		  /* 8216FEF4h */ case    6:  		/* std R20, <#[R22 + 16]> */
		/* 8216FEF4h case    6:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000010) );
		/* 8216FEF4h case    6:*/		return 0x8216FEF8;
		  /* 8216FEF8h */ case    7:  		/* mr R4, R17 */
		/* 8216FEF8h case    7:*/		regs.R4 = regs.R17;
		/* 8216FEF8h case    7:*/		return 0x8216FEFC;
		  /* 8216FEFCh */ case    8:  		/* std R20, <#[R22 + 24]> */
		/* 8216FEFCh case    8:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000018) );
		/* 8216FEFCh case    8:*/		return 0x8216FF00;
		  /* 8216FF00h */ case    9:  		/* mr R3, R21 */
		/* 8216FF00h case    9:*/		regs.R3 = regs.R21;
		/* 8216FF00h case    9:*/		return 0x8216FF04;
		  /* 8216FF04h */ case   10:  		/* std R20, <#[R22 + 32]> */
		/* 8216FF04h case   10:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000020) );
		/* 8216FF04h case   10:*/		return 0x8216FF08;
	}
	return 0x8216FF08;
} // Block from 8216FEDCh-8216FF08h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216FF08h
// Function '?Init@?$_SpecialRegisterSet@VGeneralRegisterSet@D3DXShader@@@D3DXShader@@QAAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FF08);
		  /* 8216FF08h */ case    0:  		/* std R20, <#[R22 + 40]> */
		/* 8216FF08h case    0:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000028) );
		/* 8216FF08h case    0:*/		return 0x8216FF0C;
		  /* 8216FF0Ch */ case    1:  		/* std R20, <#[R22 + 48]> */
		/* 8216FF0Ch case    1:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000030) );
		/* 8216FF0Ch case    1:*/		return 0x8216FF10;
		  /* 8216FF10h */ case    2:  		/* std R20, <#[R22 + 56]> */
		/* 8216FF10h case    2:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000038) );
		/* 8216FF10h case    2:*/		return 0x8216FF14;
		  /* 8216FF14h */ case    3:  		/* std R20, <#[R22 + 64]> */
		/* 8216FF14h case    3:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000040) );
		/* 8216FF14h case    3:*/		return 0x8216FF18;
		  /* 8216FF18h */ case    4:  		/* stw R20, <#[R22 + 72]> */
		/* 8216FF18h case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R22 + 0x00000048) );
		/* 8216FF18h case    4:*/		return 0x8216FF1C;
		  /* 8216FF1Ch */ case    5:  		/* bl -1700 */
		/* 8216FF1Ch case    5:*/		regs.LR = 0x8216FF20; return 0x8216F878;
		/* 8216FF1Ch case    5:*/		return 0x8216FF20;
	}
	return 0x8216FF20;
} // Block from 8216FF08h-8216FF20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216FF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FF20);
		  /* 8216FF20h */ case    0:  		/* li R5, 36 */
		/* 8216FF20h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 8216FF20h case    0:*/		return 0x8216FF24;
		  /* 8216FF24h */ case    1:  		/* stw R22, <#[R1 + 148]> */
		/* 8216FF24h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000094) );
		/* 8216FF24h case    1:*/		return 0x8216FF28;
		  /* 8216FF28h */ case    2:  		/* li R4, 0 */
		/* 8216FF28h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216FF28h case    2:*/		return 0x8216FF2C;
		  /* 8216FF2Ch */ case    3:  		/* stw R21, <#[R1 + 96]> */
		/* 8216FF2Ch case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000060) );
		/* 8216FF2Ch case    3:*/		return 0x8216FF30;
		  /* 8216FF30h */ case    4:  		/* addi R3, R1, 100 */
		/* 8216FF30h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 8216FF30h case    4:*/		return 0x8216FF34;
		  /* 8216FF34h */ case    5:  		/* bl -912372 */
		/* 8216FF34h case    5:*/		regs.LR = 0x8216FF38; return 0x82091340;
		/* 8216FF34h case    5:*/		return 0x8216FF38;
		  /* 8216FF38h */ case    6:  		/* lwz R11, <#[R18]> */
		/* 8216FF38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8216FF38h case    6:*/		return 0x8216FF3C;
		  /* 8216FF3Ch */ case    7:  		/* stw R21, <#[R1 + 140]> */
		/* 8216FF3Ch case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000008C) );
		/* 8216FF3Ch case    7:*/		return 0x8216FF40;
		  /* 8216FF40h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8216FF40h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8216FF40h case    8:*/		return 0x8216FF44;
		  /* 8216FF44h */ case    9:  		/* stw R20, <#[R1 + 136]> */
		/* 8216FF44h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000088) );
		/* 8216FF44h case    9:*/		return 0x8216FF48;
		  /* 8216FF48h */ case   10:  		/* stw R20, <#[R1 + 144]> */
		/* 8216FF48h case   10:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000090) );
		/* 8216FF48h case   10:*/		return 0x8216FF4C;
		  /* 8216FF4Ch */ case   11:  		/* bc 4, CR0_EQ, 432 */
		/* 8216FF4Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x821700FC;  }
		/* 8216FF4Ch case   11:*/		return 0x8216FF50;
		  /* 8216FF50h */ case   12:  		/* lwz R11, <#[R14]> */
		/* 8216FF50h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 8216FF50h case   12:*/		return 0x8216FF54;
		  /* 8216FF54h */ case   13:  		/* b 412 */
		/* 8216FF54h case   13:*/		return 0x821700F0;
		/* 8216FF54h case   13:*/		return 0x8216FF58;
		  /* 8216FF58h */ case   14:  		/* cmplw CR6, R30, R28 */
		/* 8216FF58h case   14:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 8216FF58h case   14:*/		return 0x8216FF5C;
		  /* 8216FF5Ch */ case   15:  		/* bc 12, CR6_EQ, 388 */
		/* 8216FF5Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x821700E0;  }
		/* 8216FF5Ch case   15:*/		return 0x8216FF60;
		  /* 8216FF60h */ case   16:  		/* cmplw CR6, R30, R26 */
		/* 8216FF60h case   16:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R26);
		/* 8216FF60h case   16:*/		return 0x8216FF64;
		  /* 8216FF64h */ case   17:  		/* bc 12, CR6_EQ, 380 */
		/* 8216FF64h case   17:*/		if ( regs.CR[6].eq ) { return 0x821700E0;  }
		/* 8216FF64h case   17:*/		return 0x8216FF68;
		  /* 8216FF68h */ case   18:  		/* lwz R11, <#[R30 + 20]> */
		/* 8216FF68h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8216FF68h case   18:*/		return 0x8216FF6C;
		  /* 8216FF6Ch */ case   19:  		/* rlwinm R29, R11, 0, 19, 31 */
		/* 8216FF6Ch case   19:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R29,regs.R11);
		/* 8216FF6Ch case   19:*/		return 0x8216FF70;
		  /* 8216FF70h */ case   20:  		/* cmplw CR6, R29, R27 */
		/* 8216FF70h case   20:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R27);
		/* 8216FF70h case   20:*/		return 0x8216FF74;
		  /* 8216FF74h */ case   21:  		/* bc 12, CR6_LT, 324 */
		/* 8216FF74h case   21:*/		if ( regs.CR[6].lt ) { return 0x821700B8;  }
		/* 8216FF74h case   21:*/		return 0x8216FF78;
		  /* 8216FF78h */ case   22:  		/* mr R4, R26 */
		/* 8216FF78h case   22:*/		regs.R4 = regs.R26;
		/* 8216FF78h case   22:*/		return 0x8216FF7C;
		  /* 8216FF7Ch */ case   23:  		/* addi R3, R1, 96 */
		/* 8216FF7Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216FF7Ch case   23:*/		return 0x8216FF80;
		  /* 8216FF80h */ case   24:  		/* bl -3624 */
		/* 8216FF80h case   24:*/		regs.LR = 0x8216FF84; return 0x8216F158;
		/* 8216FF80h case   24:*/		return 0x8216FF84;
		  /* 8216FF84h */ case   25:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FF84h case   25:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FF84h case   25:*/		return 0x8216FF88;
	}
	return 0x8216FF88;
} // Block from 8216FF20h-8216FF88h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216FF88h
// Function '?EnsureInUse@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintTempRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FF88);
		  /* 8216FF88h */ case    0:  		/* bc 12, CR0_EQ, 304 */
		/* 8216FF88h case    0:*/		if ( regs.CR[0].eq ) { return 0x821700B8;  }
		/* 8216FF88h case    0:*/		return 0x8216FF8C;
		  /* 8216FF8Ch */ case    1:  		/* mr R4, R26 */
		/* 8216FF8Ch case    1:*/		regs.R4 = regs.R26;
		/* 8216FF8Ch case    1:*/		return 0x8216FF90;
		  /* 8216FF90h */ case    2:  		/* addi R3, R1, 96 */
		/* 8216FF90h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216FF90h case    2:*/		return 0x8216FF94;
		  /* 8216FF94h */ case    3:  		/* bl -2060 */
		/* 8216FF94h case    3:*/		regs.LR = 0x8216FF98; return 0x8216F788;
		/* 8216FF94h case    3:*/		return 0x8216FF98;
		  /* 8216FF98h */ case    4:  		/* mr R4, R28 */
		/* 8216FF98h case    4:*/		regs.R4 = regs.R28;
		/* 8216FF98h case    4:*/		return 0x8216FF9C;
		  /* 8216FF9Ch */ case    5:  		/* addi R3, R1, 96 */
		/* 8216FF9Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216FF9Ch case    5:*/		return 0x8216FFA0;
		  /* 8216FFA0h */ case    6:  		/* bl -3656 */
		/* 8216FFA0h case    6:*/		regs.LR = 0x8216FFA4; return 0x8216F158;
		/* 8216FFA0h case    6:*/		return 0x8216FFA4;
		  /* 8216FFA4h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FFA4h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FFA4h case    7:*/		return 0x8216FFA8;
		  /* 8216FFA8h */ case    8:  		/* bc 12, CR0_EQ, 88 */
		/* 8216FFA8h case    8:*/		if ( regs.CR[0].eq ) { return 0x82170000;  }
		/* 8216FFA8h case    8:*/		return 0x8216FFAC;
		  /* 8216FFACh */ case    9:  		/* mr R4, R28 */
		/* 8216FFACh case    9:*/		regs.R4 = regs.R28;
		/* 8216FFACh case    9:*/		return 0x8216FFB0;
		  /* 8216FFB0h */ case   10:  		/* addi R3, R1, 96 */
		/* 8216FFB0h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216FFB0h case   10:*/		return 0x8216FFB4;
		  /* 8216FFB4h */ case   11:  		/* bl -2092 */
		/* 8216FFB4h case   11:*/		regs.LR = 0x8216FFB8; return 0x8216F788;
		/* 8216FFB4h case   11:*/		return 0x8216FFB8;
		  /* 8216FFB8h */ case   12:  		/* mr R31, R30 */
		/* 8216FFB8h case   12:*/		regs.R31 = regs.R30;
		/* 8216FFB8h case   12:*/		return 0x8216FFBC;
		  /* 8216FFBCh */ case   13:  		/* mr R4, R31 */
		/* 8216FFBCh case   13:*/		regs.R4 = regs.R31;
		/* 8216FFBCh case   13:*/		return 0x8216FFC0;
		  /* 8216FFC0h */ case   14:  		/* addi R3, R1, 96 */
		/* 8216FFC0h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216FFC0h case   14:*/		return 0x8216FFC4;
		  /* 8216FFC4h */ case   15:  		/* bl -3692 */
		/* 8216FFC4h case   15:*/		regs.LR = 0x8216FFC8; return 0x8216F158;
		/* 8216FFC4h case   15:*/		return 0x8216FFC8;
		  /* 8216FFC8h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216FFC8h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216FFC8h case   16:*/		return 0x8216FFCC;
		  /* 8216FFCCh */ case   17:  		/* bc 12, CR0_EQ, 44 */
		/* 8216FFCCh case   17:*/		if ( regs.CR[0].eq ) { return 0x8216FFF8;  }
		/* 8216FFCCh case   17:*/		return 0x8216FFD0;
		  /* 8216FFD0h */ case   18:  		/* mr R4, R31 */
		/* 8216FFD0h case   18:*/		regs.R4 = regs.R31;
		/* 8216FFD0h case   18:*/		return 0x8216FFD4;
		  /* 8216FFD4h */ case   19:  		/* addi R3, R1, 96 */
		/* 8216FFD4h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8216FFD4h case   19:*/		return 0x8216FFD8;
		  /* 8216FFD8h */ case   20:  		/* bl -2128 */
		/* 8216FFD8h case   20:*/		regs.LR = 0x8216FFDC; return 0x8216F788;
		/* 8216FFD8h case   20:*/		return 0x8216FFDC;
		  /* 8216FFDCh */ case   21:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216FFDCh case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216FFDCh case   21:*/		return 0x8216FFE0;
		  /* 8216FFE0h */ case   22:  		/* lwz R11, <#[R11 + 36]> */
		/* 8216FFE0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8216FFE0h case   22:*/		return 0x8216FFE4;
		  /* 8216FFE4h */ case   23:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216FFE4h case   23:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216FFE4h case   23:*/		return 0x8216FFE8;
	}
	return 0x8216FFE8;
} // Block from 8216FF88h-8216FFE8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8216FFE8h
// Function '?EnsureFree@?$RegisterSet@V?$FixedSizeBitSet@_K$03@D3DXShader@@$1?PrintTempRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FFE8);
		  /* 8216FFE8h */ case    0:  		/* bc 4, CR0_EQ, 708 */
		/* 8216FFE8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x821702AC;  }
		/* 8216FFE8h case    0:*/		return 0x8216FFEC;
		  /* 8216FFECh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216FFECh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216FFECh case    1:*/		return 0x8216FFF0;
		  /* 8216FFF0h */ case    2:  		/* addic. R31, R11, -40 */
		/* 8216FFF0h case    2:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8216FFF0h case    2:*/		return 0x8216FFF4;
		  /* 8216FFF4h */ case    3:  		/* bc 4, CR0_EQ, -56 */
		/* 8216FFF4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216FFBC;  }
		/* 8216FFF4h case    3:*/		return 0x8216FFF8;
	}
	return 0x8216FFF8;
} // Block from 8216FFE8h-8216FFF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216FFF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216FFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216FFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216FFF8);
		  /* 8216FFF8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8216FFF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216FFF8h case    0:*/		return 0x8216FFFC;
		  /* 8216FFFCh */ case    1:  		/* bc 12, CR6_EQ, 688 */
		/* 8216FFFCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821702AC;  }
		/* 8216FFFCh case    1:*/		return 0x82170000;
	}
	return 0x82170000;
} // Block from 8216FFF8h-82170000h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170000);
		  /* 82170000h */ case    0:  		/* lwz R11, <#[R1 + 140]> */
		/* 82170000h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82170000h case    0:*/		return 0x82170004;
		  /* 82170004h */ case    1:  		/* li R5, 36 */
		/* 82170004h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 82170004h case    1:*/		return 0x82170008;
		  /* 82170008h */ case    2:  		/* li R4, 0 */
		/* 82170008h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82170008h case    2:*/		return 0x8217000C;
		  /* 8217000Ch */ case    3:  		/* addi R3, R1, 100 */
		/* 8217000Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 8217000Ch case    3:*/		return 0x82170010;
		  /* 82170010h */ case    4:  		/* mr R31, R11 */
		/* 82170010h case    4:*/		regs.R31 = regs.R11;
		/* 82170010h case    4:*/		return 0x82170014;
		  /* 82170014h */ case    5:  		/* stw R11, <#[R1 + 96]> */
		/* 82170014h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82170014h case    5:*/		return 0x82170018;
		  /* 82170018h */ case    6:  		/* bl -912600 */
		/* 82170018h case    6:*/		regs.LR = 0x8217001C; return 0x82091340;
		/* 82170018h case    6:*/		return 0x8217001C;
		  /* 8217001Ch */ case    7:  		/* stw R31, <#[R1 + 140]> */
		/* 8217001Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000008C) );
		/* 8217001Ch case    7:*/		return 0x82170020;
		  /* 82170020h */ case    8:  		/* cmplwi CR6, R22, 0 */
		/* 82170020h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82170020h case    8:*/		return 0x82170024;
		  /* 82170024h */ case    9:  		/* stw R20, <#[R1 + 136]> */
		/* 82170024h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000088) );
		/* 82170024h case    9:*/		return 0x82170028;
		  /* 82170028h */ case   10:  		/* stw R20, <#[R1 + 144]> */
		/* 82170028h case   10:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000090) );
		/* 82170028h case   10:*/		return 0x8217002C;
		  /* 8217002Ch */ case   11:  		/* bc 12, CR6_EQ, 56 */
		/* 8217002Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82170064;  }
		/* 8217002Ch case   11:*/		return 0x82170030;
		  /* 82170030h */ case   12:  		/* std R20, <#[R22 + 8]> */
		/* 82170030h case   12:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000008) );
		/* 82170030h case   12:*/		return 0x82170034;
		  /* 82170034h */ case   13:  		/* mr R5, R22 */
		/* 82170034h case   13:*/		regs.R5 = regs.R22;
		/* 82170034h case   13:*/		return 0x82170038;
		  /* 82170038h */ case   14:  		/* std R20, <#[R22 + 16]> */
		/* 82170038h case   14:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000010) );
		/* 82170038h case   14:*/		return 0x8217003C;
		  /* 8217003Ch */ case   15:  		/* mr R4, R17 */
		/* 8217003Ch case   15:*/		regs.R4 = regs.R17;
		/* 8217003Ch case   15:*/		return 0x82170040;
		  /* 82170040h */ case   16:  		/* std R20, <#[R22 + 24]> */
		/* 82170040h case   16:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000018) );
		/* 82170040h case   16:*/		return 0x82170044;
		  /* 82170044h */ case   17:  		/* mr R3, R21 */
		/* 82170044h case   17:*/		regs.R3 = regs.R21;
		/* 82170044h case   17:*/		return 0x82170048;
		  /* 82170048h */ case   18:  		/* std R20, <#[R22 + 32]> */
		/* 82170048h case   18:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000020) );
		/* 82170048h case   18:*/		return 0x8217004C;
		  /* 8217004Ch */ case   19:  		/* std R20, <#[R22 + 40]> */
		/* 8217004Ch case   19:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000028) );
		/* 8217004Ch case   19:*/		return 0x82170050;
		  /* 82170050h */ case   20:  		/* std R20, <#[R22 + 48]> */
		/* 82170050h case   20:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000030) );
		/* 82170050h case   20:*/		return 0x82170054;
		  /* 82170054h */ case   21:  		/* std R20, <#[R22 + 56]> */
		/* 82170054h case   21:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000038) );
		/* 82170054h case   21:*/		return 0x82170058;
		  /* 82170058h */ case   22:  		/* std R20, <#[R22 + 64]> */
		/* 82170058h case   22:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000040) );
		/* 82170058h case   22:*/		return 0x8217005C;
		  /* 8217005Ch */ case   23:  		/* stw R20, <#[R22 + 72]> */
		/* 8217005Ch case   23:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R22 + 0x00000048) );
		/* 8217005Ch case   23:*/		return 0x82170060;
		  /* 82170060h */ case   24:  		/* bl -2024 */
		/* 82170060h case   24:*/		regs.LR = 0x82170064; return 0x8216F878;
		/* 82170060h case   24:*/		return 0x82170064;
	}
	return 0x82170064;
} // Block from 82170000h-82170064h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82170064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170064);
		  /* 82170064h */ case    0:  		/* lwz R11, <#[R18]> */
		/* 82170064h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82170064h case    0:*/		return 0x82170068;
		  /* 82170068h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82170068h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82170068h case    1:*/		return 0x8217006C;
		  /* 8217006Ch */ case    2:  		/* bc 4, CR0_EQ, 76 */
		/* 8217006Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x821700B8;  }
		/* 8217006Ch case    2:*/		return 0x82170070;
	}
	return 0x82170070;
} // Block from 82170064h-82170070h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170070h
// Function '?SimulateBackwards@FinalSchedulingSimulator@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170070);
		  /* 82170070h */ case    0:  		/* lwz R11, <#[R14]> */
		/* 82170070h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 82170070h case    0:*/		return 0x82170074;
		  /* 82170074h */ case    1:  		/* b 56 */
		/* 82170074h case    1:*/		return 0x821700AC;
		/* 82170074h case    1:*/		return 0x82170078;
		  /* 82170078h */ case    2:  		/* cmplw CR6, R31, R30 */
		/* 82170078h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82170078h case    2:*/		return 0x8217007C;
		  /* 8217007Ch */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 8217007Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821700B8;  }
		/* 8217007Ch case    3:*/		return 0x82170080;
		  /* 82170080h */ case    4:  		/* cmplw CR6, R31, R28 */
		/* 82170080h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 82170080h case    4:*/		return 0x82170084;
		  /* 82170084h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 82170084h case    5:*/		if ( regs.CR[6].eq ) { return 0x8217009C;  }
		/* 82170084h case    5:*/		return 0x82170088;
		  /* 82170088h */ case    6:  		/* cmplw CR6, R31, R26 */
		/* 82170088h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 82170088h case    6:*/		return 0x8217008C;
		  /* 8217008Ch */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8217008Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8217009C;  }
		/* 8217008Ch case    7:*/		return 0x82170090;
		  /* 82170090h */ case    8:  		/* mr R4, R31 */
		/* 82170090h case    8:*/		regs.R4 = regs.R31;
		/* 82170090h case    8:*/		return 0x82170094;
		  /* 82170094h */ case    9:  		/* addi R3, R1, 96 */
		/* 82170094h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82170094h case    9:*/		return 0x82170098;
		  /* 82170098h */ case   10:  		/* bl -2320 */
		/* 82170098h case   10:*/		regs.LR = 0x8217009C; return 0x8216F788;
		/* 82170098h case   10:*/		return 0x8217009C;
	}
	return 0x8217009C;
} // Block from 82170070h-8217009Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8217009Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217009C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217009C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217009C);
		  /* 8217009Ch */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8217009Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8217009Ch case    0:*/		return 0x821700A0;
		  /* 821700A0h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 821700A0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821700A0h case    1:*/		return 0x821700A4;
		  /* 821700A4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821700A4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821700A4h case    2:*/		return 0x821700A8;
		  /* 821700A8h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821700A8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821700B8;  }
		/* 821700A8h case    3:*/		return 0x821700AC;
	}
	return 0x821700AC;
} // Block from 8217009Ch-821700ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821700ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821700AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821700AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821700AC);
		  /* 821700ACh */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821700ACh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821700ACh case    0:*/		return 0x821700B0;
		  /* 821700B0h */ case    1:  		/* addic. R31, R11, -40 */
		/* 821700B0h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821700B0h case    1:*/		return 0x821700B4;
		  /* 821700B4h */ case    2:  		/* bc 4, CR0_EQ, -60 */
		/* 821700B4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82170078;  }
		/* 821700B4h case    2:*/		return 0x821700B8;
	}
	return 0x821700B8;
} // Block from 821700ACh-821700B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821700B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821700B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821700B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821700B8);
		  /* 821700B8h */ case    0:  		/* cmplw CR6, R29, R25 */
		/* 821700B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 821700B8h case    0:*/		return 0x821700BC;
		  /* 821700BCh */ case    1:  		/* bc 4, CR6_LT, 72 */
		/* 821700BCh case    1:*/		if ( !regs.CR[6].lt ) { return 0x82170104;  }
		/* 821700BCh case    1:*/		return 0x821700C0;
		  /* 821700C0h */ case    2:  		/* mr R4, R30 */
		/* 821700C0h case    2:*/		regs.R4 = regs.R30;
		/* 821700C0h case    2:*/		return 0x821700C4;
		  /* 821700C4h */ case    3:  		/* addi R3, R1, 96 */
		/* 821700C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821700C4h case    3:*/		return 0x821700C8;
		  /* 821700C8h */ case    4:  		/* bl -3952 */
		/* 821700C8h case    4:*/		regs.LR = 0x821700CC; return 0x8216F158;
		/* 821700C8h case    4:*/		return 0x821700CC;
		  /* 821700CCh */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821700CCh case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821700CCh case    5:*/		return 0x821700D0;
		  /* 821700D0h */ case    6:  		/* bc 12, CR0_EQ, 52 */
		/* 821700D0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82170104;  }
		/* 821700D0h case    6:*/		return 0x821700D4;
		  /* 821700D4h */ case    7:  		/* mr R4, R30 */
		/* 821700D4h case    7:*/		regs.R4 = regs.R30;
		/* 821700D4h case    7:*/		return 0x821700D8;
		  /* 821700D8h */ case    8:  		/* addi R3, R1, 96 */
		/* 821700D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821700D8h case    8:*/		return 0x821700DC;
		  /* 821700DCh */ case    9:  		/* bl -2388 */
		/* 821700DCh case    9:*/		regs.LR = 0x821700E0; return 0x8216F788;
		/* 821700DCh case    9:*/		return 0x821700E0;
	}
	return 0x821700E0;
} // Block from 821700B8h-821700E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821700E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821700E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821700E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821700E0);
		  /* 821700E0h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821700E0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821700E0h case    0:*/		return 0x821700E4;
		  /* 821700E4h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 821700E4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821700E4h case    1:*/		return 0x821700E8;
		  /* 821700E8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821700E8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821700E8h case    2:*/		return 0x821700EC;
		  /* 821700ECh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821700ECh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821700FC;  }
		/* 821700ECh case    3:*/		return 0x821700F0;
	}
	return 0x821700F0;
} // Block from 821700E0h-821700F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821700F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821700F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821700F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821700F0);
		  /* 821700F0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821700F0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821700F0h case    0:*/		return 0x821700F4;
		  /* 821700F4h */ case    1:  		/* addic. R30, R11, -40 */
		/* 821700F4h case    1:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 821700F4h case    1:*/		return 0x821700F8;
		  /* 821700F8h */ case    2:  		/* bc 4, CR0_EQ, -416 */
		/* 821700F8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216FF58;  }
		/* 821700F8h case    2:*/		return 0x821700FC;
	}
	return 0x821700FC;
} // Block from 821700F0h-821700FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821700FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821700FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821700FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821700FC);
		  /* 821700FCh */ case    0:  		/* cmplwi CR6, R25, 8191 */
		/* 821700FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00001FFF);
		/* 821700FCh case    0:*/		return 0x82170100;
		  /* 82170100h */ case    1:  		/* bc 12, CR6_EQ, 520 */
		/* 82170100h case    1:*/		if ( regs.CR[6].eq ) { return 0x82170308;  }
		/* 82170100h case    1:*/		return 0x82170104;
	}
	return 0x82170104;
} // Block from 821700FCh-82170104h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170104);
		  /* 82170104h */ case    0:  		/* addi R24, R24, 12 */
		/* 82170104h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xC);
		/* 82170104h case    0:*/		return 0x82170108;
	}
	return 0x82170108;
} // Block from 82170104h-82170108h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170108);
		  /* 82170108h */ case    0:  		/* cmplw CR6, R24, R23 */
		/* 82170108h case    0:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R23);
		/* 82170108h case    0:*/		return 0x8217010C;
		  /* 8217010Ch */ case    1:  		/* bc 12, CR6_LT, -896 */
		/* 8217010Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8216FD8C;  }
		/* 8217010Ch case    1:*/		return 0x82170110;
		  /* 82170110h */ case    2:  		/* lbz R11, <#[R1 + 407]> */
		/* 82170110h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000197) );
		/* 82170110h case    2:*/		return 0x82170114;
		  /* 82170114h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82170114h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82170114h case    3:*/		return 0x82170118;
		  /* 82170118h */ case    4:  		/* bc 12, CR0_EQ, 392 */
		/* 82170118h case    4:*/		if ( regs.CR[0].eq ) { return 0x821702A0;  }
		/* 82170118h case    4:*/		return 0x8217011C;
		  /* 8217011Ch */ case    5:  		/* lwz R11, <#[R17 + 76]> */
		/* 8217011Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 8217011Ch case    5:*/		return 0x82170120;
		  /* 82170120h */ case    6:  		/* rlwinm. R11, R11, 0, 13, 31 */
		/* 82170120h case    6:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R11,regs.R11);
		/* 82170120h case    6:*/		return 0x82170124;
		  /* 82170124h */ case    7:  		/* bc 4, CR0_EQ, 380 */
		/* 82170124h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821702A0;  }
		/* 82170124h case    7:*/		return 0x82170128;
		  /* 82170128h */ case    8:  		/* lwz R10, <#[R19 + 8]> */
		/* 82170128h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000008) );
		/* 82170128h case    8:*/		return 0x8217012C;
		  /* 8217012Ch */ case    9:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 8217012Ch case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 8217012Ch case    9:*/		return 0x82170130;
		  /* 82170130h */ case   10:  		/* cmplwi CR6, R11, 1 */
		/* 82170130h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82170130h case   10:*/		return 0x82170134;
		  /* 82170134h */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 82170134h case   11:*/		if ( regs.CR[6].lt ) { return 0x82170144;  }
		/* 82170134h case   11:*/		return 0x82170138;
		  /* 82170138h */ case   12:  		/* cmplwi CR6, R11, 31 */
		/* 82170138h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82170138h case   12:*/		return 0x8217013C;
		  /* 8217013Ch */ case   13:  		/* li R11, 1 */
		/* 8217013Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8217013Ch case   13:*/		return 0x82170140;
		  /* 82170140h */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 82170140h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82170148;  }
		/* 82170140h case   14:*/		return 0x82170144;
	}
	return 0x82170144;
} // Block from 82170108h-82170144h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82170144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170144);
		  /* 82170144h */ case    0:  		/* mr R11, R20 */
		/* 82170144h case    0:*/		regs.R11 = regs.R20;
		/* 82170144h case    0:*/		return 0x82170148;
	}
	return 0x82170148;
} // Block from 82170144h-82170148h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170148);
		  /* 82170148h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82170148h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82170148h case    0:*/		return 0x8217014C;
		  /* 8217014Ch */ case    1:  		/* bc 12, CR0_EQ, 340 */
		/* 8217014Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821702A0;  }
		/* 8217014Ch case    1:*/		return 0x82170150;
		  /* 82170150h */ case    2:  		/* rlwinm R11, R10, 0, 15, 17 */
		/* 82170150h case    2:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R10);
		/* 82170150h case    2:*/		return 0x82170154;
		  /* 82170154h */ case    3:  		/* cmplwi CR6, R11, 16384 */
		/* 82170154h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 82170154h case    3:*/		return 0x82170158;
		  /* 82170158h */ case    4:  		/* bc 4, CR6_EQ, 328 */
		/* 82170158h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821702A0;  }
		/* 82170158h case    4:*/		return 0x8217015C;
		  /* 8217015Ch */ case    5:  		/* rlwinm. R11, R10, 7, 31, 31 */
		/* 8217015Ch case    5:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R10);
		/* 8217015Ch case    5:*/		return 0x82170160;
	}
	return 0x82170160;
} // Block from 82170148h-82170160h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82170160h
// Function '?ReserveBlockOutputRegisters@Compiler@D3DXShader@@AAAXPAVBlock@2@PAV?$_SpecialRegisterSet@VGeneralRegisterSet@D3DXShader@@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170160);
		  /* 82170160h */ case    0:  		/* bc 4, CR0_EQ, 320 */
		/* 82170160h case    0:*/		if ( !regs.CR[0].eq ) { return 0x821702A0;  }
		/* 82170160h case    0:*/		return 0x82170164;
		  /* 82170164h */ case    1:  		/* mr R3, R19 */
		/* 82170164h case    1:*/		regs.R3 = regs.R19;
		/* 82170164h case    1:*/		return 0x82170168;
		  /* 82170168h */ case    2:  		/* bl 134248 */
		/* 82170168h case    2:*/		regs.LR = 0x8217016C; return 0x82190DD0;
		/* 82170168h case    2:*/		return 0x8217016C;
		  /* 8217016Ch */ case    3:  		/* cmplwi CR6, R3, 1 */
		/* 8217016Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8217016Ch case    3:*/		return 0x82170170;
		  /* 82170170h */ case    4:  		/* bc 4, CR6_EQ, 304 */
		/* 82170170h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821702A0;  }
		/* 82170170h case    4:*/		return 0x82170174;
		  /* 82170174h */ case    5:  		/* addi R11, R1, 52 */
		/* 82170174h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x34);
		/* 82170174h case    5:*/		return 0x82170178;
		  /* 82170178h */ case    6:  		/* addi R10, R1, 92 */
		/* 82170178h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 82170178h case    6:*/		return 0x8217017C;
		  /* 8217017Ch */ case    7:  		/* ori R10, R10, 1 */
		/* 8217017Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8217017Ch case    7:*/		return 0x82170180;
		  /* 82170180h */ case    8:  		/* ori R11, R11, 1 */
		/* 82170180h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82170180h case    8:*/		return 0x82170184;
		  /* 82170184h */ case    9:  		/* stw R10, <#[R1 + 88]> */
		/* 82170184h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82170184h case    9:*/		return 0x82170188;
		  /* 82170188h */ case   10:  		/* addi R5, R1, 88 */
		/* 82170188h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 82170188h case   10:*/		return 0x8217018C;
		  /* 8217018Ch */ case   11:  		/* stw R11, <#[R1 + 92]> */
		/* 8217018Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8217018Ch case   11:*/		return 0x82170190;
		  /* 82170190h */ case   12:  		/* mr R4, R19 */
		/* 82170190h case   12:*/		regs.R4 = regs.R19;
		/* 82170190h case   12:*/		return 0x82170194;
		  /* 82170194h */ case   13:  		/* mr R3, R21 */
		/* 82170194h case   13:*/		regs.R3 = regs.R21;
		/* 82170194h case   13:*/		return 0x82170198;
		  /* 82170198h */ case   14:  		/* bl 146168 */
		/* 82170198h case   14:*/		regs.LR = 0x8217019C; return 0x82193C90;
		/* 82170198h case   14:*/		return 0x8217019C;
		  /* 8217019Ch */ case   15:  		/* lwz R11, <#[R1 + 92]> */
		/* 8217019Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8217019Ch case   15:*/		return 0x821701A0;
		  /* 821701A0h */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821701A0h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821701A0h case   16:*/		return 0x821701A4;
		  /* 821701A4h */ case   17:  		/* bc 4, CR0_EQ, 252 */
		/* 821701A4h case   17:*/		if ( !regs.CR[0].eq ) { return 0x821702A0;  }
		/* 821701A4h case   17:*/		return 0x821701A8;
		  /* 821701A8h */ case   18:  		/* lwz R11, <#[R1 + 88]> */
		/* 821701A8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821701A8h case   18:*/		return 0x821701AC;
		  /* 821701ACh */ case   19:  		/* cmplwi CR6, R22, 0 */
		/* 821701ACh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821701ACh case   19:*/		return 0x821701B0;
		  /* 821701B0h */ case   20:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821701B0h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821701B0h case   20:*/		return 0x821701B4;
		  /* 821701B4h */ case   21:  		/* addi R30, R11, -40 */
		/* 821701B4h case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 821701B4h case   21:*/		return 0x821701B8;
		  /* 821701B8h */ case   22:  		/* bc 12, CR6_EQ, 56 */
		/* 821701B8h case   22:*/		if ( regs.CR[6].eq ) { return 0x821701F0;  }
		/* 821701B8h case   22:*/		return 0x821701BC;
		  /* 821701BCh */ case   23:  		/* std R20, <#[R22 + 8]> */
		/* 821701BCh case   23:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000008) );
		/* 821701BCh case   23:*/		return 0x821701C0;
		  /* 821701C0h */ case   24:  		/* mr R5, R22 */
		/* 821701C0h case   24:*/		regs.R5 = regs.R22;
		/* 821701C0h case   24:*/		return 0x821701C4;
		  /* 821701C4h */ case   25:  		/* std R20, <#[R22 + 16]> */
		/* 821701C4h case   25:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000010) );
		/* 821701C4h case   25:*/		return 0x821701C8;
		  /* 821701C8h */ case   26:  		/* mr R4, R17 */
		/* 821701C8h case   26:*/		regs.R4 = regs.R17;
		/* 821701C8h case   26:*/		return 0x821701CC;
		  /* 821701CCh */ case   27:  		/* std R20, <#[R22 + 24]> */
		/* 821701CCh case   27:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000018) );
		/* 821701CCh case   27:*/		return 0x821701D0;
		  /* 821701D0h */ case   28:  		/* mr R3, R21 */
		/* 821701D0h case   28:*/		regs.R3 = regs.R21;
		/* 821701D0h case   28:*/		return 0x821701D4;
		  /* 821701D4h */ case   29:  		/* std R20, <#[R22 + 32]> */
		/* 821701D4h case   29:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000020) );
		/* 821701D4h case   29:*/		return 0x821701D8;
		  /* 821701D8h */ case   30:  		/* std R20, <#[R22 + 40]> */
		/* 821701D8h case   30:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000028) );
		/* 821701D8h case   30:*/		return 0x821701DC;
		  /* 821701DCh */ case   31:  		/* std R20, <#[R22 + 48]> */
		/* 821701DCh case   31:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000030) );
		/* 821701DCh case   31:*/		return 0x821701E0;
		  /* 821701E0h */ case   32:  		/* std R20, <#[R22 + 56]> */
		/* 821701E0h case   32:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000038) );
		/* 821701E0h case   32:*/		return 0x821701E4;
		  /* 821701E4h */ case   33:  		/* std R20, <#[R22 + 64]> */
		/* 821701E4h case   33:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R22 + 0x00000040) );
		/* 821701E4h case   33:*/		return 0x821701E8;
		  /* 821701E8h */ case   34:  		/* stw R20, <#[R22 + 72]> */
		/* 821701E8h case   34:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R22 + 0x00000048) );
		/* 821701E8h case   34:*/		return 0x821701EC;
		  /* 821701ECh */ case   35:  		/* bl -2420 */
		/* 821701ECh case   35:*/		regs.LR = 0x821701F0; return 0x8216F878;
		/* 821701ECh case   35:*/		return 0x821701F0;
	}
	return 0x821701F0;
} // Block from 82170160h-821701F0h (36 instructions)

//////////////////////////////////////////////////////
// Block at 821701F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821701F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821701F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821701F0);
		  /* 821701F0h */ case    0:  		/* li R5, 36 */
		/* 821701F0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 821701F0h case    0:*/		return 0x821701F4;
		  /* 821701F4h */ case    1:  		/* stw R22, <#[R1 + 212]> */
		/* 821701F4h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x000000D4) );
		/* 821701F4h case    1:*/		return 0x821701F8;
		  /* 821701F8h */ case    2:  		/* li R4, 0 */
		/* 821701F8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821701F8h case    2:*/		return 0x821701FC;
		  /* 821701FCh */ case    3:  		/* stw R21, <#[R1 + 160]> */
		/* 821701FCh case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x000000A0) );
		/* 821701FCh case    3:*/		return 0x82170200;
		  /* 82170200h */ case    4:  		/* addi R3, R1, 164 */
		/* 82170200h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA4);
		/* 82170200h case    4:*/		return 0x82170204;
		  /* 82170204h */ case    5:  		/* bl -913092 */
		/* 82170204h case    5:*/		regs.LR = 0x82170208; return 0x82091340;
		/* 82170204h case    5:*/		return 0x82170208;
		  /* 82170208h */ case    6:  		/* lwz R11, <#[R18]> */
		/* 82170208h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82170208h case    6:*/		return 0x8217020C;
		  /* 8217020Ch */ case    7:  		/* stw R21, <#[R1 + 204]> */
		/* 8217020Ch case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x000000CC) );
		/* 8217020Ch case    7:*/		return 0x82170210;
		  /* 82170210h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82170210h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82170210h case    8:*/		return 0x82170214;
		  /* 82170214h */ case    9:  		/* stw R20, <#[R1 + 200]> */
		/* 82170214h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x000000C8) );
		/* 82170214h case    9:*/		return 0x82170218;
		  /* 82170218h */ case   10:  		/* stw R20, <#[R1 + 208]> */
		/* 82170218h case   10:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x000000D0) );
		/* 82170218h case   10:*/		return 0x8217021C;
		  /* 8217021Ch */ case   11:  		/* bc 4, CR0_EQ, 468 */
		/* 8217021Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x821703F0;  }
		/* 8217021Ch case   11:*/		return 0x82170220;
		  /* 82170220h */ case   12:  		/* lwz R11, <#[R14]> */
		/* 82170220h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 82170220h case   12:*/		return 0x82170224;
		  /* 82170224h */ case   13:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82170224h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82170224h case   13:*/		return 0x82170228;
		  /* 82170228h */ case   14:  		/* addic. R31, R11, -40 */
		/* 82170228h case   14:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82170228h case   14:*/		return 0x8217022C;
		  /* 8217022Ch */ case   15:  		/* bc 12, CR0_EQ, 452 */
		/* 8217022Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x821703F0;  }
		/* 8217022Ch case   15:*/		return 0x82170230;
		  /* 82170230h */ case   16:  		/* cmplw CR6, R31, R19 */
		/* 82170230h case   16:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R19);
		/* 82170230h case   16:*/		return 0x82170234;
		  /* 82170234h */ case   17:  		/* addi R3, R1, 160 */
		/* 82170234h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82170234h case   17:*/		return 0x82170238;
		  /* 82170238h */ case   18:  		/* bc 4, CR6_EQ, 28 */
		/* 82170238h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82170254;  }
		/* 82170238h case   18:*/		return 0x8217023C;
		  /* 8217023Ch */ case   19:  		/* mr R4, R30 */
		/* 8217023Ch case   19:*/		regs.R4 = regs.R30;
		/* 8217023Ch case   19:*/		return 0x82170240;
		  /* 82170240h */ case   20:  		/* bl -4328 */
		/* 82170240h case   20:*/		regs.LR = 0x82170244; return 0x8216F158;
		/* 82170240h case   20:*/		return 0x82170244;
		  /* 82170244h */ case   21:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82170244h case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82170244h case   21:*/		return 0x82170248;
		  /* 82170248h */ case   22:  		/* bc 12, CR0_EQ, 68 */
		/* 82170248h case   22:*/		if ( regs.CR[0].eq ) { return 0x8217028C;  }
		/* 82170248h case   22:*/		return 0x8217024C;
		  /* 8217024Ch */ case   23:  		/* mr R4, R30 */
		/* 8217024Ch case   23:*/		regs.R4 = regs.R30;
		/* 8217024Ch case   23:*/		return 0x82170250;
		  /* 82170250h */ case   24:  		/* b 24 */
		/* 82170250h case   24:*/		return 0x82170268;
		/* 82170250h case   24:*/		return 0x82170254;
	}
	return 0x82170254;
} // Block from 821701F0h-82170254h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82170254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170254);
		  /* 82170254h */ case    0:  		/* mr R4, R31 */
		/* 82170254h case    0:*/		regs.R4 = regs.R31;
		/* 82170254h case    0:*/		return 0x82170258;
		  /* 82170258h */ case    1:  		/* bl -4352 */
		/* 82170258h case    1:*/		regs.LR = 0x8217025C; return 0x8216F158;
		/* 82170258h case    1:*/		return 0x8217025C;
		  /* 8217025Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8217025Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8217025Ch case    2:*/		return 0x82170260;
		  /* 82170260h */ case    3:  		/* bc 12, CR0_EQ, 44 */
		/* 82170260h case    3:*/		if ( regs.CR[0].eq ) { return 0x8217028C;  }
		/* 82170260h case    3:*/		return 0x82170264;
		  /* 82170264h */ case    4:  		/* mr R4, R31 */
		/* 82170264h case    4:*/		regs.R4 = regs.R31;
		/* 82170264h case    4:*/		return 0x82170268;
	}
	return 0x82170268;
} // Block from 82170254h-82170268h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82170268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170268);
		  /* 82170268h */ case    0:  		/* addi R3, R1, 160 */
		/* 82170268h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82170268h case    0:*/		return 0x8217026C;
		  /* 8217026Ch */ case    1:  		/* bl -2788 */
		/* 8217026Ch case    1:*/		regs.LR = 0x82170270; return 0x8216F788;
		/* 8217026Ch case    1:*/		return 0x82170270;
		  /* 82170270h */ case    2:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82170270h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82170270h case    2:*/		return 0x82170274;
		  /* 82170274h */ case    3:  		/* lwz R11, <#[R11 + 36]> */
		/* 82170274h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82170274h case    3:*/		return 0x82170278;
		  /* 82170278h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170278h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170278h case    4:*/		return 0x8217027C;
		  /* 8217027Ch */ case    5:  		/* bc 4, CR0_EQ, 372 */
		/* 8217027Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821703F0;  }
		/* 8217027Ch case    5:*/		return 0x82170280;
		  /* 82170280h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82170280h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82170280h case    6:*/		return 0x82170284;
		  /* 82170284h */ case    7:  		/* addic. R31, R11, -40 */
		/* 82170284h case    7:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82170284h case    7:*/		return 0x82170288;
	}
	return 0x82170288;
} // Block from 82170268h-82170288h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82170288h
// Function '?CoissueInBlock@Compiler@D3DXShader@@AAAXPAVBlock@2@_NPAV?$_SpecialRegisterSet@VGeneralRegisterSet@D3DXShader@@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170288);
		  /* 82170288h */ case    0:  		/* bc 4, CR0_EQ, -88 */
		/* 82170288h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82170230;  }
		/* 82170288h case    0:*/		return 0x8217028C;
	}
	return 0x8217028C;
} // Block from 82170288h-8217028Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8217028Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217028C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217028C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217028C);
		  /* 8217028Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8217028Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8217028Ch case    0:*/		return 0x82170290;
		  /* 82170290h */ case    1:  		/* bc 12, CR6_EQ, 352 */
		/* 82170290h case    1:*/		if ( regs.CR[6].eq ) { return 0x821703F0;  }
		/* 82170290h case    1:*/		return 0x82170294;
		  /* 82170294h */ case    2:  		/* addi R4, R1, 88 */
		/* 82170294h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82170294h case    2:*/		return 0x82170298;
		  /* 82170298h */ case    3:  		/* mr R3, R21 */
		/* 82170298h case    3:*/		regs.R3 = regs.R21;
		/* 82170298h case    3:*/		return 0x8217029C;
		  /* 8217029Ch */ case    4:  		/* bl 136804 */
		/* 8217029Ch case    4:*/		regs.LR = 0x821702A0; return 0x82191900;
		/* 8217029Ch case    4:*/		return 0x821702A0;
	}
	return 0x821702A0;
} // Block from 8217028Ch-821702A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821702A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821702A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821702A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821702A0);
		  /* 821702A0h */ case    0:  		/* rlwinm R11, R19, 0, 0, 30 */
		/* 821702A0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R19);
		/* 821702A0h case    0:*/		return 0x821702A4;
		  /* 821702A4h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821702A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821702A4h case    1:*/		return 0x821702A8;
		  /* 821702A8h */ case    2:  		/* b -2200 */
		/* 821702A8h case    2:*/		return 0x8216FA10;
		/* 821702A8h case    2:*/		return 0x821702AC;
	}
	return 0x821702AC;
} // Block from 821702A0h-821702ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821702ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821702AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821702AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821702AC);
		  /* 821702ACh */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821702ACh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821702ACh case    0:*/		return 0x821702B0;
		  /* 821702B0h */ case    1:  		/* rlwinm R10, R30, 0, 0, 30 */
		/* 821702B0h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R30);
		/* 821702B0h case    1:*/		return 0x821702B4;
		  /* 821702B4h */ case    2:  		/* addi R11, R11, 36 */
		/* 821702B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821702B4h case    2:*/		return 0x821702B8;
		  /* 821702B8h */ case    3:  		/* addi R10, R10, 36 */
		/* 821702B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821702B8h case    3:*/		return 0x821702BC;
		  /* 821702BCh */ case    4:  		/* addi R9, R11, 4 */
		/* 821702BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821702BCh case    4:*/		return 0x821702C0;
		  /* 821702C0h */ case    5:  		/* addi R8, R10, 4 */
		/* 821702C0h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 821702C0h case    5:*/		return 0x821702C4;
		  /* 821702C4h */ case    6:  		/* addi R7, R11, -36 */
		/* 821702C4h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821702C4h case    6:*/		return 0x821702C8;
		  /* 821702C8h */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 821702C8h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821702C8h case    7:*/		return 0x821702CC;
		  /* 821702CCh */ case    8:  		/* lwz R5, <#[R11]> */
		/* 821702CCh case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 821702CCh case    8:*/		return 0x821702D0;
		  /* 821702D0h */ case    9:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821702D0h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821702D0h case    9:*/		return 0x821702D4;
		  /* 821702D4h */ case   10:  		/* stw R5, <#[R6 + 36]> */
		/* 821702D4h case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x00000024) );
		/* 821702D4h case   10:*/		return 0x821702D8;
		  /* 821702D8h */ case   11:  		/* lwz R6, <#[R11 + 4]> */
		/* 821702D8h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821702D8h case   11:*/		return 0x821702DC;
		  /* 821702DCh */ case   12:  		/* lwz R5, <#[R11]> */
		/* 821702DCh case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 821702DCh case   12:*/		return 0x821702E0;
		  /* 821702E0h */ case   13:  		/* rlwinm R5, R5, 0, 0, 30 */
		/* 821702E0h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R5,regs.R5);
		/* 821702E0h case   13:*/		return 0x821702E4;
		  /* 821702E4h */ case   14:  		/* stw R6, <#[R5]> */
		/* 821702E4h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + 0x00000000) );
		/* 821702E4h case   14:*/		return 0x821702E8;
		  /* 821702E8h */ case   15:  		/* lwz R6, <#[R10 + 4]> */
		/* 821702E8h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821702E8h case   15:*/		return 0x821702EC;
		  /* 821702ECh */ case   16:  		/* stw R6, <#[R11 + 4]> */
		/* 821702ECh case   16:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821702ECh case   16:*/		return 0x821702F0;
		  /* 821702F0h */ case   17:  		/* lwz R6, <#[R10 + 4]> */
		/* 821702F0h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821702F0h case   17:*/		return 0x821702F4;
		  /* 821702F4h */ case   18:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821702F4h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821702F4h case   18:*/		return 0x821702F8;
		  /* 821702F8h */ case   19:  		/* stw R9, <#[R6 + 36]> */
		/* 821702F8h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 821702F8h case   19:*/		return 0x821702FC;
		  /* 821702FCh */ case   20:  		/* stw R8, <#[R11]> */
		/* 821702FCh case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821702FCh case   20:*/		return 0x82170300;
		  /* 82170300h */ case   21:  		/* stw R7, <#[R10 + 4]> */
		/* 82170300h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82170300h case   21:*/		return 0x82170304;
		  /* 82170304h */ case   22:  		/* b 84 */
		/* 82170304h case   22:*/		return 0x82170358;
		/* 82170304h case   22:*/		return 0x82170308;
	}
	return 0x82170308;
} // Block from 821702ACh-82170308h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82170308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170308);
		  /* 82170308h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82170308h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82170308h case    0:*/		return 0x8217030C;
		  /* 8217030Ch */ case    1:  		/* ori R9, R18, 1 */
		/* 8217030Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R18,0x1);
		/* 8217030Ch case    1:*/		return 0x82170310;
		  /* 82170310h */ case    2:  		/* addi R11, R11, 36 */
		/* 82170310h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82170310h case    2:*/		return 0x82170314;
		  /* 82170314h */ case    3:  		/* addi R10, R11, 4 */
		/* 82170314h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82170314h case    3:*/		return 0x82170318;
		  /* 82170318h */ case    4:  		/* addi R8, R11, -36 */
		/* 82170318h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82170318h case    4:*/		return 0x8217031C;
		  /* 8217031Ch */ case    5:  		/* lwz R7, <#[R11 + 4]> */
		/* 8217031Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8217031Ch case    5:*/		return 0x82170320;
		  /* 82170320h */ case    6:  		/* lwz R6, <#[R11]> */
		/* 82170320h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82170320h case    6:*/		return 0x82170324;
		  /* 82170324h */ case    7:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82170324h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82170324h case    7:*/		return 0x82170328;
		  /* 82170328h */ case    8:  		/* stw R6, <#[R7 + 36]> */
		/* 82170328h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000024) );
		/* 82170328h case    8:*/		return 0x8217032C;
		  /* 8217032Ch */ case    9:  		/* lwz R7, <#[R11 + 4]> */
		/* 8217032Ch case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8217032Ch case    9:*/		return 0x82170330;
		  /* 82170330h */ case   10:  		/* lwz R6, <#[R11]> */
		/* 82170330h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82170330h case   10:*/		return 0x82170334;
		  /* 82170334h */ case   11:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82170334h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82170334h case   11:*/		return 0x82170338;
		  /* 82170338h */ case   12:  		/* stw R7, <#[R6]> */
		/* 82170338h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 82170338h case   12:*/		return 0x8217033C;
		  /* 8217033Ch */ case   13:  		/* lwz R7, <#[R18]> */
		/* 8217033Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R18 + 0x00000000) );
		/* 8217033Ch case   13:*/		return 0x82170340;
		  /* 82170340h */ case   14:  		/* stw R7, <#[R11 + 4]> */
		/* 82170340h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82170340h case   14:*/		return 0x82170344;
		  /* 82170344h */ case   15:  		/* lwz R7, <#[R18]> */
		/* 82170344h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R18 + 0x00000000) );
		/* 82170344h case   15:*/		return 0x82170348;
		  /* 82170348h */ case   16:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82170348h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82170348h case   16:*/		return 0x8217034C;
		  /* 8217034Ch */ case   17:  		/* stw R10, <#[R7 + 36]> */
		/* 8217034Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000024) );
		/* 8217034Ch case   17:*/		return 0x82170350;
		  /* 82170350h */ case   18:  		/* stw R9, <#[R11]> */
		/* 82170350h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82170350h case   18:*/		return 0x82170354;
		  /* 82170354h */ case   19:  		/* stw R8, <#[R18]> */
		/* 82170354h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R18 + 0x00000000) );
		/* 82170354h case   19:*/		return 0x82170358;
	}
	return 0x82170358;
} // Block from 82170308h-82170358h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82170358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170358);
		  /* 82170358h */ case    0:  		/* rlwinm R10, R26, 0, 0, 30 */
		/* 82170358h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R26);
		/* 82170358h case    0:*/		return 0x8217035C;
		  /* 8217035Ch */ case    1:  		/* addi R9, R11, 4 */
		/* 8217035Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8217035Ch case    1:*/		return 0x82170360;
		  /* 82170360h */ case    2:  		/* addi R10, R10, 36 */
		/* 82170360h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82170360h case    2:*/		return 0x82170364;
		  /* 82170364h */ case    3:  		/* cmplwi CR6, R22, 0 */
		/* 82170364h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82170364h case    3:*/		return 0x82170368;
		  /* 82170368h */ case    4:  		/* addi R8, R10, 4 */
		/* 82170368h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82170368h case    4:*/		return 0x8217036C;
		  /* 8217036Ch */ case    5:  		/* addi R7, R10, -36 */
		/* 8217036Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 8217036Ch case    5:*/		return 0x82170370;
		  /* 82170370h */ case    6:  		/* lwz R6, <#[R10 + 4]> */
		/* 82170370h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82170370h case    6:*/		return 0x82170374;
		  /* 82170374h */ case    7:  		/* lwz R5, <#[R10]> */
		/* 82170374h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 82170374h case    7:*/		return 0x82170378;
		  /* 82170378h */ case    8:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82170378h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82170378h case    8:*/		return 0x8217037C;
		  /* 8217037Ch */ case    9:  		/* stw R5, <#[R6 + 36]> */
		/* 8217037Ch case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x00000024) );
		/* 8217037Ch case    9:*/		return 0x82170380;
		  /* 82170380h */ case   10:  		/* lwz R6, <#[R10]> */
		/* 82170380h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 82170380h case   10:*/		return 0x82170384;
		  /* 82170384h */ case   11:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82170384h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82170384h case   11:*/		return 0x82170388;
		  /* 82170388h */ case   12:  		/* lwz R5, <#[R10 + 4]> */
		/* 82170388h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 82170388h case   12:*/		return 0x8217038C;
		  /* 8217038Ch */ case   13:  		/* stw R5, <#[R6]> */
		/* 8217038Ch case   13:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x00000000) );
		/* 8217038Ch case   13:*/		return 0x82170390;
		  /* 82170390h */ case   14:  		/* lwz R6, <#[R11 + 4]> */
		/* 82170390h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82170390h case   14:*/		return 0x82170394;
		  /* 82170394h */ case   15:  		/* stw R6, <#[R10 + 4]> */
		/* 82170394h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82170394h case   15:*/		return 0x82170398;
		  /* 82170398h */ case   16:  		/* lwz R6, <#[R11 + 4]> */
		/* 82170398h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82170398h case   16:*/		return 0x8217039C;
		  /* 8217039Ch */ case   17:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8217039Ch case   17:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8217039Ch case   17:*/		return 0x821703A0;
		  /* 821703A0h */ case   18:  		/* stw R8, <#[R6 + 36]> */
		/* 821703A0h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 821703A0h case   18:*/		return 0x821703A4;
		  /* 821703A4h */ case   19:  		/* stw R9, <#[R10]> */
		/* 821703A4h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821703A4h case   19:*/		return 0x821703A8;
		  /* 821703A8h */ case   20:  		/* stw R7, <#[R11 + 4]> */
		/* 821703A8h case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821703A8h case   20:*/		return 0x821703AC;
		  /* 821703ACh */ case   21:  		/* lwz R11, <#[R28 + 20]> */
		/* 821703ACh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821703ACh case   21:*/		return 0x821703B0;
		  /* 821703B0h */ case   22:  		/* bc 4, CR6_EQ, 44 */
		/* 821703B0h case   22:*/		if ( !regs.CR[6].eq ) { return 0x821703DC;  }
		/* 821703B0h case   22:*/		return 0x821703B4;
		  /* 821703B4h */ case   23:  		/* mr R4, R28 */
		/* 821703B4h case   23:*/		regs.R4 = regs.R28;
		/* 821703B4h case   23:*/		return 0x821703B8;
		  /* 821703B8h */ case   24:  		/* mr R3, R21 */
		/* 821703B8h case   24:*/		regs.R3 = regs.R21;
		/* 821703B8h case   24:*/		return 0x821703BC;
		  /* 821703BCh */ case   25:  		/* rlwinm R5, R11, 0, 19, 31 */
		/* 821703BCh case   25:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R5,regs.R11);
		/* 821703BCh case   25:*/		return 0x821703C0;
		  /* 821703C0h */ case   26:  		/* bl 142080 */
		/* 821703C0h case   26:*/		regs.LR = 0x821703C4; return 0x82192EC0;
		/* 821703C0h case   26:*/		return 0x821703C4;
		  /* 821703C4h */ case   27:  		/* lwz R11, <#[R28 + 20]> */
		/* 821703C4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821703C4h case   27:*/		return 0x821703C8;
		  /* 821703C8h */ case   28:  		/* mr R4, R26 */
		/* 821703C8h case   28:*/		regs.R4 = regs.R26;
		/* 821703C8h case   28:*/		return 0x821703CC;
		  /* 821703CCh */ case   29:  		/* mr R3, R21 */
		/* 821703CCh case   29:*/		regs.R3 = regs.R21;
		/* 821703CCh case   29:*/		return 0x821703D0;
		  /* 821703D0h */ case   30:  		/* rlwinm R5, R11, 0, 19, 31 */
		/* 821703D0h case   30:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R5,regs.R11);
		/* 821703D0h case   30:*/		return 0x821703D4;
		  /* 821703D4h */ case   31:  		/* bl 142060 */
		/* 821703D4h case   31:*/		regs.LR = 0x821703D8; return 0x82192EC0;
		/* 821703D4h case   31:*/		return 0x821703D8;
		  /* 821703D8h */ case   32:  		/* b 16 */
		/* 821703D8h case   32:*/		return 0x821703E8;
		/* 821703D8h case   32:*/		return 0x821703DC;
	}
	return 0x821703DC;
} // Block from 82170358h-821703DCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 821703DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821703DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821703DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821703DC);
		  /* 821703DCh */ case    0:  		/* lwz R10, <#[R26 + 20]> */
		/* 821703DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821703DCh case    0:*/		return 0x821703E0;
		  /* 821703E0h */ case    1:  		/* rlwimi R11, R10, 0, 0, 18 */
		/* 821703E0h case    1:*/		cpu::op::rlwimi<0,0,0,18>(regs,&regs.R11,regs.R10);
		/* 821703E0h case    1:*/		return 0x821703E4;
		  /* 821703E4h */ case    2:  		/* stw R11, <#[R26 + 20]> */
		/* 821703E4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821703E4h case    2:*/		return 0x821703E8;
	}
	return 0x821703E8;
} // Block from 821703DCh-821703E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821703E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821703E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821703E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821703E8);
		  /* 821703E8h */ case    0:  		/* li R15, 1 */
		/* 821703E8h case    0:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 821703E8h case    0:*/		return 0x821703EC;
		  /* 821703ECh */ case    1:  		/* b -2576 */
		/* 821703ECh case    1:*/		return 0x8216F9DC;
		/* 821703ECh case    1:*/		return 0x821703F0;
	}
	return 0x821703F0;
} // Block from 821703E8h-821703F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821703F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821703F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821703F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821703F0);
		  /* 821703F0h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821703F0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821703F0h case    0:*/		return 0x821703F4;
		  /* 821703F4h */ case    1:  		/* rlwinm R10, R19, 0, 0, 30 */
		/* 821703F4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R19);
		/* 821703F4h case    1:*/		return 0x821703F8;
		  /* 821703F8h */ case    2:  		/* addi R11, R11, 36 */
		/* 821703F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821703F8h case    2:*/		return 0x821703FC;
		  /* 821703FCh */ case    3:  		/* addi R10, R10, 36 */
		/* 821703FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821703FCh case    3:*/		return 0x82170400;
		  /* 82170400h */ case    4:  		/* addi R9, R11, 4 */
		/* 82170400h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82170400h case    4:*/		return 0x82170404;
		  /* 82170404h */ case    5:  		/* addi R8, R10, 4 */
		/* 82170404h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82170404h case    5:*/		return 0x82170408;
		  /* 82170408h */ case    6:  		/* addi R7, R11, -36 */
		/* 82170408h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82170408h case    6:*/		return 0x8217040C;
		  /* 8217040Ch */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 8217040Ch case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8217040Ch case    7:*/		return 0x82170410;
		  /* 82170410h */ case    8:  		/* mr R5, R30 */
		/* 82170410h case    8:*/		regs.R5 = regs.R30;
		/* 82170410h case    8:*/		return 0x82170414;
		  /* 82170414h */ case    9:  		/* lwz R31, <#[R11]> */
		/* 82170414h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82170414h case    9:*/		return 0x82170418;
		  /* 82170418h */ case   10:  		/* mr R4, R19 */
		/* 82170418h case   10:*/		regs.R4 = regs.R19;
		/* 82170418h case   10:*/		return 0x8217041C;
		  /* 8217041Ch */ case   11:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8217041Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8217041Ch case   11:*/		return 0x82170420;
		  /* 82170420h */ case   12:  		/* mr R3, R21 */
		/* 82170420h case   12:*/		regs.R3 = regs.R21;
		/* 82170420h case   12:*/		return 0x82170424;
		  /* 82170424h */ case   13:  		/* stw R31, <#[R6 + 36]> */
		/* 82170424h case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R6 + 0x00000024) );
		/* 82170424h case   13:*/		return 0x82170428;
		  /* 82170428h */ case   14:  		/* lwz R31, <#[R11]> */
		/* 82170428h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82170428h case   14:*/		return 0x8217042C;
		  /* 8217042Ch */ case   15:  		/* rlwinm R31, R31, 0, 0, 30 */
		/* 8217042Ch case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R31,regs.R31);
		/* 8217042Ch case   15:*/		return 0x82170430;
		  /* 82170430h */ case   16:  		/* lwz R6, <#[R11 + 4]> */
		/* 82170430h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82170430h case   16:*/		return 0x82170434;
		  /* 82170434h */ case   17:  		/* stw R6, <#[R31]> */
		/* 82170434h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 82170434h case   17:*/		return 0x82170438;
		  /* 82170438h */ case   18:  		/* lwz R6, <#[R10 + 4]> */
		/* 82170438h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82170438h case   18:*/		return 0x8217043C;
		  /* 8217043Ch */ case   19:  		/* stw R6, <#[R11 + 4]> */
		/* 8217043Ch case   19:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8217043Ch case   19:*/		return 0x82170440;
		  /* 82170440h */ case   20:  		/* lwz R6, <#[R10 + 4]> */
		/* 82170440h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82170440h case   20:*/		return 0x82170444;
		  /* 82170444h */ case   21:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82170444h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82170444h case   21:*/		return 0x82170448;
		  /* 82170448h */ case   22:  		/* stw R9, <#[R6 + 36]> */
		/* 82170448h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 82170448h case   22:*/		return 0x8217044C;
		  /* 8217044Ch */ case   23:  		/* stw R8, <#[R11]> */
		/* 8217044Ch case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8217044Ch case   23:*/		return 0x82170450;
		  /* 82170450h */ case   24:  		/* stw R7, <#[R10 + 4]> */
		/* 82170450h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82170450h case   24:*/		return 0x82170454;
		  /* 82170454h */ case   25:  		/* bl 135140 */
		/* 82170454h case   25:*/		regs.LR = 0x82170458; return 0x82191438;
		/* 82170454h case   25:*/		return 0x82170458;
		  /* 82170458h */ case   26:  		/* cmplwi CR6, R22, 0 */
		/* 82170458h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82170458h case   26:*/		return 0x8217045C;
		  /* 8217045Ch */ case   27:  		/* bc 4, CR6_EQ, 24 */
		/* 8217045Ch case   27:*/		if ( !regs.CR[6].eq ) { return 0x82170474;  }
		/* 8217045Ch case   27:*/		return 0x82170460;
		  /* 82170460h */ case   28:  		/* lwz R11, <#[R19 + 20]> */
		/* 82170460h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82170460h case   28:*/		return 0x82170464;
		  /* 82170464h */ case   29:  		/* mr R4, R30 */
		/* 82170464h case   29:*/		regs.R4 = regs.R30;
		/* 82170464h case   29:*/		return 0x82170468;
		  /* 82170468h */ case   30:  		/* mr R3, R21 */
		/* 82170468h case   30:*/		regs.R3 = regs.R21;
		/* 82170468h case   30:*/		return 0x8217046C;
		  /* 8217046Ch */ case   31:  		/* rlwinm R5, R11, 0, 19, 31 */
		/* 8217046Ch case   31:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R5,regs.R11);
		/* 8217046Ch case   31:*/		return 0x82170470;
		  /* 82170470h */ case   32:  		/* bl 141904 */
		/* 82170470h case   32:*/		regs.LR = 0x82170474; return 0x82192EC0;
		/* 82170470h case   32:*/		return 0x82170474;
	}
	return 0x82170474;
} // Block from 821703F0h-82170474h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82170474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170474);
		  /* 82170474h */ case    0:  		/* li R6, 1 */
		/* 82170474h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82170474h case    0:*/		return 0x82170478;
		  /* 82170478h */ case    1:  		/* li R5, 0 */
		/* 82170478h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82170478h case    1:*/		return 0x8217047C;
		  /* 8217047Ch */ case    2:  		/* mr R4, R19 */
		/* 8217047Ch case    2:*/		regs.R4 = regs.R19;
		/* 8217047Ch case    2:*/		return 0x82170480;
		  /* 82170480h */ case    3:  		/* mr R3, R21 */
		/* 82170480h case    3:*/		regs.R3 = regs.R21;
		/* 82170480h case    3:*/		return 0x82170484;
		  /* 82170484h */ case    4:  		/* bl 765764 */
		/* 82170484h case    4:*/		regs.LR = 0x82170488; return 0x8222B3C8;
		/* 82170484h case    4:*/		return 0x82170488;
		  /* 82170488h */ case    5:  		/* b -2732 */
		/* 82170488h case    5:*/		return 0x8216F9DC;
		/* 82170488h case    5:*/		return 0x8217048C;
	}
	return 0x8217048C;
} // Block from 82170474h-8217048Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8217048Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217048C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217048C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217048C);
		  /* 8217048Ch */ case    0:  		/* li R4, 4800 */
		/* 8217048Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8217048Ch case    0:*/		return 0x82170490;
		  /* 82170490h */ case    1:  		/* mr R3, R21 */
		/* 82170490h case    1:*/		regs.R3 = regs.R21;
		/* 82170490h case    1:*/		return 0x82170494;
		  /* 82170494h */ case    2:  		/* bl -124460 */
		/* 82170494h case    2:*/		regs.LR = 0x82170498; return 0x82151E68;
		/* 82170494h case    2:*/		return 0x82170498;
	}
	return 0x82170498;
} // Block from 8217048Ch-82170498h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170498);
		  /* 82170498h */ case    0:  		/* li R4, 4800 */
		/* 82170498h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82170498h case    0:*/		return 0x8217049C;
		  /* 8217049Ch */ case    1:  		/* mr R3, R21 */
		/* 8217049Ch case    1:*/		regs.R3 = regs.R21;
		/* 8217049Ch case    1:*/		return 0x821704A0;
		  /* 821704A0h */ case    2:  		/* bl -124472 */
		/* 821704A0h case    2:*/		regs.LR = 0x821704A4; return 0x82151E68;
		/* 821704A0h case    2:*/		return 0x821704A4;
	}
	return 0x821704A4;
} // Block from 82170498h-821704A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821704A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821704A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821704A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821704A4);
		  /* 821704A4h */ case    0:  		/* lwz R4, <#[R21 + 732]> */
		/* 821704A4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x000002DC) );
		/* 821704A4h case    0:*/		return 0x821704A8;
		  /* 821704A8h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 821704A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821704A8h case    1:*/		return 0x821704AC;
		  /* 821704ACh */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821704ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x821704C4;  }
		/* 821704ACh case    2:*/		return 0x821704B0;
		  /* 821704B0h */ case    3:  		/* li R6, 0 */
		/* 821704B0h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821704B0h case    3:*/		return 0x821704B4;
		  /* 821704B4h */ case    4:  		/* mulli R5, R16, 12 */
		/* 821704B4h case    4:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R16,0xC);
		/* 821704B4h case    4:*/		return 0x821704B8;
		  /* 821704B8h */ case    5:  		/* mr R3, R21 */
		/* 821704B8h case    5:*/		regs.R3 = regs.R21;
		/* 821704B8h case    5:*/		return 0x821704BC;
		  /* 821704BCh */ case    6:  		/* bl -13932 */
		/* 821704BCh case    6:*/		regs.LR = 0x821704C0; return 0x8216CE50;
		/* 821704BCh case    6:*/		return 0x821704C0;
		  /* 821704C0h */ case    7:  		/* stw R20, <#[R21 + 732]> */
		/* 821704C0h case    7:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R21 + 0x000002DC) );
		/* 821704C0h case    7:*/		return 0x821704C4;
	}
	return 0x821704C4;
} // Block from 821704A4h-821704C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821704C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821704C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821704C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821704C4);
		  /* 821704C4h */ case    0:  		/* rlwinm. R11, R15, 0, 24, 31 */
		/* 821704C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R15);
		/* 821704C4h case    0:*/		return 0x821704C8;
		  /* 821704C8h */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 821704C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8217051C;  }
		/* 821704C8h case    1:*/		return 0x821704CC;
		  /* 821704CCh */ case    2:  		/* cmplwi CR6, R22, 0 */
		/* 821704CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821704CCh case    2:*/		return 0x821704D0;
		  /* 821704D0h */ case    3:  		/* bc 4, CR6_EQ, 76 */
		/* 821704D0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8217051C;  }
		/* 821704D0h case    3:*/		return 0x821704D4;
		  /* 821704D4h */ case    4:  		/* lwz R31, <#[R18]> */
		/* 821704D4h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R18 + 0x00000000) );
		/* 821704D4h case    4:*/		return 0x821704D8;
		  /* 821704D8h */ case    5:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821704D8h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821704D8h case    5:*/		return 0x821704DC;
		  /* 821704DCh */ case    6:  		/* bc 4, CR0_EQ, 64 */
		/* 821704DCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x8217051C;  }
		/* 821704DCh case    6:*/		return 0x821704E0;
		  /* 821704E0h */ case    7:  		/* cmplwi CR0, R31, 0 */
		/* 821704E0h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 821704E0h case    7:*/		return 0x821704E4;
		  /* 821704E4h */ case    8:  		/* bc 12, CR0_EQ, 56 */
		/* 821704E4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8217051C;  }
		/* 821704E4h case    8:*/		return 0x821704E8;
		  /* 821704E8h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 821704E8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821704E8h case    9:*/		return 0x821704EC;
		  /* 821704ECh */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821704ECh case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821704ECh case   10:*/		return 0x821704F0;
		  /* 821704F0h */ case   11:  		/* cmplwi CR6, R11, 14080 */
		/* 821704F0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821704F0h case   11:*/		return 0x821704F4;
		  /* 821704F4h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 821704F4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82170504;  }
		/* 821704F4h case   12:*/		return 0x821704F8;
		  /* 821704F8h */ case   13:  		/* mr R4, R31 */
		/* 821704F8h case   13:*/		regs.R4 = regs.R31;
		/* 821704F8h case   13:*/		return 0x821704FC;
		  /* 821704FCh */ case   14:  		/* mr R3, R21 */
		/* 821704FCh case   14:*/		regs.R3 = regs.R21;
		/* 821704FCh case   14:*/		return 0x82170500;
		  /* 82170500h */ case   15:  		/* bl 132856 */
		/* 82170500h case   15:*/		regs.LR = 0x82170504; return 0x82190BF8;
		/* 82170500h case   15:*/		return 0x82170504;
	}
	return 0x82170504;
} // Block from 821704C4h-82170504h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82170504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170504);
		  /* 82170504h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82170504h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82170504h case    0:*/		return 0x82170508;
		  /* 82170508h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 82170508h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 82170508h case    1:*/		return 0x8217050C;
		  /* 8217050Ch */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8217050Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8217050Ch case    2:*/		return 0x82170510;
		  /* 82170510h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82170510h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8217051C;  }
		/* 82170510h case    3:*/		return 0x82170514;
		  /* 82170514h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82170514h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82170514h case    4:*/		return 0x82170518;
		  /* 82170518h */ case    5:  		/* bc 4, CR6_EQ, -48 */
		/* 82170518h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821704E8;  }
		/* 82170518h case    5:*/		return 0x8217051C;
	}
	return 0x8217051C;
} // Block from 82170504h-8217051Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8217051Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217051C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217051C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217051C);
		  /* 8217051Ch */ case    0:  		/* addi R1, R1, 368 */
		/* 8217051Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x170);
		/* 8217051Ch case    0:*/		return 0x82170520;
		  /* 82170520h */ case    1:  		/* b -914096 */
		/* 82170520h case    1:*/		return 0x82091270;
		/* 82170520h case    1:*/		return 0x82170524;
		  /* 82170524h */ case    2:  		/* nop */
		/* 82170524h case    2:*/		cpu::op::nop();
		/* 82170524h case    2:*/		return 0x82170528;
	}
	return 0x82170528;
} // Block from 8217051Ch-82170528h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170528h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170528);
		  /* 82170528h */ case    0:  		/* mfspr R12, LR */
		/* 82170528h case    0:*/		regs.R12 = regs.LR;
		/* 82170528h case    0:*/		return 0x8217052C;
		  /* 8217052Ch */ case    1:  		/* bl -914128 */
		/* 8217052Ch case    1:*/		regs.LR = 0x82170530; return 0x8209125C;
		/* 8217052Ch case    1:*/		return 0x82170530;
		  /* 82170530h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82170530h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82170530h case    2:*/		return 0x82170534;
		  /* 82170534h */ case    3:  		/* mr R29, R3 */
		/* 82170534h case    3:*/		regs.R29 = regs.R3;
		/* 82170534h case    3:*/		return 0x82170538;
		  /* 82170538h */ case    4:  		/* mr R4, R3 */
		/* 82170538h case    4:*/		regs.R4 = regs.R3;
		/* 82170538h case    4:*/		return 0x8217053C;
		  /* 8217053Ch */ case    5:  		/* addi R3, R1, 80 */
		/* 8217053Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8217053Ch case    5:*/		return 0x82170540;
		  /* 82170540h */ case    6:  		/* bl -3872 */
		/* 82170540h case    6:*/		regs.LR = 0x82170544; return 0x8216F620;
		/* 82170540h case    6:*/		return 0x82170544;
		  /* 82170544h */ case    7:  		/* lwz R11, <#[R29 + 4]> */
		/* 82170544h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82170544h case    7:*/		return 0x82170548;
		  /* 82170548h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170548h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170548h case    8:*/		return 0x8217054C;
		  /* 8217054Ch */ case    9:  		/* bc 4, CR0_EQ, 100 */
		/* 8217054Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x821705B0;  }
		/* 8217054Ch case    9:*/		return 0x82170550;
		  /* 82170550h */ case   10:  		/* mr R31, R11 */
		/* 82170550h case   10:*/		regs.R31 = regs.R11;
		/* 82170550h case   10:*/		return 0x82170554;
		  /* 82170554h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82170554h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82170554h case   11:*/		return 0x82170558;
		  /* 82170558h */ case   12:  		/* bc 12, CR0_EQ, 88 */
		/* 82170558h case   12:*/		if ( regs.CR[0].eq ) { return 0x821705B0;  }
		/* 82170558h case   12:*/		return 0x8217055C;
		  /* 8217055Ch */ case   13:  		/* lwz R11, <#[R29 + 44]> */
		/* 8217055Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000002C) );
		/* 8217055Ch case   13:*/		return 0x82170560;
		  /* 82170560h */ case   14:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 82170560h case   14:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 82170560h case   14:*/		return 0x82170564;
		  /* 82170564h */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 82170564h case   15:*/		if ( regs.CR[0].eq ) { return 0x82170574;  }
		/* 82170564h case   15:*/		return 0x82170568;
		  /* 82170568h */ case   16:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82170568h case   16:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82170568h case   16:*/		return 0x8217056C;
		  /* 8217056Ch */ case   17:  		/* li R11, 1 */
		/* 8217056Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8217056Ch case   17:*/		return 0x82170570;
		  /* 82170570h */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 82170570h case   18:*/		if ( regs.CR[0].eq ) { return 0x82170578;  }
		/* 82170570h case   18:*/		return 0x82170574;
	}
	return 0x82170574;
} // Block from 82170528h-82170574h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82170574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170574);
		  /* 82170574h */ case    0:  		/* li R11, 0 */
		/* 82170574h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82170574h case    0:*/		return 0x82170578;
	}
	return 0x82170578;
} // Block from 82170574h-82170578h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170578);
		  /* 82170578h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82170578h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82170578h case    0:*/		return 0x8217057C;
		  /* 8217057Ch */ case    1:  		/* addi R6, R1, 80 */
		/* 8217057Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8217057Ch case    1:*/		return 0x82170580;
		  /* 82170580h */ case    2:  		/* cntlzw R11, R11 */
		/* 82170580h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82170580h case    2:*/		return 0x82170584;
		  /* 82170584h */ case    3:  		/* mr R4, R31 */
		/* 82170584h case    3:*/		regs.R4 = regs.R31;
		/* 82170584h case    3:*/		return 0x82170588;
		  /* 82170588h */ case    4:  		/* rlwinm R5, R11, 27, 31, 31 */
		/* 82170588h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R5,regs.R11);
		/* 82170588h case    4:*/		return 0x8217058C;
		  /* 8217058Ch */ case    5:  		/* mr R3, R29 */
		/* 8217058Ch case    5:*/		regs.R3 = regs.R29;
		/* 8217058Ch case    5:*/		return 0x82170590;
		  /* 82170590h */ case    6:  		/* bl -3056 */
		/* 82170590h case    6:*/		regs.LR = 0x82170594; return 0x8216F9A0;
		/* 82170590h case    6:*/		return 0x82170594;
		  /* 82170594h */ case    7:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82170594h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82170594h case    7:*/		return 0x82170598;
		  /* 82170598h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82170598h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82170598h case    8:*/		return 0x8217059C;
		  /* 8217059Ch */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8217059Ch case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8217059Ch case    9:*/		return 0x821705A0;
		  /* 821705A0h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 821705A0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821705B0;  }
		/* 821705A0h case   10:*/		return 0x821705A4;
		  /* 821705A4h */ case   11:  		/* mr R31, R11 */
		/* 821705A4h case   11:*/		regs.R31 = regs.R11;
		/* 821705A4h case   11:*/		return 0x821705A8;
		  /* 821705A8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821705A8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821705A8h case   12:*/		return 0x821705AC;
		  /* 821705ACh */ case   13:  		/* bc 4, CR6_EQ, -80 */
		/* 821705ACh case   13:*/		if ( !regs.CR[6].eq ) { return 0x8217055C;  }
		/* 821705ACh case   13:*/		return 0x821705B0;
	}
	return 0x821705B0;
} // Block from 82170578h-821705B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821705B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821705B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821705B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821705B0);
		  /* 821705B0h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 821705B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821705B0h case    0:*/		return 0x821705B4;
		  /* 821705B4h */ case    1:  		/* li R30, 0 */
		/* 821705B4h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821705B4h case    1:*/		return 0x821705B8;
		  /* 821705B8h */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821705B8h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821705B8h case    2:*/		return 0x821705BC;
		  /* 821705BCh */ case    3:  		/* addic R10, R10, -1 */
		/* 821705BCh case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821705BCh case    3:*/		return 0x821705C0;
		  /* 821705C0h */ case    4:  		/* subfe R10, R10, R10 */
		/* 821705C0h case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821705C0h case    4:*/		return 0x821705C4;
		  /* 821705C4h */ case    5:  		/* and R11, R10, R11 */
		/* 821705C4h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821705C4h case    5:*/		return 0x821705C8;
		  /* 821705C8h */ case    6:  		/* lwz R31, <#[R11 + 20]> */
		/* 821705C8h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 821705C8h case    6:*/		return 0x821705CC;
		  /* 821705CCh */ case    7:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821705CCh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821705CCh case    7:*/		return 0x821705D0;
		  /* 821705D0h */ case    8:  		/* bc 4, CR0_EQ, 216 */
		/* 821705D0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821706A8;  }
		/* 821705D0h case    8:*/		return 0x821705D4;
		  /* 821705D4h */ case    9:  		/* cmplwi CR0, R31, 0 */
		/* 821705D4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 821705D4h case    9:*/		return 0x821705D8;
		  /* 821705D8h */ case   10:  		/* bc 12, CR0_EQ, 208 */
		/* 821705D8h case   10:*/		if ( regs.CR[0].eq ) { return 0x821706A8;  }
		/* 821705D8h case   10:*/		return 0x821705DC;
		  /* 821705DCh */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 821705DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821705DCh case   11:*/		return 0x821705E0;
		  /* 821705E0h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821705E0h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821705E0h case   12:*/		return 0x821705E4;
		  /* 821705E4h */ case   13:  		/* cmplwi CR6, R11, 16000 */
		/* 821705E4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821705E4h case   13:*/		return 0x821705E8;
		  /* 821705E8h */ case   14:  		/* bc 4, CR6_EQ, 40 */
		/* 821705E8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82170610;  }
		/* 821705E8h case   14:*/		return 0x821705EC;
		  /* 821705ECh */ case   15:  		/* mr R3, R31 */
		/* 821705ECh case   15:*/		regs.R3 = regs.R31;
		/* 821705ECh case   15:*/		return 0x821705F0;
		  /* 821705F0h */ case   16:  		/* bl -48240 */
		/* 821705F0h case   16:*/		regs.LR = 0x821705F4; return 0x82164980;
		/* 821705F0h case   16:*/		return 0x821705F4;
		  /* 821705F4h */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821705F4h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821705F4h case   17:*/		return 0x821705F8;
		  /* 821705F8h */ case   18:  		/* bc 12, CR0_EQ, 24 */
		/* 821705F8h case   18:*/		if ( regs.CR[0].eq ) { return 0x82170610;  }
		/* 821705F8h case   18:*/		return 0x821705FC;
		  /* 821705FCh */ case   19:  		/* li R6, 1 */
		/* 821705FCh case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821705FCh case   19:*/		return 0x82170600;
		  /* 82170600h */ case   20:  		/* li R5, 0 */
		/* 82170600h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82170600h case   20:*/		return 0x82170604;
		  /* 82170604h */ case   21:  		/* mr R4, R31 */
		/* 82170604h case   21:*/		regs.R4 = regs.R31;
		/* 82170604h case   21:*/		return 0x82170608;
		  /* 82170608h */ case   22:  		/* mr R3, R29 */
		/* 82170608h case   22:*/		regs.R3 = regs.R29;
		/* 82170608h case   22:*/		return 0x8217060C;
		  /* 8217060Ch */ case   23:  		/* bl 765372 */
		/* 8217060Ch case   23:*/		regs.LR = 0x82170610; return 0x8222B3C8;
		/* 8217060Ch case   23:*/		return 0x82170610;
	}
	return 0x82170610;
} // Block from 821705B0h-82170610h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82170610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170610);
		  /* 82170610h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82170610h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82170610h case    0:*/		return 0x82170614;
		  /* 82170614h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 82170614h case    1:*/		if ( regs.CR[6].eq ) { return 0x82170658;  }
		/* 82170614h case    1:*/		return 0x82170618;
		  /* 82170618h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82170618h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82170618h case    2:*/		return 0x8217061C;
		  /* 8217061Ch */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 8217061Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8217061Ch case    3:*/		return 0x82170620;
		  /* 82170620h */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82170620h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170620h case    4:*/		return 0x82170624;
		  /* 82170624h */ case    5:  		/* addic R10, R10, -1 */
		/* 82170624h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82170624h case    5:*/		return 0x82170628;
		  /* 82170628h */ case    6:  		/* subfe R10, R10, R10 */
		/* 82170628h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82170628h case    6:*/		return 0x8217062C;
		  /* 8217062Ch */ case    7:  		/* and R10, R10, R11 */
		/* 8217062Ch case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8217062Ch case    7:*/		return 0x82170630;
		  /* 82170630h */ case    8:  		/* cmplw CR6, R31, R10 */
		/* 82170630h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 82170630h case    8:*/		return 0x82170634;
		  /* 82170634h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 82170634h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82170648;  }
		/* 82170634h case    9:*/		return 0x82170638;
		  /* 82170638h */ case   10:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82170638h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82170638h case   10:*/		return 0x8217063C;
		  /* 8217063Ch */ case   11:  		/* mr R30, R31 */
		/* 8217063Ch case   11:*/		regs.R30 = regs.R31;
		/* 8217063Ch case   11:*/		return 0x82170640;
		  /* 82170640h */ case   12:  		/* lwz R31, <#[R11 + 40]> */
		/* 82170640h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 82170640h case   12:*/		return 0x82170644;
		  /* 82170644h */ case   13:  		/* b 84 */
		/* 82170644h case   13:*/		return 0x82170698;
		/* 82170644h case   13:*/		return 0x82170648;
	}
	return 0x82170648;
} // Block from 82170610h-82170648h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82170648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170648);
		  /* 82170648h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170648h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170648h case    0:*/		return 0x8217064C;
		  /* 8217064Ch */ case    1:  		/* bc 4, CR0_EQ, 92 */
		/* 8217064Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821706A8;  }
		/* 8217064Ch case    1:*/		return 0x82170650;
		  /* 82170650h */ case    2:  		/* mr R31, R11 */
		/* 82170650h case    2:*/		regs.R31 = regs.R11;
		/* 82170650h case    2:*/		return 0x82170654;
		  /* 82170654h */ case    3:  		/* b 76 */
		/* 82170654h case    3:*/		return 0x821706A0;
		/* 82170654h case    3:*/		return 0x82170658;
	}
	return 0x82170658;
} // Block from 82170648h-82170658h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82170658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170658);
		  /* 82170658h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82170658h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82170658h case    0:*/		return 0x8217065C;
		  /* 8217065Ch */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8217065Ch case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8217065Ch case    1:*/		return 0x82170660;
		  /* 82170660h */ case    2:  		/* addic R9, R10, -1 */
		/* 82170660h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82170660h case    2:*/		return 0x82170664;
		  /* 82170664h */ case    3:  		/* subfe R9, R9, R9 */
		/* 82170664h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 82170664h case    3:*/		return 0x82170668;
		  /* 82170668h */ case    4:  		/* and R9, R9, R11 */
		/* 82170668h case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 82170668h case    4:*/		return 0x8217066C;
		  /* 8217066Ch */ case    5:  		/* lwz R9, <#[R9 + 20]> */
		/* 8217066Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 8217066Ch case    5:*/		return 0x82170670;
		  /* 82170670h */ case    6:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 82170670h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 82170670h case    6:*/		return 0x82170674;
		  /* 82170674h */ case    7:  		/* addic R8, R8, -1 */
		/* 82170674h case    7:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82170674h case    7:*/		return 0x82170678;
		  /* 82170678h */ case    8:  		/* subfe R8, R8, R8 */
		/* 82170678h case    8:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 82170678h case    8:*/		return 0x8217067C;
		  /* 8217067Ch */ case    9:  		/* and R9, R8, R9 */
		/* 8217067Ch case    9:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8217067Ch case    9:*/		return 0x82170680;
		  /* 82170680h */ case   10:  		/* cmplw CR6, R31, R9 */
		/* 82170680h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 82170680h case   10:*/		return 0x82170684;
		  /* 82170684h */ case   11:  		/* bc 12, CR6_EQ, -76 */
		/* 82170684h case   11:*/		if ( regs.CR[6].eq ) { return 0x82170638;  }
		/* 82170684h case   11:*/		return 0x82170688;
		  /* 82170688h */ case   12:  		/* addic R10, R10, -1 */
		/* 82170688h case   12:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82170688h case   12:*/		return 0x8217068C;
		  /* 8217068Ch */ case   13:  		/* subfe R10, R10, R10 */
		/* 8217068Ch case   13:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8217068Ch case   13:*/		return 0x82170690;
		  /* 82170690h */ case   14:  		/* and R11, R10, R11 */
		/* 82170690h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82170690h case   14:*/		return 0x82170694;
		  /* 82170694h */ case   15:  		/* lwz R31, <#[R11 + 20]> */
		/* 82170694h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 82170694h case   15:*/		return 0x82170698;
	}
	return 0x82170698;
} // Block from 82170658h-82170698h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82170698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170698);
		  /* 82170698h */ case    0:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82170698h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82170698h case    0:*/		return 0x8217069C;
		  /* 8217069Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8217069Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821706A8;  }
		/* 8217069Ch case    1:*/		return 0x821706A0;
	}
	return 0x821706A0;
} // Block from 82170698h-821706A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821706A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821706A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821706A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821706A0);
		  /* 821706A0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821706A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821706A0h case    0:*/		return 0x821706A4;
		  /* 821706A4h */ case    1:  		/* bc 4, CR6_EQ, -200 */
		/* 821706A4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821705DC;  }
		/* 821706A4h case    1:*/		return 0x821706A8;
	}
	return 0x821706A8;
} // Block from 821706A0h-821706A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821706A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821706A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821706A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821706A8);
		  /* 821706A8h */ case    0:  		/* addi R1, R1, 192 */
		/* 821706A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821706A8h case    0:*/		return 0x821706AC;
		  /* 821706ACh */ case    1:  		/* b -914432 */
		/* 821706ACh case    1:*/		return 0x820912AC;
		/* 821706ACh case    1:*/		return 0x821706B0;
	}
	return 0x821706B0;
} // Block from 821706A8h-821706B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821706B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821706B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821706B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821706B0);
		  /* 821706B0h */ case    0:  		/* mfspr R12, LR */
		/* 821706B0h case    0:*/		regs.R12 = regs.LR;
		/* 821706B0h case    0:*/		return 0x821706B4;
		  /* 821706B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821706B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821706B4h case    1:*/		return 0x821706B8;
		  /* 821706B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821706B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821706B8h case    2:*/		return 0x821706BC;
		  /* 821706BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821706BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821706BCh case    3:*/		return 0x821706C0;
		  /* 821706C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821706C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821706C0h case    4:*/		return 0x821706C4;
		  /* 821706C4h */ case    5:  		/* mr R31, R4 */
		/* 821706C4h case    5:*/		regs.R31 = regs.R4;
		/* 821706C4h case    5:*/		return 0x821706C8;
		  /* 821706C8h */ case    6:  		/* mr R4, R5 */
		/* 821706C8h case    6:*/		regs.R4 = regs.R5;
		/* 821706C8h case    6:*/		return 0x821706CC;
		  /* 821706CCh */ case    7:  		/* mr R30, R3 */
		/* 821706CCh case    7:*/		regs.R30 = regs.R3;
		/* 821706CCh case    7:*/		return 0x821706D0;
		  /* 821706D0h */ case    8:  		/* bl 31480 */
		/* 821706D0h case    8:*/		regs.LR = 0x821706D4; return 0x821781C8;
		/* 821706D0h case    8:*/		return 0x821706D4;
		  /* 821706D4h */ case    9:  		/* addi R11, R31, 11 */
		/* 821706D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xB);
		/* 821706D4h case    9:*/		return 0x821706D8;
		  /* 821706D8h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821706D8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821706D8h case   10:*/		return 0x821706DC;
		  /* 821706DCh */ case   11:  		/* stwx R3, <#[R11 + R30]> */
		/* 821706DCh case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 821706DCh case   11:*/		return 0x821706E0;
		  /* 821706E0h */ case   12:  		/* addi R1, R1, 112 */
		/* 821706E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821706E0h case   12:*/		return 0x821706E4;
		  /* 821706E4h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 821706E4h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821706E4h case   13:*/		return 0x821706E8;
		  /* 821706E8h */ case   14:  		/* mtspr LR, R12 */
		/* 821706E8h case   14:*/		regs.LR = regs.R12;
		/* 821706E8h case   14:*/		return 0x821706EC;
		  /* 821706ECh */ case   15:  		/* ld R30, <#[R1 - 24]> */
		/* 821706ECh case   15:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821706ECh case   15:*/		return 0x821706F0;
		  /* 821706F0h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 821706F0h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821706F0h case   16:*/		return 0x821706F4;
		  /* 821706F4h */ case   17:  		/* bclr 20, CR0_LT */
		/* 821706F4h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821706F4h case   17:*/		return 0x821706F8;
	}
	return 0x821706F8;
} // Block from 821706B0h-821706F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821706F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821706F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821706F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821706F8);
		  /* 821706F8h */ case    0:  		/* mfspr R12, LR */
		/* 821706F8h case    0:*/		regs.R12 = regs.LR;
		/* 821706F8h case    0:*/		return 0x821706FC;
		  /* 821706FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821706FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821706FCh case    1:*/		return 0x82170700;
		  /* 82170700h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82170700h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82170700h case    2:*/		return 0x82170704;
		  /* 82170704h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82170704h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82170704h case    3:*/		return 0x82170708;
		  /* 82170708h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82170708h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82170708h case    4:*/		return 0x8217070C;
		  /* 8217070Ch */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 8217070Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8217070Ch case    5:*/		return 0x82170710;
		  /* 82170710h */ case    6:  		/* mr R31, R3 */
		/* 82170710h case    6:*/		regs.R31 = regs.R3;
		/* 82170710h case    6:*/		return 0x82170714;
		  /* 82170714h */ case    7:  		/* mr R30, R4 */
		/* 82170714h case    7:*/		regs.R30 = regs.R4;
		/* 82170714h case    7:*/		return 0x82170718;
		  /* 82170718h */ case    8:  		/* mr R3, R5 */
		/* 82170718h case    8:*/		regs.R3 = regs.R5;
		/* 82170718h case    8:*/		return 0x8217071C;
		  /* 8217071Ch */ case    9:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8217071Ch case    9:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8217071Ch case    9:*/		return 0x82170720;
		  /* 82170720h */ case   10:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82170720h case   10:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82170720h case   10:*/		return 0x82170724;
		  /* 82170724h */ case   11:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82170724h case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82170724h case   11:*/		return 0x82170728;
		  /* 82170728h */ case   12:  		/* bl -49912 */
		/* 82170728h case   12:*/		regs.LR = 0x8217072C; return 0x82164430;
		/* 82170728h case   12:*/		return 0x8217072C;
		  /* 8217072Ch */ case   13:  		/* addi R11, R31, -16 */
		/* 8217072Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8217072Ch case   13:*/		return 0x82170730;
		  /* 82170730h */ case   14:  		/* stwx R30, <#[R3 + R11]> */
		/* 82170730h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82170730h case   14:*/		return 0x82170734;
		  /* 82170734h */ case   15:  		/* addi R1, R1, 112 */
		/* 82170734h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82170734h case   15:*/		return 0x82170738;
		  /* 82170738h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 82170738h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82170738h case   16:*/		return 0x8217073C;
		  /* 8217073Ch */ case   17:  		/* mtspr LR, R12 */
		/* 8217073Ch case   17:*/		regs.LR = regs.R12;
		/* 8217073Ch case   17:*/		return 0x82170740;
		  /* 82170740h */ case   18:  		/* ld R30, <#[R1 - 24]> */
		/* 82170740h case   18:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82170740h case   18:*/		return 0x82170744;
		  /* 82170744h */ case   19:  		/* ld R31, <#[R1 - 16]> */
		/* 82170744h case   19:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82170744h case   19:*/		return 0x82170748;
		  /* 82170748h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82170748h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170748h case   20:*/		return 0x8217074C;
	}
	return 0x8217074C;
} // Block from 821706F8h-8217074Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8217074Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217074C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217074C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217074C);
		  /* 8217074Ch */ case    0:  		/* nop */
		/* 8217074Ch case    0:*/		cpu::op::nop();
		/* 8217074Ch case    0:*/		return 0x82170750;
	}
	return 0x82170750;
} // Block from 8217074Ch-82170750h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170750);
		  /* 82170750h */ case    0:  		/* mfspr R12, LR */
		/* 82170750h case    0:*/		regs.R12 = regs.LR;
		/* 82170750h case    0:*/		return 0x82170754;
		  /* 82170754h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82170754h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82170754h case    1:*/		return 0x82170758;
		  /* 82170758h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82170758h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82170758h case    2:*/		return 0x8217075C;
		  /* 8217075Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8217075Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8217075Ch case    3:*/		return 0x82170760;
		  /* 82170760h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82170760h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82170760h case    4:*/		return 0x82170764;
		  /* 82170764h */ case    5:  		/* mr R31, R4 */
		/* 82170764h case    5:*/		regs.R31 = regs.R4;
		/* 82170764h case    5:*/		return 0x82170768;
		  /* 82170768h */ case    6:  		/* mr R30, R5 */
		/* 82170768h case    6:*/		regs.R30 = regs.R5;
		/* 82170768h case    6:*/		return 0x8217076C;
		  /* 8217076Ch */ case    7:  		/* li R5, 26 */
		/* 8217076Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1A);
		/* 8217076Ch case    7:*/		return 0x82170770;
		  /* 82170770h */ case    8:  		/* li R4, 20 */
		/* 82170770h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82170770h case    8:*/		return 0x82170774;
		  /* 82170774h */ case    9:  		/* bl -15308 */
		/* 82170774h case    9:*/		regs.LR = 0x82170778; return 0x8216CBA8;
		/* 82170774h case    9:*/		return 0x82170778;
		  /* 82170778h */ case   10:  		/* lwz R10, <#[R3]> */
		/* 82170778h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82170778h case   10:*/		return 0x8217077C;
		  /* 8217077Ch */ case   11:  		/* lis R11, 16384 */
		/* 8217077Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0x4000);
		/* 8217077Ch case   11:*/		return 0x82170780;
		  /* 82170780h */ case   12:  		/* stw R31, <#[R3 + 12]> */
		/* 82170780h case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x0000000C) );
		/* 82170780h case   12:*/		return 0x82170784;
		  /* 82170784h */ case   13:  		/* rlwinm R10, R10, 0, 19, 6 */
		/* 82170784h case   13:*/		cpu::op::rlwinm<0,0,19,6>(regs,&regs.R10,regs.R10);
		/* 82170784h case   13:*/		return 0x82170788;
		  /* 82170788h */ case   14:  		/* rlwimi R11, R30, 13, 7, 18 */
		/* 82170788h case   14:*/		cpu::op::rlwimi<0,13,7,18>(regs,&regs.R11,regs.R30);
		/* 82170788h case   14:*/		return 0x8217078C;
		  /* 8217078Ch */ case   15:  		/* or R11, R11, R10 */
		/* 8217078Ch case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8217078Ch case   15:*/		return 0x82170790;
		  /* 82170790h */ case   16:  		/* stw R11, <#[R3]> */
		/* 82170790h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82170790h case   16:*/		return 0x82170794;
		  /* 82170794h */ case   17:  		/* lwz R11, <#[R31 + 4]> */
		/* 82170794h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82170794h case   17:*/		return 0x82170798;
		  /* 82170798h */ case   18:  		/* stw R11, <#[R3 + 8]> */
		/* 82170798h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82170798h case   18:*/		return 0x8217079C;
		  /* 8217079Ch */ case   19:  		/* stw R3, <#[R31 + 4]> */
		/* 8217079Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 8217079Ch case   19:*/		return 0x821707A0;
		  /* 821707A0h */ case   20:  		/* addi R1, R1, 112 */
		/* 821707A0h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821707A0h case   20:*/		return 0x821707A4;
		  /* 821707A4h */ case   21:  		/* lwz R12, <#[R1 - 8]> */
		/* 821707A4h case   21:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821707A4h case   21:*/		return 0x821707A8;
		  /* 821707A8h */ case   22:  		/* mtspr LR, R12 */
		/* 821707A8h case   22:*/		regs.LR = regs.R12;
		/* 821707A8h case   22:*/		return 0x821707AC;
		  /* 821707ACh */ case   23:  		/* ld R30, <#[R1 - 24]> */
		/* 821707ACh case   23:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821707ACh case   23:*/		return 0x821707B0;
		  /* 821707B0h */ case   24:  		/* ld R31, <#[R1 - 16]> */
		/* 821707B0h case   24:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821707B0h case   24:*/		return 0x821707B4;
		  /* 821707B4h */ case   25:  		/* bclr 20, CR0_LT */
		/* 821707B4h case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821707B4h case   25:*/		return 0x821707B8;
	}
	return 0x821707B8;
} // Block from 82170750h-821707B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821707B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821707B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821707B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821707B8);
		  /* 821707B8h */ case    0:  		/* mfspr R12, LR */
		/* 821707B8h case    0:*/		regs.R12 = regs.LR;
		/* 821707B8h case    0:*/		return 0x821707BC;
		  /* 821707BCh */ case    1:  		/* bl -914788 */
		/* 821707BCh case    1:*/		regs.LR = 0x821707C0; return 0x82091258;
		/* 821707BCh case    1:*/		return 0x821707C0;
		  /* 821707C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821707C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821707C0h case    2:*/		return 0x821707C4;
		  /* 821707C4h */ case    3:  		/* lwz R9, <#[R3 + 4]> */
		/* 821707C4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 821707C4h case    3:*/		return 0x821707C8;
		  /* 821707C8h */ case    4:  		/* mr R28, R3 */
		/* 821707C8h case    4:*/		regs.R28 = regs.R3;
		/* 821707C8h case    4:*/		return 0x821707CC;
		  /* 821707CCh */ case    5:  		/* rlwinm. R11, R9, 0, 31, 31 */
		/* 821707CCh case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R9);
		/* 821707CCh case    5:*/		return 0x821707D0;
		  /* 821707D0h */ case    6:  		/* bc 4, CR0_EQ, 164 */
		/* 821707D0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82170874;  }
		/* 821707D0h case    6:*/		return 0x821707D4;
		  /* 821707D4h */ case    7:  		/* cmplwi CR0, R9, 0 */
		/* 821707D4h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 821707D4h case    7:*/		return 0x821707D8;
		  /* 821707D8h */ case    8:  		/* bc 12, CR0_EQ, 156 */
		/* 821707D8h case    8:*/		if ( regs.CR[0].eq ) { return 0x82170874;  }
		/* 821707D8h case    8:*/		return 0x821707DC;
		  /* 821707DCh */ case    9:  		/* lwz R11, <#[R9 + 20]> */
		/* 821707DCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 821707DCh case    9:*/		return 0x821707E0;
		  /* 821707E0h */ case   10:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821707E0h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821707E0h case   10:*/		return 0x821707E4;
		  /* 821707E4h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 821707E4h case   11:*/		if ( regs.CR[0].eq ) { return 0x821707F4;  }
		/* 821707E4h case   11:*/		return 0x821707E8;
		  /* 821707E8h */ case   12:  		/* lwz R11, <#[R9 + 28]> */
		/* 821707E8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000001C) );
		/* 821707E8h case   12:*/		return 0x821707EC;
		  /* 821707ECh */ case   13:  		/* addi R8, R9, 24 */
		/* 821707ECh case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x18);
		/* 821707ECh case   13:*/		return 0x821707F0;
		  /* 821707F0h */ case   14:  		/* b 12 */
		/* 821707F0h case   14:*/		return 0x821707FC;
		/* 821707F0h case   14:*/		return 0x821707F4;
	}
	return 0x821707F4;
} // Block from 821707B8h-821707F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821707F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821707F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821707F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821707F4);
		  /* 821707F4h */ case    0:  		/* lwz R11, <#[R9 + 20]> */
		/* 821707F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 821707F4h case    0:*/		return 0x821707F8;
		  /* 821707F8h */ case    1:  		/* addi R8, R9, 16 */
		/* 821707F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x10);
		/* 821707F8h case    1:*/		return 0x821707FC;
	}
	return 0x821707FC;
} // Block from 821707F4h-821707FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821707FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821707FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821707FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821707FC);
		  /* 821707FCh */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821707FCh case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821707FCh case    0:*/		return 0x82170800;
		  /* 82170800h */ case    1:  		/* addic R10, R10, -1 */
		/* 82170800h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82170800h case    1:*/		return 0x82170804;
		  /* 82170804h */ case    2:  		/* subfe R10, R10, R10 */
		/* 82170804h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82170804h case    2:*/		return 0x82170808;
		  /* 82170808h */ case    3:  		/* and R11, R10, R11 */
		/* 82170808h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82170808h case    3:*/		return 0x8217080C;
		  /* 8217080Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8217080Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217080Ch case    4:*/		return 0x82170810;
		  /* 82170810h */ case    5:  		/* bc 12, CR6_EQ, 76 */
		/* 82170810h case    5:*/		if ( regs.CR[6].eq ) { return 0x8217085C;  }
		/* 82170810h case    5:*/		return 0x82170814;
		  /* 82170814h */ case    6:  		/* lwz R10, <#[R11 + 8]> */
		/* 82170814h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82170814h case    6:*/		return 0x82170818;
		  /* 82170818h */ case    7:  		/* rlwinm R7, R11, 0, 0, 30 */
		/* 82170818h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R11);
		/* 82170818h case    7:*/		return 0x8217081C;
		  /* 8217081Ch */ case    8:  		/* rlwinm R10, R10, 0, 6, 4 */
		/* 8217081Ch case    8:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R10,regs.R10);
		/* 8217081Ch case    8:*/		return 0x82170820;
		  /* 82170820h */ case    9:  		/* stw R10, <#[R11 + 8]> */
		/* 82170820h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82170820h case    9:*/		return 0x82170824;
		  /* 82170824h */ case   10:  		/* lwz R11, <#[R7 + 40]> */
		/* 82170824h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000028) );
		/* 82170824h case   10:*/		return 0x82170828;
		  /* 82170828h */ case   11:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170828h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170828h case   11:*/		return 0x8217082C;
		  /* 8217082Ch */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 8217082Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x82170838;  }
		/* 8217082Ch case   12:*/		return 0x82170830;
		  /* 82170830h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82170830h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82170830h case   13:*/		return 0x82170834;
		  /* 82170834h */ case   14:  		/* bc 4, CR6_EQ, -32 */
		/* 82170834h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82170814;  }
		/* 82170834h case   14:*/		return 0x82170838;
	}
	return 0x82170838;
} // Block from 821707FCh-82170838h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82170838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170838);
		  /* 82170838h */ case    0:  		/* addi R10, R9, 24 */
		/* 82170838h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x18);
		/* 82170838h case    0:*/		return 0x8217083C;
		  /* 8217083Ch */ case    1:  		/* cmplw CR6, R8, R10 */
		/* 8217083Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 8217083Ch case    1:*/		return 0x82170840;
		  /* 82170840h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82170840h case    2:*/		if ( regs.CR[6].eq ) { return 0x8217085C;  }
		/* 82170840h case    2:*/		return 0x82170844;
		  /* 82170844h */ case    3:  		/* lwz R11, <#[R10 + 4]> */
		/* 82170844h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82170844h case    3:*/		return 0x82170848;
		  /* 82170848h */ case    4:  		/* mr R8, R10 */
		/* 82170848h case    4:*/		regs.R8 = regs.R10;
		/* 82170848h case    4:*/		return 0x8217084C;
		  /* 8217084Ch */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8217084Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8217084Ch case    5:*/		return 0x82170850;
		  /* 82170850h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82170850h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8217085C;  }
		/* 82170850h case    6:*/		return 0x82170854;
		  /* 82170854h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82170854h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82170854h case    7:*/		return 0x82170858;
		  /* 82170858h */ case    8:  		/* bc 4, CR0_EQ, -68 */
		/* 82170858h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82170814;  }
		/* 82170858h case    8:*/		return 0x8217085C;
	}
	return 0x8217085C;
} // Block from 82170838h-8217085Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8217085Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217085C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217085C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217085C);
		  /* 8217085Ch */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 8217085Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 8217085Ch case    0:*/		return 0x82170860;
		  /* 82170860h */ case    1:  		/* lwz R9, <#[R11 + 4]> */
		/* 82170860h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82170860h case    1:*/		return 0x82170864;
		  /* 82170864h */ case    2:  		/* rlwinm. R11, R9, 0, 31, 31 */
		/* 82170864h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R9);
		/* 82170864h case    2:*/		return 0x82170868;
		  /* 82170868h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82170868h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82170874;  }
		/* 82170868h case    3:*/		return 0x8217086C;
		  /* 8217086Ch */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 8217086Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8217086Ch case    4:*/		return 0x82170870;
		  /* 82170870h */ case    5:  		/* bc 4, CR6_EQ, -148 */
		/* 82170870h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821707DC;  }
		/* 82170870h case    5:*/		return 0x82170874;
	}
	return 0x82170874;
} // Block from 8217085Ch-82170874h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82170874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170874);
		  /* 82170874h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82170874h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82170874h case    0:*/		return 0x82170878;
		  /* 82170878h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170878h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170878h case    1:*/		return 0x8217087C;
		  /* 8217087Ch */ case    2:  		/* bc 4, CR0_EQ, 440 */
		/* 8217087Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x82170A34;  }
		/* 8217087Ch case    2:*/		return 0x82170880;
		  /* 82170880h */ case    3:  		/* mr R29, R11 */
		/* 82170880h case    3:*/		regs.R29 = regs.R11;
		/* 82170880h case    3:*/		return 0x82170884;
		  /* 82170884h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82170884h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82170884h case    4:*/		return 0x82170888;
		  /* 82170888h */ case    5:  		/* bc 12, CR0_EQ, 428 */
		/* 82170888h case    5:*/		if ( regs.CR[0].eq ) { return 0x82170A34;  }
		/* 82170888h case    5:*/		return 0x8217088C;
		  /* 8217088Ch */ case    6:  		/* lwz R11, <#[R29 + 28]> */
		/* 8217088Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 8217088Ch case    6:*/		return 0x82170890;
		  /* 82170890h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170890h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170890h case    7:*/		return 0x82170894;
		  /* 82170894h */ case    8:  		/* bc 4, CR0_EQ, 388 */
		/* 82170894h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82170A18;  }
		/* 82170894h case    8:*/		return 0x82170898;
		  /* 82170898h */ case    9:  		/* mr R30, R11 */
		/* 82170898h case    9:*/		regs.R30 = regs.R11;
		/* 82170898h case    9:*/		return 0x8217089C;
		  /* 8217089Ch */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 8217089Ch case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8217089Ch case   10:*/		return 0x821708A0;
		  /* 821708A0h */ case   11:  		/* bc 12, CR0_EQ, 376 */
		/* 821708A0h case   11:*/		if ( regs.CR[0].eq ) { return 0x82170A18;  }
		/* 821708A0h case   11:*/		return 0x821708A4;
		  /* 821708A4h */ case   12:  		/* lwz R10, <#[R30 + 8]> */
		/* 821708A4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821708A4h case   12:*/		return 0x821708A8;
		  /* 821708A8h */ case   13:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821708A8h case   13:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821708A8h case   13:*/		return 0x821708AC;
		  /* 821708ACh */ case   14:  		/* cmplwi CR6, R11, 83 */
		/* 821708ACh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000053);
		/* 821708ACh case   14:*/		return 0x821708B0;
		  /* 821708B0h */ case   15:  		/* bc 12, CR6_EQ, 304 */
		/* 821708B0h case   15:*/		if ( regs.CR[6].eq ) { return 0x821709E0;  }
		/* 821708B0h case   15:*/		return 0x821708B4;
		  /* 821708B4h */ case   16:  		/* cmplwi CR6, R11, 91 */
		/* 821708B4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005B);
		/* 821708B4h case   16:*/		return 0x821708B8;
		  /* 821708B8h */ case   17:  		/* bc 12, CR6_LT, 16 */
		/* 821708B8h case   17:*/		if ( regs.CR[6].lt ) { return 0x821708C8;  }
		/* 821708B8h case   17:*/		return 0x821708BC;
		  /* 821708BCh */ case   18:  		/* cmplwi CR6, R11, 94 */
		/* 821708BCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005E);
		/* 821708BCh case   18:*/		return 0x821708C0;
		  /* 821708C0h */ case   19:  		/* li R11, 1 */
		/* 821708C0h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821708C0h case   19:*/		return 0x821708C4;
		  /* 821708C4h */ case   20:  		/* bc 4, CR6_GT, 8 */
		/* 821708C4h case   20:*/		if ( !regs.CR[6].gt ) { return 0x821708CC;  }
		/* 821708C4h case   20:*/		return 0x821708C8;
	}
	return 0x821708C8;
} // Block from 82170874h-821708C8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821708C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821708C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821708C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821708C8);
		  /* 821708C8h */ case    0:  		/* li R11, 0 */
		/* 821708C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821708C8h case    0:*/		return 0x821708CC;
	}
	return 0x821708CC;
} // Block from 821708C8h-821708CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821708CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821708CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821708CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821708CC);
		  /* 821708CCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821708CCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821708CCh case    0:*/		return 0x821708D0;
		  /* 821708D0h */ case    1:  		/* bc 4, CR0_EQ, 272 */
		/* 821708D0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821709E0;  }
		/* 821708D0h case    1:*/		return 0x821708D4;
		  /* 821708D4h */ case    2:  		/* rlwinm. R11, R10, 27, 31, 31 */
		/* 821708D4h case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R10);
		/* 821708D4h case    2:*/		return 0x821708D8;
		  /* 821708D8h */ case    3:  		/* bc 12, CR0_EQ, 292 */
		/* 821708D8h case    3:*/		if ( regs.CR[0].eq ) { return 0x821709FC;  }
		/* 821708D8h case    3:*/		return 0x821708DC;
		  /* 821708DCh */ case    4:  		/* lwz R11, <#[R30 + 4]> */
		/* 821708DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821708DCh case    4:*/		return 0x821708E0;
		  /* 821708E0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821708E0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821708E0h case    5:*/		return 0x821708E4;
		  /* 821708E4h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 821708E4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821708FC;  }
		/* 821708E4h case    6:*/		return 0x821708E8;
		  /* 821708E8h */ case    7:  		/* lwz R9, <#[R11]> */
		/* 821708E8h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821708E8h case    7:*/		return 0x821708EC;
		  /* 821708ECh */ case    8:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 821708ECh case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 821708ECh case    8:*/		return 0x821708F0;
		  /* 821708F0h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 821708F0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821708FC;  }
		/* 821708F0h case    9:*/		return 0x821708F4;
		  /* 821708F4h */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 821708F4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821708F4h case   10:*/		return 0x821708F8;
		  /* 821708F8h */ case   11:  		/* b -24 */
		/* 821708F8h case   11:*/		return 0x821708E0;
		/* 821708F8h case   11:*/		return 0x821708FC;
	}
	return 0x821708FC;
} // Block from 821708CCh-821708FCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821708FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821708FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821708FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821708FC);
		  /* 821708FCh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821708FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821708FCh case    0:*/		return 0x82170900;
		  /* 82170900h */ case    1:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 82170900h case    1:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 82170900h case    1:*/		return 0x82170904;
		  /* 82170904h */ case    2:  		/* cmplwi CR6, R11, 32 */
		/* 82170904h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82170904h case    2:*/		return 0x82170908;
		  /* 82170908h */ case    3:  		/* bc 12, CR6_LT, 244 */
		/* 82170908h case    3:*/		if ( regs.CR[6].lt ) { return 0x821709FC;  }
		/* 82170908h case    3:*/		return 0x8217090C;
		  /* 8217090Ch */ case    4:  		/* cmplwi CR6, R11, 37 */
		/* 8217090Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000025);
		/* 8217090Ch case    4:*/		return 0x82170910;
		  /* 82170910h */ case    5:  		/* bc 4, CR6_GT, 20 */
		/* 82170910h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82170924;  }
		/* 82170910h case    5:*/		return 0x82170914;
		  /* 82170914h */ case    6:  		/* cmplwi CR6, R11, 61 */
		/* 82170914h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003D);
		/* 82170914h case    6:*/		return 0x82170918;
		  /* 82170918h */ case    7:  		/* bc 4, CR6_GT, 228 */
		/* 82170918h case    7:*/		if ( !regs.CR[6].gt ) { return 0x821709FC;  }
		/* 82170918h case    7:*/		return 0x8217091C;
		  /* 8217091Ch */ case    8:  		/* cmplwi CR6, R11, 63 */
		/* 8217091Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003F);
		/* 8217091Ch case    8:*/		return 0x82170920;
		  /* 82170920h */ case    9:  		/* bc 12, CR6_GT, 220 */
		/* 82170920h case    9:*/		if ( regs.CR[6].gt ) { return 0x821709FC;  }
		/* 82170920h case    9:*/		return 0x82170924;
	}
	return 0x82170924;
} // Block from 821708FCh-82170924h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82170924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170924);
		  /* 82170924h */ case    0:  		/* oris R11, R10, 1024 */
		/* 82170924h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x400);
		/* 82170924h case    0:*/		return 0x82170928;
		  /* 82170928h */ case    1:  		/* li R6, 0 */
		/* 82170928h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82170928h case    1:*/		return 0x8217092C;
		  /* 8217092Ch */ case    2:  		/* stw R11, <#[R30 + 8]> */
		/* 8217092Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8217092Ch case    2:*/		return 0x82170930;
		  /* 82170930h */ case    3:  		/* li R5, 0 */
		/* 82170930h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82170930h case    3:*/		return 0x82170934;
		  /* 82170934h */ case    4:  		/* mr R4, R30 */
		/* 82170934h case    4:*/		regs.R4 = regs.R30;
		/* 82170934h case    4:*/		return 0x82170938;
		  /* 82170938h */ case    5:  		/* mr R3, R28 */
		/* 82170938h case    5:*/		regs.R3 = regs.R28;
		/* 82170938h case    5:*/		return 0x8217093C;
		  /* 8217093Ch */ case    6:  		/* bl 769020 */
		/* 8217093Ch case    6:*/		regs.LR = 0x82170940; return 0x8222C538;
		/* 8217093Ch case    6:*/		return 0x82170940;
		  /* 82170940h */ case    7:  		/* lwz R31, <#[R30]> */
		/* 82170940h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82170940h case    7:*/		return 0x82170944;
		  /* 82170944h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 82170944h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82170944h case    8:*/		return 0x82170948;
		  /* 82170948h */ case    9:  		/* bc 12, CR6_EQ, 64 */
		/* 82170948h case    9:*/		if ( regs.CR[6].eq ) { return 0x82170988;  }
		/* 82170948h case    9:*/		return 0x8217094C;
		  /* 8217094Ch */ case   10:  		/* lwz R11, <#[R31]> */
		/* 8217094Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8217094Ch case   10:*/		return 0x82170950;
		  /* 82170950h */ case   11:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82170950h case   11:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82170950h case   11:*/		return 0x82170954;
		  /* 82170954h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 82170954h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82170964;  }
		/* 82170954h case   12:*/		return 0x82170958;
		  /* 82170958h */ case   13:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82170958h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82170958h case   13:*/		return 0x8217095C;
		  /* 8217095Ch */ case   14:  		/* li R11, 1 */
		/* 8217095Ch case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8217095Ch case   14:*/		return 0x82170960;
		  /* 82170960h */ case   15:  		/* bc 12, CR0_EQ, 8 */
		/* 82170960h case   15:*/		if ( regs.CR[0].eq ) { return 0x82170968;  }
		/* 82170960h case   15:*/		return 0x82170964;
	}
	return 0x82170964;
} // Block from 82170924h-82170964h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82170964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170964);
		  /* 82170964h */ case    0:  		/* li R11, 0 */
		/* 82170964h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82170964h case    0:*/		return 0x82170968;
	}
	return 0x82170968;
} // Block from 82170964h-82170968h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170968);
		  /* 82170968h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82170968h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82170968h case    0:*/		return 0x8217096C;
		  /* 8217096Ch */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 8217096Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82170980;  }
		/* 8217096Ch case    1:*/		return 0x82170970;
		  /* 82170970h */ case    2:  		/* li R5, 0 */
		/* 82170970h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82170970h case    2:*/		return 0x82170974;
		  /* 82170974h */ case    3:  		/* mr R4, R31 */
		/* 82170974h case    3:*/		regs.R4 = regs.R31;
		/* 82170974h case    3:*/		return 0x82170978;
		  /* 82170978h */ case    4:  		/* mr R3, R28 */
		/* 82170978h case    4:*/		regs.R3 = regs.R28;
		/* 82170978h case    4:*/		return 0x8217097C;
		  /* 8217097Ch */ case    5:  		/* bl 775148 */
		/* 8217097Ch case    5:*/		regs.LR = 0x82170980; return 0x8222DD68;
		/* 8217097Ch case    5:*/		return 0x82170980;
	}
	return 0x82170980;
} // Block from 82170968h-82170980h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82170980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170980);
		  /* 82170980h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 82170980h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 82170980h case    0:*/		return 0x82170984;
		  /* 82170984h */ case    1:  		/* b -64 */
		/* 82170984h case    1:*/		return 0x82170944;
		/* 82170984h case    1:*/		return 0x82170988;
	}
	return 0x82170988;
} // Block from 82170980h-82170988h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170988);
		  /* 82170988h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 82170988h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82170988h case    0:*/		return 0x8217098C;
		  /* 8217098Ch */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8217098Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8217098Ch case    1:*/		return 0x82170990;
		  /* 82170990h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 82170990h case    2:*/		if ( regs.CR[6].eq ) { return 0x821709FC;  }
		/* 82170990h case    2:*/		return 0x82170994;
		  /* 82170994h */ case    3:  		/* lwz R9, <#[R10 + 16]> */
		/* 82170994h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 82170994h case    3:*/		return 0x82170998;
		  /* 82170998h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82170998h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82170998h case    4:*/		return 0x8217099C;
		  /* 8217099Ch */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 8217099Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821709D8;  }
		/* 8217099Ch case    5:*/		return 0x821709A0;
		  /* 821709A0h */ case    6:  		/* lwz R11, <#[R10]> */
		/* 821709A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821709A0h case    6:*/		return 0x821709A4;
		  /* 821709A4h */ case    7:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821709A4h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821709A4h case    7:*/		return 0x821709A8;
		  /* 821709A8h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 821709A8h case    8:*/		if ( regs.CR[0].eq ) { return 0x821709C0;  }
		/* 821709A8h case    8:*/		return 0x821709AC;
		  /* 821709ACh */ case    9:  		/* lwz R11, <#[R10 + 12]> */
		/* 821709ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 821709ACh case    9:*/		return 0x821709B0;
		  /* 821709B0h */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 821709B0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821709B0h case   10:*/		return 0x821709B4;
		  /* 821709B4h */ case   11:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 821709B4h case   11:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821709B4h case   11:*/		return 0x821709B8;
		  /* 821709B8h */ case   12:  		/* li R11, 1 */
		/* 821709B8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821709B8h case   12:*/		return 0x821709BC;
		  /* 821709BCh */ case   13:  		/* bc 4, CR0_EQ, 8 */
		/* 821709BCh case   13:*/		if ( !regs.CR[0].eq ) { return 0x821709C4;  }
		/* 821709BCh case   13:*/		return 0x821709C0;
	}
	return 0x821709C0;
} // Block from 82170988h-821709C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821709C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821709C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821709C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821709C0);
		  /* 821709C0h */ case    0:  		/* li R11, 0 */
		/* 821709C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821709C0h case    0:*/		return 0x821709C4;
	}
	return 0x821709C4;
} // Block from 821709C0h-821709C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821709C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821709C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821709C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821709C4);
		  /* 821709C4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821709C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821709C4h case    0:*/		return 0x821709C8;
		  /* 821709C8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821709C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821709D8;  }
		/* 821709C8h case    1:*/		return 0x821709CC;
		  /* 821709CCh */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 821709CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821709CCh case    2:*/		return 0x821709D0;
		  /* 821709D0h */ case    3:  		/* oris R11, R11, 1024 */
		/* 821709D0h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821709D0h case    3:*/		return 0x821709D4;
		  /* 821709D4h */ case    4:  		/* stw R11, <#[R9 + 8]> */
		/* 821709D4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821709D4h case    4:*/		return 0x821709D8;
	}
	return 0x821709D8;
} // Block from 821709C4h-821709D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821709D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821709D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821709D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821709D8);
		  /* 821709D8h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821709D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821709D8h case    0:*/		return 0x821709DC;
		  /* 821709DCh */ case    1:  		/* b -80 */
		/* 821709DCh case    1:*/		return 0x8217098C;
		/* 821709DCh case    1:*/		return 0x821709E0;
	}
	return 0x821709E0;
} // Block from 821709D8h-821709E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821709E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821709E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821709E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821709E0);
		  /* 821709E0h */ case    0:  		/* oris R11, R10, 1024 */
		/* 821709E0h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x400);
		/* 821709E0h case    0:*/		return 0x821709E4;
		  /* 821709E4h */ case    1:  		/* li R6, 0 */
		/* 821709E4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821709E4h case    1:*/		return 0x821709E8;
		  /* 821709E8h */ case    2:  		/* stw R11, <#[R30 + 8]> */
		/* 821709E8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821709E8h case    2:*/		return 0x821709EC;
		  /* 821709ECh */ case    3:  		/* li R5, 0 */
		/* 821709ECh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821709ECh case    3:*/		return 0x821709F0;
		  /* 821709F0h */ case    4:  		/* mr R4, R30 */
		/* 821709F0h case    4:*/		regs.R4 = regs.R30;
		/* 821709F0h case    4:*/		return 0x821709F4;
		  /* 821709F4h */ case    5:  		/* mr R3, R28 */
		/* 821709F4h case    5:*/		regs.R3 = regs.R28;
		/* 821709F4h case    5:*/		return 0x821709F8;
		  /* 821709F8h */ case    6:  		/* bl 768832 */
		/* 821709F8h case    6:*/		regs.LR = 0x821709FC; return 0x8222C538;
		/* 821709F8h case    6:*/		return 0x821709FC;
	}
	return 0x821709FC;
} // Block from 821709E0h-821709FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821709FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821709FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821709FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821709FC);
		  /* 821709FCh */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821709FCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821709FCh case    0:*/		return 0x82170A00;
		  /* 82170A00h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82170A00h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82170A00h case    1:*/		return 0x82170A04;
		  /* 82170A04h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170A04h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170A04h case    2:*/		return 0x82170A08;
		  /* 82170A08h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82170A08h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82170A18;  }
		/* 82170A08h case    3:*/		return 0x82170A0C;
		  /* 82170A0Ch */ case    4:  		/* mr R30, R11 */
		/* 82170A0Ch case    4:*/		regs.R30 = regs.R11;
		/* 82170A0Ch case    4:*/		return 0x82170A10;
		  /* 82170A10h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82170A10h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82170A10h case    5:*/		return 0x82170A14;
		  /* 82170A14h */ case    6:  		/* bc 4, CR6_EQ, -368 */
		/* 82170A14h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821708A4;  }
		/* 82170A14h case    6:*/		return 0x82170A18;
	}
	return 0x82170A18;
} // Block from 821709FCh-82170A18h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82170A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170A18);
		  /* 82170A18h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82170A18h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82170A18h case    0:*/		return 0x82170A1C;
		  /* 82170A1Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82170A1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82170A1Ch case    1:*/		return 0x82170A20;
		  /* 82170A20h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170A20h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170A20h case    2:*/		return 0x82170A24;
		  /* 82170A24h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82170A24h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82170A34;  }
		/* 82170A24h case    3:*/		return 0x82170A28;
		  /* 82170A28h */ case    4:  		/* mr R29, R11 */
		/* 82170A28h case    4:*/		regs.R29 = regs.R11;
		/* 82170A28h case    4:*/		return 0x82170A2C;
		  /* 82170A2Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82170A2Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82170A2Ch case    5:*/		return 0x82170A30;
		  /* 82170A30h */ case    6:  		/* bc 4, CR6_EQ, -420 */
		/* 82170A30h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8217088C;  }
		/* 82170A30h case    6:*/		return 0x82170A34;
	}
	return 0x82170A34;
} // Block from 82170A18h-82170A34h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82170A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170A34);
		  /* 82170A34h */ case    0:  		/* addi R1, R1, 128 */
		/* 82170A34h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82170A34h case    0:*/		return 0x82170A38;
		  /* 82170A38h */ case    1:  		/* b -915344 */
		/* 82170A38h case    1:*/		return 0x820912A8;
		/* 82170A38h case    1:*/		return 0x82170A3C;
		  /* 82170A3Ch */ case    2:  		/* nop */
		/* 82170A3Ch case    2:*/		cpu::op::nop();
		/* 82170A3Ch case    2:*/		return 0x82170A40;
	}
	return 0x82170A40;
} // Block from 82170A34h-82170A40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170A40h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170A40);
		  /* 82170A40h */ case    0:  		/* mfspr R12, LR */
		/* 82170A40h case    0:*/		regs.R12 = regs.LR;
		/* 82170A40h case    0:*/		return 0x82170A44;
		  /* 82170A44h */ case    1:  		/* bl -915444 */
		/* 82170A44h case    1:*/		regs.LR = 0x82170A48; return 0x82091250;
		/* 82170A44h case    1:*/		return 0x82170A48;
		  /* 82170A48h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82170A48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82170A48h case    2:*/		return 0x82170A4C;
		  /* 82170A4Ch */ case    3:  		/* mr R31, R3 */
		/* 82170A4Ch case    3:*/		regs.R31 = regs.R3;
		/* 82170A4Ch case    3:*/		return 0x82170A50;
		  /* 82170A50h */ case    4:  		/* bl -664 */
		/* 82170A50h case    4:*/		regs.LR = 0x82170A54; return 0x821707B8;
		/* 82170A50h case    4:*/		return 0x82170A54;
		  /* 82170A54h */ case    5:  		/* lwz R4, <#[R31 + 4]> */
		/* 82170A54h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 82170A54h case    5:*/		return 0x82170A58;
		  /* 82170A58h */ case    6:  		/* addi R11, R1, 88 */
		/* 82170A58h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 82170A58h case    6:*/		return 0x82170A5C;
		  /* 82170A5Ch */ case    7:  		/* addi R10, R1, 92 */
		/* 82170A5Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 82170A5Ch case    7:*/		return 0x82170A60;
		  /* 82170A60h */ case    8:  		/* rlwinm R30, R4, 0, 31, 31 */
		/* 82170A60h case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R30,regs.R4);
		/* 82170A60h case    8:*/		return 0x82170A64;
		  /* 82170A64h */ case    9:  		/* ori R11, R11, 1 */
		/* 82170A64h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82170A64h case    9:*/		return 0x82170A68;
		  /* 82170A68h */ case   10:  		/* addic R30, R30, -1 */
		/* 82170A68h case   10:*/		cpu::op::addic<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82170A68h case   10:*/		return 0x82170A6C;
		  /* 82170A6Ch */ case   11:  		/* ori R10, R10, 1 */
		/* 82170A6Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82170A6Ch case   11:*/		return 0x82170A70;
		  /* 82170A70h */ case   12:  		/* subfe R30, R30, R30 */
		/* 82170A70h case   12:*/		cpu::op::subfe<0>(regs,&regs.R30,regs.R30,regs.R30);
		/* 82170A70h case   12:*/		return 0x82170A74;
		  /* 82170A74h */ case   13:  		/* mr R3, R31 */
		/* 82170A74h case   13:*/		regs.R3 = regs.R31;
		/* 82170A74h case   13:*/		return 0x82170A78;
		  /* 82170A78h */ case   14:  		/* and R29, R30, R4 */
		/* 82170A78h case   14:*/		cpu::op::and<0>(regs,&regs.R29,regs.R30,regs.R4);
		/* 82170A78h case   14:*/		return 0x82170A7C;
		  /* 82170A7Ch */ case   15:  		/* li R9, 0 */
		/* 82170A7Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82170A7Ch case   15:*/		return 0x82170A80;
		  /* 82170A80h */ case   16:  		/* rlwinm R4, R29, 0, 0, 30 */
		/* 82170A80h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R4,regs.R29);
		/* 82170A80h case   16:*/		return 0x82170A84;
		  /* 82170A84h */ case   17:  		/* addi R8, R1, 80 */
		/* 82170A84h case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82170A84h case   17:*/		return 0x82170A88;
		  /* 82170A88h */ case   18:  		/* addi R7, R1, 88 */
		/* 82170A88h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 82170A88h case   18:*/		return 0x82170A8C;
		  /* 82170A8Ch */ case   19:  		/* li R6, 1 */
		/* 82170A8Ch case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82170A8Ch case   19:*/		return 0x82170A90;
		  /* 82170A90h */ case   20:  		/* li R5, 0 */
		/* 82170A90h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82170A90h case   20:*/		return 0x82170A94;
		  /* 82170A94h */ case   21:  		/* lwz R4, <#[R4 + 4]> */
		/* 82170A94h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82170A94h case   21:*/		return 0x82170A98;
		  /* 82170A98h */ case   22:  		/* stw R11, <#[R1 + 92]> */
		/* 82170A98h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82170A98h case   22:*/		return 0x82170A9C;
		  /* 82170A9Ch */ case   23:  		/* stw R10, <#[R1 + 88]> */
		/* 82170A9Ch case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82170A9Ch case   23:*/		return 0x82170AA0;
		  /* 82170AA0h */ case   24:  		/* rlwinm R11, R4, 0, 31, 31 */
		/* 82170AA0h case   24:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R4);
		/* 82170AA0h case   24:*/		return 0x82170AA4;
		  /* 82170AA4h */ case   25:  		/* addic R11, R11, -1 */
		/* 82170AA4h case   25:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82170AA4h case   25:*/		return 0x82170AA8;
		  /* 82170AA8h */ case   26:  		/* subfe R11, R11, R11 */
		/* 82170AA8h case   26:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82170AA8h case   26:*/		return 0x82170AAC;
		  /* 82170AACh */ case   27:  		/* and R4, R11, R4 */
		/* 82170AACh case   27:*/		cpu::op::and<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 82170AACh case   27:*/		return 0x82170AB0;
		  /* 82170AB0h */ case   28:  		/* bl 366792 */
		/* 82170AB0h case   28:*/		regs.LR = 0x82170AB4; return 0x821CA378;
		/* 82170AB0h case   28:*/		return 0x82170AB4;
		  /* 82170AB4h */ case   29:  		/* lwz R11, <#[R1 + 92]> */
		/* 82170AB4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82170AB4h case   29:*/		return 0x82170AB8;
		  /* 82170AB8h */ case   30:  		/* mr R3, R31 */
		/* 82170AB8h case   30:*/		regs.R3 = regs.R31;
		/* 82170AB8h case   30:*/		return 0x82170ABC;
		  /* 82170ABCh */ case   31:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82170ABCh case   31:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170ABCh case   31:*/		return 0x82170AC0;
		  /* 82170AC0h */ case   32:  		/* addi R4, R1, 88 */
		/* 82170AC0h case   32:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82170AC0h case   32:*/		return 0x82170AC4;
		  /* 82170AC4h */ case   33:  		/* addic R10, R10, -1 */
		/* 82170AC4h case   33:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82170AC4h case   33:*/		return 0x82170AC8;
		  /* 82170AC8h */ case   34:  		/* subfe R10, R10, R10 */
		/* 82170AC8h case   34:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82170AC8h case   34:*/		return 0x82170ACC;
		  /* 82170ACCh */ case   35:  		/* and R30, R10, R11 */
		/* 82170ACCh case   35:*/		cpu::op::and<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 82170ACCh case   35:*/		return 0x82170AD0;
		  /* 82170AD0h */ case   36:  		/* lwz R11, <#[R30 + 76]> */
		/* 82170AD0h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 82170AD0h case   36:*/		return 0x82170AD4;
		  /* 82170AD4h */ case   37:  		/* oris R11, R11, 32 */
		/* 82170AD4h case   37:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82170AD4h case   37:*/		return 0x82170AD8;
		  /* 82170AD8h */ case   38:  		/* stw R11, <#[R30 + 76]> */
		/* 82170AD8h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 82170AD8h case   38:*/		return 0x82170ADC;
		  /* 82170ADCh */ case   39:  		/* bl 512908 */
		/* 82170ADCh case   39:*/		regs.LR = 0x82170AE0; return 0x821EDE68;
		/* 82170ADCh case   39:*/		return 0x82170AE0;
		  /* 82170AE0h */ case   40:  		/* mr R5, R31 */
		/* 82170AE0h case   40:*/		regs.R5 = regs.R31;
		/* 82170AE0h case   40:*/		return 0x82170AE4;
		  /* 82170AE4h */ case   41:  		/* mr R3, R29 */
		/* 82170AE4h case   41:*/		regs.R3 = regs.R29;
		/* 82170AE4h case   41:*/		return 0x82170AE8;
		  /* 82170AE8h */ case   42:  		/* mr R4, R30 */
		/* 82170AE8h case   42:*/		regs.R4 = regs.R30;
		/* 82170AE8h case   42:*/		return 0x82170AEC;
		  /* 82170AECh */ case   43:  		/* bl 782324 */
		/* 82170AECh case   43:*/		regs.LR = 0x82170AF0; return 0x8222FAE0;
		/* 82170AECh case   43:*/		return 0x82170AF0;
		  /* 82170AF0h */ case   44:  		/* addi R28, R29, 24 */
		/* 82170AF0h case   44:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x18);
		/* 82170AF0h case   44:*/		return 0x82170AF4;
		  /* 82170AF4h */ case   45:  		/* mr R4, R29 */
		/* 82170AF4h case   45:*/		regs.R4 = regs.R29;
		/* 82170AF4h case   45:*/		return 0x82170AF8;
		  /* 82170AF8h */ case   46:  		/* mr R5, R28 */
		/* 82170AF8h case   46:*/		regs.R5 = regs.R28;
		/* 82170AF8h case   46:*/		return 0x82170AFC;
		  /* 82170AFCh */ case   47:  		/* mr R3, R31 */
		/* 82170AFCh case   47:*/		regs.R3 = regs.R31;
		/* 82170AFCh case   47:*/		return 0x82170B00;
		  /* 82170B00h */ case   48:  		/* li R8, 0 */
		/* 82170B00h case   48:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82170B00h case   48:*/		return 0x82170B04;
		  /* 82170B04h */ case   49:  		/* li R7, 0 */
		/* 82170B04h case   49:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82170B04h case   49:*/		return 0x82170B08;
		  /* 82170B08h */ case   50:  		/* li R6, 120 */
		/* 82170B08h case   50:*/		cpu::op::li<0>(regs,&regs.R6,0x78);
		/* 82170B08h case   50:*/		return 0x82170B0C;
		  /* 82170B0Ch */ case   51:  		/* bl 736908 */
		/* 82170B0Ch case   51:*/		regs.LR = 0x82170B10; return 0x82224998;
		/* 82170B0Ch case   51:*/		return 0x82170B10;
		  /* 82170B10h */ case   52:  		/* mr R27, R3 */
		/* 82170B10h case   52:*/		regs.R27 = regs.R3;
		/* 82170B10h case   52:*/		return 0x82170B14;
		  /* 82170B14h */ case   53:  		/* mr R3, R31 */
		/* 82170B14h case   53:*/		regs.R3 = regs.R31;
		/* 82170B14h case   53:*/		return 0x82170B18;
		  /* 82170B18h */ case   54:  		/* li R8, 0 */
		/* 82170B18h case   54:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82170B18h case   54:*/		return 0x82170B1C;
		  /* 82170B1Ch */ case   55:  		/* li R7, 1 */
		/* 82170B1Ch case   55:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82170B1Ch case   55:*/		return 0x82170B20;
		  /* 82170B20h */ case   56:  		/* li R6, 90 */
		/* 82170B20h case   56:*/		cpu::op::li<0>(regs,&regs.R6,0x5A);
		/* 82170B20h case   56:*/		return 0x82170B24;
		  /* 82170B24h */ case   57:  		/* lwz R11, <#[R27 + 8]> */
		/* 82170B24h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82170B24h case   57:*/		return 0x82170B28;
		  /* 82170B28h */ case   58:  		/* mr R5, R28 */
		/* 82170B28h case   58:*/		regs.R5 = regs.R28;
		/* 82170B28h case   58:*/		return 0x82170B2C;
		  /* 82170B2Ch */ case   59:  		/* mr R4, R29 */
		/* 82170B2Ch case   59:*/		regs.R4 = regs.R29;
		/* 82170B2Ch case   59:*/		return 0x82170B30;
		  /* 82170B30h */ case   60:  		/* oris R11, R11, 256 */
		/* 82170B30h case   60:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82170B30h case   60:*/		return 0x82170B34;
		  /* 82170B34h */ case   61:  		/* ori R11, R11, 64 */
		/* 82170B34h case   61:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82170B34h case   61:*/		return 0x82170B38;
		  /* 82170B38h */ case   62:  		/* stw R11, <#[R27 + 8]> */
		/* 82170B38h case   62:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82170B38h case   62:*/		return 0x82170B3C;
		  /* 82170B3Ch */ case   63:  		/* bl 736860 */
		/* 82170B3Ch case   63:*/		regs.LR = 0x82170B40; return 0x82224998;
		/* 82170B3Ch case   63:*/		return 0x82170B40;
		  /* 82170B40h */ case   64:  		/* mr R28, R3 */
		/* 82170B40h case   64:*/		regs.R28 = regs.R3;
		/* 82170B40h case   64:*/		return 0x82170B44;
		  /* 82170B44h */ case   65:  		/* mr R3, R31 */
		/* 82170B44h case   65:*/		regs.R3 = regs.R31;
		/* 82170B44h case   65:*/		return 0x82170B48;
		  /* 82170B48h */ case   66:  		/* li R5, 7 */
		/* 82170B48h case   66:*/		cpu::op::li<0>(regs,&regs.R5,0x7);
		/* 82170B48h case   66:*/		return 0x82170B4C;
		  /* 82170B4Ch */ case   67:  		/* mr R4, R27 */
		/* 82170B4Ch case   67:*/		regs.R4 = regs.R27;
		/* 82170B4Ch case   67:*/		return 0x82170B50;
		  /* 82170B50h */ case   68:  		/* bl -1024 */
		/* 82170B50h case   68:*/		regs.LR = 0x82170B54; return 0x82170750;
		/* 82170B50h case   68:*/		return 0x82170B54;
		  /* 82170B54h */ case   69:  		/* mr R4, R3 */
		/* 82170B54h case   69:*/		regs.R4 = regs.R3;
		/* 82170B54h case   69:*/		return 0x82170B58;
		  /* 82170B58h */ case   70:  		/* mr R3, R28 */
		/* 82170B58h case   70:*/		regs.R3 = regs.R28;
		/* 82170B58h case   70:*/		return 0x82170B5C;
		  /* 82170B5Ch */ case   71:  		/* bl 30316 */
		/* 82170B5Ch case   71:*/		regs.LR = 0x82170B60; return 0x821781C8;
		/* 82170B5Ch case   71:*/		return 0x82170B60;
		  /* 82170B60h */ case   72:  		/* lwz R11, <#[R28 + 8]> */
		/* 82170B60h case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82170B60h case   72:*/		return 0x82170B64;
		  /* 82170B64h */ case   73:  		/* li R26, 1 */
		/* 82170B64h case   73:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82170B64h case   73:*/		return 0x82170B68;
		  /* 82170B68h */ case   74:  		/* stw R3, <#[R28 + 44]> */
		/* 82170B68h case   74:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 82170B68h case   74:*/		return 0x82170B6C;
		  /* 82170B6Ch */ case   75:  		/* mr R3, R31 */
		/* 82170B6Ch case   75:*/		regs.R3 = regs.R31;
		/* 82170B6Ch case   75:*/		return 0x82170B70;
		  /* 82170B70h */ case   76:  		/* rlwimi R11, R26, 17, 13, 14 */
		/* 82170B70h case   76:*/		cpu::op::rlwimi<0,17,13,14>(regs,&regs.R11,regs.R26);
		/* 82170B70h case   76:*/		return 0x82170B74;
		  /* 82170B74h */ case   77:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82170B74h case   77:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82170B74h case   77:*/		return 0x82170B78;
		  /* 82170B78h */ case   78:  		/* stw R11, <#[R28 + 8]> */
		/* 82170B78h case   78:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82170B78h case   78:*/		return 0x82170B7C;
		  /* 82170B7Ch */ case   79:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82170B7Ch case   79:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82170B7Ch case   79:*/		return 0x82170B80;
		  /* 82170B80h */ case   80:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82170B80h case   80:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82170B80h case   80:*/		return 0x82170B84;
		  /* 82170B84h */ case   81:  		/* bl -51028 */
		/* 82170B84h case   81:*/		regs.LR = 0x82170B88; return 0x82164430;
		/* 82170B84h case   81:*/		return 0x82170B88;
		  /* 82170B88h */ case   82:  		/* addi R11, R28, -16 */
		/* 82170B88h case   82:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFF0);
		/* 82170B88h case   82:*/		return 0x82170B8C;
		  /* 82170B8Ch */ case   83:  		/* stwx R30, <#[R3 + R11]> */
		/* 82170B8Ch case   83:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82170B8Ch case   83:*/		return 0x82170B90;
		  /* 82170B90h */ case   84:  		/* lwz R11, <#[R28 + 8]> */
		/* 82170B90h case   84:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82170B90h case   84:*/		return 0x82170B94;
		  /* 82170B94h */ case   85:  		/* mr R3, R31 */
		/* 82170B94h case   85:*/		regs.R3 = regs.R31;
		/* 82170B94h case   85:*/		return 0x82170B98;
		  /* 82170B98h */ case   86:  		/* oris R11, R11, 256 */
		/* 82170B98h case   86:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82170B98h case   86:*/		return 0x82170B9C;
		  /* 82170B9Ch */ case   87:  		/* stw R11, <#[R28 + 8]> */
		/* 82170B9Ch case   87:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82170B9Ch case   87:*/		return 0x82170BA0;
		  /* 82170BA0h */ case   88:  		/* lwz R11, <#[R29 + 48]> */
		/* 82170BA0h case   88:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 82170BA0h case   88:*/		return 0x82170BA4;
		  /* 82170BA4h */ case   89:  		/* oris R11, R11, 3072 */
		/* 82170BA4h case   89:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0xC00);
		/* 82170BA4h case   89:*/		return 0x82170BA8;
		  /* 82170BA8h */ case   90:  		/* stw R11, <#[R29 + 48]> */
		/* 82170BA8h case   90:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 82170BA8h case   90:*/		return 0x82170BAC;
		  /* 82170BACh */ case   91:  		/* bl 501620 */
		/* 82170BACh case   91:*/		regs.LR = 0x82170BB0; return 0x821EB320;
		/* 82170BACh case   91:*/		return 0x82170BB0;
		  /* 82170BB0h */ case   92:  		/* mr R5, R30 */
		/* 82170BB0h case   92:*/		regs.R5 = regs.R30;
		/* 82170BB0h case   92:*/		return 0x82170BB4;
		  /* 82170BB4h */ case   93:  		/* mr R3, R31 */
		/* 82170BB4h case   93:*/		regs.R3 = regs.R31;
		/* 82170BB4h case   93:*/		return 0x82170BB8;
		  /* 82170BB8h */ case   94:  		/* lwz R4, <#[R1 + 80]> */
		/* 82170BB8h case   94:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82170BB8h case   94:*/		return 0x82170BBC;
		  /* 82170BBCh */ case   95:  		/* bl 324524 */
		/* 82170BBCh case   95:*/		regs.LR = 0x82170BC0; return 0x821BFF68;
		/* 82170BBCh case   95:*/		return 0x82170BC0;
		  /* 82170BC0h */ case   96:  		/* lwz R11, <#[R30 + 28]> */
		/* 82170BC0h case   96:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82170BC0h case   96:*/		return 0x82170BC4;
		  /* 82170BC4h */ case   97:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170BC4h case   97:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170BC4h case   97:*/		return 0x82170BC8;
		  /* 82170BC8h */ case   98:  		/* bc 4, CR0_EQ, 208 */
		/* 82170BC8h case   98:*/		if ( !regs.CR[0].eq ) { return 0x82170C98;  }
		/* 82170BC8h case   98:*/		return 0x82170BCC;
		  /* 82170BCCh */ case   99:  		/* mr R28, R11 */
		/* 82170BCCh case   99:*/		regs.R28 = regs.R11;
		/* 82170BCCh case   99:*/		return 0x82170BD0;
		  /* 82170BD0h */ case  100:  		/* cmplwi CR0, R11, 0 */
		/* 82170BD0h case  100:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82170BD0h case  100:*/		return 0x82170BD4;
		  /* 82170BD4h */ case  101:  		/* bc 12, CR0_EQ, 196 */
		/* 82170BD4h case  101:*/		if ( regs.CR[0].eq ) { return 0x82170C98;  }
		/* 82170BD4h case  101:*/		return 0x82170BD8;
		  /* 82170BD8h */ case  102:  		/* lwz R11, <#[R28 + 8]> */
		/* 82170BD8h case  102:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82170BD8h case  102:*/		return 0x82170BDC;
		  /* 82170BDCh */ case  103:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82170BDCh case  103:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82170BDCh case  103:*/		return 0x82170BE0;
		  /* 82170BE0h */ case  104:  		/* cmplwi CR6, R11, 14336 */
		/* 82170BE0h case  104:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82170BE0h case  104:*/		return 0x82170BE4;
		  /* 82170BE4h */ case  105:  		/* bc 12, CR6_EQ, 152 */
		/* 82170BE4h case  105:*/		if ( regs.CR[6].eq ) { return 0x82170C7C;  }
		/* 82170BE4h case  105:*/		return 0x82170BE8;
		  /* 82170BE8h */ case  106:  		/* mr R27, R28 */
		/* 82170BE8h case  106:*/		regs.R27 = regs.R28;
		/* 82170BE8h case  106:*/		return 0x82170BEC;
		  /* 82170BECh */ case  107:  		/* lwz R29, <#[R27]> */
		/* 82170BECh case  107:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000000) );
		/* 82170BECh case  107:*/		return 0x82170BF0;
		  /* 82170BF0h */ case  108:  		/* cmplwi CR6, R29, 0 */
		/* 82170BF0h case  108:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82170BF0h case  108:*/		return 0x82170BF4;
		  /* 82170BF4h */ case  109:  		/* bc 12, CR6_EQ, 136 */
		/* 82170BF4h case  109:*/		if ( regs.CR[6].eq ) { return 0x82170C7C;  }
		/* 82170BF4h case  109:*/		return 0x82170BF8;
		  /* 82170BF8h */ case  110:  		/* lwz R11, <#[R29 + 12]> */
		/* 82170BF8h case  110:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82170BF8h case  110:*/		return 0x82170BFC;
		  /* 82170BFCh */ case  111:  		/* lwz R9, <#[R30 + 40]> */
		/* 82170BFCh case  111:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000028) );
		/* 82170BFCh case  111:*/		return 0x82170C00;
		  /* 82170C00h */ case  112:  		/* lwz R10, <#[R11 + 28]> */
		/* 82170C00h case  112:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82170C00h case  112:*/		return 0x82170C04;
		  /* 82170C04h */ case  113:  		/* lwz R11, <#[R10 + 48]> */
		/* 82170C04h case  113:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 82170C04h case  113:*/		return 0x82170C08;
		  /* 82170C08h */ case  114:  		/* rlwinm R8, R11, 0, 13, 31 */
		/* 82170C08h case  114:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R8,regs.R11);
		/* 82170C08h case  114:*/		return 0x82170C0C;
		  /* 82170C0Ch */ case  115:  		/* rlwinm R11, R8, 27, 5, 31 */
		/* 82170C0Ch case  115:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R8);
		/* 82170C0Ch case  115:*/		return 0x82170C10;
		  /* 82170C10h */ case  116:  		/* rlwinm R8, R8, 0, 27, 31 */
		/* 82170C10h case  116:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R8);
		/* 82170C10h case  116:*/		return 0x82170C14;
		  /* 82170C14h */ case  117:  		/* addi R11, R11, 1 */
		/* 82170C14h case  117:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82170C14h case  117:*/		return 0x82170C18;
		  /* 82170C18h */ case  118:  		/* slw R8, R26, R8 */
		/* 82170C18h case  118:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R26,regs.R8);
		/* 82170C18h case  118:*/		return 0x82170C1C;
		  /* 82170C1Ch */ case  119:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82170C1Ch case  119:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82170C1Ch case  119:*/		return 0x82170C20;
		  /* 82170C20h */ case  120:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82170C20h case  120:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82170C20h case  120:*/		return 0x82170C24;
		  /* 82170C24h */ case  121:  		/* and. R11, R11, R8 */
		/* 82170C24h case  121:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82170C24h case  121:*/		return 0x82170C28;
		  /* 82170C28h */ case  122:  		/* bc 12, CR0_EQ, 48 */
		/* 82170C28h case  122:*/		if ( regs.CR[0].eq ) { return 0x82170C58;  }
		/* 82170C28h case  122:*/		return 0x82170C2C;
		  /* 82170C2Ch */ case  123:  		/* lwz R11, <#[R29]> */
		/* 82170C2Ch case  123:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82170C2Ch case  123:*/		return 0x82170C30;
		  /* 82170C30h */ case  124:  		/* rlwinm. R9, R11, 0, 1, 1 */
		/* 82170C30h case  124:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R9,regs.R11);
		/* 82170C30h case  124:*/		return 0x82170C34;
		  /* 82170C34h */ case  125:  		/* bc 4, CR0_EQ, 16 */
		/* 82170C34h case  125:*/		if ( !regs.CR[0].eq ) { return 0x82170C44;  }
		/* 82170C34h case  125:*/		return 0x82170C38;
		  /* 82170C38h */ case  126:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82170C38h case  126:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82170C38h case  126:*/		return 0x82170C3C;
		  /* 82170C3Ch */ case  127:  		/* mr R11, R26 */
		/* 82170C3Ch case  127:*/		regs.R11 = regs.R26;
		/* 82170C3Ch case  127:*/		return 0x82170C40;
		  /* 82170C40h */ case  128:  		/* bc 12, CR0_EQ, 8 */
		/* 82170C40h case  128:*/		if ( regs.CR[0].eq ) { return 0x82170C48;  }
		/* 82170C40h case  128:*/		return 0x82170C44;
	}
	return 0x82170C44;
} // Block from 82170A40h-82170C44h (129 instructions)

//////////////////////////////////////////////////////
// Block at 82170C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170C44);
		  /* 82170C44h */ case    0:  		/* li R11, 0 */
		/* 82170C44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82170C44h case    0:*/		return 0x82170C48;
	}
	return 0x82170C48;
} // Block from 82170C44h-82170C48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170C48);
		  /* 82170C48h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82170C48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82170C48h case    0:*/		return 0x82170C4C;
		  /* 82170C4Ch */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82170C4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82170C68;  }
		/* 82170C4Ch case    1:*/		return 0x82170C50;
		  /* 82170C50h */ case    2:  		/* cmplw CR6, R10, R30 */
		/* 82170C50h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 82170C50h case    2:*/		return 0x82170C54;
		  /* 82170C54h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82170C54h case    3:*/		if ( regs.CR[6].eq ) { return 0x82170C68;  }
		/* 82170C54h case    3:*/		return 0x82170C58;
	}
	return 0x82170C58;
} // Block from 82170C48h-82170C58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82170C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170C58);
		  /* 82170C58h */ case    0:  		/* mr R5, R31 */
		/* 82170C58h case    0:*/		regs.R5 = regs.R31;
		/* 82170C58h case    0:*/		return 0x82170C5C;
		  /* 82170C5Ch */ case    1:  		/* mr R4, R29 */
		/* 82170C5Ch case    1:*/		regs.R4 = regs.R29;
		/* 82170C5Ch case    1:*/		return 0x82170C60;
		  /* 82170C60h */ case    2:  		/* mr R3, R28 */
		/* 82170C60h case    2:*/		regs.R3 = regs.R28;
		/* 82170C60h case    2:*/		return 0x82170C64;
		  /* 82170C64h */ case    3:  		/* bl 31916 */
		/* 82170C64h case    3:*/		regs.LR = 0x82170C68; return 0x82178910;
		/* 82170C64h case    3:*/		return 0x82170C68;
	}
	return 0x82170C68;
} // Block from 82170C58h-82170C68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82170C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170C68);
		  /* 82170C68h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 82170C68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82170C68h case    0:*/		return 0x82170C6C;
		  /* 82170C6Ch */ case    1:  		/* cmplw CR6, R11, R29 */
		/* 82170C6Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82170C6Ch case    1:*/		return 0x82170C70;
		  /* 82170C70h */ case    2:  		/* bc 4, CR6_EQ, -132 */
		/* 82170C70h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82170BEC;  }
		/* 82170C70h case    2:*/		return 0x82170C74;
		  /* 82170C74h */ case    3:  		/* addi R27, R29, 4 */
		/* 82170C74h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R29,0x4);
		/* 82170C74h case    3:*/		return 0x82170C78;
		  /* 82170C78h */ case    4:  		/* b -140 */
		/* 82170C78h case    4:*/		return 0x82170BEC;
		/* 82170C78h case    4:*/		return 0x82170C7C;
	}
	return 0x82170C7C;
} // Block from 82170C68h-82170C7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82170C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170C7C);
		  /* 82170C7Ch */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82170C7Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82170C7Ch case    0:*/		return 0x82170C80;
		  /* 82170C80h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82170C80h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82170C80h case    1:*/		return 0x82170C84;
		  /* 82170C84h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170C84h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170C84h case    2:*/		return 0x82170C88;
		  /* 82170C88h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82170C88h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82170C98;  }
		/* 82170C88h case    3:*/		return 0x82170C8C;
		  /* 82170C8Ch */ case    4:  		/* mr R28, R11 */
		/* 82170C8Ch case    4:*/		regs.R28 = regs.R11;
		/* 82170C8Ch case    4:*/		return 0x82170C90;
		  /* 82170C90h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82170C90h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82170C90h case    5:*/		return 0x82170C94;
		  /* 82170C94h */ case    6:  		/* bc 4, CR6_EQ, -188 */
		/* 82170C94h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82170BD8;  }
		/* 82170C94h case    6:*/		return 0x82170C98;
	}
	return 0x82170C98;
} // Block from 82170C7Ch-82170C98h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82170C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170C98);
		  /* 82170C98h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82170C98h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82170C98h case    0:*/		return 0x82170C9C;
		  /* 82170C9Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82170C9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82170C9Ch case    1:*/		return 0x82170CA0;
		  /* 82170CA0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82170CA0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82170CA0h case    2:*/		return 0x82170CA4;
		  /* 82170CA4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82170CA4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82170CB4;  }
		/* 82170CA4h case    3:*/		return 0x82170CA8;
		  /* 82170CA8h */ case    4:  		/* mr R30, R11 */
		/* 82170CA8h case    4:*/		regs.R30 = regs.R11;
		/* 82170CA8h case    4:*/		return 0x82170CAC;
		  /* 82170CACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82170CACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82170CACh case    5:*/		return 0x82170CB0;
		  /* 82170CB0h */ case    6:  		/* bc 4, CR6_EQ, -240 */
		/* 82170CB0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82170BC0;  }
		/* 82170CB0h case    6:*/		return 0x82170CB4;
	}
	return 0x82170CB4;
} // Block from 82170C98h-82170CB4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82170CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170CB4);
		  /* 82170CB4h */ case    0:  		/* addi R1, R1, 160 */
		/* 82170CB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82170CB4h case    0:*/		return 0x82170CB8;
		  /* 82170CB8h */ case    1:  		/* b -915992 */
		/* 82170CB8h case    1:*/		return 0x820912A0;
		/* 82170CB8h case    1:*/		return 0x82170CBC;
		  /* 82170CBCh */ case    2:  		/* nop */
		/* 82170CBCh case    2:*/		cpu::op::nop();
		/* 82170CBCh case    2:*/		return 0x82170CC0;
		  /* 82170CC0h */ case    3:  		/* lis R10, -28311 */
		/* 82170CC0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 82170CC0h case    3:*/		return 0x82170CC4;
		  /* 82170CC4h */ case    4:  		/* lis R9, 0 */
		/* 82170CC4h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x0);
		/* 82170CC4h case    4:*/		return 0x82170CC8;
		  /* 82170CC8h */ case    5:  		/* ori R10, R10, 5192 */
		/* 82170CC8h case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 82170CC8h case    5:*/		return 0x82170CCC;
		  /* 82170CCCh */ case    6:  		/* ori R9, R9, 36262 */
		/* 82170CCCh case    6:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x8DA6);
		/* 82170CCCh case    6:*/		return 0x82170CD0;
		  /* 82170CD0h */ case    7:  		/* rldicl R11, R3, 0, 32 */
		/* 82170CD0h case    7:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R3);
		/* 82170CD0h case    7:*/		return 0x82170CD4;
		  /* 82170CD4h */ case    8:  		/* rldimi R10, R9, 32, 0 */
		/* 82170CD4h case    8:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 82170CD4h case    8:*/		return 0x82170CD8;
		  /* 82170CD8h */ case    9:  		/* srd R10, R10, R11 */
		/* 82170CD8h case    9:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82170CD8h case    9:*/		return 0x82170CDC;
		  /* 82170CDCh */ case   10:  		/* srd R10, R10, R11 */
		/* 82170CDCh case   10:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82170CDCh case   10:*/		return 0x82170CE0;
		  /* 82170CE0h */ case   11:  		/* srd R11, R10, R11 */
		/* 82170CE0h case   11:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82170CE0h case   11:*/		return 0x82170CE4;
		  /* 82170CE4h */ case   12:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 82170CE4h case   12:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 82170CE4h case   12:*/		return 0x82170CE8;
		  /* 82170CE8h */ case   13:  		/* cmplw CR6, R11, R4 */
		/* 82170CE8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82170CE8h case   13:*/		return 0x82170CEC;
		  /* 82170CECh */ case   14:  		/* bclr 4, CR6_GT */
		/* 82170CECh case   14:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82170CECh case   14:*/		return 0x82170CF0;
	}
	return 0x82170CF0;
} // Block from 82170CB4h-82170CF0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82170CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170CF0);
		  /* 82170CF0h */ case    0:  		/* subf R11, R4, R11 */
		/* 82170CF0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 82170CF0h case    0:*/		return 0x82170CF4;
		  /* 82170CF4h */ case    1:  		/* mtspr CTR, R11 */
		/* 82170CF4h case    1:*/		regs.CTR = regs.R11;
		/* 82170CF4h case    1:*/		return 0x82170CF8;
		  /* 82170CF8h */ case    2:  		/* cntlzw R11, R3 */
		/* 82170CF8h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R3);
		/* 82170CF8h case    2:*/		return 0x82170CFC;
		  /* 82170CFCh */ case    3:  		/* li R10, 1 */
		/* 82170CFCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82170CFCh case    3:*/		return 0x82170D00;
		  /* 82170D00h */ case    4:  		/* addi R11, R11, 1 */
		/* 82170D00h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82170D00h case    4:*/		return 0x82170D04;
		  /* 82170D04h */ case    5:  		/* subfic R11, R11, 32 */
		/* 82170D04h case    5:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82170D04h case    5:*/		return 0x82170D08;
		  /* 82170D08h */ case    6:  		/* rlwnm R11, R10, R11, 0, 31 */
		/* 82170D08h case    6:*/		cpu::op::rlwnm<0,0,31>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82170D08h case    6:*/		return 0x82170D0C;
		  /* 82170D0Ch */ case    7:  		/* subf R3, R11, R3 */
		/* 82170D0Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 82170D0Ch case    7:*/		return 0x82170D10;
		  /* 82170D10h */ case    8:  		/* bc 16, CR0_LT, -24 */
		/* 82170D10h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82170CF8;  }
		/* 82170D10h case    8:*/		return 0x82170D14;
		  /* 82170D14h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82170D14h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170D14h case    9:*/		return 0x82170D18;
	}
	return 0x82170D18;
} // Block from 82170CF0h-82170D18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82170D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170D18);
		  /* 82170D18h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82170D18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82170D18h case    0:*/		return 0x82170D1C;
		  /* 82170D1Ch */ case    1:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 82170D1Ch case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 82170D1Ch case    1:*/		return 0x82170D20;
		  /* 82170D20h */ case    2:  		/* bc 4, CR0_EQ, 60 */
		/* 82170D20h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82170D5C;  }
		/* 82170D20h case    2:*/		return 0x82170D24;
		  /* 82170D24h */ case    3:  		/* rlwinm. R10, R11, 0, 8, 8 */
		/* 82170D24h case    3:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R10,regs.R11);
		/* 82170D24h case    3:*/		return 0x82170D28;
		  /* 82170D28h */ case    4:  		/* bc 4, CR0_EQ, 52 */
		/* 82170D28h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82170D5C;  }
		/* 82170D28h case    4:*/		return 0x82170D2C;
		  /* 82170D2Ch */ case    5:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82170D2Ch case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82170D2Ch case    5:*/		return 0x82170D30;
		  /* 82170D30h */ case    6:  		/* cmplwi CR6, R10, 125 */
		/* 82170D30h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 82170D30h case    6:*/		return 0x82170D34;
		  /* 82170D34h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 82170D34h case    7:*/		if ( regs.CR[6].eq ) { return 0x82170D44;  }
		/* 82170D34h case    7:*/		return 0x82170D38;
		  /* 82170D38h */ case    8:  		/* cmplwi CR6, R10, 124 */
		/* 82170D38h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 82170D38h case    8:*/		return 0x82170D3C;
		  /* 82170D3Ch */ case    9:  		/* li R11, 0 */
		/* 82170D3Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82170D3Ch case    9:*/		return 0x82170D40;
		  /* 82170D40h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 82170D40h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82170D48;  }
		/* 82170D40h case   10:*/		return 0x82170D44;
	}
	return 0x82170D44;
} // Block from 82170D18h-82170D44h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82170D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170D44);
		  /* 82170D44h */ case    0:  		/* li R11, 1 */
		/* 82170D44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82170D44h case    0:*/		return 0x82170D48;
	}
	return 0x82170D48;
} // Block from 82170D44h-82170D48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170D48);
		  /* 82170D48h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82170D48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82170D48h case    0:*/		return 0x82170D4C;
		  /* 82170D4Ch */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82170D4Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82170D5C;  }
		/* 82170D4Ch case    1:*/		return 0x82170D50;
		  /* 82170D50h */ case    2:  		/* cmplwi CR6, R10, 120 */
		/* 82170D50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000078);
		/* 82170D50h case    2:*/		return 0x82170D54;
		  /* 82170D54h */ case    3:  		/* li R11, 0 */
		/* 82170D54h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82170D54h case    3:*/		return 0x82170D58;
		  /* 82170D58h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82170D58h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82170D60;  }
		/* 82170D58h case    4:*/		return 0x82170D5C;
	}
	return 0x82170D5C;
} // Block from 82170D48h-82170D5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82170D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170D5C);
		  /* 82170D5Ch */ case    0:  		/* li R11, 1 */
		/* 82170D5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82170D5Ch case    0:*/		return 0x82170D60;
	}
	return 0x82170D60;
} // Block from 82170D5Ch-82170D60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170D60);
		  /* 82170D60h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82170D60h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82170D60h case    0:*/		return 0x82170D64;
		  /* 82170D64h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82170D64h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170D64h case    1:*/		return 0x82170D68;
	}
	return 0x82170D68;
} // Block from 82170D60h-82170D68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170D68);
		  /* 82170D68h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82170D68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82170D68h case    0:*/		return 0x82170D6C;
		  /* 82170D6Ch */ case    1:  		/* rlwinm R10, R11, 22, 29, 30 */
		/* 82170D6Ch case    1:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R10,regs.R11);
		/* 82170D6Ch case    1:*/		return 0x82170D70;
		  /* 82170D70h */ case    2:  		/* rlwinm R9, R11, 24, 29, 30 */
		/* 82170D70h case    2:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R9,regs.R11);
		/* 82170D70h case    2:*/		return 0x82170D74;
		  /* 82170D74h */ case    3:  		/* srw R10, R4, R10 */
		/* 82170D74h case    3:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R4,regs.R10);
		/* 82170D74h case    3:*/		return 0x82170D78;
		  /* 82170D78h */ case    4:  		/* srw R9, R4, R9 */
		/* 82170D78h case    4:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 82170D78h case    4:*/		return 0x82170D7C;
		  /* 82170D7Ch */ case    5:  		/* rlwimi R9, R10, 2, 28, 29 */
		/* 82170D7Ch case    5:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R9,regs.R10);
		/* 82170D7Ch case    5:*/		return 0x82170D80;
		  /* 82170D80h */ case    6:  		/* rlwinm R10, R11, 26, 29, 30 */
		/* 82170D80h case    6:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R10,regs.R11);
		/* 82170D80h case    6:*/		return 0x82170D84;
		  /* 82170D84h */ case    7:  		/* rlwinm R9, R9, 0, 28, 31 */
		/* 82170D84h case    7:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R9);
		/* 82170D84h case    7:*/		return 0x82170D88;
		  /* 82170D88h */ case    8:  		/* srw R10, R4, R10 */
		/* 82170D88h case    8:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R4,regs.R10);
		/* 82170D88h case    8:*/		return 0x82170D8C;
		  /* 82170D8Ch */ case    9:  		/* rlwinm R8, R11, 28, 29, 30 */
		/* 82170D8Ch case    9:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R8,regs.R11);
		/* 82170D8Ch case    9:*/		return 0x82170D90;
		  /* 82170D90h */ case   10:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 82170D90h case   10:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82170D90h case   10:*/		return 0x82170D94;
		  /* 82170D94h */ case   11:  		/* srw R9, R4, R8 */
		/* 82170D94h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R4,regs.R8);
		/* 82170D94h case   11:*/		return 0x82170D98;
		  /* 82170D98h */ case   12:  		/* rlwimi R9, R10, 2, 0, 29 */
		/* 82170D98h case   12:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82170D98h case   12:*/		return 0x82170D9C;
		  /* 82170D9Ch */ case   13:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 82170D9Ch case   13:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 82170D9Ch case   13:*/		return 0x82170DA0;
		  /* 82170DA0h */ case   14:  		/* rlwinm R10, R9, 5, 0, 26 */
		/* 82170DA0h case   14:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R9);
		/* 82170DA0h case   14:*/		return 0x82170DA4;
		  /* 82170DA4h */ case   15:  		/* or R11, R10, R11 */
		/* 82170DA4h case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82170DA4h case   15:*/		return 0x82170DA8;
		  /* 82170DA8h */ case   16:  		/* stw R11, <#[R3]> */
		/* 82170DA8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82170DA8h case   16:*/		return 0x82170DAC;
		  /* 82170DACh */ case   17:  		/* bclr 20, CR0_LT */
		/* 82170DACh case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170DACh case   17:*/		return 0x82170DB0;
	}
	return 0x82170DB0;
} // Block from 82170D68h-82170DB0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82170DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170DB0);
		  /* 82170DB0h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82170DB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82170DB0h case    0:*/		return 0x82170DB4;
		  /* 82170DB4h */ case    1:  		/* li R3, 0 */
		/* 82170DB4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82170DB4h case    1:*/		return 0x82170DB8;
		  /* 82170DB8h */ case    2:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82170DB8h case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82170DB8h case    2:*/		return 0x82170DBC;
		  /* 82170DBCh */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 82170DBCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82170DBCh case    3:*/		return 0x82170DC0;
		  /* 82170DC0h */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 82170DC0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82170DD0;  }
		/* 82170DC0h case    4:*/		return 0x82170DC4;
		  /* 82170DC4h */ case    5:  		/* cmplwi CR6, R11, 31 */
		/* 82170DC4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82170DC4h case    5:*/		return 0x82170DC8;
		  /* 82170DC8h */ case    6:  		/* li R10, 1 */
		/* 82170DC8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82170DC8h case    6:*/		return 0x82170DCC;
		  /* 82170DCCh */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 82170DCCh case    7:*/		if ( !regs.CR[6].gt ) { return 0x82170DD4;  }
		/* 82170DCCh case    7:*/		return 0x82170DD0;
	}
	return 0x82170DD0;
} // Block from 82170DB0h-82170DD0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82170DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170DD0);
		  /* 82170DD0h */ case    0:  		/* li R10, 0 */
		/* 82170DD0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82170DD0h case    0:*/		return 0x82170DD4;
	}
	return 0x82170DD4;
} // Block from 82170DD0h-82170DD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170DD4);
		  /* 82170DD4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82170DD4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82170DD4h case    0:*/		return 0x82170DD8;
		  /* 82170DD8h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 82170DD8h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82170DD8h case    1:*/		return 0x82170DDC;
	}
	return 0x82170DDC;
} // Block from 82170DD4h-82170DDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170DDC);
		  /* 82170DDCh */ case    0:  		/* cmplwi CR6, R11, 16 */
		/* 82170DDCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82170DDCh case    0:*/		return 0x82170DE0;
		  /* 82170DE0h */ case    1:  		/* bc 12, CR6_LT, 28 */
		/* 82170DE0h case    1:*/		if ( regs.CR[6].lt ) { return 0x82170DFC;  }
		/* 82170DE0h case    1:*/		return 0x82170DE4;
		  /* 82170DE4h */ case    2:  		/* cmplwi CR6, R11, 24 */
		/* 82170DE4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 82170DE4h case    2:*/		return 0x82170DE8;
		  /* 82170DE8h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 82170DE8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82170DF4;  }
		/* 82170DE8h case    3:*/		return 0x82170DEC;
		  /* 82170DECh */ case    4:  		/* cmplwi CR6, R11, 29 */
		/* 82170DECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001D);
		/* 82170DECh case    4:*/		return 0x82170DF0;
		  /* 82170DF0h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82170DF0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82170DFC;  }
		/* 82170DF0h case    5:*/		return 0x82170DF4;
	}
	return 0x82170DF4;
} // Block from 82170DDCh-82170DF4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82170DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170DF4);
		  /* 82170DF4h */ case    0:  		/* li R3, 0 */
		/* 82170DF4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82170DF4h case    0:*/		return 0x82170DF8;
		  /* 82170DF8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82170DF8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170DF8h case    1:*/		return 0x82170DFC;
	}
	return 0x82170DFC;
} // Block from 82170DF4h-82170DFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170DFC);
		  /* 82170DFCh */ case    0:  		/* li R3, 1 */
		/* 82170DFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82170DFCh case    0:*/		return 0x82170E00;
		  /* 82170E00h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82170E00h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170E00h case    1:*/		return 0x82170E04;
	}
	return 0x82170E04;
} // Block from 82170DFCh-82170E04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E04);
		  /* 82170E04h */ case    0:  		/* nop */
		/* 82170E04h case    0:*/		cpu::op::nop();
		/* 82170E04h case    0:*/		return 0x82170E08;
	}
	return 0x82170E08;
} // Block from 82170E04h-82170E08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E08);
		  /* 82170E08h */ case    0:  		/* mfspr R12, LR */
		/* 82170E08h case    0:*/		regs.R12 = regs.LR;
		/* 82170E08h case    0:*/		return 0x82170E0C;
		  /* 82170E0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82170E0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82170E0Ch case    1:*/		return 0x82170E10;
	}
	return 0x82170E10;
} // Block from 82170E08h-82170E10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170E10h
// Function '?FinalScheduling@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E10);
		  /* 82170E10h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 82170E10h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82170E10h case    0:*/		return 0x82170E14;
		  /* 82170E14h */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 82170E14h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82170E14h case    1:*/		return 0x82170E18;
		  /* 82170E18h */ case    2:  		/* mr R31, R3 */
		/* 82170E18h case    2:*/		regs.R31 = regs.R3;
		/* 82170E18h case    2:*/		return 0x82170E1C;
		  /* 82170E1Ch */ case    3:  		/* bl -108 */
		/* 82170E1Ch case    3:*/		regs.LR = 0x82170E20; return 0x82170DB0;
		/* 82170E1Ch case    3:*/		return 0x82170E20;
		  /* 82170E20h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82170E20h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82170E20h case    4:*/		return 0x82170E24;
		  /* 82170E24h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82170E24h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82170E30;  }
		/* 82170E24h case    5:*/		return 0x82170E28;
		  /* 82170E28h */ case    6:  		/* li R3, 0 */
		/* 82170E28h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82170E28h case    6:*/		return 0x82170E2C;
		  /* 82170E2Ch */ case    7:  		/* b 36 */
		/* 82170E2Ch case    7:*/		return 0x82170E50;
		/* 82170E2Ch case    7:*/		return 0x82170E30;
	}
	return 0x82170E30;
} // Block from 82170E10h-82170E30h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82170E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E30);
		  /* 82170E30h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82170E30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82170E30h case    0:*/		return 0x82170E34;
		  /* 82170E34h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82170E34h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82170E34h case    1:*/		return 0x82170E38;
		  /* 82170E38h */ case    2:  		/* cmplwi CR6, R11, 25 */
		/* 82170E38h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000019);
		/* 82170E38h case    2:*/		return 0x82170E3C;
		  /* 82170E3Ch */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82170E3Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82170E4C;  }
		/* 82170E3Ch case    3:*/		return 0x82170E40;
		  /* 82170E40h */ case    4:  		/* cmplwi CR6, R11, 28 */
		/* 82170E40h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 82170E40h case    4:*/		return 0x82170E44;
		  /* 82170E44h */ case    5:  		/* li R3, 0 */
		/* 82170E44h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82170E44h case    5:*/		return 0x82170E48;
		  /* 82170E48h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82170E48h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82170E50;  }
		/* 82170E48h case    6:*/		return 0x82170E4C;
	}
	return 0x82170E4C;
} // Block from 82170E30h-82170E4Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82170E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E4C);
		  /* 82170E4Ch */ case    0:  		/* li R3, 1 */
		/* 82170E4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82170E4Ch case    0:*/		return 0x82170E50;
	}
	return 0x82170E50;
} // Block from 82170E4Ch-82170E50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E50);
		  /* 82170E50h */ case    0:  		/* addi R1, R1, 96 */
		/* 82170E50h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82170E50h case    0:*/		return 0x82170E54;
		  /* 82170E54h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82170E54h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82170E54h case    1:*/		return 0x82170E58;
		  /* 82170E58h */ case    2:  		/* mtspr LR, R12 */
		/* 82170E58h case    2:*/		regs.LR = regs.R12;
		/* 82170E58h case    2:*/		return 0x82170E5C;
		  /* 82170E5Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82170E5Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82170E5Ch case    3:*/		return 0x82170E60;
		  /* 82170E60h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82170E60h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170E60h case    4:*/		return 0x82170E64;
	}
	return 0x82170E64;
} // Block from 82170E50h-82170E64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82170E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E64);
		  /* 82170E64h */ case    0:  		/* nop */
		/* 82170E64h case    0:*/		cpu::op::nop();
		/* 82170E64h case    0:*/		return 0x82170E68;
		  /* 82170E68h */ case    1:  		/* lwz R11, <#[R4 + 8]> */
		/* 82170E68h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82170E68h case    1:*/		return 0x82170E6C;
		  /* 82170E6Ch */ case    2:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 82170E6Ch case    2:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 82170E6Ch case    2:*/		return 0x82170E70;
		  /* 82170E70h */ case    3:  		/* bclr 12, CR0_EQ */
		/* 82170E70h case    3:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82170E70h case    3:*/		return 0x82170E74;
	}
	return 0x82170E74;
} // Block from 82170E64h-82170E74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82170E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E74);
		  /* 82170E74h */ case    0:  		/* lwz R8, <#[R4 + 4]> */
		/* 82170E74h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000004) );
		/* 82170E74h case    0:*/		return 0x82170E78;
		  /* 82170E78h */ case    1:  		/* li R9, 1 */
		/* 82170E78h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82170E78h case    1:*/		return 0x82170E7C;
		  /* 82170E7Ch */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 82170E7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82170E7Ch case    2:*/		return 0x82170E80;
		  /* 82170E80h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 82170E80h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82170E80h case    3:*/		return 0x82170E84;
	}
	return 0x82170E84;
} // Block from 82170E74h-82170E84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82170E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170E84);
		  /* 82170E84h */ case    0:  		/* lwz R11, <#[R8 + 16]> */
		/* 82170E84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 82170E84h case    0:*/		return 0x82170E88;
		  /* 82170E88h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82170E88h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82170E88h case    1:*/		return 0x82170E8C;
		  /* 82170E8Ch */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 82170E8Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82170ED8;  }
		/* 82170E8Ch case    2:*/		return 0x82170E90;
		  /* 82170E90h */ case    3:  		/* lwz R11, <#[R8]> */
		/* 82170E90h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82170E90h case    3:*/		return 0x82170E94;
		  /* 82170E94h */ case    4:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82170E94h case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82170E94h case    4:*/		return 0x82170E98;
		  /* 82170E98h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82170E98h case    5:*/		if ( regs.CR[0].eq ) { return 0x82170EA8;  }
		/* 82170E98h case    5:*/		return 0x82170E9C;
		  /* 82170E9Ch */ case    6:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 82170E9Ch case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 82170E9Ch case    6:*/		return 0x82170EA0;
		  /* 82170EA0h */ case    7:  		/* mr R10, R9 */
		/* 82170EA0h case    7:*/		regs.R10 = regs.R9;
		/* 82170EA0h case    7:*/		return 0x82170EA4;
		  /* 82170EA4h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82170EA4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82170EAC;  }
		/* 82170EA4h case    8:*/		return 0x82170EA8;
	}
	return 0x82170EA8;
} // Block from 82170E84h-82170EA8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82170EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170EA8);
		  /* 82170EA8h */ case    0:  		/* li R10, 0 */
		/* 82170EA8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82170EA8h case    0:*/		return 0x82170EAC;
	}
	return 0x82170EAC;
} // Block from 82170EA8h-82170EACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170EAC);
		  /* 82170EACh */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82170EACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82170EACh case    0:*/		return 0x82170EB0;
		  /* 82170EB0h */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 82170EB0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82170ED8;  }
		/* 82170EB0h case    1:*/		return 0x82170EB4;
		  /* 82170EB4h */ case    2:  		/* rlwinm R11, R11, 19, 20, 31 */
		/* 82170EB4h case    2:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R11);
		/* 82170EB4h case    2:*/		return 0x82170EB8;
		  /* 82170EB8h */ case    3:  		/* rlwinm. R10, R5, 0, 24, 31 */
		/* 82170EB8h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R5);
		/* 82170EB8h case    3:*/		return 0x82170EBC;
		  /* 82170EBCh */ case    4:  		/* lwz R10, <#[R3 + 48]> */
		/* 82170EBCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 82170EBCh case    4:*/		return 0x82170EC0;
		  /* 82170EC0h */ case    5:  		/* slw R11, R9, R11 */
		/* 82170EC0h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82170EC0h case    5:*/		return 0x82170EC4;
		  /* 82170EC4h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82170EC4h case    6:*/		if ( regs.CR[0].eq ) { return 0x82170ED0;  }
		/* 82170EC4h case    6:*/		return 0x82170EC8;
		  /* 82170EC8h */ case    7:  		/* or R11, R11, R10 */
		/* 82170EC8h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82170EC8h case    7:*/		return 0x82170ECC;
		  /* 82170ECCh */ case    8:  		/* b 8 */
		/* 82170ECCh case    8:*/		return 0x82170ED4;
		/* 82170ECCh case    8:*/		return 0x82170ED0;
	}
	return 0x82170ED0;
} // Block from 82170EACh-82170ED0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82170ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170ED0);
		  /* 82170ED0h */ case    0:  		/* andc R11, R10, R11 */
		/* 82170ED0h case    0:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82170ED0h case    0:*/		return 0x82170ED4;
	}
	return 0x82170ED4;
} // Block from 82170ED0h-82170ED4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170ED4);
		  /* 82170ED4h */ case    0:  		/* stw R11, <#[R3 + 48]> */
		/* 82170ED4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 82170ED4h case    0:*/		return 0x82170ED8;
	}
	return 0x82170ED8;
} // Block from 82170ED4h-82170ED8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170ED8);
		  /* 82170ED8h */ case    0:  		/* lwz R8, <#[R8 + 8]> */
		/* 82170ED8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 82170ED8h case    0:*/		return 0x82170EDC;
		  /* 82170EDCh */ case    1:  		/* b -96 */
		/* 82170EDCh case    1:*/		return 0x82170E7C;
		/* 82170EDCh case    1:*/		return 0x82170EE0;
		  /* 82170EE0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82170EE0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170EE0h case    2:*/		return 0x82170EE4;
	}
	return 0x82170EE4;
} // Block from 82170ED8h-82170EE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170EE4);
		  /* 82170EE4h */ case    0:  		/* nop */
		/* 82170EE4h case    0:*/		cpu::op::nop();
		/* 82170EE4h case    0:*/		return 0x82170EE8;
		  /* 82170EE8h */ case    1:  		/* mr R9, R3 */
		/* 82170EE8h case    1:*/		regs.R9 = regs.R3;
		/* 82170EE8h case    1:*/		return 0x82170EEC;
		  /* 82170EECh */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 82170EECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82170EECh case    2:*/		return 0x82170EF0;
		  /* 82170EF0h */ case    3:  		/* bc 12, CR6_EQ, 140 */
		/* 82170EF0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82170F7C;  }
		/* 82170EF0h case    3:*/		return 0x82170EF4;
		  /* 82170EF4h */ case    4:  		/* lwz R8, <#[R9 + 4]> */
		/* 82170EF4h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 82170EF4h case    4:*/		return 0x82170EF8;
		  /* 82170EF8h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 82170EF8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82170EF8h case    5:*/		return 0x82170EFC;
		  /* 82170EFCh */ case    6:  		/* bc 12, CR6_EQ, 116 */
		/* 82170EFCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82170F70;  }
		/* 82170EFCh case    6:*/		return 0x82170F00;
		  /* 82170F00h */ case    7:  		/* lwz R10, <#[R8 + 16]> */
		/* 82170F00h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000010) );
		/* 82170F00h case    7:*/		return 0x82170F04;
		  /* 82170F04h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82170F04h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82170F04h case    8:*/		return 0x82170F08;
		  /* 82170F08h */ case    9:  		/* bc 12, CR6_EQ, 96 */
		/* 82170F08h case    9:*/		if ( regs.CR[6].eq ) { return 0x82170F68;  }
		/* 82170F08h case    9:*/		return 0x82170F0C;
		  /* 82170F0Ch */ case   10:  		/* lwz R11, <#[R10 + 28]> */
		/* 82170F0Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000001C) );
		/* 82170F0Ch case   10:*/		return 0x82170F10;
		  /* 82170F10h */ case   11:  		/* lwz R7, <#[R9 + 28]> */
		/* 82170F10h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x0000001C) );
		/* 82170F10h case   11:*/		return 0x82170F14;
		  /* 82170F14h */ case   12:  		/* cmpw CR6, R11, R7 */
		/* 82170F14h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R7);
		/* 82170F14h case   12:*/		return 0x82170F18;
		  /* 82170F18h */ case   13:  		/* bc 4, CR6_EQ, 80 */
		/* 82170F18h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82170F68;  }
		/* 82170F18h case   13:*/		return 0x82170F1C;
		  /* 82170F1Ch */ case   14:  		/* lwz R11, <#[R10 + 8]> */
		/* 82170F1Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82170F1Ch case   14:*/		return 0x82170F20;
		  /* 82170F20h */ case   15:  		/* rlwinm R7, R11, 0, 18, 24 */
		/* 82170F20h case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R7,regs.R11);
		/* 82170F20h case   15:*/		return 0x82170F24;
		  /* 82170F24h */ case   16:  		/* cmplwi CR6, R7, 14336 */
		/* 82170F24h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00003800);
		/* 82170F24h case   16:*/		return 0x82170F28;
		  /* 82170F28h */ case   17:  		/* bc 12, CR6_EQ, 64 */
		/* 82170F28h case   17:*/		if ( regs.CR[6].eq ) { return 0x82170F68;  }
		/* 82170F28h case   17:*/		return 0x82170F2C;
		  /* 82170F2Ch */ case   18:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 82170F2Ch case   18:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 82170F2Ch case   18:*/		return 0x82170F30;
		  /* 82170F30h */ case   19:  		/* bc 12, CR0_EQ, 56 */
		/* 82170F30h case   19:*/		if ( regs.CR[0].eq ) { return 0x82170F68;  }
		/* 82170F30h case   19:*/		return 0x82170F34;
		  /* 82170F34h */ case   20:  		/* lwz R11, <#[R10 + 16]> */
		/* 82170F34h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82170F34h case   20:*/		return 0x82170F38;
		  /* 82170F38h */ case   21:  		/* rlwinm. R7, R11, 7, 31, 31 */
		/* 82170F38h case   21:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R7,regs.R11);
		/* 82170F38h case   21:*/		return 0x82170F3C;
		  /* 82170F3Ch */ case   22:  		/* bc 4, CR0_EQ, 44 */
		/* 82170F3Ch case   22:*/		if ( !regs.CR[0].eq ) { return 0x82170F68;  }
		/* 82170F3Ch case   22:*/		return 0x82170F40;
		  /* 82170F40h */ case   23:  		/* lwz R10, <#[R10 + 20]> */
		/* 82170F40h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 82170F40h case   23:*/		return 0x82170F44;
		  /* 82170F44h */ case   24:  		/* lwz R7, <#[R3 + 16]> */
		/* 82170F44h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 82170F44h case   24:*/		return 0x82170F48;
		  /* 82170F48h */ case   25:  		/* lwz R6, <#[R3 + 20]> */
		/* 82170F48h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 82170F48h case   25:*/		return 0x82170F4C;
		  /* 82170F4Ch */ case   26:  		/* rlwimi R11, R10, 27, 5, 31 */
		/* 82170F4Ch case   26:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 82170F4Ch case   26:*/		return 0x82170F50;
		  /* 82170F50h */ case   27:  		/* rlwimi R7, R6, 27, 5, 31 */
		/* 82170F50h case   27:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R7,regs.R6);
		/* 82170F50h case   27:*/		return 0x82170F54;
		  /* 82170F54h */ case   28:  		/* rlwinm R11, R11, 0, 1, 31 */
		/* 82170F54h case   28:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R11,regs.R11);
		/* 82170F54h case   28:*/		return 0x82170F58;
		  /* 82170F58h */ case   29:  		/* rlwinm R10, R7, 0, 1, 31 */
		/* 82170F58h case   29:*/		cpu::op::rlwinm<0,0,1,31>(regs,&regs.R10,regs.R7);
		/* 82170F58h case   29:*/		return 0x82170F5C;
		  /* 82170F5Ch */ case   30:  		/* xor R11, R10, R11 */
		/* 82170F5Ch case   30:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82170F5Ch case   30:*/		return 0x82170F60;
		  /* 82170F60h */ case   31:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 82170F60h case   31:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82170F60h case   31:*/		return 0x82170F64;
		  /* 82170F64h */ case   32:  		/* bc 4, CR0_EQ, 32 */
		/* 82170F64h case   32:*/		if ( !regs.CR[0].eq ) { return 0x82170F84;  }
		/* 82170F64h case   32:*/		return 0x82170F68;
	}
	return 0x82170F68;
} // Block from 82170EE4h-82170F68h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82170F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170F68);
		  /* 82170F68h */ case    0:  		/* lwz R8, <#[R8 + 8]> */
		/* 82170F68h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 82170F68h case    0:*/		return 0x82170F6C;
		  /* 82170F6Ch */ case    1:  		/* b -116 */
		/* 82170F6Ch case    1:*/		return 0x82170EF8;
		/* 82170F6Ch case    1:*/		return 0x82170F70;
	}
	return 0x82170F70;
} // Block from 82170F68h-82170F70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170F70);
		  /* 82170F70h */ case    0:  		/* lwz R9, <#[R9 + 32]> */
		/* 82170F70h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000020) );
		/* 82170F70h case    0:*/		return 0x82170F74;
		  /* 82170F74h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82170F74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82170F74h case    1:*/		return 0x82170F78;
		  /* 82170F78h */ case    2:  		/* bc 4, CR6_EQ, -132 */
		/* 82170F78h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82170EF4;  }
		/* 82170F78h case    2:*/		return 0x82170F7C;
	}
	return 0x82170F7C;
} // Block from 82170F70h-82170F7Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170F7C);
		  /* 82170F7Ch */ case    0:  		/* li R3, 1 */
		/* 82170F7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82170F7Ch case    0:*/		return 0x82170F80;
		  /* 82170F80h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82170F80h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170F80h case    1:*/		return 0x82170F84;
	}
	return 0x82170F84;
} // Block from 82170F7Ch-82170F84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170F84);
		  /* 82170F84h */ case    0:  		/* li R3, 0 */
		/* 82170F84h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82170F84h case    0:*/		return 0x82170F88;
		  /* 82170F88h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82170F88h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82170F88h case    1:*/		return 0x82170F8C;
	}
	return 0x82170F8C;
} // Block from 82170F84h-82170F8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170F8C);
		  /* 82170F8Ch */ case    0:  		/* nop */
		/* 82170F8Ch case    0:*/		cpu::op::nop();
		/* 82170F8Ch case    0:*/		return 0x82170F90;
	}
	return 0x82170F90;
} // Block from 82170F8Ch-82170F90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170F90);
		  /* 82170F90h */ case    0:  		/* mfspr R12, LR */
		/* 82170F90h case    0:*/		regs.R12 = regs.LR;
		/* 82170F90h case    0:*/		return 0x82170F94;
		  /* 82170F94h */ case    1:  		/* bl -916792 */
		/* 82170F94h case    1:*/		regs.LR = 0x82170F98; return 0x8209125C;
		/* 82170F94h case    1:*/		return 0x82170F98;
	}
	return 0x82170F98;
} // Block from 82170F90h-82170F98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82170F98h
// Function '?InitOperand@Instruction@D3DXShader@@QAAPAVDependency@2@IPAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170F98);
		  /* 82170F98h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82170F98h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82170F98h case    0:*/		return 0x82170F9C;
		  /* 82170F9Ch */ case    1:  		/* lwz R29, <#[R4 + 4]> */
		/* 82170F9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x00000004) );
		/* 82170F9Ch case    1:*/		return 0x82170FA0;
		  /* 82170FA0h */ case    2:  		/* mr R30, R4 */
		/* 82170FA0h case    2:*/		regs.R30 = regs.R4;
		/* 82170FA0h case    2:*/		return 0x82170FA4;
		  /* 82170FA4h */ case    3:  		/* mr R11, R29 */
		/* 82170FA4h case    3:*/		regs.R11 = regs.R29;
		/* 82170FA4h case    3:*/		return 0x82170FA8;
		  /* 82170FA8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82170FA8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82170FA8h case    4:*/		return 0x82170FAC;
		  /* 82170FACh */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82170FACh case    5:*/		if ( regs.CR[6].eq ) { return 0x82170FD0;  }
		/* 82170FACh case    5:*/		return 0x82170FB0;
		  /* 82170FB0h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82170FB0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82170FB0h case    6:*/		return 0x82170FB4;
		  /* 82170FB4h */ case    7:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 82170FB4h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 82170FB4h case    7:*/		return 0x82170FB8;
		  /* 82170FB8h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 82170FB8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82170FC4;  }
		/* 82170FB8h case    8:*/		return 0x82170FBC;
		  /* 82170FBCh */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 82170FBCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82170FBCh case    9:*/		return 0x82170FC0;
		  /* 82170FC0h */ case   10:  		/* b -24 */
		/* 82170FC0h case   10:*/		return 0x82170FA8;
		/* 82170FC0h case   10:*/		return 0x82170FC4;
	}
	return 0x82170FC4;
} // Block from 82170F98h-82170FC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82170FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170FC4);
		  /* 82170FC4h */ case    0:  		/* rlwinm. R11, R10, 2, 31, 31 */
		/* 82170FC4h case    0:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R10);
		/* 82170FC4h case    0:*/		return 0x82170FC8;
		  /* 82170FC8h */ case    1:  		/* li R11, 1 */
		/* 82170FC8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82170FC8h case    1:*/		return 0x82170FCC;
		  /* 82170FCCh */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82170FCCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82170FD4;  }
		/* 82170FCCh case    2:*/		return 0x82170FD0;
	}
	return 0x82170FD0;
} // Block from 82170FC4h-82170FD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170FD0);
		  /* 82170FD0h */ case    0:  		/* li R11, 0 */
		/* 82170FD0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82170FD0h case    0:*/		return 0x82170FD4;
	}
	return 0x82170FD4;
} // Block from 82170FD0h-82170FD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82170FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170FD4);
		  /* 82170FD4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82170FD4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82170FD4h case    0:*/		return 0x82170FD8;
		  /* 82170FD8h */ case    1:  		/* bc 12, CR0_EQ, 256 */
		/* 82170FD8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821710D8;  }
		/* 82170FD8h case    1:*/		return 0x82170FDC;
		  /* 82170FDCh */ case    2:  		/* mr R3, R30 */
		/* 82170FDCh case    2:*/		regs.R3 = regs.R30;
		/* 82170FDCh case    2:*/		return 0x82170FE0;
	}
	return 0x82170FE0;
} // Block from 82170FD4h-82170FE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82170FE0h
// Function '?SetJumpTarget@Instruction@D3DXShader@@QAAXPAVBlock@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82170FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82170FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82170FE0);
		  /* 82170FE0h */ case    0:  		/* bl -712 */
		/* 82170FE0h case    0:*/		regs.LR = 0x82170FE4; return 0x82170D18;
		/* 82170FE0h case    0:*/		return 0x82170FE4;
		  /* 82170FE4h */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82170FE4h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82170FE4h case    1:*/		return 0x82170FE8;
		  /* 82170FE8h */ case    2:  		/* bc 4, CR0_EQ, 240 */
		/* 82170FE8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821710D8;  }
		/* 82170FE8h case    2:*/		return 0x82170FEC;
		  /* 82170FECh */ case    3:  		/* mr R3, R30 */
		/* 82170FECh case    3:*/		regs.R3 = regs.R30;
		/* 82170FECh case    3:*/		return 0x82170FF0;
		  /* 82170FF0h */ case    4:  		/* li R31, 228 */
		/* 82170FF0h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0xE4);
		/* 82170FF0h case    4:*/		return 0x82170FF4;
		  /* 82170FF4h */ case    5:  		/* bl -492 */
		/* 82170FF4h case    5:*/		regs.LR = 0x82170FF8; return 0x82170E08;
		/* 82170FF4h case    5:*/		return 0x82170FF8;
		  /* 82170FF8h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82170FF8h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82170FF8h case    6:*/		return 0x82170FFC;
		  /* 82170FFCh */ case    7:  		/* bc 4, CR0_EQ, 44 */
		/* 82170FFCh case    7:*/		if ( !regs.CR[0].eq ) { return 0x82171028;  }
		/* 82170FFCh case    7:*/		return 0x82171000;
		  /* 82171000h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 82171000h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82171000h case    8:*/		return 0x82171004;
		  /* 82171004h */ case    9:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82171004h case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82171004h case    9:*/		return 0x82171008;
		  /* 82171008h */ case   10:  		/* cmplwi CR6, R11, 32 */
		/* 82171008h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82171008h case   10:*/		return 0x8217100C;
		  /* 8217100Ch */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 8217100Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x8217101C;  }
		/* 8217100Ch case   11:*/		return 0x82171010;
		  /* 82171010h */ case   12:  		/* cmplwi CR6, R11, 82 */
		/* 82171010h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82171010h case   12:*/		return 0x82171014;
		  /* 82171014h */ case   13:  		/* li R11, 1 */
		/* 82171014h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82171014h case   13:*/		return 0x82171018;
		  /* 82171018h */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 82171018h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82171020;  }
		/* 82171018h case   14:*/		return 0x8217101C;
	}
	return 0x8217101C;
} // Block from 82170FE0h-8217101Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8217101Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217101C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217101C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217101C);
		  /* 8217101Ch */ case    0:  		/* li R11, 0 */
		/* 8217101Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8217101Ch case    0:*/		return 0x82171020;
	}
	return 0x82171020;
} // Block from 8217101Ch-82171020h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171020);
		  /* 82171020h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82171020h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82171020h case    0:*/		return 0x82171024;
		  /* 82171024h */ case    1:  		/* bc 12, CR0_EQ, 60 */
		/* 82171024h case    1:*/		if ( regs.CR[0].eq ) { return 0x82171060;  }
		/* 82171024h case    1:*/		return 0x82171028;
	}
	return 0x82171028;
} // Block from 82171020h-82171028h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171028);
		  /* 82171028h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82171028h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82171028h case    0:*/		return 0x8217102C;
		  /* 8217102Ch */ case    1:  		/* li R9, 1 */
		/* 8217102Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8217102Ch case    1:*/		return 0x82171030;
		  /* 82171030h */ case    2:  		/* rlwinm R8, R11, 18, 29, 31 */
		/* 82171030h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R8,regs.R11);
		/* 82171030h case    2:*/		return 0x82171034;
		  /* 82171034h */ case    3:  		/* rlwinm R10, R11, 31, 28, 31 */
		/* 82171034h case    3:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R10,regs.R11);
		/* 82171034h case    3:*/		return 0x82171038;
	}
	return 0x82171038;
} // Block from 82171028h-82171038h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82171038h
// Function '?CreateSpecialOutput@Compiler@D3DXShader@@QAAPAVDependency@2@PAVInstruction@2@W4SpecialRegister@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171038);
		  /* 82171038h */ case    0:  		/* slw R9, R9, R8 */
		/* 82171038h case    0:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82171038h case    0:*/		return 0x8217103C;
		  /* 8217103Ch */ case    1:  		/* addi R9, R9, -1 */
		/* 8217103Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8217103Ch case    1:*/		return 0x82171040;
		  /* 82171040h */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 82171040h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82171040h case    2:*/		return 0x82171044;
		  /* 82171044h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82171044h case    3:*/		if ( regs.CR[6].eq ) { return 0x82171060;  }
		/* 82171044h case    3:*/		return 0x82171048;
		  /* 82171048h */ case    4:  		/* lis R8, -32252 */
		/* 82171048h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82171048h case    4:*/		return 0x8217104C;
		  /* 8217104Ch */ case    5:  		/* rlwimi R11, R9, 1, 27, 30 */
		/* 8217104Ch case    5:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R11,regs.R9);
		/* 8217104Ch case    5:*/		return 0x82171050;
		  /* 82171050h */ case    6:  		/* addi R8, R8, -704 */
		/* 82171050h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFD40);
		/* 82171050h case    6:*/		return 0x82171054;
		  /* 82171054h */ case    7:  		/* add R10, R10, R8 */
		/* 82171054h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82171054h case    7:*/		return 0x82171058;
		  /* 82171058h */ case    8:  		/* lbz R31, <#[R10 - 1]> */
		/* 82171058h case    8:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R10 + 0xFFFFFFFF) );
		/* 82171058h case    8:*/		return 0x8217105C;
		  /* 8217105Ch */ case    9:  		/* stw R11, <#[R30 + 8]> */
		/* 8217105Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8217105Ch case    9:*/		return 0x82171060;
	}
	return 0x82171060;
} // Block from 82171038h-82171060h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82171060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171060);
		  /* 82171060h */ case    0:  		/* mr R10, R29 */
		/* 82171060h case    0:*/		regs.R10 = regs.R29;
		/* 82171060h case    0:*/		return 0x82171064;
		  /* 82171064h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82171064h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82171064h case    1:*/		return 0x82171068;
		  /* 82171068h */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 82171068h case    2:*/		if ( regs.CR[6].eq ) { return 0x821710D8;  }
		/* 82171068h case    2:*/		return 0x8217106C;
		  /* 8217106Ch */ case    3:  		/* lwz R11, <#[R10]> */
		/* 8217106Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8217106Ch case    3:*/		return 0x82171070;
		  /* 82171070h */ case    4:  		/* rlwinm. R9, R11, 0, 4, 6 */
		/* 82171070h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R11);
		/* 82171070h case    4:*/		return 0x82171074;
		  /* 82171074h */ case    5:  		/* bc 12, CR0_EQ, 92 */
		/* 82171074h case    5:*/		if ( regs.CR[0].eq ) { return 0x821710D0;  }
		/* 82171074h case    5:*/		return 0x82171078;
		  /* 82171078h */ case    6:  		/* cmplwi CR6, R31, 228 */
		/* 82171078h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x000000E4);
		/* 82171078h case    6:*/		return 0x8217107C;
		  /* 8217107Ch */ case    7:  		/* bc 12, CR6_EQ, 68 */
		/* 8217107Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821710C0;  }
		/* 8217107Ch case    7:*/		return 0x82171080;
		  /* 82171080h */ case    8:  		/* rlwinm R9, R11, 22, 29, 30 */
		/* 82171080h case    8:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R11);
		/* 82171080h case    8:*/		return 0x82171084;
		  /* 82171084h */ case    9:  		/* rlwinm R8, R11, 24, 29, 30 */
		/* 82171084h case    9:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R11);
		/* 82171084h case    9:*/		return 0x82171088;
		  /* 82171088h */ case   10:  		/* srw R9, R31, R9 */
		/* 82171088h case   10:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R31,regs.R9);
		/* 82171088h case   10:*/		return 0x8217108C;
		  /* 8217108Ch */ case   11:  		/* srw R8, R31, R8 */
		/* 8217108Ch case   11:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R31,regs.R8);
		/* 8217108Ch case   11:*/		return 0x82171090;
		  /* 82171090h */ case   12:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 82171090h case   12:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 82171090h case   12:*/		return 0x82171094;
		  /* 82171094h */ case   13:  		/* rlwinm R9, R11, 26, 29, 30 */
		/* 82171094h case   13:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R11);
		/* 82171094h case   13:*/		return 0x82171098;
		  /* 82171098h */ case   14:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 82171098h case   14:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 82171098h case   14:*/		return 0x8217109C;
		  /* 8217109Ch */ case   15:  		/* srw R9, R31, R9 */
		/* 8217109Ch case   15:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R31,regs.R9);
		/* 8217109Ch case   15:*/		return 0x821710A0;
	}
	return 0x821710A0;
} // Block from 82171060h-821710A0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821710A0h
// Function '?MarkAutoZPassInstructions@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821710A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821710A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821710A0);
		  /* 821710A0h */ case    0:  		/* rlwinm R7, R11, 28, 29, 30 */
		/* 821710A0h case    0:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R11);
		/* 821710A0h case    0:*/		return 0x821710A4;
		  /* 821710A4h */ case    1:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 821710A4h case    1:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821710A4h case    1:*/		return 0x821710A8;
		  /* 821710A8h */ case    2:  		/* srw R8, R31, R7 */
		/* 821710A8h case    2:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R31,regs.R7);
		/* 821710A8h case    2:*/		return 0x821710AC;
		  /* 821710ACh */ case    3:  		/* rlwimi R8, R9, 2, 0, 29 */
		/* 821710ACh case    3:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 821710ACh case    3:*/		return 0x821710B0;
		  /* 821710B0h */ case    4:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821710B0h case    4:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821710B0h case    4:*/		return 0x821710B4;
		  /* 821710B4h */ case    5:  		/* rlwinm R9, R8, 5, 0, 26 */
		/* 821710B4h case    5:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R8);
		/* 821710B4h case    5:*/		return 0x821710B8;
		  /* 821710B8h */ case    6:  		/* or R11, R9, R11 */
		/* 821710B8h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821710B8h case    6:*/		return 0x821710BC;
		  /* 821710BCh */ case    7:  		/* stw R11, <#[R10]> */
		/* 821710BCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821710BCh case    7:*/		return 0x821710C0;
	}
	return 0x821710C0;
} // Block from 821710A0h-821710C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821710C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821710C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821710C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821710C0);
		  /* 821710C0h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 821710C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821710C0h case    0:*/		return 0x821710C4;
		  /* 821710C4h */ case    1:  		/* rlwinm R11, R11, 0, 19, 6 */
		/* 821710C4h case    1:*/		cpu::op::rlwinm<0,0,19,6>(regs,&regs.R11,regs.R11);
		/* 821710C4h case    1:*/		return 0x821710C8;
		  /* 821710C8h */ case    2:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 821710C8h case    2:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 821710C8h case    2:*/		return 0x821710CC;
		  /* 821710CCh */ case    3:  		/* stw R11, <#[R10]> */
		/* 821710CCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821710CCh case    3:*/		return 0x821710D0;
	}
	return 0x821710D0;
} // Block from 821710C0h-821710D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821710D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821710D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821710D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821710D0);
		  /* 821710D0h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821710D0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821710D0h case    0:*/		return 0x821710D4;
		  /* 821710D4h */ case    1:  		/* b -112 */
		/* 821710D4h case    1:*/		return 0x82171064;
		/* 821710D4h case    1:*/		return 0x821710D8;
	}
	return 0x821710D8;
} // Block from 821710D0h-821710D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821710D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821710D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821710D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821710D8);
		  /* 821710D8h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 821710D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 821710D8h case    0:*/		return 0x821710DC;
		  /* 821710DCh */ case    1:  		/* rlwinm R11, R11, 0, 19, 6 */
		/* 821710DCh case    1:*/		cpu::op::rlwinm<0,0,19,6>(regs,&regs.R11,regs.R11);
		/* 821710DCh case    1:*/		return 0x821710E0;
		  /* 821710E0h */ case    2:  		/* stw R11, <#[R30 + 20]> */
		/* 821710E0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 821710E0h case    2:*/		return 0x821710E4;
		  /* 821710E4h */ case    3:  		/* addi R1, R1, 112 */
		/* 821710E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821710E4h case    3:*/		return 0x821710E8;
		  /* 821710E8h */ case    4:  		/* b -917052 */
		/* 821710E8h case    4:*/		return 0x820912AC;
		/* 821710E8h case    4:*/		return 0x821710EC;
		  /* 821710ECh */ case    5:  		/* nop */
		/* 821710ECh case    5:*/		cpu::op::nop();
		/* 821710ECh case    5:*/		return 0x821710F0;
	}
	return 0x821710F0;
} // Block from 821710D8h-821710F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821710F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821710F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821710F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821710F0);
		  /* 821710F0h */ case    0:  		/* mfspr R12, LR */
		/* 821710F0h case    0:*/		regs.R12 = regs.LR;
		/* 821710F0h case    0:*/		return 0x821710F4;
		  /* 821710F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821710F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821710F4h case    1:*/		return 0x821710F8;
		  /* 821710F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821710F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821710F8h case    2:*/		return 0x821710FC;
		  /* 821710FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821710FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821710FCh case    3:*/		return 0x82171100;
		  /* 82171100h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82171100h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82171100h case    4:*/		return 0x82171104;
		  /* 82171104h */ case    5:  		/* mr R31, R4 */
		/* 82171104h case    5:*/		regs.R31 = regs.R4;
		/* 82171104h case    5:*/		return 0x82171108;
		  /* 82171108h */ case    6:  		/* mr R30, R5 */
		/* 82171108h case    6:*/		regs.R30 = regs.R5;
		/* 82171108h case    6:*/		return 0x8217110C;
		  /* 8217110Ch */ case    7:  		/* li R5, 26 */
		/* 8217110Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1A);
		/* 8217110Ch case    7:*/		return 0x82171110;
		  /* 82171110h */ case    8:  		/* li R4, 20 */
		/* 82171110h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82171110h case    8:*/		return 0x82171114;
		  /* 82171114h */ case    9:  		/* bl -17772 */
		/* 82171114h case    9:*/		regs.LR = 0x82171118; return 0x8216CBA8;
		/* 82171114h case    9:*/		return 0x82171118;
		  /* 82171118h */ case   10:  		/* li R11, 5 */
		/* 82171118h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 82171118h case   10:*/		return 0x8217111C;
		  /* 8217111Ch */ case   11:  		/* addi R10, R31, -4 */
		/* 8217111Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFFC);
		/* 8217111Ch case   11:*/		return 0x82171120;
		  /* 82171120h */ case   12:  		/* addi R9, R3, -4 */
		/* 82171120h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0xFFFFFFFC);
		/* 82171120h case   12:*/		return 0x82171124;
		  /* 82171124h */ case   13:  		/* mtspr CTR, R11 */
		/* 82171124h case   13:*/		regs.CTR = regs.R11;
		/* 82171124h case   13:*/		return 0x82171128;
		  /* 82171128h */ case   14:  		/* lwzu R11, <#[R10 + 4]> */
		/* 82171128h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82171128h case   14:*/		return 0x8217112C;
		  /* 8217112Ch */ case   15:  		/* stwu R11, <#[R9 + 4]> */
		/* 8217112Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8217112Ch case   15:*/		return 0x82171130;
		  /* 82171130h */ case   16:  		/* bc 16, CR0_LT, -8 */
		/* 82171130h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82171128;  }
		/* 82171130h case   16:*/		return 0x82171134;
		  /* 82171134h */ case   17:  		/* li R11, 0 */
		/* 82171134h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82171134h case   17:*/		return 0x82171138;
		  /* 82171138h */ case   18:  		/* stw R30, <#[R3 + 12]> */
		/* 82171138h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 82171138h case   18:*/		return 0x8217113C;
		  /* 8217113Ch */ case   19:  		/* stw R11, <#[R3 + 16]> */
		/* 8217113Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8217113Ch case   19:*/		return 0x82171140;
		  /* 82171140h */ case   20:  		/* lwz R11, <#[R30 + 4]> */
		/* 82171140h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82171140h case   20:*/		return 0x82171144;
		  /* 82171144h */ case   21:  		/* stw R11, <#[R3 + 8]> */
		/* 82171144h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82171144h case   21:*/		return 0x82171148;
		  /* 82171148h */ case   22:  		/* stw R3, <#[R30 + 4]> */
		/* 82171148h case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 82171148h case   22:*/		return 0x8217114C;
		  /* 8217114Ch */ case   23:  		/* addi R1, R1, 112 */
		/* 8217114Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8217114Ch case   23:*/		return 0x82171150;
		  /* 82171150h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 82171150h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82171150h case   24:*/		return 0x82171154;
		  /* 82171154h */ case   25:  		/* mtspr LR, R12 */
		/* 82171154h case   25:*/		regs.LR = regs.R12;
		/* 82171154h case   25:*/		return 0x82171158;
		  /* 82171158h */ case   26:  		/* ld R30, <#[R1 - 24]> */
		/* 82171158h case   26:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82171158h case   26:*/		return 0x8217115C;
		  /* 8217115Ch */ case   27:  		/* ld R31, <#[R1 - 16]> */
		/* 8217115Ch case   27:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8217115Ch case   27:*/		return 0x82171160;
		  /* 82171160h */ case   28:  		/* bclr 20, CR0_LT */
		/* 82171160h case   28:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171160h case   28:*/		return 0x82171164;
	}
	return 0x82171164;
} // Block from 821710F0h-82171164h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82171164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171164);
		  /* 82171164h */ case    0:  		/* nop */
		/* 82171164h case    0:*/		cpu::op::nop();
		/* 82171164h case    0:*/		return 0x82171168;
	}
	return 0x82171168;
} // Block from 82171164h-82171168h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171168h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171168);
		  /* 82171168h */ case    0:  		/* mfspr R12, LR */
		/* 82171168h case    0:*/		regs.R12 = regs.LR;
		/* 82171168h case    0:*/		return 0x8217116C;
		  /* 8217116Ch */ case    1:  		/* bl -917288 */
		/* 8217116Ch case    1:*/		regs.LR = 0x82171170; return 0x82091244;
		/* 8217116Ch case    1:*/		return 0x82171170;
		  /* 82171170h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82171170h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82171170h case    2:*/		return 0x82171174;
		  /* 82171174h */ case    3:  		/* lwz R11, <#[R4 + 88]> */
		/* 82171174h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000058) );
		/* 82171174h case    3:*/		return 0x82171178;
		  /* 82171178h */ case    4:  		/* mr R31, R3 */
		/* 82171178h case    4:*/		regs.R31 = regs.R3;
		/* 82171178h case    4:*/		return 0x8217117C;
		  /* 8217117Ch */ case    5:  		/* mr R26, R4 */
		/* 8217117Ch case    5:*/		regs.R26 = regs.R4;
		/* 8217117Ch case    5:*/		return 0x82171180;
		  /* 82171180h */ case    6:  		/* mr R23, R5 */
		/* 82171180h case    6:*/		regs.R23 = regs.R5;
		/* 82171180h case    6:*/		return 0x82171184;
		  /* 82171184h */ case    7:  		/* li R24, 0 */
		/* 82171184h case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82171184h case    7:*/		return 0x82171188;
		  /* 82171188h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82171188h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82171188h case    8:*/		return 0x8217118C;
		  /* 8217118Ch */ case    9:  		/* bc 12, CR6_EQ, 256 */
		/* 8217118Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8217128C;  }
		/* 8217118Ch case    9:*/		return 0x82171190;
		  /* 82171190h */ case   10:  		/* lhz R27, <#[R5 + 18]> */
		/* 82171190h case   10:*/		cpu::mem::load16z( regs, &regs.R27, (uint32)(regs.R5 + 0x00000012) );
		/* 82171190h case   10:*/		return 0x82171194;
		  /* 82171194h */ case   11:  		/* lwz R11, <#[R3 + 668]> */
		/* 82171194h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000029C) );
		/* 82171194h case   11:*/		return 0x82171198;
		  /* 82171198h */ case   12:  		/* cmplw CR6, R27, R11 */
		/* 82171198h case   12:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82171198h case   12:*/		return 0x8217119C;
		  /* 8217119Ch */ case   13:  		/* bc 4, CR6_LT, 240 */
		/* 8217119Ch case   13:*/		if ( !regs.CR[6].lt ) { return 0x8217128C;  }
		/* 8217119Ch case   13:*/		return 0x821711A0;
		  /* 821711A0h */ case   14:  		/* rlwinm R25, R27, 2, 0, 29 */
		/* 821711A0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R27);
		/* 821711A0h case   14:*/		return 0x821711A4;
		  /* 821711A4h */ case   15:  		/* lwz R11, <#[R31 + 708]> */
		/* 821711A4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002C4) );
		/* 821711A4h case   15:*/		return 0x821711A8;
		  /* 821711A8h */ case   16:  		/* lwzx R11, <#[R25 + R11]> */
		/* 821711A8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 821711A8h case   16:*/		return 0x821711AC;
		  /* 821711ACh */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 821711ACh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821711ACh case   17:*/		return 0x821711B0;
		  /* 821711B0h */ case   18:  		/* bc 12, CR6_EQ, 200 */
		/* 821711B0h case   18:*/		if ( regs.CR[6].eq ) { return 0x82171278;  }
		/* 821711B0h case   18:*/		return 0x821711B4;
		  /* 821711B4h */ case   19:  		/* cmplw CR6, R11, R23 */
		/* 821711B4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 821711B4h case   19:*/		return 0x821711B8;
		  /* 821711B8h */ case   20:  		/* bc 4, CR6_EQ, 212 */
		/* 821711B8h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8217128C;  }
		/* 821711B8h case   20:*/		return 0x821711BC;
		  /* 821711BCh */ case   21:  		/* mr R4, R27 */
		/* 821711BCh case   21:*/		regs.R4 = regs.R27;
		/* 821711BCh case   21:*/		return 0x821711C0;
		  /* 821711C0h */ case   22:  		/* mr R3, R31 */
		/* 821711C0h case   22:*/		regs.R3 = regs.R31;
		/* 821711C0h case   22:*/		return 0x821711C4;
		  /* 821711C4h */ case   23:  		/* bl 75676 */
		/* 821711C4h case   23:*/		regs.LR = 0x821711C8; return 0x82183960;
		/* 821711C4h case   23:*/		return 0x821711C8;
		  /* 821711C8h */ case   24:  		/* li R4, 0 */
		/* 821711C8h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821711C8h case   24:*/		return 0x821711CC;
		  /* 821711CCh */ case   25:  		/* mr R28, R3 */
		/* 821711CCh case   25:*/		regs.R28 = regs.R3;
		/* 821711CCh case   25:*/		return 0x821711D0;
		  /* 821711D0h */ case   26:  		/* lwz R3, <#[R26 + 88]> */
		/* 821711D0h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000058) );
		/* 821711D0h case   26:*/		return 0x821711D4;
		  /* 821711D4h */ case   27:  		/* lwz R5, <#[R31 + 672]> */
		/* 821711D4h case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 821711D4h case   27:*/		return 0x821711D8;
		  /* 821711D8h */ case   28:  		/* bl -8832 */
		/* 821711D8h case   28:*/		regs.LR = 0x821711DC; return 0x8216EF58;
		/* 821711D8h case   28:*/		return 0x821711DC;
		  /* 821711DCh */ case   29:  		/* lwz R11, <#[R31 + 668]> */
		/* 821711DCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 821711DCh case   29:*/		return 0x821711E0;
		  /* 821711E0h */ case   30:  		/* mr R30, R3 */
		/* 821711E0h case   30:*/		regs.R30 = regs.R3;
		/* 821711E0h case   30:*/		return 0x821711E4;
		  /* 821711E4h */ case   31:  		/* addi R11, R11, -1 */
		/* 821711E4h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821711E4h case   31:*/		return 0x821711E8;
		  /* 821711E8h */ case   32:  		/* cmplw CR6, R3, R11 */
		/* 821711E8h case   32:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 821711E8h case   32:*/		return 0x821711EC;
		  /* 821711ECh */ case   33:  		/* bc 12, CR6_GT, 140 */
		/* 821711ECh case   33:*/		if ( regs.CR[6].gt ) { return 0x82171278;  }
		/* 821711ECh case   33:*/		return 0x821711F0;
		  /* 821711F0h */ case   34:  		/* mr R4, R30 */
		/* 821711F0h case   34:*/		regs.R4 = regs.R30;
		/* 821711F0h case   34:*/		return 0x821711F4;
		  /* 821711F4h */ case   35:  		/* mr R3, R31 */
		/* 821711F4h case   35:*/		regs.R3 = regs.R31;
		/* 821711F4h case   35:*/		return 0x821711F8;
		  /* 821711F8h */ case   36:  		/* bl 75624 */
		/* 821711F8h case   36:*/		regs.LR = 0x821711FC; return 0x82183960;
		/* 821711F8h case   36:*/		return 0x821711FC;
		  /* 821711FCh */ case   37:  		/* cmplw CR6, R3, R28 */
		/* 821711FCh case   37:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R28);
		/* 821711FCh case   37:*/		return 0x82171200;
		  /* 82171200h */ case   38:  		/* bc 12, CR6_EQ, 60 */
		/* 82171200h case   38:*/		if ( regs.CR[6].eq ) { return 0x8217123C;  }
		/* 82171200h case   38:*/		return 0x82171204;
		  /* 82171204h */ case   39:  		/* lwz R11, <#[R31 + 668]> */
		/* 82171204h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 82171204h case   39:*/		return 0x82171208;
		  /* 82171208h */ case   40:  		/* addi R29, R11, -1 */
		/* 82171208h case   40:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFF);
		/* 82171208h case   40:*/		return 0x8217120C;
		  /* 8217120Ch */ case   41:  		/* cmplw CR6, R30, R29 */
		/* 8217120Ch case   41:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 8217120Ch case   41:*/		return 0x82171210;
		  /* 82171210h */ case   42:  		/* bc 4, CR6_EQ, 12 */
		/* 82171210h case   42:*/		if ( !regs.CR[6].eq ) { return 0x8217121C;  }
		/* 82171210h case   42:*/		return 0x82171214;
		  /* 82171214h */ case   43:  		/* li R30, -1 */
		/* 82171214h case   43:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82171214h case   43:*/		return 0x82171218;
		  /* 82171218h */ case   44:  		/* b 24 */
		/* 82171218h case   44:*/		return 0x82171230;
		/* 82171218h case   44:*/		return 0x8217121C;
	}
	return 0x8217121C;
} // Block from 82171168h-8217121Ch (45 instructions)

//////////////////////////////////////////////////////
// Block at 8217121Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217121C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217121C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217121C);
		  /* 8217121Ch */ case    0:  		/* addi R4, R30, 1 */
		/* 8217121Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x1);
		/* 8217121Ch case    0:*/		return 0x82171220;
		  /* 82171220h */ case    1:  		/* lwz R5, <#[R31 + 672]> */
		/* 82171220h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 82171220h case    1:*/		return 0x82171224;
		  /* 82171224h */ case    2:  		/* lwz R3, <#[R26 + 88]> */
		/* 82171224h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000058) );
		/* 82171224h case    2:*/		return 0x82171228;
		  /* 82171228h */ case    3:  		/* bl -8912 */
		/* 82171228h case    3:*/		regs.LR = 0x8217122C; return 0x8216EF58;
		/* 82171228h case    3:*/		return 0x8217122C;
		  /* 8217122Ch */ case    4:  		/* mr R30, R3 */
		/* 8217122Ch case    4:*/		regs.R30 = regs.R3;
		/* 8217122Ch case    4:*/		return 0x82171230;
	}
	return 0x82171230;
} // Block from 8217121Ch-82171230h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82171230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171230);
		  /* 82171230h */ case    0:  		/* cmplw CR6, R30, R29 */
		/* 82171230h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 82171230h case    0:*/		return 0x82171234;
		  /* 82171234h */ case    1:  		/* bc 4, CR6_GT, -68 */
		/* 82171234h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821711F0;  }
		/* 82171234h case    1:*/		return 0x82171238;
		  /* 82171238h */ case    2:  		/* b 64 */
		/* 82171238h case    2:*/		return 0x82171278;
		/* 82171238h case    2:*/		return 0x8217123C;
	}
	return 0x8217123C;
} // Block from 82171230h-8217123Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8217123Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217123C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217123C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217123C);
		  /* 8217123Ch */ case    0:  		/* mr R4, R28 */
		/* 8217123Ch case    0:*/		regs.R4 = regs.R28;
		/* 8217123Ch case    0:*/		return 0x82171240;
		  /* 82171240h */ case    1:  		/* mr R3, R31 */
		/* 82171240h case    1:*/		regs.R3 = regs.R31;
		/* 82171240h case    1:*/		return 0x82171244;
		  /* 82171244h */ case    2:  		/* bl 76676 */
		/* 82171244h case    2:*/		regs.LR = 0x82171248; return 0x82183DC8;
		/* 82171244h case    2:*/		return 0x82171248;
		  /* 82171248h */ case    3:  		/* mr R30, R3 */
		/* 82171248h case    3:*/		regs.R30 = regs.R3;
		/* 82171248h case    3:*/		return 0x8217124C;
		  /* 8217124Ch */ case    4:  		/* mr R4, R28 */
		/* 8217124Ch case    4:*/		regs.R4 = regs.R28;
		/* 8217124Ch case    4:*/		return 0x82171250;
		  /* 82171250h */ case    5:  		/* mr R3, R31 */
		/* 82171250h case    5:*/		regs.R3 = regs.R31;
		/* 82171250h case    5:*/		return 0x82171254;
		  /* 82171254h */ case    6:  		/* bl 76548 */
		/* 82171254h case    6:*/		regs.LR = 0x82171258; return 0x82183D58;
		/* 82171254h case    6:*/		return 0x82171258;
		  /* 82171258h */ case    7:  		/* lwz R11, <#[R30 + 192]> */
		/* 82171258h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000C0) );
		/* 82171258h case    7:*/		return 0x8217125C;
		  /* 8217125Ch */ case    8:  		/* rlwinm R10, R3, 1, 0, 30 */
		/* 8217125Ch case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R3);
		/* 8217125Ch case    8:*/		return 0x82171260;
		  /* 82171260h */ case    9:  		/* rlwinm R11, R11, 18, 24, 31 */
		/* 82171260h case    9:*/		cpu::op::rlwinm<0,18,24,31>(regs,&regs.R11,regs.R11);
		/* 82171260h case    9:*/		return 0x82171264;
		  /* 82171264h */ case   10:  		/* li R9, 1 */
		/* 82171264h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82171264h case   10:*/		return 0x82171268;
		  /* 82171268h */ case   11:  		/* srw R11, R11, R10 */
		/* 82171268h case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82171268h case   11:*/		return 0x8217126C;
		  /* 8217126Ch */ case   12:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8217126Ch case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8217126Ch case   12:*/		return 0x82171270;
		  /* 82171270h */ case   13:  		/* slw R11, R9, R11 */
		/* 82171270h case   13:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82171270h case   13:*/		return 0x82171274;
		  /* 82171274h */ case   14:  		/* or R24, R11, R24 */
		/* 82171274h case   14:*/		cpu::op::or<0>(regs,&regs.R24,regs.R11,regs.R24);
		/* 82171274h case   14:*/		return 0x82171278;
	}
	return 0x82171278;
} // Block from 8217123Ch-82171278h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82171278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171278);
		  /* 82171278h */ case    0:  		/* lwz R11, <#[R31 + 668]> */
		/* 82171278h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 82171278h case    0:*/		return 0x8217127C;
		  /* 8217127Ch */ case    1:  		/* addi R27, R27, 1 */
		/* 8217127Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8217127Ch case    1:*/		return 0x82171280;
		  /* 82171280h */ case    2:  		/* addi R25, R25, 4 */
		/* 82171280h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82171280h case    2:*/		return 0x82171284;
		  /* 82171284h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 82171284h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82171284h case    3:*/		return 0x82171288;
		  /* 82171288h */ case    4:  		/* bc 12, CR6_LT, -228 */
		/* 82171288h case    4:*/		if ( regs.CR[6].lt ) { return 0x821711A4;  }
		/* 82171288h case    4:*/		return 0x8217128C;
	}
	return 0x8217128C;
} // Block from 82171278h-8217128Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8217128Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217128C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217128C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217128C);
		  /* 8217128Ch */ case    0:  		/* mr R3, R24 */
		/* 8217128Ch case    0:*/		regs.R3 = regs.R24;
		/* 8217128Ch case    0:*/		return 0x82171290;
		  /* 82171290h */ case    1:  		/* addi R1, R1, 160 */
		/* 82171290h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82171290h case    1:*/		return 0x82171294;
		  /* 82171294h */ case    2:  		/* b -917504 */
		/* 82171294h case    2:*/		return 0x82091294;
		/* 82171294h case    2:*/		return 0x82171298;
	}
	return 0x82171298;
} // Block from 8217128Ch-82171298h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171298);
		  /* 82171298h */ case    0:  		/* mfspr R12, LR */
		/* 82171298h case    0:*/		regs.R12 = regs.LR;
		/* 82171298h case    0:*/		return 0x8217129C;
		  /* 8217129Ch */ case    1:  		/* bl -917592 */
		/* 8217129Ch case    1:*/		regs.LR = 0x821712A0; return 0x82091244;
		/* 8217129Ch case    1:*/		return 0x821712A0;
		  /* 821712A0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821712A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821712A0h case    2:*/		return 0x821712A4;
		  /* 821712A4h */ case    3:  		/* lwz R28, <#[R4]> */
		/* 821712A4h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x00000000) );
		/* 821712A4h case    3:*/		return 0x821712A8;
		  /* 821712A8h */ case    4:  		/* mr R29, R4 */
		/* 821712A8h case    4:*/		regs.R29 = regs.R4;
		/* 821712A8h case    4:*/		return 0x821712AC;
		  /* 821712ACh */ case    5:  		/* mr R25, R5 */
		/* 821712ACh case    5:*/		regs.R25 = regs.R5;
		/* 821712ACh case    5:*/		return 0x821712B0;
		  /* 821712B0h */ case    6:  		/* mr R27, R6 */
		/* 821712B0h case    6:*/		regs.R27 = regs.R6;
		/* 821712B0h case    6:*/		return 0x821712B4;
		  /* 821712B4h */ case    7:  		/* mr R24, R7 */
		/* 821712B4h case    7:*/		regs.R24 = regs.R7;
		/* 821712B4h case    7:*/		return 0x821712B8;
		  /* 821712B8h */ case    8:  		/* mr R23, R8 */
		/* 821712B8h case    8:*/		regs.R23 = regs.R8;
		/* 821712B8h case    8:*/		return 0x821712BC;
		  /* 821712BCh */ case    9:  		/* li R26, 0 */
		/* 821712BCh case    9:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821712BCh case    9:*/		return 0x821712C0;
		  /* 821712C0h */ case   10:  		/* cmplwi CR6, R28, 0 */
		/* 821712C0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821712C0h case   10:*/		return 0x821712C4;
		  /* 821712C4h */ case   11:  		/* bc 12, CR6_EQ, 280 */
		/* 821712C4h case   11:*/		if ( regs.CR[6].eq ) { return 0x821713DC;  }
		/* 821712C4h case   11:*/		return 0x821712C8;
		  /* 821712C8h */ case   12:  		/* mr R3, R28 */
		/* 821712C8h case   12:*/		regs.R3 = regs.R28;
		/* 821712C8h case   12:*/		return 0x821712CC;
		  /* 821712CCh */ case   13:  		/* bl -51868 */
		/* 821712CCh case   13:*/		regs.LR = 0x821712D0; return 0x82164830;
		/* 821712CCh case   13:*/		return 0x821712D0;
		  /* 821712D0h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821712D0h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821712D0h case   14:*/		return 0x821712D4;
		  /* 821712D4h */ case   15:  		/* bc 12, CR0_EQ, 256 */
		/* 821712D4h case   15:*/		if ( regs.CR[0].eq ) { return 0x821713D4;  }
		/* 821712D4h case   15:*/		return 0x821712D8;
		  /* 821712D8h */ case   16:  		/* lwz R30, <#[R28 + 12]> */
		/* 821712D8h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x0000000C) );
		/* 821712D8h case   16:*/		return 0x821712DC;
		  /* 821712DCh */ case   17:  		/* lwz R11, <#[R30 + 8]> */
		/* 821712DCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821712DCh case   17:*/		return 0x821712E0;
		  /* 821712E0h */ case   18:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821712E0h case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821712E0h case   18:*/		return 0x821712E4;
		  /* 821712E4h */ case   19:  		/* cmplwi CR6, R11, 15360 */
		/* 821712E4h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 821712E4h case   19:*/		return 0x821712E8;
		  /* 821712E8h */ case   20:  		/* bc 12, CR6_EQ, 236 */
		/* 821712E8h case   20:*/		if ( regs.CR[6].eq ) { return 0x821713D4;  }
		/* 821712E8h case   20:*/		return 0x821712EC;
		  /* 821712ECh */ case   21:  		/* lwz R11, <#[R30 + 28]> */
		/* 821712ECh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821712ECh case   21:*/		return 0x821712F0;
		  /* 821712F0h */ case   22:  		/* lwz R10, <#[R29 + 28]> */
		/* 821712F0h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000001C) );
		/* 821712F0h case   22:*/		return 0x821712F4;
		  /* 821712F4h */ case   23:  		/* cmpw CR6, R11, R10 */
		/* 821712F4h case   23:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 821712F4h case   23:*/		return 0x821712F8;
		  /* 821712F8h */ case   24:  		/* bc 4, CR6_EQ, 36 */
		/* 821712F8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8217131C;  }
		/* 821712F8h case   24:*/		return 0x821712FC;
		  /* 821712FCh */ case   25:  		/* lwz R11, <#[R30 + 20]> */
		/* 821712FCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 821712FCh case   25:*/		return 0x82171300;
		  /* 82171300h */ case   26:  		/* rlwinm. R10, R11, 0, 15, 18 */
		/* 82171300h case   26:*/		cpu::op::rlwinm<1,0,15,18>(regs,&regs.R10,regs.R11);
		/* 82171300h case   26:*/		return 0x82171304;
		  /* 82171304h */ case   27:  		/* bc 12, CR0_EQ, 24 */
		/* 82171304h case   27:*/		if ( regs.CR[0].eq ) { return 0x8217131C;  }
		/* 82171304h case   27:*/		return 0x82171308;
		  /* 82171308h */ case   28:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 82171308h case   28:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 82171308h case   28:*/		return 0x8217130C;
		  /* 8217130Ch */ case   29:  		/* cmplw CR6, R11, R24 */
		/* 8217130Ch case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 8217130Ch case   29:*/		return 0x82171310;
		  /* 82171310h */ case   30:  		/* bc 4, CR6_EQ, 12 */
		/* 82171310h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8217131C;  }
		/* 82171310h case   30:*/		return 0x82171314;
		  /* 82171314h */ case   31:  		/* li R11, 1 */
		/* 82171314h case   31:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82171314h case   31:*/		return 0x82171318;
		  /* 82171318h */ case   32:  		/* stb R11, <#[R23]> */
		/* 82171318h case   32:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82171318h case   32:*/		return 0x8217131C;
	}
	return 0x8217131C;
} // Block from 82171298h-8217131Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 8217131Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217131C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217131C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217131C);
		  /* 8217131Ch */ case    0:  		/* lwz R31, <#[R29]> */
		/* 8217131Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 8217131Ch case    0:*/		return 0x82171320;
		  /* 82171320h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82171320h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82171320h case    1:*/		return 0x82171324;
		  /* 82171324h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 82171324h case    2:*/		if ( regs.CR[6].eq ) { return 0x82171354;  }
		/* 82171324h case    2:*/		return 0x82171328;
	}
	return 0x82171328;
} // Block from 8217131Ch-82171328h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171328h
// Function '?CreateZPassShader@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171328);
		  /* 82171328h */ case    0:  		/* cmplw CR6, R31, R28 */
		/* 82171328h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 82171328h case    0:*/		return 0x8217132C;
		  /* 8217132Ch */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8217132Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8217135C;  }
		/* 8217132Ch case    1:*/		return 0x82171330;
		  /* 82171330h */ case    2:  		/* mr R3, R31 */
		/* 82171330h case    2:*/		regs.R3 = regs.R31;
		/* 82171330h case    2:*/		return 0x82171334;
		  /* 82171334h */ case    3:  		/* bl -51972 */
		/* 82171334h case    3:*/		regs.LR = 0x82171338; return 0x82164830;
		/* 82171334h case    3:*/		return 0x82171338;
		  /* 82171338h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82171338h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82171338h case    4:*/		return 0x8217133C;
		  /* 8217133Ch */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 8217133Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8217134C;  }
		/* 8217133Ch case    5:*/		return 0x82171340;
		  /* 82171340h */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 82171340h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82171340h case    6:*/		return 0x82171344;
		  /* 82171344h */ case    7:  		/* cmplw CR6, R11, R30 */
		/* 82171344h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82171344h case    7:*/		return 0x82171348;
		  /* 82171348h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82171348h case    8:*/		if ( regs.CR[6].eq ) { return 0x82171354;  }
		/* 82171348h case    8:*/		return 0x8217134C;
	}
	return 0x8217134C;
} // Block from 82171328h-8217134Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8217134Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217134C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217134C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217134C);
		  /* 8217134Ch */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 8217134Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8217134Ch case    0:*/		return 0x82171350;
		  /* 82171350h */ case    1:  		/* b -48 */
		/* 82171350h case    1:*/		return 0x82171320;
		/* 82171350h case    1:*/		return 0x82171354;
	}
	return 0x82171354;
} // Block from 8217134Ch-82171354h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171354);
		  /* 82171354h */ case    0:  		/* cmplw CR6, R31, R28 */
		/* 82171354h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 82171354h case    0:*/		return 0x82171358;
		  /* 82171358h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 82171358h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821713D4;  }
		/* 82171358h case    1:*/		return 0x8217135C;
	}
	return 0x8217135C;
} // Block from 82171354h-8217135Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217135Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217135C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217135C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217135C);
		  /* 8217135Ch */ case    0:  		/* lwz R9, <#[R30 + 4]> */
		/* 8217135Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 8217135Ch case    0:*/		return 0x82171360;
		  /* 82171360h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82171360h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82171360h case    1:*/		return 0x82171364;
		  /* 82171364h */ case    2:  		/* bc 12, CR6_EQ, 80 */
		/* 82171364h case    2:*/		if ( regs.CR[6].eq ) { return 0x821713B4;  }
		/* 82171364h case    2:*/		return 0x82171368;
		  /* 82171368h */ case    3:  		/* lwz R11, <#[R9 + 16]> */
		/* 82171368h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 82171368h case    3:*/		return 0x8217136C;
		  /* 8217136Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8217136Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217136Ch case    4:*/		return 0x82171370;
		  /* 82171370h */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 82171370h case    5:*/		if ( regs.CR[6].eq ) { return 0x821713AC;  }
		/* 82171370h case    5:*/		return 0x82171374;
		  /* 82171374h */ case    6:  		/* cmplw CR6, R11, R29 */
		/* 82171374h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82171374h case    6:*/		return 0x82171378;
		  /* 82171378h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 82171378h case    7:*/		if ( regs.CR[6].eq ) { return 0x821713AC;  }
		/* 82171378h case    7:*/		return 0x8217137C;
		  /* 8217137Ch */ case    8:  		/* lwz R10, <#[R11 + 8]> */
		/* 8217137Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8217137Ch case    8:*/		return 0x82171380;
		  /* 82171380h */ case    9:  		/* rlwinm. R8, R10, 6, 31, 31 */
		/* 82171380h case    9:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R8,regs.R10);
		/* 82171380h case    9:*/		return 0x82171384;
		  /* 82171384h */ case   10:  		/* bc 12, CR0_EQ, 40 */
		/* 82171384h case   10:*/		if ( regs.CR[0].eq ) { return 0x821713AC;  }
		/* 82171384h case   10:*/		return 0x82171388;
		  /* 82171388h */ case   11:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82171388h case   11:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82171388h case   11:*/		return 0x8217138C;
		  /* 8217138Ch */ case   12:  		/* cmplwi CR6, R10, 14336 */
		/* 8217138Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003800);
		/* 8217138Ch case   12:*/		return 0x82171390;
		  /* 82171390h */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 82171390h case   13:*/		if ( regs.CR[6].eq ) { return 0x821713AC;  }
		/* 82171390h case   13:*/		return 0x82171394;
		  /* 82171394h */ case   14:  		/* lwz R10, <#[R11 + 16]> */
		/* 82171394h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82171394h case   14:*/		return 0x82171398;
		  /* 82171398h */ case   15:  		/* lwz R11, <#[R11 + 20]> */
		/* 82171398h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82171398h case   15:*/		return 0x8217139C;
		  /* 8217139Ch */ case   16:  		/* rlwimi R10, R11, 27, 5, 31 */
		/* 8217139Ch case   16:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8217139Ch case   16:*/		return 0x821713A0;
		  /* 821713A0h */ case   17:  		/* rlwinm R11, R10, 12, 21, 31 */
		/* 821713A0h case   17:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R11,regs.R10);
		/* 821713A0h case   17:*/		return 0x821713A4;
		  /* 821713A4h */ case   18:  		/* cmplw CR6, R11, R25 */
		/* 821713A4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821713A4h case   18:*/		return 0x821713A8;
		  /* 821713A8h */ case   19:  		/* bc 12, CR6_EQ, 24 */
		/* 821713A8h case   19:*/		if ( regs.CR[6].eq ) { return 0x821713C0;  }
		/* 821713A8h case   19:*/		return 0x821713AC;
	}
	return 0x821713AC;
} // Block from 8217135Ch-821713ACh (20 instructions)

//////////////////////////////////////////////////////
// Block at 821713ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821713AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821713AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821713AC);
		  /* 821713ACh */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 821713ACh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821713ACh case    0:*/		return 0x821713B0;
		  /* 821713B0h */ case    1:  		/* b -80 */
		/* 821713B0h case    1:*/		return 0x82171360;
		/* 821713B0h case    1:*/		return 0x821713B4;
	}
	return 0x821713B4;
} // Block from 821713ACh-821713B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821713B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821713B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821713B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821713B4);
		  /* 821713B4h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 821713B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821713B4h case    0:*/		return 0x821713B8;
		  /* 821713B8h */ case    1:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821713B8h case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821713B8h case    1:*/		return 0x821713BC;
		  /* 821713BCh */ case    2:  		/* add R26, R11, R26 */
		/* 821713BCh case    2:*/		cpu::op::add<0>(regs,&regs.R26,regs.R11,regs.R26);
		/* 821713BCh case    2:*/		return 0x821713C0;
	}
	return 0x821713C0;
} // Block from 821713B4h-821713C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821713C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821713C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821713C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821713C0);
		  /* 821713C0h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 821713C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821713C0h case    0:*/		return 0x821713C4;
		  /* 821713C4h */ case    1:  		/* lwz R10, <#[R27]> */
		/* 821713C4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821713C4h case    1:*/		return 0x821713C8;
		  /* 821713C8h */ case    2:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821713C8h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821713C8h case    2:*/		return 0x821713CC;
		  /* 821713CCh */ case    3:  		/* add R11, R11, R10 */
		/* 821713CCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821713CCh case    3:*/		return 0x821713D0;
		  /* 821713D0h */ case    4:  		/* stw R11, <#[R27]> */
		/* 821713D0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821713D0h case    4:*/		return 0x821713D4;
	}
	return 0x821713D4;
} // Block from 821713C0h-821713D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821713D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821713D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821713D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821713D4);
		  /* 821713D4h */ case    0:  		/* lwz R28, <#[R28 + 4]> */
		/* 821713D4h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000004) );
		/* 821713D4h case    0:*/		return 0x821713D8;
		  /* 821713D8h */ case    1:  		/* b -280 */
		/* 821713D8h case    1:*/		return 0x821712C0;
		/* 821713D8h case    1:*/		return 0x821713DC;
	}
	return 0x821713DC;
} // Block from 821713D4h-821713DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821713DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821713DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821713DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821713DC);
		  /* 821713DCh */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 821713DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821713DCh case    0:*/		return 0x821713E0;
		  /* 821713E0h */ case    1:  		/* lwz R10, <#[R27]> */
		/* 821713E0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821713E0h case    1:*/		return 0x821713E4;
		  /* 821713E4h */ case    2:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821713E4h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821713E4h case    2:*/		return 0x821713E8;
		  /* 821713E8h */ case    3:  		/* subf R11, R11, R10 */
		/* 821713E8h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821713E8h case    3:*/		return 0x821713EC;
		  /* 821713ECh */ case    4:  		/* stw R11, <#[R27]> */
		/* 821713ECh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821713ECh case    4:*/		return 0x821713F0;
		  /* 821713F0h */ case    5:  		/* lwz R11, <#[R29 + 8]> */
		/* 821713F0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821713F0h case    5:*/		return 0x821713F4;
		  /* 821713F4h */ case    6:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821713F4h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821713F4h case    6:*/		return 0x821713F8;
		  /* 821713F8h */ case    7:  		/* subf R3, R11, R26 */
		/* 821713F8h case    7:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 821713F8h case    7:*/		return 0x821713FC;
		  /* 821713FCh */ case    8:  		/* addi R1, R1, 160 */
		/* 821713FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821713FCh case    8:*/		return 0x82171400;
		  /* 82171400h */ case    9:  		/* b -917868 */
		/* 82171400h case    9:*/		return 0x82091294;
		/* 82171400h case    9:*/		return 0x82171404;
		  /* 82171404h */ case   10:  		/* nop */
		/* 82171404h case   10:*/		cpu::op::nop();
		/* 82171404h case   10:*/		return 0x82171408;
		  /* 82171408h */ case   11:  		/* lwz R10, <#[R3]> */
		/* 82171408h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82171408h case   11:*/		return 0x8217140C;
		  /* 8217140Ch */ case   12:  		/* nor R11, R10, R10 */
		/* 8217140Ch case   12:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R10,regs.R10);
		/* 8217140Ch case   12:*/		return 0x82171410;
		  /* 82171410h */ case   13:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82171410h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82171410h case   13:*/		return 0x82171414;
		  /* 82171414h */ case   14:  		/* bc 4, CR0_EQ, 16 */
		/* 82171414h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82171424;  }
		/* 82171414h case   14:*/		return 0x82171418;
		  /* 82171418h */ case   15:  		/* lwz R11, <#[R4]> */
		/* 82171418h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82171418h case   15:*/		return 0x8217141C;
		  /* 8217141Ch */ case   16:  		/* stw R11, <#[R3]> */
		/* 8217141Ch case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8217141Ch case   16:*/		return 0x82171420;
		  /* 82171420h */ case   17:  		/* bclr 20, CR0_LT */
		/* 82171420h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171420h case   17:*/		return 0x82171424;
	}
	return 0x82171424;
} // Block from 821713DCh-82171424h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82171424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171424);
		  /* 82171424h */ case    0:  		/* lwz R9, <#[R10]> */
		/* 82171424h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82171424h case    0:*/		return 0x82171428;
		  /* 82171428h */ case    1:  		/* addi R11, R10, 4 */
		/* 82171428h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 82171428h case    1:*/		return 0x8217142C;
		  /* 8217142Ch */ case    2:  		/* lwz R8, <#[R4]> */
		/* 8217142Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 8217142Ch case    2:*/		return 0x82171430;
		  /* 82171430h */ case    3:  		/* addi R7, R9, 1 */
		/* 82171430h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R9,0x1);
		/* 82171430h case    3:*/		return 0x82171434;
		  /* 82171434h */ case    4:  		/* addi R9, R8, 4 */
		/* 82171434h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x4);
		/* 82171434h case    4:*/		return 0x82171438;
		  /* 82171438h */ case    5:  		/* rlwinm R8, R7, 2, 0, 29 */
		/* 82171438h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R7);
		/* 82171438h case    5:*/		return 0x8217143C;
		  /* 8217143Ch */ case    6:  		/* add R10, R8, R10 */
		/* 8217143Ch case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8217143Ch case    6:*/		return 0x82171440;
		  /* 82171440h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82171440h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82171440h case    7:*/		return 0x82171444;
		  /* 82171444h */ case    8:  		/* bclr 4, CR6_LT */
		/* 82171444h case    8:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82171444h case    8:*/		return 0x82171448;
	}
	return 0x82171448;
} // Block from 82171424h-82171448h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82171448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171448);
		  /* 82171448h */ case    0:  		/* subf R10, R11, R10 */
		/* 82171448h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82171448h case    0:*/		return 0x8217144C;
		  /* 8217144Ch */ case    1:  		/* addi R9, R9, -4 */
		/* 8217144Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 8217144Ch case    1:*/		return 0x82171450;
		  /* 82171450h */ case    2:  		/* addi R8, R10, -1 */
		/* 82171450h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 82171450h case    2:*/		return 0x82171454;
		  /* 82171454h */ case    3:  		/* addi R10, R11, -4 */
		/* 82171454h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFC);
		/* 82171454h case    3:*/		return 0x82171458;
		  /* 82171458h */ case    4:  		/* rlwinm R11, R8, 30, 2, 31 */
		/* 82171458h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R8);
		/* 82171458h case    4:*/		return 0x8217145C;
		  /* 8217145Ch */ case    5:  		/* addi R11, R11, 1 */
		/* 8217145Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8217145Ch case    5:*/		return 0x82171460;
		  /* 82171460h */ case    6:  		/* mtspr CTR, R11 */
		/* 82171460h case    6:*/		regs.CTR = regs.R11;
		/* 82171460h case    6:*/		return 0x82171464;
		  /* 82171464h */ case    7:  		/* lwzu R11, <#[R9 + 4]> */
		/* 82171464h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82171464h case    7:*/		return 0x82171468;
		  /* 82171468h */ case    8:  		/* stwu R11, <#[R10 + 4]> */
		/* 82171468h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82171468h case    8:*/		return 0x8217146C;
		  /* 8217146Ch */ case    9:  		/* bc 16, CR0_LT, -8 */
		/* 8217146Ch case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82171464;  }
		/* 8217146Ch case    9:*/		return 0x82171470;
		  /* 82171470h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82171470h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171470h case   10:*/		return 0x82171474;
	}
	return 0x82171474;
} // Block from 82171448h-82171474h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82171474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171474);
		  /* 82171474h */ case    0:  		/* nop */
		/* 82171474h case    0:*/		cpu::op::nop();
		/* 82171474h case    0:*/		return 0x82171478;
		  /* 82171478h */ case    1:  		/* addi R7, R5, 1 */
		/* 82171478h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R5,0x1);
		/* 82171478h case    1:*/		return 0x8217147C;
		  /* 8217147Ch */ case    2:  		/* lwz R8, <#[R3]> */
		/* 8217147Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 8217147Ch case    2:*/		return 0x82171480;
		  /* 82171480h */ case    3:  		/* addi R11, R4, 1 */
		/* 82171480h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 82171480h case    3:*/		return 0x82171484;
		  /* 82171484h */ case    4:  		/* rlwinm R10, R7, 0, 27, 31 */
		/* 82171484h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R7);
		/* 82171484h case    4:*/		return 0x82171488;
		  /* 82171488h */ case    5:  		/* li R9, 2 */
		/* 82171488h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82171488h case    5:*/		return 0x8217148C;
		  /* 8217148Ch */ case    6:  		/* nor R5, R8, R8 */
		/* 8217148Ch case    6:*/		cpu::op::nor<0>(regs,&regs.R5,regs.R8,regs.R8);
		/* 8217148Ch case    6:*/		return 0x82171490;
		  /* 82171490h */ case    7:  		/* li R4, -1 */
		/* 82171490h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82171490h case    7:*/		return 0x82171494;
		  /* 82171494h */ case    8:  		/* rlwinm R6, R11, 0, 27, 31 */
		/* 82171494h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R11);
		/* 82171494h case    8:*/		return 0x82171498;
		  /* 82171498h */ case    9:  		/* slw R9, R9, R10 */
		/* 82171498h case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82171498h case    9:*/		return 0x8217149C;
		  /* 8217149Ch */ case   10:  		/* rlwinm. R10, R5, 0, 31, 31 */
		/* 8217149Ch case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R5);
		/* 8217149Ch case   10:*/		return 0x821714A0;
		  /* 821714A0h */ case   11:  		/* slw R5, R4, R6 */
		/* 821714A0h case   11:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R4,regs.R6);
		/* 821714A0h case   11:*/		return 0x821714A4;
		  /* 821714A4h */ case   12:  		/* addi R4, R9, -1 */
		/* 821714A4h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0xFFFFFFFF);
		/* 821714A4h case   12:*/		return 0x821714A8;
		  /* 821714A8h */ case   13:  		/* addi R9, R8, 4 */
		/* 821714A8h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x4);
		/* 821714A8h case   13:*/		return 0x821714AC;
		  /* 821714ACh */ case   14:  		/* bc 4, CR0_EQ, 8 */
		/* 821714ACh case   14:*/		if ( !regs.CR[0].eq ) { return 0x821714B4;  }
		/* 821714ACh case   14:*/		return 0x821714B0;
		  /* 821714B0h */ case   15:  		/* mr R9, R3 */
		/* 821714B0h case   15:*/		regs.R9 = regs.R3;
		/* 821714B0h case   15:*/		return 0x821714B4;
	}
	return 0x821714B4;
} // Block from 82171474h-821714B4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821714B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821714B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821714B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821714B4);
		  /* 821714B4h */ case    0:  		/* rlwinm R11, R11, 29, 3, 29 */
		/* 821714B4h case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R11);
		/* 821714B4h case    0:*/		return 0x821714B8;
		  /* 821714B8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821714B8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821714B8h case    1:*/		return 0x821714BC;
		  /* 821714BCh */ case    2:  		/* add R10, R11, R9 */
		/* 821714BCh case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 821714BCh case    2:*/		return 0x821714C0;
		  /* 821714C0h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 821714C0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821714C8;  }
		/* 821714C0h case    3:*/		return 0x821714C4;
		  /* 821714C4h */ case    4:  		/* addi R3, R8, 4 */
		/* 821714C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R8,0x4);
		/* 821714C4h case    4:*/		return 0x821714C8;
	}
	return 0x821714C8;
} // Block from 821714B4h-821714C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821714C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821714C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821714C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821714C8);
		  /* 821714C8h */ case    0:  		/* rlwinm R11, R7, 29, 3, 29 */
		/* 821714C8h case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R7);
		/* 821714C8h case    0:*/		return 0x821714CC;
		  /* 821714CCh */ case    1:  		/* lwz R9, <#[R10]> */
		/* 821714CCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821714CCh case    1:*/		return 0x821714D0;
		  /* 821714D0h */ case    2:  		/* add R11, R11, R3 */
		/* 821714D0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 821714D0h case    2:*/		return 0x821714D4;
		  /* 821714D4h */ case    3:  		/* and R9, R5, R9 */
		/* 821714D4h case    3:*/		cpu::op::and<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 821714D4h case    3:*/		return 0x821714D8;
		  /* 821714D8h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 821714D8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821714D8h case    4:*/		return 0x821714DC;
		  /* 821714DCh */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 821714DCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x821714EC;  }
		/* 821714DCh case    5:*/		return 0x821714E0;
		  /* 821714E0h */ case    6:  		/* and R11, R9, R4 */
		/* 821714E0h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R4);
		/* 821714E0h case    6:*/		return 0x821714E4;
		  /* 821714E4h */ case    7:  		/* srw R3, R11, R6 */
		/* 821714E4h case    7:*/		cpu::op::srw<0>(regs,&regs.R3,regs.R11,regs.R6);
		/* 821714E4h case    7:*/		return 0x821714E8;
		  /* 821714E8h */ case    8:  		/* bclr 20, CR0_LT */
		/* 821714E8h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821714E8h case    8:*/		return 0x821714EC;
	}
	return 0x821714EC;
} // Block from 821714C8h-821714ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821714ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821714EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821714EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821714EC);
		  /* 821714ECh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821714ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821714ECh case    0:*/		return 0x821714F0;
		  /* 821714F0h */ case    1:  		/* subfic R10, R6, 32 */
		/* 821714F0h case    1:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R6,0x20);
		/* 821714F0h case    1:*/		return 0x821714F4;
		  /* 821714F4h */ case    2:  		/* srw R9, R9, R6 */
		/* 821714F4h case    2:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 821714F4h case    2:*/		return 0x821714F8;
		  /* 821714F8h */ case    3:  		/* and R11, R11, R4 */
		/* 821714F8h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821714F8h case    3:*/		return 0x821714FC;
		  /* 821714FCh */ case    4:  		/* slw R11, R11, R10 */
		/* 821714FCh case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821714FCh case    4:*/		return 0x82171500;
		  /* 82171500h */ case    5:  		/* or R3, R11, R9 */
		/* 82171500h case    5:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 82171500h case    5:*/		return 0x82171504;
		  /* 82171504h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82171504h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171504h case    6:*/		return 0x82171508;
	}
	return 0x82171508;
} // Block from 821714ECh-82171508h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82171508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171508);
		  /* 82171508h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 82171508h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82171508h case    0:*/		return 0x8217150C;
		  /* 8217150Ch */ case    1:  		/* addi R11, R4, 1 */
		/* 8217150Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 8217150Ch case    1:*/		return 0x82171510;
		  /* 82171510h */ case    2:  		/* nor R10, R9, R9 */
		/* 82171510h case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R9,regs.R9);
		/* 82171510h case    2:*/		return 0x82171514;
		  /* 82171514h */ case    3:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 82171514h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 82171514h case    3:*/		return 0x82171518;
		  /* 82171518h */ case    4:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82171518h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82171518h case    4:*/		return 0x8217151C;
		  /* 8217151Ch */ case    5:  		/* slw R4, R6, R7 */
		/* 8217151Ch case    5:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R6,regs.R7);
		/* 8217151Ch case    5:*/		return 0x82171520;
		  /* 82171520h */ case    6:  		/* addi R8, R9, 4 */
		/* 82171520h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x4);
		/* 82171520h case    6:*/		return 0x82171524;
		  /* 82171524h */ case    7:  		/* bc 4, CR0_EQ, 8 */
		/* 82171524h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8217152C;  }
		/* 82171524h case    7:*/		return 0x82171528;
		  /* 82171528h */ case    8:  		/* mr R8, R3 */
		/* 82171528h case    8:*/		regs.R8 = regs.R3;
		/* 82171528h case    8:*/		return 0x8217152C;
	}
	return 0x8217152C;
} // Block from 82171508h-8217152Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8217152Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217152C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217152C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217152C);
		  /* 8217152Ch */ case    0:  		/* rlwinm R11, R11, 29, 3, 29 */
		/* 8217152Ch case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R11);
		/* 8217152Ch case    0:*/		return 0x82171530;
		  /* 82171530h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82171530h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82171530h case    1:*/		return 0x82171534;
		  /* 82171534h */ case    2:  		/* add R11, R11, R8 */
		/* 82171534h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82171534h case    2:*/		return 0x82171538;
		  /* 82171538h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 82171538h case    3:*/		if ( regs.CR[6].eq ) { return 0x82171540;  }
		/* 82171538h case    3:*/		return 0x8217153C;
		  /* 8217153Ch */ case    4:  		/* addi R3, R9, 4 */
		/* 8217153Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x4);
		/* 8217153Ch case    4:*/		return 0x82171540;
	}
	return 0x82171540;
} // Block from 8217152Ch-82171540h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82171540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171540);
		  /* 82171540h */ case    0:  		/* addi R10, R5, 1 */
		/* 82171540h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x1);
		/* 82171540h case    0:*/		return 0x82171544;
		  /* 82171544h */ case    1:  		/* lwz R9, <#[R11]> */
		/* 82171544h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82171544h case    1:*/		return 0x82171548;
		  /* 82171548h */ case    2:  		/* rlwinm R10, R10, 29, 3, 29 */
		/* 82171548h case    2:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R10);
		/* 82171548h case    2:*/		return 0x8217154C;
		  /* 8217154Ch */ case    3:  		/* or R9, R9, R4 */
		/* 8217154Ch case    3:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R4);
		/* 8217154Ch case    3:*/		return 0x82171550;
		  /* 82171550h */ case    4:  		/* add R10, R10, R3 */
		/* 82171550h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82171550h case    4:*/		return 0x82171554;
		  /* 82171554h */ case    5:  		/* stw R9, <#[R11]> */
		/* 82171554h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82171554h case    5:*/		return 0x82171558;
		  /* 82171558h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82171558h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82171558h case    6:*/		return 0x8217155C;
		  /* 8217155Ch */ case    7:  		/* bclr 12, CR6_EQ */
		/* 8217155Ch case    7:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8217155Ch case    7:*/		return 0x82171560;
	}
	return 0x82171560;
} // Block from 82171540h-82171560h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82171560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171560);
		  /* 82171560h */ case    0:  		/* subfic R11, R7, 32 */
		/* 82171560h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R7,0x20);
		/* 82171560h case    0:*/		return 0x82171564;
		  /* 82171564h */ case    1:  		/* lwz R9, <#[R10]> */
		/* 82171564h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82171564h case    1:*/		return 0x82171568;
		  /* 82171568h */ case    2:  		/* srw R11, R6, R11 */
		/* 82171568h case    2:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82171568h case    2:*/		return 0x8217156C;
		  /* 8217156Ch */ case    3:  		/* or R11, R11, R9 */
		/* 8217156Ch case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8217156Ch case    3:*/		return 0x82171570;
		  /* 82171570h */ case    4:  		/* stw R11, <#[R10]> */
		/* 82171570h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82171570h case    4:*/		return 0x82171574;
		  /* 82171574h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82171574h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171574h case    5:*/		return 0x82171578;
	}
	return 0x82171578;
} // Block from 82171560h-82171578h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82171578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171578);
		  /* 82171578h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 82171578h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82171578h case    0:*/		return 0x8217157C;
		  /* 8217157Ch */ case    1:  		/* addi R11, R4, 1 */
		/* 8217157Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 8217157Ch case    1:*/		return 0x82171580;
		  /* 82171580h */ case    2:  		/* nor R10, R9, R9 */
		/* 82171580h case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R9,regs.R9);
		/* 82171580h case    2:*/		return 0x82171584;
		  /* 82171584h */ case    3:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 82171584h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 82171584h case    3:*/		return 0x82171588;
		  /* 82171588h */ case    4:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82171588h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82171588h case    4:*/		return 0x8217158C;
		  /* 8217158Ch */ case    5:  		/* slw R4, R6, R7 */
		/* 8217158Ch case    5:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R6,regs.R7);
		/* 8217158Ch case    5:*/		return 0x82171590;
		  /* 82171590h */ case    6:  		/* addi R8, R9, 4 */
		/* 82171590h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x4);
		/* 82171590h case    6:*/		return 0x82171594;
		  /* 82171594h */ case    7:  		/* bc 4, CR0_EQ, 8 */
		/* 82171594h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8217159C;  }
		/* 82171594h case    7:*/		return 0x82171598;
		  /* 82171598h */ case    8:  		/* mr R8, R3 */
		/* 82171598h case    8:*/		regs.R8 = regs.R3;
		/* 82171598h case    8:*/		return 0x8217159C;
	}
	return 0x8217159C;
} // Block from 82171578h-8217159Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8217159Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217159C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217159C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217159C);
		  /* 8217159Ch */ case    0:  		/* rlwinm R11, R11, 29, 3, 29 */
		/* 8217159Ch case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R11);
		/* 8217159Ch case    0:*/		return 0x821715A0;
		  /* 821715A0h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821715A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821715A0h case    1:*/		return 0x821715A4;
		  /* 821715A4h */ case    2:  		/* add R11, R11, R8 */
		/* 821715A4h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821715A4h case    2:*/		return 0x821715A8;
	}
	return 0x821715A8;
} // Block from 8217159Ch-821715A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821715A8h
// Function '?RestrictNumSetBitsInNibble@D3DXShader@@YAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821715A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821715A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821715A8);
		  /* 821715A8h */ case    0:  		/* bc 12, CR6_EQ, 8 */
		/* 821715A8h case    0:*/		if ( regs.CR[6].eq ) { return 0x821715B0;  }
		/* 821715A8h case    0:*/		return 0x821715AC;
		  /* 821715ACh */ case    1:  		/* addi R3, R9, 4 */
		/* 821715ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x4);
		/* 821715ACh case    1:*/		return 0x821715B0;
	}
	return 0x821715B0;
} // Block from 821715A8h-821715B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821715B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821715B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821715B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821715B0);
		  /* 821715B0h */ case    0:  		/* addi R10, R5, 1 */
		/* 821715B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x1);
		/* 821715B0h case    0:*/		return 0x821715B4;
		  /* 821715B4h */ case    1:  		/* lwz R9, <#[R11]> */
		/* 821715B4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821715B4h case    1:*/		return 0x821715B8;
		  /* 821715B8h */ case    2:  		/* rlwinm R10, R10, 29, 3, 29 */
		/* 821715B8h case    2:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R10);
		/* 821715B8h case    2:*/		return 0x821715BC;
		  /* 821715BCh */ case    3:  		/* subf R9, R4, R9 */
		/* 821715BCh case    3:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 821715BCh case    3:*/		return 0x821715C0;
		  /* 821715C0h */ case    4:  		/* add R10, R10, R3 */
		/* 821715C0h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 821715C0h case    4:*/		return 0x821715C4;
		  /* 821715C4h */ case    5:  		/* stw R9, <#[R11]> */
		/* 821715C4h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821715C4h case    5:*/		return 0x821715C8;
		  /* 821715C8h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 821715C8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821715C8h case    6:*/		return 0x821715CC;
		  /* 821715CCh */ case    7:  		/* bclr 12, CR6_EQ */
		/* 821715CCh case    7:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821715CCh case    7:*/		return 0x821715D0;
	}
	return 0x821715D0;
} // Block from 821715B0h-821715D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821715D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821715D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821715D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821715D0);
		  /* 821715D0h */ case    0:  		/* subfic R11, R7, 32 */
		/* 821715D0h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R7,0x20);
		/* 821715D0h case    0:*/		return 0x821715D4;
		  /* 821715D4h */ case    1:  		/* lwz R9, <#[R10]> */
		/* 821715D4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821715D4h case    1:*/		return 0x821715D8;
		  /* 821715D8h */ case    2:  		/* srw R11, R6, R11 */
		/* 821715D8h case    2:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 821715D8h case    2:*/		return 0x821715DC;
		  /* 821715DCh */ case    3:  		/* subf R11, R11, R9 */
		/* 821715DCh case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821715DCh case    3:*/		return 0x821715E0;
		  /* 821715E0h */ case    4:  		/* stw R11, <#[R10]> */
		/* 821715E0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821715E0h case    4:*/		return 0x821715E4;
		  /* 821715E4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821715E4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821715E4h case    5:*/		return 0x821715E8;
	}
	return 0x821715E8;
} // Block from 821715D0h-821715E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821715E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821715E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821715E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821715E8);
		  /* 821715E8h */ case    0:  		/* mfspr R12, LR */
		/* 821715E8h case    0:*/		regs.R12 = regs.LR;
		/* 821715E8h case    0:*/		return 0x821715EC;
		  /* 821715ECh */ case    1:  		/* bl -918416 */
		/* 821715ECh case    1:*/		regs.LR = 0x821715F0; return 0x8209125C;
		/* 821715ECh case    1:*/		return 0x821715F0;
		  /* 821715F0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821715F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821715F0h case    2:*/		return 0x821715F4;
		  /* 821715F4h */ case    3:  		/* addi R11, R4, 1 */
		/* 821715F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 821715F4h case    3:*/		return 0x821715F8;
		  /* 821715F8h */ case    4:  		/* lwz R10, <#[R3]> */
		/* 821715F8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821715F8h case    4:*/		return 0x821715FC;
		  /* 821715FCh */ case    5:  		/* mr R6, R3 */
		/* 821715FCh case    5:*/		regs.R6 = regs.R3;
		/* 821715FCh case    5:*/		return 0x82171600;
	}
	return 0x82171600;
} // Block from 821715E8h-82171600h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82171600h
// Function '?IsOutputRegisterAssignedBeforeRegOpts@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171600);
		  /* 82171600h */ case    0:  		/* rlwinm R8, R11, 0, 27, 31 */
		/* 82171600h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R11);
		/* 82171600h case    0:*/		return 0x82171604;
		  /* 82171604h */ case    1:  		/* li R3, -1 */
		/* 82171604h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82171604h case    1:*/		return 0x82171608;
		  /* 82171608h */ case    2:  		/* nor R9, R10, R10 */
		/* 82171608h case    2:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R10,regs.R10);
		/* 82171608h case    2:*/		return 0x8217160C;
		  /* 8217160Ch */ case    3:  		/* slw R7, R3, R8 */
		/* 8217160Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R3,regs.R8);
		/* 8217160Ch case    3:*/		return 0x82171610;
		  /* 82171610h */ case    4:  		/* mr R29, R5 */
		/* 82171610h case    4:*/		regs.R29 = regs.R5;
		/* 82171610h case    4:*/		return 0x82171614;
		  /* 82171614h */ case    5:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82171614h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82171614h case    5:*/		return 0x82171618;
		  /* 82171618h */ case    6:  		/* addi R8, R10, 4 */
		/* 82171618h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82171618h case    6:*/		return 0x8217161C;
		  /* 8217161Ch */ case    7:  		/* bc 4, CR0_EQ, 8 */
		/* 8217161Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82171624;  }
		/* 8217161Ch case    7:*/		return 0x82171620;
		  /* 82171620h */ case    8:  		/* mr R8, R6 */
		/* 82171620h case    8:*/		regs.R8 = regs.R6;
		/* 82171620h case    8:*/		return 0x82171624;
	}
	return 0x82171624;
} // Block from 82171600h-82171624h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82171624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171624);
		  /* 82171624h */ case    0:  		/* rlwinm R11, R11, 29, 3, 29 */
		/* 82171624h case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R11);
		/* 82171624h case    0:*/		return 0x82171628;
		  /* 82171628h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82171628h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82171628h case    1:*/		return 0x8217162C;
		  /* 8217162Ch */ case    2:  		/* add R11, R11, R8 */
		/* 8217162Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8217162Ch case    2:*/		return 0x82171630;
		  /* 82171630h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82171630h case    3:*/		if ( regs.CR[6].eq ) { return 0x82171648;  }
		/* 82171630h case    3:*/		return 0x82171634;
		  /* 82171634h */ case    4:  		/* lwz R9, <#[R10]> */
		/* 82171634h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82171634h case    4:*/		return 0x82171638;
		  /* 82171638h */ case    5:  		/* addi R9, R9, 1 */
		/* 82171638h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82171638h case    5:*/		return 0x8217163C;
		  /* 8217163Ch */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8217163Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8217163Ch case    6:*/		return 0x82171640;
		  /* 82171640h */ case    7:  		/* add R9, R9, R10 */
		/* 82171640h case    7:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82171640h case    7:*/		return 0x82171644;
		  /* 82171644h */ case    8:  		/* b 8 */
		/* 82171644h case    8:*/		return 0x8217164C;
		/* 82171644h case    8:*/		return 0x82171648;
	}
	return 0x82171648;
} // Block from 82171624h-82171648h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82171648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171648);
		  /* 82171648h */ case    0:  		/* addi R9, R6, 4 */
		/* 82171648h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x4);
		/* 82171648h case    0:*/		return 0x8217164C;
	}
	return 0x8217164C;
} // Block from 82171648h-8217164Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8217164Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217164C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217164C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217164C);
		  /* 8217164Ch */ case    0:  		/* rlwinm R10, R4, 27, 5, 31 */
		/* 8217164Ch case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R4);
		/* 8217164Ch case    0:*/		return 0x82171650;
	}
	return 0x82171650;
} // Block from 8217164Ch-82171650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171650h
// Function '?RenameSwizzle@Dependency@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171650);
		  /* 82171650h */ case    0:  		/* b 28 */
		/* 82171650h case    0:*/		return 0x8217166C;
		/* 82171650h case    0:*/		return 0x82171654;
		  /* 82171654h */ case    1:  		/* lwz R8, <#[R11]> */
		/* 82171654h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82171654h case    1:*/		return 0x82171658;
		  /* 82171658h */ case    2:  		/* andc. R8, R7, R8 */
		/* 82171658h case    2:*/		cpu::op::andc<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 82171658h case    2:*/		return 0x8217165C;
		  /* 8217165Ch */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 8217165Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82171678;  }
		/* 8217165Ch case    3:*/		return 0x82171660;
		  /* 82171660h */ case    4:  		/* addi R11, R11, 4 */
		/* 82171660h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82171660h case    4:*/		return 0x82171664;
		  /* 82171664h */ case    5:  		/* mr R7, R3 */
		/* 82171664h case    5:*/		regs.R7 = regs.R3;
		/* 82171664h case    5:*/		return 0x82171668;
		  /* 82171668h */ case    6:  		/* addi R10, R10, 1 */
		/* 82171668h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82171668h case    6:*/		return 0x8217166C;
	}
	return 0x8217166C;
} // Block from 82171650h-8217166Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8217166Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217166C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217166C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217166C);
		  /* 8217166Ch */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 8217166Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8217166Ch case    0:*/		return 0x82171670;
		  /* 82171670h */ case    1:  		/* bc 12, CR6_LT, -28 */
		/* 82171670h case    1:*/		if ( regs.CR[6].lt ) { return 0x82171654;  }
		/* 82171670h case    1:*/		return 0x82171674;
		  /* 82171674h */ case    2:  		/* b 96 */
		/* 82171674h case    2:*/		return 0x821716D4;
		/* 82171674h case    2:*/		return 0x82171678;
	}
	return 0x82171678;
} // Block from 8217166Ch-82171678h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171678);
		  /* 82171678h */ case    0:  		/* addi R7, R8, -1 */
		/* 82171678h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R8,0xFFFFFFFF);
		/* 82171678h case    0:*/		return 0x8217167C;
		  /* 8217167Ch */ case    1:  		/* andc R8, R8, R7 */
		/* 8217167Ch case    1:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8217167Ch case    1:*/		return 0x82171680;
		  /* 82171680h */ case    2:  		/* cntlzw R8, R8 */
		/* 82171680h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R8,regs.R8);
		/* 82171680h case    2:*/		return 0x82171684;
		  /* 82171684h */ case    3:  		/* subfic R8, R8, 31 */
		/* 82171684h case    3:*/		cpu::op::subfic<0>(regs,&regs.R8,regs.R8,0x1F);
		/* 82171684h case    3:*/		return 0x82171688;
		  /* 82171688h */ case    4:  		/* cmplwi CR6, R8, 0 */
		/* 82171688h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82171688h case    4:*/		return 0x8217168C;
		  /* 8217168Ch */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8217168Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82171698;  }
		/* 8217168Ch case    5:*/		return 0x82171690;
		  /* 82171690h */ case    6:  		/* addi R10, R10, -1 */
		/* 82171690h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82171690h case    6:*/		return 0x82171694;
		  /* 82171694h */ case    7:  		/* li R8, 32 */
		/* 82171694h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x20);
		/* 82171694h case    7:*/		return 0x82171698;
	}
	return 0x82171698;
} // Block from 82171678h-82171698h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82171698h
// Function '?IsPerComponent@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171698);
		  /* 82171698h */ case    0:  		/* addi R31, R8, -1 */
		/* 82171698h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R8,0xFFFFFFFF);
		/* 82171698h case    0:*/		return 0x8217169C;
		  /* 8217169Ch */ case    1:  		/* rlwinm R30, R10, 5, 0, 26 */
		/* 8217169Ch case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R30,regs.R10);
		/* 8217169Ch case    1:*/		return 0x821716A0;
		  /* 821716A0h */ case    2:  		/* rlwinm R10, R31, 0, 0, 29 */
		/* 821716A0h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R31);
		/* 821716A0h case    2:*/		return 0x821716A4;
		  /* 821716A4h */ case    3:  		/* addi R11, R11, 4 */
		/* 821716A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821716A4h case    3:*/		return 0x821716A8;
		  /* 821716A8h */ case    4:  		/* add R4, R10, R30 */
		/* 821716A8h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R30);
		/* 821716A8h case    4:*/		return 0x821716AC;
		  /* 821716ACh */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 821716ACh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821716ACh case    5:*/		return 0x821716B0;
		  /* 821716B0h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 821716B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821716C0;  }
		/* 821716B0h case    6:*/		return 0x821716B4;
		  /* 821716B4h */ case    7:  		/* addi R11, R4, 4 */
		/* 821716B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x4);
		/* 821716B4h case    7:*/		return 0x821716B8;
		  /* 821716B8h */ case    8:  		/* cmplwi CR6, R11, 32 */
		/* 821716B8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 821716B8h case    8:*/		return 0x821716BC;
		  /* 821716BCh */ case    9:  		/* bc 12, CR6_GT, 24 */
		/* 821716BCh case    9:*/		if ( regs.CR[6].gt ) { return 0x821716D4;  }
		/* 821716BCh case    9:*/		return 0x821716C0;
	}
	return 0x821716C0;
} // Block from 82171698h-821716C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821716C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821716C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821716C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821716C0);
		  /* 821716C0h */ case    0:  		/* addi R5, R4, 3 */
		/* 821716C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 821716C0h case    0:*/		return 0x821716C4;
		  /* 821716C4h */ case    1:  		/* mr R3, R6 */
		/* 821716C4h case    1:*/		regs.R3 = regs.R6;
		/* 821716C4h case    1:*/		return 0x821716C8;
		  /* 821716C8h */ case    2:  		/* bl -592 */
		/* 821716C8h case    2:*/		regs.LR = 0x821716CC; return 0x82171478;
		/* 821716C8h case    2:*/		return 0x821716CC;
		  /* 821716CCh */ case    3:  		/* stw R3, <#[R29]> */
		/* 821716CCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 821716CCh case    3:*/		return 0x821716D0;
		  /* 821716D0h */ case    4:  		/* add R3, R30, R31 */
		/* 821716D0h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R30,regs.R31);
		/* 821716D0h case    4:*/		return 0x821716D4;
	}
	return 0x821716D4;
} // Block from 821716C0h-821716D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821716D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821716D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821716D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821716D4);
		  /* 821716D4h */ case    0:  		/* addi R1, R1, 112 */
		/* 821716D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821716D4h case    0:*/		return 0x821716D8;
		  /* 821716D8h */ case    1:  		/* b -918572 */
		/* 821716D8h case    1:*/		return 0x820912AC;
		/* 821716D8h case    1:*/		return 0x821716DC;
		  /* 821716DCh */ case    2:  		/* nop */
		/* 821716DCh case    2:*/		cpu::op::nop();
		/* 821716DCh case    2:*/		return 0x821716E0;
	}
	return 0x821716E0;
} // Block from 821716D4h-821716E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821716E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821716E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821716E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821716E0);
		  /* 821716E0h */ case    0:  		/* mfspr R12, LR */
		/* 821716E0h case    0:*/		regs.R12 = regs.LR;
		/* 821716E0h case    0:*/		return 0x821716E4;
		  /* 821716E4h */ case    1:  		/* bl -918664 */
		/* 821716E4h case    1:*/		regs.LR = 0x821716E8; return 0x8209125C;
		/* 821716E4h case    1:*/		return 0x821716E8;
		  /* 821716E8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821716E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821716E8h case    2:*/		return 0x821716EC;
		  /* 821716ECh */ case    3:  		/* addi R11, R4, 1 */
		/* 821716ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 821716ECh case    3:*/		return 0x821716F0;
	}
	return 0x821716F0;
} // Block from 821716E0h-821716F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821716F0h
// Function '?RequiresReordering@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821716F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821716F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821716F0);
		  /* 821716F0h */ case    0:  		/* lwz R8, <#[R3]> */
		/* 821716F0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 821716F0h case    0:*/		return 0x821716F4;
		  /* 821716F4h */ case    1:  		/* li R10, 2 */
		/* 821716F4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 821716F4h case    1:*/		return 0x821716F8;
		  /* 821716F8h */ case    2:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 821716F8h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 821716F8h case    2:*/		return 0x821716FC;
		  /* 821716FCh */ case    3:  		/* nor R7, R8, R8 */
		/* 821716FCh case    3:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R8,regs.R8);
		/* 821716FCh case    3:*/		return 0x82171700;
		  /* 82171700h */ case    4:  		/* slw R9, R10, R9 */
		/* 82171700h case    4:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82171700h case    4:*/		return 0x82171704;
		  /* 82171704h */ case    5:  		/* addi R6, R9, -1 */
		/* 82171704h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0xFFFFFFFF);
		/* 82171704h case    5:*/		return 0x82171708;
		  /* 82171708h */ case    6:  		/* mr R29, R5 */
		/* 82171708h case    6:*/		regs.R29 = regs.R5;
		/* 82171708h case    6:*/		return 0x8217170C;
		  /* 8217170Ch */ case    7:  		/* rlwinm. R10, R7, 0, 31, 31 */
		/* 8217170Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R7);
		/* 8217170Ch case    7:*/		return 0x82171710;
		  /* 82171710h */ case    8:  		/* addi R9, R8, 4 */
		/* 82171710h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x4);
		/* 82171710h case    8:*/		return 0x82171714;
		  /* 82171714h */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 82171714h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8217171C;  }
		/* 82171714h case    9:*/		return 0x82171718;
		  /* 82171718h */ case   10:  		/* mr R9, R3 */
		/* 82171718h case   10:*/		regs.R9 = regs.R3;
		/* 82171718h case   10:*/		return 0x8217171C;
	}
	return 0x8217171C;
} // Block from 821716F0h-8217171Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8217171Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217171C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217171C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217171C);
		  /* 8217171Ch */ case    0:  		/* rlwinm R11, R11, 29, 3, 29 */
		/* 8217171Ch case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R11);
		/* 8217171Ch case    0:*/		return 0x82171720;
		  /* 82171720h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82171720h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82171720h case    1:*/		return 0x82171724;
		  /* 82171724h */ case    2:  		/* add R11, R11, R9 */
		/* 82171724h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82171724h case    2:*/		return 0x82171728;
		  /* 82171728h */ case    3:  		/* addi R9, R8, 4 */
		/* 82171728h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x4);
		/* 82171728h case    3:*/		return 0x8217172C;
		  /* 8217172Ch */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 8217172Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82171734;  }
		/* 8217172Ch case    4:*/		return 0x82171730;
		  /* 82171730h */ case    5:  		/* mr R9, R3 */
		/* 82171730h case    5:*/		regs.R9 = regs.R3;
		/* 82171730h case    5:*/		return 0x82171734;
	}
	return 0x82171734;
} // Block from 8217171Ch-82171734h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82171734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171734);
		  /* 82171734h */ case    0:  		/* rlwinm R10, R4, 27, 5, 31 */
		/* 82171734h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R4);
		/* 82171734h case    0:*/		return 0x82171738;
		  /* 82171738h */ case    1:  		/* li R7, -1 */
		/* 82171738h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 82171738h case    1:*/		return 0x8217173C;
		  /* 8217173Ch */ case    2:  		/* b 28 */
		/* 8217173Ch case    2:*/		return 0x82171758;
		/* 8217173Ch case    2:*/		return 0x82171740;
		  /* 82171740h */ case    3:  		/* lwz R8, <#[R11]> */
		/* 82171740h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82171740h case    3:*/		return 0x82171744;
		  /* 82171744h */ case    4:  		/* andc. R8, R6, R8 */
		/* 82171744h case    4:*/		cpu::op::andc<1>(regs,&regs.R8,regs.R6,regs.R8);
		/* 82171744h case    4:*/		return 0x82171748;
		  /* 82171748h */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 82171748h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8217176C;  }
		/* 82171748h case    5:*/		return 0x8217174C;
		  /* 8217174Ch */ case    6:  		/* addi R11, R11, -4 */
		/* 8217174Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8217174Ch case    6:*/		return 0x82171750;
	}
	return 0x82171750;
} // Block from 82171734h-82171750h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82171750h
// Function '?UpdateRAWSpecialRegisterHazards@MachineState@D3DXShader@@QAAXPAVInstruction@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171750);
		  /* 82171750h */ case    0:  		/* mr R6, R7 */
		/* 82171750h case    0:*/		regs.R6 = regs.R7;
		/* 82171750h case    0:*/		return 0x82171754;
		  /* 82171754h */ case    1:  		/* addi R10, R10, -1 */
		/* 82171754h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82171754h case    1:*/		return 0x82171758;
	}
	return 0x82171758;
} // Block from 82171750h-82171758h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171758);
		  /* 82171758h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 82171758h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82171758h case    0:*/		return 0x8217175C;
		  /* 8217175Ch */ case    1:  		/* bc 4, CR6_LT, -28 */
		/* 8217175Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82171740;  }
		/* 8217175Ch case    1:*/		return 0x82171760;
		  /* 82171760h */ case    2:  		/* mr R3, R7 */
		/* 82171760h case    2:*/		regs.R3 = regs.R7;
		/* 82171760h case    2:*/		return 0x82171764;
		  /* 82171764h */ case    3:  		/* addi R1, R1, 112 */
		/* 82171764h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82171764h case    3:*/		return 0x82171768;
		  /* 82171768h */ case    4:  		/* b -918716 */
		/* 82171768h case    4:*/		return 0x820912AC;
		/* 82171768h case    4:*/		return 0x8217176C;
	}
	return 0x8217176C;
} // Block from 82171758h-8217176Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8217176Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217176C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217176C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217176C);
		  /* 8217176Ch */ case    0:  		/* cntlzw R11, R8 */
		/* 8217176Ch case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R8);
		/* 8217176Ch case    0:*/		return 0x82171770;
		  /* 82171770h */ case    1:  		/* subfic R11, R11, 31 */
		/* 82171770h case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82171770h case    1:*/		return 0x82171774;
		  /* 82171774h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82171774h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82171774h case    2:*/		return 0x82171778;
		  /* 82171778h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82171778h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82171784;  }
		/* 82171778h case    3:*/		return 0x8217177C;
		  /* 8217177Ch */ case    4:  		/* addi R10, R10, -1 */
		/* 8217177Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8217177Ch case    4:*/		return 0x82171780;
		  /* 82171780h */ case    5:  		/* li R11, 32 */
		/* 82171780h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 82171780h case    5:*/		return 0x82171784;
	}
	return 0x82171784;
} // Block from 8217176Ch-82171784h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82171784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171784);
		  /* 82171784h */ case    0:  		/* addi R31, R11, -1 */
		/* 82171784h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82171784h case    0:*/		return 0x82171788;
		  /* 82171788h */ case    1:  		/* rlwinm R30, R10, 5, 0, 26 */
		/* 82171788h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R30,regs.R10);
		/* 82171788h case    1:*/		return 0x8217178C;
		  /* 8217178Ch */ case    2:  		/* rlwinm R11, R31, 0, 0, 29 */
		/* 8217178Ch case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R31);
		/* 8217178Ch case    2:*/		return 0x82171790;
		  /* 82171790h */ case    3:  		/* add R4, R11, R30 */
		/* 82171790h case    3:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 82171790h case    3:*/		return 0x82171794;
		  /* 82171794h */ case    4:  		/* addi R5, R4, 3 */
		/* 82171794h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 82171794h case    4:*/		return 0x82171798;
		  /* 82171798h */ case    5:  		/* bl -800 */
		/* 82171798h case    5:*/		regs.LR = 0x8217179C; return 0x82171478;
		/* 82171798h case    5:*/		return 0x8217179C;
		  /* 8217179Ch */ case    6:  		/* stw R3, <#[R29]> */
		/* 8217179Ch case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 8217179Ch case    6:*/		return 0x821717A0;
		  /* 821717A0h */ case    7:  		/* add R3, R30, R31 */
		/* 821717A0h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R30,regs.R31);
		/* 821717A0h case    7:*/		return 0x821717A4;
		  /* 821717A4h */ case    8:  		/* b -64 */
		/* 821717A4h case    8:*/		return 0x82171764;
		/* 821717A4h case    8:*/		return 0x821717A8;
	}
	return 0x821717A8;
} // Block from 82171784h-821717A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821717A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821717A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821717A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821717A8);
		  /* 821717A8h */ case    0:  		/* mfspr R12, LR */
		/* 821717A8h case    0:*/		regs.R12 = regs.LR;
		/* 821717A8h case    0:*/		return 0x821717AC;
		  /* 821717ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821717ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821717ACh case    1:*/		return 0x821717B0;
		  /* 821717B0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821717B0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821717B0h case    2:*/		return 0x821717B4;
		  /* 821717B4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821717B4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821717B4h case    3:*/		return 0x821717B8;
		  /* 821717B8h */ case    4:  		/* mr R31, R3 */
		/* 821717B8h case    4:*/		regs.R31 = regs.R3;
		/* 821717B8h case    4:*/		return 0x821717BC;
		  /* 821717BCh */ case    5:  		/* bl -18996 */
		/* 821717BCh case    5:*/		regs.LR = 0x821717C0; return 0x8216CD88;
		/* 821717BCh case    5:*/		return 0x821717C0;
		  /* 821717C0h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821717C0h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821717C0h case    6:*/		return 0x821717C4;
		  /* 821717C4h */ case    7:  		/* bc 12, CR0_EQ, 52 */
		/* 821717C4h case    7:*/		if ( regs.CR[0].eq ) { return 0x821717F8;  }
		/* 821717C4h case    7:*/		return 0x821717C8;
		  /* 821717C8h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 821717C8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821717C8h case    8:*/		return 0x821717CC;
		  /* 821717CCh */ case    9:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821717CCh case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821717CCh case    9:*/		return 0x821717D0;
	}
	return 0x821717D0;
} // Block from 821717A8h-821717D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821717D0h
// Function '?IsUnblocked@RegOptSimulator@D3DXShader@@SA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821717D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821717D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821717D0);
		  /* 821717D0h */ case    0:  		/* cmplwi CR6, R11, 83 */
		/* 821717D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000053);
		/* 821717D0h case    0:*/		return 0x821717D4;
		  /* 821717D4h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 821717D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x821717E4;  }
		/* 821717D4h case    1:*/		return 0x821717D8;
		  /* 821717D8h */ case    2:  		/* cmplwi CR6, R11, 95 */
		/* 821717D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 821717D8h case    2:*/		return 0x821717DC;
		  /* 821717DCh */ case    3:  		/* li R11, 1 */
		/* 821717DCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821717DCh case    3:*/		return 0x821717E0;
		  /* 821717E0h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 821717E0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821717E8;  }
		/* 821717E0h case    4:*/		return 0x821717E4;
	}
	return 0x821717E4;
} // Block from 821717D0h-821717E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821717E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821717E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821717E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821717E4);
		  /* 821717E4h */ case    0:  		/* li R11, 0 */
		/* 821717E4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821717E4h case    0:*/		return 0x821717E8;
	}
	return 0x821717E8;
} // Block from 821717E4h-821717E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821717E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821717E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821717E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821717E8);
		  /* 821717E8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821717E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821717E8h case    0:*/		return 0x821717EC;
		  /* 821717ECh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821717ECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821717F8;  }
		/* 821717ECh case    1:*/		return 0x821717F0;
		  /* 821717F0h */ case    2:  		/* li R3, 1 */
		/* 821717F0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821717F0h case    2:*/		return 0x821717F4;
		  /* 821717F4h */ case    3:  		/* b 92 */
		/* 821717F4h case    3:*/		return 0x82171850;
		/* 821717F4h case    3:*/		return 0x821717F8;
	}
	return 0x821717F8;
} // Block from 821717E8h-821717F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821717F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821717F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821717F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821717F8);
		  /* 821717F8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821717F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821717F8h case    0:*/		return 0x821717FC;
		  /* 821717FCh */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821717FCh case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821717FCh case    1:*/		return 0x82171800;
		  /* 82171800h */ case    2:  		/* cmplwi CR6, R11, 119 */
		/* 82171800h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000077);
		/* 82171800h case    2:*/		return 0x82171804;
		  /* 82171804h */ case    3:  		/* bc 12, CR6_GT, 48 */
		/* 82171804h case    3:*/		if ( regs.CR[6].gt ) { return 0x82171834;  }
		/* 82171804h case    3:*/		return 0x82171808;
		  /* 82171808h */ case    4:  		/* cmplwi CR6, R11, 118 */
		/* 82171808h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000076);
		/* 82171808h case    4:*/		return 0x8217180C;
		  /* 8217180Ch */ case    5:  		/* bc 4, CR6_LT, -28 */
		/* 8217180Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x821717F0;  }
		/* 8217180Ch case    5:*/		return 0x82171810;
		  /* 82171810h */ case    6:  		/* cmplwi CR6, R11, 103 */
		/* 82171810h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 82171810h case    6:*/		return 0x82171814;
		  /* 82171814h */ case    7:  		/* bc 12, CR6_LT, 56 */
		/* 82171814h case    7:*/		if ( regs.CR[6].lt ) { return 0x8217184C;  }
		/* 82171814h case    7:*/		return 0x82171818;
		  /* 82171818h */ case    8:  		/* cmplwi CR6, R11, 104 */
		/* 82171818h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000068);
		/* 82171818h case    8:*/		return 0x8217181C;
		  /* 8217181Ch */ case    9:  		/* bc 4, CR6_GT, -44 */
		/* 8217181Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x821717F0;  }
		/* 8217181Ch case    9:*/		return 0x82171820;
		  /* 82171820h */ case   10:  		/* cmplwi CR6, R11, 107 */
		/* 82171820h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006B);
		/* 82171820h case   10:*/		return 0x82171824;
		  /* 82171824h */ case   11:  		/* bc 4, CR6_GT, 40 */
		/* 82171824h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8217184C;  }
		/* 82171824h case   11:*/		return 0x82171828;
		  /* 82171828h */ case   12:  		/* cmplwi CR6, R11, 111 */
		/* 82171828h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006F);
		/* 82171828h case   12:*/		return 0x8217182C;
		  /* 8217182Ch */ case   13:  		/* bc 4, CR6_GT, -60 */
		/* 8217182Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x821717F0;  }
		/* 8217182Ch case   13:*/		return 0x82171830;
		  /* 82171830h */ case   14:  		/* b 28 */
		/* 82171830h case   14:*/		return 0x8217184C;
		/* 82171830h case   14:*/		return 0x82171834;
	}
	return 0x82171834;
} // Block from 821717F8h-82171834h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82171834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171834);
		  /* 82171834h */ case    0:  		/* cmplwi CR6, R11, 121 */
		/* 82171834h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000079);
		/* 82171834h case    0:*/		return 0x82171838;
		  /* 82171838h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 82171838h case    1:*/		if ( regs.CR[6].lt ) { return 0x8217184C;  }
		/* 82171838h case    1:*/		return 0x8217183C;
		  /* 8217183Ch */ case    2:  		/* cmplwi CR6, R11, 122 */
		/* 8217183Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007A);
		/* 8217183Ch case    2:*/		return 0x82171840;
		  /* 82171840h */ case    3:  		/* bc 4, CR6_GT, -80 */
		/* 82171840h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821717F0;  }
		/* 82171840h case    3:*/		return 0x82171844;
		  /* 82171844h */ case    4:  		/* cmplwi CR6, R11, 126 */
		/* 82171844h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007E);
		/* 82171844h case    4:*/		return 0x82171848;
		  /* 82171848h */ case    5:  		/* bc 12, CR6_EQ, -88 */
		/* 82171848h case    5:*/		if ( regs.CR[6].eq ) { return 0x821717F0;  }
		/* 82171848h case    5:*/		return 0x8217184C;
	}
	return 0x8217184C;
} // Block from 82171834h-8217184Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8217184Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217184C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217184C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217184C);
		  /* 8217184Ch */ case    0:  		/* li R3, 0 */
		/* 8217184Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8217184Ch case    0:*/		return 0x82171850;
	}
	return 0x82171850;
} // Block from 8217184Ch-82171850h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171850);
		  /* 82171850h */ case    0:  		/* addi R1, R1, 96 */
		/* 82171850h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82171850h case    0:*/		return 0x82171854;
		  /* 82171854h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82171854h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82171854h case    1:*/		return 0x82171858;
		  /* 82171858h */ case    2:  		/* mtspr LR, R12 */
		/* 82171858h case    2:*/		regs.LR = regs.R12;
		/* 82171858h case    2:*/		return 0x8217185C;
		  /* 8217185Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8217185Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8217185Ch case    3:*/		return 0x82171860;
		  /* 82171860h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82171860h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171860h case    4:*/		return 0x82171864;
	}
	return 0x82171864;
} // Block from 82171850h-82171864h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82171864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171864);
		  /* 82171864h */ case    0:  		/* nop */
		/* 82171864h case    0:*/		cpu::op::nop();
		/* 82171864h case    0:*/		return 0x82171868;
	}
	return 0x82171868;
} // Block from 82171864h-82171868h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171868);
		  /* 82171868h */ case    0:  		/* mfspr R12, LR */
		/* 82171868h case    0:*/		regs.R12 = regs.LR;
		/* 82171868h case    0:*/		return 0x8217186C;
		  /* 8217186Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8217186Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8217186Ch case    1:*/		return 0x82171870;
		  /* 82171870h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82171870h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82171870h case    2:*/		return 0x82171874;
		  /* 82171874h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82171874h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82171874h case    3:*/		return 0x82171878;
	}
	return 0x82171878;
} // Block from 82171868h-82171878h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82171878h
// Function '?ClearLocalRegisterAssignment@Compiler@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171878);
		  /* 82171878h */ case    0:  		/* mr R31, R3 */
		/* 82171878h case    0:*/		regs.R31 = regs.R3;
		/* 82171878h case    0:*/		return 0x8217187C;
		  /* 8217187Ch */ case    1:  		/* bl -212 */
		/* 8217187Ch case    1:*/		regs.LR = 0x82171880; return 0x821717A8;
		/* 8217187Ch case    1:*/		return 0x82171880;
		  /* 82171880h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82171880h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82171880h case    2:*/		return 0x82171884;
		  /* 82171884h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82171884h case    3:*/		if ( regs.CR[0].eq ) { return 0x82171890;  }
		/* 82171884h case    3:*/		return 0x82171888;
		  /* 82171888h */ case    4:  		/* li R3, 1 */
		/* 82171888h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82171888h case    4:*/		return 0x8217188C;
		  /* 8217188Ch */ case    5:  		/* b 40 */
		/* 8217188Ch case    5:*/		return 0x821718B4;
		/* 8217188Ch case    5:*/		return 0x82171890;
	}
	return 0x82171890;
} // Block from 82171878h-82171890h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82171890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171890);
		  /* 82171890h */ case    0:  		/* lbz R11, <#[R31 + 16]> */
		/* 82171890h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82171890h case    0:*/		return 0x82171894;
		  /* 82171894h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82171894h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82171894h case    1:*/		return 0x82171898;
		  /* 82171898h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 82171898h case    2:*/		if ( regs.CR[0].eq ) { return 0x821718B0;  }
		/* 82171898h case    2:*/		return 0x8217189C;
		  /* 8217189Ch */ case    3:  		/* lwz R11, <#[R31 + 20]> */
		/* 8217189Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8217189Ch case    3:*/		return 0x821718A0;
		  /* 821718A0h */ case    4:  		/* li R3, 1 */
		/* 821718A0h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821718A0h case    4:*/		return 0x821718A4;
		  /* 821718A4h */ case    5:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 821718A4h case    5:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 821718A4h case    5:*/		return 0x821718A8;
		  /* 821718A8h */ case    6:  		/* cmplwi CR6, R11, 8191 */
		/* 821718A8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001FFF);
		/* 821718A8h case    6:*/		return 0x821718AC;
		  /* 821718ACh */ case    7:  		/* bc 12, CR6_LT, 8 */
		/* 821718ACh case    7:*/		if ( regs.CR[6].lt ) { return 0x821718B4;  }
		/* 821718ACh case    7:*/		return 0x821718B0;
	}
	return 0x821718B0;
} // Block from 82171890h-821718B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821718B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821718B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821718B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821718B0);
		  /* 821718B0h */ case    0:  		/* li R3, 0 */
		/* 821718B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821718B0h case    0:*/		return 0x821718B4;
	}
	return 0x821718B4;
} // Block from 821718B0h-821718B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821718B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821718B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821718B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821718B4);
		  /* 821718B4h */ case    0:  		/* addi R1, R1, 96 */
		/* 821718B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821718B4h case    0:*/		return 0x821718B8;
		  /* 821718B8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821718B8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821718B8h case    1:*/		return 0x821718BC;
		  /* 821718BCh */ case    2:  		/* mtspr LR, R12 */
		/* 821718BCh case    2:*/		regs.LR = regs.R12;
		/* 821718BCh case    2:*/		return 0x821718C0;
		  /* 821718C0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821718C0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821718C0h case    3:*/		return 0x821718C4;
		  /* 821718C4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821718C4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821718C4h case    4:*/		return 0x821718C8;
	}
	return 0x821718C8;
} // Block from 821718B4h-821718C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821718C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821718C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821718C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821718C8);
		  /* 821718C8h */ case    0:  		/* mr R11, R3 */
		/* 821718C8h case    0:*/		regs.R11 = regs.R3;
		/* 821718C8h case    0:*/		return 0x821718CC;
		  /* 821718CCh */ case    1:  		/* mr R3, R4 */
		/* 821718CCh case    1:*/		regs.R3 = regs.R4;
		/* 821718CCh case    1:*/		return 0x821718D0;
		  /* 821718D0h */ case    2:  		/* lbz R10, <#[R11 + 16]> */
		/* 821718D0h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821718D0h case    2:*/		return 0x821718D4;
		  /* 821718D4h */ case    3:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821718D4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821718D4h case    3:*/		return 0x821718D8;
		  /* 821718D8h */ case    4:  		/* bc 12, CR0_EQ, 108 */
		/* 821718D8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82171944;  }
		/* 821718D8h case    4:*/		return 0x821718DC;
		  /* 821718DCh */ case    5:  		/* lbz R10, <#[R4 + 16]> */
		/* 821718DCh case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 821718DCh case    5:*/		return 0x821718E0;
		  /* 821718E0h */ case    6:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821718E0h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821718E0h case    6:*/		return 0x821718E4;
		  /* 821718E4h */ case    7:  		/* bc 12, CR0_EQ, 96 */
		/* 821718E4h case    7:*/		if ( regs.CR[0].eq ) { return 0x82171944;  }
		/* 821718E4h case    7:*/		return 0x821718E8;
		  /* 821718E8h */ case    8:  		/* lwz R10, <#[R11 + 20]> */
		/* 821718E8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821718E8h case    8:*/		return 0x821718EC;
		  /* 821718ECh */ case    9:  		/* lwz R9, <#[R4 + 20]> */
		/* 821718ECh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000014) );
		/* 821718ECh case    9:*/		return 0x821718F0;
		  /* 821718F0h */ case   10:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 821718F0h case   10:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 821718F0h case   10:*/		return 0x821718F4;
		  /* 821718F4h */ case   11:  		/* rlwinm R9, R9, 0, 19, 31 */
		/* 821718F4h case   11:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R9,regs.R9);
		/* 821718F4h case   11:*/		return 0x821718F8;
		  /* 821718F8h */ case   12:  		/* cmplw CR6, R10, R9 */
		/* 821718F8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821718F8h case   12:*/		return 0x821718FC;
		  /* 821718FCh */ case   13:  		/* bc 4, CR6_GT, 12 */
		/* 821718FCh case   13:*/		if ( !regs.CR[6].gt ) { return 0x82171908;  }
		/* 821718FCh case   13:*/		return 0x82171900;
		  /* 82171900h */ case   14:  		/* li R3, 1 */
		/* 82171900h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82171900h case   14:*/		return 0x82171904;
		  /* 82171904h */ case   15:  		/* bclr 20, CR0_LT */
		/* 82171904h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171904h case   15:*/		return 0x82171908;
	}
	return 0x82171908;
} // Block from 821718C8h-82171908h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82171908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171908);
		  /* 82171908h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82171908h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82171908h case    0:*/		return 0x8217190C;
		  /* 8217190Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8217190Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8217190Ch case    1:*/		return 0x82171910;
		  /* 82171910h */ case    2:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82171910h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82171910h case    2:*/		return 0x82171914;
		  /* 82171914h */ case    3:  		/* bc 4, CR0_EQ, 40 */
		/* 82171914h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8217193C;  }
		/* 82171914h case    3:*/		return 0x82171918;
		  /* 82171918h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82171918h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82171918h case    4:*/		return 0x8217191C;
		  /* 8217191Ch */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 8217191Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8217193C;  }
		/* 8217191Ch case    5:*/		return 0x82171920;
		  /* 82171920h */ case    6:  		/* lwz R9, <#[R11 + 20]> */
		/* 82171920h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82171920h case    6:*/		return 0x82171924;
		  /* 82171924h */ case    7:  		/* rlwinm R9, R9, 0, 19, 31 */
		/* 82171924h case    7:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R9,regs.R9);
		/* 82171924h case    7:*/		return 0x82171928;
		  /* 82171928h */ case    8:  		/* cmplw CR6, R9, R10 */
		/* 82171928h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82171928h case    8:*/		return 0x8217192C;
		  /* 8217192Ch */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 8217192Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x8217193C;  }
		/* 8217192Ch case    9:*/		return 0x82171930;
		  /* 82171930h */ case   10:  		/* cmplw CR6, R11, R3 */
		/* 82171930h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 82171930h case   10:*/		return 0x82171934;
		  /* 82171934h */ case   11:  		/* bc 4, CR6_EQ, -44 */
		/* 82171934h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82171908;  }
		/* 82171934h case   11:*/		return 0x82171938;
		  /* 82171938h */ case   12:  		/* b -56 */
		/* 82171938h case   12:*/		return 0x82171900;
		/* 82171938h case   12:*/		return 0x8217193C;
	}
	return 0x8217193C;
} // Block from 82171908h-8217193Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8217193Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217193C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217193C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217193C);
		  /* 8217193Ch */ case    0:  		/* li R3, 0 */
		/* 8217193Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8217193Ch case    0:*/		return 0x82171940;
		  /* 82171940h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82171940h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171940h case    1:*/		return 0x82171944;
	}
	return 0x82171944;
} // Block from 8217193Ch-82171944h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171944);
		  /* 82171944h */ case    0:  		/* mr R4, R11 */
		/* 82171944h case    0:*/		regs.R4 = regs.R11;
		/* 82171944h case    0:*/		return 0x82171948;
		  /* 82171948h */ case    1:  		/* b 739192 */
		/* 82171948h case    1:*/		return 0x822260C0;
		/* 82171948h case    1:*/		return 0x8217194C;
		  /* 8217194Ch */ case    2:  		/* nop */
		/* 8217194Ch case    2:*/		cpu::op::nop();
		/* 8217194Ch case    2:*/		return 0x82171950;
	}
	return 0x82171950;
} // Block from 82171944h-82171950h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171950);
		  /* 82171950h */ case    0:  		/* mfspr R12, LR */
		/* 82171950h case    0:*/		regs.R12 = regs.LR;
		/* 82171950h case    0:*/		return 0x82171954;
		  /* 82171954h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82171954h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82171954h case    1:*/		return 0x82171958;
		  /* 82171958h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82171958h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82171958h case    2:*/		return 0x8217195C;
		  /* 8217195Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8217195Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8217195Ch case    3:*/		return 0x82171960;
		  /* 82171960h */ case    4:  		/* lwz R4, <#[R3]> */
		/* 82171960h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 82171960h case    4:*/		return 0x82171964;
		  /* 82171964h */ case    5:  		/* mr R31, R3 */
		/* 82171964h case    5:*/		regs.R31 = regs.R3;
		/* 82171964h case    5:*/		return 0x82171968;
		  /* 82171968h */ case    6:  		/* nor R11, R4, R4 */
		/* 82171968h case    6:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R4,regs.R4);
		/* 82171968h case    6:*/		return 0x8217196C;
		  /* 8217196Ch */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8217196Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8217196Ch case    7:*/		return 0x82171970;
		  /* 82171970h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 82171970h case    8:*/		if ( regs.CR[0].eq ) { return 0x8217198C;  }
		/* 82171970h case    8:*/		return 0x82171974;
		  /* 82171974h */ case    9:  		/* lwz R11, <#[R4]> */
		/* 82171974h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82171974h case    9:*/		return 0x82171978;
		  /* 82171978h */ case   10:  		/* addi R11, R11, 1 */
		/* 82171978h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82171978h case   10:*/		return 0x8217197C;
		  /* 8217197Ch */ case   11:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8217197Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8217197Ch case   11:*/		return 0x82171980;
		  /* 82171980h */ case   12:  		/* bl -129912 */
		/* 82171980h case   12:*/		regs.LR = 0x82171984; return 0x82151E08;
		/* 82171980h case   12:*/		return 0x82171984;
		  /* 82171984h */ case   13:  		/* li R11, 1 */
		/* 82171984h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82171984h case   13:*/		return 0x82171988;
		  /* 82171988h */ case   14:  		/* stw R11, <#[R31]> */
		/* 82171988h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82171988h case   14:*/		return 0x8217198C;
	}
	return 0x8217198C;
} // Block from 82171950h-8217198Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8217198Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217198C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217198C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217198C);
		  /* 8217198Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 8217198Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8217198Ch case    0:*/		return 0x82171990;
		  /* 82171990h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82171990h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82171990h case    1:*/		return 0x82171994;
		  /* 82171994h */ case    2:  		/* mtspr LR, R12 */
		/* 82171994h case    2:*/		regs.LR = regs.R12;
		/* 82171994h case    2:*/		return 0x82171998;
		  /* 82171998h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82171998h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82171998h case    3:*/		return 0x8217199C;
		  /* 8217199Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8217199Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8217199Ch case    4:*/		return 0x821719A0;
	}
	return 0x821719A0;
} // Block from 8217198Ch-821719A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821719A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821719A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821719A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821719A0);
		  /* 821719A0h */ case    0:  		/* mfspr R12, LR */
		/* 821719A0h case    0:*/		regs.R12 = regs.LR;
		/* 821719A0h case    0:*/		return 0x821719A4;
		  /* 821719A4h */ case    1:  		/* bl -919372 */
		/* 821719A4h case    1:*/		regs.LR = 0x821719A8; return 0x82091258;
		/* 821719A4h case    1:*/		return 0x821719A8;
		  /* 821719A8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821719A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821719A8h case    2:*/		return 0x821719AC;
		  /* 821719ACh */ case    3:  		/* mr R30, R3 */
		/* 821719ACh case    3:*/		regs.R30 = regs.R3;
		/* 821719ACh case    3:*/		return 0x821719B0;
		  /* 821719B0h */ case    4:  		/* mr R29, R5 */
		/* 821719B0h case    4:*/		regs.R29 = regs.R5;
		/* 821719B0h case    4:*/		return 0x821719B4;
		  /* 821719B4h */ case    5:  		/* mr R28, R6 */
		/* 821719B4h case    5:*/		regs.R28 = regs.R6;
		/* 821719B4h case    5:*/		return 0x821719B8;
		  /* 821719B8h */ case    6:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 821719B8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 821719B8h case    6:*/		return 0x821719BC;
		  /* 821719BCh */ case    7:  		/* addi R31, R30, 4 */
		/* 821719BCh case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R30,0x4);
		/* 821719BCh case    7:*/		return 0x821719C0;
		  /* 821719C0h */ case    8:  		/* cmpwi CR6, R28, 0 */
		/* 821719C0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 821719C0h case    8:*/		return 0x821719C4;
		  /* 821719C4h */ case    9:  		/* addi R5, R1, 80 */
		/* 821719C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821719C4h case    9:*/		return 0x821719C8;
		  /* 821719C8h */ case   10:  		/* mr R3, R31 */
		/* 821719C8h case   10:*/		regs.R3 = regs.R31;
		/* 821719C8h case   10:*/		return 0x821719CC;
		  /* 821719CCh */ case   11:  		/* bc 4, CR6_GT, 12 */
		/* 821719CCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x821719D8;  }
		/* 821719CCh case   11:*/		return 0x821719D0;
		  /* 821719D0h */ case   12:  		/* bl -1000 */
		/* 821719D0h case   12:*/		regs.LR = 0x821719D4; return 0x821715E8;
		/* 821719D0h case   12:*/		return 0x821719D4;
		  /* 821719D4h */ case   13:  		/* b 12 */
		/* 821719D4h case   13:*/		return 0x821719E0;
		/* 821719D4h case   13:*/		return 0x821719D8;
	}
	return 0x821719D8;
} // Block from 821719A0h-821719D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821719D8h
// Function '?Clone@Compiler@D3DXShader@@QAAPAVDependency@2@PAV32@PAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821719D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821719D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821719D8);
		  /* 821719D8h */ case    0:  		/* addi R4, R4, 3 */
		/* 821719D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x3);
		/* 821719D8h case    0:*/		return 0x821719DC;
		  /* 821719DCh */ case    1:  		/* bl -764 */
		/* 821719DCh case    1:*/		regs.LR = 0x821719E0; return 0x821716E0;
		/* 821719DCh case    1:*/		return 0x821719E0;
	}
	return 0x821719E0;
} // Block from 821719D8h-821719E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821719E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821719E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821719E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821719E0);
		  /* 821719E0h */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 821719E0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821719E0h case    0:*/		return 0x821719E4;
		  /* 821719E4h */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 821719E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82171A58;  }
		/* 821719E4h case    1:*/		return 0x821719E8;
		  /* 821719E8h */ case    2:  		/* cmplwi CR6, R29, 1 */
		/* 821719E8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 821719E8h case    2:*/		return 0x821719EC;
		  /* 821719ECh */ case    3:  		/* bc 12, CR6_EQ, 120 */
		/* 821719ECh case    3:*/		if ( regs.CR[6].eq ) { return 0x82171A64;  }
		/* 821719ECh case    3:*/		return 0x821719F0;
		  /* 821719F0h */ case    4:  		/* lis R10, -27863 */
		/* 821719F0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9329);
		/* 821719F0h case    4:*/		return 0x821719F4;
		  /* 821719F4h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 821719F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821719F4h case    5:*/		return 0x821719F8;
		  /* 821719F8h */ case    6:  		/* li R9, 1186 */
		/* 821719F8h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x4A2);
		/* 821719F8h case    6:*/		return 0x821719FC;
		  /* 821719FCh */ case    7:  		/* ori R10, R10, 13532 */
		/* 821719FCh case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x34DC);
		/* 821719FCh case    7:*/		return 0x82171A00;
		  /* 82171A00h */ case    8:  		/* mr R8, R11 */
		/* 82171A00h case    8:*/		regs.R8 = regs.R11;
		/* 82171A00h case    8:*/		return 0x82171A04;
		  /* 82171A04h */ case    9:  		/* rldimi R10, R9, 32, 0 */
		/* 82171A04h case    9:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 82171A04h case    9:*/		return 0x82171A08;
		  /* 82171A08h */ case   10:  		/* srd R10, R10, R11 */
		/* 82171A08h case   10:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82171A08h case   10:*/		return 0x82171A0C;
		  /* 82171A0Ch */ case   11:  		/* srd R10, R10, R11 */
		/* 82171A0Ch case   11:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82171A0Ch case   11:*/		return 0x82171A10;
		  /* 82171A10h */ case   12:  		/* srd R10, R10, R11 */
		/* 82171A10h case   12:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82171A10h case   12:*/		return 0x82171A14;
		  /* 82171A14h */ case   13:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82171A14h case   13:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82171A14h case   13:*/		return 0x82171A18;
		  /* 82171A18h */ case   14:  		/* cmplw CR6, R10, R29 */
		/* 82171A18h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 82171A18h case   14:*/		return 0x82171A1C;
		  /* 82171A1Ch */ case   15:  		/* bc 4, CR6_LT, 88 */
		/* 82171A1Ch case   15:*/		if ( !regs.CR[6].lt ) { return 0x82171A74;  }
		/* 82171A1Ch case   15:*/		return 0x82171A20;
		  /* 82171A20h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 82171A20h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82171A20h case   16:*/		return 0x82171A24;
		  /* 82171A24h */ case   17:  		/* add R10, R3, R28 */
		/* 82171A24h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R28);
		/* 82171A24h case   17:*/		return 0x82171A28;
		  /* 82171A28h */ case   18:  		/* nor R9, R11, R11 */
		/* 82171A28h case   18:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R11,regs.R11);
		/* 82171A28h case   18:*/		return 0x82171A2C;
		  /* 82171A2Ch */ case   19:  		/* rlwinm R4, R10, 0, 0, 29 */
		/* 82171A2Ch case   19:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R10);
		/* 82171A2Ch case   19:*/		return 0x82171A30;
		  /* 82171A30h */ case   20:  		/* rlwinm. R10, R9, 0, 31, 31 */
		/* 82171A30h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R9);
		/* 82171A30h case   20:*/		return 0x82171A34;
		  /* 82171A34h */ case   21:  		/* bc 4, CR0_EQ, 12 */
		/* 82171A34h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82171A40;  }
		/* 82171A34h case   21:*/		return 0x82171A38;
		  /* 82171A38h */ case   22:  		/* li R11, 31 */
		/* 82171A38h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x1F);
		/* 82171A38h case   22:*/		return 0x82171A3C;
		  /* 82171A3Ch */ case   23:  		/* b 16 */
		/* 82171A3Ch case   23:*/		return 0x82171A4C;
		/* 82171A3Ch case   23:*/		return 0x82171A40;
	}
	return 0x82171A40;
} // Block from 821719E0h-82171A40h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82171A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A40);
		  /* 82171A40h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82171A40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82171A40h case    0:*/		return 0x82171A44;
		  /* 82171A44h */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 82171A44h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 82171A44h case    1:*/		return 0x82171A48;
		  /* 82171A48h */ case    2:  		/* addi R11, R11, -1 */
		/* 82171A48h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82171A48h case    2:*/		return 0x82171A4C;
	}
	return 0x82171A4C;
} // Block from 82171A40h-82171A4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A4C);
		  /* 82171A4Ch */ case    0:  		/* add R10, R4, R29 */
		/* 82171A4Ch case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R4,regs.R29);
		/* 82171A4Ch case    0:*/		return 0x82171A50;
	}
	return 0x82171A50;
} // Block from 82171A4Ch-82171A50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171A50h
// Function '?ComputeBlockOutputRegMask@Compiler@D3DXShader@@QAAIPAVBlock@2@PAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A50);
		  /* 82171A50h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82171A50h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82171A50h case    0:*/		return 0x82171A54;
		  /* 82171A54h */ case    1:  		/* bc 4, CR6_GT, -152 */
		/* 82171A54h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821719BC;  }
		/* 82171A54h case    1:*/		return 0x82171A58;
	}
	return 0x82171A58;
} // Block from 82171A50h-82171A58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A58);
		  /* 82171A58h */ case    0:  		/* li R3, -1 */
		/* 82171A58h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82171A58h case    0:*/		return 0x82171A5C;
		  /* 82171A5Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 82171A5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82171A5Ch case    1:*/		return 0x82171A60;
		  /* 82171A60h */ case    2:  		/* b -919480 */
		/* 82171A60h case    2:*/		return 0x820912A8;
		/* 82171A60h case    2:*/		return 0x82171A64;
	}
	return 0x82171A64;
} // Block from 82171A58h-82171A64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A64);
		  /* 82171A64h */ case    0:  		/* rlwinm R11, R3, 0, 30, 31 */
		/* 82171A64h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R3);
		/* 82171A64h case    0:*/		return 0x82171A68;
		  /* 82171A68h */ case    1:  		/* li R10, 1 */
		/* 82171A68h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82171A68h case    1:*/		return 0x82171A6C;
		  /* 82171A6Ch */ case    2:  		/* slw R11, R10, R11 */
		/* 82171A6Ch case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82171A6Ch case    2:*/		return 0x82171A70;
		  /* 82171A70h */ case    3:  		/* b 8 */
		/* 82171A70h case    3:*/		return 0x82171A78;
		/* 82171A70h case    3:*/		return 0x82171A74;
	}
	return 0x82171A74;
} // Block from 82171A64h-82171A74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82171A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A74);
		  /* 82171A74h */ case    0:  		/* nor R11, R11, R11 */
		/* 82171A74h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82171A74h case    0:*/		return 0x82171A78;
	}
	return 0x82171A78;
} // Block from 82171A74h-82171A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A78);
		  /* 82171A78h */ case    0:  		/* rlwimi R11, R3, 2, 0, 27 */
		/* 82171A78h case    0:*/		cpu::op::rlwimi<0,2,0,27>(regs,&regs.R11,regs.R3);
		/* 82171A78h case    0:*/		return 0x82171A7C;
		  /* 82171A7Ch */ case    1:  		/* mr R3, R11 */
		/* 82171A7Ch case    1:*/		regs.R3 = regs.R11;
		/* 82171A7Ch case    1:*/		return 0x82171A80;
		  /* 82171A80h */ case    2:  		/* b -36 */
		/* 82171A80h case    2:*/		return 0x82171A5C;
		/* 82171A80h case    2:*/		return 0x82171A84;
		  /* 82171A84h */ case    3:  		/* nop */
		/* 82171A84h case    3:*/		cpu::op::nop();
		/* 82171A84h case    3:*/		return 0x82171A88;
	}
	return 0x82171A88;
} // Block from 82171A78h-82171A88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82171A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171A88);
		  /* 82171A88h */ case    0:  		/* mfspr R12, LR */
		/* 82171A88h case    0:*/		regs.R12 = regs.LR;
		/* 82171A88h case    0:*/		return 0x82171A8C;
		  /* 82171A8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82171A8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82171A8Ch case    1:*/		return 0x82171A90;
		  /* 82171A90h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82171A90h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82171A90h case    2:*/		return 0x82171A94;
		  /* 82171A94h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82171A94h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82171A94h case    3:*/		return 0x82171A98;
		  /* 82171A98h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 82171A98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82171A98h case    4:*/		return 0x82171A9C;
		  /* 82171A9Ch */ case    5:  		/* mr R31, R3 */
		/* 82171A9Ch case    5:*/		regs.R31 = regs.R3;
		/* 82171A9Ch case    5:*/		return 0x82171AA0;
		  /* 82171AA0h */ case    6:  		/* nor R10, R11, R11 */
		/* 82171AA0h case    6:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 82171AA0h case    6:*/		return 0x82171AA4;
		  /* 82171AA4h */ case    7:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82171AA4h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82171AA4h case    7:*/		return 0x82171AA8;
		  /* 82171AA8h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 82171AA8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82171AB8;  }
		/* 82171AA8h case    8:*/		return 0x82171AAC;
		  /* 82171AACh */ case    9:  		/* li R11, 1 */
		/* 82171AACh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82171AACh case    9:*/		return 0x82171AB0;
		  /* 82171AB0h */ case   10:  		/* stw R11, <#[R3 + 4]> */
		/* 82171AB0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82171AB0h case   10:*/		return 0x82171AB4;
		  /* 82171AB4h */ case   11:  		/* b 24 */
		/* 82171AB4h case   11:*/		return 0x82171ACC;
		/* 82171AB4h case   11:*/		return 0x82171AB8;
	}
	return 0x82171AB8;
} // Block from 82171A88h-82171AB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82171AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171AB8);
		  /* 82171AB8h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82171AB8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82171AB8h case    0:*/		return 0x82171ABC;
		  /* 82171ABCh */ case    1:  		/* li R4, 0 */
		/* 82171ABCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82171ABCh case    1:*/		return 0x82171AC0;
		  /* 82171AC0h */ case    2:  		/* addi R3, R11, 4 */
		/* 82171AC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x4);
		/* 82171AC0h case    2:*/		return 0x82171AC4;
		  /* 82171AC4h */ case    3:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 82171AC4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 82171AC4h case    3:*/		return 0x82171AC8;
		  /* 82171AC8h */ case    4:  		/* bl -919432 */
		/* 82171AC8h case    4:*/		regs.LR = 0x82171ACC; return 0x82091340;
		/* 82171AC8h case    4:*/		return 0x82171ACC;
	}
	return 0x82171ACC;
} // Block from 82171AB8h-82171ACCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82171ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171ACC);
		  /* 82171ACCh */ case    0:  		/* lwz R3, <#[R31 + 8]> */
		/* 82171ACCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82171ACCh case    0:*/		return 0x82171AD0;
		  /* 82171AD0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82171AD0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82171AD0h case    1:*/		return 0x82171AD4;
		  /* 82171AD4h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82171AD4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82171AE8;  }
		/* 82171AD4h case    2:*/		return 0x82171AD8;
		  /* 82171AD8h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 82171AD8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82171AD8h case    3:*/		return 0x82171ADC;
		  /* 82171ADCh */ case    4:  		/* li R4, 0 */
		/* 82171ADCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82171ADCh case    4:*/		return 0x82171AE0;
		  /* 82171AE0h */ case    5:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82171AE0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82171AE0h case    5:*/		return 0x82171AE4;
		  /* 82171AE4h */ case    6:  		/* bl -919460 */
		/* 82171AE4h case    6:*/		regs.LR = 0x82171AE8; return 0x82091340;
		/* 82171AE4h case    6:*/		return 0x82171AE8;
	}
	return 0x82171AE8;
} // Block from 82171ACCh-82171AE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82171AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171AE8);
		  /* 82171AE8h */ case    0:  		/* li R11, 0 */
		/* 82171AE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82171AE8h case    0:*/		return 0x82171AEC;
		  /* 82171AECh */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 82171AECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82171AECh case    1:*/		return 0x82171AF0;
		  /* 82171AF0h */ case    2:  		/* addi R1, R1, 96 */
		/* 82171AF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82171AF0h case    2:*/		return 0x82171AF4;
		  /* 82171AF4h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82171AF4h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82171AF4h case    3:*/		return 0x82171AF8;
		  /* 82171AF8h */ case    4:  		/* mtspr LR, R12 */
		/* 82171AF8h case    4:*/		regs.LR = regs.R12;
		/* 82171AF8h case    4:*/		return 0x82171AFC;
		  /* 82171AFCh */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82171AFCh case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82171AFCh case    5:*/		return 0x82171B00;
		  /* 82171B00h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82171B00h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82171B00h case    6:*/		return 0x82171B04;
	}
	return 0x82171B04;
} // Block from 82171AE8h-82171B04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82171B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171B04);
		  /* 82171B04h */ case    0:  		/* nop */
		/* 82171B04h case    0:*/		cpu::op::nop();
		/* 82171B04h case    0:*/		return 0x82171B08;
	}
	return 0x82171B08;
} // Block from 82171B04h-82171B08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171B08);
		  /* 82171B08h */ case    0:  		/* mfspr R12, LR */
		/* 82171B08h case    0:*/		regs.R12 = regs.LR;
		/* 82171B08h case    0:*/		return 0x82171B0C;
		  /* 82171B0Ch */ case    1:  		/* bl -919744 */
		/* 82171B0Ch case    1:*/		regs.LR = 0x82171B10; return 0x8209124C;
		/* 82171B0Ch case    1:*/		return 0x82171B10;
		  /* 82171B10h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82171B10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82171B10h case    2:*/		return 0x82171B14;
		  /* 82171B14h */ case    3:  		/* rlwinm R27, R4, 30, 2, 29 */
		/* 82171B14h case    3:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R27,regs.R4);
		/* 82171B14h case    3:*/		return 0x82171B18;
		  /* 82171B18h */ case    4:  		/* lwz R11, <#[R3 + 12]> */
		/* 82171B18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82171B18h case    4:*/		return 0x82171B1C;
		  /* 82171B1Ch */ case    5:  		/* mr R31, R3 */
		/* 82171B1Ch case    5:*/		regs.R31 = regs.R3;
		/* 82171B1Ch case    5:*/		return 0x82171B20;
		  /* 82171B20h */ case    6:  		/* addi R29, R27, 4 */
		/* 82171B20h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x4);
		/* 82171B20h case    6:*/		return 0x82171B24;
		  /* 82171B24h */ case    7:  		/* mr R30, R4 */
		/* 82171B24h case    7:*/		regs.R30 = regs.R4;
		/* 82171B24h case    7:*/		return 0x82171B28;
		  /* 82171B28h */ case    8:  		/* mr R26, R5 */
		/* 82171B28h case    8:*/		regs.R26 = regs.R5;
		/* 82171B28h case    8:*/		return 0x82171B2C;
		  /* 82171B2Ch */ case    9:  		/* rlwinm R28, R4, 28, 4, 31 */
		/* 82171B2Ch case    9:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R28,regs.R4);
		/* 82171B2Ch case    9:*/		return 0x82171B30;
		  /* 82171B30h */ case   10:  		/* cmplw CR6, R29, R11 */
		/* 82171B30h case   10:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82171B30h case   10:*/		return 0x82171B34;
		  /* 82171B34h */ case   11:  		/* bc 4, CR6_GT, 72 */
		/* 82171B34h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82171B7C;  }
		/* 82171B34h case   11:*/		return 0x82171B38;
		  /* 82171B38h */ case   12:  		/* li R5, 0 */
		/* 82171B38h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82171B38h case   12:*/		return 0x82171B3C;
		  /* 82171B3Ch */ case   13:  		/* lwz R3, <#[R3]> */
		/* 82171B3Ch case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82171B3Ch case   13:*/		return 0x82171B40;
		  /* 82171B40h */ case   14:  		/* rlwinm R4, R29, 2, 0, 29 */
		/* 82171B40h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R29);
		/* 82171B40h case   14:*/		return 0x82171B44;
		  /* 82171B44h */ case   15:  		/* bl -51980 */
		/* 82171B44h case   15:*/		regs.LR = 0x82171B48; return 0x82165038;
		/* 82171B44h case   15:*/		return 0x82171B48;
		  /* 82171B48h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 82171B48h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82171B48h case   16:*/		return 0x82171B4C;
		  /* 82171B4Ch */ case   17:  		/* lwz R4, <#[R31 + 8]> */
		/* 82171B4Ch case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82171B4Ch case   17:*/		return 0x82171B50;
		  /* 82171B50h */ case   18:  		/* mr R25, R3 */
		/* 82171B50h case   18:*/		regs.R25 = regs.R3;
		/* 82171B50h case   18:*/		return 0x82171B54;
		  /* 82171B54h */ case   19:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82171B54h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82171B54h case   19:*/		return 0x82171B58;
		  /* 82171B58h */ case   20:  		/* bl -917928 */
		/* 82171B58h case   20:*/		regs.LR = 0x82171B5C; return 0x820919B0;
		/* 82171B58h case   20:*/		return 0x82171B5C;
		  /* 82171B5Ch */ case   21:  		/* lwz R11, <#[R31 + 12]> */
		/* 82171B5Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82171B5Ch case   21:*/		return 0x82171B60;
		  /* 82171B60h */ case   22:  		/* li R6, 0 */
		/* 82171B60h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82171B60h case   22:*/		return 0x82171B64;
		  /* 82171B64h */ case   23:  		/* lwz R4, <#[R31 + 8]> */
		/* 82171B64h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82171B64h case   23:*/		return 0x82171B68;
		  /* 82171B68h */ case   24:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82171B68h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82171B68h case   24:*/		return 0x82171B6C;
		  /* 82171B6Ch */ case   25:  		/* lwz R3, <#[R31]> */
		/* 82171B6Ch case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82171B6Ch case   25:*/		return 0x82171B70;
		  /* 82171B70h */ case   26:  		/* bl -19744 */
		/* 82171B70h case   26:*/		regs.LR = 0x82171B74; return 0x8216CE50;
		/* 82171B70h case   26:*/		return 0x82171B74;
		  /* 82171B74h */ case   27:  		/* stw R25, <#[R31 + 8]> */
		/* 82171B74h case   27:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000008) );
		/* 82171B74h case   27:*/		return 0x82171B78;
		  /* 82171B78h */ case   28:  		/* stw R29, <#[R31 + 12]> */
		/* 82171B78h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 82171B78h case   28:*/		return 0x82171B7C;
	}
	return 0x82171B7C;
} // Block from 82171B08h-82171B7Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 82171B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171B7C);
		  /* 82171B7Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82171B7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82171B7Ch case    0:*/		return 0x82171B80;
	}
	return 0x82171B80;
} // Block from 82171B7Ch-82171B80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171B80h
// Function '?ComputeRegisterEffectOnGroup@Compiler@D3DXShader@@QAAHPAVInstruction@2@IPAHIPA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171B80);
		  /* 82171B80h */ case    0:  		/* cmplw CR6, R28, R11 */
		/* 82171B80h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82171B80h case    0:*/		return 0x82171B84;
		  /* 82171B84h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82171B84h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82171B8C;  }
		/* 82171B84h case    1:*/		return 0x82171B88;
		  /* 82171B88h */ case    2:  		/* stw R28, <#[R31 + 16]> */
		/* 82171B88h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000010) );
		/* 82171B88h case    2:*/		return 0x82171B8C;
	}
	return 0x82171B8C;
} // Block from 82171B80h-82171B8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171B8C);
		  /* 82171B8Ch */ case    0:  		/* li R10, 4 */
		/* 82171B8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82171B8Ch case    0:*/		return 0x82171B90;
		  /* 82171B90h */ case    1:  		/* rlwinm R9, R30, 0, 28, 31 */
		/* 82171B90h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R30);
		/* 82171B90h case    1:*/		return 0x82171B94;
		  /* 82171B94h */ case    2:  		/* li R11, 0 */
		/* 82171B94h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82171B94h case    2:*/		return 0x82171B98;
		  /* 82171B98h */ case    3:  		/* mtspr CTR, R10 */
		/* 82171B98h case    3:*/		regs.CTR = regs.R10;
		/* 82171B98h case    3:*/		return 0x82171B9C;
		  /* 82171B9Ch */ case    4:  		/* li R10, 1 */
		/* 82171B9Ch case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82171B9Ch case    4:*/		return 0x82171BA0;
		  /* 82171BA0h */ case    5:  		/* slw R10, R10, R11 */
		/* 82171BA0h case    5:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82171BA0h case    5:*/		return 0x82171BA4;
		  /* 82171BA4h */ case    6:  		/* and. R10, R10, R9 */
		/* 82171BA4h case    6:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82171BA4h case    6:*/		return 0x82171BA8;
		  /* 82171BA8h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 82171BA8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82171BBC;  }
		/* 82171BA8h case    7:*/		return 0x82171BAC;
		  /* 82171BACh */ case    8:  		/* add R10, R27, R11 */
		/* 82171BACh case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R27,regs.R11);
		/* 82171BACh case    8:*/		return 0x82171BB0;
		  /* 82171BB0h */ case    9:  		/* lwz R8, <#[R31 + 8]> */
		/* 82171BB0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82171BB0h case    9:*/		return 0x82171BB4;
		  /* 82171BB4h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82171BB4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82171BB4h case   10:*/		return 0x82171BB8;
		  /* 82171BB8h */ case   11:  		/* stwx R26, <#[R10 + R8]> */
		/* 82171BB8h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82171BB8h case   11:*/		return 0x82171BBC;
	}
	return 0x82171BBC;
} // Block from 82171B8Ch-82171BBCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82171BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171BBC);
		  /* 82171BBCh */ case    0:  		/* addi R11, R11, 1 */
		/* 82171BBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82171BBCh case    0:*/		return 0x82171BC0;
		  /* 82171BC0h */ case    1:  		/* bc 16, CR0_LT, -36 */
		/* 82171BC0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82171B9C;  }
		/* 82171BC0h case    1:*/		return 0x82171BC4;
		  /* 82171BC4h */ case    2:  		/* addi R1, R1, 144 */
		/* 82171BC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82171BC4h case    2:*/		return 0x82171BC8;
		  /* 82171BC8h */ case    3:  		/* b -919852 */
		/* 82171BC8h case    3:*/		return 0x8209129C;
		/* 82171BC8h case    3:*/		return 0x82171BCC;
		  /* 82171BCCh */ case    4:  		/* nop */
		/* 82171BCCh case    4:*/		cpu::op::nop();
		/* 82171BCCh case    4:*/		return 0x82171BD0;
	}
	return 0x82171BD0;
} // Block from 82171BBCh-82171BD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82171BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171BD0);
		  /* 82171BD0h */ case    0:  		/* mfspr R12, LR */
		/* 82171BD0h case    0:*/		regs.R12 = regs.LR;
		/* 82171BD0h case    0:*/		return 0x82171BD4;
		  /* 82171BD4h */ case    1:  		/* bl -919936 */
		/* 82171BD4h case    1:*/		regs.LR = 0x82171BD8; return 0x82091254;
		/* 82171BD4h case    1:*/		return 0x82171BD8;
		  /* 82171BD8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82171BD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82171BD8h case    2:*/		return 0x82171BDC;
		  /* 82171BDCh */ case    3:  		/* lwz R11, <#[R4 + 28]> */
		/* 82171BDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82171BDCh case    3:*/		return 0x82171BE0;
		  /* 82171BE0h */ case    4:  		/* mr R28, R3 */
		/* 82171BE0h case    4:*/		regs.R28 = regs.R3;
		/* 82171BE0h case    4:*/		return 0x82171BE4;
		  /* 82171BE4h */ case    5:  		/* mr R29, R4 */
		/* 82171BE4h case    5:*/		regs.R29 = regs.R4;
		/* 82171BE4h case    5:*/		return 0x82171BE8;
		  /* 82171BE8h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82171BE8h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82171BE8h case    6:*/		return 0x82171BEC;
		  /* 82171BECh */ case    7:  		/* bc 4, CR0_EQ, 116 */
		/* 82171BECh case    7:*/		if ( !regs.CR[0].eq ) { return 0x82171C60;  }
		/* 82171BECh case    7:*/		return 0x82171BF0;
		  /* 82171BF0h */ case    8:  		/* lwz R11, <#[R4 + 24]> */
		/* 82171BF0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 82171BF0h case    8:*/		return 0x82171BF4;
		  /* 82171BF4h */ case    9:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82171BF4h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82171BF4h case    9:*/		return 0x82171BF8;
		  /* 82171BF8h */ case   10:  		/* addic. R31, R11, -40 */
		/* 82171BF8h case   10:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82171BF8h case   10:*/		return 0x82171BFC;
		  /* 82171BFCh */ case   11:  		/* bc 12, CR0_EQ, 100 */
		/* 82171BFCh case   11:*/		if ( regs.CR[0].eq ) { return 0x82171C60;  }
		/* 82171BFCh case   11:*/		return 0x82171C00;
		  /* 82171C00h */ case   12:  		/* rlwinm R27, R5, 0, 24, 31 */
		/* 82171C00h case   12:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R27,regs.R5);
		/* 82171C00h case   12:*/		return 0x82171C04;
		  /* 82171C04h */ case   13:  		/* mr R4, R31 */
		/* 82171C04h case   13:*/		regs.R4 = regs.R31;
		/* 82171C04h case   13:*/		return 0x82171C08;
		  /* 82171C08h */ case   14:  		/* mr R3, R28 */
		/* 82171C08h case   14:*/		regs.R3 = regs.R28;
		/* 82171C08h case   14:*/		return 0x82171C0C;
		  /* 82171C0Ch */ case   15:  		/* bl -3196 */
		/* 82171C0Ch case   15:*/		regs.LR = 0x82171C10; return 0x82170F90;
		/* 82171C0Ch case   15:*/		return 0x82171C10;
		  /* 82171C10h */ case   16:  		/* cmplwi CR6, R27, 0 */
		/* 82171C10h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82171C10h case   16:*/		return 0x82171C14;
		  /* 82171C14h */ case   17:  		/* bc 12, CR6_EQ, 48 */
		/* 82171C14h case   17:*/		if ( regs.CR[6].eq ) { return 0x82171C44;  }
		/* 82171C14h case   17:*/		return 0x82171C18;
		  /* 82171C18h */ case   18:  		/* lwz R30, <#[R31]> */
		/* 82171C18h case   18:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 82171C18h case   18:*/		return 0x82171C1C;
		  /* 82171C1Ch */ case   19:  		/* cmplwi CR6, R30, 0 */
		/* 82171C1Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82171C1Ch case   19:*/		return 0x82171C20;
		  /* 82171C20h */ case   20:  		/* bc 12, CR6_EQ, 36 */
		/* 82171C20h case   20:*/		if ( regs.CR[6].eq ) { return 0x82171C44;  }
		/* 82171C20h case   20:*/		return 0x82171C24;
		  /* 82171C24h */ case   21:  		/* lwz R4, <#[R30 + 12]> */
		/* 82171C24h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82171C24h case   21:*/		return 0x82171C28;
		  /* 82171C28h */ case   22:  		/* lwz R11, <#[R4 + 28]> */
		/* 82171C28h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82171C28h case   22:*/		return 0x82171C2C;
		  /* 82171C2Ch */ case   23:  		/* cmplw CR6, R11, R29 */
		/* 82171C2Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82171C2Ch case   23:*/		return 0x82171C30;
		  /* 82171C30h */ case   24:  		/* bc 4, CR6_EQ, 12 */
		/* 82171C30h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82171C3C;  }
		/* 82171C30h case   24:*/		return 0x82171C34;
		  /* 82171C34h */ case   25:  		/* mr R3, R28 */
		/* 82171C34h case   25:*/		regs.R3 = regs.R28;
		/* 82171C34h case   25:*/		return 0x82171C38;
		  /* 82171C38h */ case   26:  		/* bl -3240 */
		/* 82171C38h case   26:*/		regs.LR = 0x82171C3C; return 0x82170F90;
		/* 82171C38h case   26:*/		return 0x82171C3C;
	}
	return 0x82171C3C;
} // Block from 82171BD0h-82171C3Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 82171C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171C3C);
		  /* 82171C3Ch */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82171C3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82171C3Ch case    0:*/		return 0x82171C40;
		  /* 82171C40h */ case    1:  		/* b -36 */
		/* 82171C40h case    1:*/		return 0x82171C1C;
		/* 82171C40h case    1:*/		return 0x82171C44;
	}
	return 0x82171C44;
} // Block from 82171C3Ch-82171C44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171C44);
		  /* 82171C44h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82171C44h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82171C44h case    0:*/		return 0x82171C48;
		  /* 82171C48h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82171C48h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82171C48h case    1:*/		return 0x82171C4C;
		  /* 82171C4Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82171C4Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82171C4Ch case    2:*/		return 0x82171C50;
		  /* 82171C50h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82171C50h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82171C60;  }
		/* 82171C50h case    3:*/		return 0x82171C54;
		  /* 82171C54h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82171C54h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82171C54h case    4:*/		return 0x82171C58;
		  /* 82171C58h */ case    5:  		/* addic. R31, R11, -40 */
		/* 82171C58h case    5:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82171C58h case    5:*/		return 0x82171C5C;
		  /* 82171C5Ch */ case    6:  		/* bc 4, CR0_EQ, -88 */
		/* 82171C5Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x82171C04;  }
		/* 82171C5Ch case    6:*/		return 0x82171C60;
	}
	return 0x82171C60;
} // Block from 82171C44h-82171C60h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82171C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171C60);
		  /* 82171C60h */ case    0:  		/* addi R1, R1, 128 */
		/* 82171C60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82171C60h case    0:*/		return 0x82171C64;
		  /* 82171C64h */ case    1:  		/* b -920000 */
		/* 82171C64h case    1:*/		return 0x820912A4;
		/* 82171C64h case    1:*/		return 0x82171C68;
	}
	return 0x82171C68;
} // Block from 82171C60h-82171C68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171C68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171C68);
		  /* 82171C68h */ case    0:  		/* mfspr R12, LR */
		/* 82171C68h case    0:*/		regs.R12 = regs.LR;
		/* 82171C68h case    0:*/		return 0x82171C6C;
		  /* 82171C6Ch */ case    1:  		/* bl -920096 */
		/* 82171C6Ch case    1:*/		regs.LR = 0x82171C70; return 0x8209124C;
		/* 82171C6Ch case    1:*/		return 0x82171C70;
		  /* 82171C70h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82171C70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82171C70h case    2:*/		return 0x82171C74;
		  /* 82171C74h */ case    3:  		/* lwz R11, <#[R4 + 28]> */
		/* 82171C74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82171C74h case    3:*/		return 0x82171C78;
		  /* 82171C78h */ case    4:  		/* mr R26, R3 */
		/* 82171C78h case    4:*/		regs.R26 = regs.R3;
		/* 82171C78h case    4:*/		return 0x82171C7C;
		  /* 82171C7Ch */ case    5:  		/* mr R25, R5 */
		/* 82171C7Ch case    5:*/		regs.R25 = regs.R5;
		/* 82171C7Ch case    5:*/		return 0x82171C80;
		  /* 82171C80h */ case    6:  		/* li R27, 0 */
		/* 82171C80h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82171C80h case    6:*/		return 0x82171C84;
		  /* 82171C84h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82171C84h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82171C84h case    7:*/		return 0x82171C88;
		  /* 82171C88h */ case    8:  		/* bc 4, CR0_EQ, 324 */
		/* 82171C88h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82171DCC;  }
		/* 82171C88h case    8:*/		return 0x82171C8C;
		  /* 82171C8Ch */ case    9:  		/* lwz R11, <#[R4 + 24]> */
		/* 82171C8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 82171C8Ch case    9:*/		return 0x82171C90;
		  /* 82171C90h */ case   10:  		/* b 304 */
		/* 82171C90h case   10:*/		return 0x82171DC0;
		/* 82171C90h case   10:*/		return 0x82171C94;
		  /* 82171C94h */ case   11:  		/* lwz R11, <#[R30 + 8]> */
		/* 82171C94h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82171C94h case   11:*/		return 0x82171C98;
		  /* 82171C98h */ case   12:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82171C98h case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82171C98h case   12:*/		return 0x82171C9C;
		  /* 82171C9Ch */ case   13:  		/* cmplwi CR6, R11, 126 */
		/* 82171C9Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007E);
		/* 82171C9Ch case   13:*/		return 0x82171CA0;
		  /* 82171CA0h */ case   14:  		/* bc 12, CR6_EQ, 272 */
		/* 82171CA0h case   14:*/		if ( regs.CR[6].eq ) { return 0x82171DB0;  }
		/* 82171CA0h case   14:*/		return 0x82171CA4;
		  /* 82171CA4h */ case   15:  		/* addi R28, R27, 1 */
		/* 82171CA4h case   15:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0x1);
		/* 82171CA4h case   15:*/		return 0x82171CA8;
		  /* 82171CA8h */ case   16:  		/* cmplwi CR6, R11, 32 */
		/* 82171CA8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82171CA8h case   16:*/		return 0x82171CAC;
		  /* 82171CACh */ case   17:  		/* bc 12, CR6_LT, 16 */
		/* 82171CACh case   17:*/		if ( regs.CR[6].lt ) { return 0x82171CBC;  }
		/* 82171CACh case   17:*/		return 0x82171CB0;
		  /* 82171CB0h */ case   18:  		/* cmplwi CR6, R11, 82 */
		/* 82171CB0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82171CB0h case   18:*/		return 0x82171CB4;
		  /* 82171CB4h */ case   19:  		/* li R11, 1 */
		/* 82171CB4h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82171CB4h case   19:*/		return 0x82171CB8;
		  /* 82171CB8h */ case   20:  		/* bc 4, CR6_GT, 8 */
		/* 82171CB8h case   20:*/		if ( !regs.CR[6].gt ) { return 0x82171CC0;  }
		/* 82171CB8h case   20:*/		return 0x82171CBC;
	}
	return 0x82171CBC;
} // Block from 82171C68h-82171CBCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 82171CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171CBC);
		  /* 82171CBCh */ case    0:  		/* li R11, 0 */
		/* 82171CBCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82171CBCh case    0:*/		return 0x82171CC0;
	}
	return 0x82171CC0;
} // Block from 82171CBCh-82171CC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171CC0);
		  /* 82171CC0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82171CC0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82171CC0h case    0:*/		return 0x82171CC4;
		  /* 82171CC4h */ case    1:  		/* bc 12, CR0_EQ, 208 */
		/* 82171CC4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82171D94;  }
		/* 82171CC4h case    1:*/		return 0x82171CC8;
		  /* 82171CC8h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82171CC8h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82171CC8h case    2:*/		return 0x82171CCC;
		  /* 82171CCCh */ case    3:  		/* lwz R11, <#[R11 + 36]> */
		/* 82171CCCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82171CCCh case    3:*/		return 0x82171CD0;
		  /* 82171CD0h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82171CD0h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82171CD0h case    4:*/		return 0x82171CD4;
		  /* 82171CD4h */ case    5:  		/* bc 4, CR0_EQ, 192 */
		/* 82171CD4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82171D94;  }
		/* 82171CD4h case    5:*/		return 0x82171CD8;
		  /* 82171CD8h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82171CD8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82171CD8h case    6:*/		return 0x82171CDC;
		  /* 82171CDCh */ case    7:  		/* addic. R31, R11, -40 */
		/* 82171CDCh case    7:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82171CDCh case    7:*/		return 0x82171CE0;
		  /* 82171CE0h */ case    8:  		/* bc 12, CR0_EQ, 180 */
		/* 82171CE0h case    8:*/		if ( regs.CR[0].eq ) { return 0x82171D94;  }
		/* 82171CE0h case    8:*/		return 0x82171CE4;
		  /* 82171CE4h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 82171CE4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82171CE4h case    9:*/		return 0x82171CE8;
		  /* 82171CE8h */ case   10:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82171CE8h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82171CE8h case   10:*/		return 0x82171CEC;
		  /* 82171CECh */ case   11:  		/* cmplwi CR6, R11, 1 */
		/* 82171CECh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82171CECh case   11:*/		return 0x82171CF0;
	}
	return 0x82171CF0;
} // Block from 82171CC0h-82171CF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82171CF0h
// Function '?CopyFrom@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAXPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171CF0);
		  /* 82171CF0h */ case    0:  		/* bc 12, CR6_LT, 16 */
		/* 82171CF0h case    0:*/		if ( regs.CR[6].lt ) { return 0x82171D00;  }
		/* 82171CF0h case    0:*/		return 0x82171CF4;
		  /* 82171CF4h */ case    1:  		/* cmplwi CR6, R11, 31 */
		/* 82171CF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82171CF4h case    1:*/		return 0x82171CF8;
		  /* 82171CF8h */ case    2:  		/* li R11, 1 */
		/* 82171CF8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82171CF8h case    2:*/		return 0x82171CFC;
		  /* 82171CFCh */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 82171CFCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x82171D04;  }
		/* 82171CFCh case    3:*/		return 0x82171D00;
	}
	return 0x82171D00;
} // Block from 82171CF0h-82171D00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82171D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D00);
		  /* 82171D00h */ case    0:  		/* li R11, 0 */
		/* 82171D00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82171D00h case    0:*/		return 0x82171D04;
	}
	return 0x82171D04;
} // Block from 82171D00h-82171D04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D04);
		  /* 82171D04h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82171D04h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82171D04h case    0:*/		return 0x82171D08;
		  /* 82171D08h */ case    1:  		/* bc 12, CR0_EQ, 140 */
		/* 82171D08h case    1:*/		if ( regs.CR[0].eq ) { return 0x82171D94;  }
		/* 82171D08h case    1:*/		return 0x82171D0C;
		  /* 82171D0Ch */ case    2:  		/* mr R3, R31 */
		/* 82171D0Ch case    2:*/		regs.R3 = regs.R31;
		/* 82171D0Ch case    2:*/		return 0x82171D10;
		  /* 82171D10h */ case    3:  		/* li R29, 0 */
		/* 82171D10h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82171D10h case    3:*/		return 0x82171D14;
		  /* 82171D14h */ case    4:  		/* bl -53156 */
		/* 82171D14h case    4:*/		regs.LR = 0x82171D18; return 0x82164D70;
		/* 82171D14h case    4:*/		return 0x82171D18;
		  /* 82171D18h */ case    5:  		/* cmplw CR6, R30, R3 */
		/* 82171D18h case    5:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R3);
		/* 82171D18h case    5:*/		return 0x82171D1C;
		  /* 82171D1Ch */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 82171D1Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82171D28;  }
		/* 82171D1Ch case    6:*/		return 0x82171D20;
		  /* 82171D20h */ case    7:  		/* li R29, 1 */
		/* 82171D20h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82171D20h case    7:*/		return 0x82171D24;
		  /* 82171D24h */ case    8:  		/* b 100 */
		/* 82171D24h case    8:*/		return 0x82171D88;
		/* 82171D24h case    8:*/		return 0x82171D28;
	}
	return 0x82171D28;
} // Block from 82171D04h-82171D28h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82171D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D28);
		  /* 82171D28h */ case    0:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 82171D28h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 82171D28h case    0:*/		return 0x82171D2C;
		  /* 82171D2Ch */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 82171D2Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82171D88;  }
		/* 82171D2Ch case    1:*/		return 0x82171D30;
		  /* 82171D30h */ case    2:  		/* mr R3, R31 */
		/* 82171D30h case    2:*/		regs.R3 = regs.R31;
		/* 82171D30h case    2:*/		return 0x82171D34;
		  /* 82171D34h */ case    3:  		/* bl 121740 */
		/* 82171D34h case    3:*/		regs.LR = 0x82171D38; return 0x8218F8C0;
		/* 82171D34h case    3:*/		return 0x82171D38;
		  /* 82171D38h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82171D38h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82171D38h case    4:*/		return 0x82171D3C;
		  /* 82171D3Ch */ case    5:  		/* bc 12, CR0_EQ, 76 */
		/* 82171D3Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82171D88;  }
		/* 82171D3Ch case    5:*/		return 0x82171D40;
		  /* 82171D40h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 82171D40h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82171D40h case    6:*/		return 0x82171D44;
		  /* 82171D44h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82171D44h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82171D44h case    7:*/		return 0x82171D48;
		  /* 82171D48h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 82171D48h case    8:*/		if ( regs.CR[6].eq ) { return 0x82171D68;  }
		/* 82171D48h case    8:*/		return 0x82171D4C;
		  /* 82171D4Ch */ case    9:  		/* lwz R10, <#[R11 + 12]> */
		/* 82171D4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82171D4Ch case    9:*/		return 0x82171D50;
		  /* 82171D50h */ case   10:  		/* cmplw CR6, R10, R31 */
		/* 82171D50h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82171D50h case   10:*/		return 0x82171D54;
		  /* 82171D54h */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 82171D54h case   11:*/		if ( regs.CR[6].eq ) { return 0x82171D60;  }
		/* 82171D54h case   11:*/		return 0x82171D58;
		  /* 82171D58h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 82171D58h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82171D58h case   12:*/		return 0x82171D5C;
		  /* 82171D5Ch */ case   13:  		/* b -24 */
		/* 82171D5Ch case   13:*/		return 0x82171D44;
		/* 82171D5Ch case   13:*/		return 0x82171D60;
	}
	return 0x82171D60;
} // Block from 82171D28h-82171D60h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82171D60h
// Function '?GetBitRange@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D60);
		  /* 82171D60h */ case    0:  		/* li R11, 1 */
		/* 82171D60h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82171D60h case    0:*/		return 0x82171D64;
		  /* 82171D64h */ case    1:  		/* b 8 */
		/* 82171D64h case    1:*/		return 0x82171D6C;
		/* 82171D64h case    1:*/		return 0x82171D68;
	}
	return 0x82171D68;
} // Block from 82171D60h-82171D68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D68);
		  /* 82171D68h */ case    0:  		/* li R11, 0 */
		/* 82171D68h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82171D68h case    0:*/		return 0x82171D6C;
	}
	return 0x82171D6C;
} // Block from 82171D68h-82171D6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D6C);
		  /* 82171D6Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82171D6Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82171D6Ch case    0:*/		return 0x82171D70;
		  /* 82171D70h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 82171D70h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82171D88;  }
		/* 82171D70h case    1:*/		return 0x82171D74;
		  /* 82171D74h */ case    2:  		/* mr R5, R30 */
		/* 82171D74h case    2:*/		regs.R5 = regs.R30;
		/* 82171D74h case    2:*/		return 0x82171D78;
		  /* 82171D78h */ case    3:  		/* mr R4, R31 */
		/* 82171D78h case    3:*/		regs.R4 = regs.R31;
		/* 82171D78h case    3:*/		return 0x82171D7C;
		  /* 82171D7Ch */ case    4:  		/* mr R3, R26 */
		/* 82171D7Ch case    4:*/		regs.R3 = regs.R26;
		/* 82171D7Ch case    4:*/		return 0x82171D80;
		  /* 82171D80h */ case    5:  		/* bl 122712 */
		/* 82171D80h case    5:*/		regs.LR = 0x82171D84; return 0x8218FCD8;
		/* 82171D80h case    5:*/		return 0x82171D84;
		  /* 82171D84h */ case    6:  		/* mr R29, R3 */
		/* 82171D84h case    6:*/		regs.R29 = regs.R3;
		/* 82171D84h case    6:*/		return 0x82171D88;
	}
	return 0x82171D88;
} // Block from 82171D6Ch-82171D88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82171D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D88);
		  /* 82171D88h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82171D88h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82171D88h case    0:*/		return 0x82171D8C;
		  /* 82171D8Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82171D8Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82171D94;  }
		/* 82171D8Ch case    1:*/		return 0x82171D90;
		  /* 82171D90h */ case    2:  		/* mr R28, R27 */
		/* 82171D90h case    2:*/		regs.R28 = regs.R27;
		/* 82171D90h case    2:*/		return 0x82171D94;
	}
	return 0x82171D94;
} // Block from 82171D88h-82171D94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171D94);
		  /* 82171D94h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 82171D94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82171D94h case    0:*/		return 0x82171D98;
		  /* 82171D98h */ case    1:  		/* lwz R10, <#[R30 + 20]> */
		/* 82171D98h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 82171D98h case    1:*/		return 0x82171D9C;
		  /* 82171D9Ch */ case    2:  		/* oris R11, R11, 256 */
		/* 82171D9Ch case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82171D9Ch case    2:*/		return 0x82171DA0;
		  /* 82171DA0h */ case    3:  		/* rlwimi R10, R27, 0, 19, 31 */
		/* 82171DA0h case    3:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R10,regs.R27);
		/* 82171DA0h case    3:*/		return 0x82171DA4;
		  /* 82171DA4h */ case    4:  		/* stw R11, <#[R30 + 16]> */
		/* 82171DA4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82171DA4h case    4:*/		return 0x82171DA8;
		  /* 82171DA8h */ case    5:  		/* mr R27, R28 */
		/* 82171DA8h case    5:*/		regs.R27 = regs.R28;
		/* 82171DA8h case    5:*/		return 0x82171DAC;
		  /* 82171DACh */ case    6:  		/* stw R10, <#[R30 + 20]> */
		/* 82171DACh case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 82171DACh case    6:*/		return 0x82171DB0;
	}
	return 0x82171DB0;
} // Block from 82171D94h-82171DB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82171DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171DB0);
		  /* 82171DB0h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82171DB0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82171DB0h case    0:*/		return 0x82171DB4;
		  /* 82171DB4h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82171DB4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82171DB4h case    1:*/		return 0x82171DB8;
		  /* 82171DB8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82171DB8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82171DB8h case    2:*/		return 0x82171DBC;
		  /* 82171DBCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82171DBCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82171DCC;  }
		/* 82171DBCh case    3:*/		return 0x82171DC0;
	}
	return 0x82171DC0;
} // Block from 82171DB0h-82171DC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82171DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171DC0);
		  /* 82171DC0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82171DC0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82171DC0h case    0:*/		return 0x82171DC4;
		  /* 82171DC4h */ case    1:  		/* addic. R30, R11, -40 */
		/* 82171DC4h case    1:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 82171DC4h case    1:*/		return 0x82171DC8;
		  /* 82171DC8h */ case    2:  		/* bc 4, CR0_EQ, -308 */
		/* 82171DC8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82171C94;  }
		/* 82171DC8h case    2:*/		return 0x82171DCC;
	}
	return 0x82171DCC;
} // Block from 82171DC0h-82171DCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171DCC);
		  /* 82171DCCh */ case    0:  		/* addi R1, R1, 144 */
		/* 82171DCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82171DCCh case    0:*/		return 0x82171DD0;
		  /* 82171DD0h */ case    1:  		/* b -920372 */
		/* 82171DD0h case    1:*/		return 0x8209129C;
		/* 82171DD0h case    1:*/		return 0x82171DD4;
		  /* 82171DD4h */ case    2:  		/* nop */
		/* 82171DD4h case    2:*/		cpu::op::nop();
		/* 82171DD4h case    2:*/		return 0x82171DD8;
	}
	return 0x82171DD8;
} // Block from 82171DCCh-82171DD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171DD8);
		  /* 82171DD8h */ case    0:  		/* mfspr R12, LR */
		/* 82171DD8h case    0:*/		regs.R12 = regs.LR;
		/* 82171DD8h case    0:*/		return 0x82171DDC;
		  /* 82171DDCh */ case    1:  		/* bl -920468 */
		/* 82171DDCh case    1:*/		regs.LR = 0x82171DE0; return 0x82091248;
		/* 82171DDCh case    1:*/		return 0x82171DE0;
		  /* 82171DE0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82171DE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82171DE0h case    2:*/		return 0x82171DE4;
		  /* 82171DE4h */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 82171DE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82171DE4h case    3:*/		return 0x82171DE8;
		  /* 82171DE8h */ case    4:  		/* mr R24, R3 */
		/* 82171DE8h case    4:*/		regs.R24 = regs.R3;
		/* 82171DE8h case    4:*/		return 0x82171DEC;
		  /* 82171DECh */ case    5:  		/* mr R27, R4 */
		/* 82171DECh case    5:*/		regs.R27 = regs.R4;
		/* 82171DECh case    5:*/		return 0x82171DF0;
	}
	return 0x82171DF0;
} // Block from 82171DD8h-82171DF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82171DF0h
// Function '?AddBitMask@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAXIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171DF0);
		  /* 82171DF0h */ case    0:  		/* mr R10, R11 */
		/* 82171DF0h case    0:*/		regs.R10 = regs.R11;
		/* 82171DF0h case    0:*/		return 0x82171DF4;
		  /* 82171DF4h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82171DF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82171DF4h case    1:*/		return 0x82171DF8;
		  /* 82171DF8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 82171DF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82171E1C;  }
		/* 82171DF8h case    2:*/		return 0x82171DFC;
		  /* 82171DFCh */ case    3:  		/* lwz R9, <#[R10]> */
		/* 82171DFCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82171DFCh case    3:*/		return 0x82171E00;
		  /* 82171E00h */ case    4:  		/* rlwinm. R8, R9, 0, 4, 6 */
		/* 82171E00h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R9);
		/* 82171E00h case    4:*/		return 0x82171E04;
		  /* 82171E04h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82171E04h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82171E10;  }
		/* 82171E04h case    5:*/		return 0x82171E08;
		  /* 82171E08h */ case    6:  		/* lwz R10, <#[R10 + 8]> */
		/* 82171E08h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82171E08h case    6:*/		return 0x82171E0C;
		  /* 82171E0Ch */ case    7:  		/* b -24 */
		/* 82171E0Ch case    7:*/		return 0x82171DF4;
		/* 82171E0Ch case    7:*/		return 0x82171E10;
	}
	return 0x82171E10;
} // Block from 82171DF0h-82171E10h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82171E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171E10);
		  /* 82171E10h */ case    0:  		/* rlwinm. R10, R9, 2, 31, 31 */
		/* 82171E10h case    0:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R9);
		/* 82171E10h case    0:*/		return 0x82171E14;
		  /* 82171E14h */ case    1:  		/* li R10, 1 */
		/* 82171E14h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82171E14h case    1:*/		return 0x82171E18;
		  /* 82171E18h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82171E18h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82171E20;  }
		/* 82171E18h case    2:*/		return 0x82171E1C;
	}
	return 0x82171E1C;
} // Block from 82171E10h-82171E1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171E1C);
		  /* 82171E1Ch */ case    0:  		/* li R10, 0 */
		/* 82171E1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82171E1Ch case    0:*/		return 0x82171E20;
	}
	return 0x82171E20;
} // Block from 82171E1Ch-82171E20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171E20);
		  /* 82171E20h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82171E20h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82171E20h case    0:*/		return 0x82171E24;
		  /* 82171E24h */ case    1:  		/* bc 12, CR0_EQ, 512 */
		/* 82171E24h case    1:*/		if ( regs.CR[0].eq ) { return 0x82172024;  }
		/* 82171E24h case    1:*/		return 0x82171E28;
		  /* 82171E28h */ case    2:  		/* lwz R25, <#[R27 + 28]> */
		/* 82171E28h case    2:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R27 + 0x0000001C) );
		/* 82171E28h case    2:*/		return 0x82171E2C;
		  /* 82171E2Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82171E2Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82171E2Ch case    3:*/		return 0x82171E30;
		  /* 82171E30h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82171E30h case    4:*/		if ( regs.CR[6].eq ) { return 0x82171E48;  }
		/* 82171E30h case    4:*/		return 0x82171E34;
		  /* 82171E34h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 82171E34h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82171E34h case    5:*/		return 0x82171E38;
		  /* 82171E38h */ case    6:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82171E38h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82171E38h case    6:*/		return 0x82171E3C;
		  /* 82171E3Ch */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 82171E3Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82171E48;  }
		/* 82171E3Ch case    7:*/		return 0x82171E40;
		  /* 82171E40h */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 82171E40h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82171E40h case    8:*/		return 0x82171E44;
		  /* 82171E44h */ case    9:  		/* b -24 */
		/* 82171E44h case    9:*/		return 0x82171E2C;
		/* 82171E44h case    9:*/		return 0x82171E48;
	}
	return 0x82171E48;
} // Block from 82171E20h-82171E48h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82171E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171E48);
		  /* 82171E48h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82171E48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82171E48h case    0:*/		return 0x82171E4C;
		  /* 82171E4Ch */ case    1:  		/* rlwinm R10, R27, 0, 0, 30 */
		/* 82171E4Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R27);
		/* 82171E4Ch case    1:*/		return 0x82171E50;
		  /* 82171E50h */ case    2:  		/* lwz R9, <#[R27 + 8]> */
		/* 82171E50h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000008) );
		/* 82171E50h case    2:*/		return 0x82171E54;
		  /* 82171E54h */ case    3:  		/* rlwimi R9, R11, 20, 19, 26 */
		/* 82171E54h case    3:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R9,regs.R11);
		/* 82171E54h case    3:*/		return 0x82171E58;
		  /* 82171E58h */ case    4:  		/* lwz R11, <#[R10 + 36]> */
		/* 82171E58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000024) );
		/* 82171E58h case    4:*/		return 0x82171E5C;
		  /* 82171E5Ch */ case    5:  		/* rlwinm R26, R9, 31, 20, 31 */
		/* 82171E5Ch case    5:*/		cpu::op::rlwinm<0,31,20,31>(regs,&regs.R26,regs.R9);
		/* 82171E5Ch case    5:*/		return 0x82171E60;
	}
	return 0x82171E60;
} // Block from 82171E48h-82171E60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82171E60h
// Function '?SubtractBitMask@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAXIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171E60);
		  /* 82171E60h */ case    0:  		/* b 148 */
		/* 82171E60h case    0:*/		return 0x82171EF4;
		/* 82171E60h case    0:*/		return 0x82171E64;
		  /* 82171E64h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 82171E64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82171E64h case    1:*/		return 0x82171E68;
		  /* 82171E68h */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82171E68h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82171E68h case    2:*/		return 0x82171E6C;
		  /* 82171E6Ch */ case    3:  		/* cmplwi CR6, R11, 14080 */
		/* 82171E6Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82171E6Ch case    3:*/		return 0x82171E70;
		  /* 82171E70h */ case    4:  		/* bc 12, CR6_EQ, 124 */
		/* 82171E70h case    4:*/		if ( regs.CR[6].eq ) { return 0x82171EEC;  }
		/* 82171E70h case    4:*/		return 0x82171E74;
		  /* 82171E74h */ case    5:  		/* li R29, 0 */
		/* 82171E74h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82171E74h case    5:*/		return 0x82171E78;
		  /* 82171E78h */ case    6:  		/* addi R28, R31, 44 */
		/* 82171E78h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x2C);
		/* 82171E78h case    6:*/		return 0x82171E7C;
		  /* 82171E7Ch */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 82171E7Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82171E7Ch case    7:*/		return 0x82171E80;
		  /* 82171E80h */ case    8:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 82171E80h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82171E80h case    8:*/		return 0x82171E84;
		  /* 82171E84h */ case    9:  		/* cmplw CR6, R29, R11 */
		/* 82171E84h case    9:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82171E84h case    9:*/		return 0x82171E88;
		  /* 82171E88h */ case   10:  		/* bc 4, CR6_LT, 100 */
		/* 82171E88h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82171EEC;  }
		/* 82171E88h case   10:*/		return 0x82171E8C;
		  /* 82171E8Ch */ case   11:  		/* lwz R30, <#[R28]> */
		/* 82171E8Ch case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 82171E8Ch case   11:*/		return 0x82171E90;
		  /* 82171E90h */ case   12:  		/* mr R3, R30 */
		/* 82171E90h case   12:*/		regs.R3 = regs.R30;
		/* 82171E90h case   12:*/		return 0x82171E94;
		  /* 82171E94h */ case   13:  		/* bl -54884 */
		/* 82171E94h case   13:*/		regs.LR = 0x82171E98; return 0x82164830;
		/* 82171E94h case   13:*/		return 0x82171E98;
		  /* 82171E98h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82171E98h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82171E98h case   14:*/		return 0x82171E9C;
		  /* 82171E9Ch */ case   15:  		/* bc 12, CR0_EQ, 68 */
		/* 82171E9Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x82171EE0;  }
		/* 82171E9Ch case   15:*/		return 0x82171EA0;
		  /* 82171EA0h */ case   16:  		/* lwz R11, <#[R30 + 12]> */
		/* 82171EA0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82171EA0h case   16:*/		return 0x82171EA4;
		  /* 82171EA4h */ case   17:  		/* lwz R11, <#[R11 + 8]> */
		/* 82171EA4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82171EA4h case   17:*/		return 0x82171EA8;
		  /* 82171EA8h */ case   18:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82171EA8h case   18:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82171EA8h case   18:*/		return 0x82171EAC;
		  /* 82171EACh */ case   19:  		/* bc 12, CR0_EQ, 52 */
		/* 82171EACh case   19:*/		if ( regs.CR[0].eq ) { return 0x82171EE0;  }
		/* 82171EACh case   19:*/		return 0x82171EB0;
		  /* 82171EB0h */ case   20:  		/* lwz R11, <#[R30]> */
		/* 82171EB0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82171EB0h case   20:*/		return 0x82171EB4;
		  /* 82171EB4h */ case   21:  		/* rlwinm R11, R11, 19, 20, 31 */
		/* 82171EB4h case   21:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R11);
		/* 82171EB4h case   21:*/		return 0x82171EB8;
		  /* 82171EB8h */ case   22:  		/* xor R10, R11, R26 */
		/* 82171EB8h case   22:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 82171EB8h case   22:*/		return 0x82171EBC;
		  /* 82171EBCh */ case   23:  		/* rlwinm. R10, R10, 0, 0, 27 */
		/* 82171EBCh case   23:*/		cpu::op::rlwinm<1,0,0,27>(regs,&regs.R10,regs.R10);
		/* 82171EBCh case   23:*/		return 0x82171EC0;
		  /* 82171EC0h */ case   24:  		/* bc 4, CR0_EQ, 32 */
		/* 82171EC0h case   24:*/		if ( !regs.CR[0].eq ) { return 0x82171EE0;  }
		/* 82171EC0h case   24:*/		return 0x82171EC4;
		  /* 82171EC4h */ case   25:  		/* and R11, R11, R26 */
		/* 82171EC4h case   25:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 82171EC4h case   25:*/		return 0x82171EC8;
		  /* 82171EC8h */ case   26:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 82171EC8h case   26:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82171EC8h case   26:*/		return 0x82171ECC;
		  /* 82171ECCh */ case   27:  		/* bc 12, CR0_EQ, 20 */
		/* 82171ECCh case   27:*/		if ( regs.CR[0].eq ) { return 0x82171EE0;  }
		/* 82171ECCh case   27:*/		return 0x82171ED0;
	}
	return 0x82171ED0;
} // Block from 82171E60h-82171ED0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82171ED0h
// Function '?FindNibbleWithClearBit@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAIIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171ED0);
		  /* 82171ED0h */ case    0:  		/* mr R5, R24 */
		/* 82171ED0h case    0:*/		regs.R5 = regs.R24;
		/* 82171ED0h case    0:*/		return 0x82171ED4;
		  /* 82171ED4h */ case    1:  		/* mr R4, R31 */
		/* 82171ED4h case    1:*/		regs.R4 = regs.R31;
		/* 82171ED4h case    1:*/		return 0x82171ED8;
		  /* 82171ED8h */ case    2:  		/* mr R3, R27 */
		/* 82171ED8h case    2:*/		regs.R3 = regs.R27;
		/* 82171ED8h case    2:*/		return 0x82171EDC;
		  /* 82171EDCh */ case    3:  		/* bl 25524 */
		/* 82171EDCh case    3:*/		regs.LR = 0x82171EE0; return 0x82178290;
		/* 82171EDCh case    3:*/		return 0x82171EE0;
	}
	return 0x82171EE0;
} // Block from 82171ED0h-82171EE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82171EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171EE0);
		  /* 82171EE0h */ case    0:  		/* addi R29, R29, 1 */
		/* 82171EE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82171EE0h case    0:*/		return 0x82171EE4;
		  /* 82171EE4h */ case    1:  		/* addi R28, R28, 4 */
		/* 82171EE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82171EE4h case    1:*/		return 0x82171EE8;
		  /* 82171EE8h */ case    2:  		/* b -108 */
		/* 82171EE8h case    2:*/		return 0x82171E7C;
		/* 82171EE8h case    2:*/		return 0x82171EEC;
	}
	return 0x82171EEC;
} // Block from 82171EE0h-82171EECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171EEC);
		  /* 82171EECh */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82171EECh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82171EECh case    0:*/		return 0x82171EF0;
		  /* 82171EF0h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82171EF0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82171EF0h case    1:*/		return 0x82171EF4;
	}
	return 0x82171EF4;
} // Block from 82171EECh-82171EF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82171EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171EF4);
		  /* 82171EF4h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82171EF4h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82171EF4h case    0:*/		return 0x82171EF8;
		  /* 82171EF8h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82171EF8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82171F08;  }
		/* 82171EF8h case    1:*/		return 0x82171EFC;
		  /* 82171EFCh */ case    2:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82171EFCh case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82171EFCh case    2:*/		return 0x82171F00;
		  /* 82171F00h */ case    3:  		/* addic. R31, R11, -40 */
		/* 82171F00h case    3:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82171F00h case    3:*/		return 0x82171F04;
		  /* 82171F04h */ case    4:  		/* bc 4, CR0_EQ, -160 */
		/* 82171F04h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82171E64;  }
		/* 82171F04h case    4:*/		return 0x82171F08;
	}
	return 0x82171F08;
} // Block from 82171EF4h-82171F08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82171F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171F08);
		  /* 82171F08h */ case    0:  		/* lwz R29, <#[R27 + 4]> */
		/* 82171F08h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000004) );
		/* 82171F08h case    0:*/		return 0x82171F0C;
		  /* 82171F0Ch */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 82171F0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82171F0Ch case    1:*/		return 0x82171F10;
		  /* 82171F10h */ case    2:  		/* bc 12, CR6_EQ, 276 */
		/* 82171F10h case    2:*/		if ( regs.CR[6].eq ) { return 0x82172024;  }
		/* 82171F10h case    2:*/		return 0x82171F14;
		  /* 82171F14h */ case    3:  		/* lwz R30, <#[R29 + 16]> */
		/* 82171F14h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000010) );
		/* 82171F14h case    3:*/		return 0x82171F18;
		  /* 82171F18h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82171F18h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82171F18h case    4:*/		return 0x82171F1C;
		  /* 82171F1Ch */ case    5:  		/* bc 12, CR6_EQ, 256 */
		/* 82171F1Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8217201C;  }
		/* 82171F1Ch case    5:*/		return 0x82171F20;
		  /* 82171F20h */ case    6:  		/* mr R3, R29 */
		/* 82171F20h case    6:*/		regs.R3 = regs.R29;
		/* 82171F20h case    6:*/		return 0x82171F24;
		  /* 82171F24h */ case    7:  		/* bl -55028 */
		/* 82171F24h case    7:*/		regs.LR = 0x82171F28; return 0x82164830;
		/* 82171F24h case    7:*/		return 0x82171F28;
		  /* 82171F28h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82171F28h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82171F28h case    8:*/		return 0x82171F2C;
		  /* 82171F2Ch */ case    9:  		/* bc 12, CR0_EQ, 240 */
		/* 82171F2Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8217201C;  }
		/* 82171F2Ch case    9:*/		return 0x82171F30;
		  /* 82171F30h */ case   10:  		/* lwz R11, <#[R30 + 28]> */
		/* 82171F30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82171F30h case   10:*/		return 0x82171F34;
		  /* 82171F34h */ case   11:  		/* cmplw CR6, R11, R25 */
		/* 82171F34h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 82171F34h case   11:*/		return 0x82171F38;
		  /* 82171F38h */ case   12:  		/* bc 4, CR6_EQ, 228 */
		/* 82171F38h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8217201C;  }
		/* 82171F38h case   12:*/		return 0x82171F3C;
		  /* 82171F3Ch */ case   13:  		/* lwz R11, <#[R30 + 8]> */
		/* 82171F3Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82171F3Ch case   13:*/		return 0x82171F40;
		  /* 82171F40h */ case   14:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82171F40h case   14:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82171F40h case   14:*/		return 0x82171F44;
		  /* 82171F44h */ case   15:  		/* cmplwi CR6, R11, 112 */
		/* 82171F44h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 82171F44h case   15:*/		return 0x82171F48;
		  /* 82171F48h */ case   16:  		/* bc 12, CR6_EQ, 212 */
		/* 82171F48h case   16:*/		if ( regs.CR[6].eq ) { return 0x8217201C;  }
		/* 82171F48h case   16:*/		return 0x82171F4C;
		  /* 82171F4Ch */ case   17:  		/* cmplwi CR6, R11, 110 */
		/* 82171F4Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 82171F4Ch case   17:*/		return 0x82171F50;
		  /* 82171F50h */ case   18:  		/* bc 12, CR6_EQ, 204 */
		/* 82171F50h case   18:*/		if ( regs.CR[6].eq ) { return 0x8217201C;  }
		/* 82171F50h case   18:*/		return 0x82171F54;
		  /* 82171F54h */ case   19:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82171F54h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82171F54h case   19:*/		return 0x82171F58;
		  /* 82171F58h */ case   20:  		/* b 172 */
		/* 82171F58h case   20:*/		return 0x82172004;
		/* 82171F58h case   20:*/		return 0x82171F5C;
		  /* 82171F5Ch */ case   21:  		/* lwz R8, <#[R31 + 8]> */
		/* 82171F5Ch case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82171F5Ch case   21:*/		return 0x82171F60;
		  /* 82171F60h */ case   22:  		/* rlwinm. R11, R8, 9, 31, 31 */
		/* 82171F60h case   22:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R8);
		/* 82171F60h case   22:*/		return 0x82171F64;
		  /* 82171F64h */ case   23:  		/* bc 12, CR0_EQ, 156 */
		/* 82171F64h case   23:*/		if ( regs.CR[0].eq ) { return 0x82172000;  }
		/* 82171F64h case   23:*/		return 0x82171F68;
		  /* 82171F68h */ case   24:  		/* rlwinm R11, R8, 0, 18, 24 */
		/* 82171F68h case   24:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R8);
		/* 82171F68h case   24:*/		return 0x82171F6C;
		  /* 82171F6Ch */ case   25:  		/* cmplwi CR6, R11, 14080 */
		/* 82171F6Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82171F6Ch case   25:*/		return 0x82171F70;
		  /* 82171F70h */ case   26:  		/* bc 12, CR6_EQ, 144 */
		/* 82171F70h case   26:*/		if ( regs.CR[6].eq ) { return 0x82172000;  }
		/* 82171F70h case   26:*/		return 0x82171F74;
		  /* 82171F74h */ case   27:  		/* lwz R11, <#[R31 + 4]> */
		/* 82171F74h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82171F74h case   27:*/		return 0x82171F78;
		  /* 82171F78h */ case   28:  		/* mr R10, R11 */
		/* 82171F78h case   28:*/		regs.R10 = regs.R11;
		/* 82171F78h case   28:*/		return 0x82171F7C;
		  /* 82171F7Ch */ case   29:  		/* cmplwi CR6, R10, 0 */
		/* 82171F7Ch case   29:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82171F7Ch case   29:*/		return 0x82171F80;
		  /* 82171F80h */ case   30:  		/* bc 12, CR6_EQ, 36 */
		/* 82171F80h case   30:*/		if ( regs.CR[6].eq ) { return 0x82171FA4;  }
		/* 82171F80h case   30:*/		return 0x82171F84;
		  /* 82171F84h */ case   31:  		/* lwz R9, <#[R10]> */
		/* 82171F84h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82171F84h case   31:*/		return 0x82171F88;
		  /* 82171F88h */ case   32:  		/* rlwinm. R7, R9, 0, 4, 6 */
		/* 82171F88h case   32:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R7,regs.R9);
		/* 82171F88h case   32:*/		return 0x82171F8C;
		  /* 82171F8Ch */ case   33:  		/* bc 4, CR0_EQ, 12 */
		/* 82171F8Ch case   33:*/		if ( !regs.CR[0].eq ) { return 0x82171F98;  }
		/* 82171F8Ch case   33:*/		return 0x82171F90;
		  /* 82171F90h */ case   34:  		/* lwz R10, <#[R10 + 8]> */
		/* 82171F90h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82171F90h case   34:*/		return 0x82171F94;
		  /* 82171F94h */ case   35:  		/* b -24 */
		/* 82171F94h case   35:*/		return 0x82171F7C;
		/* 82171F94h case   35:*/		return 0x82171F98;
	}
	return 0x82171F98;
} // Block from 82171F08h-82171F98h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82171F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171F98);
		  /* 82171F98h */ case    0:  		/* rlwinm. R10, R9, 2, 31, 31 */
		/* 82171F98h case    0:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R9);
		/* 82171F98h case    0:*/		return 0x82171F9C;
		  /* 82171F9Ch */ case    1:  		/* li R10, 1 */
		/* 82171F9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82171F9Ch case    1:*/		return 0x82171FA0;
		  /* 82171FA0h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82171FA0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82171FA8;  }
		/* 82171FA0h case    2:*/		return 0x82171FA4;
	}
	return 0x82171FA4;
} // Block from 82171F98h-82171FA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82171FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171FA4);
		  /* 82171FA4h */ case    0:  		/* li R10, 0 */
		/* 82171FA4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82171FA4h case    0:*/		return 0x82171FA8;
	}
	return 0x82171FA8;
} // Block from 82171FA4h-82171FA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171FA8);
		  /* 82171FA8h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82171FA8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82171FA8h case    0:*/		return 0x82171FAC;
		  /* 82171FACh */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 82171FACh case    1:*/		if ( regs.CR[0].eq ) { return 0x82172000;  }
		/* 82171FACh case    1:*/		return 0x82171FB0;
		  /* 82171FB0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82171FB0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82171FB0h case    2:*/		return 0x82171FB4;
		  /* 82171FB4h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82171FB4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82171FCC;  }
		/* 82171FB4h case    3:*/		return 0x82171FB8;
		  /* 82171FB8h */ case    4:  		/* lwz R10, <#[R11]> */
		/* 82171FB8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82171FB8h case    4:*/		return 0x82171FBC;
		  /* 82171FBCh */ case    5:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82171FBCh case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82171FBCh case    5:*/		return 0x82171FC0;
		  /* 82171FC0h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82171FC0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82171FCC;  }
		/* 82171FC0h case    6:*/		return 0x82171FC4;
		  /* 82171FC4h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 82171FC4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82171FC4h case    7:*/		return 0x82171FC8;
	}
	return 0x82171FC8;
} // Block from 82171FA8h-82171FC8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82171FC8h
// Function '?FindLastNibbleWithClearBit@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAIIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171FC8);
		  /* 82171FC8h */ case    0:  		/* b -24 */
		/* 82171FC8h case    0:*/		return 0x82171FB0;
		/* 82171FC8h case    0:*/		return 0x82171FCC;
	}
	return 0x82171FCC;
} // Block from 82171FC8h-82171FCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82171FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82171FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82171FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82171FCC);
		  /* 82171FCCh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82171FCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82171FCCh case    0:*/		return 0x82171FD0;
		  /* 82171FD0h */ case    1:  		/* rlwimi R8, R11, 20, 19, 26 */
		/* 82171FD0h case    1:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R8,regs.R11);
		/* 82171FD0h case    1:*/		return 0x82171FD4;
		  /* 82171FD4h */ case    2:  		/* rlwinm R11, R8, 31, 20, 31 */
		/* 82171FD4h case    2:*/		cpu::op::rlwinm<0,31,20,31>(regs,&regs.R11,regs.R8);
		/* 82171FD4h case    2:*/		return 0x82171FD8;
		  /* 82171FD8h */ case    3:  		/* xor R10, R11, R26 */
		/* 82171FD8h case    3:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 82171FD8h case    3:*/		return 0x82171FDC;
		  /* 82171FDCh */ case    4:  		/* rlwinm. R10, R10, 0, 0, 27 */
		/* 82171FDCh case    4:*/		cpu::op::rlwinm<1,0,0,27>(regs,&regs.R10,regs.R10);
		/* 82171FDCh case    4:*/		return 0x82171FE0;
		  /* 82171FE0h */ case    5:  		/* bc 4, CR0_EQ, 32 */
		/* 82171FE0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82172000;  }
		/* 82171FE0h case    5:*/		return 0x82171FE4;
		  /* 82171FE4h */ case    6:  		/* and R11, R11, R26 */
		/* 82171FE4h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 82171FE4h case    6:*/		return 0x82171FE8;
		  /* 82171FE8h */ case    7:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 82171FE8h case    7:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82171FE8h case    7:*/		return 0x82171FEC;
		  /* 82171FECh */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 82171FECh case    8:*/		if ( regs.CR[0].eq ) { return 0x82172000;  }
		/* 82171FECh case    8:*/		return 0x82171FF0;
		  /* 82171FF0h */ case    9:  		/* mr R5, R24 */
		/* 82171FF0h case    9:*/		regs.R5 = regs.R24;
		/* 82171FF0h case    9:*/		return 0x82171FF4;
		  /* 82171FF4h */ case   10:  		/* mr R4, R30 */
		/* 82171FF4h case   10:*/		regs.R4 = regs.R30;
		/* 82171FF4h case   10:*/		return 0x82171FF8;
		  /* 82171FF8h */ case   11:  		/* mr R3, R31 */
		/* 82171FF8h case   11:*/		regs.R3 = regs.R31;
		/* 82171FF8h case   11:*/		return 0x82171FFC;
		  /* 82171FFCh */ case   12:  		/* bl 25236 */
		/* 82171FFCh case   12:*/		regs.LR = 0x82172000; return 0x82178290;
		/* 82171FFCh case   12:*/		return 0x82172000;
	}
	return 0x82172000;
} // Block from 82171FCCh-82172000h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82172000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172000);
		  /* 82172000h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82172000h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82172000h case    0:*/		return 0x82172004;
	}
	return 0x82172004;
} // Block from 82172000h-82172004h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172004);
		  /* 82172004h */ case    0:  		/* lwz R11, <#[R11 + 40]> */
		/* 82172004h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82172004h case    0:*/		return 0x82172008;
		  /* 82172008h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82172008h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82172008h case    1:*/		return 0x8217200C;
		  /* 8217200Ch */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 8217200Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8217201C;  }
		/* 8217200Ch case    2:*/		return 0x82172010;
		  /* 82172010h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82172010h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82172010h case    3:*/		return 0x82172014;
		  /* 82172014h */ case    4:  		/* mr R31, R11 */
		/* 82172014h case    4:*/		regs.R31 = regs.R11;
		/* 82172014h case    4:*/		return 0x82172018;
		  /* 82172018h */ case    5:  		/* bc 4, CR6_EQ, -188 */
		/* 82172018h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82171F5C;  }
		/* 82172018h case    5:*/		return 0x8217201C;
	}
	return 0x8217201C;
} // Block from 82172004h-8217201Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8217201Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217201C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217201C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217201C);
		  /* 8217201Ch */ case    0:  		/* lwz R29, <#[R29 + 8]> */
		/* 8217201Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8217201Ch case    0:*/		return 0x82172020;
		  /* 82172020h */ case    1:  		/* b -276 */
		/* 82172020h case    1:*/		return 0x82171F0C;
		/* 82172020h case    1:*/		return 0x82172024;
	}
	return 0x82172024;
} // Block from 8217201Ch-82172024h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172024);
		  /* 82172024h */ case    0:  		/* addi R1, R1, 160 */
		/* 82172024h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82172024h case    0:*/		return 0x82172028;
		  /* 82172028h */ case    1:  		/* b -920976 */
		/* 82172028h case    1:*/		return 0x82091298;
		/* 82172028h case    1:*/		return 0x8217202C;
		  /* 8217202Ch */ case    2:  		/* nop */
		/* 8217202Ch case    2:*/		cpu::op::nop();
		/* 8217202Ch case    2:*/		return 0x82172030;
		  /* 82172030h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82172030h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82172030h case    3:*/		return 0x82172034;
		  /* 82172034h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82172034h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82172034h case    4:*/		return 0x82172038;
		  /* 82172038h */ case    5:  		/* bc 4, CR0_EQ, 92 */
		/* 82172038h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82172094;  }
		/* 82172038h case    5:*/		return 0x8217203C;
		  /* 8217203Ch */ case    6:  		/* mr R9, R11 */
		/* 8217203Ch case    6:*/		regs.R9 = regs.R11;
		/* 8217203Ch case    6:*/		return 0x82172040;
		  /* 82172040h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82172040h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82172040h case    7:*/		return 0x82172044;
		  /* 82172044h */ case    8:  		/* bc 12, CR0_EQ, 80 */
		/* 82172044h case    8:*/		if ( regs.CR[0].eq ) { return 0x82172094;  }
		/* 82172044h case    8:*/		return 0x82172048;
		  /* 82172048h */ case    9:  		/* lwz R8, <#[R9 + 8]> */
		/* 82172048h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000008) );
		/* 82172048h case    9:*/		return 0x8217204C;
		  /* 8217204Ch */ case   10:  		/* li R10, 0 */
		/* 8217204Ch case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8217204Ch case   10:*/		return 0x82172050;
		  /* 82172050h */ case   11:  		/* cmplwi CR6, R8, 0 */
		/* 82172050h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82172050h case   11:*/		return 0x82172054;
		  /* 82172054h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 82172054h case   12:*/		if ( regs.CR[6].eq ) { return 0x82172078;  }
		/* 82172054h case   12:*/		return 0x82172058;
		  /* 82172058h */ case   13:  		/* addi R11, R9, 16 */
		/* 82172058h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x10);
		/* 82172058h case   13:*/		return 0x8217205C;
		  /* 8217205Ch */ case   14:  		/* lwz R7, <#[R11]> */
		/* 8217205Ch case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8217205Ch case   14:*/		return 0x82172060;
		  /* 82172060h */ case   15:  		/* cmplw CR6, R7, R4 */
		/* 82172060h case   15:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 82172060h case   15:*/		return 0x82172064;
		  /* 82172064h */ case   16:  		/* bc 12, CR6_EQ, 56 */
		/* 82172064h case   16:*/		if ( regs.CR[6].eq ) { return 0x8217209C;  }
		/* 82172064h case   16:*/		return 0x82172068;
		  /* 82172068h */ case   17:  		/* addi R10, R10, 1 */
		/* 82172068h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82172068h case   17:*/		return 0x8217206C;
		  /* 8217206Ch */ case   18:  		/* addi R11, R11, 4 */
		/* 8217206Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8217206Ch case   18:*/		return 0x82172070;
		  /* 82172070h */ case   19:  		/* cmplw CR6, R10, R8 */
		/* 82172070h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82172070h case   19:*/		return 0x82172074;
		  /* 82172074h */ case   20:  		/* bc 12, CR6_LT, -24 */
		/* 82172074h case   20:*/		if ( regs.CR[6].lt ) { return 0x8217205C;  }
		/* 82172074h case   20:*/		return 0x82172078;
	}
	return 0x82172078;
} // Block from 82172024h-82172078h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82172078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172078);
		  /* 82172078h */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 82172078h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 82172078h case    0:*/		return 0x8217207C;
		  /* 8217207Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8217207Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8217207Ch case    1:*/		return 0x82172080;
		  /* 82172080h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82172080h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82172080h case    2:*/		return 0x82172084;
		  /* 82172084h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82172084h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82172094;  }
		/* 82172084h case    3:*/		return 0x82172088;
		  /* 82172088h */ case    4:  		/* mr R9, R11 */
		/* 82172088h case    4:*/		regs.R9 = regs.R11;
		/* 82172088h case    4:*/		return 0x8217208C;
		  /* 8217208Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8217208Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217208Ch case    5:*/		return 0x82172090;
	}
	return 0x82172090;
} // Block from 82172078h-82172090h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172090h
// Function '?ShouldBeInBody_BeforeScheduling@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172090);
		  /* 82172090h */ case    0:  		/* bc 4, CR6_EQ, -72 */
		/* 82172090h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82172048;  }
		/* 82172090h case    0:*/		return 0x82172094;
	}
	return 0x82172094;
} // Block from 82172090h-82172094h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172094);
		  /* 82172094h */ case    0:  		/* li R3, 0 */
		/* 82172094h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82172094h case    0:*/		return 0x82172098;
		  /* 82172098h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82172098h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172098h case    1:*/		return 0x8217209C;
	}
	return 0x8217209C;
} // Block from 82172094h-8217209Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217209Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217209C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217209C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217209C);
		  /* 8217209Ch */ case    0:  		/* li R3, 1 */
		/* 8217209Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8217209Ch case    0:*/		return 0x821720A0;
		  /* 821720A0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821720A0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821720A0h case    1:*/		return 0x821720A4;
	}
	return 0x821720A4;
} // Block from 8217209Ch-821720A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821720A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821720A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821720A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821720A4);
		  /* 821720A4h */ case    0:  		/* nop */
		/* 821720A4h case    0:*/		cpu::op::nop();
		/* 821720A4h case    0:*/		return 0x821720A8;
		  /* 821720A8h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 821720A8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821720A8h case    1:*/		return 0x821720AC;
		  /* 821720ACh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821720ACh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821720ACh case    2:*/		return 0x821720B0;
		  /* 821720B0h */ case    3:  		/* bclr 4, CR0_EQ */
		/* 821720B0h case    3:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821720B0h case    3:*/		return 0x821720B4;
	}
	return 0x821720B4;
} // Block from 821720A4h-821720B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821720B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821720B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821720B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821720B4);
		  /* 821720B4h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 821720B4h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821720B4h case    0:*/		return 0x821720B8;
		  /* 821720B8h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 821720B8h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821720B8h case    1:*/		return 0x821720BC;
	}
	return 0x821720BC;
} // Block from 821720B4h-821720BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821720BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821720BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821720BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821720BC);
		  /* 821720BCh */ case    0:  		/* lwz R8, <#[R11 + 8]> */
		/* 821720BCh case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 821720BCh case    0:*/		return 0x821720C0;
		  /* 821720C0h */ case    1:  		/* li R10, 0 */
		/* 821720C0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821720C0h case    1:*/		return 0x821720C4;
		  /* 821720C4h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 821720C4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821720C4h case    2:*/		return 0x821720C8;
		  /* 821720C8h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 821720C8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821720F0;  }
		/* 821720C8h case    3:*/		return 0x821720CC;
		  /* 821720CCh */ case    4:  		/* addi R9, R11, 16 */
		/* 821720CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x10);
		/* 821720CCh case    4:*/		return 0x821720D0;
		  /* 821720D0h */ case    5:  		/* lwz R7, <#[R9]> */
		/* 821720D0h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 821720D0h case    5:*/		return 0x821720D4;
		  /* 821720D4h */ case    6:  		/* cmplw CR6, R7, R4 */
		/* 821720D4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 821720D4h case    6:*/		return 0x821720D8;
		  /* 821720D8h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 821720D8h case    7:*/		if ( regs.CR[6].eq ) { return 0x8217210C;  }
		/* 821720D8h case    7:*/		return 0x821720DC;
		  /* 821720DCh */ case    8:  		/* lwz R7, <#[R11 + 8]> */
		/* 821720DCh case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 821720DCh case    8:*/		return 0x821720E0;
		  /* 821720E0h */ case    9:  		/* addi R10, R10, 1 */
		/* 821720E0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821720E0h case    9:*/		return 0x821720E4;
		  /* 821720E4h */ case   10:  		/* addi R9, R9, 4 */
		/* 821720E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821720E4h case   10:*/		return 0x821720E8;
		  /* 821720E8h */ case   11:  		/* cmplw CR6, R10, R7 */
		/* 821720E8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 821720E8h case   11:*/		return 0x821720EC;
		  /* 821720ECh */ case   12:  		/* bc 12, CR6_LT, -28 */
		/* 821720ECh case   12:*/		if ( regs.CR[6].lt ) { return 0x821720D0;  }
		/* 821720ECh case   12:*/		return 0x821720F0;
	}
	return 0x821720F0;
} // Block from 821720BCh-821720F0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821720F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821720F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821720F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821720F0);
		  /* 821720F0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821720F0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821720F0h case    0:*/		return 0x821720F4;
		  /* 821720F4h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821720F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821720F4h case    1:*/		return 0x821720F8;
		  /* 821720F8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821720F8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821720F8h case    2:*/		return 0x821720FC;
		  /* 821720FCh */ case    3:  		/* bclr 4, CR0_EQ */
		/* 821720FCh case    3:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821720FCh case    3:*/		return 0x82172100;
	}
	return 0x82172100;
} // Block from 821720F0h-82172100h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82172100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172100);
		  /* 82172100h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82172100h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82172100h case    0:*/		return 0x82172104;
		  /* 82172104h */ case    1:  		/* bc 4, CR6_EQ, -72 */
		/* 82172104h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821720BC;  }
		/* 82172104h case    1:*/		return 0x82172108;
		  /* 82172108h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82172108h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172108h case    2:*/		return 0x8217210C;
	}
	return 0x8217210C;
} // Block from 82172100h-8217210Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8217210Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217210C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217210C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217210C);
		  /* 8217210Ch */ case    0:  		/* addic. R9, R8, -1 */
		/* 8217210Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R9,regs.R8,0xFFFFFFFF);
		/* 8217210Ch case    0:*/		return 0x82172110;
		  /* 82172110h */ case    1:  		/* stw R9, <#[R11 + 8]> */
		/* 82172110h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82172110h case    1:*/		return 0x82172114;
		  /* 82172114h */ case    2:  		/* bc 4, CR0_EQ, 60 */
		/* 82172114h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82172150;  }
		/* 82172114h case    2:*/		return 0x82172118;
		  /* 82172118h */ case    3:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 82172118h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 82172118h case    3:*/		return 0x8217211C;
		  /* 8217211Ch */ case    4:  		/* mr R4, R11 */
		/* 8217211Ch case    4:*/		regs.R4 = regs.R11;
		/* 8217211Ch case    4:*/		return 0x82172120;
		  /* 82172120h */ case    5:  		/* lwz R9, <#[R10 + 4]> */
		/* 82172120h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82172120h case    5:*/		return 0x82172124;
		  /* 82172124h */ case    6:  		/* lwz R8, <#[R10]> */
		/* 82172124h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82172124h case    6:*/		return 0x82172128;
		  /* 82172128h */ case    7:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82172128h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82172128h case    7:*/		return 0x8217212C;
		  /* 8217212Ch */ case    8:  		/* stw R8, <#[R9]> */
		/* 8217212Ch case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8217212Ch case    8:*/		return 0x82172130;
		  /* 82172130h */ case    9:  		/* lwz R9, <#[R10 + 4]> */
		/* 82172130h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82172130h case    9:*/		return 0x82172134;
		  /* 82172134h */ case   10:  		/* lwz R10, <#[R10]> */
		/* 82172134h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82172134h case   10:*/		return 0x82172138;
		  /* 82172138h */ case   11:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82172138h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82172138h case   11:*/		return 0x8217213C;
		  /* 8217213Ch */ case   12:  		/* stw R9, <#[R10]> */
		/* 8217213Ch case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8217213Ch case   12:*/		return 0x82172140;
		  /* 82172140h */ case   13:  		/* lwz R11, <#[R11 + 12]> */
		/* 82172140h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82172140h case   13:*/		return 0x82172144;
		  /* 82172144h */ case   14:  		/* addi R11, R11, 4 */
		/* 82172144h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82172144h case   14:*/		return 0x82172148;
		  /* 82172148h */ case   15:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82172148h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82172148h case   15:*/		return 0x8217214C;
		  /* 8217214Ch */ case   16:  		/* b -131908 */
		/* 8217214Ch case   16:*/		return 0x82151E08;
		/* 8217214Ch case   16:*/		return 0x82172150;
	}
	return 0x82172150;
} // Block from 8217210Ch-82172150h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82172150h
// Function '?ShouldBeInBody_PossiblyAfterScheduling@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172150);
		  /* 82172150h */ case    0:  		/* cmplw CR6, R10, R9 */
		/* 82172150h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82172150h case    0:*/		return 0x82172154;
		  /* 82172154h */ case    1:  		/* bclr 4, CR6_LT */
		/* 82172154h case    1:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82172154h case    1:*/		return 0x82172158;
	}
	return 0x82172158;
} // Block from 82172150h-82172158h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172158);
		  /* 82172158h */ case    0:  		/* addi R8, R10, 5 */
		/* 82172158h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x5);
		/* 82172158h case    0:*/		return 0x8217215C;
		  /* 8217215Ch */ case    1:  		/* addi R7, R10, 4 */
		/* 8217215Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x4);
		/* 8217215Ch case    1:*/		return 0x82172160;
		  /* 82172160h */ case    2:  		/* subf R6, R10, R9 */
		/* 82172160h case    2:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R10,regs.R9);
		/* 82172160h case    2:*/		return 0x82172164;
		  /* 82172164h */ case    3:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 82172164h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82172164h case    3:*/		return 0x82172168;
		  /* 82172168h */ case    4:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 82172168h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 82172168h case    4:*/		return 0x8217216C;
		  /* 8217216Ch */ case    5:  		/* rlwinm R5, R6, 2, 0, 29 */
		/* 8217216Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R6);
		/* 8217216Ch case    5:*/		return 0x82172170;
		  /* 82172170h */ case    6:  		/* add R4, R9, R11 */
		/* 82172170h case    6:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 82172170h case    6:*/		return 0x82172174;
		  /* 82172174h */ case    7:  		/* add R3, R10, R11 */
		/* 82172174h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82172174h case    7:*/		return 0x82172178;
		  /* 82172178h */ case    8:  		/* b -918104 */
		/* 82172178h case    8:*/		return 0x82091F20;
		/* 82172178h case    8:*/		return 0x8217217C;
		  /* 8217217Ch */ case    9:  		/* nop */
		/* 8217217Ch case    9:*/		cpu::op::nop();
		/* 8217217Ch case    9:*/		return 0x82172180;
	}
	return 0x82172180;
} // Block from 82172158h-82172180h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82172180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172180);
		  /* 82172180h */ case    0:  		/* mfspr R12, LR */
		/* 82172180h case    0:*/		regs.R12 = regs.LR;
		/* 82172180h case    0:*/		return 0x82172184;
		  /* 82172184h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82172184h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172184h case    1:*/		return 0x82172188;
		  /* 82172188h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172188h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172188h case    2:*/		return 0x8217218C;
		  /* 8217218Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8217218Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8217218Ch case    3:*/		return 0x82172190;
		  /* 82172190h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172190h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172190h case    4:*/		return 0x82172194;
		  /* 82172194h */ case    5:  		/* mr R31, R3 */
		/* 82172194h case    5:*/		regs.R31 = regs.R3;
		/* 82172194h case    5:*/		return 0x82172198;
		  /* 82172198h */ case    6:  		/* lwz R3, <#[R3 + 4]> */
		/* 82172198h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82172198h case    6:*/		return 0x8217219C;
		  /* 8217219Ch */ case    7:  		/* mr R30, R4 */
		/* 8217219Ch case    7:*/		regs.R30 = regs.R4;
		/* 8217219Ch case    7:*/		return 0x821721A0;
		  /* 821721A0h */ case    8:  		/* lwz R11, <#[R3 + 12]> */
		/* 821721A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821721A0h case    8:*/		return 0x821721A4;
		  /* 821721A4h */ case    9:  		/* lwz R10, <#[R3 + 8]> */
		/* 821721A4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821721A4h case    9:*/		return 0x821721A8;
		  /* 821721A8h */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 821721A8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821721A8h case   10:*/		return 0x821721AC;
		  /* 821721ACh */ case   11:  		/* bc 4, CR6_EQ, 168 */
		/* 821721ACh case   11:*/		if ( !regs.CR[6].eq ) { return 0x82172254;  }
		/* 821721ACh case   11:*/		return 0x821721B0;
	}
	return 0x821721B0;
} // Block from 82172180h-821721B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821721B0h
// Function '?IsScheduledBefore@Instruction@D3DXShader@@QAA_NPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821721B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821721B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821721B0);
		  /* 821721B0h */ case    0:  		/* addi R11, R11, 4 */
		/* 821721B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821721B0h case    0:*/		return 0x821721B4;
		  /* 821721B4h */ case    1:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 821721B4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 821721B4h case    1:*/		return 0x821721B8;
		  /* 821721B8h */ case    2:  		/* bl -53808 */
		/* 821721B8h case    2:*/		regs.LR = 0x821721BC; return 0x82164F88;
		/* 821721B8h case    2:*/		return 0x821721BC;
		  /* 821721BCh */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 821721BCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821721BCh case    3:*/		return 0x821721C0;
		  /* 821721C0h */ case    4:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821721C0h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821721C0h case    4:*/		return 0x821721C4;
		  /* 821721C4h */ case    5:  		/* mr R9, R3 */
		/* 821721C4h case    5:*/		regs.R9 = regs.R3;
		/* 821721C4h case    5:*/		return 0x821721C8;
		  /* 821721C8h */ case    6:  		/* addi R8, R11, 4 */
		/* 821721C8h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 821721C8h case    6:*/		return 0x821721CC;
		  /* 821721CCh */ case    7:  		/* lwz R10, <#[R10 + 12]> */
		/* 821721CCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 821721CCh case    7:*/		return 0x821721D0;
		  /* 821721D0h */ case    8:  		/* stw R10, <#[R3 + 12]> */
		/* 821721D0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821721D0h case    8:*/		return 0x821721D4;
		  /* 821721D4h */ case    9:  		/* lwz R10, <#[R31 + 4]> */
		/* 821721D4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821721D4h case    9:*/		return 0x821721D8;
		  /* 821721D8h */ case   10:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821721D8h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821721D8h case   10:*/		return 0x821721DC;
		  /* 821721DCh */ case   11:  		/* lwz R6, <#[R10 + 4]> */
		/* 821721DCh case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821721DCh case   11:*/		return 0x821721E0;
		  /* 821721E0h */ case   12:  		/* addi R7, R10, 4 */
		/* 821721E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x4);
		/* 821721E0h case   12:*/		return 0x821721E4;
		  /* 821721E4h */ case   13:  		/* stw R6, <#[R11 + 4]> */
		/* 821721E4h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821721E4h case   13:*/		return 0x821721E8;
		  /* 821721E8h */ case   14:  		/* lwz R6, <#[R10 + 4]> */
		/* 821721E8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821721E8h case   14:*/		return 0x821721EC;
		  /* 821721ECh */ case   15:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821721ECh case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821721ECh case   15:*/		return 0x821721F0;
		  /* 821721F0h */ case   16:  		/* stw R8, <#[R6]> */
		/* 821721F0h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 821721F0h case   16:*/		return 0x821721F4;
		  /* 821721F4h */ case   17:  		/* stw R7, <#[R11]> */
		/* 821721F4h case   17:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821721F4h case   17:*/		return 0x821721F8;
		  /* 821721F8h */ case   18:  		/* stw R11, <#[R10 + 4]> */
		/* 821721F8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821721F8h case   18:*/		return 0x821721FC;
		  /* 821721FCh */ case   19:  		/* lwz R10, <#[R31 + 4]> */
		/* 821721FCh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821721FCh case   19:*/		return 0x82172200;
		  /* 82172200h */ case   20:  		/* lwz R11, <#[R31 + 8]> */
		/* 82172200h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82172200h case   20:*/		return 0x82172204;
		  /* 82172204h */ case   21:  		/* lwz R10, <#[R10 + 8]> */
		/* 82172204h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82172204h case   21:*/		return 0x82172208;
		  /* 82172208h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 82172208h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82172208h case   22:*/		return 0x8217220C;
		  /* 8217220Ch */ case   23:  		/* bc 4, CR6_LT, 60 */
		/* 8217220Ch case   23:*/		if ( !regs.CR[6].lt ) { return 0x82172248;  }
		/* 8217220Ch case   23:*/		return 0x82172210;
		  /* 82172210h */ case   24:  		/* subf R11, R11, R10 */
		/* 82172210h case   24:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82172210h case   24:*/		return 0x82172214;
		  /* 82172214h */ case   25:  		/* addi R3, R3, 16 */
		/* 82172214h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x10);
		/* 82172214h case   25:*/		return 0x82172218;
		  /* 82172218h */ case   26:  		/* stw R11, <#[R9 + 8]> */
		/* 82172218h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82172218h case   26:*/		return 0x8217221C;
		  /* 8217221Ch */ case   27:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8217221Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8217221Ch case   27:*/		return 0x82172220;
		  /* 82172220h */ case   28:  		/* lwz R10, <#[R31 + 4]> */
		/* 82172220h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82172220h case   28:*/		return 0x82172224;
		  /* 82172224h */ case   29:  		/* lwz R11, <#[R31 + 8]> */
		/* 82172224h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82172224h case   29:*/		return 0x82172228;
		  /* 82172228h */ case   30:  		/* addi R11, R11, 4 */
		/* 82172228h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82172228h case   30:*/		return 0x8217222C;
		  /* 8217222Ch */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8217222Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8217222Ch case   31:*/		return 0x82172230;
		  /* 82172230h */ case   32:  		/* add R4, R11, R10 */
		/* 82172230h case   32:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 82172230h case   32:*/		return 0x82172234;
		  /* 82172234h */ case   33:  		/* bl -919684 */
		/* 82172234h case   33:*/		regs.LR = 0x82172238; return 0x820919B0;
		/* 82172234h case   33:*/		return 0x82172238;
	}
	return 0x82172238;
} // Block from 821721B0h-82172238h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82172238h
// Function '?Destruct@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172238);
		  /* 82172238h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82172238h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82172238h case    0:*/		return 0x8217223C;
		  /* 8217223Ch */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 8217223Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8217223Ch case    1:*/		return 0x82172240;
		  /* 82172240h */ case    2:  		/* stw R10, <#[R11 + 8]> */
		/* 82172240h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82172240h case    2:*/		return 0x82172244;
		  /* 82172244h */ case    3:  		/* b 16 */
		/* 82172244h case    3:*/		return 0x82172254;
		/* 82172244h case    3:*/		return 0x82172248;
	}
	return 0x82172248;
} // Block from 82172238h-82172248h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82172248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172248);
		  /* 82172248h */ case    0:  		/* li R11, 0 */
		/* 82172248h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82172248h case    0:*/		return 0x8217224C;
		  /* 8217224Ch */ case    1:  		/* stw R9, <#[R31 + 4]> */
		/* 8217224Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8217224Ch case    1:*/		return 0x82172250;
		  /* 82172250h */ case    2:  		/* stw R11, <#[R31 + 8]> */
		/* 82172250h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82172250h case    2:*/		return 0x82172254;
	}
	return 0x82172254;
} // Block from 82172248h-82172254h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82172254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172254);
		  /* 82172254h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82172254h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82172254h case    0:*/		return 0x82172258;
		  /* 82172258h */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 82172258h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82172258h case    1:*/		return 0x8217225C;
		  /* 8217225Ch */ case    2:  		/* addi R9, R10, 4 */
		/* 8217225Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8217225Ch case    2:*/		return 0x82172260;
		  /* 82172260h */ case    3:  		/* addi R8, R10, 5 */
		/* 82172260h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x5);
		/* 82172260h case    3:*/		return 0x82172264;
		  /* 82172264h */ case    4:  		/* lwz R7, <#[R11 + 8]> */
		/* 82172264h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 82172264h case    4:*/		return 0x82172268;
		  /* 82172268h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82172268h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82172268h case    5:*/		return 0x8217226C;
		  /* 8217226Ch */ case    6:  		/* subf R7, R10, R7 */
		/* 8217226Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R10,regs.R7);
		/* 8217226Ch case    6:*/		return 0x82172270;
		  /* 82172270h */ case    7:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 82172270h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 82172270h case    7:*/		return 0x82172274;
		  /* 82172274h */ case    8:  		/* rlwinm R5, R7, 2, 0, 29 */
		/* 82172274h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R7);
		/* 82172274h case    8:*/		return 0x82172278;
		  /* 82172278h */ case    9:  		/* add R4, R9, R11 */
		/* 82172278h case    9:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 82172278h case    9:*/		return 0x8217227C;
		  /* 8217227Ch */ case   10:  		/* add R3, R10, R11 */
		/* 8217227Ch case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8217227Ch case   10:*/		return 0x82172280;
		  /* 82172280h */ case   11:  		/* bl -918368 */
		/* 82172280h case   11:*/		regs.LR = 0x82172284; return 0x82091F20;
		/* 82172280h case   11:*/		return 0x82172284;
		  /* 82172284h */ case   12:  		/* lwz R11, <#[R31 + 4]> */
		/* 82172284h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82172284h case   12:*/		return 0x82172288;
	}
	return 0x82172288;
} // Block from 82172254h-82172288h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82172288h
// Function '?Find@?$RegisterSet@V?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@$1?PrintVirtualRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAIIIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172288);
		  /* 82172288h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82172288h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82172288h case    0:*/		return 0x8217228C;
		  /* 8217228Ch */ case    1:  		/* addi R10, R10, 1 */
		/* 8217228Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8217228Ch case    1:*/		return 0x82172290;
		  /* 82172290h */ case    2:  		/* stw R10, <#[R11 + 8]> */
		/* 82172290h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82172290h case    2:*/		return 0x82172294;
		  /* 82172294h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 82172294h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82172294h case    3:*/		return 0x82172298;
		  /* 82172298h */ case    4:  		/* addi R11, R11, 4 */
		/* 82172298h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82172298h case    4:*/		return 0x8217229C;
		  /* 8217229Ch */ case    5:  		/* lwz R10, <#[R31 + 4]> */
		/* 8217229Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8217229Ch case    5:*/		return 0x821722A0;
		  /* 821722A0h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821722A0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821722A0h case    6:*/		return 0x821722A4;
		  /* 821722A4h */ case    7:  		/* stwx R30, <#[R11 + R10]> */
		/* 821722A4h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821722A4h case    7:*/		return 0x821722A8;
		  /* 821722A8h */ case    8:  		/* addi R1, R1, 112 */
		/* 821722A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821722A8h case    8:*/		return 0x821722AC;
		  /* 821722ACh */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 821722ACh case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821722ACh case    9:*/		return 0x821722B0;
		  /* 821722B0h */ case   10:  		/* mtspr LR, R12 */
		/* 821722B0h case   10:*/		regs.LR = regs.R12;
		/* 821722B0h case   10:*/		return 0x821722B4;
		  /* 821722B4h */ case   11:  		/* ld R30, <#[R1 - 24]> */
		/* 821722B4h case   11:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821722B4h case   11:*/		return 0x821722B8;
		  /* 821722B8h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 821722B8h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821722B8h case   12:*/		return 0x821722BC;
		  /* 821722BCh */ case   13:  		/* bclr 20, CR0_LT */
		/* 821722BCh case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821722BCh case   13:*/		return 0x821722C0;
	}
	return 0x821722C0;
} // Block from 82172288h-821722C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821722C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821722C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821722C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821722C0);
		  /* 821722C0h */ case    0:  		/* mfspr R12, LR */
		/* 821722C0h case    0:*/		regs.R12 = regs.LR;
		/* 821722C0h case    0:*/		return 0x821722C4;
		  /* 821722C4h */ case    1:  		/* bl -921704 */
		/* 821722C4h case    1:*/		regs.LR = 0x821722C8; return 0x8209125C;
		/* 821722C4h case    1:*/		return 0x821722C8;
		  /* 821722C8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821722C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821722C8h case    2:*/		return 0x821722CC;
		  /* 821722CCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821722CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821722CCh case    3:*/		return 0x821722D0;
		  /* 821722D0h */ case    4:  		/* mr R30, R3 */
		/* 821722D0h case    4:*/		regs.R30 = regs.R3;
		/* 821722D0h case    4:*/		return 0x821722D4;
		  /* 821722D4h */ case    5:  		/* nor R10, R11, R11 */
		/* 821722D4h case    5:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 821722D4h case    5:*/		return 0x821722D8;
		  /* 821722D8h */ case    6:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821722D8h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821722D8h case    6:*/		return 0x821722DC;
		  /* 821722DCh */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 821722DCh case    7:*/		if ( !regs.CR[0].eq ) { return 0x821722E8;  }
		/* 821722DCh case    7:*/		return 0x821722E0;
		  /* 821722E0h */ case    8:  		/* li R11, 31 */
		/* 821722E0h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1F);
		/* 821722E0h case    8:*/		return 0x821722E4;
		  /* 821722E4h */ case    9:  		/* b 16 */
		/* 821722E4h case    9:*/		return 0x821722F4;
		/* 821722E4h case    9:*/		return 0x821722E8;
	}
	return 0x821722E8;
} // Block from 821722C0h-821722E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821722E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821722E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821722E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821722E8);
		  /* 821722E8h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821722E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821722E8h case    0:*/		return 0x821722EC;
		  /* 821722ECh */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821722ECh case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821722ECh case    1:*/		return 0x821722F0;
		  /* 821722F0h */ case    2:  		/* addi R11, R11, -1 */
		/* 821722F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821722F0h case    2:*/		return 0x821722F4;
	}
	return 0x821722F4;
} // Block from 821722E8h-821722F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821722F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821722F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821722F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821722F4);
		  /* 821722F4h */ case    0:  		/* cmplw CR6, R4, R11 */
		/* 821722F4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821722F4h case    0:*/		return 0x821722F8;
		  /* 821722F8h */ case    1:  		/* bc 4, CR6_GT, 112 */
		/* 821722F8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82172368;  }
		/* 821722F8h case    1:*/		return 0x821722FC;
		  /* 821722FCh */ case    2:  		/* addi R11, R4, 32 */
		/* 821722FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 821722FCh case    2:*/		return 0x82172300;
		  /* 82172300h */ case    3:  		/* mr R3, R30 */
		/* 82172300h case    3:*/		regs.R3 = regs.R30;
		/* 82172300h case    3:*/		return 0x82172304;
		  /* 82172304h */ case    4:  		/* rlwinm R29, R11, 27, 5, 31 */
		/* 82172304h case    4:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R29,regs.R11);
		/* 82172304h case    4:*/		return 0x82172308;
		  /* 82172308h */ case    5:  		/* addi R11, R29, 1 */
		/* 82172308h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x1);
		/* 82172308h case    5:*/		return 0x8217230C;
		  /* 8217230Ch */ case    6:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 8217230Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 8217230Ch case    6:*/		return 0x82172310;
		  /* 82172310h */ case    7:  		/* bl -54152 */
		/* 82172310h case    7:*/		regs.LR = 0x82172314; return 0x82164F88;
		/* 82172310h case    7:*/		return 0x82172314;
		  /* 82172314h */ case    8:  		/* stw R29, <#[R3]> */
		/* 82172314h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82172314h case    8:*/		return 0x82172318;
		  /* 82172318h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 82172318h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82172318h case    9:*/		return 0x8217231C;
		  /* 8217231Ch */ case   10:  		/* nor R10, R11, R11 */
		/* 8217231Ch case   10:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8217231Ch case   10:*/		return 0x82172320;
		  /* 82172320h */ case   11:  		/* mr R31, R3 */
		/* 82172320h case   11:*/		regs.R31 = regs.R3;
		/* 82172320h case   11:*/		return 0x82172324;
		  /* 82172324h */ case   12:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82172324h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82172324h case   12:*/		return 0x82172328;
		  /* 82172328h */ case   13:  		/* bc 12, CR0_EQ, 52 */
		/* 82172328h case   13:*/		if ( regs.CR[0].eq ) { return 0x8217235C;  }
		/* 82172328h case   13:*/		return 0x8217232C;
		  /* 8217232Ch */ case   14:  		/* lwz R10, <#[R11]> */
		/* 8217232Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8217232Ch case   14:*/		return 0x82172330;
		  /* 82172330h */ case   15:  		/* addi R4, R11, 4 */
		/* 82172330h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 82172330h case   15:*/		return 0x82172334;
		  /* 82172334h */ case   16:  		/* addi R3, R3, 4 */
		/* 82172334h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82172334h case   16:*/		return 0x82172338;
		  /* 82172338h */ case   17:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 82172338h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 82172338h case   17:*/		return 0x8217233C;
		  /* 8217233Ch */ case   18:  		/* bl -919948 */
		/* 8217233Ch case   18:*/		regs.LR = 0x82172340; return 0x820919B0;
		/* 8217233Ch case   18:*/		return 0x82172340;
		  /* 82172340h */ case   19:  		/* lwz R4, <#[R30]> */
		/* 82172340h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 82172340h case   19:*/		return 0x82172344;
		  /* 82172344h */ case   20:  		/* mr R3, R30 */
		/* 82172344h case   20:*/		regs.R3 = regs.R30;
		/* 82172344h case   20:*/		return 0x82172348;
		  /* 82172348h */ case   21:  		/* lwz R11, <#[R4]> */
		/* 82172348h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82172348h case   21:*/		return 0x8217234C;
		  /* 8217234Ch */ case   22:  		/* addi R11, R11, 1 */
		/* 8217234Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8217234Ch case   22:*/		return 0x82172350;
		  /* 82172350h */ case   23:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82172350h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82172350h case   23:*/		return 0x82172354;
		  /* 82172354h */ case   24:  		/* bl -132428 */
		/* 82172354h case   24:*/		regs.LR = 0x82172358; return 0x82151E08;
		/* 82172354h case   24:*/		return 0x82172358;
		  /* 82172358h */ case   25:  		/* b 12 */
		/* 82172358h case   25:*/		return 0x82172364;
		/* 82172358h case   25:*/		return 0x8217235C;
	}
	return 0x8217235C;
} // Block from 821722F4h-8217235Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8217235Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217235C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217235C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217235C);
		  /* 8217235Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8217235Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8217235Ch case    0:*/		return 0x82172360;
		  /* 82172360h */ case    1:  		/* stw R11, <#[R31 + 4]> */
		/* 82172360h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82172360h case    1:*/		return 0x82172364;
	}
	return 0x82172364;
} // Block from 8217235Ch-82172364h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172364);
		  /* 82172364h */ case    0:  		/* stw R31, <#[R30]> */
		/* 82172364h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82172364h case    0:*/		return 0x82172368;
	}
	return 0x82172368;
} // Block from 82172364h-82172368h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172368);
		  /* 82172368h */ case    0:  		/* addi R1, R1, 112 */
		/* 82172368h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82172368h case    0:*/		return 0x8217236C;
		  /* 8217236Ch */ case    1:  		/* b -921792 */
		/* 8217236Ch case    1:*/		return 0x820912AC;
		/* 8217236Ch case    1:*/		return 0x82172370;
	}
	return 0x82172370;
} // Block from 82172368h-82172370h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172370h
// Function '?ClearAll@InfiniteLocalRegisterSet@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172370);
		  /* 82172370h */ case    0:  		/* mfspr R12, LR */
		/* 82172370h case    0:*/		regs.R12 = regs.LR;
		/* 82172370h case    0:*/		return 0x82172374;
		  /* 82172374h */ case    1:  		/* bl -921892 */
		/* 82172374h case    1:*/		regs.LR = 0x82172378; return 0x82091250;
		/* 82172374h case    1:*/		return 0x82172378;
		  /* 82172378h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82172378h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82172378h case    2:*/		return 0x8217237C;
		  /* 8217237Ch */ case    3:  		/* rlwinm R31, R4, 30, 2, 29 */
		/* 8217237Ch case    3:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R31,regs.R4);
		/* 8217237Ch case    3:*/		return 0x82172380;
		  /* 82172380h */ case    4:  		/* addi R30, R3, 4 */
		/* 82172380h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x4);
		/* 82172380h case    4:*/		return 0x82172384;
		  /* 82172384h */ case    5:  		/* addi R29, R31, 3 */
		/* 82172384h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x3);
		/* 82172384h case    5:*/		return 0x82172388;
		  /* 82172388h */ case    6:  		/* mr R11, R4 */
		/* 82172388h case    6:*/		regs.R11 = regs.R4;
		/* 82172388h case    6:*/		return 0x8217238C;
		  /* 8217238Ch */ case    7:  		/* mr R27, R3 */
		/* 8217238Ch case    7:*/		regs.R27 = regs.R3;
		/* 8217238Ch case    7:*/		return 0x82172390;
		  /* 82172390h */ case    8:  		/* mr R4, R31 */
		/* 82172390h case    8:*/		regs.R4 = regs.R31;
		/* 82172390h case    8:*/		return 0x82172394;
		  /* 82172394h */ case    9:  		/* mr R5, R29 */
		/* 82172394h case    9:*/		regs.R5 = regs.R29;
		/* 82172394h case    9:*/		return 0x82172398;
		  /* 82172398h */ case   10:  		/* mr R3, R30 */
		/* 82172398h case   10:*/		regs.R3 = regs.R30;
		/* 82172398h case   10:*/		return 0x8217239C;
		  /* 8217239Ch */ case   11:  		/* rlwinm R26, R11, 28, 4, 31 */
		/* 8217239Ch case   11:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R26,regs.R11);
		/* 8217239Ch case   11:*/		return 0x821723A0;
		  /* 821723A0h */ case   12:  		/* rlwinm R28, R11, 0, 28, 31 */
		/* 821723A0h case   12:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R28,regs.R11);
		/* 821723A0h case   12:*/		return 0x821723A4;
		  /* 821723A4h */ case   13:  		/* bl -3884 */
		/* 821723A4h case   13:*/		regs.LR = 0x821723A8; return 0x82171478;
		/* 821723A4h case   13:*/		return 0x821723A8;
		  /* 821723A8h */ case   14:  		/* and. R11, R3, R28 */
		/* 821723A8h case   14:*/		cpu::op::and<1>(regs,&regs.R11,regs.R3,regs.R28);
		/* 821723A8h case   14:*/		return 0x821723AC;
		  /* 821723ACh */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 821723ACh case   15:*/		if ( regs.CR[0].eq ) { return 0x821723C0;  }
		/* 821723ACh case   15:*/		return 0x821723B0;
		  /* 821723B0h */ case   16:  		/* mr R5, R26 */
		/* 821723B0h case   16:*/		regs.R5 = regs.R26;
		/* 821723B0h case   16:*/		return 0x821723B4;
		  /* 821723B4h */ case   17:  		/* lwz R3, <#[R27]> */
		/* 821723B4h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000000) );
		/* 821723B4h case   17:*/		return 0x821723B8;
		  /* 821723B8h */ case   18:  		/* li R4, 3526 */
		/* 821723B8h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0xDC6);
		/* 821723B8h case   18:*/		return 0x821723BC;
		  /* 821723BCh */ case   19:  		/* bl -132436 */
		/* 821723BCh case   19:*/		regs.LR = 0x821723C0; return 0x82151E68;
		/* 821723BCh case   19:*/		return 0x821723C0;
	}
	return 0x821723C0;
} // Block from 82172370h-821723C0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821723C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821723C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821723C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821723C0);
		  /* 821723C0h */ case    0:  		/* mr R6, R28 */
		/* 821723C0h case    0:*/		regs.R6 = regs.R28;
		/* 821723C0h case    0:*/		return 0x821723C4;
		  /* 821723C4h */ case    1:  		/* mr R5, R29 */
		/* 821723C4h case    1:*/		regs.R5 = regs.R29;
		/* 821723C4h case    1:*/		return 0x821723C8;
		  /* 821723C8h */ case    2:  		/* mr R4, R31 */
		/* 821723C8h case    2:*/		regs.R4 = regs.R31;
		/* 821723C8h case    2:*/		return 0x821723CC;
		  /* 821723CCh */ case    3:  		/* mr R3, R30 */
		/* 821723CCh case    3:*/		regs.R3 = regs.R30;
		/* 821723CCh case    3:*/		return 0x821723D0;
		  /* 821723D0h */ case    4:  		/* bl -3784 */
		/* 821723D0h case    4:*/		regs.LR = 0x821723D4; return 0x82171508;
		/* 821723D0h case    4:*/		return 0x821723D4;
		  /* 821723D4h */ case    5:  		/* addi R1, R1, 144 */
		/* 821723D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821723D4h case    5:*/		return 0x821723D8;
		  /* 821723D8h */ case    6:  		/* b -921912 */
		/* 821723D8h case    6:*/		return 0x820912A0;
		/* 821723D8h case    6:*/		return 0x821723DC;
		  /* 821723DCh */ case    7:  		/* nop */
		/* 821723DCh case    7:*/		cpu::op::nop();
		/* 821723DCh case    7:*/		return 0x821723E0;
	}
	return 0x821723E0;
} // Block from 821723C0h-821723E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821723E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821723E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821723E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821723E0);
		  /* 821723E0h */ case    0:  		/* mfspr R12, LR */
		/* 821723E0h case    0:*/		regs.R12 = regs.LR;
		/* 821723E0h case    0:*/		return 0x821723E4;
		  /* 821723E4h */ case    1:  		/* bl -921996 */
		/* 821723E4h case    1:*/		regs.LR = 0x821723E8; return 0x82091258;
		/* 821723E4h case    1:*/		return 0x821723E8;
		  /* 821723E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821723E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821723E8h case    2:*/		return 0x821723EC;
		  /* 821723ECh */ case    3:  		/* mr R28, R5 */
		/* 821723ECh case    3:*/		regs.R28 = regs.R5;
		/* 821723ECh case    3:*/		return 0x821723F0;
	}
	return 0x821723F0;
} // Block from 821723E0h-821723F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821723F0h
// Function '?MarkRegOwner@InfiniteLocalRegisterSet@D3DXShader@@AAAXIPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821723F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821723F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821723F0);
		  /* 821723F0h */ case    0:  		/* mr R30, R4 */
		/* 821723F0h case    0:*/		regs.R30 = regs.R4;
		/* 821723F0h case    0:*/		return 0x821723F4;
		  /* 821723F4h */ case    1:  		/* mr R5, R4 */
		/* 821723F4h case    1:*/		regs.R5 = regs.R4;
		/* 821723F4h case    1:*/		return 0x821723F8;
		  /* 821723F8h */ case    2:  		/* li R6, 4 */
		/* 821723F8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 821723F8h case    2:*/		return 0x821723FC;
		  /* 821723FCh */ case    3:  		/* li R4, 0 */
		/* 821723FCh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821723FCh case    3:*/		return 0x82172400;
		  /* 82172400h */ case    4:  		/* mr R29, R3 */
		/* 82172400h case    4:*/		regs.R29 = regs.R3;
		/* 82172400h case    4:*/		return 0x82172404;
		  /* 82172404h */ case    5:  		/* bl -2660 */
		/* 82172404h case    5:*/		regs.LR = 0x82172408; return 0x821719A0;
		/* 82172404h case    5:*/		return 0x82172408;
		  /* 82172408h */ case    6:  		/* mr R31, R3 */
		/* 82172408h case    6:*/		regs.R31 = regs.R3;
		/* 82172408h case    6:*/		return 0x8217240C;
		  /* 8217240Ch */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 8217240Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8217240Ch case    7:*/		return 0x82172410;
		  /* 82172410h */ case    8:  		/* bc 4, CR6_EQ, 216 */
		/* 82172410h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821724E8;  }
		/* 82172410h case    8:*/		return 0x82172414;
		  /* 82172414h */ case    9:  		/* lwz R11, <#[R29 + 4]> */
		/* 82172414h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82172414h case    9:*/		return 0x82172418;
		  /* 82172418h */ case   10:  		/* addi R3, R29, 4 */
		/* 82172418h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x4);
		/* 82172418h case   10:*/		return 0x8217241C;
		  /* 8217241Ch */ case   11:  		/* nor R10, R11, R11 */
		/* 8217241Ch case   11:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8217241Ch case   11:*/		return 0x82172420;
		  /* 82172420h */ case   12:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82172420h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82172420h case   12:*/		return 0x82172424;
		  /* 82172424h */ case   13:  		/* bc 4, CR0_EQ, 12 */
		/* 82172424h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82172430;  }
		/* 82172424h case   13:*/		return 0x82172428;
		  /* 82172428h */ case   14:  		/* li R10, 31 */
		/* 82172428h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x1F);
		/* 82172428h case   14:*/		return 0x8217242C;
		  /* 8217242Ch */ case   15:  		/* b 16 */
		/* 8217242Ch case   15:*/		return 0x8217243C;
		/* 8217242Ch case   15:*/		return 0x82172430;
	}
	return 0x82172430;
} // Block from 821723F0h-82172430h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82172430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172430);
		  /* 82172430h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82172430h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82172430h case    0:*/		return 0x82172434;
		  /* 82172434h */ case    1:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 82172434h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 82172434h case    1:*/		return 0x82172438;
		  /* 82172438h */ case    2:  		/* addi R10, R10, -1 */
		/* 82172438h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82172438h case    2:*/		return 0x8217243C;
	}
	return 0x8217243C;
} // Block from 82172430h-8217243Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8217243Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217243C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217243C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217243C);
		  /* 8217243Ch */ case    0:  		/* rlwinm R10, R10, 30, 2, 31 */
		/* 8217243Ch case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R10);
		/* 8217243Ch case    0:*/		return 0x82172440;
		  /* 82172440h */ case    1:  		/* addi R10, R10, -1 */
		/* 82172440h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82172440h case    1:*/		return 0x82172444;
		  /* 82172444h */ case    2:  		/* cmplwi CR6, R10, 255 */
		/* 82172444h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x000000FF);
		/* 82172444h case    2:*/		return 0x82172448;
		  /* 82172448h */ case    3:  		/* bc 12, CR6_LT, 52 */
		/* 82172448h case    3:*/		if ( regs.CR[6].lt ) { return 0x8217247C;  }
		/* 82172448h case    3:*/		return 0x8217244C;
		  /* 8217244Ch */ case    4:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8217244Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8217244Ch case    4:*/		return 0x82172450;
		  /* 82172450h */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 82172450h case    5:*/		if ( regs.CR[0].eq ) { return 0x82172474;  }
		/* 82172450h case    5:*/		return 0x82172454;
		  /* 82172454h */ case    6:  		/* lwz R3, <#[R29]> */
		/* 82172454h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 82172454h case    6:*/		return 0x82172458;
		  /* 82172458h */ case    7:  		/* lwz R11, <#[R3 + 792]> */
		/* 82172458h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000318) );
		/* 82172458h case    7:*/		return 0x8217245C;
		  /* 8217245Ch */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8217245Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217245Ch case    8:*/		return 0x82172460;
		  /* 82172460h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 82172460h case    9:*/		if ( regs.CR[6].eq ) { return 0x8217246C;  }
		/* 82172460h case    9:*/		return 0x82172464;
		  /* 82172464h */ case   10:  		/* li R4, 3518 */
		/* 82172464h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0xDBE);
		/* 82172464h case   10:*/		return 0x82172468;
		  /* 82172468h */ case   11:  		/* bl -132608 */
		/* 82172468h case   11:*/		regs.LR = 0x8217246C; return 0x82151E68;
		/* 82172468h case   11:*/		return 0x8217246C;
	}
	return 0x8217246C;
} // Block from 8217243Ch-8217246Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8217246Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217246C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217246C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217246C);
		  /* 8217246Ch */ case    0:  		/* li R4, 3565 */
		/* 8217246Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDED);
		/* 8217246Ch case    0:*/		return 0x82172470;
		  /* 82172470h */ case    1:  		/* bl -132616 */
		/* 82172470h case    1:*/		regs.LR = 0x82172474; return 0x82151E68;
		/* 82172470h case    1:*/		return 0x82172474;
	}
	return 0x82172474;
} // Block from 8217246Ch-82172474h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172474);
		  /* 82172474h */ case    0:  		/* li R3, -1 */
		/* 82172474h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82172474h case    0:*/		return 0x82172478;
		  /* 82172478h */ case    1:  		/* b 160 */
		/* 82172478h case    1:*/		return 0x82172518;
		/* 82172478h case    1:*/		return 0x8217247C;
	}
	return 0x8217247C;
} // Block from 82172474h-8217247Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217247Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217247C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217247C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217247C);
		  /* 8217247Ch */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 8217247Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8217247Ch case    0:*/		return 0x82172480;
		  /* 82172480h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82172480h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8217248C;  }
		/* 82172480h case    1:*/		return 0x82172484;
		  /* 82172484h */ case    2:  		/* li R11, 31 */
		/* 82172484h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1F);
		/* 82172484h case    2:*/		return 0x82172488;
		  /* 82172488h */ case    3:  		/* b 16 */
		/* 82172488h case    3:*/		return 0x82172498;
		/* 82172488h case    3:*/		return 0x8217248C;
	}
	return 0x8217248C;
} // Block from 8217247Ch-8217248Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8217248Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217248C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217248C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217248C);
		  /* 8217248Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8217248Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8217248Ch case    0:*/		return 0x82172490;
		  /* 82172490h */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 82172490h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 82172490h case    1:*/		return 0x82172494;
		  /* 82172494h */ case    2:  		/* addi R11, R11, -1 */
		/* 82172494h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82172494h case    2:*/		return 0x82172498;
	}
	return 0x82172498;
} // Block from 8217248Ch-82172498h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82172498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172498);
		  /* 82172498h */ case    0:  		/* addi R4, R11, 4 */
		/* 82172498h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 82172498h case    0:*/		return 0x8217249C;
		  /* 8217249Ch */ case    1:  		/* bl -476 */
		/* 8217249Ch case    1:*/		regs.LR = 0x821724A0; return 0x821722C0;
		/* 8217249Ch case    1:*/		return 0x821724A0;
		  /* 821724A0h */ case    2:  		/* li R6, 4 */
		/* 821724A0h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 821724A0h case    2:*/		return 0x821724A4;
		  /* 821724A4h */ case    3:  		/* mr R5, R30 */
		/* 821724A4h case    3:*/		regs.R5 = regs.R30;
		/* 821724A4h case    3:*/		return 0x821724A8;
		  /* 821724A8h */ case    4:  		/* li R4, 0 */
		/* 821724A8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821724A8h case    4:*/		return 0x821724AC;
		  /* 821724ACh */ case    5:  		/* mr R3, R29 */
		/* 821724ACh case    5:*/		regs.R3 = regs.R29;
		/* 821724ACh case    5:*/		return 0x821724B0;
		  /* 821724B0h */ case    6:  		/* bl -2832 */
		/* 821724B0h case    6:*/		regs.LR = 0x821724B4; return 0x821719A0;
		/* 821724B0h case    6:*/		return 0x821724B4;
		  /* 821724B4h */ case    7:  		/* mr R31, R3 */
		/* 821724B4h case    7:*/		regs.R31 = regs.R3;
		/* 821724B4h case    7:*/		return 0x821724B8;
	}
	return 0x821724B8;
} // Block from 82172498h-821724B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821724B8h
// Function '?ClearLocalRegisterAssignments@Compiler@D3DXShader@@QAAXPAVBlock@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821724B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821724B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821724B8);
		  /* 821724B8h */ case    0:  		/* cmpwi CR6, R3, -1 */
		/* 821724B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821724B8h case    0:*/		return 0x821724BC;
		  /* 821724BCh */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 821724BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821724E8;  }
		/* 821724BCh case    1:*/		return 0x821724C0;
		  /* 821724C0h */ case    2:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 821724C0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 821724C0h case    2:*/		return 0x821724C4;
		  /* 821724C4h */ case    3:  		/* bc 12, CR0_EQ, -80 */
		/* 821724C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82172474;  }
		/* 821724C4h case    3:*/		return 0x821724C8;
		  /* 821724C8h */ case    4:  		/* lwz R3, <#[R29]> */
		/* 821724C8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 821724C8h case    4:*/		return 0x821724CC;
		  /* 821724CCh */ case    5:  		/* lwz R11, <#[R3 + 792]> */
		/* 821724CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000318) );
		/* 821724CCh case    5:*/		return 0x821724D0;
		  /* 821724D0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821724D0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821724D0h case    6:*/		return 0x821724D4;
		  /* 821724D4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 821724D4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821724E0;  }
		/* 821724D4h case    7:*/		return 0x821724D8;
		  /* 821724D8h */ case    8:  		/* li R4, 3518 */
		/* 821724D8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0xDBE);
		/* 821724D8h case    8:*/		return 0x821724DC;
		  /* 821724DCh */ case    9:  		/* bl -132724 */
		/* 821724DCh case    9:*/		regs.LR = 0x821724E0; return 0x82151E68;
		/* 821724DCh case    9:*/		return 0x821724E0;
	}
	return 0x821724E0;
} // Block from 821724B8h-821724E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821724E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821724E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821724E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821724E0);
		  /* 821724E0h */ case    0:  		/* li R4, 3565 */
		/* 821724E0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDED);
		/* 821724E0h case    0:*/		return 0x821724E4;
		  /* 821724E4h */ case    1:  		/* bl -132732 */
		/* 821724E4h case    1:*/		regs.LR = 0x821724E8; return 0x82151E68;
		/* 821724E4h case    1:*/		return 0x821724E8;
	}
	return 0x821724E8;
} // Block from 821724E0h-821724E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821724E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821724E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821724E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821724E8);
		  /* 821724E8h */ case    0:  		/* mr R4, R30 */
		/* 821724E8h case    0:*/		regs.R4 = regs.R30;
		/* 821724E8h case    0:*/		return 0x821724EC;
		  /* 821724ECh */ case    1:  		/* rlwinm R3, R31, 0, 28, 31 */
		/* 821724ECh case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R31);
		/* 821724ECh case    1:*/		return 0x821724F0;
		  /* 821724F0h */ case    2:  		/* rlwinm R30, R31, 30, 2, 29 */
		/* 821724F0h case    2:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R30,regs.R31);
		/* 821724F0h case    2:*/		return 0x821724F4;
		  /* 821724F4h */ case    3:  		/* bl -6196 */
		/* 821724F4h case    3:*/		regs.LR = 0x821724F8; return 0x82170CC0;
		/* 821724F4h case    3:*/		return 0x821724F8;
		  /* 821724F8h */ case    4:  		/* mr R28, R3 */
		/* 821724F8h case    4:*/		regs.R28 = regs.R3;
		/* 821724F8h case    4:*/		return 0x821724FC;
		  /* 821724FCh */ case    5:  		/* addi R3, R29, 4 */
		/* 821724FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x4);
		/* 821724FCh case    5:*/		return 0x82172500;
		  /* 82172500h */ case    6:  		/* addi R5, R30, 3 */
		/* 82172500h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0x3);
		/* 82172500h case    6:*/		return 0x82172504;
		  /* 82172504h */ case    7:  		/* mr R6, R28 */
		/* 82172504h case    7:*/		regs.R6 = regs.R28;
		/* 82172504h case    7:*/		return 0x82172508;
		  /* 82172508h */ case    8:  		/* mr R4, R30 */
		/* 82172508h case    8:*/		regs.R4 = regs.R30;
		/* 82172508h case    8:*/		return 0x8217250C;
		  /* 8217250Ch */ case    9:  		/* bl -4100 */
		/* 8217250Ch case    9:*/		regs.LR = 0x82172510; return 0x82171508;
		/* 8217250Ch case    9:*/		return 0x82172510;
		  /* 82172510h */ case   10:  		/* mr R3, R28 */
		/* 82172510h case   10:*/		regs.R3 = regs.R28;
		/* 82172510h case   10:*/		return 0x82172514;
		  /* 82172514h */ case   11:  		/* rlwimi R3, R31, 0, 0, 27 */
		/* 82172514h case   11:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R3,regs.R31);
		/* 82172514h case   11:*/		return 0x82172518;
	}
	return 0x82172518;
} // Block from 821724E8h-82172518h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82172518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172518);
		  /* 82172518h */ case    0:  		/* addi R1, R1, 128 */
		/* 82172518h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82172518h case    0:*/		return 0x8217251C;
		  /* 8217251Ch */ case    1:  		/* b -922228 */
		/* 8217251Ch case    1:*/		return 0x820912A8;
		/* 8217251Ch case    1:*/		return 0x82172520;
	}
	return 0x82172520;
} // Block from 82172518h-82172520h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172520);
		  /* 82172520h */ case    0:  		/* mfspr R12, LR */
		/* 82172520h case    0:*/		regs.R12 = regs.LR;
		/* 82172520h case    0:*/		return 0x82172524;
		  /* 82172524h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82172524h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172524h case    1:*/		return 0x82172528;
		  /* 82172528h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172528h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172528h case    2:*/		return 0x8217252C;
		  /* 8217252Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8217252Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8217252Ch case    3:*/		return 0x82172530;
		  /* 82172530h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172530h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172530h case    4:*/		return 0x82172534;
		  /* 82172534h */ case    5:  		/* mr R30, R4 */
		/* 82172534h case    5:*/		regs.R30 = regs.R4;
		/* 82172534h case    5:*/		return 0x82172538;
		  /* 82172538h */ case    6:  		/* rlwinm R4, R4, 30, 2, 29 */
		/* 82172538h case    6:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R4,regs.R4);
		/* 82172538h case    6:*/		return 0x8217253C;
		  /* 8217253Ch */ case    7:  		/* mr R31, R3 */
		/* 8217253Ch case    7:*/		regs.R31 = regs.R3;
		/* 8217253Ch case    7:*/		return 0x82172540;
		  /* 82172540h */ case    8:  		/* rlwinm R6, R30, 0, 28, 31 */
		/* 82172540h case    8:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R30);
		/* 82172540h case    8:*/		return 0x82172544;
		  /* 82172544h */ case    9:  		/* addi R5, R4, 3 */
		/* 82172544h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 82172544h case    9:*/		return 0x82172548;
		  /* 82172548h */ case   10:  		/* addi R3, R3, 4 */
		/* 82172548h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82172548h case   10:*/		return 0x8217254C;
		  /* 8217254Ch */ case   11:  		/* bl -4052 */
		/* 8217254Ch case   11:*/		regs.LR = 0x82172550; return 0x82171578;
		/* 8217254Ch case   11:*/		return 0x82172550;
	}
	return 0x82172550;
} // Block from 82172520h-82172550h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82172550h
// Function '?RenumberBundles@Compiler@D3DXShader@@QAAXPAVBlock@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172550);
		  /* 82172550h */ case    0:  		/* li R5, 0 */
		/* 82172550h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82172550h case    0:*/		return 0x82172554;
		  /* 82172554h */ case    1:  		/* mr R4, R30 */
		/* 82172554h case    1:*/		regs.R4 = regs.R30;
		/* 82172554h case    1:*/		return 0x82172558;
		  /* 82172558h */ case    2:  		/* mr R3, R31 */
		/* 82172558h case    2:*/		regs.R3 = regs.R31;
		/* 82172558h case    2:*/		return 0x8217255C;
		  /* 8217255Ch */ case    3:  		/* bl -2644 */
		/* 8217255Ch case    3:*/		regs.LR = 0x82172560; return 0x82171B08;
		/* 8217255Ch case    3:*/		return 0x82172560;
		  /* 82172560h */ case    4:  		/* addi R1, R1, 112 */
		/* 82172560h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82172560h case    4:*/		return 0x82172564;
		  /* 82172564h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 82172564h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172564h case    5:*/		return 0x82172568;
		  /* 82172568h */ case    6:  		/* mtspr LR, R12 */
		/* 82172568h case    6:*/		regs.LR = regs.R12;
		/* 82172568h case    6:*/		return 0x8217256C;
		  /* 8217256Ch */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 8217256Ch case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8217256Ch case    7:*/		return 0x82172570;
		  /* 82172570h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 82172570h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172570h case    8:*/		return 0x82172574;
		  /* 82172574h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82172574h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172574h case    9:*/		return 0x82172578;
	}
	return 0x82172578;
} // Block from 82172550h-82172578h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82172578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172578);
		  /* 82172578h */ case    0:  		/* mfspr R12, LR */
		/* 82172578h case    0:*/		regs.R12 = regs.LR;
		/* 82172578h case    0:*/		return 0x8217257C;
		  /* 8217257Ch */ case    1:  		/* bl -922412 */
		/* 8217257Ch case    1:*/		regs.LR = 0x82172580; return 0x82091250;
		/* 8217257Ch case    1:*/		return 0x82172580;
		  /* 82172580h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82172580h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82172580h case    2:*/		return 0x82172584;
		  /* 82172584h */ case    3:  		/* lwz R28, <#[R4]> */
		/* 82172584h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x00000000) );
		/* 82172584h case    3:*/		return 0x82172588;
		  /* 82172588h */ case    4:  		/* mr R27, R4 */
		/* 82172588h case    4:*/		regs.R27 = regs.R4;
		/* 82172588h case    4:*/		return 0x8217258C;
		  /* 8217258Ch */ case    5:  		/* mr R30, R6 */
		/* 8217258Ch case    5:*/		regs.R30 = regs.R6;
		/* 8217258Ch case    5:*/		return 0x82172590;
		  /* 82172590h */ case    6:  		/* li R26, 0 */
		/* 82172590h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82172590h case    6:*/		return 0x82172594;
		  /* 82172594h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 82172594h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82172594h case    7:*/		return 0x82172598;
		  /* 82172598h */ case    8:  		/* bc 12, CR6_EQ, 192 */
		/* 82172598h case    8:*/		if ( regs.CR[6].eq ) { return 0x82172658;  }
		/* 82172598h case    8:*/		return 0x8217259C;
		  /* 8217259Ch */ case    9:  		/* lwz R11, <#[R28]> */
		/* 8217259Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8217259Ch case    9:*/		return 0x821725A0;
		  /* 821725A0h */ case   10:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 821725A0h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 821725A0h case   10:*/		return 0x821725A4;
		  /* 821725A4h */ case   11:  		/* bc 12, CR0_EQ, 172 */
		/* 821725A4h case   11:*/		if ( regs.CR[0].eq ) { return 0x82172650;  }
		/* 821725A4h case   11:*/		return 0x821725A8;
		  /* 821725A8h */ case   12:  		/* rlwinm. R10, R11, 2, 31, 31 */
		/* 821725A8h case   12:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R11);
		/* 821725A8h case   12:*/		return 0x821725AC;
		  /* 821725ACh */ case   13:  		/* bc 12, CR0_EQ, 164 */
		/* 821725ACh case   13:*/		if ( regs.CR[0].eq ) { return 0x82172650;  }
		/* 821725ACh case   13:*/		return 0x821725B0;
		  /* 821725B0h */ case   14:  		/* lwz R29, <#[R28 + 12]> */
		/* 821725B0h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x0000000C) );
		/* 821725B0h case   14:*/		return 0x821725B4;
		  /* 821725B4h */ case   15:  		/* lwz R10, <#[R29 + 8]> */
		/* 821725B4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821725B4h case   15:*/		return 0x821725B8;
		  /* 821725B8h */ case   16:  		/* rlwinm. R10, R10, 9, 31, 31 */
		/* 821725B8h case   16:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R10);
		/* 821725B8h case   16:*/		return 0x821725BC;
		  /* 821725BCh */ case   17:  		/* bc 12, CR0_EQ, 148 */
		/* 821725BCh case   17:*/		if ( regs.CR[0].eq ) { return 0x82172650;  }
		/* 821725BCh case   17:*/		return 0x821725C0;
		  /* 821725C0h */ case   18:  		/* rlwinm R4, R11, 17, 22, 29 */
		/* 821725C0h case   18:*/		cpu::op::rlwinm<0,17,22,29>(regs,&regs.R4,regs.R11);
		/* 821725C0h case   18:*/		return 0x821725C4;
		  /* 821725C4h */ case   19:  		/* addi R3, R30, 4 */
		/* 821725C4h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 821725C4h case   19:*/		return 0x821725C8;
		  /* 821725C8h */ case   20:  		/* addi R5, R4, 3 */
		/* 821725C8h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 821725C8h case   20:*/		return 0x821725CC;
		  /* 821725CCh */ case   21:  		/* rlwinm R31, R11, 19, 20, 31 */
		/* 821725CCh case   21:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R31,regs.R11);
		/* 821725CCh case   21:*/		return 0x821725D0;
		  /* 821725D0h */ case   22:  		/* bl -4440 */
		/* 821725D0h case   22:*/		regs.LR = 0x821725D4; return 0x82171478;
		/* 821725D0h case   22:*/		return 0x821725D4;
		  /* 821725D4h */ case   23:  		/* cmplwi CR0, R3, 0 */
		/* 821725D4h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821725D4h case   23:*/		return 0x821725D8;
		  /* 821725D8h */ case   24:  		/* bc 12, CR0_EQ, 120 */
		/* 821725D8h case   24:*/		if ( regs.CR[0].eq ) { return 0x82172650;  }
		/* 821725D8h case   24:*/		return 0x821725DC;
		  /* 821725DCh */ case   25:  		/* li R10, 1 */
		/* 821725DCh case   25:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821725DCh case   25:*/		return 0x821725E0;
		  /* 821725E0h */ case   26:  		/* and. R11, R10, R3 */
		/* 821725E0h case   26:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R3);
		/* 821725E0h case   26:*/		return 0x821725E4;
		  /* 821725E4h */ case   27:  		/* bc 12, CR0_EQ, 96 */
		/* 821725E4h case   27:*/		if ( regs.CR[0].eq ) { return 0x82172644;  }
		/* 821725E4h case   27:*/		return 0x821725E8;
		  /* 821725E8h */ case   28:  		/* mr R11, R10 */
		/* 821725E8h case   28:*/		regs.R11 = regs.R10;
		/* 821725E8h case   28:*/		return 0x821725EC;
		  /* 821725ECh */ case   29:  		/* lwz R9, <#[R30 + 8]> */
		/* 821725ECh case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 821725ECh case   29:*/		return 0x821725F0;
		  /* 821725F0h */ case   30:  		/* rlwimi R11, R31, 0, 0, 27 */
		/* 821725F0h case   30:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R31);
		/* 821725F0h case   30:*/		return 0x821725F4;
		  /* 821725F4h */ case   31:  		/* mr R8, R11 */
		/* 821725F4h case   31:*/		regs.R8 = regs.R11;
		/* 821725F4h case   31:*/		return 0x821725F8;
		  /* 821725F8h */ case   32:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 821725F8h case   32:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 821725F8h case   32:*/		return 0x821725FC;
		  /* 821725FCh */ case   33:  		/* rlwinm R8, R8, 30, 2, 29 */
		/* 821725FCh case   33:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R8,regs.R8);
		/* 821725FCh case   33:*/		return 0x82172600;
		  /* 82172600h */ case   34:  		/* addi R7, R11, -1 */
		/* 82172600h case   34:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 82172600h case   34:*/		return 0x82172604;
		  /* 82172604h */ case   35:  		/* andc R11, R11, R7 */
		/* 82172604h case   35:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82172604h case   35:*/		return 0x82172608;
		  /* 82172608h */ case   36:  		/* cntlzw R11, R11 */
		/* 82172608h case   36:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82172608h case   36:*/		return 0x8217260C;
		  /* 8217260Ch */ case   37:  		/* subf R11, R11, R8 */
		/* 8217260Ch case   37:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8217260Ch case   37:*/		return 0x82172610;
		  /* 82172610h */ case   38:  		/* addi R11, R11, 31 */
		/* 82172610h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82172610h case   38:*/		return 0x82172614;
		  /* 82172614h */ case   39:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82172614h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82172614h case   39:*/		return 0x82172618;
		  /* 82172618h */ case   40:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82172618h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82172618h case   40:*/		return 0x8217261C;
		  /* 8217261Ch */ case   41:  		/* cmplw CR6, R11, R29 */
		/* 8217261Ch case   41:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8217261Ch case   41:*/		return 0x82172620;
		  /* 82172620h */ case   42:  		/* bc 12, CR6_EQ, 36 */
		/* 82172620h case   42:*/		if ( regs.CR[6].eq ) { return 0x82172644;  }
		/* 82172620h case   42:*/		return 0x82172624;
		  /* 82172624h */ case   43:  		/* cmplw CR6, R11, R27 */
		/* 82172624h case   43:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 82172624h case   43:*/		return 0x82172628;
		  /* 82172628h */ case   44:  		/* bc 12, CR6_EQ, 28 */
		/* 82172628h case   44:*/		if ( regs.CR[6].eq ) { return 0x82172644;  }
		/* 82172628h case   44:*/		return 0x8217262C;
		  /* 8217262Ch */ case   45:  		/* lwz R11, <#[R11 + 8]> */
		/* 8217262Ch case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8217262Ch case   45:*/		return 0x82172630;
		  /* 82172630h */ case   46:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82172630h case   46:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82172630h case   46:*/		return 0x82172634;
		  /* 82172634h */ case   47:  		/* bc 12, CR0_EQ, 12 */
		/* 82172634h case   47:*/		if ( regs.CR[0].eq ) { return 0x82172640;  }
		/* 82172634h case   47:*/		return 0x82172638;
		  /* 82172638h */ case   48:  		/* ori R26, R26, 1 */
		/* 82172638h case   48:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82172638h case   48:*/		return 0x8217263C;
		  /* 8217263Ch */ case   49:  		/* b 8 */
		/* 8217263Ch case   49:*/		return 0x82172644;
		/* 8217263Ch case   49:*/		return 0x82172640;
	}
	return 0x82172640;
} // Block from 82172578h-82172640h (50 instructions)

//////////////////////////////////////////////////////
// Block at 82172640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172640);
		  /* 82172640h */ case    0:  		/* ori R26, R26, 2 */
		/* 82172640h case    0:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R26,0x2);
		/* 82172640h case    0:*/		return 0x82172644;
	}
	return 0x82172644;
} // Block from 82172640h-82172644h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172644);
		  /* 82172644h */ case    0:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 82172644h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 82172644h case    0:*/		return 0x82172648;
		  /* 82172648h */ case    1:  		/* cmplwi CR6, R10, 16 */
		/* 82172648h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000010);
		/* 82172648h case    1:*/		return 0x8217264C;
		  /* 8217264Ch */ case    2:  		/* bc 12, CR6_LT, -108 */
		/* 8217264Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x821725E0;  }
		/* 8217264Ch case    2:*/		return 0x82172650;
	}
	return 0x82172650;
} // Block from 82172644h-82172650h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82172650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172650);
		  /* 82172650h */ case    0:  		/* lwz R28, <#[R28 + 4]> */
		/* 82172650h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000004) );
		/* 82172650h case    0:*/		return 0x82172654;
		  /* 82172654h */ case    1:  		/* b -192 */
		/* 82172654h case    1:*/		return 0x82172594;
		/* 82172654h case    1:*/		return 0x82172658;
	}
	return 0x82172658;
} // Block from 82172650h-82172658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172658);
		  /* 82172658h */ case    0:  		/* mr R3, R26 */
		/* 82172658h case    0:*/		regs.R3 = regs.R26;
		/* 82172658h case    0:*/		return 0x8217265C;
		  /* 8217265Ch */ case    1:  		/* addi R1, R1, 144 */
		/* 8217265Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8217265Ch case    1:*/		return 0x82172660;
		  /* 82172660h */ case    2:  		/* b -922560 */
		/* 82172660h case    2:*/		return 0x820912A0;
		/* 82172660h case    2:*/		return 0x82172664;
		  /* 82172664h */ case    3:  		/* nop */
		/* 82172664h case    3:*/		cpu::op::nop();
		/* 82172664h case    3:*/		return 0x82172668;
	}
	return 0x82172668;
} // Block from 82172658h-82172668h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82172668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172668);
		  /* 82172668h */ case    0:  		/* mfspr R12, LR */
		/* 82172668h case    0:*/		regs.R12 = regs.LR;
		/* 82172668h case    0:*/		return 0x8217266C;
		  /* 8217266Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8217266Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8217266Ch case    1:*/		return 0x82172670;
		  /* 82172670h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172670h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172670h case    2:*/		return 0x82172674;
		  /* 82172674h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82172674h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172674h case    3:*/		return 0x82172678;
		  /* 82172678h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172678h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172678h case    4:*/		return 0x8217267C;
		  /* 8217267Ch */ case    5:  		/* li R5, 54 */
		/* 8217267Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x36);
		/* 8217267Ch case    5:*/		return 0x82172680;
		  /* 82172680h */ case    6:  		/* li R4, 32 */
		/* 82172680h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 82172680h case    6:*/		return 0x82172684;
		  /* 82172684h */ case    7:  		/* mr R31, R3 */
		/* 82172684h case    7:*/		regs.R31 = regs.R3;
		/* 82172684h case    7:*/		return 0x82172688;
		  /* 82172688h */ case    8:  		/* bl -56728 */
		/* 82172688h case    8:*/		regs.LR = 0x8217268C; return 0x821648F0;
		/* 82172688h case    8:*/		return 0x8217268C;
		  /* 8217268Ch */ case    9:  		/* mr R30, R3 */
		/* 8217268Ch case    9:*/		regs.R30 = regs.R3;
		/* 8217268Ch case    9:*/		return 0x82172690;
		  /* 82172690h */ case   10:  		/* li R5, 36 */
		/* 82172690h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 82172690h case   10:*/		return 0x82172694;
		  /* 82172694h */ case   11:  		/* li R4, 8 */
		/* 82172694h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82172694h case   11:*/		return 0x82172698;
		  /* 82172698h */ case   12:  		/* mr R3, R31 */
		/* 82172698h case   12:*/		regs.R3 = regs.R31;
		/* 82172698h case   12:*/		return 0x8217269C;
		  /* 8217269Ch */ case   13:  		/* bl -56748 */
		/* 8217269Ch case   13:*/		regs.LR = 0x821726A0; return 0x821648F0;
		/* 8217269Ch case   13:*/		return 0x821726A0;
		  /* 821726A0h */ case   14:  		/* mr R11, R3 */
		/* 821726A0h case   14:*/		regs.R11 = regs.R3;
		/* 821726A0h case   14:*/		return 0x821726A4;
		  /* 821726A4h */ case   15:  		/* addi R10, R3, 4 */
		/* 821726A4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x4);
		/* 821726A4h case   15:*/		return 0x821726A8;
		  /* 821726A8h */ case   16:  		/* stw R3, <#[R30 + 4]> */
		/* 821726A8h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 821726A8h case   16:*/		return 0x821726AC;
		  /* 821726ACh */ case   17:  		/* ori R9, R3, 1 */
		/* 821726ACh case   17:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R3,0x1);
		/* 821726ACh case   17:*/		return 0x821726B0;
		  /* 821726B0h */ case   18:  		/* ori R10, R10, 1 */
		/* 821726B0h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821726B0h case   18:*/		return 0x821726B4;
		  /* 821726B4h */ case   19:  		/* stw R9, <#[R3 + 4]> */
		/* 821726B4h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 821726B4h case   19:*/		return 0x821726B8;
		  /* 821726B8h */ case   20:  		/* mr R3, R30 */
		/* 821726B8h case   20:*/		regs.R3 = regs.R30;
		/* 821726B8h case   20:*/		return 0x821726BC;
		  /* 821726BCh */ case   21:  		/* stw R10, <#[R11]> */
		/* 821726BCh case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821726BCh case   21:*/		return 0x821726C0;
	}
	return 0x821726C0;
} // Block from 82172668h-821726C0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821726C0h
// Function '?AddGlobalOrderingDependencies@Compiler@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821726C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821726C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821726C0);
		  /* 821726C0h */ case    0:  		/* addi R1, R1, 112 */
		/* 821726C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821726C0h case    0:*/		return 0x821726C4;
		  /* 821726C4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821726C4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821726C4h case    1:*/		return 0x821726C8;
		  /* 821726C8h */ case    2:  		/* mtspr LR, R12 */
		/* 821726C8h case    2:*/		regs.LR = regs.R12;
		/* 821726C8h case    2:*/		return 0x821726CC;
		  /* 821726CCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821726CCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821726CCh case    3:*/		return 0x821726D0;
		  /* 821726D0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821726D0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821726D0h case    4:*/		return 0x821726D4;
		  /* 821726D4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821726D4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821726D4h case    5:*/		return 0x821726D8;
	}
	return 0x821726D8;
} // Block from 821726C0h-821726D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821726D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821726D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821726D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821726D8);
		  /* 821726D8h */ case    0:  		/* mfspr R12, LR */
		/* 821726D8h case    0:*/		regs.R12 = regs.LR;
		/* 821726D8h case    0:*/		return 0x821726DC;
		  /* 821726DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821726DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821726DCh case    1:*/		return 0x821726E0;
		  /* 821726E0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821726E0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821726E0h case    2:*/		return 0x821726E4;
		  /* 821726E4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821726E4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821726E4h case    3:*/		return 0x821726E8;
		  /* 821726E8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821726E8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821726E8h case    4:*/		return 0x821726EC;
		  /* 821726ECh */ case    5:  		/* mr R31, R3 */
		/* 821726ECh case    5:*/		regs.R31 = regs.R3;
		/* 821726ECh case    5:*/		return 0x821726F0;
		  /* 821726F0h */ case    6:  		/* lwz R3, <#[R4 + 4]> */
		/* 821726F0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000004) );
		/* 821726F0h case    6:*/		return 0x821726F4;
		  /* 821726F4h */ case    7:  		/* mr R30, R4 */
		/* 821726F4h case    7:*/		regs.R30 = regs.R4;
		/* 821726F4h case    7:*/		return 0x821726F8;
		  /* 821726F8h */ case    8:  		/* bl 520936 */
		/* 821726F8h case    8:*/		regs.LR = 0x821726FC; return 0x821F19E0;
		/* 821726F8h case    8:*/		return 0x821726FC;
		  /* 821726FCh */ case    9:  		/* addi R11, R31, 972 */
		/* 821726FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3CC);
		/* 821726FCh case    9:*/		return 0x82172700;
		  /* 82172700h */ case   10:  		/* lwz R10, <#[R30 + 4]> */
		/* 82172700h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82172700h case   10:*/		return 0x82172704;
		  /* 82172704h */ case   11:  		/* lwz R11, <#[R31 + 976]> */
		/* 82172704h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003D0) );
		/* 82172704h case   11:*/		return 0x82172708;
		  /* 82172708h */ case   12:  		/* stw R11, <#[R10]> */
		/* 82172708h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82172708h case   12:*/		return 0x8217270C;
		  /* 8217270Ch */ case   13:  		/* stw R10, <#[R31 + 976]> */
		/* 8217270Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x000003D0) );
		/* 8217270Ch case   13:*/		return 0x82172710;
		  /* 82172710h */ case   14:  		/* lwz R11, <#[R31 + 1000]> */
		/* 82172710h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003E8) );
		/* 82172710h case   14:*/		return 0x82172714;
		  /* 82172714h */ case   15:  		/* stw R11, <#[R30]> */
		/* 82172714h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82172714h case   15:*/		return 0x82172718;
		  /* 82172718h */ case   16:  		/* stw R30, <#[R31 + 1000]> */
		/* 82172718h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000003E8) );
		/* 82172718h case   16:*/		return 0x8217271C;
		  /* 8217271Ch */ case   17:  		/* addi R1, R1, 112 */
		/* 8217271Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8217271Ch case   17:*/		return 0x82172720;
		  /* 82172720h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 82172720h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172720h case   18:*/		return 0x82172724;
		  /* 82172724h */ case   19:  		/* mtspr LR, R12 */
		/* 82172724h case   19:*/		regs.LR = regs.R12;
		/* 82172724h case   19:*/		return 0x82172728;
		  /* 82172728h */ case   20:  		/* ld R30, <#[R1 - 24]> */
		/* 82172728h case   20:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172728h case   20:*/		return 0x8217272C;
		  /* 8217272Ch */ case   21:  		/* ld R31, <#[R1 - 16]> */
		/* 8217272Ch case   21:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8217272Ch case   21:*/		return 0x82172730;
		  /* 82172730h */ case   22:  		/* bclr 20, CR0_LT */
		/* 82172730h case   22:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172730h case   22:*/		return 0x82172734;
	}
	return 0x82172734;
} // Block from 821726D8h-82172734h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82172734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172734);
		  /* 82172734h */ case    0:  		/* nop */
		/* 82172734h case    0:*/		cpu::op::nop();
		/* 82172734h case    0:*/		return 0x82172738;
		  /* 82172738h */ case    1:  		/* lwz R9, <#[R4 + 4]> */
		/* 82172738h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000004) );
		/* 82172738h case    1:*/		return 0x8217273C;
		  /* 8217273Ch */ case    2:  		/* li R7, 0 */
		/* 8217273Ch case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8217273Ch case    2:*/		return 0x82172740;
		  /* 82172740h */ case    3:  		/* lwz R11, <#[R4 + 12]> */
		/* 82172740h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82172740h case    3:*/		return 0x82172744;
		  /* 82172744h */ case    4:  		/* lwz R10, <#[R4 + 20]> */
		/* 82172744h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 82172744h case    4:*/		return 0x82172748;
		  /* 82172748h */ case    5:  		/* add R5, R10, R11 */
		/* 82172748h case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 82172748h case    5:*/		return 0x8217274C;
		  /* 8217274Ch */ case    6:  		/* lwz R11, <#[R9 + 4]> */
		/* 8217274Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8217274Ch case    6:*/		return 0x82172750;
		  /* 82172750h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82172750h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82172750h case    7:*/		return 0x82172754;
		  /* 82172754h */ case    8:  		/* bc 4, CR0_EQ, 44 */
		/* 82172754h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82172780;  }
		/* 82172754h case    8:*/		return 0x82172758;
		  /* 82172758h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82172758h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82172758h case    9:*/		return 0x8217275C;
		  /* 8217275Ch */ case   10:  		/* bc 12, CR0_EQ, 36 */
		/* 8217275Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x82172780;  }
		/* 8217275Ch case   10:*/		return 0x82172760;
		  /* 82172760h */ case   11:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 82172760h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 82172760h case   11:*/		return 0x82172764;
		  /* 82172764h */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 82172764h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82172764h case   12:*/		return 0x82172768;
		  /* 82172768h */ case   13:  		/* add R7, R11, R7 */
		/* 82172768h case   13:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 82172768h case   13:*/		return 0x8217276C;
		  /* 8217276Ch */ case   14:  		/* lwz R11, <#[R10 + 4]> */
		/* 8217276Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8217276Ch case   14:*/		return 0x82172770;
		  /* 82172770h */ case   15:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82172770h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82172770h case   15:*/		return 0x82172774;
		  /* 82172774h */ case   16:  		/* bc 4, CR0_EQ, 12 */
		/* 82172774h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82172780;  }
		/* 82172774h case   16:*/		return 0x82172778;
		  /* 82172778h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 82172778h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82172778h case   17:*/		return 0x8217277C;
		  /* 8217277Ch */ case   18:  		/* bc 4, CR6_EQ, -28 */
		/* 8217277Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x82172760;  }
		/* 8217277Ch case   18:*/		return 0x82172780;
	}
	return 0x82172780;
} // Block from 82172734h-82172780h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82172780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172780);
		  /* 82172780h */ case    0:  		/* li R11, 0 */
		/* 82172780h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82172780h case    0:*/		return 0x82172784;
		  /* 82172784h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 82172784h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82172784h case    1:*/		return 0x82172788;
		  /* 82172788h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 82172788h case    2:*/		if ( regs.CR[6].eq ) { return 0x821727F4;  }
		/* 82172788h case    2:*/		return 0x8217278C;
		  /* 8217278Ch */ case    3:  		/* lwz R6, <#[R9 + 4]> */
		/* 8217278Ch case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000004) );
		/* 8217278Ch case    3:*/		return 0x82172790;
		  /* 82172790h */ case    4:  		/* rlwinm R10, R6, 0, 31, 31 */
		/* 82172790h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R6);
		/* 82172790h case    4:*/		return 0x82172794;
		  /* 82172794h */ case    5:  		/* mr R9, R11 */
		/* 82172794h case    5:*/		regs.R9 = regs.R11;
		/* 82172794h case    5:*/		return 0x82172798;
		  /* 82172798h */ case    6:  		/* addic R10, R10, -1 */
		/* 82172798h case    6:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82172798h case    6:*/		return 0x8217279C;
		  /* 8217279Ch */ case    7:  		/* subfe R10, R10, R10 */
		/* 8217279Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8217279Ch case    7:*/		return 0x821727A0;
		  /* 821727A0h */ case    8:  		/* and R10, R10, R6 */
		/* 821727A0h case    8:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 821727A0h case    8:*/		return 0x821727A4;
		  /* 821727A4h */ case    9:  		/* lwz R8, <#[R10 + 8]> */
		/* 821727A4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 821727A4h case    9:*/		return 0x821727A8;
		  /* 821727A8h */ case   10:  		/* cmplw CR6, R11, R8 */
		/* 821727A8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821727A8h case   10:*/		return 0x821727AC;
		  /* 821727ACh */ case   11:  		/* bc 12, CR6_LT, 44 */
		/* 821727ACh case   11:*/		if ( regs.CR[6].lt ) { return 0x821727D8;  }
		/* 821727ACh case   11:*/		return 0x821727B0;
		  /* 821727B0h */ case   12:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821727B0h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821727B0h case   12:*/		return 0x821727B4;
		  /* 821727B4h */ case   13:  		/* subf R9, R8, R9 */
		/* 821727B4h case   13:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821727B4h case   13:*/		return 0x821727B8;
		  /* 821727B8h */ case   14:  		/* lwz R10, <#[R10 + 4]> */
		/* 821727B8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821727B8h case   14:*/		return 0x821727BC;
		  /* 821727BCh */ case   15:  		/* rlwinm R8, R10, 0, 31, 31 */
		/* 821727BCh case   15:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R10);
		/* 821727BCh case   15:*/		return 0x821727C0;
		  /* 821727C0h */ case   16:  		/* addic R8, R8, -1 */
		/* 821727C0h case   16:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821727C0h case   16:*/		return 0x821727C4;
		  /* 821727C4h */ case   17:  		/* subfe R8, R8, R8 */
		/* 821727C4h case   17:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821727C4h case   17:*/		return 0x821727C8;
		  /* 821727C8h */ case   18:  		/* and R10, R8, R10 */
		/* 821727C8h case   18:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821727C8h case   18:*/		return 0x821727CC;
		  /* 821727CCh */ case   19:  		/* lwz R8, <#[R10 + 8]> */
		/* 821727CCh case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 821727CCh case   19:*/		return 0x821727D0;
		  /* 821727D0h */ case   20:  		/* cmplw CR6, R9, R8 */
		/* 821727D0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821727D0h case   20:*/		return 0x821727D4;
		  /* 821727D4h */ case   21:  		/* bc 4, CR6_LT, -36 */
		/* 821727D4h case   21:*/		if ( !regs.CR[6].lt ) { return 0x821727B0;  }
		/* 821727D4h case   21:*/		return 0x821727D8;
	}
	return 0x821727D8;
} // Block from 82172780h-821727D8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821727D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821727D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821727D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821727D8);
		  /* 821727D8h */ case    0:  		/* addi R9, R9, 4 */
		/* 821727D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821727D8h case    0:*/		return 0x821727DC;
		  /* 821727DCh */ case    1:  		/* addi R11, R11, 1 */
		/* 821727DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821727DCh case    1:*/		return 0x821727E0;
		  /* 821727E0h */ case    2:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821727E0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821727E0h case    2:*/		return 0x821727E4;
		  /* 821727E4h */ case    3:  		/* cmplw CR6, R11, R7 */
		/* 821727E4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 821727E4h case    3:*/		return 0x821727E8;
		  /* 821727E8h */ case    4:  		/* lwzx R10, <#[R9 + R10]> */
		/* 821727E8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821727E8h case    4:*/		return 0x821727EC;
		  /* 821727ECh */ case    5:  		/* add R5, R10, R5 */
		/* 821727ECh case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 821727ECh case    5:*/		return 0x821727F0;
		  /* 821727F0h */ case    6:  		/* bc 12, CR6_LT, -96 */
		/* 821727F0h case    6:*/		if ( regs.CR[6].lt ) { return 0x82172790;  }
		/* 821727F0h case    6:*/		return 0x821727F4;
	}
	return 0x821727F4;
} // Block from 821727D8h-821727F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821727F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821727F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821727F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821727F4);
		  /* 821727F4h */ case    0:  		/* stw R5, <#[R4 + 24]> */
		/* 821727F4h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x00000018) );
		/* 821727F4h case    0:*/		return 0x821727F8;
		  /* 821727F8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821727F8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821727F8h case    1:*/		return 0x821727FC;
	}
	return 0x821727FC;
} // Block from 821727F4h-821727FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821727FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821727FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821727FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821727FC);
		  /* 821727FCh */ case    0:  		/* nop */
		/* 821727FCh case    0:*/		cpu::op::nop();
		/* 821727FCh case    0:*/		return 0x82172800;
	}
	return 0x82172800;
} // Block from 821727FCh-82172800h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172800);
		  /* 82172800h */ case    0:  		/* mfspr R12, LR */
		/* 82172800h case    0:*/		regs.R12 = regs.LR;
		/* 82172800h case    0:*/		return 0x82172804;
		  /* 82172804h */ case    1:  		/* bl -923052 */
		/* 82172804h case    1:*/		regs.LR = 0x82172808; return 0x82091258;
		/* 82172804h case    1:*/		return 0x82172808;
		  /* 82172808h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82172808h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82172808h case    2:*/		return 0x8217280C;
		  /* 8217280Ch */ case    3:  		/* lwz R11, <#[R4 + 24]> */
		/* 8217280Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 8217280Ch case    3:*/		return 0x82172810;
		  /* 82172810h */ case    4:  		/* mr R31, R3 */
		/* 82172810h case    4:*/		regs.R31 = regs.R3;
		/* 82172810h case    4:*/		return 0x82172814;
		  /* 82172814h */ case    5:  		/* mr R30, R4 */
		/* 82172814h case    5:*/		regs.R30 = regs.R4;
		/* 82172814h case    5:*/		return 0x82172818;
		  /* 82172818h */ case    6:  		/* mr R28, R5 */
		/* 82172818h case    6:*/		regs.R28 = regs.R5;
		/* 82172818h case    6:*/		return 0x8217281C;
		  /* 8217281Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8217281Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217281Ch case    7:*/		return 0x82172820;
		  /* 82172820h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 82172820h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82172828;  }
		/* 82172820h case    8:*/		return 0x82172824;
		  /* 82172824h */ case    9:  		/* bl -236 */
		/* 82172824h case    9:*/		regs.LR = 0x82172828; return 0x82172738;
		/* 82172824h case    9:*/		return 0x82172828;
	}
	return 0x82172828;
} // Block from 82172800h-82172828h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82172828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172828);
		  /* 82172828h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 82172828h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82172828h case    0:*/		return 0x8217282C;
		  /* 8217282Ch */ case    1:  		/* li R10, 997 */
		/* 8217282Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x3E5);
		/* 8217282Ch case    1:*/		return 0x82172830;
		  /* 82172830h */ case    2:  		/* lwz R9, <#[R31 + 712]> */
		/* 82172830h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002C8) );
		/* 82172830h case    2:*/		return 0x82172834;
		  /* 82172834h */ case    3:  		/* divwu R10, R11, R10 */
		/* 82172834h case    3:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82172834h case    3:*/		return 0x82172838;
		  /* 82172838h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82172838h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82172838h case    4:*/		return 0x8217283C;
		  /* 8217283Ch */ case    5:  		/* mulli R10, R10, 997 */
		/* 8217283Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x3E5);
		/* 8217283Ch case    5:*/		return 0x82172840;
		  /* 82172840h */ case    6:  		/* subf R29, R10, R11 */
		/* 82172840h case    6:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 82172840h case    6:*/		return 0x82172844;
		  /* 82172844h */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 82172844h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82172858;  }
		/* 82172844h case    7:*/		return 0x82172848;
		  /* 82172848h */ case    8:  		/* li R4, 3988 */
		/* 82172848h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0xF94);
		/* 82172848h case    8:*/		return 0x8217284C;
		  /* 8217284Ch */ case    9:  		/* addi R3, R31, 972 */
		/* 8217284Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x3CC);
		/* 8217284Ch case    9:*/		return 0x82172850;
		  /* 82172850h */ case   10:  		/* bl -55616 */
		/* 82172850h case   10:*/		regs.LR = 0x82172854; return 0x82164F10;
		/* 82172850h case   10:*/		return 0x82172854;
		  /* 82172854h */ case   11:  		/* stw R3, <#[R31 + 712]> */
		/* 82172854h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000002C8) );
		/* 82172854h case   11:*/		return 0x82172858;
	}
	return 0x82172858;
} // Block from 82172828h-82172858h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82172858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172858);
		  /* 82172858h */ case    0:  		/* lwz R11, <#[R31 + 712]> */
		/* 82172858h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002C8) );
		/* 82172858h case    0:*/		return 0x8217285C;
		  /* 8217285Ch */ case    1:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 8217285Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 8217285Ch case    1:*/		return 0x82172860;
		  /* 82172860h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82172860h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82172860h case    2:*/		return 0x82172864;
		  /* 82172864h */ case    3:  		/* stw R11, <#[R30 + 28]> */
		/* 82172864h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82172864h case    3:*/		return 0x82172868;
		  /* 82172868h */ case    4:  		/* lwz R11, <#[R31 + 712]> */
		/* 82172868h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002C8) );
		/* 82172868h case    4:*/		return 0x8217286C;
		  /* 8217286Ch */ case    5:  		/* stwx R30, <#[R10 + R11]> */
		/* 8217286Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8217286Ch case    5:*/		return 0x82172870;
		  /* 82172870h */ case    6:  		/* lwz R11, <#[R31 + 716]> */
		/* 82172870h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002CC) );
		/* 82172870h case    6:*/		return 0x82172874;
		  /* 82172874h */ case    7:  		/* addi R11, R11, 1 */
		/* 82172874h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82172874h case    7:*/		return 0x82172878;
		  /* 82172878h */ case    8:  		/* stw R11, <#[R31 + 716]> */
		/* 82172878h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000002CC) );
		/* 82172878h case    8:*/		return 0x8217287C;
		  /* 8217287Ch */ case    9:  		/* cmplwi CR6, R11, 25000 */
		/* 8217287Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000061A8);
		/* 8217287Ch case    9:*/		return 0x82172880;
		  /* 82172880h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 82172880h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8217288C;  }
		/* 82172880h case   10:*/		return 0x82172884;
		  /* 82172884h */ case   11:  		/* li R3, 0 */
		/* 82172884h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82172884h case   11:*/		return 0x82172888;
		  /* 82172888h */ case   12:  		/* b 112 */
		/* 82172888h case   12:*/		return 0x821728F8;
		/* 82172888h case   12:*/		return 0x8217288C;
	}
	return 0x8217288C;
} // Block from 82172858h-8217288Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8217288Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217288C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217288C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217288C);
		  /* 8217288Ch */ case    0:  		/* lwz R10, <#[R28 + 28]> */
		/* 8217288Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000001C) );
		/* 8217288Ch case    0:*/		return 0x82172890;
		  /* 82172890h */ case    1:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 82172890h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 82172890h case    1:*/		return 0x82172894;
		  /* 82172894h */ case    2:  		/* bc 4, CR0_EQ, 96 */
		/* 82172894h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821728F4;  }
		/* 82172894h case    2:*/		return 0x82172898;
		  /* 82172898h */ case    3:  		/* cmplwi CR0, R10, 0 */
		/* 82172898h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82172898h case    3:*/		return 0x8217289C;
		  /* 8217289Ch */ case    4:  		/* bc 12, CR0_EQ, 88 */
		/* 8217289Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x821728F4;  }
		/* 8217289Ch case    4:*/		return 0x821728A0;
		  /* 821728A0h */ case    5:  		/* lwz R11, <#[R10 + 8]> */
		/* 821728A0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821728A0h case    5:*/		return 0x821728A4;
		  /* 821728A4h */ case    6:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821728A4h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821728A4h case    6:*/		return 0x821728A8;
		  /* 821728A8h */ case    7:  		/* bc 12, CR0_EQ, 52 */
		/* 821728A8h case    7:*/		if ( regs.CR[0].eq ) { return 0x821728DC;  }
		/* 821728A8h case    7:*/		return 0x821728AC;
		  /* 821728ACh */ case    8:  		/* lwz R11, <#[R10 + 16]> */
		/* 821728ACh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821728ACh case    8:*/		return 0x821728B0;
		  /* 821728B0h */ case    9:  		/* lwz R8, <#[R10 + 20]> */
		/* 821728B0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 821728B0h case    9:*/		return 0x821728B4;
		  /* 821728B4h */ case   10:  		/* rlwinm R11, R11, 12, 21, 24 */
		/* 821728B4h case   10:*/		cpu::op::rlwinm<0,12,21,24>(regs,&regs.R11,regs.R11);
		/* 821728B4h case   10:*/		return 0x821728B8;
		  /* 821728B8h */ case   11:  		/* lwz R9, <#[R31 + 724]> */
		/* 821728B8h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002D4) );
		/* 821728B8h case   11:*/		return 0x821728BC;
		  /* 821728BCh */ case   12:  		/* rlwinm R8, R8, 7, 25, 31 */
		/* 821728BCh case   12:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R8,regs.R8);
		/* 821728BCh case   12:*/		return 0x821728C0;
		  /* 821728C0h */ case   13:  		/* or R11, R11, R8 */
		/* 821728C0h case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821728C0h case   13:*/		return 0x821728C4;
		  /* 821728C4h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821728C4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821728C4h case   14:*/		return 0x821728C8;
		  /* 821728C8h */ case   15:  		/* add R11, R11, R9 */
		/* 821728C8h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821728C8h case   15:*/		return 0x821728CC;
		  /* 821728CCh */ case   16:  		/* addi R9, R11, -4 */
		/* 821728CCh case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 821728CCh case   16:*/		return 0x821728D0;
		  /* 821728D0h */ case   17:  		/* lwz R9, <#[R11 - 4]> */
		/* 821728D0h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 821728D0h case   17:*/		return 0x821728D4;
		  /* 821728D4h */ case   18:  		/* addi R9, R9, 1 */
		/* 821728D4h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821728D4h case   18:*/		return 0x821728D8;
		  /* 821728D8h */ case   19:  		/* stw R9, <#[R11 - 4]> */
		/* 821728D8h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 821728D8h case   19:*/		return 0x821728DC;
	}
	return 0x821728DC;
} // Block from 8217288Ch-821728DCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 821728DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821728DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821728DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821728DC);
		  /* 821728DCh */ case    0:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 821728DCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 821728DCh case    0:*/		return 0x821728E0;
		  /* 821728E0h */ case    1:  		/* lwz R10, <#[R11 + 40]> */
		/* 821728E0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 821728E0h case    1:*/		return 0x821728E4;
		  /* 821728E4h */ case    2:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 821728E4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 821728E4h case    2:*/		return 0x821728E8;
		  /* 821728E8h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821728E8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821728F4;  }
		/* 821728E8h case    3:*/		return 0x821728EC;
		  /* 821728ECh */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821728ECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821728ECh case    4:*/		return 0x821728F0;
		  /* 821728F0h */ case    5:  		/* bc 4, CR6_EQ, -80 */
		/* 821728F0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821728A0;  }
		/* 821728F0h case    5:*/		return 0x821728F4;
	}
	return 0x821728F4;
} // Block from 821728DCh-821728F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821728F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821728F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821728F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821728F4);
		  /* 821728F4h */ case    0:  		/* li R3, 1 */
		/* 821728F4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821728F4h case    0:*/		return 0x821728F8;
	}
	return 0x821728F8;
} // Block from 821728F4h-821728F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821728F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821728F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821728F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821728F8);
		  /* 821728F8h */ case    0:  		/* addi R1, R1, 128 */
		/* 821728F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821728F8h case    0:*/		return 0x821728FC;
		  /* 821728FCh */ case    1:  		/* b -923220 */
		/* 821728FCh case    1:*/		return 0x820912A8;
		/* 821728FCh case    1:*/		return 0x82172900;
	}
	return 0x82172900;
} // Block from 821728F8h-82172900h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172900);
		  /* 82172900h */ case    0:  		/* mfspr R12, LR */
		/* 82172900h case    0:*/		regs.R12 = regs.LR;
		/* 82172900h case    0:*/		return 0x82172904;
		  /* 82172904h */ case    1:  		/* bl -923320 */
		/* 82172904h case    1:*/		regs.LR = 0x82172908; return 0x8209124C;
		/* 82172904h case    1:*/		return 0x82172908;
		  /* 82172908h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82172908h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82172908h case    2:*/		return 0x8217290C;
		  /* 8217290Ch */ case    3:  		/* lwz R11, <#[R3 + 712]> */
		/* 8217290Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000002C8) );
		/* 8217290Ch case    3:*/		return 0x82172910;
		  /* 82172910h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82172910h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82172910h case    4:*/		return 0x82172914;
		  /* 82172914h */ case    5:  		/* bc 12, CR6_EQ, 488 */
		/* 82172914h case    5:*/		if ( regs.CR[6].eq ) { return 0x82172AFC;  }
		/* 82172914h case    5:*/		return 0x82172918;
	}
	return 0x82172918;
} // Block from 82172900h-82172918h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172918h
// Function '?Contains@?$ArrayList@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172918);
		  /* 82172918h */ case    0:  		/* lwz R11, <#[R4 + 24]> */
		/* 82172918h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 82172918h case    0:*/		return 0x8217291C;
		  /* 8217291Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8217291Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217291Ch case    1:*/		return 0x82172920;
		  /* 82172920h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 82172920h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82172928;  }
		/* 82172920h case    2:*/		return 0x82172924;
		  /* 82172924h */ case    3:  		/* bl -492 */
		/* 82172924h case    3:*/		regs.LR = 0x82172928; return 0x82172738;
		/* 82172924h case    3:*/		return 0x82172928;
	}
	return 0x82172928;
} // Block from 82172918h-82172928h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82172928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172928);
		  /* 82172928h */ case    0:  		/* lwz R25, <#[R4 + 24]> */
		/* 82172928h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R4 + 0x00000018) );
		/* 82172928h case    0:*/		return 0x8217292C;
		  /* 8217292Ch */ case    1:  		/* li R11, 997 */
		/* 8217292Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x3E5);
		/* 8217292Ch case    1:*/		return 0x82172930;
		  /* 82172930h */ case    2:  		/* lwz R26, <#[R4 + 4]> */
		/* 82172930h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R4 + 0x00000004) );
		/* 82172930h case    2:*/		return 0x82172934;
		  /* 82172934h */ case    3:  		/* li R27, 0 */
		/* 82172934h case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82172934h case    3:*/		return 0x82172938;
		  /* 82172938h */ case    4:  		/* divwu R10, R25, R11 */
		/* 82172938h case    4:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R25,regs.R11);
		/* 82172938h case    4:*/		return 0x8217293C;
		  /* 8217293Ch */ case    5:  		/* mulli R10, R10, 997 */
		/* 8217293Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x3E5);
		/* 8217293Ch case    5:*/		return 0x82172940;
		  /* 82172940h */ case    6:  		/* lwz R11, <#[R26 + 4]> */
		/* 82172940h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82172940h case    6:*/		return 0x82172944;
		  /* 82172944h */ case    7:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82172944h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82172944h case    7:*/		return 0x82172948;
		  /* 82172948h */ case    8:  		/* subf R10, R10, R25 */
		/* 82172948h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R25);
		/* 82172948h case    8:*/		return 0x8217294C;
		  /* 8217294Ch */ case    9:  		/* bc 4, CR0_EQ, 44 */
		/* 8217294Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x82172978;  }
		/* 8217294Ch case    9:*/		return 0x82172950;
		  /* 82172950h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82172950h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82172950h case   10:*/		return 0x82172954;
		  /* 82172954h */ case   11:  		/* bc 12, CR0_EQ, 36 */
		/* 82172954h case   11:*/		if ( regs.CR[0].eq ) { return 0x82172978;  }
		/* 82172954h case   11:*/		return 0x82172958;
		  /* 82172958h */ case   12:  		/* rlwinm R9, R11, 0, 0, 30 */
		/* 82172958h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R11);
		/* 82172958h case   12:*/		return 0x8217295C;
		  /* 8217295Ch */ case   13:  		/* lwz R11, <#[R11 + 8]> */
		/* 8217295Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8217295Ch case   13:*/		return 0x82172960;
		  /* 82172960h */ case   14:  		/* add R27, R11, R27 */
		/* 82172960h case   14:*/		cpu::op::add<0>(regs,&regs.R27,regs.R11,regs.R27);
		/* 82172960h case   14:*/		return 0x82172964;
		  /* 82172964h */ case   15:  		/* lwz R11, <#[R9 + 4]> */
		/* 82172964h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82172964h case   15:*/		return 0x82172968;
		  /* 82172968h */ case   16:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82172968h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82172968h case   16:*/		return 0x8217296C;
		  /* 8217296Ch */ case   17:  		/* bc 4, CR0_EQ, 12 */
		/* 8217296Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x82172978;  }
		/* 8217296Ch case   17:*/		return 0x82172970;
		  /* 82172970h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 82172970h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82172970h case   18:*/		return 0x82172974;
		  /* 82172974h */ case   19:  		/* bc 4, CR6_EQ, -28 */
		/* 82172974h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82172958;  }
		/* 82172974h case   19:*/		return 0x82172978;
	}
	return 0x82172978;
} // Block from 82172928h-82172978h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82172978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172978);
		  /* 82172978h */ case    0:  		/* lwz R11, <#[R3 + 712]> */
		/* 82172978h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000002C8) );
		/* 82172978h case    0:*/		return 0x8217297C;
		  /* 8217297Ch */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8217297Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8217297Ch case    1:*/		return 0x82172980;
		  /* 82172980h */ case    2:  		/* lwzx R28, <#[R10 + R11]> */
		/* 82172980h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82172980h case    2:*/		return 0x82172984;
		  /* 82172984h */ case    3:  		/* b 368 */
		/* 82172984h case    3:*/		return 0x82172AF4;
		/* 82172984h case    3:*/		return 0x82172988;
		  /* 82172988h */ case    4:  		/* lwz R11, <#[R28 + 24]> */
		/* 82172988h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000018) );
		/* 82172988h case    4:*/		return 0x8217298C;
		  /* 8217298Ch */ case    5:  		/* cmplw CR6, R11, R25 */
		/* 8217298Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8217298Ch case    5:*/		return 0x82172990;
	}
	return 0x82172990;
} // Block from 82172978h-82172990h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172990h
// Function '?Insert@?$ArrayListEnumerator@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172990);
		  /* 82172990h */ case    0:  		/* bc 4, CR6_EQ, 352 */
		/* 82172990h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82172AF0;  }
		/* 82172990h case    0:*/		return 0x82172994;
		  /* 82172994h */ case    1:  		/* lwz R11, <#[R28 + 12]> */
		/* 82172994h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 82172994h case    1:*/		return 0x82172998;
		  /* 82172998h */ case    2:  		/* lwz R10, <#[R4 + 12]> */
		/* 82172998h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 82172998h case    2:*/		return 0x8217299C;
		  /* 8217299Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8217299Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8217299Ch case    3:*/		return 0x821729A0;
		  /* 821729A0h */ case    4:  		/* bc 4, CR6_EQ, 336 */
		/* 821729A0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82172AF0;  }
		/* 821729A0h case    4:*/		return 0x821729A4;
		  /* 821729A4h */ case    5:  		/* lwz R11, <#[R28 + 20]> */
		/* 821729A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821729A4h case    5:*/		return 0x821729A8;
		  /* 821729A8h */ case    6:  		/* lwz R10, <#[R4 + 20]> */
		/* 821729A8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 821729A8h case    6:*/		return 0x821729AC;
		  /* 821729ACh */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 821729ACh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821729ACh case    7:*/		return 0x821729B0;
		  /* 821729B0h */ case    8:  		/* bc 4, CR6_EQ, 320 */
		/* 821729B0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82172AF0;  }
		/* 821729B0h case    8:*/		return 0x821729B4;
		  /* 821729B4h */ case    9:  		/* lwz R29, <#[R28 + 4]> */
		/* 821729B4h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000004) );
		/* 821729B4h case    9:*/		return 0x821729B8;
		  /* 821729B8h */ case   10:  		/* li R3, 0 */
		/* 821729B8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821729B8h case   10:*/		return 0x821729BC;
		  /* 821729BCh */ case   11:  		/* lwz R11, <#[R29 + 4]> */
		/* 821729BCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821729BCh case   11:*/		return 0x821729C0;
		  /* 821729C0h */ case   12:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821729C0h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821729C0h case   12:*/		return 0x821729C4;
		  /* 821729C4h */ case   13:  		/* bc 4, CR0_EQ, 44 */
		/* 821729C4h case   13:*/		if ( !regs.CR[0].eq ) { return 0x821729F0;  }
		/* 821729C4h case   13:*/		return 0x821729C8;
		  /* 821729C8h */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 821729C8h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821729C8h case   14:*/		return 0x821729CC;
		  /* 821729CCh */ case   15:  		/* bc 12, CR0_EQ, 36 */
		/* 821729CCh case   15:*/		if ( regs.CR[0].eq ) { return 0x821729F0;  }
		/* 821729CCh case   15:*/		return 0x821729D0;
		  /* 821729D0h */ case   16:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 821729D0h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 821729D0h case   16:*/		return 0x821729D4;
		  /* 821729D4h */ case   17:  		/* lwz R11, <#[R11 + 8]> */
		/* 821729D4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821729D4h case   17:*/		return 0x821729D8;
		  /* 821729D8h */ case   18:  		/* add R3, R11, R3 */
		/* 821729D8h case   18:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 821729D8h case   18:*/		return 0x821729DC;
		  /* 821729DCh */ case   19:  		/* lwz R11, <#[R10 + 4]> */
		/* 821729DCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821729DCh case   19:*/		return 0x821729E0;
		  /* 821729E0h */ case   20:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821729E0h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821729E0h case   20:*/		return 0x821729E4;
		  /* 821729E4h */ case   21:  		/* bc 4, CR0_EQ, 12 */
		/* 821729E4h case   21:*/		if ( !regs.CR[0].eq ) { return 0x821729F0;  }
		/* 821729E4h case   21:*/		return 0x821729E8;
		  /* 821729E8h */ case   22:  		/* cmplwi CR6, R11, 0 */
		/* 821729E8h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821729E8h case   22:*/		return 0x821729EC;
		  /* 821729ECh */ case   23:  		/* bc 4, CR6_EQ, -28 */
		/* 821729ECh case   23:*/		if ( !regs.CR[6].eq ) { return 0x821729D0;  }
		/* 821729ECh case   23:*/		return 0x821729F0;
	}
	return 0x821729F0;
} // Block from 82172990h-821729F0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821729F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821729F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821729F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821729F0);
		  /* 821729F0h */ case    0:  		/* cmplw CR6, R3, R27 */
		/* 821729F0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R27);
		/* 821729F0h case    0:*/		return 0x821729F4;
		  /* 821729F4h */ case    1:  		/* bc 4, CR6_EQ, 252 */
		/* 821729F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82172AF0;  }
		/* 821729F4h case    1:*/		return 0x821729F8;
		  /* 821729F8h */ case    2:  		/* li R5, 0 */
		/* 821729F8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821729F8h case    2:*/		return 0x821729FC;
		  /* 821729FCh */ case    3:  		/* cmplwi CR6, R27, 0 */
		/* 821729FCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821729FCh case    3:*/		return 0x82172A00;
		  /* 82172A00h */ case    4:  		/* bc 12, CR6_EQ, 232 */
		/* 82172A00h case    4:*/		if ( regs.CR[6].eq ) { return 0x82172AE8;  }
		/* 82172A00h case    4:*/		return 0x82172A04;
		  /* 82172A04h */ case    5:  		/* lwz R31, <#[R26 + 4]> */
		/* 82172A04h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000004) );
		/* 82172A04h case    5:*/		return 0x82172A08;
		  /* 82172A08h */ case    6:  		/* rlwinm R30, R31, 0, 31, 31 */
		/* 82172A08h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R30,regs.R31);
		/* 82172A08h case    6:*/		return 0x82172A0C;
		  /* 82172A0Ch */ case    7:  		/* addic R11, R30, -1 */
		/* 82172A0Ch case    7:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 82172A0Ch case    7:*/		return 0x82172A10;
		  /* 82172A10h */ case    8:  		/* mr R10, R5 */
		/* 82172A10h case    8:*/		regs.R10 = regs.R5;
		/* 82172A10h case    8:*/		return 0x82172A14;
		  /* 82172A14h */ case    9:  		/* subfe R11, R11, R11 */
		/* 82172A14h case    9:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82172A14h case    9:*/		return 0x82172A18;
		  /* 82172A18h */ case   10:  		/* and R11, R11, R31 */
		/* 82172A18h case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82172A18h case   10:*/		return 0x82172A1C;
		  /* 82172A1Ch */ case   11:  		/* lwz R9, <#[R11 + 8]> */
		/* 82172A1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82172A1Ch case   11:*/		return 0x82172A20;
		  /* 82172A20h */ case   12:  		/* cmplw CR6, R5, R9 */
		/* 82172A20h case   12:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R9);
		/* 82172A20h case   12:*/		return 0x82172A24;
		  /* 82172A24h */ case   13:  		/* bc 12, CR6_LT, 44 */
		/* 82172A24h case   13:*/		if ( regs.CR[6].lt ) { return 0x82172A50;  }
		/* 82172A24h case   13:*/		return 0x82172A28;
		  /* 82172A28h */ case   14:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82172A28h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82172A28h case   14:*/		return 0x82172A2C;
		  /* 82172A2Ch */ case   15:  		/* subf R10, R9, R10 */
		/* 82172A2Ch case   15:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82172A2Ch case   15:*/		return 0x82172A30;
		  /* 82172A30h */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 82172A30h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82172A30h case   16:*/		return 0x82172A34;
		  /* 82172A34h */ case   17:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 82172A34h case   17:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82172A34h case   17:*/		return 0x82172A38;
		  /* 82172A38h */ case   18:  		/* addic R9, R9, -1 */
		/* 82172A38h case   18:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82172A38h case   18:*/		return 0x82172A3C;
		  /* 82172A3Ch */ case   19:  		/* subfe R9, R9, R9 */
		/* 82172A3Ch case   19:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 82172A3Ch case   19:*/		return 0x82172A40;
		  /* 82172A40h */ case   20:  		/* and R11, R9, R11 */
		/* 82172A40h case   20:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82172A40h case   20:*/		return 0x82172A44;
		  /* 82172A44h */ case   21:  		/* lwz R9, <#[R11 + 8]> */
		/* 82172A44h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82172A44h case   21:*/		return 0x82172A48;
		  /* 82172A48h */ case   22:  		/* cmplw CR6, R10, R9 */
		/* 82172A48h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82172A48h case   22:*/		return 0x82172A4C;
		  /* 82172A4Ch */ case   23:  		/* bc 4, CR6_LT, -36 */
		/* 82172A4Ch case   23:*/		if ( !regs.CR[6].lt ) { return 0x82172A28;  }
		/* 82172A4Ch case   23:*/		return 0x82172A50;
	}
	return 0x82172A50;
} // Block from 821729F0h-82172A50h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82172A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172A50);
		  /* 82172A50h */ case    0:  		/* addi R10, R10, 4 */
		/* 82172A50h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82172A50h case    0:*/		return 0x82172A54;
		  /* 82172A54h */ case    1:  		/* li R8, 0 */
		/* 82172A54h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82172A54h case    1:*/		return 0x82172A58;
		  /* 82172A58h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82172A58h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82172A58h case    2:*/		return 0x82172A5C;
		  /* 82172A5Ch */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 82172A5Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82172A5Ch case    3:*/		return 0x82172A60;
		  /* 82172A60h */ case    4:  		/* lwzx R6, <#[R10 + R11]> */
		/* 82172A60h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82172A60h case    4:*/		return 0x82172A64;
		  /* 82172A64h */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 82172A64h case    5:*/		if ( regs.CR[6].eq ) { return 0x82172AD4;  }
		/* 82172A64h case    5:*/		return 0x82172A68;
		  /* 82172A68h */ case    6:  		/* lwz R7, <#[R29 + 4]> */
		/* 82172A68h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x00000004) );
		/* 82172A68h case    6:*/		return 0x82172A6C;
		  /* 82172A6Ch */ case    7:  		/* rlwinm R11, R7, 0, 31, 31 */
		/* 82172A6Ch case    7:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R7);
		/* 82172A6Ch case    7:*/		return 0x82172A70;
		  /* 82172A70h */ case    8:  		/* mr R9, R8 */
		/* 82172A70h case    8:*/		regs.R9 = regs.R8;
		/* 82172A70h case    8:*/		return 0x82172A74;
		  /* 82172A74h */ case    9:  		/* addic R11, R11, -1 */
		/* 82172A74h case    9:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82172A74h case    9:*/		return 0x82172A78;
		  /* 82172A78h */ case   10:  		/* subfe R11, R11, R11 */
		/* 82172A78h case   10:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82172A78h case   10:*/		return 0x82172A7C;
		  /* 82172A7Ch */ case   11:  		/* and R11, R11, R7 */
		/* 82172A7Ch case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82172A7Ch case   11:*/		return 0x82172A80;
		  /* 82172A80h */ case   12:  		/* lwz R10, <#[R11 + 8]> */
		/* 82172A80h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82172A80h case   12:*/		return 0x82172A84;
		  /* 82172A84h */ case   13:  		/* cmplw CR6, R8, R10 */
		/* 82172A84h case   13:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82172A84h case   13:*/		return 0x82172A88;
		  /* 82172A88h */ case   14:  		/* bc 12, CR6_LT, 44 */
		/* 82172A88h case   14:*/		if ( regs.CR[6].lt ) { return 0x82172AB4;  }
		/* 82172A88h case   14:*/		return 0x82172A8C;
		  /* 82172A8Ch */ case   15:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82172A8Ch case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82172A8Ch case   15:*/		return 0x82172A90;
		  /* 82172A90h */ case   16:  		/* subf R9, R10, R9 */
		/* 82172A90h case   16:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82172A90h case   16:*/		return 0x82172A94;
		  /* 82172A94h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 82172A94h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82172A94h case   17:*/		return 0x82172A98;
		  /* 82172A98h */ case   18:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82172A98h case   18:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82172A98h case   18:*/		return 0x82172A9C;
		  /* 82172A9Ch */ case   19:  		/* addic R10, R10, -1 */
		/* 82172A9Ch case   19:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82172A9Ch case   19:*/		return 0x82172AA0;
		  /* 82172AA0h */ case   20:  		/* subfe R10, R10, R10 */
		/* 82172AA0h case   20:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82172AA0h case   20:*/		return 0x82172AA4;
		  /* 82172AA4h */ case   21:  		/* and R11, R10, R11 */
		/* 82172AA4h case   21:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82172AA4h case   21:*/		return 0x82172AA8;
		  /* 82172AA8h */ case   22:  		/* lwz R10, <#[R11 + 8]> */
		/* 82172AA8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82172AA8h case   22:*/		return 0x82172AAC;
		  /* 82172AACh */ case   23:  		/* cmplw CR6, R9, R10 */
		/* 82172AACh case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82172AACh case   23:*/		return 0x82172AB0;
		  /* 82172AB0h */ case   24:  		/* bc 4, CR6_LT, -36 */
		/* 82172AB0h case   24:*/		if ( !regs.CR[6].lt ) { return 0x82172A8C;  }
		/* 82172AB0h case   24:*/		return 0x82172AB4;
	}
	return 0x82172AB4;
} // Block from 82172A50h-82172AB4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82172AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172AB4);
		  /* 82172AB4h */ case    0:  		/* addi R10, R9, 4 */
		/* 82172AB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 82172AB4h case    0:*/		return 0x82172AB8;
		  /* 82172AB8h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82172AB8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82172AB8h case    1:*/		return 0x82172ABC;
		  /* 82172ABCh */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82172ABCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82172ABCh case    2:*/		return 0x82172AC0;
		  /* 82172AC0h */ case    3:  		/* cmplw CR6, R11, R6 */
		/* 82172AC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 82172AC0h case    3:*/		return 0x82172AC4;
		  /* 82172AC4h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82172AC4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82172AD4;  }
		/* 82172AC4h case    4:*/		return 0x82172AC8;
		  /* 82172AC8h */ case    5:  		/* addi R8, R8, 1 */
		/* 82172AC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82172AC8h case    5:*/		return 0x82172ACC;
		  /* 82172ACCh */ case    6:  		/* cmplw CR6, R8, R3 */
		/* 82172ACCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R3);
		/* 82172ACCh case    6:*/		return 0x82172AD0;
	}
	return 0x82172AD0;
} // Block from 82172AB4h-82172AD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82172AD0h
// Function '?EnsureCapacity@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172AD0);
		  /* 82172AD0h */ case    0:  		/* bc 12, CR6_LT, -100 */
		/* 82172AD0h case    0:*/		if ( regs.CR[6].lt ) { return 0x82172A6C;  }
		/* 82172AD0h case    0:*/		return 0x82172AD4;
	}
	return 0x82172AD4;
} // Block from 82172AD0h-82172AD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172AD4);
		  /* 82172AD4h */ case    0:  		/* cmplw CR6, R8, R3 */
		/* 82172AD4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R3);
		/* 82172AD4h case    0:*/		return 0x82172AD8;
		  /* 82172AD8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82172AD8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82172AE8;  }
		/* 82172AD8h case    1:*/		return 0x82172ADC;
		  /* 82172ADCh */ case    2:  		/* addi R5, R5, 1 */
		/* 82172ADCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82172ADCh case    2:*/		return 0x82172AE0;
		  /* 82172AE0h */ case    3:  		/* cmplw CR6, R5, R27 */
		/* 82172AE0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R27);
		/* 82172AE0h case    3:*/		return 0x82172AE4;
		  /* 82172AE4h */ case    4:  		/* bc 12, CR6_LT, -216 */
		/* 82172AE4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82172A0C;  }
		/* 82172AE4h case    4:*/		return 0x82172AE8;
	}
	return 0x82172AE8;
} // Block from 82172AD4h-82172AE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82172AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172AE8);
		  /* 82172AE8h */ case    0:  		/* cmplw CR6, R5, R27 */
		/* 82172AE8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R27);
		/* 82172AE8h case    0:*/		return 0x82172AEC;
		  /* 82172AECh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82172AECh case    1:*/		if ( regs.CR[6].eq ) { return 0x82172B08;  }
		/* 82172AECh case    1:*/		return 0x82172AF0;
	}
	return 0x82172AF0;
} // Block from 82172AE8h-82172AF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172AF0);
		  /* 82172AF0h */ case    0:  		/* lwz R28, <#[R28 + 28]> */
		/* 82172AF0h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x0000001C) );
		/* 82172AF0h case    0:*/		return 0x82172AF4;
	}
	return 0x82172AF4;
} // Block from 82172AF0h-82172AF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172AF4);
		  /* 82172AF4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82172AF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82172AF4h case    0:*/		return 0x82172AF8;
		  /* 82172AF8h */ case    1:  		/* bc 4, CR6_EQ, -368 */
		/* 82172AF8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82172988;  }
		/* 82172AF8h case    1:*/		return 0x82172AFC;
	}
	return 0x82172AFC;
} // Block from 82172AF4h-82172AFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172AFC);
		  /* 82172AFCh */ case    0:  		/* li R3, 0 */
		/* 82172AFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82172AFCh case    0:*/		return 0x82172B00;
		  /* 82172B00h */ case    1:  		/* addi R1, R1, 144 */
		/* 82172B00h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82172B00h case    1:*/		return 0x82172B04;
		  /* 82172B04h */ case    2:  		/* b -923752 */
		/* 82172B04h case    2:*/		return 0x8209129C;
		/* 82172B04h case    2:*/		return 0x82172B08;
	}
	return 0x82172B08;
} // Block from 82172AFCh-82172B08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82172B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172B08);
		  /* 82172B08h */ case    0:  		/* li R3, 1 */
		/* 82172B08h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82172B08h case    0:*/		return 0x82172B0C;
		  /* 82172B0Ch */ case    1:  		/* b -12 */
		/* 82172B0Ch case    1:*/		return 0x82172B00;
		/* 82172B0Ch case    1:*/		return 0x82172B10;
	}
	return 0x82172B10;
} // Block from 82172B08h-82172B10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172B10);
		  /* 82172B10h */ case    0:  		/* mfspr R12, LR */
		/* 82172B10h case    0:*/		regs.R12 = regs.LR;
		/* 82172B10h case    0:*/		return 0x82172B14;
		  /* 82172B14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82172B14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172B14h case    1:*/		return 0x82172B18;
		  /* 82172B18h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172B18h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172B18h case    2:*/		return 0x82172B1C;
		  /* 82172B1Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82172B1Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172B1Ch case    3:*/		return 0x82172B20;
		  /* 82172B20h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172B20h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172B20h case    4:*/		return 0x82172B24;
		  /* 82172B24h */ case    5:  		/* li R30, 1 */
		/* 82172B24h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82172B24h case    5:*/		return 0x82172B28;
		  /* 82172B28h */ case    6:  		/* stw R4, <#[R3]> */
		/* 82172B28h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 82172B28h case    6:*/		return 0x82172B2C;
		  /* 82172B2Ch */ case    7:  		/* addi R31, R3, 4 */
		/* 82172B2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 82172B2Ch case    7:*/		return 0x82172B30;
		  /* 82172B30h */ case    8:  		/* stw R30, <#[R3 + 4]> */
		/* 82172B30h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 82172B30h case    8:*/		return 0x82172B34;
		  /* 82172B34h */ case    9:  		/* li R4, 256 */
		/* 82172B34h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 82172B34h case    9:*/		return 0x82172B38;
		  /* 82172B38h */ case   10:  		/* mr R3, R31 */
		/* 82172B38h case   10:*/		regs.R3 = regs.R31;
		/* 82172B38h case   10:*/		return 0x82172B3C;
		  /* 82172B3Ch */ case   11:  		/* bl -2172 */
		/* 82172B3Ch case   11:*/		regs.LR = 0x82172B40; return 0x821722C0;
		/* 82172B3Ch case   11:*/		return 0x82172B40;
		  /* 82172B40h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 82172B40h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82172B40h case   12:*/		return 0x82172B44;
		  /* 82172B44h */ case   13:  		/* nor R10, R11, R11 */
		/* 82172B44h case   13:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 82172B44h case   13:*/		return 0x82172B48;
		  /* 82172B48h */ case   14:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82172B48h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82172B48h case   14:*/		return 0x82172B4C;
		  /* 82172B4Ch */ case   15:  		/* bc 4, CR0_EQ, 12 */
		/* 82172B4Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x82172B58;  }
		/* 82172B4Ch case   15:*/		return 0x82172B50;
		  /* 82172B50h */ case   16:  		/* stw R30, <#[R31]> */
		/* 82172B50h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 82172B50h case   16:*/		return 0x82172B54;
		  /* 82172B54h */ case   17:  		/* b 24 */
		/* 82172B54h case   17:*/		return 0x82172B6C;
		/* 82172B54h case   17:*/		return 0x82172B58;
	}
	return 0x82172B58;
} // Block from 82172B10h-82172B58h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82172B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172B58);
		  /* 82172B58h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82172B58h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82172B58h case    0:*/		return 0x82172B5C;
		  /* 82172B5Ch */ case    1:  		/* li R4, 0 */
		/* 82172B5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82172B5Ch case    1:*/		return 0x82172B60;
		  /* 82172B60h */ case    2:  		/* addi R3, R11, 4 */
		/* 82172B60h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x4);
		/* 82172B60h case    2:*/		return 0x82172B64;
		  /* 82172B64h */ case    3:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 82172B64h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 82172B64h case    3:*/		return 0x82172B68;
		  /* 82172B68h */ case    4:  		/* bl -923688 */
		/* 82172B68h case    4:*/		regs.LR = 0x82172B6C; return 0x82091340;
		/* 82172B68h case    4:*/		return 0x82172B6C;
	}
	return 0x82172B6C;
} // Block from 82172B58h-82172B6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82172B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172B6C);
		  /* 82172B6Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 82172B6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82172B6Ch case    0:*/		return 0x82172B70;
		  /* 82172B70h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82172B70h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172B70h case    1:*/		return 0x82172B74;
		  /* 82172B74h */ case    2:  		/* mtspr LR, R12 */
		/* 82172B74h case    2:*/		regs.LR = regs.R12;
		/* 82172B74h case    2:*/		return 0x82172B78;
		  /* 82172B78h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82172B78h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172B78h case    3:*/		return 0x82172B7C;
		  /* 82172B7Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82172B7Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172B7Ch case    4:*/		return 0x82172B80;
	}
	return 0x82172B80;
} // Block from 82172B6Ch-82172B80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82172B80h
// Function '?GetSpaceWorker@?$ArrayList@PAUPossibleVectorization@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@AAAPAUArrayListEntry@12@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172B80);
		  /* 82172B80h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82172B80h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172B80h case    0:*/		return 0x82172B84;
	}
	return 0x82172B84;
} // Block from 82172B80h-82172B84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172B84);
		  /* 82172B84h */ case    0:  		/* nop */
		/* 82172B84h case    0:*/		cpu::op::nop();
		/* 82172B84h case    0:*/		return 0x82172B88;
	}
	return 0x82172B88;
} // Block from 82172B84h-82172B88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172B88);
		  /* 82172B88h */ case    0:  		/* mfspr R12, LR */
		/* 82172B88h case    0:*/		regs.R12 = regs.LR;
		/* 82172B88h case    0:*/		return 0x82172B8C;
		  /* 82172B8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82172B8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172B8Ch case    1:*/		return 0x82172B90;
		  /* 82172B90h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172B90h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172B90h case    2:*/		return 0x82172B94;
		  /* 82172B94h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82172B94h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172B94h case    3:*/		return 0x82172B98;
		  /* 82172B98h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172B98h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172B98h case    4:*/		return 0x82172B9C;
		  /* 82172B9Ch */ case    5:  		/* lwz R11, <#[R4]> */
		/* 82172B9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82172B9Ch case    5:*/		return 0x82172BA0;
		  /* 82172BA0h */ case    6:  		/* li R10, 1 */
		/* 82172BA0h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82172BA0h case    6:*/		return 0x82172BA4;
		  /* 82172BA4h */ case    7:  		/* addi R31, R3, 4 */
		/* 82172BA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 82172BA4h case    7:*/		return 0x82172BA8;
		  /* 82172BA8h */ case    8:  		/* stw R10, <#[R3 + 4]> */
		/* 82172BA8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82172BA8h case    8:*/		return 0x82172BAC;
		  /* 82172BACh */ case    9:  		/* addi R30, R4, 4 */
		/* 82172BACh case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0x4);
		/* 82172BACh case    9:*/		return 0x82172BB0;
		  /* 82172BB0h */ case   10:  		/* stw R11, <#[R3]> */
		/* 82172BB0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82172BB0h case   10:*/		return 0x82172BB4;
		  /* 82172BB4h */ case   11:  		/* lwz R11, <#[R4 + 4]> */
		/* 82172BB4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82172BB4h case   11:*/		return 0x82172BB8;
		  /* 82172BB8h */ case   12:  		/* nor R10, R11, R11 */
		/* 82172BB8h case   12:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 82172BB8h case   12:*/		return 0x82172BBC;
		  /* 82172BBCh */ case   13:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82172BBCh case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82172BBCh case   13:*/		return 0x82172BC0;
		  /* 82172BC0h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 82172BC0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82172BCC;  }
		/* 82172BC0h case   14:*/		return 0x82172BC4;
		  /* 82172BC4h */ case   15:  		/* li R4, 31 */
		/* 82172BC4h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x1F);
		/* 82172BC4h case   15:*/		return 0x82172BC8;
		  /* 82172BC8h */ case   16:  		/* b 16 */
		/* 82172BC8h case   16:*/		return 0x82172BD8;
		/* 82172BC8h case   16:*/		return 0x82172BCC;
	}
	return 0x82172BCC;
} // Block from 82172B88h-82172BCCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82172BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172BCC);
		  /* 82172BCCh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82172BCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82172BCCh case    0:*/		return 0x82172BD0;
		  /* 82172BD0h */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 82172BD0h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 82172BD0h case    1:*/		return 0x82172BD4;
		  /* 82172BD4h */ case    2:  		/* addi R4, R11, -1 */
		/* 82172BD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 82172BD4h case    2:*/		return 0x82172BD8;
	}
	return 0x82172BD8;
} // Block from 82172BCCh-82172BD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82172BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172BD8);
		  /* 82172BD8h */ case    0:  		/* mr R3, R31 */
		/* 82172BD8h case    0:*/		regs.R3 = regs.R31;
		/* 82172BD8h case    0:*/		return 0x82172BDC;
		  /* 82172BDCh */ case    1:  		/* bl -2332 */
		/* 82172BDCh case    1:*/		regs.LR = 0x82172BE0; return 0x821722C0;
		/* 82172BDCh case    1:*/		return 0x82172BE0;
		  /* 82172BE0h */ case    2:  		/* mr R4, R30 */
		/* 82172BE0h case    2:*/		regs.R4 = regs.R30;
		/* 82172BE0h case    2:*/		return 0x82172BE4;
		  /* 82172BE4h */ case    3:  		/* mr R3, R31 */
		/* 82172BE4h case    3:*/		regs.R3 = regs.R31;
		/* 82172BE4h case    3:*/		return 0x82172BE8;
		  /* 82172BE8h */ case    4:  		/* bl -6112 */
		/* 82172BE8h case    4:*/		regs.LR = 0x82172BEC; return 0x82171408;
		/* 82172BE8h case    4:*/		return 0x82172BEC;
		  /* 82172BECh */ case    5:  		/* addi R1, R1, 112 */
		/* 82172BECh case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82172BECh case    5:*/		return 0x82172BF0;
		  /* 82172BF0h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82172BF0h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172BF0h case    6:*/		return 0x82172BF4;
		  /* 82172BF4h */ case    7:  		/* mtspr LR, R12 */
		/* 82172BF4h case    7:*/		regs.LR = regs.R12;
		/* 82172BF4h case    7:*/		return 0x82172BF8;
		  /* 82172BF8h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 82172BF8h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172BF8h case    8:*/		return 0x82172BFC;
		  /* 82172BFCh */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82172BFCh case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172BFCh case    9:*/		return 0x82172C00;
		  /* 82172C00h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82172C00h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172C00h case   10:*/		return 0x82172C04;
	}
	return 0x82172C04;
} // Block from 82172BD8h-82172C04h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82172C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172C04);
		  /* 82172C04h */ case    0:  		/* nop */
		/* 82172C04h case    0:*/		cpu::op::nop();
		/* 82172C04h case    0:*/		return 0x82172C08;
	}
	return 0x82172C08;
} // Block from 82172C04h-82172C08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172C08h
// Function '?Reserve@?$RegisterSet@V?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@$1?PrintVirtualRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172C08);
		  /* 82172C08h */ case    0:  		/* mfspr R12, LR */
		/* 82172C08h case    0:*/		regs.R12 = regs.LR;
		/* 82172C08h case    0:*/		return 0x82172C0C;
		  /* 82172C0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82172C0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172C0Ch case    1:*/		return 0x82172C10;
		  /* 82172C10h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172C10h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172C10h case    2:*/		return 0x82172C14;
		  /* 82172C14h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82172C14h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172C14h case    3:*/		return 0x82172C18;
		  /* 82172C18h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172C18h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172C18h case    4:*/		return 0x82172C1C;
		  /* 82172C1Ch */ case    5:  		/* mr R31, R4 */
		/* 82172C1Ch case    5:*/		regs.R31 = regs.R4;
		/* 82172C1Ch case    5:*/		return 0x82172C20;
		  /* 82172C20h */ case    6:  		/* rlwinm R4, R4, 30, 2, 29 */
		/* 82172C20h case    6:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R4,regs.R4);
		/* 82172C20h case    6:*/		return 0x82172C24;
		  /* 82172C24h */ case    7:  		/* mr R30, R3 */
		/* 82172C24h case    7:*/		regs.R30 = regs.R3;
		/* 82172C24h case    7:*/		return 0x82172C28;
		  /* 82172C28h */ case    8:  		/* addi R3, R3, 4 */
		/* 82172C28h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82172C28h case    8:*/		return 0x82172C2C;
		  /* 82172C2Ch */ case    9:  		/* addi R5, R4, 3 */
		/* 82172C2Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 82172C2Ch case    9:*/		return 0x82172C30;
		  /* 82172C30h */ case   10:  		/* bl -6072 */
		/* 82172C30h case   10:*/		regs.LR = 0x82172C34; return 0x82171478;
		/* 82172C30h case   10:*/		return 0x82172C34;
		  /* 82172C34h */ case   11:  		/* andc R11, R31, R3 */
		/* 82172C34h case   11:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R3);
		/* 82172C34h case   11:*/		return 0x82172C38;
		  /* 82172C38h */ case   12:  		/* rlwinm. R4, R11, 0, 28, 31 */
		/* 82172C38h case   12:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R4,regs.R11);
		/* 82172C38h case   12:*/		return 0x82172C3C;
		  /* 82172C3Ch */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 82172C3Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82172C4C;  }
		/* 82172C3Ch case   13:*/		return 0x82172C40;
		  /* 82172C40h */ case   14:  		/* mr R3, R30 */
		/* 82172C40h case   14:*/		regs.R3 = regs.R30;
		/* 82172C40h case   14:*/		return 0x82172C44;
		  /* 82172C44h */ case   15:  		/* rlwimi R4, R31, 0, 0, 27 */
		/* 82172C44h case   15:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R4,regs.R31);
		/* 82172C44h case   15:*/		return 0x82172C48;
		  /* 82172C48h */ case   16:  		/* bl -2264 */
		/* 82172C48h case   16:*/		regs.LR = 0x82172C4C; return 0x82172370;
		/* 82172C48h case   16:*/		return 0x82172C4C;
	}
	return 0x82172C4C;
} // Block from 82172C08h-82172C4Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82172C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172C4C);
		  /* 82172C4Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 82172C4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82172C4Ch case    0:*/		return 0x82172C50;
		  /* 82172C50h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82172C50h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172C50h case    1:*/		return 0x82172C54;
		  /* 82172C54h */ case    2:  		/* mtspr LR, R12 */
		/* 82172C54h case    2:*/		regs.LR = regs.R12;
		/* 82172C54h case    2:*/		return 0x82172C58;
		  /* 82172C58h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82172C58h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172C58h case    3:*/		return 0x82172C5C;
		  /* 82172C5Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82172C5Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172C5Ch case    4:*/		return 0x82172C60;
		  /* 82172C60h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82172C60h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172C60h case    5:*/		return 0x82172C64;
	}
	return 0x82172C64;
} // Block from 82172C4Ch-82172C64h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172C64);
		  /* 82172C64h */ case    0:  		/* nop */
		/* 82172C64h case    0:*/		cpu::op::nop();
		/* 82172C64h case    0:*/		return 0x82172C68;
	}
	return 0x82172C68;
} // Block from 82172C64h-82172C68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172C68);
		  /* 82172C68h */ case    0:  		/* mfspr R12, LR */
		/* 82172C68h case    0:*/		regs.R12 = regs.LR;
		/* 82172C68h case    0:*/		return 0x82172C6C;
		  /* 82172C6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82172C6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172C6Ch case    1:*/		return 0x82172C70;
		  /* 82172C70h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172C70h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172C70h case    2:*/		return 0x82172C74;
		  /* 82172C74h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82172C74h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172C74h case    3:*/		return 0x82172C78;
	}
	return 0x82172C78;
} // Block from 82172C68h-82172C78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82172C78h
// Function '?Alloc@?$RegisterSet@V?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@$1?PrintVirtualRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAII_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172C78);
		  /* 82172C78h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172C78h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172C78h case    0:*/		return 0x82172C7C;
		  /* 82172C7Ch */ case    1:  		/* mr R31, R4 */
		/* 82172C7Ch case    1:*/		regs.R31 = regs.R4;
		/* 82172C7Ch case    1:*/		return 0x82172C80;
		  /* 82172C80h */ case    2:  		/* rlwinm R4, R4, 30, 2, 29 */
		/* 82172C80h case    2:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R4,regs.R4);
		/* 82172C80h case    2:*/		return 0x82172C84;
		  /* 82172C84h */ case    3:  		/* addi R30, R3, 4 */
		/* 82172C84h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x4);
		/* 82172C84h case    3:*/		return 0x82172C88;
		  /* 82172C88h */ case    4:  		/* addi R5, R4, 3 */
		/* 82172C88h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 82172C88h case    4:*/		return 0x82172C8C;
		  /* 82172C8Ch */ case    5:  		/* mr R3, R30 */
		/* 82172C8Ch case    5:*/		regs.R3 = regs.R30;
		/* 82172C8Ch case    5:*/		return 0x82172C90;
		  /* 82172C90h */ case    6:  		/* bl -6168 */
		/* 82172C90h case    6:*/		regs.LR = 0x82172C94; return 0x82171478;
		/* 82172C90h case    6:*/		return 0x82172C94;
		  /* 82172C94h */ case    7:  		/* and R11, R3, R31 */
		/* 82172C94h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R3,regs.R31);
		/* 82172C94h case    7:*/		return 0x82172C98;
		  /* 82172C98h */ case    8:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 82172C98h case    8:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82172C98h case    8:*/		return 0x82172C9C;
		  /* 82172C9Ch */ case    9:  		/* bc 12, CR0_EQ, 28 */
		/* 82172C9Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82172CB8;  }
		/* 82172C9Ch case    9:*/		return 0x82172CA0;
		  /* 82172CA0h */ case   10:  		/* rlwimi R11, R31, 0, 0, 27 */
		/* 82172CA0h case   10:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R31);
		/* 82172CA0h case   10:*/		return 0x82172CA4;
		  /* 82172CA4h */ case   11:  		/* mr R3, R30 */
		/* 82172CA4h case   11:*/		regs.R3 = regs.R30;
		/* 82172CA4h case   11:*/		return 0x82172CA8;
		  /* 82172CA8h */ case   12:  		/* rlwinm R4, R11, 30, 2, 29 */
		/* 82172CA8h case   12:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R4,regs.R11);
		/* 82172CA8h case   12:*/		return 0x82172CAC;
		  /* 82172CACh */ case   13:  		/* rlwinm R6, R11, 0, 28, 31 */
		/* 82172CACh case   13:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R11);
		/* 82172CACh case   13:*/		return 0x82172CB0;
		  /* 82172CB0h */ case   14:  		/* addi R5, R4, 3 */
		/* 82172CB0h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 82172CB0h case   14:*/		return 0x82172CB4;
		  /* 82172CB4h */ case   15:  		/* bl -5948 */
		/* 82172CB4h case   15:*/		regs.LR = 0x82172CB8; return 0x82171578;
		/* 82172CB4h case   15:*/		return 0x82172CB8;
	}
	return 0x82172CB8;
} // Block from 82172C78h-82172CB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82172CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172CB8);
		  /* 82172CB8h */ case    0:  		/* addi R1, R1, 112 */
		/* 82172CB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82172CB8h case    0:*/		return 0x82172CBC;
		  /* 82172CBCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82172CBCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172CBCh case    1:*/		return 0x82172CC0;
		  /* 82172CC0h */ case    2:  		/* mtspr LR, R12 */
		/* 82172CC0h case    2:*/		regs.LR = regs.R12;
		/* 82172CC0h case    2:*/		return 0x82172CC4;
		  /* 82172CC4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82172CC4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172CC4h case    3:*/		return 0x82172CC8;
		  /* 82172CC8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82172CC8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172CC8h case    4:*/		return 0x82172CCC;
		  /* 82172CCCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 82172CCCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172CCCh case    5:*/		return 0x82172CD0;
	}
	return 0x82172CD0;
} // Block from 82172CB8h-82172CD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172CD0);
		  /* 82172CD0h */ case    0:  		/* mfspr R12, LR */
		/* 82172CD0h case    0:*/		regs.R12 = regs.LR;
		/* 82172CD0h case    0:*/		return 0x82172CD4;
		  /* 82172CD4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82172CD4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172CD4h case    1:*/		return 0x82172CD8;
		  /* 82172CD8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82172CD8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172CD8h case    2:*/		return 0x82172CDC;
		  /* 82172CDCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82172CDCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172CDCh case    3:*/		return 0x82172CE0;
		  /* 82172CE0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82172CE0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82172CE0h case    4:*/		return 0x82172CE4;
		  /* 82172CE4h */ case    5:  		/* mr R31, R3 */
		/* 82172CE4h case    5:*/		regs.R31 = regs.R3;
		/* 82172CE4h case    5:*/		return 0x82172CE8;
		  /* 82172CE8h */ case    6:  		/* mr R30, R4 */
		/* 82172CE8h case    6:*/		regs.R30 = regs.R4;
		/* 82172CE8h case    6:*/		return 0x82172CEC;
		  /* 82172CECh */ case    7:  		/* bl -476 */
		/* 82172CECh case    7:*/		regs.LR = 0x82172CF0; return 0x82172B10;
		/* 82172CECh case    7:*/		return 0x82172CF0;
		  /* 82172CF0h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 82172CF0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82172CF0h case    8:*/		return 0x82172CF4;
		  /* 82172CF4h */ case    9:  		/* nor R10, R11, R11 */
		/* 82172CF4h case    9:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 82172CF4h case    9:*/		return 0x82172CF8;
		  /* 82172CF8h */ case   10:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82172CF8h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82172CF8h case   10:*/		return 0x82172CFC;
		  /* 82172CFCh */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 82172CFCh case   11:*/		if ( !regs.CR[0].eq ) { return 0x82172D08;  }
		/* 82172CFCh case   11:*/		return 0x82172D00;
		  /* 82172D00h */ case   12:  		/* li R11, 31 */
		/* 82172D00h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1F);
		/* 82172D00h case   12:*/		return 0x82172D04;
		  /* 82172D04h */ case   13:  		/* b 16 */
		/* 82172D04h case   13:*/		return 0x82172D14;
		/* 82172D04h case   13:*/		return 0x82172D08;
	}
	return 0x82172D08;
} // Block from 82172CD0h-82172D08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82172D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172D08);
		  /* 82172D08h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82172D08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82172D08h case    0:*/		return 0x82172D0C;
		  /* 82172D0Ch */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 82172D0Ch case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 82172D0Ch case    1:*/		return 0x82172D10;
		  /* 82172D10h */ case    2:  		/* addi R11, R11, -1 */
		/* 82172D10h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82172D10h case    2:*/		return 0x82172D14;
	}
	return 0x82172D14;
} // Block from 82172D08h-82172D14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82172D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172D14);
		  /* 82172D14h */ case    0:  		/* stw R11, <#[R31 + 12]> */
		/* 82172D14h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82172D14h case    0:*/		return 0x82172D18;
		  /* 82172D18h */ case    1:  		/* li R5, 0 */
		/* 82172D18h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82172D18h case    1:*/		return 0x82172D1C;
		  /* 82172D1Ch */ case    2:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82172D1Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82172D1Ch case    2:*/		return 0x82172D20;
		  /* 82172D20h */ case    3:  		/* mr R3, R30 */
		/* 82172D20h case    3:*/		regs.R3 = regs.R30;
		/* 82172D20h case    3:*/		return 0x82172D24;
		  /* 82172D24h */ case    4:  		/* bl -56556 */
		/* 82172D24h case    4:*/		regs.LR = 0x82172D28; return 0x82165038;
		/* 82172D24h case    4:*/		return 0x82172D28;
		  /* 82172D28h */ case    5:  		/* li R11, 0 */
		/* 82172D28h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82172D28h case    5:*/		return 0x82172D2C;
		  /* 82172D2Ch */ case    6:  		/* stw R3, <#[R31 + 8]> */
		/* 82172D2Ch case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82172D2Ch case    6:*/		return 0x82172D30;
		  /* 82172D30h */ case    7:  		/* stw R11, <#[R31 + 16]> */
		/* 82172D30h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82172D30h case    7:*/		return 0x82172D34;
		  /* 82172D34h */ case    8:  		/* addi R1, R1, 112 */
		/* 82172D34h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82172D34h case    8:*/		return 0x82172D38;
		  /* 82172D38h */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 82172D38h case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82172D38h case    9:*/		return 0x82172D3C;
		  /* 82172D3Ch */ case   10:  		/* mtspr LR, R12 */
		/* 82172D3Ch case   10:*/		regs.LR = regs.R12;
		/* 82172D3Ch case   10:*/		return 0x82172D40;
		  /* 82172D40h */ case   11:  		/* ld R30, <#[R1 - 24]> */
		/* 82172D40h case   11:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82172D40h case   11:*/		return 0x82172D44;
		  /* 82172D44h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 82172D44h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82172D44h case   12:*/		return 0x82172D48;
		  /* 82172D48h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82172D48h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82172D48h case   13:*/		return 0x82172D4C;
	}
	return 0x82172D4C;
} // Block from 82172D14h-82172D4Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82172D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172D4C);
		  /* 82172D4Ch */ case    0:  		/* nop */
		/* 82172D4Ch case    0:*/		cpu::op::nop();
		/* 82172D4Ch case    0:*/		return 0x82172D50;
	}
	return 0x82172D50;
} // Block from 82172D4Ch-82172D50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172D50);
		  /* 82172D50h */ case    0:  		/* mfspr R12, LR */
		/* 82172D50h case    0:*/		regs.R12 = regs.LR;
		/* 82172D50h case    0:*/		return 0x82172D54;
		  /* 82172D54h */ case    1:  		/* bl -924440 */
		/* 82172D54h case    1:*/		regs.LR = 0x82172D58; return 0x8209123C;
		/* 82172D54h case    1:*/		return 0x82172D58;
		  /* 82172D58h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82172D58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82172D58h case    2:*/		return 0x82172D5C;
		  /* 82172D5Ch */ case    3:  		/* lbz R11, <#[R3 + 72]> */
		/* 82172D5Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 82172D5Ch case    3:*/		return 0x82172D60;
		  /* 82172D60h */ case    4:  		/* mr R23, R3 */
		/* 82172D60h case    4:*/		regs.R23 = regs.R3;
		/* 82172D60h case    4:*/		return 0x82172D64;
		  /* 82172D64h */ case    5:  		/* lwz R25, <#[R4]> */
		/* 82172D64h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R4 + 0x00000000) );
		/* 82172D64h case    5:*/		return 0x82172D68;
		  /* 82172D68h */ case    6:  		/* mr R24, R4 */
		/* 82172D68h case    6:*/		regs.R24 = regs.R4;
		/* 82172D68h case    6:*/		return 0x82172D6C;
		  /* 82172D6Ch */ case    7:  		/* addic R11, R11, -1 */
		/* 82172D6Ch case    7:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82172D6Ch case    7:*/		return 0x82172D70;
		  /* 82172D70h */ case    8:  		/* li R21, 0 */
		/* 82172D70h case    8:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82172D70h case    8:*/		return 0x82172D74;
		  /* 82172D74h */ case    9:  		/* subfe R11, R11, R11 */
		/* 82172D74h case    9:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82172D74h case    9:*/		return 0x82172D78;
		  /* 82172D78h */ case   10:  		/* and R22, R11, R5 */
		/* 82172D78h case   10:*/		cpu::op::and<0>(regs,&regs.R22,regs.R11,regs.R5);
		/* 82172D78h case   10:*/		return 0x82172D7C;
		  /* 82172D7Ch */ case   11:  		/* cmplwi CR6, R25, 0 */
		/* 82172D7Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82172D7Ch case   11:*/		return 0x82172D80;
		  /* 82172D80h */ case   12:  		/* bc 12, CR6_EQ, 804 */
		/* 82172D80h case   12:*/		if ( regs.CR[6].eq ) { return 0x821730A4;  }
		/* 82172D80h case   12:*/		return 0x82172D84;
		  /* 82172D84h */ case   13:  		/* lwz R11, <#[R25]> */
		/* 82172D84h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82172D84h case   13:*/		return 0x82172D88;
		  /* 82172D88h */ case   14:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82172D88h case   14:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82172D88h case   14:*/		return 0x82172D8C;
		  /* 82172D8Ch */ case   15:  		/* bc 4, CR0_EQ, 16 */
		/* 82172D8Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x82172D9C;  }
		/* 82172D8Ch case   15:*/		return 0x82172D90;
		  /* 82172D90h */ case   16:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82172D90h case   16:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82172D90h case   16:*/		return 0x82172D94;
		  /* 82172D94h */ case   17:  		/* mr R11, R21 */
		/* 82172D94h case   17:*/		regs.R11 = regs.R21;
		/* 82172D94h case   17:*/		return 0x82172D98;
		  /* 82172D98h */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 82172D98h case   18:*/		if ( regs.CR[0].eq ) { return 0x82172DA0;  }
		/* 82172D98h case   18:*/		return 0x82172D9C;
	}
	return 0x82172D9C;
} // Block from 82172D50h-82172D9Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82172D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172D9C);
		  /* 82172D9Ch */ case    0:  		/* li R11, 1 */
		/* 82172D9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82172D9Ch case    0:*/		return 0x82172DA0;
	}
	return 0x82172DA0;
} // Block from 82172D9Ch-82172DA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172DA0);
		  /* 82172DA0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82172DA0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82172DA0h case    0:*/		return 0x82172DA4;
		  /* 82172DA4h */ case    1:  		/* bc 12, CR0_EQ, 760 */
		/* 82172DA4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8217309C;  }
		/* 82172DA4h case    1:*/		return 0x82172DA8;
		  /* 82172DA8h */ case    2:  		/* lwz R26, <#[R25 + 12]> */
		/* 82172DA8h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R25 + 0x0000000C) );
		/* 82172DA8h case    2:*/		return 0x82172DAC;
		  /* 82172DACh */ case    3:  		/* lwz R31, <#[R24 + 28]> */
		/* 82172DACh case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x0000001C) );
		/* 82172DACh case    3:*/		return 0x82172DB0;
		  /* 82172DB0h */ case    4:  		/* lwz R11, <#[R26 + 28]> */
		/* 82172DB0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 82172DB0h case    4:*/		return 0x82172DB4;
		  /* 82172DB4h */ case    5:  		/* cmpw CR6, R11, R31 */
		/* 82172DB4h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R31);
		/* 82172DB4h case    5:*/		return 0x82172DB8;
	}
	return 0x82172DB8;
} // Block from 82172DA0h-82172DB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172DB8h
// Function '?Free@InfiniteLocalRegisterSet@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172DB8);
		  /* 82172DB8h */ case    0:  		/* bc 4, CR6_EQ, 740 */
		/* 82172DB8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8217309C;  }
		/* 82172DB8h case    0:*/		return 0x82172DBC;
		  /* 82172DBCh */ case    1:  		/* lwz R11, <#[R26 + 8]> */
		/* 82172DBCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82172DBCh case    1:*/		return 0x82172DC0;
		  /* 82172DC0h */ case    2:  		/* mr R29, R21 */
		/* 82172DC0h case    2:*/		regs.R29 = regs.R21;
		/* 82172DC0h case    2:*/		return 0x82172DC4;
		  /* 82172DC4h */ case    3:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82172DC4h case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82172DC4h case    3:*/		return 0x82172DC8;
		  /* 82172DC8h */ case    4:  		/* bc 12, CR0_EQ, 200 */
		/* 82172DC8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82172E90;  }
		/* 82172DC8h case    4:*/		return 0x82172DCC;
		  /* 82172DCCh */ case    5:  		/* mr R3, R25 */
		/* 82172DCCh case    5:*/		regs.R3 = regs.R25;
		/* 82172DCCh case    5:*/		return 0x82172DD0;
		  /* 82172DD0h */ case    6:  		/* bl -58784 */
		/* 82172DD0h case    6:*/		regs.LR = 0x82172DD4; return 0x82164830;
		/* 82172DD0h case    6:*/		return 0x82172DD4;
		  /* 82172DD4h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82172DD4h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82172DD4h case    7:*/		return 0x82172DD8;
		  /* 82172DD8h */ case    8:  		/* bc 12, CR0_EQ, 184 */
		/* 82172DD8h case    8:*/		if ( regs.CR[0].eq ) { return 0x82172E90;  }
		/* 82172DD8h case    8:*/		return 0x82172DDC;
		  /* 82172DDCh */ case    9:  		/* mr R3, R25 */
		/* 82172DDCh case    9:*/		regs.R3 = regs.R25;
		/* 82172DDCh case    9:*/		return 0x82172DE0;
		  /* 82172DE0h */ case   10:  		/* bl -16456 */
		/* 82172DE0h case   10:*/		regs.LR = 0x82172DE4; return 0x8216ED98;
		/* 82172DE0h case   10:*/		return 0x82172DE4;
		  /* 82172DE4h */ case   11:  		/* lwz R11, <#[R23 + 48]> */
		/* 82172DE4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000030) );
		/* 82172DE4h case   11:*/		return 0x82172DE8;
		  /* 82172DE8h */ case   12:  		/* rlwinm R28, R3, 0, 28, 31 */
		/* 82172DE8h case   12:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R28,regs.R3);
		/* 82172DE8h case   12:*/		return 0x82172DEC;
		  /* 82172DECh */ case   13:  		/* mr R5, R26 */
		/* 82172DECh case   13:*/		regs.R5 = regs.R26;
		/* 82172DECh case   13:*/		return 0x82172DF0;
		  /* 82172DF0h */ case   14:  		/* mr R4, R31 */
		/* 82172DF0h case   14:*/		regs.R4 = regs.R31;
		/* 82172DF0h case   14:*/		return 0x82172DF4;
		  /* 82172DF4h */ case   15:  		/* mr R3, R11 */
		/* 82172DF4h case   15:*/		regs.R3 = regs.R11;
		/* 82172DF4h case   15:*/		return 0x82172DF8;
		  /* 82172DF8h */ case   16:  		/* bl -7312 */
		/* 82172DF8h case   16:*/		regs.LR = 0x82172DFC; return 0x82171168;
		/* 82172DF8h case   16:*/		return 0x82172DFC;
		  /* 82172DFCh */ case   17:  		/* lwz R11, <#[R24 + 20]> */
		/* 82172DFCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82172DFCh case   17:*/		return 0x82172E00;
		  /* 82172E00h */ case   18:  		/* mr R27, R3 */
		/* 82172E00h case   18:*/		regs.R27 = regs.R3;
		/* 82172E00h case   18:*/		return 0x82172E04;
		  /* 82172E04h */ case   19:  		/* rlwinm R11, R11, 19, 13, 31 */
		/* 82172E04h case   19:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R11,regs.R11);
		/* 82172E04h case   19:*/		return 0x82172E08;
		  /* 82172E08h */ case   20:  		/* mr R30, R21 */
		/* 82172E08h case   20:*/		regs.R30 = regs.R21;
		/* 82172E08h case   20:*/		return 0x82172E0C;
		  /* 82172E0Ch */ case   21:  		/* rlwinm. R10, R11, 0, 28, 31 */
		/* 82172E0Ch case   21:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R10,regs.R11);
		/* 82172E0Ch case   21:*/		return 0x82172E10;
	}
	return 0x82172E10;
} // Block from 82172DB8h-82172E10h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82172E10h
// Function '?CheckGlobalConflicts@Compiler@D3DXShader@@QAAIPAVInstruction@2@PAVBlock@2@PAVInfiniteLocalRegisterSet@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172E10);
		  /* 82172E10h */ case    0:  		/* bc 12, CR0_EQ, 36 */
		/* 82172E10h case    0:*/		if ( regs.CR[0].eq ) { return 0x82172E34;  }
		/* 82172E10h case    0:*/		return 0x82172E14;
		  /* 82172E14h */ case    1:  		/* lwz R10, <#[R25]> */
		/* 82172E14h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 82172E14h case    1:*/		return 0x82172E18;
		  /* 82172E18h */ case    2:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82172E18h case    2:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82172E18h case    2:*/		return 0x82172E1C;
		  /* 82172E1Ch */ case    3:  		/* rlwinm R10, R10, 19, 20, 27 */
		/* 82172E1Ch case    3:*/		cpu::op::rlwinm<0,19,20,27>(regs,&regs.R10,regs.R10);
		/* 82172E1Ch case    3:*/		return 0x82172E20;
		  /* 82172E20h */ case    4:  		/* xor R10, R10, R11 */
		/* 82172E20h case    4:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82172E20h case    4:*/		return 0x82172E24;
		  /* 82172E24h */ case    5:  		/* rlwinm. R10, R10, 0, 0, 27 */
		/* 82172E24h case    5:*/		cpu::op::rlwinm<1,0,0,27>(regs,&regs.R10,regs.R10);
		/* 82172E24h case    5:*/		return 0x82172E28;
		  /* 82172E28h */ case    6:  		/* bc 4, CR0_EQ, 96 */
		/* 82172E28h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82172E88;  }
		/* 82172E28h case    6:*/		return 0x82172E2C;
		  /* 82172E2Ch */ case    7:  		/* rlwinm R30, R11, 0, 28, 31 */
		/* 82172E2Ch case    7:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R30,regs.R11);
		/* 82172E2Ch case    7:*/		return 0x82172E30;
		  /* 82172E30h */ case    8:  		/* b 88 */
		/* 82172E30h case    8:*/		return 0x82172E88;
		/* 82172E30h case    8:*/		return 0x82172E34;
	}
	return 0x82172E34;
} // Block from 82172E10h-82172E34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82172E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172E34);
		  /* 82172E34h */ case    0:  		/* lwz R29, <#[R24 + 8]> */
		/* 82172E34h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R24 + 0x00000008) );
		/* 82172E34h case    0:*/		return 0x82172E38;
		  /* 82172E38h */ case    1:  		/* rlwinm. R11, R29, 9, 31, 31 */
		/* 82172E38h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R29);
		/* 82172E38h case    1:*/		return 0x82172E3C;
		  /* 82172E3Ch */ case    2:  		/* bc 12, CR0_EQ, 76 */
		/* 82172E3Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82172E88;  }
		/* 82172E3Ch case    2:*/		return 0x82172E40;
		  /* 82172E40h */ case    3:  		/* lwz R31, <#[R24 + 4]> */
		/* 82172E40h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x00000004) );
		/* 82172E40h case    3:*/		return 0x82172E44;
		  /* 82172E44h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82172E44h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82172E44h case    4:*/		return 0x82172E48;
		  /* 82172E48h */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 82172E48h case    5:*/		if ( regs.CR[6].eq ) { return 0x82172E88;  }
		/* 82172E48h case    5:*/		return 0x82172E4C;
		  /* 82172E4Ch */ case    6:  		/* lwz R11, <#[R31 + 16]> */
		/* 82172E4Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82172E4Ch case    6:*/		return 0x82172E50;
		  /* 82172E50h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82172E50h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82172E50h case    7:*/		return 0x82172E54;
		  /* 82172E54h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82172E54h case    8:*/		if ( regs.CR[6].eq ) { return 0x82172E68;  }
		/* 82172E54h case    8:*/		return 0x82172E58;
		  /* 82172E58h */ case    9:  		/* mr R3, R31 */
		/* 82172E58h case    9:*/		regs.R3 = regs.R31;
		/* 82172E58h case    9:*/		return 0x82172E5C;
		  /* 82172E5Ch */ case   10:  		/* bl -58924 */
		/* 82172E5Ch case   10:*/		regs.LR = 0x82172E60; return 0x82164830;
		/* 82172E5Ch case   10:*/		return 0x82172E60;
		  /* 82172E60h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82172E60h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82172E60h case   11:*/		return 0x82172E64;
		  /* 82172E64h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 82172E64h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82172E70;  }
		/* 82172E64h case   12:*/		return 0x82172E68;
	}
	return 0x82172E68;
} // Block from 82172E34h-82172E68h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82172E68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172E68);
		  /* 82172E68h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82172E68h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82172E68h case    0:*/		return 0x82172E6C;
		  /* 82172E6Ch */ case    1:  		/* b -40 */
		/* 82172E6Ch case    1:*/		return 0x82172E44;
		/* 82172E6Ch case    1:*/		return 0x82172E70;
	}
	return 0x82172E70;
} // Block from 82172E68h-82172E70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172E70);
		  /* 82172E70h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 82172E70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82172E70h case    0:*/		return 0x82172E74;
		  /* 82172E74h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 82172E74h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82172E74h case    1:*/		return 0x82172E78;
		  /* 82172E78h */ case    2:  		/* xor R11, R11, R10 */
		/* 82172E78h case    2:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82172E78h case    2:*/		return 0x82172E7C;
		  /* 82172E7Ch */ case    3:  		/* rlwinm. R11, R11, 0, 7, 14 */
		/* 82172E7Ch case    3:*/		cpu::op::rlwinm<1,0,7,14>(regs,&regs.R11,regs.R11);
		/* 82172E7Ch case    3:*/		return 0x82172E80;
		  /* 82172E80h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82172E80h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82172E88;  }
		/* 82172E80h case    4:*/		return 0x82172E84;
		  /* 82172E84h */ case    5:  		/* rlwinm R30, R29, 31, 28, 31 */
		/* 82172E84h case    5:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R30,regs.R29);
		/* 82172E84h case    5:*/		return 0x82172E88;
	}
	return 0x82172E88;
} // Block from 82172E70h-82172E88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172E88);
		  /* 82172E88h */ case    0:  		/* andc R11, R27, R30 */
		/* 82172E88h case    0:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R27,regs.R30);
		/* 82172E88h case    0:*/		return 0x82172E8C;
		  /* 82172E8Ch */ case    1:  		/* andc R29, R28, R11 */
		/* 82172E8Ch case    1:*/		cpu::op::andc<0>(regs,&regs.R29,regs.R28,regs.R11);
		/* 82172E8Ch case    1:*/		return 0x82172E90;
	}
	return 0x82172E90;
} // Block from 82172E88h-82172E90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172E90);
		  /* 82172E90h */ case    0:  		/* lwz R31, <#[R26 + 4]> */
		/* 82172E90h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000004) );
		/* 82172E90h case    0:*/		return 0x82172E94;
		  /* 82172E94h */ case    1:  		/* mr R30, R21 */
		/* 82172E94h case    1:*/		regs.R30 = regs.R21;
		/* 82172E94h case    1:*/		return 0x82172E98;
		  /* 82172E98h */ case    2:  		/* mr R28, R21 */
		/* 82172E98h case    2:*/		regs.R28 = regs.R21;
		/* 82172E98h case    2:*/		return 0x82172E9C;
		  /* 82172E9Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82172E9Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82172E9Ch case    3:*/		return 0x82172EA0;
		  /* 82172EA0h */ case    4:  		/* bc 12, CR6_EQ, 244 */
		/* 82172EA0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82172F94;  }
		/* 82172EA0h case    4:*/		return 0x82172EA4;
		  /* 82172EA4h */ case    5:  		/* lwz R4, <#[R31 + 16]> */
		/* 82172EA4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82172EA4h case    5:*/		return 0x82172EA8;
		  /* 82172EA8h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 82172EA8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82172EA8h case    6:*/		return 0x82172EAC;
		  /* 82172EACh */ case    7:  		/* bc 12, CR6_EQ, 224 */
		/* 82172EACh case    7:*/		if ( regs.CR[6].eq ) { return 0x82172F8C;  }
		/* 82172EACh case    7:*/		return 0x82172EB0;
		  /* 82172EB0h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 82172EB0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82172EB0h case    8:*/		return 0x82172EB4;
		  /* 82172EB4h */ case    9:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82172EB4h case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82172EB4h case    9:*/		return 0x82172EB8;
		  /* 82172EB8h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 82172EB8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82172EC8;  }
		/* 82172EB8h case   10:*/		return 0x82172EBC;
		  /* 82172EBCh */ case   11:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82172EBCh case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82172EBCh case   11:*/		return 0x82172EC0;
		  /* 82172EC0h */ case   12:  		/* mr R11, R21 */
		/* 82172EC0h case   12:*/		regs.R11 = regs.R21;
		/* 82172EC0h case   12:*/		return 0x82172EC4;
		  /* 82172EC4h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 82172EC4h case   13:*/		if ( regs.CR[0].eq ) { return 0x82172ECC;  }
		/* 82172EC4h case   13:*/		return 0x82172EC8;
	}
	return 0x82172EC8;
} // Block from 82172E90h-82172EC8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82172EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172EC8);
		  /* 82172EC8h */ case    0:  		/* li R11, 1 */
		/* 82172EC8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82172EC8h case    0:*/		return 0x82172ECC;
	}
	return 0x82172ECC;
} // Block from 82172EC8h-82172ECCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172ECC);
		  /* 82172ECCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82172ECCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82172ECCh case    0:*/		return 0x82172ED0;
		  /* 82172ED0h */ case    1:  		/* bc 12, CR0_EQ, 188 */
		/* 82172ED0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82172F8C;  }
		/* 82172ED0h case    1:*/		return 0x82172ED4;
		  /* 82172ED4h */ case    2:  		/* cmplw CR6, R4, R24 */
		/* 82172ED4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R24);
		/* 82172ED4h case    2:*/		return 0x82172ED8;
		  /* 82172ED8h */ case    3:  		/* bc 12, CR6_EQ, 180 */
		/* 82172ED8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82172F8C;  }
		/* 82172ED8h case    3:*/		return 0x82172EDC;
		  /* 82172EDCh */ case    4:  		/* lwz R11, <#[R4 + 28]> */
		/* 82172EDCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82172EDCh case    4:*/		return 0x82172EE0;
		  /* 82172EE0h */ case    5:  		/* lwz R10, <#[R24 + 28]> */
		/* 82172EE0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 82172EE0h case    5:*/		return 0x82172EE4;
		  /* 82172EE4h */ case    6:  		/* cmpw CR6, R11, R10 */
		/* 82172EE4h case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82172EE4h case    6:*/		return 0x82172EE8;
		  /* 82172EE8h */ case    7:  		/* bc 4, CR6_EQ, 164 */
		/* 82172EE8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82172F8C;  }
		/* 82172EE8h case    7:*/		return 0x82172EEC;
		  /* 82172EECh */ case    8:  		/* lwz R11, <#[R4 + 8]> */
		/* 82172EECh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82172EECh case    8:*/		return 0x82172EF0;
		  /* 82172EF0h */ case    9:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82172EF0h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82172EF0h case    9:*/		return 0x82172EF4;
		  /* 82172EF4h */ case   10:  		/* cmplwi CR6, R10, 14336 */
		/* 82172EF4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003800);
		/* 82172EF4h case   10:*/		return 0x82172EF8;
		  /* 82172EF8h */ case   11:  		/* bc 12, CR6_EQ, 148 */
		/* 82172EF8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82172F8C;  }
		/* 82172EF8h case   11:*/		return 0x82172EFC;
		  /* 82172EFCh */ case   12:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 82172EFCh case   12:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 82172EFCh case   12:*/		return 0x82172F00;
	}
	return 0x82172F00;
} // Block from 82172ECCh-82172F00h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82172F00h
// Function '?CreateRegOptSolutionStep@Compiler@D3DXShader@@AAAPAURegOptSolutionStep@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F00);
		  /* 82172F00h */ case    0:  		/* bc 4, CR0_EQ, 36 */
		/* 82172F00h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82172F24;  }
		/* 82172F00h case    0:*/		return 0x82172F04;
		  /* 82172F04h */ case    1:  		/* lwz R11, <#[R24 + 8]> */
		/* 82172F04h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82172F04h case    1:*/		return 0x82172F08;
		  /* 82172F08h */ case    2:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 82172F08h case    2:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 82172F08h case    2:*/		return 0x82172F0C;
		  /* 82172F0Ch */ case    3:  		/* bc 4, CR0_EQ, 128 */
		/* 82172F0Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82172F8C;  }
		/* 82172F0Ch case    3:*/		return 0x82172F10;
		  /* 82172F10h */ case    4:  		/* mr R3, R24 */
		/* 82172F10h case    4:*/		regs.R3 = regs.R24;
		/* 82172F10h case    4:*/		return 0x82172F14;
		  /* 82172F14h */ case    5:  		/* bl -5708 */
		/* 82172F14h case    5:*/		regs.LR = 0x82172F18; return 0x821718C8;
		/* 82172F14h case    5:*/		return 0x82172F18;
		  /* 82172F18h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82172F18h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82172F18h case    6:*/		return 0x82172F1C;
		  /* 82172F1Ch */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 82172F1Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82172F30;  }
		/* 82172F1Ch case    7:*/		return 0x82172F20;
		  /* 82172F20h */ case    8:  		/* b 108 */
		/* 82172F20h case    8:*/		return 0x82172F8C;
		/* 82172F20h case    8:*/		return 0x82172F24;
	}
	return 0x82172F24;
} // Block from 82172F00h-82172F24h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82172F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F24);
		  /* 82172F24h */ case    0:  		/* lwz R11, <#[R4 + 16]> */
		/* 82172F24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 82172F24h case    0:*/		return 0x82172F28;
		  /* 82172F28h */ case    1:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 82172F28h case    1:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 82172F28h case    1:*/		return 0x82172F2C;
		  /* 82172F2Ch */ case    2:  		/* bc 12, CR0_EQ, 96 */
		/* 82172F2Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82172F8C;  }
		/* 82172F2Ch case    2:*/		return 0x82172F30;
	}
	return 0x82172F30;
} // Block from 82172F24h-82172F30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82172F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F30);
		  /* 82172F30h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82172F30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82172F30h case    0:*/		return 0x82172F34;
		  /* 82172F34h */ case    1:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82172F34h case    1:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82172F34h case    1:*/		return 0x82172F38;
		  /* 82172F38h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82172F38h case    2:*/		if ( regs.CR[0].eq ) { return 0x82172F48;  }
		/* 82172F38h case    2:*/		return 0x82172F3C;
		  /* 82172F3Ch */ case    3:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82172F3Ch case    3:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82172F3Ch case    3:*/		return 0x82172F40;
		  /* 82172F40h */ case    4:  		/* li R11, 1 */
		/* 82172F40h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82172F40h case    4:*/		return 0x82172F44;
		  /* 82172F44h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82172F44h case    5:*/		if ( regs.CR[0].eq ) { return 0x82172F4C;  }
		/* 82172F44h case    5:*/		return 0x82172F48;
	}
	return 0x82172F48;
} // Block from 82172F30h-82172F48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82172F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F48);
		  /* 82172F48h */ case    0:  		/* mr R11, R21 */
		/* 82172F48h case    0:*/		regs.R11 = regs.R21;
		/* 82172F48h case    0:*/		return 0x82172F4C;
	}
	return 0x82172F4C;
} // Block from 82172F48h-82172F4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F4C);
		  /* 82172F4Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82172F4Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82172F4Ch case    0:*/		return 0x82172F50;
		  /* 82172F50h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82172F50h case    1:*/		if ( regs.CR[0].eq ) { return 0x82172F5C;  }
		/* 82172F50h case    1:*/		return 0x82172F54;
		  /* 82172F54h */ case    2:  		/* mr R28, R31 */
		/* 82172F54h case    2:*/		regs.R28 = regs.R31;
		/* 82172F54h case    2:*/		return 0x82172F58;
		  /* 82172F58h */ case    3:  		/* b 52 */
		/* 82172F58h case    3:*/		return 0x82172F8C;
		/* 82172F58h case    3:*/		return 0x82172F5C;
	}
	return 0x82172F5C;
} // Block from 82172F4Ch-82172F5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82172F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F5C);
		  /* 82172F5Ch */ case    0:  		/* mr R3, R31 */
		/* 82172F5Ch case    0:*/		regs.R3 = regs.R31;
		/* 82172F5Ch case    0:*/		return 0x82172F60;
		  /* 82172F60h */ case    1:  		/* bl -59184 */
		/* 82172F60h case    1:*/		regs.LR = 0x82172F64; return 0x82164830;
		/* 82172F60h case    1:*/		return 0x82172F64;
		  /* 82172F64h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82172F64h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82172F64h case    2:*/		return 0x82172F68;
		  /* 82172F68h */ case    3:  		/* bc 12, CR0_EQ, 36 */
		/* 82172F68h case    3:*/		if ( regs.CR[0].eq ) { return 0x82172F8C;  }
		/* 82172F68h case    3:*/		return 0x82172F6C;
		  /* 82172F6Ch */ case    4:  		/* lwz R11, <#[R26 + 8]> */
		/* 82172F6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82172F6Ch case    4:*/		return 0x82172F70;
	}
	return 0x82172F70;
} // Block from 82172F5Ch-82172F70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82172F70h
// Function '?FreeSolutionStep@Compiler@D3DXShader@@AAAXPAURegOptSolutionStep@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F70);
		  /* 82172F70h */ case    0:  		/* mr R30, R31 */
		/* 82172F70h case    0:*/		regs.R30 = regs.R31;
		/* 82172F70h case    0:*/		return 0x82172F74;
		  /* 82172F74h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82172F74h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82172F74h case    1:*/		return 0x82172F78;
		  /* 82172F78h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 82172F78h case    2:*/		if ( regs.CR[0].eq ) { return 0x82172F8C;  }
		/* 82172F78h case    2:*/		return 0x82172F7C;
		  /* 82172F7Ch */ case    3:  		/* mr R3, R31 */
		/* 82172F7Ch case    3:*/		regs.R3 = regs.R31;
		/* 82172F7Ch case    3:*/		return 0x82172F80;
		  /* 82172F80h */ case    4:  		/* bl -16872 */
		/* 82172F80h case    4:*/		regs.LR = 0x82172F84; return 0x8216ED98;
		/* 82172F80h case    4:*/		return 0x82172F84;
		  /* 82172F84h */ case    5:  		/* rlwinm R11, R3, 0, 28, 31 */
		/* 82172F84h case    5:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R3);
		/* 82172F84h case    5:*/		return 0x82172F88;
		  /* 82172F88h */ case    6:  		/* andc R29, R29, R11 */
		/* 82172F88h case    6:*/		cpu::op::andc<0>(regs,&regs.R29,regs.R29,regs.R11);
		/* 82172F88h case    6:*/		return 0x82172F8C;
	}
	return 0x82172F8C;
} // Block from 82172F70h-82172F8Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82172F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F8C);
		  /* 82172F8Ch */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82172F8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82172F8Ch case    0:*/		return 0x82172F90;
		  /* 82172F90h */ case    1:  		/* b -244 */
		/* 82172F90h case    1:*/		return 0x82172E9C;
		/* 82172F90h case    1:*/		return 0x82172F94;
	}
	return 0x82172F94;
} // Block from 82172F8Ch-82172F94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82172F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172F94);
		  /* 82172F94h */ case    0:  		/* mr R3, R25 */
		/* 82172F94h case    0:*/		regs.R3 = regs.R25;
		/* 82172F94h case    0:*/		return 0x82172F98;
		  /* 82172F98h */ case    1:  		/* bl -59240 */
		/* 82172F98h case    1:*/		regs.LR = 0x82172F9C; return 0x82164830;
		/* 82172F98h case    1:*/		return 0x82172F9C;
		  /* 82172F9Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82172F9Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82172F9Ch case    2:*/		return 0x82172FA0;
		  /* 82172FA0h */ case    3:  		/* bc 12, CR0_EQ, 204 */
		/* 82172FA0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8217306C;  }
		/* 82172FA0h case    3:*/		return 0x82172FA4;
		  /* 82172FA4h */ case    4:  		/* lwz R11, <#[R26 + 20]> */
		/* 82172FA4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82172FA4h case    4:*/		return 0x82172FA8;
		  /* 82172FA8h */ case    5:  		/* rlwinm R11, R11, 19, 13, 31 */
		/* 82172FA8h case    5:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R11,regs.R11);
		/* 82172FA8h case    5:*/		return 0x82172FAC;
		  /* 82172FACh */ case    6:  		/* rlwinm. R10, R11, 0, 28, 31 */
		/* 82172FACh case    6:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R10,regs.R11);
		/* 82172FACh case    6:*/		return 0x82172FB0;
		  /* 82172FB0h */ case    7:  		/* bc 12, CR0_EQ, 84 */
		/* 82172FB0h case    7:*/		if ( regs.CR[0].eq ) { return 0x82173004;  }
		/* 82172FB0h case    7:*/		return 0x82172FB4;
		  /* 82172FB4h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 82172FB4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82172FB4h case    8:*/		return 0x82172FB8;
		  /* 82172FB8h */ case    9:  		/* bc 4, CR6_EQ, 76 */
		/* 82172FB8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82173004;  }
		/* 82172FB8h case    9:*/		return 0x82172FBC;
		  /* 82172FBCh */ case   10:  		/* rlwinm. R10, R22, 0, 24, 31 */
		/* 82172FBCh case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R22);
		/* 82172FBCh case   10:*/		return 0x82172FC0;
		  /* 82172FC0h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 82172FC0h case   11:*/		if ( regs.CR[0].eq ) { return 0x82172FD4;  }
		/* 82172FC0h case   11:*/		return 0x82172FC4;
		  /* 82172FC4h */ case   12:  		/* rlwinm R4, R11, 0, 20, 31 */
		/* 82172FC4h case   12:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R4,regs.R11);
		/* 82172FC4h case   12:*/		return 0x82172FC8;
		  /* 82172FC8h */ case   13:  		/* lwz R3, <#[R23 + 56]> */
		/* 82172FC8h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000038) );
		/* 82172FC8h case   13:*/		return 0x82172FCC;
		  /* 82172FCCh */ case   14:  		/* bl -2732 */
		/* 82172FCCh case   14:*/		regs.LR = 0x82172FD0; return 0x82172520;
		/* 82172FCCh case   14:*/		return 0x82172FD0;
	}
	return 0x82172FD0;
} // Block from 82172F94h-82172FD0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82172FD0h
// Function '?ComputeRegOptSolutionHash@Compiler@D3DXShader@@AAAXPAURegOptSolutionStep@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172FD0);
		  /* 82172FD0h */ case    0:  		/* b 40 */
		/* 82172FD0h case    0:*/		return 0x82172FF8;
		/* 82172FD0h case    0:*/		return 0x82172FD4;
	}
	return 0x82172FD4;
} // Block from 82172FD0h-82172FD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82172FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172FD4);
		  /* 82172FD4h */ case    0:  		/* lwz R31, <#[R23 + 56]> */
		/* 82172FD4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000038) );
		/* 82172FD4h case    0:*/		return 0x82172FD8;
		  /* 82172FD8h */ case    1:  		/* rlwinm R30, R11, 0, 20, 31 */
		/* 82172FD8h case    1:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R30,regs.R11);
		/* 82172FD8h case    1:*/		return 0x82172FDC;
		  /* 82172FDCh */ case    2:  		/* mr R4, R30 */
		/* 82172FDCh case    2:*/		regs.R4 = regs.R30;
		/* 82172FDCh case    2:*/		return 0x82172FE0;
		  /* 82172FE0h */ case    3:  		/* mr R3, R31 */
		/* 82172FE0h case    3:*/		regs.R3 = regs.R31;
		/* 82172FE0h case    3:*/		return 0x82172FE4;
		  /* 82172FE4h */ case    4:  		/* bl -892 */
		/* 82172FE4h case    4:*/		regs.LR = 0x82172FE8; return 0x82172C68;
		/* 82172FE4h case    4:*/		return 0x82172FE8;
		  /* 82172FE8h */ case    5:  		/* li R5, 0 */
		/* 82172FE8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82172FE8h case    5:*/		return 0x82172FEC;
		  /* 82172FECh */ case    6:  		/* mr R4, R30 */
		/* 82172FECh case    6:*/		regs.R4 = regs.R30;
		/* 82172FECh case    6:*/		return 0x82172FF0;
		  /* 82172FF0h */ case    7:  		/* mr R3, R31 */
		/* 82172FF0h case    7:*/		regs.R3 = regs.R31;
		/* 82172FF0h case    7:*/		return 0x82172FF4;
		  /* 82172FF4h */ case    8:  		/* bl -5356 */
		/* 82172FF4h case    8:*/		regs.LR = 0x82172FF8; return 0x82171B08;
		/* 82172FF4h case    8:*/		return 0x82172FF8;
	}
	return 0x82172FF8;
} // Block from 82172FD4h-82172FF8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82172FF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82172FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82172FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82172FF8);
		  /* 82172FF8h */ case    0:  		/* mr R4, R26 */
		/* 82172FF8h case    0:*/		regs.R4 = regs.R26;
		/* 82172FF8h case    0:*/		return 0x82172FFC;
		  /* 82172FFCh */ case    1:  		/* lwz R3, <#[R23 + 48]> */
		/* 82172FFCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000030) );
		/* 82172FFCh case    1:*/		return 0x82173000;
		  /* 82173000h */ case    2:  		/* bl -8304 */
		/* 82173000h case    2:*/		regs.LR = 0x82173004; return 0x82170F90;
		/* 82173000h case    2:*/		return 0x82173004;
	}
	return 0x82173004;
} // Block from 82172FF8h-82173004h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173004);
		  /* 82173004h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82173004h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82173004h case    0:*/		return 0x82173008;
		  /* 82173008h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82173008h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82173008h case    1:*/		return 0x8217300C;
		  /* 8217300Ch */ case    2:  		/* bc 12, CR0_EQ, 96 */
		/* 8217300Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8217306C;  }
		/* 8217300Ch case    2:*/		return 0x82173010;
		  /* 82173010h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 82173010h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82173010h case    3:*/		return 0x82173014;
		  /* 82173014h */ case    4:  		/* bc 12, CR6_EQ, 88 */
		/* 82173014h case    4:*/		if ( regs.CR[6].eq ) { return 0x8217306C;  }
		/* 82173014h case    4:*/		return 0x82173018;
		  /* 82173018h */ case    5:  		/* lwz R11, <#[R25]> */
		/* 82173018h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82173018h case    5:*/		return 0x8217301C;
		  /* 8217301Ch */ case    6:  		/* lwz R31, <#[R23 + 56]> */
		/* 8217301Ch case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000038) );
		/* 8217301Ch case    6:*/		return 0x82173020;
		  /* 82173020h */ case    7:  		/* rlwinm R30, R11, 15, 24, 31 */
		/* 82173020h case    7:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R30,regs.R11);
		/* 82173020h case    7:*/		return 0x82173024;
		  /* 82173024h */ case    8:  		/* addi R3, R31, 4 */
		/* 82173024h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82173024h case    8:*/		return 0x82173028;
		  /* 82173028h */ case    9:  		/* rlwinm R4, R30, 2, 0, 29 */
		/* 82173028h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R30);
		/* 82173028h case    9:*/		return 0x8217302C;
		  /* 8217302Ch */ case   10:  		/* addi R5, R4, 3 */
		/* 8217302Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 8217302Ch case   10:*/		return 0x82173030;
		  /* 82173030h */ case   11:  		/* bl -7096 */
		/* 82173030h case   11:*/		regs.LR = 0x82173034; return 0x82171478;
		/* 82173030h case   11:*/		return 0x82173034;
		  /* 82173034h */ case   12:  		/* and. R4, R3, R29 */
		/* 82173034h case   12:*/		cpu::op::and<1>(regs,&regs.R4,regs.R3,regs.R29);
		/* 82173034h case   12:*/		return 0x82173038;
		  /* 82173038h */ case   13:  		/* bc 12, CR0_EQ, 52 */
		/* 82173038h case   13:*/		if ( regs.CR[0].eq ) { return 0x8217306C;  }
		/* 82173038h case   13:*/		return 0x8217303C;
		  /* 8217303Ch */ case   14:  		/* rlwinm. R11, R22, 0, 24, 31 */
		/* 8217303Ch case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R22);
		/* 8217303Ch case   14:*/		return 0x82173040;
		  /* 82173040h */ case   15:  		/* mr R3, R31 */
		/* 82173040h case   15:*/		regs.R3 = regs.R31;
		/* 82173040h case   15:*/		return 0x82173044;
		  /* 82173044h */ case   16:  		/* rlwimi R4, R30, 4, 0, 27 */
		/* 82173044h case   16:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R4,regs.R30);
		/* 82173044h case   16:*/		return 0x82173048;
		  /* 82173048h */ case   17:  		/* bc 12, CR0_EQ, 12 */
		/* 82173048h case   17:*/		if ( regs.CR[0].eq ) { return 0x82173054;  }
		/* 82173048h case   17:*/		return 0x8217304C;
		  /* 8217304Ch */ case   18:  		/* bl -2860 */
		/* 8217304Ch case   18:*/		regs.LR = 0x82173050; return 0x82172520;
		/* 8217304Ch case   18:*/		return 0x82173050;
		  /* 82173050h */ case   19:  		/* b 28 */
		/* 82173050h case   19:*/		return 0x8217306C;
		/* 82173050h case   19:*/		return 0x82173054;
	}
	return 0x82173054;
} // Block from 82173004h-82173054h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82173054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173054);
		  /* 82173054h */ case    0:  		/* mr R30, R4 */
		/* 82173054h case    0:*/		regs.R30 = regs.R4;
		/* 82173054h case    0:*/		return 0x82173058;
		  /* 82173058h */ case    1:  		/* bl -1008 */
		/* 82173058h case    1:*/		regs.LR = 0x8217305C; return 0x82172C68;
		/* 82173058h case    1:*/		return 0x8217305C;
		  /* 8217305Ch */ case    2:  		/* li R5, 0 */
		/* 8217305Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8217305Ch case    2:*/		return 0x82173060;
		  /* 82173060h */ case    3:  		/* mr R4, R30 */
		/* 82173060h case    3:*/		regs.R4 = regs.R30;
		/* 82173060h case    3:*/		return 0x82173064;
		  /* 82173064h */ case    4:  		/* mr R3, R31 */
		/* 82173064h case    4:*/		regs.R3 = regs.R31;
		/* 82173064h case    4:*/		return 0x82173068;
		  /* 82173068h */ case    5:  		/* bl -5472 */
		/* 82173068h case    5:*/		regs.LR = 0x8217306C; return 0x82171B08;
		/* 82173068h case    5:*/		return 0x8217306C;
	}
	return 0x8217306C;
} // Block from 82173054h-8217306Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8217306Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217306C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217306C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217306C);
		  /* 8217306Ch */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8217306Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8217306Ch case    0:*/		return 0x82173070;
		  /* 82173070h */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 82173070h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8217309C;  }
		/* 82173070h case    1:*/		return 0x82173074;
		  /* 82173074h */ case    2:  		/* mr R10, R21 */
		/* 82173074h case    2:*/		regs.R10 = regs.R21;
		/* 82173074h case    2:*/		return 0x82173078;
		  /* 82173078h */ case    3:  		/* addi R11, R23, 8 */
		/* 82173078h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x8);
		/* 82173078h case    3:*/		return 0x8217307C;
		  /* 8217307Ch */ case    4:  		/* lwz R9, <#[R11]> */
		/* 8217307Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8217307Ch case    4:*/		return 0x82173080;
		  /* 82173080h */ case    5:  		/* cmplw CR6, R26, R9 */
		/* 82173080h case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R9);
		/* 82173080h case    5:*/		return 0x82173084;
		  /* 82173084h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82173084h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8217308C;  }
		/* 82173084h case    6:*/		return 0x82173088;
		  /* 82173088h */ case    7:  		/* stw R21, <#[R11]> */
		/* 82173088h case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000000) );
		/* 82173088h case    7:*/		return 0x8217308C;
	}
	return 0x8217308C;
} // Block from 8217306Ch-8217308Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8217308Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217308C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217308C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217308C);
		  /* 8217308Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8217308Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8217308Ch case    0:*/		return 0x82173090;
		  /* 82173090h */ case    1:  		/* addi R11, R11, 4 */
		/* 82173090h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82173090h case    1:*/		return 0x82173094;
		  /* 82173094h */ case    2:  		/* cmplwi CR6, R10, 9 */
		/* 82173094h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000009);
		/* 82173094h case    2:*/		return 0x82173098;
	}
	return 0x82173098;
} // Block from 8217308Ch-82173098h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173098h
// Function '?RecordFailedSolution@Compiler@D3DXShader@@AAA_NPAURegOptSolutionStep@2@PAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173098);
		  /* 82173098h */ case    0:  		/* bc 12, CR6_LT, -28 */
		/* 82173098h case    0:*/		if ( regs.CR[6].lt ) { return 0x8217307C;  }
		/* 82173098h case    0:*/		return 0x8217309C;
	}
	return 0x8217309C;
} // Block from 82173098h-8217309Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8217309Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217309C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217309C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217309C);
		  /* 8217309Ch */ case    0:  		/* lwz R25, <#[R25 + 4]> */
		/* 8217309Ch case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x00000004) );
		/* 8217309Ch case    0:*/		return 0x821730A0;
		  /* 821730A0h */ case    1:  		/* b -804 */
		/* 821730A0h case    1:*/		return 0x82172D7C;
		/* 821730A0h case    1:*/		return 0x821730A4;
	}
	return 0x821730A4;
} // Block from 8217309Ch-821730A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821730A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821730A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821730A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821730A4);
		  /* 821730A4h */ case    0:  		/* lwz R31, <#[R24 + 4]> */
		/* 821730A4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x00000004) );
		/* 821730A4h case    0:*/		return 0x821730A8;
		  /* 821730A8h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821730A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821730A8h case    1:*/		return 0x821730AC;
		  /* 821730ACh */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 821730ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x821730F8;  }
		/* 821730ACh case    2:*/		return 0x821730B0;
		  /* 821730B0h */ case    3:  		/* lwz R5, <#[R31 + 16]> */
		/* 821730B0h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 821730B0h case    3:*/		return 0x821730B4;
		  /* 821730B4h */ case    4:  		/* cmplwi CR6, R5, 0 */
		/* 821730B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821730B4h case    4:*/		return 0x821730B8;
		  /* 821730B8h */ case    5:  		/* bc 12, CR6_EQ, 56 */
		/* 821730B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821730F0;  }
		/* 821730B8h case    5:*/		return 0x821730BC;
		  /* 821730BCh */ case    6:  		/* lwz R11, <#[R31]> */
		/* 821730BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821730BCh case    6:*/		return 0x821730C0;
		  /* 821730C0h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 821730C0h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 821730C0h case    7:*/		return 0x821730C4;
		  /* 821730C4h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821730C4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821730D4;  }
		/* 821730C4h case    8:*/		return 0x821730C8;
		  /* 821730C8h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821730C8h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821730C8h case    9:*/		return 0x821730CC;
		  /* 821730CCh */ case   10:  		/* mr R11, R21 */
		/* 821730CCh case   10:*/		regs.R11 = regs.R21;
		/* 821730CCh case   10:*/		return 0x821730D0;
		  /* 821730D0h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 821730D0h case   11:*/		if ( regs.CR[0].eq ) { return 0x821730D8;  }
		/* 821730D0h case   11:*/		return 0x821730D4;
	}
	return 0x821730D4;
} // Block from 821730A4h-821730D4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821730D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821730D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821730D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821730D4);
		  /* 821730D4h */ case    0:  		/* li R11, 1 */
		/* 821730D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821730D4h case    0:*/		return 0x821730D8;
	}
	return 0x821730D8;
} // Block from 821730D4h-821730D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821730D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821730D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821730D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821730D8);
		  /* 821730D8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821730D8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821730D8h case    0:*/		return 0x821730DC;
		  /* 821730DCh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821730DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821730F0;  }
		/* 821730DCh case    1:*/		return 0x821730E0;
		  /* 821730E0h */ case    2:  		/* addi R3, R23, 4 */
		/* 821730E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R23,0x4);
		/* 821730E0h case    2:*/		return 0x821730E4;
		  /* 821730E4h */ case    3:  		/* mr R6, R24 */
		/* 821730E4h case    3:*/		regs.R6 = regs.R24;
		/* 821730E4h case    3:*/		return 0x821730E8;
		  /* 821730E8h */ case    4:  		/* mr R4, R31 */
		/* 821730E8h case    4:*/		regs.R4 = regs.R31;
		/* 821730E8h case    4:*/		return 0x821730EC;
		  /* 821730ECh */ case    5:  		/* bl -15724 */
		/* 821730ECh case    5:*/		regs.LR = 0x821730F0; return 0x8216F380;
		/* 821730ECh case    5:*/		return 0x821730F0;
	}
	return 0x821730F0;
} // Block from 821730D8h-821730F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821730F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821730F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821730F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821730F0);
		  /* 821730F0h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 821730F0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 821730F0h case    0:*/		return 0x821730F4;
		  /* 821730F4h */ case    1:  		/* b -76 */
		/* 821730F4h case    1:*/		return 0x821730A8;
		/* 821730F4h case    1:*/		return 0x821730F8;
	}
	return 0x821730F8;
} // Block from 821730F0h-821730F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821730F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821730F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821730F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821730F8);
		  /* 821730F8h */ case    0:  		/* addi R31, R23, 4 */
		/* 821730F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R23,0x4);
		/* 821730F8h case    0:*/		return 0x821730FC;
		  /* 821730FCh */ case    1:  		/* li R5, 0 */
		/* 821730FCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821730FCh case    1:*/		return 0x82173100;
		  /* 82173100h */ case    2:  		/* mr R4, R24 */
		/* 82173100h case    2:*/		regs.R4 = regs.R24;
		/* 82173100h case    2:*/		return 0x82173104;
		  /* 82173104h */ case    3:  		/* mr R3, R31 */
		/* 82173104h case    3:*/		regs.R3 = regs.R31;
		/* 82173104h case    3:*/		return 0x82173108;
		  /* 82173108h */ case    4:  		/* bl -8864 */
		/* 82173108h case    4:*/		regs.LR = 0x8217310C; return 0x82170E68;
		/* 82173108h case    4:*/		return 0x8217310C;
		  /* 8217310Ch */ case    5:  		/* rlwinm. R11, R22, 0, 24, 31 */
		/* 8217310Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R22);
		/* 8217310Ch case    5:*/		return 0x82173110;
		  /* 82173110h */ case    6:  		/* bc 12, CR0_EQ, 240 */
		/* 82173110h case    6:*/		if ( regs.CR[0].eq ) { return 0x82173200;  }
		/* 82173110h case    6:*/		return 0x82173114;
		  /* 82173114h */ case    7:  		/* lwz R11, <#[R24 + 20]> */
		/* 82173114h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82173114h case    7:*/		return 0x82173118;
		  /* 82173118h */ case    8:  		/* rlwinm R11, R11, 19, 13, 31 */
		/* 82173118h case    8:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R11,regs.R11);
		/* 82173118h case    8:*/		return 0x8217311C;
		  /* 8217311Ch */ case    9:  		/* rlwinm. R10, R11, 0, 28, 31 */
		/* 8217311Ch case    9:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R10,regs.R11);
		/* 8217311Ch case    9:*/		return 0x82173120;
		  /* 82173120h */ case   10:  		/* bc 12, CR0_EQ, 40 */
		/* 82173120h case   10:*/		if ( regs.CR[0].eq ) { return 0x82173148;  }
		/* 82173120h case   10:*/		return 0x82173124;
		  /* 82173124h */ case   11:  		/* lwz R30, <#[R23 + 56]> */
		/* 82173124h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R23 + 0x00000038) );
		/* 82173124h case   11:*/		return 0x82173128;
		  /* 82173128h */ case   12:  		/* rlwinm R29, R11, 0, 20, 31 */
		/* 82173128h case   12:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R29,regs.R11);
		/* 82173128h case   12:*/		return 0x8217312C;
		  /* 8217312Ch */ case   13:  		/* mr R3, R30 */
		/* 8217312Ch case   13:*/		regs.R3 = regs.R30;
		/* 8217312Ch case   13:*/		return 0x82173130;
		  /* 82173130h */ case   14:  		/* mr R4, R29 */
		/* 82173130h case   14:*/		regs.R4 = regs.R29;
		/* 82173130h case   14:*/		return 0x82173134;
		  /* 82173134h */ case   15:  		/* bl -3524 */
		/* 82173134h case   15:*/		regs.LR = 0x82173138; return 0x82172370;
		/* 82173134h case   15:*/		return 0x82173138;
		  /* 82173138h */ case   16:  		/* mr R5, R24 */
		/* 82173138h case   16:*/		regs.R5 = regs.R24;
		/* 82173138h case   16:*/		return 0x8217313C;
		  /* 8217313Ch */ case   17:  		/* mr R4, R29 */
		/* 8217313Ch case   17:*/		regs.R4 = regs.R29;
		/* 8217313Ch case   17:*/		return 0x82173140;
		  /* 82173140h */ case   18:  		/* mr R3, R30 */
		/* 82173140h case   18:*/		regs.R3 = regs.R30;
		/* 82173140h case   18:*/		return 0x82173144;
		  /* 82173144h */ case   19:  		/* bl -5692 */
		/* 82173144h case   19:*/		regs.LR = 0x82173148; return 0x82171B08;
		/* 82173144h case   19:*/		return 0x82173148;
	}
	return 0x82173148;
} // Block from 821730F8h-82173148h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82173148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173148);
		  /* 82173148h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 82173148h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82173148h case    0:*/		return 0x8217314C;
		  /* 8217314Ch */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8217314Ch case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8217314Ch case    1:*/		return 0x82173150;
		  /* 82173150h */ case    2:  		/* bc 12, CR0_EQ, 176 */
		/* 82173150h case    2:*/		if ( regs.CR[0].eq ) { return 0x82173200;  }
		/* 82173150h case    2:*/		return 0x82173154;
		  /* 82173154h */ case    3:  		/* lwz R7, <#[R24 + 4]> */
		/* 82173154h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000004) );
		/* 82173154h case    3:*/		return 0x82173158;
		  /* 82173158h */ case    4:  		/* mr R4, R21 */
		/* 82173158h case    4:*/		regs.R4 = regs.R21;
		/* 82173158h case    4:*/		return 0x8217315C;
		  /* 8217315Ch */ case    5:  		/* mr R5, R21 */
		/* 8217315Ch case    5:*/		regs.R5 = regs.R21;
		/* 8217315Ch case    5:*/		return 0x82173160;
		  /* 82173160h */ case    6:  		/* cmplwi CR6, R7, 0 */
		/* 82173160h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82173160h case    6:*/		return 0x82173164;
		  /* 82173164h */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 82173164h case    7:*/		if ( regs.CR[6].eq ) { return 0x821731CC;  }
		/* 82173164h case    7:*/		return 0x82173168;
		  /* 82173168h */ case    8:  		/* lwz R11, <#[R7 + 16]> */
		/* 82173168h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000010) );
		/* 82173168h case    8:*/		return 0x8217316C;
		  /* 8217316Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8217316Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217316Ch case    9:*/		return 0x82173170;
		  /* 82173170h */ case   10:  		/* bc 12, CR6_EQ, 84 */
		/* 82173170h case   10:*/		if ( regs.CR[6].eq ) { return 0x821731C4;  }
		/* 82173170h case   10:*/		return 0x82173174;
		  /* 82173174h */ case   11:  		/* lwz R6, <#[R7]> */
		/* 82173174h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 82173174h case   11:*/		return 0x82173178;
		  /* 82173178h */ case   12:  		/* rlwinm. R8, R6, 7, 29, 31 */
		/* 82173178h case   12:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R6);
		/* 82173178h case   12:*/		return 0x8217317C;
		  /* 8217317Ch */ case   13:  		/* bc 12, CR0_EQ, 72 */
		/* 8217317Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x821731C4;  }
		/* 8217317Ch case   13:*/		return 0x82173180;
		  /* 82173180h */ case   14:  		/* mr R4, R7 */
		/* 82173180h case   14:*/		regs.R4 = regs.R7;
		/* 82173180h case   14:*/		return 0x82173184;
		  /* 82173184h */ case   15:  		/* mr R9, R21 */
		/* 82173184h case   15:*/		regs.R9 = regs.R21;
		/* 82173184h case   15:*/		return 0x82173188;
		  /* 82173188h */ case   16:  		/* mr R11, R21 */
		/* 82173188h case   16:*/		regs.R11 = regs.R21;
		/* 82173188h case   16:*/		return 0x8217318C;
		  /* 8217318Ch */ case   17:  		/* cmplwi CR6, R8, 0 */
		/* 8217318Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8217318Ch case   17:*/		return 0x82173190;
		  /* 82173190h */ case   18:  		/* bc 12, CR6_EQ, 48 */
		/* 82173190h case   18:*/		if ( regs.CR[6].eq ) { return 0x821731C0;  }
		/* 82173190h case   18:*/		return 0x82173194;
		  /* 82173194h */ case   19:  		/* mr R10, R21 */
		/* 82173194h case   19:*/		regs.R10 = regs.R21;
		/* 82173194h case   19:*/		return 0x82173198;
	}
	return 0x82173198;
} // Block from 82173148h-82173198h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82173198h
// Function '?FindFailedSolution@Compiler@D3DXShader@@AAA_NPAURegOptSolutionStep@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173198);
		  /* 82173198h */ case    0:  		/* rlwinm R3, R6, 27, 24, 31 */
		/* 82173198h case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R3,regs.R6);
		/* 82173198h case    0:*/		return 0x8217319C;
		  /* 8217319Ch */ case    1:  		/* li R30, 1 */
		/* 8217319Ch case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8217319Ch case    1:*/		return 0x821731A0;
		  /* 821731A0h */ case    2:  		/* srw R3, R3, R10 */
		/* 821731A0h case    2:*/		cpu::op::srw<0>(regs,&regs.R3,regs.R3,regs.R10);
		/* 821731A0h case    2:*/		return 0x821731A4;
		  /* 821731A4h */ case    3:  		/* rlwinm R3, R3, 0, 30, 31 */
		/* 821731A4h case    3:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R3);
		/* 821731A4h case    3:*/		return 0x821731A8;
		  /* 821731A8h */ case    4:  		/* addi R11, R11, 1 */
		/* 821731A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821731A8h case    4:*/		return 0x821731AC;
		  /* 821731ACh */ case    5:  		/* slw R3, R30, R3 */
		/* 821731ACh case    5:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R30,regs.R3);
		/* 821731ACh case    5:*/		return 0x821731B0;
		  /* 821731B0h */ case    6:  		/* or R9, R3, R9 */
		/* 821731B0h case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R3,regs.R9);
		/* 821731B0h case    6:*/		return 0x821731B4;
		  /* 821731B4h */ case    7:  		/* addi R10, R10, 2 */
		/* 821731B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821731B4h case    7:*/		return 0x821731B8;
		  /* 821731B8h */ case    8:  		/* cmplw CR6, R11, R8 */
		/* 821731B8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821731B8h case    8:*/		return 0x821731BC;
		  /* 821731BCh */ case    9:  		/* bc 12, CR6_LT, -36 */
		/* 821731BCh case    9:*/		if ( regs.CR[6].lt ) { return 0x82173198;  }
		/* 821731BCh case    9:*/		return 0x821731C0;
	}
	return 0x821731C0;
} // Block from 82173198h-821731C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821731C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821731C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821731C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821731C0);
		  /* 821731C0h */ case    0:  		/* or R5, R9, R5 */
		/* 821731C0h case    0:*/		cpu::op::or<0>(regs,&regs.R5,regs.R9,regs.R5);
		/* 821731C0h case    0:*/		return 0x821731C4;
	}
	return 0x821731C4;
} // Block from 821731C0h-821731C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821731C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821731C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821731C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821731C4);
		  /* 821731C4h */ case    0:  		/* lwz R7, <#[R7 + 8]> */
		/* 821731C4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000008) );
		/* 821731C4h case    0:*/		return 0x821731C8;
		  /* 821731C8h */ case    1:  		/* b -104 */
		/* 821731C8h case    1:*/		return 0x82173160;
		/* 821731C8h case    1:*/		return 0x821731CC;
	}
	return 0x821731CC;
} // Block from 821731C4h-821731CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821731CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821731CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821731CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821731CC);
		  /* 821731CCh */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 821731CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821731CCh case    0:*/		return 0x821731D0;
		  /* 821731D0h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 821731D0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82173200;  }
		/* 821731D0h case    1:*/		return 0x821731D4;
		  /* 821731D4h */ case    2:  		/* lwz R11, <#[R4]> */
		/* 821731D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821731D4h case    2:*/		return 0x821731D8;
		  /* 821731D8h */ case    3:  		/* lwz R30, <#[R23 + 56]> */
		/* 821731D8h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R23 + 0x00000038) );
		/* 821731D8h case    3:*/		return 0x821731DC;
		  /* 821731DCh */ case    4:  		/* rlwimi R5, R11, 19, 20, 27 */
		/* 821731DCh case    4:*/		cpu::op::rlwimi<0,19,20,27>(regs,&regs.R5,regs.R11);
		/* 821731DCh case    4:*/		return 0x821731E0;
		  /* 821731E0h */ case    5:  		/* mr R3, R30 */
		/* 821731E0h case    5:*/		regs.R3 = regs.R30;
		/* 821731E0h case    5:*/		return 0x821731E4;
		  /* 821731E4h */ case    6:  		/* rlwinm R29, R5, 0, 20, 31 */
		/* 821731E4h case    6:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R29,regs.R5);
		/* 821731E4h case    6:*/		return 0x821731E8;
		  /* 821731E8h */ case    7:  		/* mr R4, R29 */
		/* 821731E8h case    7:*/		regs.R4 = regs.R29;
		/* 821731E8h case    7:*/		return 0x821731EC;
		  /* 821731ECh */ case    8:  		/* bl -1508 */
		/* 821731ECh case    8:*/		regs.LR = 0x821731F0; return 0x82172C08;
		/* 821731ECh case    8:*/		return 0x821731F0;
		  /* 821731F0h */ case    9:  		/* mr R5, R24 */
		/* 821731F0h case    9:*/		regs.R5 = regs.R24;
		/* 821731F0h case    9:*/		return 0x821731F4;
		  /* 821731F4h */ case   10:  		/* mr R4, R29 */
		/* 821731F4h case   10:*/		regs.R4 = regs.R29;
		/* 821731F4h case   10:*/		return 0x821731F8;
		  /* 821731F8h */ case   11:  		/* mr R3, R30 */
		/* 821731F8h case   11:*/		regs.R3 = regs.R30;
		/* 821731F8h case   11:*/		return 0x821731FC;
		  /* 821731FCh */ case   12:  		/* bl -5876 */
		/* 821731FCh case   12:*/		regs.LR = 0x82173200; return 0x82171B08;
		/* 821731FCh case   12:*/		return 0x82173200;
	}
	return 0x82173200;
} // Block from 821731CCh-82173200h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82173200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173200);
		  /* 82173200h */ case    0:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 82173200h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 82173200h case    0:*/		return 0x82173204;
		  /* 82173204h */ case    1:  		/* lwz R4, <#[R11 + 40]> */
		/* 82173204h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000028) );
		/* 82173204h case    1:*/		return 0x82173208;
		  /* 82173208h */ case    2:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 82173208h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 82173208h case    2:*/		return 0x8217320C;
		  /* 8217320Ch */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 8217320Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82173224;  }
		/* 8217320Ch case    3:*/		return 0x82173210;
		  /* 82173210h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 82173210h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82173210h case    4:*/		return 0x82173214;
		  /* 82173214h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82173214h case    5:*/		if ( regs.CR[6].eq ) { return 0x82173224;  }
		/* 82173214h case    5:*/		return 0x82173218;
		  /* 82173218h */ case    6:  		/* mr R3, R31 */
		/* 82173218h case    6:*/		regs.R3 = regs.R31;
		/* 82173218h case    6:*/		return 0x8217321C;
		  /* 8217321Ch */ case    7:  		/* bl -17180 */
		/* 8217321Ch case    7:*/		regs.LR = 0x82173220; return 0x8216EF00;
		/* 8217321Ch case    7:*/		return 0x82173220;
		  /* 82173220h */ case    8:  		/* b 12 */
		/* 82173220h case    8:*/		return 0x8217322C;
		/* 82173220h case    8:*/		return 0x82173224;
	}
	return 0x82173224;
} // Block from 82173200h-82173224h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82173224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173224);
		  /* 82173224h */ case    0:  		/* stw R21, <#[R31 + 40]> */
		/* 82173224h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000028) );
		/* 82173224h case    0:*/		return 0x82173228;
		  /* 82173228h */ case    1:  		/* stw R21, <#[R31 + 48]> */
		/* 82173228h case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000030) );
		/* 82173228h case    1:*/		return 0x8217322C;
	}
	return 0x8217322C;
} // Block from 82173224h-8217322Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217322Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217322C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217322C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217322C);
		  /* 8217322Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 8217322Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8217322Ch case    0:*/		return 0x82173230;
		  /* 82173230h */ case    1:  		/* b -925604 */
		/* 82173230h case    1:*/		return 0x8209128C;
		/* 82173230h case    1:*/		return 0x82173234;
		  /* 82173234h */ case    2:  		/* nop */
		/* 82173234h case    2:*/		cpu::op::nop();
		/* 82173234h case    2:*/		return 0x82173238;
	}
	return 0x82173238;
} // Block from 8217322Ch-82173238h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173238);
		  /* 82173238h */ case    0:  		/* mfspr R12, LR */
		/* 82173238h case    0:*/		regs.R12 = regs.LR;
		/* 82173238h case    0:*/		return 0x8217323C;
		  /* 8217323Ch */ case    1:  		/* bl -925676 */
		/* 8217323Ch case    1:*/		regs.LR = 0x82173240; return 0x82091250;
		/* 8217323Ch case    1:*/		return 0x82173240;
		  /* 82173240h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82173240h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82173240h case    2:*/		return 0x82173244;
		  /* 82173244h */ case    3:  		/* mr R31, R3 */
		/* 82173244h case    3:*/		regs.R31 = regs.R3;
		/* 82173244h case    3:*/		return 0x82173248;
		  /* 82173248h */ case    4:  		/* lwz R3, <#[R4 + 88]> */
		/* 82173248h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000058) );
		/* 82173248h case    4:*/		return 0x8217324C;
		  /* 8217324Ch */ case    5:  		/* mr R27, R4 */
		/* 8217324Ch case    5:*/		regs.R27 = regs.R4;
		/* 8217324Ch case    5:*/		return 0x82173250;
		  /* 82173250h */ case    6:  		/* mr R26, R5 */
		/* 82173250h case    6:*/		regs.R26 = regs.R5;
		/* 82173250h case    6:*/		return 0x82173254;
		  /* 82173254h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 82173254h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82173254h case    7:*/		return 0x82173258;
		  /* 82173258h */ case    8:  		/* bc 12, CR6_EQ, 204 */
		/* 82173258h case    8:*/		if ( regs.CR[6].eq ) { return 0x82173324;  }
		/* 82173258h case    8:*/		return 0x8217325C;
		  /* 8217325Ch */ case    9:  		/* li R4, 0 */
		/* 8217325Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8217325Ch case    9:*/		return 0x82173260;
		  /* 82173260h */ case   10:  		/* lwz R5, <#[R31 + 672]> */
		/* 82173260h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 82173260h case   10:*/		return 0x82173264;
		  /* 82173264h */ case   11:  		/* bl -17164 */
		/* 82173264h case   11:*/		regs.LR = 0x82173268; return 0x8216EF58;
		/* 82173264h case   11:*/		return 0x82173268;
		  /* 82173268h */ case   12:  		/* lwz R11, <#[R31 + 668]> */
		/* 82173268h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 82173268h case   12:*/		return 0x8217326C;
		  /* 8217326Ch */ case   13:  		/* mr R30, R3 */
		/* 8217326Ch case   13:*/		regs.R30 = regs.R3;
		/* 8217326Ch case   13:*/		return 0x82173270;
		  /* 82173270h */ case   14:  		/* addi R11, R11, -1 */
		/* 82173270h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82173270h case   14:*/		return 0x82173274;
		  /* 82173274h */ case   15:  		/* cmplw CR6, R3, R11 */
		/* 82173274h case   15:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82173274h case   15:*/		return 0x82173278;
		  /* 82173278h */ case   16:  		/* bc 12, CR6_GT, 172 */
		/* 82173278h case   16:*/		if ( regs.CR[6].gt ) { return 0x82173324;  }
		/* 82173278h case   16:*/		return 0x8217327C;
		  /* 8217327Ch */ case   17:  		/* lwz R29, <#[R1 + 80]> */
		/* 8217327Ch case   17:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 8217327Ch case   17:*/		return 0x82173280;
		  /* 82173280h */ case   18:  		/* lwz R11, <#[R31 + 708]> */
		/* 82173280h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002C4) );
		/* 82173280h case   18:*/		return 0x82173284;
		  /* 82173284h */ case   19:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82173284h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82173284h case   19:*/		return 0x82173288;
		  /* 82173288h */ case   20:  		/* lwzx R28, <#[R10 + R11]> */
		/* 82173288h case   20:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82173288h case   20:*/		return 0x8217328C;
		  /* 8217328Ch */ case   21:  		/* lwz R11, <#[R28 + 4]> */
		/* 8217328Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8217328Ch case   21:*/		return 0x82173290;
		  /* 82173290h */ case   22:  		/* cmplwi CR6, R11, 0 */
		/* 82173290h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82173290h case   22:*/		return 0x82173294;
		  /* 82173294h */ case   23:  		/* bc 12, CR6_EQ, 24 */
		/* 82173294h case   23:*/		if ( regs.CR[6].eq ) { return 0x821732AC;  }
		/* 82173294h case   23:*/		return 0x82173298;
		  /* 82173298h */ case   24:  		/* lwz R10, <#[R11]> */
		/* 82173298h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82173298h case   24:*/		return 0x8217329C;
		  /* 8217329Ch */ case   25:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 8217329Ch case   25:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 8217329Ch case   25:*/		return 0x821732A0;
		  /* 821732A0h */ case   26:  		/* bc 4, CR0_EQ, 12 */
		/* 821732A0h case   26:*/		if ( !regs.CR[0].eq ) { return 0x821732AC;  }
		/* 821732A0h case   26:*/		return 0x821732A4;
		  /* 821732A4h */ case   27:  		/* lwz R11, <#[R11 + 8]> */
		/* 821732A4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821732A4h case   27:*/		return 0x821732A8;
		  /* 821732A8h */ case   28:  		/* b -24 */
		/* 821732A8h case   28:*/		return 0x82173290;
		/* 821732A8h case   28:*/		return 0x821732AC;
	}
	return 0x821732AC;
} // Block from 82173238h-821732ACh (29 instructions)

//////////////////////////////////////////////////////
// Block at 821732ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821732AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821732AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821732AC);
		  /* 821732ACh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821732ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821732ACh case    0:*/		return 0x821732B0;
		  /* 821732B0h */ case    1:  		/* mr R5, R28 */
		/* 821732B0h case    1:*/		regs.R5 = regs.R28;
		/* 821732B0h case    1:*/		return 0x821732B4;
		  /* 821732B4h */ case    2:  		/* mr R4, R27 */
		/* 821732B4h case    2:*/		regs.R4 = regs.R27;
		/* 821732B4h case    2:*/		return 0x821732B8;
		  /* 821732B8h */ case    3:  		/* rlwimi R29, R11, 19, 20, 27 */
		/* 821732B8h case    3:*/		cpu::op::rlwimi<0,19,20,27>(regs,&regs.R29,regs.R11);
		/* 821732B8h case    3:*/		return 0x821732BC;
		  /* 821732BCh */ case    4:  		/* mr R3, R31 */
		/* 821732BCh case    4:*/		regs.R3 = regs.R31;
		/* 821732BCh case    4:*/		return 0x821732C0;
		  /* 821732C0h */ case    5:  		/* rlwinm R29, R29, 0, 20, 31 */
		/* 821732C0h case    5:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R29,regs.R29);
		/* 821732C0h case    5:*/		return 0x821732C4;
		  /* 821732C4h */ case    6:  		/* bl -8540 */
		/* 821732C4h case    6:*/		regs.LR = 0x821732C8; return 0x82171168;
		/* 821732C4h case    6:*/		return 0x821732C8;
		  /* 821732C8h */ case    7:  		/* mr R11, R3 */
		/* 821732C8h case    7:*/		regs.R11 = regs.R3;
		/* 821732C8h case    7:*/		return 0x821732CC;
		  /* 821732CCh */ case    8:  		/* mr R3, R26 */
		/* 821732CCh case    8:*/		regs.R3 = regs.R26;
		/* 821732CCh case    8:*/		return 0x821732D0;
		  /* 821732D0h */ case    9:  		/* rlwimi R11, R29, 0, 0, 27 */
		/* 821732D0h case    9:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R29);
		/* 821732D0h case    9:*/		return 0x821732D4;
		  /* 821732D4h */ case   10:  		/* mr R4, R11 */
		/* 821732D4h case   10:*/		regs.R4 = regs.R11;
		/* 821732D4h case   10:*/		return 0x821732D8;
		  /* 821732D8h */ case   11:  		/* mr R29, R11 */
		/* 821732D8h case   11:*/		regs.R29 = regs.R11;
		/* 821732D8h case   11:*/		return 0x821732DC;
		  /* 821732DCh */ case   12:  		/* bl -1748 */
		/* 821732DCh case   12:*/		regs.LR = 0x821732E0; return 0x82172C08;
		/* 821732DCh case   12:*/		return 0x821732E0;
		  /* 821732E0h */ case   13:  		/* mr R5, R28 */
		/* 821732E0h case   13:*/		regs.R5 = regs.R28;
		/* 821732E0h case   13:*/		return 0x821732E4;
		  /* 821732E4h */ case   14:  		/* mr R4, R29 */
		/* 821732E4h case   14:*/		regs.R4 = regs.R29;
		/* 821732E4h case   14:*/		return 0x821732E8;
		  /* 821732E8h */ case   15:  		/* mr R3, R26 */
		/* 821732E8h case   15:*/		regs.R3 = regs.R26;
		/* 821732E8h case   15:*/		return 0x821732EC;
		  /* 821732ECh */ case   16:  		/* bl -6116 */
		/* 821732ECh case   16:*/		regs.LR = 0x821732F0; return 0x82171B08;
		/* 821732ECh case   16:*/		return 0x821732F0;
		  /* 821732F0h */ case   17:  		/* lwz R11, <#[R31 + 668]> */
		/* 821732F0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 821732F0h case   17:*/		return 0x821732F4;
		  /* 821732F4h */ case   18:  		/* addi R28, R11, -1 */
		/* 821732F4h case   18:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFFF);
		/* 821732F4h case   18:*/		return 0x821732F8;
		  /* 821732F8h */ case   19:  		/* cmplw CR6, R30, R28 */
		/* 821732F8h case   19:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 821732F8h case   19:*/		return 0x821732FC;
		  /* 821732FCh */ case   20:  		/* bc 4, CR6_EQ, 12 */
		/* 821732FCh case   20:*/		if ( !regs.CR[6].eq ) { return 0x82173308;  }
		/* 821732FCh case   20:*/		return 0x82173300;
		  /* 82173300h */ case   21:  		/* li R30, -1 */
		/* 82173300h case   21:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82173300h case   21:*/		return 0x82173304;
		  /* 82173304h */ case   22:  		/* b 24 */
		/* 82173304h case   22:*/		return 0x8217331C;
		/* 82173304h case   22:*/		return 0x82173308;
	}
	return 0x82173308;
} // Block from 821732ACh-82173308h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82173308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173308);
		  /* 82173308h */ case    0:  		/* addi R4, R30, 1 */
		/* 82173308h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x1);
		/* 82173308h case    0:*/		return 0x8217330C;
		  /* 8217330Ch */ case    1:  		/* lwz R5, <#[R31 + 672]> */
		/* 8217330Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 8217330Ch case    1:*/		return 0x82173310;
		  /* 82173310h */ case    2:  		/* lwz R3, <#[R27 + 88]> */
		/* 82173310h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000058) );
		/* 82173310h case    2:*/		return 0x82173314;
		  /* 82173314h */ case    3:  		/* bl -17340 */
		/* 82173314h case    3:*/		regs.LR = 0x82173318; return 0x8216EF58;
		/* 82173314h case    3:*/		return 0x82173318;
		  /* 82173318h */ case    4:  		/* mr R30, R3 */
		/* 82173318h case    4:*/		regs.R30 = regs.R3;
		/* 82173318h case    4:*/		return 0x8217331C;
	}
	return 0x8217331C;
} // Block from 82173308h-8217331Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8217331Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217331C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217331C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217331C);
		  /* 8217331Ch */ case    0:  		/* cmplw CR6, R30, R28 */
		/* 8217331Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 8217331Ch case    0:*/		return 0x82173320;
		  /* 82173320h */ case    1:  		/* bc 4, CR6_GT, -160 */
		/* 82173320h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82173280;  }
		/* 82173320h case    1:*/		return 0x82173324;
	}
	return 0x82173324;
} // Block from 8217331Ch-82173324h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173324);
		  /* 82173324h */ case    0:  		/* addi R1, R1, 144 */
		/* 82173324h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82173324h case    0:*/		return 0x82173328;
		  /* 82173328h */ case    1:  		/* b -925832 */
		/* 82173328h case    1:*/		return 0x820912A0;
		/* 82173328h case    1:*/		return 0x8217332C;
		  /* 8217332Ch */ case    2:  		/* nop */
		/* 8217332Ch case    2:*/		cpu::op::nop();
		/* 8217332Ch case    2:*/		return 0x82173330;
	}
	return 0x82173330;
} // Block from 82173324h-82173330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173330);
		  /* 82173330h */ case    0:  		/* mfspr R12, LR */
		/* 82173330h case    0:*/		regs.R12 = regs.LR;
		/* 82173330h case    0:*/		return 0x82173334;
		  /* 82173334h */ case    1:  		/* bl -925972 */
		/* 82173334h case    1:*/		regs.LR = 0x82173338; return 0x82091220;
		/* 82173334h case    1:*/		return 0x82173338;
		  /* 82173338h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 82173338h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82173338h case    2:*/		return 0x8217333C;
		  /* 8217333Ch */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8217333Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8217333Ch case    3:*/		return 0x82173340;
		  /* 82173340h */ case    4:  		/* mr R17, R3 */
		/* 82173340h case    4:*/		regs.R17 = regs.R3;
		/* 82173340h case    4:*/		return 0x82173344;
		  /* 82173344h */ case    5:  		/* mr R21, R4 */
		/* 82173344h case    5:*/		regs.R21 = regs.R4;
		/* 82173344h case    5:*/		return 0x82173348;
		  /* 82173348h */ case    6:  		/* mr R16, R5 */
		/* 82173348h case    6:*/		regs.R16 = regs.R5;
		/* 82173348h case    6:*/		return 0x8217334C;
		  /* 8217334Ch */ case    7:  		/* mr R20, R6 */
		/* 8217334Ch case    7:*/		regs.R20 = regs.R6;
		/* 8217334Ch case    7:*/		return 0x82173350;
		  /* 82173350h */ case    8:  		/* mr R15, R7 */
		/* 82173350h case    8:*/		regs.R15 = regs.R7;
		/* 82173350h case    8:*/		return 0x82173354;
		  /* 82173354h */ case    9:  		/* li R19, 0 */
		/* 82173354h case    9:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82173354h case    9:*/		return 0x82173358;
		  /* 82173358h */ case   10:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 82173358h case   10:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 82173358h case   10:*/		return 0x8217335C;
		  /* 8217335Ch */ case   11:  		/* bc 12, CR0_EQ, 148 */
		/* 8217335Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x821733F0;  }
		/* 8217335Ch case   11:*/		return 0x82173360;
		  /* 82173360h */ case   12:  		/* lwz R10, <#[R4 + 4]> */
		/* 82173360h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82173360h case   12:*/		return 0x82173364;
		  /* 82173364h */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 82173364h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82173364h case   13:*/		return 0x82173368;
		  /* 82173368h */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 82173368h case   14:*/		if ( regs.CR[6].eq ) { return 0x8217338C;  }
		/* 82173368h case   14:*/		return 0x8217336C;
		  /* 8217336Ch */ case   15:  		/* lwz R9, <#[R10 + 16]> */
		/* 8217336Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8217336Ch case   15:*/		return 0x82173370;
		  /* 82173370h */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 82173370h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82173370h case   16:*/		return 0x82173374;
		  /* 82173374h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 82173374h case   17:*/		if ( regs.CR[6].eq ) { return 0x82173384;  }
		/* 82173374h case   17:*/		return 0x82173378;
		  /* 82173378h */ case   18:  		/* lwz R9, <#[R10]> */
		/* 82173378h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82173378h case   18:*/		return 0x8217337C;
		  /* 8217337Ch */ case   19:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 8217337Ch case   19:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 8217337Ch case   19:*/		return 0x82173380;
		  /* 82173380h */ case   20:  		/* bc 4, CR0_EQ, 12 */
		/* 82173380h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8217338C;  }
		/* 82173380h case   20:*/		return 0x82173384;
	}
	return 0x82173384;
} // Block from 82173330h-82173384h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82173384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173384);
		  /* 82173384h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82173384h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82173384h case    0:*/		return 0x82173388;
		  /* 82173388h */ case    1:  		/* b -36 */
		/* 82173388h case    1:*/		return 0x82173364;
		/* 82173388h case    1:*/		return 0x8217338C;
	}
	return 0x8217338C;
} // Block from 82173384h-8217338Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217338Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217338C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217338C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217338C);
		  /* 8217338Ch */ case    0:  		/* lwz R10, <#[R10]> */
		/* 8217338Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8217338Ch case    0:*/		return 0x82173390;
		  /* 82173390h */ case    1:  		/* rlwimi R11, R10, 20, 27, 30 */
		/* 82173390h case    1:*/		cpu::op::rlwimi<0,20,27,30>(regs,&regs.R11,regs.R10);
		/* 82173390h case    1:*/		return 0x82173394;
		  /* 82173394h */ case    2:  		/* stw R11, <#[R21 + 8]> */
		/* 82173394h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82173394h case    2:*/		return 0x82173398;
		  /* 82173398h */ case    3:  		/* lwz R31, <#[R21]> */
		/* 82173398h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000000) );
		/* 82173398h case    3:*/		return 0x8217339C;
		  /* 8217339Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8217339Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8217339Ch case    4:*/		return 0x821733A0;
		  /* 821733A0h */ case    5:  		/* bc 12, CR6_EQ, 240 */
		/* 821733A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82173490;  }
		/* 821733A0h case    5:*/		return 0x821733A4;
		  /* 821733A4h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 821733A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821733A4h case    6:*/		return 0x821733A8;
	}
	return 0x821733A8;
} // Block from 8217338Ch-821733A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821733A8h
// Function '?Init@?$RegisterSet@V?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@$1?PrintVirtualRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821733A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821733A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821733A8);
		  /* 821733A8h */ case    0:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821733A8h case    0:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821733A8h case    0:*/		return 0x821733AC;
		  /* 821733ACh */ case    1:  		/* bc 12, CR0_EQ, 60 */
		/* 821733ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x821733E8;  }
		/* 821733ACh case    1:*/		return 0x821733B0;
		  /* 821733B0h */ case    2:  		/* lwz R30, <#[R31 + 12]> */
		/* 821733B0h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 821733B0h case    2:*/		return 0x821733B4;
		  /* 821733B4h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 821733B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821733B4h case    3:*/		return 0x821733B8;
		  /* 821733B8h */ case    4:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 821733B8h case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 821733B8h case    4:*/		return 0x821733BC;
		  /* 821733BCh */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 821733BCh case    5:*/		if ( regs.CR[0].eq ) { return 0x821733E8;  }
		/* 821733BCh case    5:*/		return 0x821733C0;
		  /* 821733C0h */ case    6:  		/* mr R3, R31 */
		/* 821733C0h case    6:*/		regs.R3 = regs.R31;
		/* 821733C0h case    6:*/		return 0x821733C4;
		  /* 821733C4h */ case    7:  		/* bl -17964 */
		/* 821733C4h case    7:*/		regs.LR = 0x821733C8; return 0x8216ED98;
		/* 821733C4h case    7:*/		return 0x821733C8;
		  /* 821733C8h */ case    8:  		/* mr R29, R3 */
		/* 821733C8h case    8:*/		regs.R29 = regs.R3;
		/* 821733C8h case    8:*/		return 0x821733CC;
		  /* 821733CCh */ case    9:  		/* mr R3, R20 */
		/* 821733CCh case    9:*/		regs.R3 = regs.R20;
		/* 821733CCh case    9:*/		return 0x821733D0;
		  /* 821733D0h */ case   10:  		/* mr R4, R29 */
		/* 821733D0h case   10:*/		regs.R4 = regs.R29;
		/* 821733D0h case   10:*/		return 0x821733D4;
		  /* 821733D4h */ case   11:  		/* bl -1996 */
		/* 821733D4h case   11:*/		regs.LR = 0x821733D8; return 0x82172C08;
		/* 821733D4h case   11:*/		return 0x821733D8;
		  /* 821733D8h */ case   12:  		/* mr R5, R30 */
		/* 821733D8h case   12:*/		regs.R5 = regs.R30;
		/* 821733D8h case   12:*/		return 0x821733DC;
		  /* 821733DCh */ case   13:  		/* mr R4, R29 */
		/* 821733DCh case   13:*/		regs.R4 = regs.R29;
		/* 821733DCh case   13:*/		return 0x821733E0;
		  /* 821733E0h */ case   14:  		/* mr R3, R20 */
		/* 821733E0h case   14:*/		regs.R3 = regs.R20;
		/* 821733E0h case   14:*/		return 0x821733E4;
		  /* 821733E4h */ case   15:  		/* bl -6364 */
		/* 821733E4h case   15:*/		regs.LR = 0x821733E8; return 0x82171B08;
		/* 821733E4h case   15:*/		return 0x821733E8;
	}
	return 0x821733E8;
} // Block from 821733A8h-821733E8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821733E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821733E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821733E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821733E8);
		  /* 821733E8h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 821733E8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821733E8h case    0:*/		return 0x821733EC;
		  /* 821733ECh */ case    1:  		/* b -80 */
		/* 821733ECh case    1:*/		return 0x8217339C;
		/* 821733ECh case    1:*/		return 0x821733F0;
	}
	return 0x821733F0;
} // Block from 821733E8h-821733F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821733F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821733F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821733F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821733F0);
		  /* 821733F0h */ case    0:  		/* lwz R10, <#[R21 + 20]> */
		/* 821733F0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000014) );
		/* 821733F0h case    0:*/		return 0x821733F4;
		  /* 821733F4h */ case    1:  		/* rlwinm R10, R10, 19, 13, 31 */
		/* 821733F4h case    1:*/		cpu::op::rlwinm<0,19,13,31>(regs,&regs.R10,regs.R10);
		/* 821733F4h case    1:*/		return 0x821733F8;
		  /* 821733F8h */ case    2:  		/* rlwinm. R9, R10, 0, 28, 31 */
		/* 821733F8h case    2:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R9,regs.R10);
		/* 821733F8h case    2:*/		return 0x821733FC;
		  /* 821733FCh */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 821733FCh case    3:*/		if ( regs.CR[0].eq ) { return 0x82173414;  }
		/* 821733FCh case    3:*/		return 0x82173400;
		  /* 82173400h */ case    4:  		/* rlwinm R19, R10, 0, 20, 31 */
		/* 82173400h case    4:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R19,regs.R10);
		/* 82173400h case    4:*/		return 0x82173404;
		  /* 82173404h */ case    5:  		/* mr R3, R20 */
		/* 82173404h case    5:*/		regs.R3 = regs.R20;
		/* 82173404h case    5:*/		return 0x82173408;
		  /* 82173408h */ case    6:  		/* mr R4, R19 */
		/* 82173408h case    6:*/		regs.R4 = regs.R19;
		/* 82173408h case    6:*/		return 0x8217340C;
		  /* 8217340Ch */ case    7:  		/* bl -3820 */
		/* 8217340Ch case    7:*/		regs.LR = 0x82173410; return 0x82172520;
		/* 8217340Ch case    7:*/		return 0x82173410;
		  /* 82173410h */ case    8:  		/* b -120 */
		/* 82173410h case    8:*/		return 0x82173398;
		/* 82173410h case    8:*/		return 0x82173414;
	}
	return 0x82173414;
} // Block from 821733F0h-82173414h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82173414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173414);
		  /* 82173414h */ case    0:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82173414h case    0:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82173414h case    0:*/		return 0x82173418;
		  /* 82173418h */ case    1:  		/* cmplwi CR6, R10, 15360 */
		/* 82173418h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003C00);
		/* 82173418h case    1:*/		return 0x8217341C;
		  /* 8217341Ch */ case    2:  		/* bc 12, CR6_EQ, -132 */
		/* 8217341Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82173398;  }
		/* 8217341Ch case    2:*/		return 0x82173420;
	}
	return 0x82173420;
} // Block from 82173414h-82173420h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173420h
// Function '?Init@?$RegisterSet@V?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@$1?PrintVirtualRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173420);
		  /* 82173420h */ case    0:  		/* lwz R10, <#[R21 + 4]> */
		/* 82173420h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000004) );
		/* 82173420h case    0:*/		return 0x82173424;
		  /* 82173424h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82173424h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82173424h case    1:*/		return 0x82173428;
		  /* 82173428h */ case    2:  		/* bc 12, CR6_EQ, 80 */
		/* 82173428h case    2:*/		if ( regs.CR[6].eq ) { return 0x82173478;  }
		/* 82173428h case    2:*/		return 0x8217342C;
		  /* 8217342Ch */ case    3:  		/* lwz R9, <#[R10 + 16]> */
		/* 8217342Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8217342Ch case    3:*/		return 0x82173430;
		  /* 82173430h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82173430h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82173430h case    4:*/		return 0x82173434;
		  /* 82173434h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82173434h case    5:*/		if ( regs.CR[6].eq ) { return 0x82173444;  }
		/* 82173434h case    5:*/		return 0x82173438;
		  /* 82173438h */ case    6:  		/* lwz R9, <#[R10]> */
		/* 82173438h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82173438h case    6:*/		return 0x8217343C;
		  /* 8217343Ch */ case    7:  		/* rlwinm. R8, R9, 0, 4, 6 */
		/* 8217343Ch case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R9);
		/* 8217343Ch case    7:*/		return 0x82173440;
		  /* 82173440h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 82173440h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8217344C;  }
		/* 82173440h case    8:*/		return 0x82173444;
	}
	return 0x82173444;
} // Block from 82173420h-82173444h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82173444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173444);
		  /* 82173444h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82173444h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82173444h case    0:*/		return 0x82173448;
		  /* 82173448h */ case    1:  		/* b -36 */
		/* 82173448h case    1:*/		return 0x82173424;
		/* 82173448h case    1:*/		return 0x8217344C;
	}
	return 0x8217344C;
} // Block from 82173444h-8217344Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217344Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217344C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217344C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217344C);
		  /* 8217344Ch */ case    0:  		/* rlwimi R11, R9, 20, 19, 26 */
		/* 8217344Ch case    0:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R11,regs.R9);
		/* 8217344Ch case    0:*/		return 0x82173450;
		  /* 82173450h */ case    1:  		/* mr R3, R20 */
		/* 82173450h case    1:*/		regs.R3 = regs.R20;
		/* 82173450h case    1:*/		return 0x82173454;
		  /* 82173454h */ case    2:  		/* rlwinm R19, R11, 31, 20, 31 */
		/* 82173454h case    2:*/		cpu::op::rlwinm<0,31,20,31>(regs,&regs.R19,regs.R11);
		/* 82173454h case    2:*/		return 0x82173458;
		  /* 82173458h */ case    3:  		/* mr R4, R19 */
		/* 82173458h case    3:*/		regs.R4 = regs.R19;
		/* 82173458h case    3:*/		return 0x8217345C;
		  /* 8217345Ch */ case    4:  		/* bl -2036 */
		/* 8217345Ch case    4:*/		regs.LR = 0x82173460; return 0x82172C68;
		/* 8217345Ch case    4:*/		return 0x82173460;
		  /* 82173460h */ case    5:  		/* li R5, 0 */
		/* 82173460h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82173460h case    5:*/		return 0x82173464;
		  /* 82173464h */ case    6:  		/* mr R4, R19 */
		/* 82173464h case    6:*/		regs.R4 = regs.R19;
		/* 82173464h case    6:*/		return 0x82173468;
		  /* 82173468h */ case    7:  		/* mr R3, R20 */
		/* 82173468h case    7:*/		regs.R3 = regs.R20;
		/* 82173468h case    7:*/		return 0x8217346C;
		  /* 8217346Ch */ case    8:  		/* bl -6500 */
		/* 8217346Ch case    8:*/		regs.LR = 0x82173470; return 0x82171B08;
		/* 8217346Ch case    8:*/		return 0x82173470;
		  /* 82173470h */ case    9:  		/* cmplwi CR6, R19, 0 */
		/* 82173470h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 82173470h case    9:*/		return 0x82173474;
		  /* 82173474h */ case   10:  		/* bc 4, CR6_EQ, -220 */
		/* 82173474h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82173398;  }
		/* 82173474h case   10:*/		return 0x82173478;
	}
	return 0x82173478;
} // Block from 8217344Ch-82173478h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82173478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173478);
		  /* 82173478h */ case    0:  		/* lwz R11, <#[R21 + 8]> */
		/* 82173478h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82173478h case    0:*/		return 0x8217347C;
		  /* 8217347Ch */ case    1:  		/* rlwinm. R11, R11, 0, 15, 17 */
		/* 8217347Ch case    1:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R11);
		/* 8217347Ch case    1:*/		return 0x82173480;
		  /* 82173480h */ case    2:  		/* bc 12, CR0_EQ, -232 */
		/* 82173480h case    2:*/		if ( regs.CR[0].eq ) { return 0x82173398;  }
		/* 82173480h case    2:*/		return 0x82173484;
		  /* 82173484h */ case    3:  		/* li R4, 4800 */
		/* 82173484h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82173484h case    3:*/		return 0x82173488;
		  /* 82173488h */ case    4:  		/* mr R3, R17 */
		/* 82173488h case    4:*/		regs.R3 = regs.R17;
		/* 82173488h case    4:*/		return 0x8217348C;
		  /* 8217348Ch */ case    5:  		/* bl -136740 */
		/* 8217348Ch case    5:*/		regs.LR = 0x82173490; return 0x82151E68;
		/* 8217348Ch case    5:*/		return 0x82173490;
	}
	return 0x82173490;
} // Block from 82173478h-82173490h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82173490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173490);
		  /* 82173490h */ case    0:  		/* lwz R18, <#[R21]> */
		/* 82173490h case    0:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R21 + 0x00000000) );
		/* 82173490h case    0:*/		return 0x82173494;
		  /* 82173494h */ case    1:  		/* li R23, 0 */
		/* 82173494h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82173494h case    1:*/		return 0x82173498;
		  /* 82173498h */ case    2:  		/* li R22, 0 */
		/* 82173498h case    2:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82173498h case    2:*/		return 0x8217349C;
		  /* 8217349Ch */ case    3:  		/* cmplwi CR6, R18, 0 */
		/* 8217349Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 8217349Ch case    3:*/		return 0x821734A0;
	}
	return 0x821734A0;
} // Block from 82173490h-821734A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821734A0h
// Function '?EnsureInUse@?$RegisterSet@V?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@$1?PrintVirtualRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821734A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821734A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821734A0);
		  /* 821734A0h */ case    0:  		/* bc 12, CR6_EQ, 1440 */
		/* 821734A0h case    0:*/		if ( regs.CR[6].eq ) { return 0x82173A40;  }
		/* 821734A0h case    0:*/		return 0x821734A4;
		  /* 821734A4h */ case    1:  		/* lwz R11, <#[R18]> */
		/* 821734A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 821734A4h case    1:*/		return 0x821734A8;
		  /* 821734A8h */ case    2:  		/* rlwinm. R9, R11, 2, 31, 31 */
		/* 821734A8h case    2:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R9,regs.R11);
		/* 821734A8h case    2:*/		return 0x821734AC;
		  /* 821734ACh */ case    3:  		/* rlwinm R8, R11, 2, 30, 31 */
		/* 821734ACh case    3:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R8,regs.R11);
		/* 821734ACh case    3:*/		return 0x821734B0;
		  /* 821734B0h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 821734B0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821734C0;  }
		/* 821734B0h case    4:*/		return 0x821734B4;
		  /* 821734B4h */ case    5:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 821734B4h case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 821734B4h case    5:*/		return 0x821734B8;
		  /* 821734B8h */ case    6:  		/* li R10, 0 */
		/* 821734B8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821734B8h case    6:*/		return 0x821734BC;
		  /* 821734BCh */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 821734BCh case    7:*/		if ( regs.CR[0].eq ) { return 0x821734C4;  }
		/* 821734BCh case    7:*/		return 0x821734C0;
	}
	return 0x821734C0;
} // Block from 821734A0h-821734C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821734C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821734C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821734C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821734C0);
		  /* 821734C0h */ case    0:  		/* li R10, 1 */
		/* 821734C0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821734C0h case    0:*/		return 0x821734C4;
	}
	return 0x821734C4;
} // Block from 821734C0h-821734C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821734C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821734C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821734C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821734C4);
		  /* 821734C4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821734C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821734C4h case    0:*/		return 0x821734C8;
		  /* 821734C8h */ case    1:  		/* bc 12, CR0_EQ, 1380 */
		/* 821734C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82173A2C;  }
		/* 821734C8h case    1:*/		return 0x821734CC;
		  /* 821734CCh */ case    2:  		/* lwz R24, <#[R18 + 12]> */
		/* 821734CCh case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R18 + 0x0000000C) );
		/* 821734CCh case    2:*/		return 0x821734D0;
		  /* 821734D0h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 821734D0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821734D0h case    3:*/		return 0x821734D4;
		  /* 821734D4h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 821734D4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821734E4;  }
		/* 821734D4h case    4:*/		return 0x821734D8;
		  /* 821734D8h */ case    5:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821734D8h case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821734D8h case    5:*/		return 0x821734DC;
		  /* 821734DCh */ case    6:  		/* li R11, 1 */
		/* 821734DCh case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821734DCh case    6:*/		return 0x821734E0;
		  /* 821734E0h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 821734E0h case    7:*/		if ( regs.CR[0].eq ) { return 0x821734E8;  }
		/* 821734E0h case    7:*/		return 0x821734E4;
	}
	return 0x821734E4;
} // Block from 821734C4h-821734E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821734E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821734E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821734E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821734E4);
		  /* 821734E4h */ case    0:  		/* li R11, 0 */
		/* 821734E4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821734E4h case    0:*/		return 0x821734E8;
	}
	return 0x821734E8;
} // Block from 821734E4h-821734E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821734E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821734E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821734E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821734E8);
		  /* 821734E8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821734E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821734E8h case    0:*/		return 0x821734EC;
		  /* 821734ECh */ case    1:  		/* bc 4, CR0_EQ, 1344 */
		/* 821734ECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82173A2C;  }
		/* 821734ECh case    1:*/		return 0x821734F0;
		  /* 821734F0h */ case    2:  		/* nor R11, R8, R8 */
		/* 821734F0h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R8,regs.R8);
		/* 821734F0h case    2:*/		return 0x821734F4;
		  /* 821734F4h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821734F4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821734F4h case    3:*/		return 0x821734F8;
		  /* 821734F8h */ case    4:  		/* bc 12, CR0_EQ, 1332 */
		/* 821734F8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82173A2C;  }
		/* 821734F8h case    4:*/		return 0x821734FC;
		  /* 821734FCh */ case    5:  		/* lwz R11, <#[R24 + 20]> */
		/* 821734FCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 821734FCh case    5:*/		return 0x82173500;
	}
	return 0x82173500;
} // Block from 821734E8h-82173500h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82173500h
// Function '?EnsureFree@?$RegisterSet@V?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@$1?PrintVirtualRegister@2@YAXPAVCompiler@2@I@Z$0EA@$03$1?ReportOutOfTempRegistersError@2@YAX0@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173500);
		  /* 82173500h */ case    0:  		/* rlwinm. R11, R11, 0, 15, 18 */
		/* 82173500h case    0:*/		cpu::op::rlwinm<1,0,15,18>(regs,&regs.R11,regs.R11);
		/* 82173500h case    0:*/		return 0x82173504;
		  /* 82173504h */ case    1:  		/* bc 4, CR0_EQ, 1320 */
		/* 82173504h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82173A2C;  }
		/* 82173504h case    1:*/		return 0x82173508;
		  /* 82173508h */ case    2:  		/* cmplwi CR6, R23, 0 */
		/* 82173508h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82173508h case    2:*/		return 0x8217350C;
		  /* 8217350Ch */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 8217350Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82173528;  }
		/* 8217350Ch case    3:*/		return 0x82173510;
		  /* 82173510h */ case    4:  		/* li R5, 34 */
		/* 82173510h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x22);
		/* 82173510h case    4:*/		return 0x82173514;
		  /* 82173514h */ case    5:  		/* li R4, 8 */
		/* 82173514h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82173514h case    5:*/		return 0x82173518;
		  /* 82173518h */ case    6:  		/* mr R3, R17 */
		/* 82173518h case    6:*/		regs.R3 = regs.R17;
		/* 82173518h case    6:*/		return 0x8217351C;
		  /* 8217351Ch */ case    7:  		/* bl -60460 */
		/* 8217351Ch case    7:*/		regs.LR = 0x82173520; return 0x821648F0;
		/* 8217351Ch case    7:*/		return 0x82173520;
		  /* 82173520h */ case    8:  		/* mr R23, R3 */
		/* 82173520h case    8:*/		regs.R23 = regs.R3;
		/* 82173520h case    8:*/		return 0x82173524;
		  /* 82173524h */ case    9:  		/* b 12 */
		/* 82173524h case    9:*/		return 0x82173530;
		/* 82173524h case    9:*/		return 0x82173528;
	}
	return 0x82173528;
} // Block from 82173500h-82173528h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82173528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173528);
		  /* 82173528h */ case    0:  		/* addi R3, R23, 4 */
		/* 82173528h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R23,0x4);
		/* 82173528h case    0:*/		return 0x8217352C;
		  /* 8217352Ch */ case    1:  		/* bl -7132 */
		/* 8217352Ch case    1:*/		regs.LR = 0x82173530; return 0x82171950;
		/* 8217352Ch case    1:*/		return 0x82173530;
	}
	return 0x82173530;
} // Block from 82173528h-82173530h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173530);
		  /* 82173530h */ case    0:  		/* mr R4, R20 */
		/* 82173530h case    0:*/		regs.R4 = regs.R20;
		/* 82173530h case    0:*/		return 0x82173534;
		  /* 82173534h */ case    1:  		/* mr R3, R23 */
		/* 82173534h case    1:*/		regs.R3 = regs.R23;
		/* 82173534h case    1:*/		return 0x82173538;
		  /* 82173538h */ case    2:  		/* bl -2480 */
		/* 82173538h case    2:*/		regs.LR = 0x8217353C; return 0x82172B88;
		/* 82173538h case    2:*/		return 0x8217353C;
		  /* 8217353Ch */ case    3:  		/* lwz R11, <#[R24 + 8]> */
		/* 8217353Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8217353Ch case    3:*/		return 0x82173540;
		  /* 82173540h */ case    4:  		/* mr R28, R24 */
		/* 82173540h case    4:*/		regs.R28 = regs.R24;
		/* 82173540h case    4:*/		return 0x82173544;
		  /* 82173544h */ case    5:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82173544h case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82173544h case    5:*/		return 0x82173548;
		  /* 82173548h */ case    6:  		/* cmplwi CR6, R11, 14080 */
		/* 82173548h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82173548h case    6:*/		return 0x8217354C;
		  /* 8217354Ch */ case    7:  		/* bc 4, CR6_EQ, 188 */
		/* 8217354Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82173608;  }
		/* 8217354Ch case    7:*/		return 0x82173550;
		  /* 82173550h */ case    8:  		/* lwz R8, <#[R24]> */
		/* 82173550h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000000) );
		/* 82173550h case    8:*/		return 0x82173554;
		  /* 82173554h */ case    9:  		/* cmplwi CR6, R8, 0 */
		/* 82173554h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82173554h case    9:*/		return 0x82173558;
		  /* 82173558h */ case   10:  		/* bc 12, CR6_EQ, 176 */
		/* 82173558h case   10:*/		if ( regs.CR[6].eq ) { return 0x82173608;  }
		/* 82173558h case   10:*/		return 0x8217355C;
		  /* 8217355Ch */ case   11:  		/* lwz R10, <#[R8 + 12]> */
		/* 8217355Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x0000000C) );
		/* 8217355Ch case   11:*/		return 0x82173560;
		  /* 82173560h */ case   12:  		/* lwz R11, <#[R10 + 8]> */
		/* 82173560h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82173560h case   12:*/		return 0x82173564;
		  /* 82173564h */ case   13:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 82173564h case   13:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 82173564h case   13:*/		return 0x82173568;
	}
	return 0x82173568;
} // Block from 82173530h-82173568h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82173568h
// Function '?Init@InfiniteLocalRegisterSet@D3DXShader@@QAAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173568);
		  /* 82173568h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 82173568h case    0:*/		if ( regs.CR[0].eq ) { return 0x82173578;  }
		/* 82173568h case    0:*/		return 0x8217356C;
		  /* 8217356Ch */ case    1:  		/* lwz R11, <#[R10 + 16]> */
		/* 8217356Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 8217356Ch case    1:*/		return 0x82173570;
		  /* 82173570h */ case    2:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 82173570h case    2:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 82173570h case    2:*/		return 0x82173574;
		  /* 82173574h */ case    3:  		/* bc 12, CR0_EQ, 104 */
		/* 82173574h case    3:*/		if ( regs.CR[0].eq ) { return 0x821735DC;  }
		/* 82173574h case    3:*/		return 0x82173578;
	}
	return 0x82173578;
} // Block from 82173568h-82173578h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82173578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173578);
		  /* 82173578h */ case    0:  		/* li R9, 1 */
		/* 82173578h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82173578h case    0:*/		return 0x8217357C;
		  /* 8217357Ch */ case    1:  		/* mr R11, R10 */
		/* 8217357Ch case    1:*/		regs.R11 = regs.R10;
		/* 8217357Ch case    1:*/		return 0x82173580;
		  /* 82173580h */ case    2:  		/* cmplw CR6, R10, R28 */
		/* 82173580h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 82173580h case    2:*/		return 0x82173584;
		  /* 82173584h */ case    3:  		/* bc 12, CR6_EQ, 76 */
		/* 82173584h case    3:*/		if ( regs.CR[6].eq ) { return 0x821735D0;  }
		/* 82173584h case    3:*/		return 0x82173588;
		  /* 82173588h */ case    4:  		/* cmplw CR6, R11, R21 */
		/* 82173588h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 82173588h case    4:*/		return 0x8217358C;
		  /* 8217358Ch */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 8217358Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821735D4;  }
		/* 8217358Ch case    5:*/		return 0x82173590;
		  /* 82173590h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82173590h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82173590h case    6:*/		return 0x82173594;
		  /* 82173594h */ case    7:  		/* lwz R11, <#[R11 + 40]> */
		/* 82173594h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82173594h case    7:*/		return 0x82173598;
		  /* 82173598h */ case    8:  		/* rlwinm. R7, R11, 0, 31, 31 */
		/* 82173598h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R11);
		/* 82173598h case    8:*/		return 0x8217359C;
		  /* 8217359Ch */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 8217359Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x821735A8;  }
		/* 8217359Ch case    9:*/		return 0x821735A0;
		  /* 821735A0h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 821735A0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821735A0h case   10:*/		return 0x821735A4;
		  /* 821735A4h */ case   11:  		/* bc 4, CR6_EQ, 36 */
		/* 821735A4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821735C8;  }
		/* 821735A4h case   11:*/		return 0x821735A8;
	}
	return 0x821735A8;
} // Block from 82173578h-821735A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821735A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821735A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821735A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821735A8);
		  /* 821735A8h */ case    0:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 821735A8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 821735A8h case    0:*/		return 0x821735AC;
		  /* 821735ACh */ case    1:  		/* bc 12, CR0_EQ, 1160 */
		/* 821735ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x82173A34;  }
		/* 821735ACh case    1:*/		return 0x821735B0;
		  /* 821735B0h */ case    2:  		/* lwz R11, <#[R16 + 28]> */
		/* 821735B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x0000001C) );
		/* 821735B0h case    2:*/		return 0x821735B4;
		  /* 821735B4h */ case    3:  		/* li R9, 0 */
		/* 821735B4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821735B4h case    3:*/		return 0x821735B8;
		  /* 821735B8h */ case    4:  		/* rlwinm R7, R11, 0, 31, 31 */
		/* 821735B8h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R7,regs.R11);
		/* 821735B8h case    4:*/		return 0x821735BC;
		  /* 821735BCh */ case    5:  		/* addic R7, R7, -1 */
		/* 821735BCh case    5:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 821735BCh case    5:*/		return 0x821735C0;
		  /* 821735C0h */ case    6:  		/* subfe R7, R7, R7 */
		/* 821735C0h case    6:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R7);
		/* 821735C0h case    6:*/		return 0x821735C4;
		  /* 821735C4h */ case    7:  		/* and R11, R7, R11 */
		/* 821735C4h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 821735C4h case    7:*/		return 0x821735C8;
	}
	return 0x821735C8;
} // Block from 821735A8h-821735C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821735C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821735C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821735C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821735C8);
		  /* 821735C8h */ case    0:  		/* cmplw CR6, R11, R28 */
		/* 821735C8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 821735C8h case    0:*/		return 0x821735CC;
		  /* 821735CCh */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 821735CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82173588;  }
		/* 821735CCh case    1:*/		return 0x821735D0;
	}
	return 0x821735D0;
} // Block from 821735C8h-821735D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821735D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821735D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821735D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821735D0);
		  /* 821735D0h */ case    0:  		/* mr R28, R10 */
		/* 821735D0h case    0:*/		regs.R28 = regs.R10;
		/* 821735D0h case    0:*/		return 0x821735D4;
	}
	return 0x821735D4;
} // Block from 821735D0h-821735D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821735D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821735D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821735D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821735D4);
		  /* 821735D4h */ case    0:  		/* lwz R8, <#[R8 + 4]> */
		/* 821735D4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 821735D4h case    0:*/		return 0x821735D8;
		  /* 821735D8h */ case    1:  		/* b -132 */
		/* 821735D8h case    1:*/		return 0x82173554;
		/* 821735D8h case    1:*/		return 0x821735DC;
	}
	return 0x821735DC;
} // Block from 821735D4h-821735DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821735DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821735DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821735DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821735DC);
		  /* 821735DCh */ case    0:  		/* cmplwi CR6, R15, 0 */
		/* 821735DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000000);
		/* 821735DCh case    0:*/		return 0x821735E0;
		  /* 821735E0h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 821735E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82173600;  }
		/* 821735E0h case    1:*/		return 0x821735E4;
		  /* 821735E4h */ case    2:  		/* rlwinm R11, R15, 0, 0, 30 */
		/* 821735E4h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R15);
		/* 821735E4h case    2:*/		return 0x821735E8;
	}
	return 0x821735E8;
} // Block from 821735DCh-821735E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821735E8h
// Function '?SimulateForwards@RegOptSimulator@D3DXShader@@AAAXPAVInstruction@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821735E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821735E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821735E8);
		  /* 821735E8h */ case    0:  		/* lwz R11, <#[R11 + 36]> */
		/* 821735E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821735E8h case    0:*/		return 0x821735EC;
		  /* 821735ECh */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821735ECh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821735ECh case    1:*/		return 0x821735F0;
		  /* 821735F0h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 821735F0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82173600;  }
		/* 821735F0h case    2:*/		return 0x821735F4;
		  /* 821735F4h */ case    3:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821735F4h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821735F4h case    3:*/		return 0x821735F8;
		  /* 821735F8h */ case    4:  		/* addi R11, R11, -40 */
		/* 821735F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 821735F8h case    4:*/		return 0x821735FC;
		  /* 821735FCh */ case    5:  		/* b 8 */
		/* 821735FCh case    5:*/		return 0x82173604;
		/* 821735FCh case    5:*/		return 0x82173600;
	}
	return 0x82173600;
} // Block from 821735E8h-82173600h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82173600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173600);
		  /* 82173600h */ case    0:  		/* li R11, 0 */
		/* 82173600h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82173600h case    0:*/		return 0x82173604;
	}
	return 0x82173604;
} // Block from 82173600h-82173604h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82173604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173604);
		  /* 82173604h */ case    0:  		/* mr R28, R11 */
		/* 82173604h case    0:*/		regs.R28 = regs.R11;
		/* 82173604h case    0:*/		return 0x82173608;
	}
	return 0x82173608;
} // Block from 82173604h-82173608h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82173608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173608);
		  /* 82173608h */ case    0:  		/* mr R30, R21 */
		/* 82173608h case    0:*/		regs.R30 = regs.R21;
		/* 82173608h case    0:*/		return 0x8217360C;
		  /* 8217360Ch */ case    1:  		/* li R29, 0 */
		/* 8217360Ch case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8217360Ch case    1:*/		return 0x82173610;
		  /* 82173610h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82173610h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82173610h case    2:*/		return 0x82173614;
		  /* 82173614h */ case    3:  		/* lwz R11, <#[R11 + 36]> */
		/* 82173614h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82173614h case    3:*/		return 0x82173618;
		  /* 82173618h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82173618h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82173618h case    4:*/		return 0x8217361C;
		  /* 8217361Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8217361Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8217362C;  }
		/* 8217361Ch case    5:*/		return 0x82173620;
		  /* 82173620h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82173620h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82173620h case    6:*/		return 0x82173624;
		  /* 82173624h */ case    7:  		/* addic. R30, R11, -40 */
		/* 82173624h case    7:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 82173624h case    7:*/		return 0x82173628;
		  /* 82173628h */ case    8:  		/* bc 4, CR0_EQ, 64 */
		/* 82173628h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82173668;  }
		/* 82173628h case    8:*/		return 0x8217362C;
	}
	return 0x8217362C;
} // Block from 82173608h-8217362Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8217362Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217362C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217362C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217362C);
		  /* 8217362Ch */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 8217362Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 8217362Ch case    0:*/		return 0x82173630;
		  /* 82173630h */ case    1:  		/* bc 4, CR0_EQ, 260 */
		/* 82173630h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82173734;  }
		/* 82173630h case    1:*/		return 0x82173634;
		  /* 82173634h */ case    2:  		/* mr R3, R24 */
		/* 82173634h case    2:*/		regs.R3 = regs.R24;
		/* 82173634h case    2:*/		return 0x82173638;
		  /* 82173638h */ case    3:  		/* bl -7632 */
		/* 82173638h case    3:*/		regs.LR = 0x8217363C; return 0x82171868;
		/* 82173638h case    3:*/		return 0x8217363C;
		  /* 8217363Ch */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8217363Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8217363Ch case    4:*/		return 0x82173640;
		  /* 82173640h */ case    5:  		/* bc 4, CR0_EQ, 244 */
		/* 82173640h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82173734;  }
		/* 82173640h case    5:*/		return 0x82173644;
		  /* 82173644h */ case    6:  		/* lwz R11, <#[R16 + 20]> */
		/* 82173644h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000014) );
		/* 82173644h case    6:*/		return 0x82173648;
		  /* 82173648h */ case    7:  		/* li R29, 1 */
		/* 82173648h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82173648h case    7:*/		return 0x8217364C;
		  /* 8217364Ch */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8217364Ch case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8217364Ch case    8:*/		return 0x82173650;
		  /* 82173650h */ case    9:  		/* bc 12, CR0_EQ, 12 */
		/* 82173650h case    9:*/		if ( regs.CR[0].eq ) { return 0x8217365C;  }
		/* 82173650h case    9:*/		return 0x82173654;
		  /* 82173654h */ case   10:  		/* li R30, 0 */
		/* 82173654h case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82173654h case   10:*/		return 0x82173658;
		  /* 82173658h */ case   11:  		/* b 16 */
		/* 82173658h case   11:*/		return 0x82173668;
		/* 82173658h case   11:*/		return 0x8217365C;
	}
	return 0x8217365C;
} // Block from 8217362Ch-8217365Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8217365Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217365C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217365C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217365C);
		  /* 8217365Ch */ case    0:  		/* lwz R11, <#[R16 + 16]> */
		/* 8217365Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000010) );
		/* 8217365Ch case    0:*/		return 0x82173660;
		  /* 82173660h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82173660h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82173660h case    1:*/		return 0x82173664;
		  /* 82173664h */ case    2:  		/* addi R30, R11, -40 */
		/* 82173664h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 82173664h case    2:*/		return 0x82173668;
	}
	return 0x82173668;
} // Block from 8217365Ch-82173668h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173668);
		  /* 82173668h */ case    0:  		/* cmplw CR6, R30, R28 */
		/* 82173668h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 82173668h case    0:*/		return 0x8217366C;
		  /* 8217366Ch */ case    1:  		/* bc 12, CR6_EQ, 200 */
		/* 8217366Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82173734;  }
		/* 8217366Ch case    1:*/		return 0x82173670;
		  /* 82173670h */ case    2:  		/* lwz R8, <#[R30 + 8]> */
		/* 82173670h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 82173670h case    2:*/		return 0x82173674;
		  /* 82173674h */ case    3:  		/* rlwinm. R11, R8, 9, 31, 31 */
		/* 82173674h case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R8);
		/* 82173674h case    3:*/		return 0x82173678;
		  /* 82173678h */ case    4:  		/* bc 12, CR0_EQ, 112 */
		/* 82173678h case    4:*/		if ( regs.CR[0].eq ) { return 0x821736E8;  }
		/* 82173678h case    4:*/		return 0x8217367C;
		  /* 8217367Ch */ case    5:  		/* lwz R11, <#[R30 + 4]> */
		/* 8217367Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8217367Ch case    5:*/		return 0x82173680;
		  /* 82173680h */ case    6:  		/* mr R10, R11 */
		/* 82173680h case    6:*/		regs.R10 = regs.R11;
		/* 82173680h case    6:*/		return 0x82173684;
		  /* 82173684h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82173684h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82173684h case    7:*/		return 0x82173688;
		  /* 82173688h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 82173688h case    8:*/		if ( regs.CR[6].eq ) { return 0x821736AC;  }
		/* 82173688h case    8:*/		return 0x8217368C;
		  /* 8217368Ch */ case    9:  		/* lwz R9, <#[R10]> */
		/* 8217368Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8217368Ch case    9:*/		return 0x82173690;
		  /* 82173690h */ case   10:  		/* rlwinm. R7, R9, 0, 4, 6 */
		/* 82173690h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R7,regs.R9);
		/* 82173690h case   10:*/		return 0x82173694;
		  /* 82173694h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 82173694h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821736A0;  }
		/* 82173694h case   11:*/		return 0x82173698;
		  /* 82173698h */ case   12:  		/* lwz R10, <#[R10 + 8]> */
		/* 82173698h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82173698h case   12:*/		return 0x8217369C;
		  /* 8217369Ch */ case   13:  		/* b -24 */
		/* 8217369Ch case   13:*/		return 0x82173684;
		/* 8217369Ch case   13:*/		return 0x821736A0;
	}
	return 0x821736A0;
} // Block from 82173668h-821736A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821736A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821736A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821736A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821736A0);
		  /* 821736A0h */ case    0:  		/* rlwinm. R10, R9, 2, 31, 31 */
		/* 821736A0h case    0:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R9);
		/* 821736A0h case    0:*/		return 0x821736A4;
		  /* 821736A4h */ case    1:  		/* li R10, 1 */
		/* 821736A4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821736A4h case    1:*/		return 0x821736A8;
		  /* 821736A8h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 821736A8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821736B0;  }
		/* 821736A8h case    2:*/		return 0x821736AC;
	}
	return 0x821736AC;
} // Block from 821736A0h-821736ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821736ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821736AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821736AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821736AC);
		  /* 821736ACh */ case    0:  		/* li R10, 0 */
		/* 821736ACh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821736ACh case    0:*/		return 0x821736B0;
	}
	return 0x821736B0;
} // Block from 821736ACh-821736B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821736B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821736B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821736B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821736B0);
		  /* 821736B0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821736B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821736B0h case    0:*/		return 0x821736B4;
		  /* 821736B4h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 821736B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821736E8;  }
		/* 821736B4h case    1:*/		return 0x821736B8;
		  /* 821736B8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821736B8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821736B8h case    2:*/		return 0x821736BC;
		  /* 821736BCh */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 821736BCh case    3:*/		if ( regs.CR[6].eq ) { return 0x821736D4;  }
		/* 821736BCh case    3:*/		return 0x821736C0;
		  /* 821736C0h */ case    4:  		/* lwz R10, <#[R11]> */
		/* 821736C0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821736C0h case    4:*/		return 0x821736C4;
		  /* 821736C4h */ case    5:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821736C4h case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821736C4h case    5:*/		return 0x821736C8;
		  /* 821736C8h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 821736C8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821736D4;  }
		/* 821736C8h case    6:*/		return 0x821736CC;
		  /* 821736CCh */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 821736CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821736CCh case    7:*/		return 0x821736D0;
		  /* 821736D0h */ case    8:  		/* b -24 */
		/* 821736D0h case    8:*/		return 0x821736B8;
		/* 821736D0h case    8:*/		return 0x821736D4;
	}
	return 0x821736D4;
} // Block from 821736B0h-821736D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821736D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821736D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821736D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821736D4);
		  /* 821736D4h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821736D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821736D4h case    0:*/		return 0x821736D8;
		  /* 821736D8h */ case    1:  		/* mr R3, R23 */
		/* 821736D8h case    1:*/		regs.R3 = regs.R23;
		/* 821736D8h case    1:*/		return 0x821736DC;
		  /* 821736DCh */ case    2:  		/* rlwimi R8, R11, 20, 19, 26 */
		/* 821736DCh case    2:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R8,regs.R11);
		/* 821736DCh case    2:*/		return 0x821736E0;
		  /* 821736E0h */ case    3:  		/* rlwinm R4, R8, 31, 20, 31 */
		/* 821736E0h case    3:*/		cpu::op::rlwinm<0,31,20,31>(regs,&regs.R4,regs.R8);
		/* 821736E0h case    3:*/		return 0x821736E4;
		  /* 821736E4h */ case    4:  		/* bl -2780 */
		/* 821736E4h case    4:*/		regs.LR = 0x821736E8; return 0x82172C08;
		/* 821736E4h case    4:*/		return 0x821736E8;
	}
	return 0x821736E8;
} // Block from 821736D4h-821736E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821736E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821736E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821736E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821736E8);
		  /* 821736E8h */ case    0:  		/* lwz R31, <#[R30]> */
		/* 821736E8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 821736E8h case    0:*/		return 0x821736EC;
		  /* 821736ECh */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821736ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821736ECh case    1:*/		return 0x821736F0;
		  /* 821736F0h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821736F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8217372C;  }
		/* 821736F0h case    2:*/		return 0x821736F4;
		  /* 821736F4h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 821736F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821736F4h case    3:*/		return 0x821736F8;
		  /* 821736F8h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821736F8h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821736F8h case    4:*/		return 0x821736FC;
		  /* 821736FCh */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 821736FCh case    5:*/		if ( regs.CR[0].eq ) { return 0x82173724;  }
		/* 821736FCh case    5:*/		return 0x82173700;
		  /* 82173700h */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 82173700h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82173700h case    6:*/		return 0x82173704;
		  /* 82173704h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 82173704h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82173704h case    7:*/		return 0x82173708;
		  /* 82173708h */ case    8:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82173708h case    8:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82173708h case    8:*/		return 0x8217370C;
		  /* 8217370Ch */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 8217370Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82173724;  }
		/* 8217370Ch case    9:*/		return 0x82173710;
		  /* 82173710h */ case   10:  		/* mr R3, R31 */
		/* 82173710h case   10:*/		regs.R3 = regs.R31;
		/* 82173710h case   10:*/		return 0x82173714;
		  /* 82173714h */ case   11:  		/* bl -18812 */
		/* 82173714h case   11:*/		regs.LR = 0x82173718; return 0x8216ED98;
		/* 82173714h case   11:*/		return 0x82173718;
		  /* 82173718h */ case   12:  		/* mr R4, R3 */
		/* 82173718h case   12:*/		regs.R4 = regs.R3;
		/* 82173718h case   12:*/		return 0x8217371C;
		  /* 8217371Ch */ case   13:  		/* mr R3, R23 */
		/* 8217371Ch case   13:*/		regs.R3 = regs.R23;
		/* 8217371Ch case   13:*/		return 0x82173720;
		  /* 82173720h */ case   14:  		/* bl -2840 */
		/* 82173720h case   14:*/		regs.LR = 0x82173724; return 0x82172C08;
		/* 82173720h case   14:*/		return 0x82173724;
	}
	return 0x82173724;
} // Block from 821736E8h-82173724h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82173724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173724);
		  /* 82173724h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 82173724h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 82173724h case    0:*/		return 0x82173728;
		  /* 82173728h */ case    1:  		/* b -60 */
		/* 82173728h case    1:*/		return 0x821736EC;
		/* 82173728h case    1:*/		return 0x8217372C;
	}
	return 0x8217372C;
} // Block from 82173724h-8217372Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217372Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217372C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217372C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217372C);
		  /* 8217372Ch */ case    0:  		/* cmplw CR6, R30, R15 */
		/* 8217372Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R15);
		/* 8217372Ch case    0:*/		return 0x82173730;
		  /* 82173730h */ case    1:  		/* bc 4, CR6_EQ, -288 */
		/* 82173730h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82173610;  }
		/* 82173730h case    1:*/		return 0x82173734;
	}
	return 0x82173734;
} // Block from 8217372Ch-82173734h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173734);
		  /* 82173734h */ case    0:  		/* lwz R11, <#[R21 + 8]> */
		/* 82173734h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82173734h case    0:*/		return 0x82173738;
		  /* 82173738h */ case    1:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82173738h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82173738h case    1:*/		return 0x8217373C;
		  /* 8217373Ch */ case    2:  		/* cmplwi CR6, R10, 14080 */
		/* 8217373Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 8217373Ch case    2:*/		return 0x82173740;
		  /* 82173740h */ case    3:  		/* bc 12, CR6_EQ, 532 */
		/* 82173740h case    3:*/		if ( regs.CR[6].eq ) { return 0x82173954;  }
		/* 82173740h case    3:*/		return 0x82173744;
		  /* 82173744h */ case    4:  		/* lwz R11, <#[R24 + 8]> */
		/* 82173744h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82173744h case    4:*/		return 0x82173748;
		  /* 82173748h */ case    5:  		/* li R30, 0 */
		/* 82173748h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82173748h case    5:*/		return 0x8217374C;
		  /* 8217374Ch */ case    6:  		/* lwz R31, <#[R24]> */
		/* 8217374Ch case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x00000000) );
		/* 8217374Ch case    6:*/		return 0x82173750;
		  /* 82173750h */ case    7:  		/* rlwinm R25, R11, 18, 29, 31 */
		/* 82173750h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R25,regs.R11);
		/* 82173750h case    7:*/		return 0x82173754;
		  /* 82173754h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 82173754h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82173754h case    8:*/		return 0x82173758;
		  /* 82173758h */ case    9:  		/* bc 12, CR6_EQ, 80 */
		/* 82173758h case    9:*/		if ( regs.CR[6].eq ) { return 0x821737A8;  }
		/* 82173758h case    9:*/		return 0x8217375C;
		  /* 8217375Ch */ case   10:  		/* lwz R11, <#[R31]> */
		/* 8217375Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8217375Ch case   10:*/		return 0x82173760;
		  /* 82173760h */ case   11:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82173760h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82173760h case   11:*/		return 0x82173764;
		  /* 82173764h */ case   12:  		/* bc 12, CR0_EQ, 60 */
		/* 82173764h case   12:*/		if ( regs.CR[0].eq ) { return 0x821737A0;  }
		/* 82173764h case   12:*/		return 0x82173768;
		  /* 82173768h */ case   13:  		/* lwz R11, <#[R31 + 12]> */
		/* 82173768h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82173768h case   13:*/		return 0x8217376C;
		  /* 8217376Ch */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 8217376Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8217376Ch case   14:*/		return 0x82173770;
		  /* 82173770h */ case   15:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82173770h case   15:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82173770h case   15:*/		return 0x82173774;
		  /* 82173774h */ case   16:  		/* bc 12, CR0_EQ, 44 */
		/* 82173774h case   16:*/		if ( regs.CR[0].eq ) { return 0x821737A0;  }
		/* 82173774h case   16:*/		return 0x82173778;
		  /* 82173778h */ case   17:  		/* mr R3, R31 */
		/* 82173778h case   17:*/		regs.R3 = regs.R31;
		/* 82173778h case   17:*/		return 0x8217377C;
		  /* 8217377Ch */ case   18:  		/* bl -18916 */
		/* 8217377Ch case   18:*/		regs.LR = 0x82173780; return 0x8216ED98;
		/* 8217377Ch case   18:*/		return 0x82173780;
		  /* 82173780h */ case   19:  		/* mr R29, R3 */
		/* 82173780h case   19:*/		regs.R29 = regs.R3;
		/* 82173780h case   19:*/		return 0x82173784;
		  /* 82173784h */ case   20:  		/* addi R3, R23, 4 */
		/* 82173784h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R23,0x4);
		/* 82173784h case   20:*/		return 0x82173788;
		  /* 82173788h */ case   21:  		/* rlwinm R4, R29, 30, 2, 29 */
		/* 82173788h case   21:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R4,regs.R29);
		/* 82173788h case   21:*/		return 0x8217378C;
		  /* 8217378Ch */ case   22:  		/* addi R5, R4, 3 */
		/* 8217378Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 8217378Ch case   22:*/		return 0x82173790;
		  /* 82173790h */ case   23:  		/* bl -8984 */
		/* 82173790h case   23:*/		regs.LR = 0x82173794; return 0x82171478;
		/* 82173790h case   23:*/		return 0x82173794;
		  /* 82173794h */ case   24:  		/* andc R11, R29, R3 */
		/* 82173794h case   24:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R29,regs.R3);
		/* 82173794h case   24:*/		return 0x82173798;
		  /* 82173798h */ case   25:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82173798h case   25:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82173798h case   25:*/		return 0x8217379C;
		  /* 8217379Ch */ case   26:  		/* or R30, R11, R30 */
		/* 8217379Ch case   26:*/		cpu::op::or<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 8217379Ch case   26:*/		return 0x821737A0;
	}
	return 0x821737A0;
} // Block from 82173734h-821737A0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821737A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821737A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821737A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821737A0);
		  /* 821737A0h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 821737A0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821737A0h case    0:*/		return 0x821737A4;
		  /* 821737A4h */ case    1:  		/* b -80 */
		/* 821737A4h case    1:*/		return 0x82173754;
		/* 821737A4h case    1:*/		return 0x821737A8;
	}
	return 0x821737A8;
} // Block from 821737A0h-821737A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821737A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821737A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821737A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821737A8);
		  /* 821737A8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821737A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821737A8h case    0:*/		return 0x821737AC;
		  /* 821737ACh */ case    1:  		/* bc 12, CR6_EQ, 380 */
		/* 821737ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x82173928;  }
		/* 821737ACh case    1:*/		return 0x821737B0;
		  /* 821737B0h */ case    2:  		/* lis R11, -28311 */
		/* 821737B0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 821737B0h case    2:*/		return 0x821737B4;
		  /* 821737B4h */ case    3:  		/* lis R10, 0 */
		/* 821737B4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 821737B4h case    3:*/		return 0x821737B8;
		  /* 821737B8h */ case    4:  		/* ori R11, R11, 5192 */
		/* 821737B8h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 821737B8h case    4:*/		return 0x821737BC;
		  /* 821737BCh */ case    5:  		/* ori R10, R10, 36262 */
		/* 821737BCh case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 821737BCh case    5:*/		return 0x821737C0;
		  /* 821737C0h */ case    6:  		/* rldicl R9, R30, 0, 32 */
		/* 821737C0h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R30);
		/* 821737C0h case    6:*/		return 0x821737C4;
		  /* 821737C4h */ case    7:  		/* rldimi R11, R10, 32, 0 */
		/* 821737C4h case    7:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 821737C4h case    7:*/		return 0x821737C8;
		  /* 821737C8h */ case    8:  		/* srd R11, R11, R9 */
		/* 821737C8h case    8:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821737C8h case    8:*/		return 0x821737CC;
		  /* 821737CCh */ case    9:  		/* srd R11, R11, R9 */
		/* 821737CCh case    9:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821737CCh case    9:*/		return 0x821737D0;
		  /* 821737D0h */ case   10:  		/* srd R11, R11, R9 */
		/* 821737D0h case   10:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821737D0h case   10:*/		return 0x821737D4;
		  /* 821737D4h */ case   11:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 821737D4h case   11:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821737D4h case   11:*/		return 0x821737D8;
		  /* 821737D8h */ case   12:  		/* cmplw CR6, R11, R25 */
		/* 821737D8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821737D8h case   12:*/		return 0x821737DC;
		  /* 821737DCh */ case   13:  		/* bc 12, CR6_LT, 332 */
		/* 821737DCh case   13:*/		if ( regs.CR[6].lt ) { return 0x82173928;  }
		/* 821737DCh case   13:*/		return 0x821737E0;
		  /* 821737E0h */ case   14:  		/* cmplwi CR6, R22, 0 */
		/* 821737E0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821737E0h case   14:*/		return 0x821737E4;
		  /* 821737E4h */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 821737E4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82173800;  }
		/* 821737E4h case   15:*/		return 0x821737E8;
		  /* 821737E8h */ case   16:  		/* li R5, 34 */
		/* 821737E8h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x22);
		/* 821737E8h case   16:*/		return 0x821737EC;
		  /* 821737ECh */ case   17:  		/* li R4, 8 */
		/* 821737ECh case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 821737ECh case   17:*/		return 0x821737F0;
		  /* 821737F0h */ case   18:  		/* mr R3, R17 */
		/* 821737F0h case   18:*/		regs.R3 = regs.R17;
		/* 821737F0h case   18:*/		return 0x821737F4;
		  /* 821737F4h */ case   19:  		/* bl -61188 */
		/* 821737F4h case   19:*/		regs.LR = 0x821737F8; return 0x821648F0;
		/* 821737F4h case   19:*/		return 0x821737F8;
		  /* 821737F8h */ case   20:  		/* mr R22, R3 */
		/* 821737F8h case   20:*/		regs.R22 = regs.R3;
		/* 821737F8h case   20:*/		return 0x821737FC;
		  /* 821737FCh */ case   21:  		/* b 12 */
		/* 821737FCh case   21:*/		return 0x82173808;
		/* 821737FCh case   21:*/		return 0x82173800;
	}
	return 0x82173800;
} // Block from 821737A8h-82173800h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82173800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173800);
		  /* 82173800h */ case    0:  		/* addi R3, R22, 4 */
		/* 82173800h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R22,0x4);
		/* 82173800h case    0:*/		return 0x82173804;
		  /* 82173804h */ case    1:  		/* bl -7860 */
		/* 82173804h case    1:*/		regs.LR = 0x82173808; return 0x82171950;
		/* 82173804h case    1:*/		return 0x82173808;
	}
	return 0x82173808;
} // Block from 82173800h-82173808h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173808);
		  /* 82173808h */ case    0:  		/* mr R4, R17 */
		/* 82173808h case    0:*/		regs.R4 = regs.R17;
		/* 82173808h case    0:*/		return 0x8217380C;
		  /* 8217380Ch */ case    1:  		/* mr R3, R22 */
		/* 8217380Ch case    1:*/		regs.R3 = regs.R22;
		/* 8217380Ch case    1:*/		return 0x82173810;
		  /* 82173810h */ case    2:  		/* bl -3328 */
		/* 82173810h case    2:*/		regs.LR = 0x82173814; return 0x82172B10;
		/* 82173810h case    2:*/		return 0x82173814;
		  /* 82173814h */ case    3:  		/* lwz R11, <#[R23 + 4]> */
		/* 82173814h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82173814h case    3:*/		return 0x82173818;
		  /* 82173818h */ case    4:  		/* addi R26, R23, 4 */
		/* 82173818h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R23,0x4);
		/* 82173818h case    4:*/		return 0x8217381C;
		  /* 8217381Ch */ case    5:  		/* nor R10, R11, R11 */
		/* 8217381Ch case    5:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8217381Ch case    5:*/		return 0x82173820;
		  /* 82173820h */ case    6:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82173820h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82173820h case    6:*/		return 0x82173824;
		  /* 82173824h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 82173824h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82173830;  }
		/* 82173824h case    7:*/		return 0x82173828;
		  /* 82173828h */ case    8:  		/* li R4, 31 */
		/* 82173828h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x1F);
		/* 82173828h case    8:*/		return 0x8217382C;
		  /* 8217382Ch */ case    9:  		/* b 16 */
		/* 8217382Ch case    9:*/		return 0x8217383C;
		/* 8217382Ch case    9:*/		return 0x82173830;
	}
	return 0x82173830;
} // Block from 82173808h-82173830h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82173830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173830);
		  /* 82173830h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82173830h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82173830h case    0:*/		return 0x82173834;
		  /* 82173834h */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 82173834h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 82173834h case    1:*/		return 0x82173838;
		  /* 82173838h */ case    2:  		/* addi R4, R11, -1 */
		/* 82173838h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 82173838h case    2:*/		return 0x8217383C;
	}
	return 0x8217383C;
} // Block from 82173830h-8217383Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8217383Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217383C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217383C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217383C);
		  /* 8217383Ch */ case    0:  		/* addi R28, R22, 4 */
		/* 8217383Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R22,0x4);
		/* 8217383Ch case    0:*/		return 0x82173840;
		  /* 82173840h */ case    1:  		/* mr R3, R28 */
		/* 82173840h case    1:*/		regs.R3 = regs.R28;
		/* 82173840h case    1:*/		return 0x82173844;
		  /* 82173844h */ case    2:  		/* bl -5508 */
		/* 82173844h case    2:*/		regs.LR = 0x82173848; return 0x821722C0;
		/* 82173844h case    2:*/		return 0x82173848;
		  /* 82173848h */ case    3:  		/* lwz R11, <#[R22 + 4]> */
		/* 82173848h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82173848h case    3:*/		return 0x8217384C;
		  /* 8217384Ch */ case    4:  		/* nor R10, R11, R11 */
		/* 8217384Ch case    4:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8217384Ch case    4:*/		return 0x82173850;
		  /* 82173850h */ case    5:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82173850h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82173850h case    5:*/		return 0x82173854;
		  /* 82173854h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 82173854h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82173864;  }
		/* 82173854h case    6:*/		return 0x82173858;
		  /* 82173858h */ case    7:  		/* li R11, -1 */
		/* 82173858h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82173858h case    7:*/		return 0x8217385C;
		  /* 8217385Ch */ case    8:  		/* stw R11, <#[R28]> */
		/* 8217385Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8217385Ch case    8:*/		return 0x82173860;
		  /* 82173860h */ case    9:  		/* b 24 */
		/* 82173860h case    9:*/		return 0x82173878;
		/* 82173860h case    9:*/		return 0x82173864;
	}
	return 0x82173864;
} // Block from 8217383Ch-82173864h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82173864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173864);
		  /* 82173864h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82173864h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82173864h case    0:*/		return 0x82173868;
		  /* 82173868h */ case    1:  		/* li R4, 255 */
		/* 82173868h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82173868h case    1:*/		return 0x8217386C;
		  /* 8217386Ch */ case    2:  		/* addi R3, R11, 4 */
		/* 8217386Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x4);
		/* 8217386Ch case    2:*/		return 0x82173870;
		  /* 82173870h */ case    3:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 82173870h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 82173870h case    3:*/		return 0x82173874;
		  /* 82173874h */ case    4:  		/* bl -927028 */
		/* 82173874h case    4:*/		regs.LR = 0x82173878; return 0x82091340;
		/* 82173874h case    4:*/		return 0x82173878;
	}
	return 0x82173878;
} // Block from 82173864h-82173878h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82173878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173878);
		  /* 82173878h */ case    0:  		/* lwz R27, <#[R24]> */
		/* 82173878h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R24 + 0x00000000) );
		/* 82173878h case    0:*/		return 0x8217387C;
		  /* 8217387Ch */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 8217387Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8217387Ch case    1:*/		return 0x82173880;
		  /* 82173880h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 82173880h case    2:*/		if ( regs.CR[6].eq ) { return 0x82173908;  }
		/* 82173880h case    2:*/		return 0x82173884;
		  /* 82173884h */ case    3:  		/* lwz R11, <#[R27]> */
		/* 82173884h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82173884h case    3:*/		return 0x82173888;
		  /* 82173888h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82173888h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82173888h case    4:*/		return 0x8217388C;
		  /* 8217388Ch */ case    5:  		/* bc 12, CR0_EQ, 116 */
		/* 8217388Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82173900;  }
		/* 8217388Ch case    5:*/		return 0x82173890;
		  /* 82173890h */ case    6:  		/* lwz R11, <#[R27 + 12]> */
		/* 82173890h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82173890h case    6:*/		return 0x82173894;
		  /* 82173894h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 82173894h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82173894h case    7:*/		return 0x82173898;
		  /* 82173898h */ case    8:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82173898h case    8:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82173898h case    8:*/		return 0x8217389C;
		  /* 8217389Ch */ case    9:  		/* bc 12, CR0_EQ, 100 */
		/* 8217389Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82173900;  }
		/* 8217389Ch case    9:*/		return 0x821738A0;
		  /* 821738A0h */ case   10:  		/* mr R3, R27 */
		/* 821738A0h case   10:*/		regs.R3 = regs.R27;
		/* 821738A0h case   10:*/		return 0x821738A4;
		  /* 821738A4h */ case   11:  		/* bl -19212 */
		/* 821738A4h case   11:*/		regs.LR = 0x821738A8; return 0x8216ED98;
		/* 821738A4h case   11:*/		return 0x821738A8;
		  /* 821738A8h */ case   12:  		/* mr R30, R3 */
		/* 821738A8h case   12:*/		regs.R30 = regs.R3;
		/* 821738A8h case   12:*/		return 0x821738AC;
		  /* 821738ACh */ case   13:  		/* mr R3, R26 */
		/* 821738ACh case   13:*/		regs.R3 = regs.R26;
		/* 821738ACh case   13:*/		return 0x821738B0;
		  /* 821738B0h */ case   14:  		/* rlwinm R31, R30, 30, 2, 29 */
		/* 821738B0h case   14:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R31,regs.R30);
		/* 821738B0h case   14:*/		return 0x821738B4;
		  /* 821738B4h */ case   15:  		/* addi R29, R31, 3 */
		/* 821738B4h case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x3);
		/* 821738B4h case   15:*/		return 0x821738B8;
		  /* 821738B8h */ case   16:  		/* mr R4, R31 */
		/* 821738B8h case   16:*/		regs.R4 = regs.R31;
		/* 821738B8h case   16:*/		return 0x821738BC;
		  /* 821738BCh */ case   17:  		/* mr R5, R29 */
		/* 821738BCh case   17:*/		regs.R5 = regs.R29;
		/* 821738BCh case   17:*/		return 0x821738C0;
		  /* 821738C0h */ case   18:  		/* bl -9288 */
		/* 821738C0h case   18:*/		regs.LR = 0x821738C4; return 0x82171478;
		/* 821738C0h case   18:*/		return 0x821738C4;
		  /* 821738C4h */ case   19:  		/* mr R14, R3 */
		/* 821738C4h case   19:*/		regs.R14 = regs.R3;
		/* 821738C4h case   19:*/		return 0x821738C8;
		  /* 821738C8h */ case   20:  		/* mr R5, R29 */
		/* 821738C8h case   20:*/		regs.R5 = regs.R29;
		/* 821738C8h case   20:*/		return 0x821738CC;
		  /* 821738CCh */ case   21:  		/* mr R4, R31 */
		/* 821738CCh case   21:*/		regs.R4 = regs.R31;
		/* 821738CCh case   21:*/		return 0x821738D0;
		  /* 821738D0h */ case   22:  		/* mr R3, R28 */
		/* 821738D0h case   22:*/		regs.R3 = regs.R28;
		/* 821738D0h case   22:*/		return 0x821738D4;
		  /* 821738D4h */ case   23:  		/* bl -9308 */
		/* 821738D4h case   23:*/		regs.LR = 0x821738D8; return 0x82171478;
		/* 821738D4h case   23:*/		return 0x821738D8;
		  /* 821738D8h */ case   24:  		/* andc R11, R3, R14 */
		/* 821738D8h case   24:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R3,regs.R14);
		/* 821738D8h case   24:*/		return 0x821738DC;
		  /* 821738DCh */ case   25:  		/* and R11, R11, R30 */
		/* 821738DCh case   25:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 821738DCh case   25:*/		return 0x821738E0;
		  /* 821738E0h */ case   26:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 821738E0h case   26:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 821738E0h case   26:*/		return 0x821738E4;
		  /* 821738E4h */ case   27:  		/* bc 12, CR0_EQ, 28 */
		/* 821738E4h case   27:*/		if ( regs.CR[0].eq ) { return 0x82173900;  }
		/* 821738E4h case   27:*/		return 0x821738E8;
		  /* 821738E8h */ case   28:  		/* rlwimi R11, R30, 0, 0, 27 */
		/* 821738E8h case   28:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R30);
		/* 821738E8h case   28:*/		return 0x821738EC;
		  /* 821738ECh */ case   29:  		/* mr R3, R28 */
		/* 821738ECh case   29:*/		regs.R3 = regs.R28;
		/* 821738ECh case   29:*/		return 0x821738F0;
		  /* 821738F0h */ case   30:  		/* rlwinm R4, R11, 30, 2, 29 */
		/* 821738F0h case   30:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R4,regs.R11);
		/* 821738F0h case   30:*/		return 0x821738F4;
		  /* 821738F4h */ case   31:  		/* rlwinm R6, R11, 0, 28, 31 */
		/* 821738F4h case   31:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R11);
		/* 821738F4h case   31:*/		return 0x821738F8;
		  /* 821738F8h */ case   32:  		/* addi R5, R4, 3 */
		/* 821738F8h case   32:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 821738F8h case   32:*/		return 0x821738FC;
		  /* 821738FCh */ case   33:  		/* bl -9092 */
		/* 821738FCh case   33:*/		regs.LR = 0x82173900; return 0x82171578;
		/* 821738FCh case   33:*/		return 0x82173900;
	}
	return 0x82173900;
} // Block from 82173878h-82173900h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82173900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173900);
		  /* 82173900h */ case    0:  		/* lwz R27, <#[R27 + 4]> */
		/* 82173900h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000004) );
		/* 82173900h case    0:*/		return 0x82173904;
		  /* 82173904h */ case    1:  		/* b -136 */
		/* 82173904h case    1:*/		return 0x8217387C;
		/* 82173904h case    1:*/		return 0x82173908;
	}
	return 0x82173908;
} // Block from 82173900h-82173908h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173908);
		  /* 82173908h */ case    0:  		/* li R5, 0 */
		/* 82173908h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82173908h case    0:*/		return 0x8217390C;
		  /* 8217390Ch */ case    1:  		/* mr R4, R25 */
		/* 8217390Ch case    1:*/		regs.R4 = regs.R25;
		/* 8217390Ch case    1:*/		return 0x82173910;
		  /* 82173910h */ case    2:  		/* mr R3, R22 */
		/* 82173910h case    2:*/		regs.R3 = regs.R22;
		/* 82173910h case    2:*/		return 0x82173914;
		  /* 82173914h */ case    3:  		/* bl -5428 */
		/* 82173914h case    3:*/		regs.LR = 0x82173918; return 0x821723E0;
		/* 82173914h case    3:*/		return 0x82173918;
		  /* 82173918h */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 82173918h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82173918h case    4:*/		return 0x8217391C;
		  /* 8217391Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8217391Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82173928;  }
		/* 8217391Ch case    5:*/		return 0x82173920;
		  /* 82173920h */ case    6:  		/* mr R31, R3 */
		/* 82173920h case    6:*/		regs.R31 = regs.R3;
		/* 82173920h case    6:*/		return 0x82173924;
		  /* 82173924h */ case    7:  		/* b 224 */
		/* 82173924h case    7:*/		return 0x82173A04;
		/* 82173924h case    7:*/		return 0x82173928;
	}
	return 0x82173928;
} // Block from 82173908h-82173928h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82173928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173928);
		  /* 82173928h */ case    0:  		/* li R5, 1 */
		/* 82173928h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82173928h case    0:*/		return 0x8217392C;
		  /* 8217392Ch */ case    1:  		/* mr R4, R25 */
		/* 8217392Ch case    1:*/		regs.R4 = regs.R25;
		/* 8217392Ch case    1:*/		return 0x82173930;
		  /* 82173930h */ case    2:  		/* mr R3, R23 */
		/* 82173930h case    2:*/		regs.R3 = regs.R23;
		/* 82173930h case    2:*/		return 0x82173934;
		  /* 82173934h */ case    3:  		/* bl -5460 */
		/* 82173934h case    3:*/		regs.LR = 0x82173938; return 0x821723E0;
		/* 82173934h case    3:*/		return 0x82173938;
		  /* 82173938h */ case    4:  		/* mr R31, R3 */
		/* 82173938h case    4:*/		regs.R31 = regs.R3;
		/* 82173938h case    4:*/		return 0x8217393C;
		  /* 8217393Ch */ case    5:  		/* addi R3, R20, 4 */
		/* 8217393Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R20,0x4);
		/* 8217393Ch case    5:*/		return 0x82173940;
		  /* 82173940h */ case    6:  		/* rlwinm R11, R31, 28, 4, 31 */
		/* 82173940h case    6:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R31);
		/* 82173940h case    6:*/		return 0x82173944;
		  /* 82173944h */ case    7:  		/* addi R11, R11, 1 */
		/* 82173944h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82173944h case    7:*/		return 0x82173948;
		  /* 82173948h */ case    8:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82173948h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82173948h case    8:*/		return 0x8217394C;
		  /* 8217394Ch */ case    9:  		/* bl -5772 */
		/* 8217394Ch case    9:*/		regs.LR = 0x82173950; return 0x821722C0;
		/* 8217394Ch case    9:*/		return 0x82173950;
		  /* 82173950h */ case   10:  		/* b 180 */
		/* 82173950h case   10:*/		return 0x82173A04;
		/* 82173950h case   10:*/		return 0x82173954;
	}
	return 0x82173954;
} // Block from 82173928h-82173954h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82173954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173954);
		  /* 82173954h */ case    0:  		/* lwz R10, <#[R24 + 8]> */
		/* 82173954h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 82173954h case    0:*/		return 0x82173958;
		  /* 82173958h */ case    1:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82173958h case    1:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82173958h case    1:*/		return 0x8217395C;
		  /* 8217395Ch */ case    2:  		/* rlwinm R30, R19, 0, 28, 31 */
		/* 8217395Ch case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R30,regs.R19);
		/* 8217395Ch case    2:*/		return 0x82173960;
		  /* 82173960h */ case    3:  		/* rlwinm R31, R10, 31, 28, 31 */
		/* 82173960h case    3:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R31,regs.R10);
		/* 82173960h case    3:*/		return 0x82173964;
		  /* 82173964h */ case    4:  		/* li R29, 0 */
		/* 82173964h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82173964h case    4:*/		return 0x82173968;
		  /* 82173968h */ case    5:  		/* li R8, 0 */
		/* 82173968h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82173968h case    5:*/		return 0x8217396C;
		  /* 8217396Ch */ case    6:  		/* bc 12, CR0_EQ, 84 */
		/* 8217396Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x821739C0;  }
		/* 8217396Ch case    6:*/		return 0x82173970;
		  /* 82173970h */ case    7:  		/* lwz R11, <#[R21 + 8]> */
		/* 82173970h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82173970h case    7:*/		return 0x82173974;
		  /* 82173974h */ case    8:  		/* addi R9, R21, 44 */
		/* 82173974h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R21,0x2C);
		/* 82173974h case    8:*/		return 0x82173978;
		  /* 82173978h */ case    9:  		/* rlwinm R7, R11, 13, 29, 31 */
		/* 82173978h case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R7,regs.R11);
		/* 82173978h case    9:*/		return 0x8217397C;
		  /* 8217397Ch */ case   10:  		/* lwz R11, <#[R9]> */
		/* 8217397Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8217397Ch case   10:*/		return 0x82173980;
		  /* 82173980h */ case   11:  		/* addi R10, R30, -1 */
		/* 82173980h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFFF);
		/* 82173980h case   11:*/		return 0x82173984;
		  /* 82173984h */ case   12:  		/* andc R10, R30, R10 */
		/* 82173984h case   12:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 82173984h case   12:*/		return 0x82173988;
		  /* 82173988h */ case   13:  		/* subf R30, R10, R30 */
		/* 82173988h case   13:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R10,regs.R30);
		/* 82173988h case   13:*/		return 0x8217398C;
		  /* 8217398Ch */ case   14:  		/* lwz R6, <#[R11 + 12]> */
		/* 8217398Ch case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 8217398Ch case   14:*/		return 0x82173990;
		  /* 82173990h */ case   15:  		/* cmplw CR6, R6, R24 */
		/* 82173990h case   15:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R24);
		/* 82173990h case   15:*/		return 0x82173994;
		  /* 82173994h */ case   16:  		/* bc 4, CR6_EQ, 28 */
		/* 82173994h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821739B0;  }
		/* 82173994h case   16:*/		return 0x82173998;
		  /* 82173998h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 82173998h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82173998h case   17:*/		return 0x8217399C;
		  /* 8217399Ch */ case   18:  		/* li R6, 1 */
		/* 8217399Ch case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8217399Ch case   18:*/		return 0x821739A0;
		  /* 821739A0h */ case   19:  		/* or R29, R10, R29 */
		/* 821739A0h case   19:*/		cpu::op::or<0>(regs,&regs.R29,regs.R10,regs.R29);
		/* 821739A0h case   19:*/		return 0x821739A4;
		  /* 821739A4h */ case   20:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 821739A4h case   20:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 821739A4h case   20:*/		return 0x821739A8;
		  /* 821739A8h */ case   21:  		/* slw R11, R6, R11 */
		/* 821739A8h case   21:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 821739A8h case   21:*/		return 0x821739AC;
		  /* 821739ACh */ case   22:  		/* andc R31, R31, R11 */
		/* 821739ACh case   22:*/		cpu::op::andc<0>(regs,&regs.R31,regs.R31,regs.R11);
		/* 821739ACh case   22:*/		return 0x821739B0;
	}
	return 0x821739B0;
} // Block from 82173954h-821739B0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821739B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821739B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821739B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821739B0);
		  /* 821739B0h */ case    0:  		/* addi R8, R8, 1 */
		/* 821739B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821739B0h case    0:*/		return 0x821739B4;
		  /* 821739B4h */ case    1:  		/* addi R9, R9, 4 */
		/* 821739B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821739B4h case    1:*/		return 0x821739B8;
		  /* 821739B8h */ case    2:  		/* cmplw CR6, R8, R7 */
		/* 821739B8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 821739B8h case    2:*/		return 0x821739BC;
		  /* 821739BCh */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 821739BCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8217397C;  }
		/* 821739BCh case    3:*/		return 0x821739C0;
	}
	return 0x821739C0;
} // Block from 821739B0h-821739C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821739C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821739C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821739C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821739C0);
		  /* 821739C0h */ case    0:  		/* rlwinm R4, R19, 30, 2, 29 */
		/* 821739C0h case    0:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R4,regs.R19);
		/* 821739C0h case    0:*/		return 0x821739C4;
		  /* 821739C4h */ case    1:  		/* addi R3, R20, 4 */
		/* 821739C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R20,0x4);
		/* 821739C4h case    1:*/		return 0x821739C8;
		  /* 821739C8h */ case    2:  		/* addi R5, R4, 3 */
		/* 821739C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x3);
		/* 821739C8h case    2:*/		return 0x821739CC;
		  /* 821739CCh */ case    3:  		/* bl -9556 */
		/* 821739CCh case    3:*/		regs.LR = 0x821739D0; return 0x82171478;
		/* 821739CCh case    3:*/		return 0x821739D0;
		  /* 821739D0h */ case    4:  		/* andc R11, R30, R3 */
		/* 821739D0h case    4:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R30,regs.R3);
		/* 821739D0h case    4:*/		return 0x821739D4;
		  /* 821739D4h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 821739D4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821739D4h case    5:*/		return 0x821739D8;
		  /* 821739D8h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 821739D8h case    6:*/		if ( regs.CR[6].eq ) { return 0x821739FC;  }
		/* 821739D8h case    6:*/		return 0x821739DC;
		  /* 821739DCh */ case    7:  		/* addi R10, R31, -1 */
		/* 821739DCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFFF);
		/* 821739DCh case    7:*/		return 0x821739E0;
		  /* 821739E0h */ case    8:  		/* addi R9, R11, -1 */
		/* 821739E0h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 821739E0h case    8:*/		return 0x821739E4;
		  /* 821739E4h */ case    9:  		/* andc R10, R31, R10 */
		/* 821739E4h case    9:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 821739E4h case    9:*/		return 0x821739E8;
		  /* 821739E8h */ case   10:  		/* andc R9, R11, R9 */
		/* 821739E8h case   10:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 821739E8h case   10:*/		return 0x821739EC;
		  /* 821739ECh */ case   11:  		/* subf. R31, R10, R31 */
		/* 821739ECh case   11:*/		cpu::op::subf<1>(regs,&regs.R31,regs.R10,regs.R31);
		/* 821739ECh case   11:*/		return 0x821739F0;
		  /* 821739F0h */ case   12:  		/* subf R11, R9, R11 */
		/* 821739F0h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821739F0h case   12:*/		return 0x821739F4;
		  /* 821739F4h */ case   13:  		/* or R29, R9, R29 */
		/* 821739F4h case   13:*/		cpu::op::or<0>(regs,&regs.R29,regs.R9,regs.R29);
		/* 821739F4h case   13:*/		return 0x821739F8;
		  /* 821739F8h */ case   14:  		/* bc 4, CR0_EQ, -28 */
		/* 821739F8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821739DC;  }
		/* 821739F8h case   14:*/		return 0x821739FC;
	}
	return 0x821739FC;
} // Block from 821739C0h-821739FCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 821739FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821739FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821739FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821739FC);
		  /* 821739FCh */ case    0:  		/* rlwimi R29, R19, 0, 0, 27 */
		/* 821739FCh case    0:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R29,regs.R19);
		/* 821739FCh case    0:*/		return 0x82173A00;
		  /* 82173A00h */ case    1:  		/* mr R31, R29 */
		/* 82173A00h case    1:*/		regs.R31 = regs.R29;
		/* 82173A00h case    1:*/		return 0x82173A04;
	}
	return 0x82173A04;
} // Block from 821739FCh-82173A04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173A04);
		  /* 82173A04h */ case    0:  		/* mr R4, R31 */
		/* 82173A04h case    0:*/		regs.R4 = regs.R31;
		/* 82173A04h case    0:*/		return 0x82173A08;
		  /* 82173A08h */ case    1:  		/* mr R3, R20 */
		/* 82173A08h case    1:*/		regs.R3 = regs.R20;
		/* 82173A08h case    1:*/		return 0x82173A0C;
		  /* 82173A0Ch */ case    2:  		/* bl -5788 */
		/* 82173A0Ch case    2:*/		regs.LR = 0x82173A10; return 0x82172370;
		/* 82173A0Ch case    2:*/		return 0x82173A10;
		  /* 82173A10h */ case    3:  		/* mr R5, R24 */
		/* 82173A10h case    3:*/		regs.R5 = regs.R24;
		/* 82173A10h case    3:*/		return 0x82173A14;
		  /* 82173A14h */ case    4:  		/* mr R4, R31 */
		/* 82173A14h case    4:*/		regs.R4 = regs.R31;
		/* 82173A14h case    4:*/		return 0x82173A18;
		  /* 82173A18h */ case    5:  		/* mr R3, R20 */
		/* 82173A18h case    5:*/		regs.R3 = regs.R20;
		/* 82173A18h case    5:*/		return 0x82173A1C;
		  /* 82173A1Ch */ case    6:  		/* bl -7956 */
		/* 82173A1Ch case    6:*/		regs.LR = 0x82173A20; return 0x82171B08;
		/* 82173A1Ch case    6:*/		return 0x82173A20;
		  /* 82173A20h */ case    7:  		/* lwz R11, <#[R24 + 20]> */
		/* 82173A20h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82173A20h case    7:*/		return 0x82173A24;
		  /* 82173A24h */ case    8:  		/* rlwimi R11, R31, 13, 7, 18 */
		/* 82173A24h case    8:*/		cpu::op::rlwimi<0,13,7,18>(regs,&regs.R11,regs.R31);
		/* 82173A24h case    8:*/		return 0x82173A28;
		  /* 82173A28h */ case    9:  		/* stw R11, <#[R24 + 20]> */
		/* 82173A28h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82173A28h case    9:*/		return 0x82173A2C;
	}
	return 0x82173A2C;
} // Block from 82173A04h-82173A2Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82173A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173A2C);
		  /* 82173A2Ch */ case    0:  		/* lwz R18, <#[R18 + 4]> */
		/* 82173A2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R18 + 0x00000004) );
		/* 82173A2Ch case    0:*/		return 0x82173A30;
		  /* 82173A30h */ case    1:  		/* b -1428 */
		/* 82173A30h case    1:*/		return 0x8217349C;
		/* 82173A30h case    1:*/		return 0x82173A34;
	}
	return 0x82173A34;
} // Block from 82173A2Ch-82173A34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173A34);
		  /* 82173A34h */ case    0:  		/* li R4, 4800 */
		/* 82173A34h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82173A34h case    0:*/		return 0x82173A38;
		  /* 82173A38h */ case    1:  		/* mr R3, R17 */
		/* 82173A38h case    1:*/		regs.R3 = regs.R17;
		/* 82173A38h case    1:*/		return 0x82173A3C;
		  /* 82173A3Ch */ case    2:  		/* bl -138196 */
		/* 82173A3Ch case    2:*/		regs.LR = 0x82173A40; return 0x82151E68;
		/* 82173A3Ch case    2:*/		return 0x82173A40;
	}
	return 0x82173A40;
} // Block from 82173A34h-82173A40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173A40);
		  /* 82173A40h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 82173A40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82173A40h case    0:*/		return 0x82173A44;
		  /* 82173A44h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82173A44h case    1:*/		if ( regs.CR[6].eq ) { return 0x82173A60;  }
		/* 82173A44h case    1:*/		return 0x82173A48;
		  /* 82173A48h */ case    2:  		/* addi R3, R23, 4 */
		/* 82173A48h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R23,0x4);
		/* 82173A48h case    2:*/		return 0x82173A4C;
		  /* 82173A4Ch */ case    3:  		/* bl -8444 */
		/* 82173A4Ch case    3:*/		regs.LR = 0x82173A50; return 0x82171950;
		/* 82173A4Ch case    3:*/		return 0x82173A50;
		  /* 82173A50h */ case    4:  		/* lwz R10, <#[R17 + 976]> */
		/* 82173A50h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x000003D0) );
		/* 82173A50h case    4:*/		return 0x82173A54;
		  /* 82173A54h */ case    5:  		/* addi R11, R17, 972 */
		/* 82173A54h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x3CC);
		/* 82173A54h case    5:*/		return 0x82173A58;
		  /* 82173A58h */ case    6:  		/* stw R10, <#[R23]> */
		/* 82173A58h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 82173A58h case    6:*/		return 0x82173A5C;
		  /* 82173A5Ch */ case    7:  		/* stw R23, <#[R17 + 976]> */
		/* 82173A5Ch case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R17 + 0x000003D0) );
		/* 82173A5Ch case    7:*/		return 0x82173A60;
	}
	return 0x82173A60;
} // Block from 82173A40h-82173A60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82173A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173A60);
		  /* 82173A60h */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 82173A60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82173A60h case    0:*/		return 0x82173A64;
		  /* 82173A64h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82173A64h case    1:*/		if ( regs.CR[6].eq ) { return 0x82173A80;  }
		/* 82173A64h case    1:*/		return 0x82173A68;
		  /* 82173A68h */ case    2:  		/* addi R3, R22, 4 */
		/* 82173A68h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R22,0x4);
		/* 82173A68h case    2:*/		return 0x82173A6C;
		  /* 82173A6Ch */ case    3:  		/* bl -8476 */
		/* 82173A6Ch case    3:*/		regs.LR = 0x82173A70; return 0x82171950;
		/* 82173A6Ch case    3:*/		return 0x82173A70;
		  /* 82173A70h */ case    4:  		/* lwz R10, <#[R17 + 976]> */
		/* 82173A70h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x000003D0) );
		/* 82173A70h case    4:*/		return 0x82173A74;
		  /* 82173A74h */ case    5:  		/* addi R11, R17, 972 */
		/* 82173A74h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x3CC);
		/* 82173A74h case    5:*/		return 0x82173A78;
		  /* 82173A78h */ case    6:  		/* stw R10, <#[R22]> */
		/* 82173A78h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R22 + 0x00000000) );
		/* 82173A78h case    6:*/		return 0x82173A7C;
		  /* 82173A7Ch */ case    7:  		/* stw R22, <#[R17 + 976]> */
		/* 82173A7Ch case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R17 + 0x000003D0) );
		/* 82173A7Ch case    7:*/		return 0x82173A80;
	}
	return 0x82173A80;
} // Block from 82173A60h-82173A80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82173A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173A80);
		  /* 82173A80h */ case    0:  		/* addi R1, R1, 240 */
		/* 82173A80h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 82173A80h case    0:*/		return 0x82173A84;
		  /* 82173A84h */ case    1:  		/* b -927764 */
		/* 82173A84h case    1:*/		return 0x82091270;
		/* 82173A84h case    1:*/		return 0x82173A88;
	}
	return 0x82173A88;
} // Block from 82173A80h-82173A88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173A88);
		  /* 82173A88h */ case    0:  		/* mfspr R12, LR */
		/* 82173A88h case    0:*/		regs.R12 = regs.LR;
		/* 82173A88h case    0:*/		return 0x82173A8C;
		  /* 82173A8Ch */ case    1:  		/* bl -927796 */
		/* 82173A8Ch case    1:*/		regs.LR = 0x82173A90; return 0x82091258;
		/* 82173A8Ch case    1:*/		return 0x82173A90;
		  /* 82173A90h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82173A90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82173A90h case    2:*/		return 0x82173A94;
		  /* 82173A94h */ case    3:  		/* mr R28, R5 */
		/* 82173A94h case    3:*/		regs.R28 = regs.R5;
		/* 82173A94h case    3:*/		return 0x82173A98;
		  /* 82173A98h */ case    4:  		/* li R5, 1 */
		/* 82173A98h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82173A98h case    4:*/		return 0x82173A9C;
		  /* 82173A9Ch */ case    5:  		/* mr R31, R3 */
		/* 82173A9Ch case    5:*/		regs.R31 = regs.R3;
		/* 82173A9Ch case    5:*/		return 0x82173AA0;
		  /* 82173AA0h */ case    6:  		/* lwz R3, <#[R3 + 48]> */
		/* 82173AA0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 82173AA0h case    6:*/		return 0x82173AA4;
		  /* 82173AA4h */ case    7:  		/* mr R29, R4 */
		/* 82173AA4h case    7:*/		regs.R29 = regs.R4;
		/* 82173AA4h case    7:*/		return 0x82173AA8;
		  /* 82173AA8h */ case    8:  		/* bl -7896 */
		/* 82173AA8h case    8:*/		regs.LR = 0x82173AAC; return 0x82171BD0;
		/* 82173AA8h case    8:*/		return 0x82173AAC;
		  /* 82173AACh */ case    9:  		/* lwz R3, <#[R31 + 56]> */
		/* 82173AACh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 82173AACh case    9:*/		return 0x82173AB0;
		  /* 82173AB0h */ case   10:  		/* bl -8232 */
		/* 82173AB0h case   10:*/		regs.LR = 0x82173AB4; return 0x82171A88;
		/* 82173AB0h case   10:*/		return 0x82173AB4;
		  /* 82173AB4h */ case   11:  		/* mr R4, R29 */
		/* 82173AB4h case   11:*/		regs.R4 = regs.R29;
		/* 82173AB4h case   11:*/		return 0x82173AB8;
		  /* 82173AB8h */ case   12:  		/* lwz R5, <#[R31 + 56]> */
		/* 82173AB8h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000038) );
		/* 82173AB8h case   12:*/		return 0x82173ABC;
		  /* 82173ABCh */ case   13:  		/* lwz R3, <#[R31 + 48]> */
		/* 82173ABCh case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82173ABCh case   13:*/		return 0x82173AC0;
		  /* 82173AC0h */ case   14:  		/* bl -2184 */
		/* 82173AC0h case   14:*/		regs.LR = 0x82173AC4; return 0x82173238;
		/* 82173AC0h case   14:*/		return 0x82173AC4;
		  /* 82173AC4h */ case   15:  		/* lwz R11, <#[R31]> */
		/* 82173AC4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82173AC4h case   15:*/		return 0x82173AC8;
		  /* 82173AC8h */ case   16:  		/* lwz R10, <#[R11 + 4]> */
		/* 82173AC8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82173AC8h case   16:*/		return 0x82173ACC;
		  /* 82173ACCh */ case   17:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82173ACCh case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82173ACCh case   17:*/		return 0x82173AD0;
	}
	return 0x82173AD0;
} // Block from 82173A88h-82173AD0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82173AD0h
// Function '?ReserveBlockOutputRegisters@Compiler@D3DXShader@@QAAXPAVBlock@2@PAVInfiniteLocalRegisterSet@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173AD0);
		  /* 82173AD0h */ case    0:  		/* bc 4, CR0_EQ, 108 */
		/* 82173AD0h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82173B3C;  }
		/* 82173AD0h case    0:*/		return 0x82173AD4;
		  /* 82173AD4h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 82173AD4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82173AD4h case    1:*/		return 0x82173AD8;
		  /* 82173AD8h */ case    2:  		/* b 84 */
		/* 82173AD8h case    2:*/		return 0x82173B2C;
		/* 82173AD8h case    2:*/		return 0x82173ADC;
		  /* 82173ADCh */ case    3:  		/* cmplw CR6, R30, R28 */
		/* 82173ADCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 82173ADCh case    3:*/		return 0x82173AE0;
		  /* 82173AE0h */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 82173AE0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82173B40;  }
		/* 82173AE0h case    4:*/		return 0x82173AE4;
		  /* 82173AE4h */ case    5:  		/* mr R7, R28 */
		/* 82173AE4h case    5:*/		regs.R7 = regs.R28;
		/* 82173AE4h case    5:*/		return 0x82173AE8;
		  /* 82173AE8h */ case    6:  		/* lwz R6, <#[R31 + 56]> */
		/* 82173AE8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000038) );
		/* 82173AE8h case    6:*/		return 0x82173AEC;
		  /* 82173AECh */ case    7:  		/* mr R5, R29 */
		/* 82173AECh case    7:*/		regs.R5 = regs.R29;
		/* 82173AECh case    7:*/		return 0x82173AF0;
		  /* 82173AF0h */ case    8:  		/* lwz R3, <#[R31 + 48]> */
		/* 82173AF0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82173AF0h case    8:*/		return 0x82173AF4;
		  /* 82173AF4h */ case    9:  		/* mr R4, R30 */
		/* 82173AF4h case    9:*/		regs.R4 = regs.R30;
		/* 82173AF4h case    9:*/		return 0x82173AF8;
		  /* 82173AF8h */ case   10:  		/* bl -1992 */
		/* 82173AF8h case   10:*/		regs.LR = 0x82173AFC; return 0x82173330;
		/* 82173AF8h case   10:*/		return 0x82173AFC;
		  /* 82173AFCh */ case   11:  		/* lbz R11, <#[R31 + 74]> */
		/* 82173AFCh case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004A) );
		/* 82173AFCh case   11:*/		return 0x82173B00;
		  /* 82173B00h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 82173B00h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82173B00h case   12:*/		return 0x82173B04;
		  /* 82173B04h */ case   13:  		/* bc 4, CR0_EQ, 24 */
		/* 82173B04h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82173B1C;  }
		/* 82173B04h case   13:*/		return 0x82173B08;
		  /* 82173B08h */ case   14:  		/* lwz R11, <#[R31 + 56]> */
		/* 82173B08h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82173B08h case   14:*/		return 0x82173B0C;
		  /* 82173B0Ch */ case   15:  		/* lwz R10, <#[R31 + 64]> */
		/* 82173B0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000040) );
		/* 82173B0Ch case   15:*/		return 0x82173B10;
		  /* 82173B10h */ case   16:  		/* lwz R11, <#[R11 + 16]> */
		/* 82173B10h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82173B10h case   16:*/		return 0x82173B14;
		  /* 82173B14h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 82173B14h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82173B14h case   17:*/		return 0x82173B18;
		  /* 82173B18h */ case   18:  		/* bc 4, CR6_LT, 40 */
		/* 82173B18h case   18:*/		if ( !regs.CR[6].lt ) { return 0x82173B40;  }
		/* 82173B18h case   18:*/		return 0x82173B1C;
	}
	return 0x82173B1C;
} // Block from 82173AD0h-82173B1Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82173B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173B1C);
		  /* 82173B1Ch */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82173B1Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82173B1Ch case    0:*/		return 0x82173B20;
		  /* 82173B20h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82173B20h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82173B20h case    1:*/		return 0x82173B24;
		  /* 82173B24h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82173B24h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82173B24h case    2:*/		return 0x82173B28;
		  /* 82173B28h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 82173B28h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82173B3C;  }
		/* 82173B28h case    3:*/		return 0x82173B2C;
	}
	return 0x82173B2C;
} // Block from 82173B1Ch-82173B2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82173B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173B2C);
		  /* 82173B2Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82173B2Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82173B2Ch case    0:*/		return 0x82173B30;
		  /* 82173B30h */ case    1:  		/* addic. R30, R11, -40 */
		/* 82173B30h case    1:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 82173B30h case    1:*/		return 0x82173B34;
		  /* 82173B34h */ case    2:  		/* bc 4, CR0_EQ, -88 */
		/* 82173B34h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82173ADC;  }
		/* 82173B34h case    2:*/		return 0x82173B38;
		  /* 82173B38h */ case    3:  		/* b 8 */
		/* 82173B38h case    3:*/		return 0x82173B40;
		/* 82173B38h case    3:*/		return 0x82173B3C;
	}
	return 0x82173B3C;
} // Block from 82173B2Ch-82173B3Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82173B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173B3C);
		  /* 82173B3Ch */ case    0:  		/* li R30, 0 */
		/* 82173B3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82173B3Ch case    0:*/		return 0x82173B40;
	}
	return 0x82173B40;
} // Block from 82173B3Ch-82173B40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82173B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173B40);
		  /* 82173B40h */ case    0:  		/* mr R3, R30 */
		/* 82173B40h case    0:*/		regs.R3 = regs.R30;
		/* 82173B40h case    0:*/		return 0x82173B44;
		  /* 82173B44h */ case    1:  		/* addi R1, R1, 128 */
		/* 82173B44h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82173B44h case    1:*/		return 0x82173B48;
		  /* 82173B48h */ case    2:  		/* b -927904 */
		/* 82173B48h case    2:*/		return 0x820912A8;
		/* 82173B48h case    2:*/		return 0x82173B4C;
		  /* 82173B4Ch */ case    3:  		/* nop */
		/* 82173B4Ch case    3:*/		cpu::op::nop();
		/* 82173B4Ch case    3:*/		return 0x82173B50;
	}
	return 0x82173B50;
} // Block from 82173B40h-82173B50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82173B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173B50);
		  /* 82173B50h */ case    0:  		/* mfspr R12, LR */
		/* 82173B50h case    0:*/		regs.R12 = regs.LR;
		/* 82173B50h case    0:*/		return 0x82173B54;
		  /* 82173B54h */ case    1:  		/* bl -928000 */
		/* 82173B54h case    1:*/		regs.LR = 0x82173B58; return 0x82091254;
		/* 82173B54h case    1:*/		return 0x82173B58;
		  /* 82173B58h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82173B58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82173B58h case    2:*/		return 0x82173B5C;
		  /* 82173B5Ch */ case    3:  		/* lbz R11, <#[R3 + 72]> */
		/* 82173B5Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 82173B5Ch case    3:*/		return 0x82173B60;
		  /* 82173B60h */ case    4:  		/* mr R31, R3 */
		/* 82173B60h case    4:*/		regs.R31 = regs.R3;
		/* 82173B60h case    4:*/		return 0x82173B64;
		  /* 82173B64h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82173B64h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82173B64h case    5:*/		return 0x82173B68;
		  /* 82173B68h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82173B68h case    6:*/		if ( regs.CR[0].eq ) { return 0x82173B78;  }
		/* 82173B68h case    6:*/		return 0x82173B6C;
		  /* 82173B6Ch */ case    7:  		/* li R4, 4800 */
		/* 82173B6Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82173B6Ch case    7:*/		return 0x82173B70;
		  /* 82173B70h */ case    8:  		/* lwz R3, <#[R3 + 48]> */
		/* 82173B70h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 82173B70h case    8:*/		return 0x82173B74;
		  /* 82173B74h */ case    9:  		/* bl -138508 */
		/* 82173B74h case    9:*/		regs.LR = 0x82173B78; return 0x82151E68;
		/* 82173B74h case    9:*/		return 0x82173B78;
	}
	return 0x82173B78;
} // Block from 82173B50h-82173B78h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82173B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173B78);
		  /* 82173B78h */ case    0:  		/* lwz R30, <#[R31 + 60]> */
		/* 82173B78h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173B78h case    0:*/		return 0x82173B7C;
		  /* 82173B7Ch */ case    1:  		/* addi R28, R31, 4 */
		/* 82173B7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x4);
		/* 82173B7Ch case    1:*/		return 0x82173B80;
		  /* 82173B80h */ case    2:  		/* mr R3, R28 */
		/* 82173B80h case    2:*/		regs.R3 = regs.R28;
		/* 82173B80h case    2:*/		return 0x82173B84;
		  /* 82173B84h */ case    3:  		/* mr R4, R30 */
		/* 82173B84h case    3:*/		regs.R4 = regs.R30;
		/* 82173B84h case    3:*/		return 0x82173B88;
		  /* 82173B88h */ case    4:  		/* bl -18992 */
		/* 82173B88h case    4:*/		regs.LR = 0x82173B8C; return 0x8216F158;
		/* 82173B88h case    4:*/		return 0x82173B8C;
		  /* 82173B8Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82173B8Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82173B8Ch case    5:*/		return 0x82173B90;
		  /* 82173B90h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82173B90h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82173B9C;  }
		/* 82173B90h case    6:*/		return 0x82173B94;
		  /* 82173B94h */ case    7:  		/* li R3, 1 */
		/* 82173B94h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82173B94h case    7:*/		return 0x82173B98;
		  /* 82173B98h */ case    8:  		/* b 252 */
		/* 82173B98h case    8:*/		return 0x82173C94;
		/* 82173B98h case    8:*/		return 0x82173B9C;
	}
	return 0x82173B9C;
} // Block from 82173B78h-82173B9Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82173B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173B9C);
		  /* 82173B9Ch */ case    0:  		/* lwz R29, <#[R30 + 28]> */
		/* 82173B9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x0000001C) );
		/* 82173B9Ch case    0:*/		return 0x82173BA0;
		  /* 82173BA0h */ case    1:  		/* mr R4, R30 */
		/* 82173BA0h case    1:*/		regs.R4 = regs.R30;
		/* 82173BA0h case    1:*/		return 0x82173BA4;
		  /* 82173BA4h */ case    2:  		/* lwz R6, <#[R31 + 56]> */
		/* 82173BA4h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000038) );
		/* 82173BA4h case    2:*/		return 0x82173BA8;
		  /* 82173BA8h */ case    3:  		/* mr R5, R29 */
		/* 82173BA8h case    3:*/		regs.R5 = regs.R29;
		/* 82173BA8h case    3:*/		return 0x82173BAC;
		  /* 82173BACh */ case    4:  		/* lwz R3, <#[R31 + 48]> */
		/* 82173BACh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82173BACh case    4:*/		return 0x82173BB0;
		  /* 82173BB0h */ case    5:  		/* bl -5688 */
		/* 82173BB0h case    5:*/		regs.LR = 0x82173BB4; return 0x82172578;
		/* 82173BB0h case    5:*/		return 0x82173BB4;
		  /* 82173BB4h */ case    6:  		/* mr R27, R3 */
		/* 82173BB4h case    6:*/		regs.R27 = regs.R3;
		/* 82173BB4h case    6:*/		return 0x82173BB8;
		  /* 82173BB8h */ case    7:  		/* mr R4, R30 */
		/* 82173BB8h case    7:*/		regs.R4 = regs.R30;
		/* 82173BB8h case    7:*/		return 0x82173BBC;
		  /* 82173BBCh */ case    8:  		/* mr R3, R28 */
		/* 82173BBCh case    8:*/		regs.R3 = regs.R28;
		/* 82173BBCh case    8:*/		return 0x82173BC0;
		  /* 82173BC0h */ case    9:  		/* bl -18408 */
		/* 82173BC0h case    9:*/		regs.LR = 0x82173BC4; return 0x8216F3D8;
		/* 82173BC0h case    9:*/		return 0x82173BC4;
		  /* 82173BC4h */ case   10:  		/* rlwinm. R11, R27, 0, 30, 30 */
		/* 82173BC4h case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R27);
		/* 82173BC4h case   10:*/		return 0x82173BC8;
	}
	return 0x82173BC8;
} // Block from 82173B9Ch-82173BC8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82173BC8h
// Function '?UpdateLocalRegisters@Compiler@D3DXShader@@QAAXPAVInstruction@2@PAVBlock@2@PAVInfiniteLocalRegisterSet@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173BC8);
		  /* 82173BC8h */ case    0:  		/* bc 4, CR0_EQ, 36 */
		/* 82173BC8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82173BEC;  }
		/* 82173BC8h case    0:*/		return 0x82173BCC;
		  /* 82173BCCh */ case    1:  		/* lbz R11, <#[R31 + 74]> */
		/* 82173BCCh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004A) );
		/* 82173BCCh case    1:*/		return 0x82173BD0;
		  /* 82173BD0h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82173BD0h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82173BD0h case    2:*/		return 0x82173BD4;
		  /* 82173BD4h */ case    3:  		/* bc 4, CR0_EQ, 96 */
		/* 82173BD4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82173C34;  }
		/* 82173BD4h case    3:*/		return 0x82173BD8;
		  /* 82173BD8h */ case    4:  		/* lwz R11, <#[R31 + 56]> */
		/* 82173BD8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82173BD8h case    4:*/		return 0x82173BDC;
		  /* 82173BDCh */ case    5:  		/* lwz R10, <#[R31 + 64]> */
		/* 82173BDCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000040) );
		/* 82173BDCh case    5:*/		return 0x82173BE0;
		  /* 82173BE0h */ case    6:  		/* lwz R11, <#[R11 + 16]> */
		/* 82173BE0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82173BE0h case    6:*/		return 0x82173BE4;
		  /* 82173BE4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82173BE4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82173BE4h case    7:*/		return 0x82173BE8;
		  /* 82173BE8h */ case    8:  		/* bc 12, CR6_LT, 76 */
		/* 82173BE8h case    8:*/		if ( regs.CR[6].lt ) { return 0x82173C34;  }
		/* 82173BE8h case    8:*/		return 0x82173BEC;
	}
	return 0x82173BEC;
} // Block from 82173BC8h-82173BECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82173BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173BEC);
		  /* 82173BECh */ case    0:  		/* mr R5, R30 */
		/* 82173BECh case    0:*/		regs.R5 = regs.R30;
		/* 82173BECh case    0:*/		return 0x82173BF0;
		  /* 82173BF0h */ case    1:  		/* mr R4, R29 */
		/* 82173BF0h case    1:*/		regs.R4 = regs.R29;
		/* 82173BF0h case    1:*/		return 0x82173BF4;
		  /* 82173BF4h */ case    2:  		/* mr R3, R31 */
		/* 82173BF4h case    2:*/		regs.R3 = regs.R31;
		/* 82173BF4h case    2:*/		return 0x82173BF8;
		  /* 82173BF8h */ case    3:  		/* bl -368 */
		/* 82173BF8h case    3:*/		regs.LR = 0x82173BFC; return 0x82173A88;
		/* 82173BF8h case    3:*/		return 0x82173BFC;
		  /* 82173BFCh */ case    4:  		/* cmplw CR6, R3, R30 */
		/* 82173BFCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 82173BFCh case    4:*/		return 0x82173C00;
		  /* 82173C00h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 82173C00h case    5:*/		if ( regs.CR[6].eq ) { return 0x82173C34;  }
		/* 82173C00h case    5:*/		return 0x82173C04;
		  /* 82173C04h */ case    6:  		/* li R5, 0 */
		/* 82173C04h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82173C04h case    6:*/		return 0x82173C08;
		  /* 82173C08h */ case    7:  		/* mr R4, R30 */
		/* 82173C08h case    7:*/		regs.R4 = regs.R30;
		/* 82173C08h case    7:*/		return 0x82173C0C;
		  /* 82173C0Ch */ case    8:  		/* mr R3, R31 */
		/* 82173C0Ch case    8:*/		regs.R3 = regs.R31;
		/* 82173C0Ch case    8:*/		return 0x82173C10;
		  /* 82173C10h */ case    9:  		/* bl -3776 */
		/* 82173C10h case    9:*/		regs.LR = 0x82173C14; return 0x82172D50;
		/* 82173C10h case    9:*/		return 0x82173C14;
		  /* 82173C14h */ case   10:  		/* li R5, 1 */
		/* 82173C14h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82173C14h case   10:*/		return 0x82173C18;
		  /* 82173C18h */ case   11:  		/* mr R4, R29 */
		/* 82173C18h case   11:*/		regs.R4 = regs.R29;
		/* 82173C18h case   11:*/		return 0x82173C1C;
		  /* 82173C1Ch */ case   12:  		/* lwz R3, <#[R31 + 48]> */
		/* 82173C1Ch case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82173C1Ch case   12:*/		return 0x82173C20;
		  /* 82173C20h */ case   13:  		/* bl -8272 */
		/* 82173C20h case   13:*/		regs.LR = 0x82173C24; return 0x82171BD0;
		/* 82173C20h case   13:*/		return 0x82173C24;
		  /* 82173C24h */ case   14:  		/* li R11, 1 */
		/* 82173C24h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82173C24h case   14:*/		return 0x82173C28;
		  /* 82173C28h */ case   15:  		/* li R3, 2 */
		/* 82173C28h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82173C28h case   15:*/		return 0x82173C2C;
		  /* 82173C2Ch */ case   16:  		/* stb R11, <#[R31 + 72]> */
		/* 82173C2Ch case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82173C2Ch case   16:*/		return 0x82173C30;
		  /* 82173C30h */ case   17:  		/* b 100 */
		/* 82173C30h case   17:*/		return 0x82173C94;
		/* 82173C30h case   17:*/		return 0x82173C34;
	}
	return 0x82173C34;
} // Block from 82173BECh-82173C34h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82173C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173C34);
		  /* 82173C34h */ case    0:  		/* mr R7, R30 */
		/* 82173C34h case    0:*/		regs.R7 = regs.R30;
		/* 82173C34h case    0:*/		return 0x82173C38;
		  /* 82173C38h */ case    1:  		/* lwz R6, <#[R31 + 56]> */
		/* 82173C38h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000038) );
		/* 82173C38h case    1:*/		return 0x82173C3C;
		  /* 82173C3Ch */ case    2:  		/* mr R5, R29 */
		/* 82173C3Ch case    2:*/		regs.R5 = regs.R29;
		/* 82173C3Ch case    2:*/		return 0x82173C40;
		  /* 82173C40h */ case    3:  		/* lwz R3, <#[R31 + 48]> */
		/* 82173C40h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82173C40h case    3:*/		return 0x82173C44;
		  /* 82173C44h */ case    4:  		/* mr R4, R30 */
		/* 82173C44h case    4:*/		regs.R4 = regs.R30;
		/* 82173C44h case    4:*/		return 0x82173C48;
		  /* 82173C48h */ case    5:  		/* bl -2328 */
		/* 82173C48h case    5:*/		regs.LR = 0x82173C4C; return 0x82173330;
		/* 82173C48h case    5:*/		return 0x82173C4C;
		  /* 82173C4Ch */ case    6:  		/* lbz R11, <#[R31 + 74]> */
		/* 82173C4Ch case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004A) );
		/* 82173C4Ch case    6:*/		return 0x82173C50;
		  /* 82173C50h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82173C50h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82173C50h case    7:*/		return 0x82173C54;
		  /* 82173C54h */ case    8:  		/* bc 4, CR0_EQ, 24 */
		/* 82173C54h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82173C6C;  }
		/* 82173C54h case    8:*/		return 0x82173C58;
		  /* 82173C58h */ case    9:  		/* lwz R11, <#[R31 + 56]> */
		/* 82173C58h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82173C58h case    9:*/		return 0x82173C5C;
		  /* 82173C5Ch */ case   10:  		/* lwz R10, <#[R31 + 64]> */
		/* 82173C5Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000040) );
		/* 82173C5Ch case   10:*/		return 0x82173C60;
		  /* 82173C60h */ case   11:  		/* lwz R11, <#[R11 + 16]> */
		/* 82173C60h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82173C60h case   11:*/		return 0x82173C64;
		  /* 82173C64h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 82173C64h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82173C64h case   12:*/		return 0x82173C68;
		  /* 82173C68h */ case   13:  		/* bc 4, CR6_LT, -100 */
		/* 82173C68h case   13:*/		if ( !regs.CR[6].lt ) { return 0x82173C04;  }
		/* 82173C68h case   13:*/		return 0x82173C6C;
	}
	return 0x82173C6C;
} // Block from 82173C34h-82173C6Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82173C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173C6C);
		  /* 82173C6Ch */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82173C6Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82173C6Ch case    0:*/		return 0x82173C70;
		  /* 82173C70h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82173C70h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82173C70h case    1:*/		return 0x82173C74;
		  /* 82173C74h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82173C74h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82173C74h case    2:*/		return 0x82173C78;
		  /* 82173C78h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82173C78h case    3:*/		if ( regs.CR[0].eq ) { return 0x82173C84;  }
		/* 82173C78h case    3:*/		return 0x82173C7C;
		  /* 82173C7Ch */ case    4:  		/* li R11, 0 */
		/* 82173C7Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82173C7Ch case    4:*/		return 0x82173C80;
		  /* 82173C80h */ case    5:  		/* b 12 */
		/* 82173C80h case    5:*/		return 0x82173C8C;
		/* 82173C80h case    5:*/		return 0x82173C84;
	}
	return 0x82173C84;
} // Block from 82173C6Ch-82173C84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82173C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173C84);
		  /* 82173C84h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82173C84h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82173C84h case    0:*/		return 0x82173C88;
		  /* 82173C88h */ case    1:  		/* addi R11, R11, -40 */
		/* 82173C88h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82173C88h case    1:*/		return 0x82173C8C;
	}
	return 0x82173C8C;
} // Block from 82173C84h-82173C8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173C8C);
		  /* 82173C8Ch */ case    0:  		/* stw R11, <#[R31 + 60]> */
		/* 82173C8Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173C8Ch case    0:*/		return 0x82173C90;
		  /* 82173C90h */ case    1:  		/* li R3, 0 */
		/* 82173C90h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82173C90h case    1:*/		return 0x82173C94;
	}
	return 0x82173C94;
} // Block from 82173C8Ch-82173C94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173C94);
		  /* 82173C94h */ case    0:  		/* addi R1, R1, 128 */
		/* 82173C94h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82173C94h case    0:*/		return 0x82173C98;
		  /* 82173C98h */ case    1:  		/* b -928244 */
		/* 82173C98h case    1:*/		return 0x820912A4;
		/* 82173C98h case    1:*/		return 0x82173C9C;
		  /* 82173C9Ch */ case    2:  		/* nop */
		/* 82173C9Ch case    2:*/		cpu::op::nop();
		/* 82173C9Ch case    2:*/		return 0x82173CA0;
	}
	return 0x82173CA0;
} // Block from 82173C94h-82173CA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173CA0);
		  /* 82173CA0h */ case    0:  		/* mfspr R12, LR */
		/* 82173CA0h case    0:*/		regs.R12 = regs.LR;
		/* 82173CA0h case    0:*/		return 0x82173CA4;
		  /* 82173CA4h */ case    1:  		/* bl -928328 */
		/* 82173CA4h case    1:*/		regs.LR = 0x82173CA8; return 0x8209125C;
		/* 82173CA4h case    1:*/		return 0x82173CA8;
		  /* 82173CA8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82173CA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82173CA8h case    2:*/		return 0x82173CAC;
		  /* 82173CACh */ case    3:  		/* lwz R11, <#[R4 + 20]> */
		/* 82173CACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 82173CACh case    3:*/		return 0x82173CB0;
		  /* 82173CB0h */ case    4:  		/* mr R31, R3 */
		/* 82173CB0h case    4:*/		regs.R31 = regs.R3;
		/* 82173CB0h case    4:*/		return 0x82173CB4;
		  /* 82173CB4h */ case    5:  		/* lwz R10, <#[R3 + 60]> */
		/* 82173CB4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000003C) );
		/* 82173CB4h case    5:*/		return 0x82173CB8;
		  /* 82173CB8h */ case    6:  		/* mr R29, R4 */
		/* 82173CB8h case    6:*/		regs.R29 = regs.R4;
		/* 82173CB8h case    6:*/		return 0x82173CBC;
		  /* 82173CBCh */ case    7:  		/* rlwinm R30, R11, 0, 19, 31 */
		/* 82173CBCh case    7:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R30,regs.R11);
		/* 82173CBCh case    7:*/		return 0x82173CC0;
		  /* 82173CC0h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82173CC0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82173CC0h case    8:*/		return 0x82173CC4;
		  /* 82173CC4h */ case    9:  		/* bc 12, CR6_EQ, 152 */
		/* 82173CC4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82173D5C;  }
		/* 82173CC4h case    9:*/		return 0x82173CC8;
		  /* 82173CC8h */ case   10:  		/* lwz R11, <#[R31 + 60]> */
		/* 82173CC8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173CC8h case   10:*/		return 0x82173CCC;
		  /* 82173CCCh */ case   11:  		/* lwz R11, <#[R11 + 20]> */
		/* 82173CCCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82173CCCh case   11:*/		return 0x82173CD0;
		  /* 82173CD0h */ case   12:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 82173CD0h case   12:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 82173CD0h case   12:*/		return 0x82173CD4;
		  /* 82173CD4h */ case   13:  		/* cmplw CR6, R30, R11 */
		/* 82173CD4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82173CD4h case   13:*/		return 0x82173CD8;
		  /* 82173CD8h */ case   14:  		/* bc 12, CR6_LT, 132 */
		/* 82173CD8h case   14:*/		if ( regs.CR[6].lt ) { return 0x82173D5C;  }
		/* 82173CD8h case   14:*/		return 0x82173CDC;
		  /* 82173CDCh */ case   15:  		/* bc 4, CR6_EQ, 44 */
		/* 82173CDCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82173D08;  }
		/* 82173CDCh case   15:*/		return 0x82173CE0;
		  /* 82173CE0h */ case   16:  		/* lwz R11, <#[R29 + 8]> */
		/* 82173CE0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82173CE0h case   16:*/		return 0x82173CE4;
		  /* 82173CE4h */ case   17:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82173CE4h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82173CE4h case   17:*/		return 0x82173CE8;
		  /* 82173CE8h */ case   18:  		/* cmplwi CR6, R11, 32 */
		/* 82173CE8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82173CE8h case   18:*/		return 0x82173CEC;
		  /* 82173CECh */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 82173CECh case   19:*/		if ( regs.CR[6].lt ) { return 0x82173CFC;  }
		/* 82173CECh case   19:*/		return 0x82173CF0;
		  /* 82173CF0h */ case   20:  		/* cmplwi CR6, R11, 82 */
		/* 82173CF0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82173CF0h case   20:*/		return 0x82173CF4;
		  /* 82173CF4h */ case   21:  		/* li R11, 1 */
		/* 82173CF4h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82173CF4h case   21:*/		return 0x82173CF8;
		  /* 82173CF8h */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 82173CF8h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82173D00;  }
		/* 82173CF8h case   22:*/		return 0x82173CFC;
	}
	return 0x82173CFC;
} // Block from 82173CA0h-82173CFCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 82173CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173CFC);
		  /* 82173CFCh */ case    0:  		/* li R11, 0 */
		/* 82173CFCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82173CFCh case    0:*/		return 0x82173D00;
	}
	return 0x82173D00;
} // Block from 82173CFCh-82173D00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82173D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173D00);
		  /* 82173D00h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82173D00h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82173D00h case    0:*/		return 0x82173D04;
		  /* 82173D04h */ case    1:  		/* bc 4, CR0_EQ, 88 */
		/* 82173D04h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82173D5C;  }
		/* 82173D04h case    1:*/		return 0x82173D08;
	}
	return 0x82173D08;
} // Block from 82173D00h-82173D08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173D08);
		  /* 82173D08h */ case    0:  		/* mr R3, R31 */
		/* 82173D08h case    0:*/		regs.R3 = regs.R31;
		/* 82173D08h case    0:*/		return 0x82173D0C;
		  /* 82173D0Ch */ case    1:  		/* bl -444 */
		/* 82173D0Ch case    1:*/		regs.LR = 0x82173D10; return 0x82173B50;
		/* 82173D0Ch case    1:*/		return 0x82173D10;
		  /* 82173D10h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82173D10h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82173D10h case    2:*/		return 0x82173D14;
		  /* 82173D14h */ case    3:  		/* bc 12, CR0_EQ, 60 */
		/* 82173D14h case    3:*/		if ( regs.CR[0].eq ) { return 0x82173D50;  }
		/* 82173D14h case    3:*/		return 0x82173D18;
		  /* 82173D18h */ case    4:  		/* cmpwi CR6, R3, 2 */
		/* 82173D18h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82173D18h case    4:*/		return 0x82173D1C;
		  /* 82173D1Ch */ case    5:  		/* bc 4, CR6_EQ, 44 */
		/* 82173D1Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82173D48;  }
		/* 82173D1Ch case    5:*/		return 0x82173D20;
		  /* 82173D20h */ case    6:  		/* lwz R5, <#[R31 + 60]> */
		/* 82173D20h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173D20h case    6:*/		return 0x82173D24;
		  /* 82173D24h */ case    7:  		/* mr R3, R31 */
		/* 82173D24h case    7:*/		regs.R3 = regs.R31;
		/* 82173D24h case    7:*/		return 0x82173D28;
		  /* 82173D28h */ case    8:  		/* lwz R4, <#[R5 + 28]> */
		/* 82173D28h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 82173D28h case    8:*/		return 0x82173D2C;
		  /* 82173D2Ch */ case    9:  		/* bl -676 */
		/* 82173D2Ch case    9:*/		regs.LR = 0x82173D30; return 0x82173A88;
		/* 82173D2Ch case    9:*/		return 0x82173D30;
		  /* 82173D30h */ case   10:  		/* lwz R11, <#[R31 + 60]> */
		/* 82173D30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173D30h case   10:*/		return 0x82173D34;
		  /* 82173D34h */ case   11:  		/* cmplw CR6, R3, R11 */
		/* 82173D34h case   11:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82173D34h case   11:*/		return 0x82173D38;
		  /* 82173D38h */ case   12:  		/* bc 4, CR6_EQ, 48 */
		/* 82173D38h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82173D68;  }
		/* 82173D38h case   12:*/		return 0x82173D3C;
		  /* 82173D3Ch */ case   13:  		/* li R11, 0 */
		/* 82173D3Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82173D3Ch case   13:*/		return 0x82173D40;
		  /* 82173D40h */ case   14:  		/* li R3, 0 */
		/* 82173D40h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82173D40h case   14:*/		return 0x82173D44;
		  /* 82173D44h */ case   15:  		/* stb R11, <#[R31 + 72]> */
		/* 82173D44h case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82173D44h case   15:*/		return 0x82173D48;
	}
	return 0x82173D48;
} // Block from 82173D08h-82173D48h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82173D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173D48);
		  /* 82173D48h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 82173D48h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82173D48h case    0:*/		return 0x82173D4C;
		  /* 82173D4Ch */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82173D4Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82173D68;  }
		/* 82173D4Ch case    1:*/		return 0x82173D50;
	}
	return 0x82173D50;
} // Block from 82173D48h-82173D50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173D50);
		  /* 82173D50h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 82173D50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173D50h case    0:*/		return 0x82173D54;
		  /* 82173D54h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82173D54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82173D54h case    1:*/		return 0x82173D58;
		  /* 82173D58h */ case    2:  		/* bc 4, CR6_EQ, -144 */
		/* 82173D58h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82173CC8;  }
		/* 82173D58h case    2:*/		return 0x82173D5C;
	}
	return 0x82173D5C;
} // Block from 82173D50h-82173D5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173D5C);
		  /* 82173D5Ch */ case    0:  		/* li R3, 1 */
		/* 82173D5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82173D5Ch case    0:*/		return 0x82173D60;
		  /* 82173D60h */ case    1:  		/* addi R1, R1, 112 */
		/* 82173D60h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82173D60h case    1:*/		return 0x82173D64;
		  /* 82173D64h */ case    2:  		/* b -928440 */
		/* 82173D64h case    2:*/		return 0x820912AC;
		/* 82173D64h case    2:*/		return 0x82173D68;
	}
	return 0x82173D68;
} // Block from 82173D5Ch-82173D68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173D68);
		  /* 82173D68h */ case    0:  		/* li R3, 0 */
		/* 82173D68h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82173D68h case    0:*/		return 0x82173D6C;
		  /* 82173D6Ch */ case    1:  		/* b -12 */
		/* 82173D6Ch case    1:*/		return 0x82173D60;
		/* 82173D6Ch case    1:*/		return 0x82173D70;
	}
	return 0x82173D70;
} // Block from 82173D68h-82173D70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173D70);
		  /* 82173D70h */ case    0:  		/* mfspr R12, LR */
		/* 82173D70h case    0:*/		regs.R12 = regs.LR;
		/* 82173D70h case    0:*/		return 0x82173D74;
		  /* 82173D74h */ case    1:  		/* bl -928536 */
		/* 82173D74h case    1:*/		regs.LR = 0x82173D78; return 0x8209125C;
		/* 82173D74h case    1:*/		return 0x82173D78;
		  /* 82173D78h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82173D78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82173D78h case    2:*/		return 0x82173D7C;
		  /* 82173D7Ch */ case    3:  		/* stw R4, <#[R3 + 68]> */
		/* 82173D7Ch case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000044) );
		/* 82173D7Ch case    3:*/		return 0x82173D80;
		  /* 82173D80h */ case    4:  		/* mr R31, R3 */
		/* 82173D80h case    4:*/		regs.R31 = regs.R3;
		/* 82173D80h case    4:*/		return 0x82173D84;
		  /* 82173D84h */ case    5:  		/* stw R5, <#[R3]> */
		/* 82173D84h case    5:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000000) );
		/* 82173D84h case    5:*/		return 0x82173D88;
		  /* 82173D88h */ case    6:  		/* mr R29, R8 */
		/* 82173D88h case    6:*/		regs.R29 = regs.R8;
		/* 82173D88h case    6:*/		return 0x82173D8C;
		  /* 82173D8Ch */ case    7:  		/* stw R6, <#[R3 + 56]> */
		/* 82173D8Ch case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000038) );
		/* 82173D8Ch case    7:*/		return 0x82173D90;
		  /* 82173D90h */ case    8:  		/* li R30, 0 */
		/* 82173D90h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82173D90h case    8:*/		return 0x82173D94;
		  /* 82173D94h */ case    9:  		/* stw R7, <#[R3 + 64]> */
		/* 82173D94h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000040) );
		/* 82173D94h case    9:*/		return 0x82173D98;
		  /* 82173D98h */ case   10:  		/* lwz R11, <#[R5 + 4]> */
		/* 82173D98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82173D98h case   10:*/		return 0x82173D9C;
		  /* 82173D9Ch */ case   11:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82173D9Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82173D9Ch case   11:*/		return 0x82173DA0;
		  /* 82173DA0h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 82173DA0h case   12:*/		if ( regs.CR[0].eq ) { return 0x82173DAC;  }
		/* 82173DA0h case   12:*/		return 0x82173DA4;
		  /* 82173DA4h */ case   13:  		/* mr R10, R30 */
		/* 82173DA4h case   13:*/		regs.R10 = regs.R30;
		/* 82173DA4h case   13:*/		return 0x82173DA8;
		  /* 82173DA8h */ case   14:  		/* b 16 */
		/* 82173DA8h case   14:*/		return 0x82173DB8;
		/* 82173DA8h case   14:*/		return 0x82173DAC;
	}
	return 0x82173DAC;
} // Block from 82173D70h-82173DACh (15 instructions)

//////////////////////////////////////////////////////
// Block at 82173DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173DAC);
		  /* 82173DACh */ case    0:  		/* lwz R11, <#[R5]> */
		/* 82173DACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82173DACh case    0:*/		return 0x82173DB0;
		  /* 82173DB0h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82173DB0h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82173DB0h case    1:*/		return 0x82173DB4;
		  /* 82173DB4h */ case    2:  		/* addi R10, R11, -40 */
		/* 82173DB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFD8);
		/* 82173DB4h case    2:*/		return 0x82173DB8;
	}
	return 0x82173DB8;
} // Block from 82173DACh-82173DB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173DB8);
		  /* 82173DB8h */ case    0:  		/* addi R11, R31, 4 */
		/* 82173DB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x4);
		/* 82173DB8h case    0:*/		return 0x82173DBC;
		  /* 82173DBCh */ case    1:  		/* stb R30, <#[R31 + 72]> */
		/* 82173DBCh case    1:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x00000048) );
		/* 82173DBCh case    1:*/		return 0x82173DC0;
		  /* 82173DC0h */ case    2:  		/* li R5, 36 */
		/* 82173DC0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 82173DC0h case    2:*/		return 0x82173DC4;
		  /* 82173DC4h */ case    3:  		/* stw R10, <#[R31 + 60]> */
		/* 82173DC4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173DC4h case    3:*/		return 0x82173DC8;
		  /* 82173DC8h */ case    4:  		/* li R4, 0 */
		/* 82173DC8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82173DC8h case    4:*/		return 0x82173DCC;
		  /* 82173DCCh */ case    5:  		/* stb R30, <#[R31 + 73]> */
		/* 82173DCCh case    5:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x00000049) );
		/* 82173DCCh case    5:*/		return 0x82173DD0;
		  /* 82173DD0h */ case    6:  		/* addi R3, R11, 4 */
		/* 82173DD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x4);
		/* 82173DD0h case    6:*/		return 0x82173DD4;
		  /* 82173DD4h */ case    7:  		/* stb R30, <#[R31 + 74]> */
		/* 82173DD4h case    7:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x0000004A) );
		/* 82173DD4h case    7:*/		return 0x82173DD8;
		  /* 82173DD8h */ case    8:  		/* stw R29, <#[R31 + 4]> */
		/* 82173DD8h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 82173DD8h case    8:*/		return 0x82173DDC;
		  /* 82173DDCh */ case    9:  		/* bl -928412 */
		/* 82173DDCh case    9:*/		regs.LR = 0x82173DE0; return 0x82091340;
		/* 82173DDCh case    9:*/		return 0x82173DE0;
		  /* 82173DE0h */ case   10:  		/* stw R29, <#[R31 + 48]> */
		/* 82173DE0h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000030) );
		/* 82173DE0h case   10:*/		return 0x82173DE4;
		  /* 82173DE4h */ case   11:  		/* stw R30, <#[R31 + 44]> */
		/* 82173DE4h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000002C) );
		/* 82173DE4h case   11:*/		return 0x82173DE8;
		  /* 82173DE8h */ case   12:  		/* stw R30, <#[R31 + 52]> */
		/* 82173DE8h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000034) );
		/* 82173DE8h case   12:*/		return 0x82173DEC;
		  /* 82173DECh */ case   13:  		/* b 76 */
		/* 82173DECh case   13:*/		return 0x82173E38;
		/* 82173DECh case   13:*/		return 0x82173DF0;
		  /* 82173DF0h */ case   14:  		/* lwz R3, <#[R31 + 60]> */
		/* 82173DF0h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173DF0h case   14:*/		return 0x82173DF4;
		  /* 82173DF4h */ case   15:  		/* lwz R11, <#[R3 + 8]> */
		/* 82173DF4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82173DF4h case   15:*/		return 0x82173DF8;
		  /* 82173DF8h */ case   16:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82173DF8h case   16:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82173DF8h case   16:*/		return 0x82173DFC;
		  /* 82173DFCh */ case   17:  		/* cmplwi CR6, R11, 83 */
		/* 82173DFCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000053);
		/* 82173DFCh case   17:*/		return 0x82173E00;
		  /* 82173E00h */ case   18:  		/* bc 12, CR6_LT, 16 */
		/* 82173E00h case   18:*/		if ( regs.CR[6].lt ) { return 0x82173E10;  }
		/* 82173E00h case   18:*/		return 0x82173E04;
		  /* 82173E04h */ case   19:  		/* cmplwi CR6, R11, 95 */
		/* 82173E04h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 82173E04h case   19:*/		return 0x82173E08;
		  /* 82173E08h */ case   20:  		/* li R11, 1 */
		/* 82173E08h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82173E08h case   20:*/		return 0x82173E0C;
		  /* 82173E0Ch */ case   21:  		/* bc 4, CR6_GT, 8 */
		/* 82173E0Ch case   21:*/		if ( !regs.CR[6].gt ) { return 0x82173E14;  }
		/* 82173E0Ch case   21:*/		return 0x82173E10;
	}
	return 0x82173E10;
} // Block from 82173DB8h-82173E10h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82173E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E10);
		  /* 82173E10h */ case    0:  		/* mr R11, R30 */
		/* 82173E10h case    0:*/		regs.R11 = regs.R30;
		/* 82173E10h case    0:*/		return 0x82173E14;
	}
	return 0x82173E14;
} // Block from 82173E10h-82173E14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82173E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E14);
		  /* 82173E14h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82173E14h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82173E14h case    0:*/		return 0x82173E18;
		  /* 82173E18h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82173E18h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82173E28;  }
		/* 82173E18h case    1:*/		return 0x82173E1C;
		  /* 82173E1Ch */ case    2:  		/* bl -64876 */
		/* 82173E1Ch case    2:*/		regs.LR = 0x82173E20; return 0x821640B0;
		/* 82173E1Ch case    2:*/		return 0x82173E20;
		  /* 82173E20h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82173E20h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82173E20h case    3:*/		return 0x82173E24;
		  /* 82173E24h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 82173E24h case    4:*/		if ( regs.CR[0].eq ) { return 0x82173E44;  }
		/* 82173E24h case    4:*/		return 0x82173E28;
	}
	return 0x82173E28;
} // Block from 82173E14h-82173E28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82173E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E28);
		  /* 82173E28h */ case    0:  		/* mr R3, R31 */
		/* 82173E28h case    0:*/		regs.R3 = regs.R31;
		/* 82173E28h case    0:*/		return 0x82173E2C;
		  /* 82173E2Ch */ case    1:  		/* bl -732 */
		/* 82173E2Ch case    1:*/		regs.LR = 0x82173E30; return 0x82173B50;
		/* 82173E2Ch case    1:*/		return 0x82173E30;
		  /* 82173E30h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82173E30h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82173E30h case    2:*/		return 0x82173E34;
		  /* 82173E34h */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 82173E34h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82173E50;  }
		/* 82173E34h case    3:*/		return 0x82173E38;
	}
	return 0x82173E38;
} // Block from 82173E28h-82173E38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82173E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E38);
		  /* 82173E38h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 82173E38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82173E38h case    0:*/		return 0x82173E3C;
		  /* 82173E3Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82173E3Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82173E3Ch case    1:*/		return 0x82173E40;
		  /* 82173E40h */ case    2:  		/* bc 4, CR6_EQ, -80 */
		/* 82173E40h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82173DF0;  }
		/* 82173E40h case    2:*/		return 0x82173E44;
	}
	return 0x82173E44;
} // Block from 82173E38h-82173E44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E44);
		  /* 82173E44h */ case    0:  		/* mr R3, R31 */
		/* 82173E44h case    0:*/		regs.R3 = regs.R31;
		/* 82173E44h case    0:*/		return 0x82173E48;
		  /* 82173E48h */ case    1:  		/* addi R1, R1, 112 */
		/* 82173E48h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82173E48h case    1:*/		return 0x82173E4C;
		  /* 82173E4Ch */ case    2:  		/* b -928672 */
		/* 82173E4Ch case    2:*/		return 0x820912AC;
		/* 82173E4Ch case    2:*/		return 0x82173E50;
	}
	return 0x82173E50;
} // Block from 82173E44h-82173E50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82173E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E50);
		  /* 82173E50h */ case    0:  		/* li R4, 4800 */
		/* 82173E50h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82173E50h case    0:*/		return 0x82173E54;
		  /* 82173E54h */ case    1:  		/* mr R3, R29 */
		/* 82173E54h case    1:*/		regs.R3 = regs.R29;
		/* 82173E54h case    1:*/		return 0x82173E58;
		  /* 82173E58h */ case    2:  		/* bl -139248 */
		/* 82173E58h case    2:*/		regs.LR = 0x82173E5C; return 0x82151E68;
		/* 82173E58h case    2:*/		return 0x82173E5C;
		  /* 82173E5Ch */ case    3:  		/* nop */
		/* 82173E5Ch case    3:*/		cpu::op::nop();
		/* 82173E5Ch case    3:*/		return 0x82173E60;
	}
	return 0x82173E60;
} // Block from 82173E50h-82173E60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82173E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E60);
		  /* 82173E60h */ case    0:  		/* mfspr R12, LR */
		/* 82173E60h case    0:*/		regs.R12 = regs.LR;
		/* 82173E60h case    0:*/		return 0x82173E64;
		  /* 82173E64h */ case    1:  		/* bl -928784 */
		/* 82173E64h case    1:*/		regs.LR = 0x82173E68; return 0x82091254;
		/* 82173E64h case    1:*/		return 0x82173E68;
		  /* 82173E68h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82173E68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82173E68h case    2:*/		return 0x82173E6C;
		  /* 82173E6Ch */ case    3:  		/* lbz R11, <#[R3 + 72]> */
		/* 82173E6Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 82173E6Ch case    3:*/		return 0x82173E70;
		  /* 82173E70h */ case    4:  		/* mr R30, R3 */
		/* 82173E70h case    4:*/		regs.R30 = regs.R3;
		/* 82173E70h case    4:*/		return 0x82173E74;
		  /* 82173E74h */ case    5:  		/* mr R27, R4 */
		/* 82173E74h case    5:*/		regs.R27 = regs.R4;
		/* 82173E74h case    5:*/		return 0x82173E78;
		  /* 82173E78h */ case    6:  		/* mr R28, R5 */
		/* 82173E78h case    6:*/		regs.R28 = regs.R5;
		/* 82173E78h case    6:*/		return 0x82173E7C;
		  /* 82173E7Ch */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82173E7Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82173E7Ch case    7:*/		return 0x82173E80;
		  /* 82173E80h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82173E80h case    8:*/		if ( regs.CR[0].eq ) { return 0x82173E90;  }
		/* 82173E80h case    8:*/		return 0x82173E84;
		  /* 82173E84h */ case    9:  		/* li R4, 4800 */
		/* 82173E84h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82173E84h case    9:*/		return 0x82173E88;
		  /* 82173E88h */ case   10:  		/* lwz R3, <#[R3 + 48]> */
		/* 82173E88h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 82173E88h case   10:*/		return 0x82173E8C;
		  /* 82173E8Ch */ case   11:  		/* bl -139300 */
		/* 82173E8Ch case   11:*/		regs.LR = 0x82173E90; return 0x82151E68;
		/* 82173E8Ch case   11:*/		return 0x82173E90;
	}
	return 0x82173E90;
} // Block from 82173E60h-82173E90h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82173E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173E90);
		  /* 82173E90h */ case    0:  		/* cmpwi CR6, R28, 1 */
		/* 82173E90h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000001);
		/* 82173E90h case    0:*/		return 0x82173E94;
		  /* 82173E94h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82173E94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82173EB4;  }
		/* 82173E94h case    1:*/		return 0x82173E98;
		  /* 82173E98h */ case    2:  		/* mr R4, R27 */
		/* 82173E98h case    2:*/		regs.R4 = regs.R27;
		/* 82173E98h case    2:*/		return 0x82173E9C;
		  /* 82173E9Ch */ case    3:  		/* mr R3, R30 */
		/* 82173E9Ch case    3:*/		regs.R3 = regs.R30;
		/* 82173E9Ch case    3:*/		return 0x82173EA0;
		  /* 82173EA0h */ case    4:  		/* bl -512 */
		/* 82173EA0h case    4:*/		regs.LR = 0x82173EA4; return 0x82173CA0;
		/* 82173EA0h case    4:*/		return 0x82173EA4;
		  /* 82173EA4h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82173EA4h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82173EA4h case    5:*/		return 0x82173EA8;
		  /* 82173EA8h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82173EA8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82173EB4;  }
		/* 82173EA8h case    6:*/		return 0x82173EAC;
		  /* 82173EACh */ case    7:  		/* li R3, 0 */
		/* 82173EACh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82173EACh case    7:*/		return 0x82173EB0;
		  /* 82173EB0h */ case    8:  		/* b 220 */
		/* 82173EB0h case    8:*/		return 0x82173F8C;
		/* 82173EB0h case    8:*/		return 0x82173EB4;
	}
	return 0x82173EB4;
} // Block from 82173E90h-82173EB4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82173EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173EB4);
		  /* 82173EB4h */ case    0:  		/* mr R31, R27 */
		/* 82173EB4h case    0:*/		regs.R31 = regs.R27;
		/* 82173EB4h case    0:*/		return 0x82173EB8;
		  /* 82173EB8h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 82173EB8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82173EB8h case    1:*/		return 0x82173EBC;
		  /* 82173EBCh */ case    2:  		/* bc 12, CR6_EQ, 204 */
		/* 82173EBCh case    2:*/		if ( regs.CR[6].eq ) { return 0x82173F88;  }
		/* 82173EBCh case    2:*/		return 0x82173EC0;
		  /* 82173EC0h */ case    3:  		/* cmpwi CR6, R28, 1 */
		/* 82173EC0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000001);
		/* 82173EC0h case    3:*/		return 0x82173EC4;
		  /* 82173EC4h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 82173EC4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82173EDC;  }
		/* 82173EC4h case    4:*/		return 0x82173EC8;
		  /* 82173EC8h */ case    5:  		/* mr R4, R31 */
		/* 82173EC8h case    5:*/		regs.R4 = regs.R31;
		/* 82173EC8h case    5:*/		return 0x82173ECC;
		  /* 82173ECCh */ case    6:  		/* mr R3, R30 */
		/* 82173ECCh case    6:*/		regs.R3 = regs.R30;
		/* 82173ECCh case    6:*/		return 0x82173ED0;
		  /* 82173ED0h */ case    7:  		/* bl -560 */
		/* 82173ED0h case    7:*/		regs.LR = 0x82173ED4; return 0x82173CA0;
		/* 82173ED0h case    7:*/		return 0x82173ED4;
		  /* 82173ED4h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82173ED4h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82173ED4h case    8:*/		return 0x82173ED8;
		  /* 82173ED8h */ case    9:  		/* bc 12, CR0_EQ, -44 */
		/* 82173ED8h case    9:*/		if ( regs.CR[0].eq ) { return 0x82173EAC;  }
		/* 82173ED8h case    9:*/		return 0x82173EDC;
	}
	return 0x82173EDC;
} // Block from 82173EB4h-82173EDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82173EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173EDC);
		  /* 82173EDCh */ case    0:  		/* lwz R11, <#[R30 + 60]> */
		/* 82173EDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 82173EDCh case    0:*/		return 0x82173EE0;
		  /* 82173EE0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82173EE0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82173EE0h case    1:*/		return 0x82173EE4;
		  /* 82173EE4h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 82173EE4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82173F24;  }
		/* 82173EE4h case    2:*/		return 0x82173EE8;
		  /* 82173EE8h */ case    3:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82173EE8h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82173EE8h case    3:*/		return 0x82173EEC;
		  /* 82173EECh */ case    4:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 82173EECh case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 82173EECh case    4:*/		return 0x82173EF0;
		  /* 82173EF0h */ case    5:  		/* addi R11, R11, 36 */
		/* 82173EF0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82173EF0h case    5:*/		return 0x82173EF4;
		  /* 82173EF4h */ case    6:  		/* addi R10, R10, 36 */
		/* 82173EF4h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82173EF4h case    6:*/		return 0x82173EF8;
		  /* 82173EF8h */ case    7:  		/* addi R9, R11, 4 */
		/* 82173EF8h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82173EF8h case    7:*/		return 0x82173EFC;
		  /* 82173EFCh */ case    8:  		/* addi R8, R10, 4 */
		/* 82173EFCh case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82173EFCh case    8:*/		return 0x82173F00;
		  /* 82173F00h */ case    9:  		/* addi R7, R10, -36 */
		/* 82173F00h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 82173F00h case    9:*/		return 0x82173F04;
		  /* 82173F04h */ case   10:  		/* lwz R6, <#[R11 + 4]> */
		/* 82173F04h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82173F04h case   10:*/		return 0x82173F08;
		  /* 82173F08h */ case   11:  		/* stw R6, <#[R10 + 4]> */
		/* 82173F08h case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82173F08h case   11:*/		return 0x82173F0C;
		  /* 82173F0Ch */ case   12:  		/* lwz R6, <#[R11 + 4]> */
		/* 82173F0Ch case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82173F0Ch case   12:*/		return 0x82173F10;
		  /* 82173F10h */ case   13:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82173F10h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82173F10h case   13:*/		return 0x82173F14;
		  /* 82173F14h */ case   14:  		/* stw R8, <#[R6 + 36]> */
		/* 82173F14h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 82173F14h case   14:*/		return 0x82173F18;
		  /* 82173F18h */ case   15:  		/* stw R9, <#[R10]> */
		/* 82173F18h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82173F18h case   15:*/		return 0x82173F1C;
		  /* 82173F1Ch */ case   16:  		/* stw R7, <#[R11 + 4]> */
		/* 82173F1Ch case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82173F1Ch case   16:*/		return 0x82173F20;
		  /* 82173F20h */ case   17:  		/* b 60 */
		/* 82173F20h case   17:*/		return 0x82173F5C;
		/* 82173F20h case   17:*/		return 0x82173F24;
	}
	return 0x82173F24;
} // Block from 82173EDCh-82173F24h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82173F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173F24);
		  /* 82173F24h */ case    0:  		/* lwz R10, <#[R30]> */
		/* 82173F24h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82173F24h case    0:*/		return 0x82173F28;
		  /* 82173F28h */ case    1:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82173F28h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82173F28h case    1:*/		return 0x82173F2C;
		  /* 82173F2Ch */ case    2:  		/* addi R11, R11, 36 */
		/* 82173F2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82173F2Ch case    2:*/		return 0x82173F30;
		  /* 82173F30h */ case    3:  		/* addi R9, R10, 4 */
		/* 82173F30h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 82173F30h case    3:*/		return 0x82173F34;
		  /* 82173F34h */ case    4:  		/* addi R8, R11, 4 */
		/* 82173F34h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 82173F34h case    4:*/		return 0x82173F38;
		  /* 82173F38h */ case    5:  		/* lwz R7, <#[R10 + 4]> */
		/* 82173F38h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82173F38h case    5:*/		return 0x82173F3C;
		  /* 82173F3Ch */ case    6:  		/* ori R9, R9, 1 */
		/* 82173F3Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82173F3Ch case    6:*/		return 0x82173F40;
		  /* 82173F40h */ case    7:  		/* addi R6, R11, -36 */
		/* 82173F40h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 82173F40h case    7:*/		return 0x82173F44;
		  /* 82173F44h */ case    8:  		/* stw R7, <#[R11 + 4]> */
		/* 82173F44h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82173F44h case    8:*/		return 0x82173F48;
		  /* 82173F48h */ case    9:  		/* lwz R7, <#[R10 + 4]> */
		/* 82173F48h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82173F48h case    9:*/		return 0x82173F4C;
		  /* 82173F4Ch */ case   10:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82173F4Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82173F4Ch case   10:*/		return 0x82173F50;
		  /* 82173F50h */ case   11:  		/* stw R8, <#[R7 + 36]> */
		/* 82173F50h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 82173F50h case   11:*/		return 0x82173F54;
		  /* 82173F54h */ case   12:  		/* stw R9, <#[R11]> */
		/* 82173F54h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82173F54h case   12:*/		return 0x82173F58;
		  /* 82173F58h */ case   13:  		/* stw R6, <#[R10 + 4]> */
		/* 82173F58h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82173F58h case   13:*/		return 0x82173F5C;
	}
	return 0x82173F5C;
} // Block from 82173F24h-82173F5Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82173F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173F5C);
		  /* 82173F5Ch */ case    0:  		/* stw R31, <#[R30 + 60]> */
		/* 82173F5Ch case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000003C) );
		/* 82173F5Ch case    0:*/		return 0x82173F60;
		  /* 82173F60h */ case    1:  		/* mr R3, R30 */
		/* 82173F60h case    1:*/		regs.R3 = regs.R30;
		/* 82173F60h case    1:*/		return 0x82173F64;
		  /* 82173F64h */ case    2:  		/* lwz R11, <#[R31 + 16]> */
		/* 82173F64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82173F64h case    2:*/		return 0x82173F68;
		  /* 82173F68h */ case    3:  		/* oris R11, R11, 512 */
		/* 82173F68h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82173F68h case    3:*/		return 0x82173F6C;
		  /* 82173F6Ch */ case    4:  		/* stw R11, <#[R31 + 16]> */
		/* 82173F6Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82173F6Ch case    4:*/		return 0x82173F70;
		  /* 82173F70h */ case    5:  		/* bl -1056 */
		/* 82173F70h case    5:*/		regs.LR = 0x82173F74; return 0x82173B50;
		/* 82173F70h case    5:*/		return 0x82173F74;
		  /* 82173F74h */ case    6:  		/* or. R29, R3, R3 */
		/* 82173F74h case    6:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82173F74h case    6:*/		return 0x82173F78;
		  /* 82173F78h */ case    7:  		/* bc 4, CR0_EQ, 28 */
		/* 82173F78h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82173F94;  }
		/* 82173F78h case    7:*/		return 0x82173F7C;
		  /* 82173F7Ch */ case    8:  		/* lwz R31, <#[R31 + 32]> */
		/* 82173F7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 82173F7Ch case    8:*/		return 0x82173F80;
		  /* 82173F80h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 82173F80h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82173F80h case    9:*/		return 0x82173F84;
		  /* 82173F84h */ case   10:  		/* bc 4, CR6_EQ, -196 */
		/* 82173F84h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82173EC0;  }
		/* 82173F84h case   10:*/		return 0x82173F88;
	}
	return 0x82173F88;
} // Block from 82173F5Ch-82173F88h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82173F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173F88);
		  /* 82173F88h */ case    0:  		/* li R3, 1 */
		/* 82173F88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82173F88h case    0:*/		return 0x82173F8C;
	}
	return 0x82173F8C;
} // Block from 82173F88h-82173F8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82173F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173F8C);
		  /* 82173F8Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 82173F8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82173F8Ch case    0:*/		return 0x82173F90;
		  /* 82173F90h */ case    1:  		/* b -929004 */
		/* 82173F90h case    1:*/		return 0x820912A4;
		/* 82173F90h case    1:*/		return 0x82173F94;
	}
	return 0x82173F94;
} // Block from 82173F8Ch-82173F94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173F94);
		  /* 82173F94h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82173F94h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82173F94h case    0:*/		return 0x82173F98;
		  /* 82173F98h */ case    1:  		/* lwz R10, <#[R11 + 36]> */
		/* 82173F98h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82173F98h case    1:*/		return 0x82173F9C;
		  /* 82173F9Ch */ case    2:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82173F9Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82173F9Ch case    2:*/		return 0x82173FA0;
		  /* 82173FA0h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82173FA0h case    3:*/		if ( regs.CR[0].eq ) { return 0x82173FAC;  }
		/* 82173FA0h case    3:*/		return 0x82173FA4;
		  /* 82173FA4h */ case    4:  		/* li R10, 0 */
		/* 82173FA4h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82173FA4h case    4:*/		return 0x82173FA8;
		  /* 82173FA8h */ case    5:  		/* b 12 */
		/* 82173FA8h case    5:*/		return 0x82173FB4;
		/* 82173FA8h case    5:*/		return 0x82173FAC;
	}
	return 0x82173FAC;
} // Block from 82173F94h-82173FACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82173FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173FAC);
		  /* 82173FACh */ case    0:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82173FACh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82173FACh case    0:*/		return 0x82173FB0;
		  /* 82173FB0h */ case    1:  		/* addi R10, R10, -40 */
		/* 82173FB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFD8);
		/* 82173FB0h case    1:*/		return 0x82173FB4;
	}
	return 0x82173FB4;
} // Block from 82173FACh-82173FB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82173FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82173FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82173FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82173FB4);
		  /* 82173FB4h */ case    0:  		/* stw R10, <#[R30 + 60]> */
		/* 82173FB4h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x0000003C) );
		/* 82173FB4h case    0:*/		return 0x82173FB8;
		  /* 82173FB8h */ case    1:  		/* cmplw CR6, R27, R31 */
		/* 82173FB8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R31);
		/* 82173FB8h case    1:*/		return 0x82173FBC;
		  /* 82173FBCh */ case    2:  		/* lwz R9, <#[R11 + 40]> */
		/* 82173FBCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000028) );
		/* 82173FBCh case    2:*/		return 0x82173FC0;
		  /* 82173FC0h */ case    3:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 82173FC0h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 82173FC0h case    3:*/		return 0x82173FC4;
		  /* 82173FC4h */ case    4:  		/* lwz R10, <#[R11 + 40]> */
		/* 82173FC4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 82173FC4h case    4:*/		return 0x82173FC8;
		  /* 82173FC8h */ case    5:  		/* addic R8, R8, -1 */
		/* 82173FC8h case    5:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82173FC8h case    5:*/		return 0x82173FCC;
		  /* 82173FCCh */ case    6:  		/* lwz R7, <#[R11 + 36]> */
		/* 82173FCCh case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000024) );
		/* 82173FCCh case    6:*/		return 0x82173FD0;
		  /* 82173FD0h */ case    7:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82173FD0h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82173FD0h case    7:*/		return 0x82173FD4;
		  /* 82173FD4h */ case    8:  		/* stw R7, <#[R10 + 36]> */
		/* 82173FD4h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000024) );
		/* 82173FD4h case    8:*/		return 0x82173FD8;
		  /* 82173FD8h */ case    9:  		/* lwz R10, <#[R11 + 36]> */
		/* 82173FD8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82173FD8h case    9:*/		return 0x82173FDC;
		  /* 82173FDCh */ case   10:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82173FDCh case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82173FDCh case   10:*/		return 0x82173FE0;
		  /* 82173FE0h */ case   11:  		/* lwz R11, <#[R11 + 40]> */
		/* 82173FE0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82173FE0h case   11:*/		return 0x82173FE4;
		  /* 82173FE4h */ case   12:  		/* subfe R8, R8, R8 */
		/* 82173FE4h case   12:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 82173FE4h case   12:*/		return 0x82173FE8;
		  /* 82173FE8h */ case   13:  		/* stw R11, <#[R10]> */
		/* 82173FE8h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82173FE8h case   13:*/		return 0x82173FEC;
		  /* 82173FECh */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 82173FECh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82173FECh case   14:*/		return 0x82173FF0;
		  /* 82173FF0h */ case   15:  		/* rlwinm R11, R11, 0, 7, 5 */
		/* 82173FF0h case   15:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R11,regs.R11);
		/* 82173FF0h case   15:*/		return 0x82173FF4;
		  /* 82173FF4h */ case   16:  		/* and R4, R8, R9 */
		/* 82173FF4h case   16:*/		cpu::op::and<0>(regs,&regs.R4,regs.R8,regs.R9);
		/* 82173FF4h case   16:*/		return 0x82173FF8;
		  /* 82173FF8h */ case   17:  		/* stw R11, <#[R31 + 16]> */
		/* 82173FF8h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82173FF8h case   17:*/		return 0x82173FFC;
		  /* 82173FFCh */ case   18:  		/* bc 12, CR6_EQ, 32 */
		/* 82173FFCh case   18:*/		if ( regs.CR[6].eq ) { return 0x8217401C;  }
		/* 82173FFCh case   18:*/		return 0x82174000;
		  /* 82174000h */ case   19:  		/* addi R11, R29, -2 */
		/* 82174000h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFE);
		/* 82174000h case   19:*/		return 0x82174004;
		  /* 82174004h */ case   20:  		/* mr R3, R30 */
		/* 82174004h case   20:*/		regs.R3 = regs.R30;
		/* 82174004h case   20:*/		return 0x82174008;
		  /* 82174008h */ case   21:  		/* addic R10, R11, -1 */
		/* 82174008h case   21:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82174008h case   21:*/		return 0x8217400C;
		  /* 8217400Ch */ case   22:  		/* mr R31, R4 */
		/* 8217400Ch case   22:*/		regs.R31 = regs.R4;
		/* 8217400Ch case   22:*/		return 0x82174010;
		  /* 82174010h */ case   23:  		/* subfe R5, R10, R11 */
		/* 82174010h case   23:*/		cpu::op::subfe<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 82174010h case   23:*/		return 0x82174014;
		  /* 82174014h */ case   24:  		/* bl -4804 */
		/* 82174014h case   24:*/		regs.LR = 0x82174018; return 0x82172D50;
		/* 82174014h case   24:*/		return 0x82174018;
		  /* 82174018h */ case   25:  		/* b -132 */
		/* 82174018h case   25:*/		return 0x82173F94;
		/* 82174018h case   25:*/		return 0x8217401C;
	}
	return 0x8217401C;
} // Block from 82173FB4h-8217401Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8217401Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217401C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217401C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217401C);
		  /* 8217401Ch */ case    0:  		/* cmpwi CR6, R29, 2 */
		/* 8217401Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000002);
		/* 8217401Ch case    0:*/		return 0x82174020;
		  /* 82174020h */ case    1:  		/* bc 4, CR6_EQ, -372 */
		/* 82174020h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82173EAC;  }
		/* 82174020h case    1:*/		return 0x82174024;
		  /* 82174024h */ case    2:  		/* mr R3, R30 */
		/* 82174024h case    2:*/		regs.R3 = regs.R30;
		/* 82174024h case    2:*/		return 0x82174028;
		  /* 82174028h */ case    3:  		/* lwz R4, <#[R27 + 28]> */
		/* 82174028h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x0000001C) );
		/* 82174028h case    3:*/		return 0x8217402C;
		  /* 8217402Ch */ case    4:  		/* lwz R5, <#[R30 + 60]> */
		/* 8217402Ch case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000003C) );
		/* 8217402Ch case    4:*/		return 0x82174030;
		  /* 82174030h */ case    5:  		/* bl -1448 */
		/* 82174030h case    5:*/		regs.LR = 0x82174034; return 0x82173A88;
		/* 82174030h case    5:*/		return 0x82174034;
		  /* 82174034h */ case    6:  		/* lwz R11, <#[R30 + 60]> */
		/* 82174034h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 82174034h case    6:*/		return 0x82174038;
		  /* 82174038h */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 82174038h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82174038h case    7:*/		return 0x8217403C;
		  /* 8217403Ch */ case    8:  		/* bc 4, CR6_EQ, -400 */
		/* 8217403Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82173EAC;  }
		/* 8217403Ch case    8:*/		return 0x82174040;
		  /* 82174040h */ case    9:  		/* li R11, 0 */
		/* 82174040h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82174040h case    9:*/		return 0x82174044;
		  /* 82174044h */ case   10:  		/* stb R11, <#[R30 + 72]> */
		/* 82174044h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 82174044h case   10:*/		return 0x82174048;
		  /* 82174048h */ case   11:  		/* b -412 */
		/* 82174048h case   11:*/		return 0x82173EAC;
		/* 82174048h case   11:*/		return 0x8217404C;
		  /* 8217404Ch */ case   12:  		/* nop */
		/* 8217404Ch case   12:*/		cpu::op::nop();
		/* 8217404Ch case   12:*/		return 0x82174050;
	}
	return 0x82174050;
} // Block from 8217401Ch-82174050h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82174050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174050);
		  /* 82174050h */ case    0:  		/* mfspr R12, LR */
		/* 82174050h case    0:*/		regs.R12 = regs.LR;
		/* 82174050h case    0:*/		return 0x82174054;
		  /* 82174054h */ case    1:  		/* bl -929284 */
		/* 82174054h case    1:*/		regs.LR = 0x82174058; return 0x82091250;
		/* 82174054h case    1:*/		return 0x82174058;
		  /* 82174058h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82174058h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82174058h case    2:*/		return 0x8217405C;
		  /* 8217405Ch */ case    3:  		/* lwz R11, <#[R3 + 60]> */
		/* 8217405Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 8217405Ch case    3:*/		return 0x82174060;
		  /* 82174060h */ case    4:  		/* mr R29, R3 */
		/* 82174060h case    4:*/		regs.R29 = regs.R3;
		/* 82174060h case    4:*/		return 0x82174064;
		  /* 82174064h */ case    5:  		/* lwz R27, <#[R4 + 16]> */
		/* 82174064h case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R4 + 0x00000010) );
		/* 82174064h case    5:*/		return 0x82174068;
		  /* 82174068h */ case    6:  		/* mr R26, R4 */
		/* 82174068h case    6:*/		regs.R26 = regs.R4;
		/* 82174068h case    6:*/		return 0x8217406C;
		  /* 8217406Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8217406Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217406Ch case    7:*/		return 0x82174070;
		  /* 82174070h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82174070h case    8:*/		if ( regs.CR[6].eq ) { return 0x82174080;  }
		/* 82174070h case    8:*/		return 0x82174074;
		  /* 82174074h */ case    9:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174074h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174074h case    9:*/		return 0x82174078;
		  /* 82174078h */ case   10:  		/* lwz R11, <#[R11 + 40]> */
		/* 82174078h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82174078h case   10:*/		return 0x8217407C;
		  /* 8217407Ch */ case   11:  		/* b 12 */
		/* 8217407Ch case   11:*/		return 0x82174088;
		/* 8217407Ch case   11:*/		return 0x82174080;
	}
	return 0x82174080;
} // Block from 82174050h-82174080h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82174080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174080);
		  /* 82174080h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 82174080h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82174080h case    0:*/		return 0x82174084;
		  /* 82174084h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82174084h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82174084h case    1:*/		return 0x82174088;
	}
	return 0x82174088;
} // Block from 82174080h-82174088h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174088);
		  /* 82174088h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82174088h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82174088h case    0:*/		return 0x8217408C;
		  /* 8217408Ch */ case    1:  		/* addic R10, R10, -1 */
		/* 8217408Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8217408Ch case    1:*/		return 0x82174090;
		  /* 82174090h */ case    2:  		/* subfe R10, R10, R10 */
		/* 82174090h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82174090h case    2:*/		return 0x82174094;
		  /* 82174094h */ case    3:  		/* and R31, R10, R11 */
		/* 82174094h case    3:*/		cpu::op::and<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 82174094h case    3:*/		return 0x82174098;
		  /* 82174098h */ case    4:  		/* cmplw CR6, R31, R27 */
		/* 82174098h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R27);
		/* 82174098h case    4:*/		return 0x8217409C;
		  /* 8217409Ch */ case    5:  		/* bc 12, CR6_EQ, 116 */
		/* 8217409Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82174110;  }
		/* 8217409Ch case    5:*/		return 0x821740A0;
		  /* 821740A0h */ case    6:  		/* rlwinm R30, R31, 0, 0, 30 */
		/* 821740A0h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R30,regs.R31);
		/* 821740A0h case    6:*/		return 0x821740A4;
		  /* 821740A4h */ case    7:  		/* li R5, 1 */
		/* 821740A4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821740A4h case    7:*/		return 0x821740A8;
		  /* 821740A8h */ case    8:  		/* mr R4, R31 */
		/* 821740A8h case    8:*/		regs.R4 = regs.R31;
		/* 821740A8h case    8:*/		return 0x821740AC;
		  /* 821740ACh */ case    9:  		/* mr R3, R29 */
		/* 821740ACh case    9:*/		regs.R3 = regs.R29;
		/* 821740ACh case    9:*/		return 0x821740B0;
		  /* 821740B0h */ case   10:  		/* lwz R11, <#[R30 + 40]> */
		/* 821740B0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 821740B0h case   10:*/		return 0x821740B4;
		  /* 821740B4h */ case   11:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821740B4h case   11:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821740B4h case   11:*/		return 0x821740B8;
		  /* 821740B8h */ case   12:  		/* addic R10, R10, -1 */
		/* 821740B8h case   12:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821740B8h case   12:*/		return 0x821740BC;
		  /* 821740BCh */ case   13:  		/* subfe R10, R10, R10 */
		/* 821740BCh case   13:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821740BCh case   13:*/		return 0x821740C0;
		  /* 821740C0h */ case   14:  		/* and R28, R10, R11 */
		/* 821740C0h case   14:*/		cpu::op::and<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 821740C0h case   14:*/		return 0x821740C4;
		  /* 821740C4h */ case   15:  		/* bl -4980 */
		/* 821740C4h case   15:*/		regs.LR = 0x821740C8; return 0x82172D50;
		/* 821740C4h case   15:*/		return 0x821740C8;
		  /* 821740C8h */ case   16:  		/* lwz R11, <#[R31 + 8]> */
		/* 821740C8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821740C8h case   16:*/		return 0x821740CC;
		  /* 821740CCh */ case   17:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821740CCh case   17:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821740CCh case   17:*/		return 0x821740D0;
		  /* 821740D0h */ case   18:  		/* bc 12, CR0_EQ, 52 */
		/* 821740D0h case   18:*/		if ( regs.CR[0].eq ) { return 0x82174104;  }
		/* 821740D0h case   18:*/		return 0x821740D4;
		  /* 821740D4h */ case   19:  		/* lwz R10, <#[R30 + 40]> */
		/* 821740D4h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 821740D4h case   19:*/		return 0x821740D8;
		  /* 821740D8h */ case   20:  		/* addi R11, R30, 36 */
		/* 821740D8h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x24);
		/* 821740D8h case   20:*/		return 0x821740DC;
		  /* 821740DCh */ case   21:  		/* lwz R11, <#[R30 + 36]> */
		/* 821740DCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 821740DCh case   21:*/		return 0x821740E0;
		  /* 821740E0h */ case   22:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821740E0h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821740E0h case   22:*/		return 0x821740E4;
		  /* 821740E4h */ case   23:  		/* stw R11, <#[R10 + 36]> */
		/* 821740E4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000024) );
		/* 821740E4h case   23:*/		return 0x821740E8;
		  /* 821740E8h */ case   24:  		/* lwz R11, <#[R30 + 40]> */
		/* 821740E8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 821740E8h case   24:*/		return 0x821740EC;
		  /* 821740ECh */ case   25:  		/* lwz R10, <#[R30 + 36]> */
		/* 821740ECh case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000024) );
		/* 821740ECh case   25:*/		return 0x821740F0;
		  /* 821740F0h */ case   26:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821740F0h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821740F0h case   26:*/		return 0x821740F4;
		  /* 821740F4h */ case   27:  		/* stw R11, <#[R10]> */
		/* 821740F4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821740F4h case   27:*/		return 0x821740F8;
		  /* 821740F8h */ case   28:  		/* lwz R11, <#[R31 + 16]> */
		/* 821740F8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821740F8h case   28:*/		return 0x821740FC;
		  /* 821740FCh */ case   29:  		/* rlwinm R11, R11, 0, 7, 5 */
		/* 821740FCh case   29:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R11,regs.R11);
		/* 821740FCh case   29:*/		return 0x82174100;
		  /* 82174100h */ case   30:  		/* stw R11, <#[R31 + 16]> */
		/* 82174100h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82174100h case   30:*/		return 0x82174104;
	}
	return 0x82174104;
} // Block from 82174088h-82174104h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82174104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174104);
		  /* 82174104h */ case    0:  		/* mr R31, R28 */
		/* 82174104h case    0:*/		regs.R31 = regs.R28;
		/* 82174104h case    0:*/		return 0x82174108;
		  /* 82174108h */ case    1:  		/* cmplw CR6, R28, R27 */
		/* 82174108h case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 82174108h case    1:*/		return 0x8217410C;
		  /* 8217410Ch */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 8217410Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x821740A0;  }
		/* 8217410Ch case    2:*/		return 0x82174110;
	}
	return 0x82174110;
} // Block from 82174104h-82174110h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174110);
		  /* 82174110h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 82174110h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82174110h case    0:*/		return 0x82174114;
		  /* 82174114h */ case    1:  		/* lwz R10, <#[R29 + 56]> */
		/* 82174114h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000038) );
		/* 82174114h case    1:*/		return 0x82174118;
		  /* 82174118h */ case    2:  		/* stw R11, <#[R29 + 60]> */
		/* 82174118h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000003C) );
		/* 82174118h case    2:*/		return 0x8217411C;
		  /* 8217411Ch */ case    3:  		/* lwz R11, <#[R26 + 20]> */
		/* 8217411Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8217411Ch case    3:*/		return 0x82174120;
		  /* 82174120h */ case    4:  		/* stw R11, <#[R10 + 16]> */
		/* 82174120h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82174120h case    4:*/		return 0x82174124;
		  /* 82174124h */ case    5:  		/* lbz R11, <#[R29 + 72]> */
		/* 82174124h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000048) );
		/* 82174124h case    5:*/		return 0x82174128;
		  /* 82174128h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82174128h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82174128h case    6:*/		return 0x8217412C;
		  /* 8217412Ch */ case    7:  		/* bc 12, CR0_EQ, 52 */
		/* 8217412Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82174160;  }
		/* 8217412Ch case    7:*/		return 0x82174130;
		  /* 82174130h */ case    8:  		/* lbz R11, <#[R29 + 73]> */
		/* 82174130h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000049) );
		/* 82174130h case    8:*/		return 0x82174134;
		  /* 82174134h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82174134h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82174134h case    9:*/		return 0x82174138;
		  /* 82174138h */ case   10:  		/* bc 4, CR0_EQ, 40 */
		/* 82174138h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82174160;  }
		/* 82174138h case   10:*/		return 0x8217413C;
		  /* 8217413Ch */ case   11:  		/* mr R3, R29 */
		/* 8217413Ch case   11:*/		regs.R3 = regs.R29;
		/* 8217413Ch case   11:*/		return 0x82174140;
		  /* 82174140h */ case   12:  		/* lwz R5, <#[R29 + 60]> */
		/* 82174140h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000003C) );
		/* 82174140h case   12:*/		return 0x82174144;
		  /* 82174144h */ case   13:  		/* lwz R4, <#[R29 + 68]> */
		/* 82174144h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000044) );
		/* 82174144h case   13:*/		return 0x82174148;
		  /* 82174148h */ case   14:  		/* bl -1728 */
		/* 82174148h case   14:*/		regs.LR = 0x8217414C; return 0x82173A88;
		/* 82174148h case   14:*/		return 0x8217414C;
		  /* 8217414Ch */ case   15:  		/* lwz R11, <#[R29 + 60]> */
		/* 8217414Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000003C) );
		/* 8217414Ch case   15:*/		return 0x82174150;
		  /* 82174150h */ case   16:  		/* cmplw CR6, R3, R11 */
		/* 82174150h case   16:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82174150h case   16:*/		return 0x82174154;
		  /* 82174154h */ case   17:  		/* bc 4, CR6_EQ, 12 */
		/* 82174154h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82174160;  }
		/* 82174154h case   17:*/		return 0x82174158;
		  /* 82174158h */ case   18:  		/* li R11, 0 */
		/* 82174158h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82174158h case   18:*/		return 0x8217415C;
		  /* 8217415Ch */ case   19:  		/* stb R11, <#[R29 + 72]> */
		/* 8217415Ch case   19:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000048) );
		/* 8217415Ch case   19:*/		return 0x82174160;
	}
	return 0x82174160;
} // Block from 82174110h-82174160h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82174160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174160);
		  /* 82174160h */ case    0:  		/* addi R1, R1, 144 */
		/* 82174160h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82174160h case    0:*/		return 0x82174164;
		  /* 82174164h */ case    1:  		/* b -929476 */
		/* 82174164h case    1:*/		return 0x820912A0;
		/* 82174164h case    1:*/		return 0x82174168;
	}
	return 0x82174168;
} // Block from 82174160h-82174168h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174168);
		  /* 82174168h */ case    0:  		/* mfspr R12, LR */
		/* 82174168h case    0:*/		regs.R12 = regs.LR;
		/* 82174168h case    0:*/		return 0x8217416C;
		  /* 8217416Ch */ case    1:  		/* bl -929560 */
		/* 8217416Ch case    1:*/		regs.LR = 0x82174170; return 0x82091254;
		/* 8217416Ch case    1:*/		return 0x82174170;
		  /* 82174170h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82174170h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82174170h case    2:*/		return 0x82174174;
		  /* 82174174h */ case    3:  		/* lwz R28, <#[R3 + 60]> */
		/* 82174174h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x0000003C) );
		/* 82174174h case    3:*/		return 0x82174178;
		  /* 82174178h */ case    4:  		/* mr R31, R3 */
		/* 82174178h case    4:*/		regs.R31 = regs.R3;
		/* 82174178h case    4:*/		return 0x8217417C;
		  /* 8217417Ch */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 8217417Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8217417Ch case    5:*/		return 0x82174180;
		  /* 82174180h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 82174180h case    6:*/		if ( regs.CR[6].eq ) { return 0x821741A0;  }
		/* 82174180h case    6:*/		return 0x82174184;
		  /* 82174184h */ case    7:  		/* mr R3, R31 */
		/* 82174184h case    7:*/		regs.R3 = regs.R31;
		/* 82174184h case    7:*/		return 0x82174188;
		  /* 82174188h */ case    8:  		/* bl -1592 */
		/* 82174188h case    8:*/		regs.LR = 0x8217418C; return 0x82173B50;
		/* 82174188h case    8:*/		return 0x8217418C;
		  /* 8217418Ch */ case    9:  		/* lwz R11, <#[R31 + 60]> */
		/* 8217418Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 8217418Ch case    9:*/		return 0x82174190;
		  /* 82174190h */ case   10:  		/* or. R29, R3, R3 */
		/* 82174190h case   10:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82174190h case   10:*/		return 0x82174194;
		  /* 82174194h */ case   11:  		/* bc 4, CR0_EQ, 24 */
		/* 82174194h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821741AC;  }
		/* 82174194h case   11:*/		return 0x82174198;
		  /* 82174198h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82174198h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82174198h case   12:*/		return 0x8217419C;
		  /* 8217419Ch */ case   13:  		/* bc 4, CR6_EQ, -24 */
		/* 8217419Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82174184;  }
		/* 8217419Ch case   13:*/		return 0x821741A0;
	}
	return 0x821741A0;
} // Block from 82174168h-821741A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821741A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821741A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821741A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821741A0);
		  /* 821741A0h */ case    0:  		/* li R3, 1 */
		/* 821741A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821741A0h case    0:*/		return 0x821741A4;
		  /* 821741A4h */ case    1:  		/* addi R1, R1, 128 */
		/* 821741A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821741A4h case    1:*/		return 0x821741A8;
		  /* 821741A8h */ case    2:  		/* b -929540 */
		/* 821741A8h case    2:*/		return 0x820912A4;
		/* 821741A8h case    2:*/		return 0x821741AC;
	}
	return 0x821741AC;
} // Block from 821741A0h-821741ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821741ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821741AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821741AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821741AC);
		  /* 821741ACh */ case    0:  		/* cmplw CR6, R11, R28 */
		/* 821741ACh case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 821741ACh case    0:*/		return 0x821741B0;
		  /* 821741B0h */ case    1:  		/* bc 12, CR6_EQ, 72 */
		/* 821741B0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821741F8;  }
		/* 821741B0h case    1:*/		return 0x821741B4;
		  /* 821741B4h */ case    2:  		/* addi R11, R29, -2 */
		/* 821741B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFE);
		/* 821741B4h case    2:*/		return 0x821741B8;
		  /* 821741B8h */ case    3:  		/* addic R10, R11, -1 */
		/* 821741B8h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 821741B8h case    3:*/		return 0x821741BC;
		  /* 821741BCh */ case    4:  		/* subfe R30, R10, R11 */
		/* 821741BCh case    4:*/		cpu::op::subfe<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 821741BCh case    4:*/		return 0x821741C0;
		  /* 821741C0h */ case    5:  		/* lwz R4, <#[R31 + 60]> */
		/* 821741C0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000003C) );
		/* 821741C0h case    5:*/		return 0x821741C4;
		  /* 821741C4h */ case    6:  		/* mr R5, R30 */
		/* 821741C4h case    6:*/		regs.R5 = regs.R30;
		/* 821741C4h case    6:*/		return 0x821741C8;
		  /* 821741C8h */ case    7:  		/* mr R3, R31 */
		/* 821741C8h case    7:*/		regs.R3 = regs.R31;
		/* 821741C8h case    7:*/		return 0x821741CC;
		  /* 821741CCh */ case    8:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821741CCh case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821741CCh case    8:*/		return 0x821741D0;
		  /* 821741D0h */ case    9:  		/* lwz R11, <#[R11 + 40]> */
		/* 821741D0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821741D0h case    9:*/		return 0x821741D4;
		  /* 821741D4h */ case   10:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821741D4h case   10:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821741D4h case   10:*/		return 0x821741D8;
		  /* 821741D8h */ case   11:  		/* addic R10, R10, -1 */
		/* 821741D8h case   11:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821741D8h case   11:*/		return 0x821741DC;
		  /* 821741DCh */ case   12:  		/* subfe R10, R10, R10 */
		/* 821741DCh case   12:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821741DCh case   12:*/		return 0x821741E0;
		  /* 821741E0h */ case   13:  		/* and R27, R10, R11 */
		/* 821741E0h case   13:*/		cpu::op::and<0>(regs,&regs.R27,regs.R10,regs.R11);
		/* 821741E0h case   13:*/		return 0x821741E4;
		  /* 821741E4h */ case   14:  		/* bl -5268 */
		/* 821741E4h case   14:*/		regs.LR = 0x821741E8; return 0x82172D50;
		/* 821741E4h case   14:*/		return 0x821741E8;
		  /* 821741E8h */ case   15:  		/* rlwinm R11, R27, 0, 0, 31 */
		/* 821741E8h case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R27);
		/* 821741E8h case   15:*/		return 0x821741EC;
		  /* 821741ECh */ case   16:  		/* stw R27, <#[R31 + 60]> */
		/* 821741ECh case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000003C) );
		/* 821741ECh case   16:*/		return 0x821741F0;
		  /* 821741F0h */ case   17:  		/* cmplw CR6, R11, R28 */
		/* 821741F0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 821741F0h case   17:*/		return 0x821741F4;
		  /* 821741F4h */ case   18:  		/* bc 4, CR6_EQ, -52 */
		/* 821741F4h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821741C0;  }
		/* 821741F4h case   18:*/		return 0x821741F8;
	}
	return 0x821741F8;
} // Block from 821741ACh-821741F8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821741F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821741F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821741F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821741F8);
		  /* 821741F8h */ case    0:  		/* cmpwi CR6, R29, 2 */
		/* 821741F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000002);
		/* 821741F8h case    0:*/		return 0x821741FC;
		  /* 821741FCh */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 821741FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82174224;  }
		/* 821741FCh case    1:*/		return 0x82174200;
		  /* 82174200h */ case    2:  		/* lwz R5, <#[R31 + 60]> */
		/* 82174200h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000003C) );
		/* 82174200h case    2:*/		return 0x82174204;
		  /* 82174204h */ case    3:  		/* mr R3, R31 */
		/* 82174204h case    3:*/		regs.R3 = regs.R31;
		/* 82174204h case    3:*/		return 0x82174208;
		  /* 82174208h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 82174208h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 82174208h case    4:*/		return 0x8217420C;
		  /* 8217420Ch */ case    5:  		/* bl -1924 */
		/* 8217420Ch case    5:*/		regs.LR = 0x82174210; return 0x82173A88;
		/* 8217420Ch case    5:*/		return 0x82174210;
		  /* 82174210h */ case    6:  		/* lwz R11, <#[R31 + 60]> */
		/* 82174210h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 82174210h case    6:*/		return 0x82174214;
		  /* 82174214h */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 82174214h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82174214h case    7:*/		return 0x82174218;
		  /* 82174218h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82174218h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82174224;  }
		/* 82174218h case    8:*/		return 0x8217421C;
		  /* 8217421Ch */ case    9:  		/* li R11, 0 */
		/* 8217421Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8217421Ch case    9:*/		return 0x82174220;
		  /* 82174220h */ case   10:  		/* stb R11, <#[R31 + 72]> */
		/* 82174220h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 82174220h case   10:*/		return 0x82174224;
	}
	return 0x82174224;
} // Block from 821741F8h-82174224h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82174224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174224);
		  /* 82174224h */ case    0:  		/* li R3, 0 */
		/* 82174224h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82174224h case    0:*/		return 0x82174228;
		  /* 82174228h */ case    1:  		/* b -132 */
		/* 82174228h case    1:*/		return 0x821741A4;
		/* 82174228h case    1:*/		return 0x8217422C;
		  /* 8217422Ch */ case    2:  		/* nop */
		/* 8217422Ch case    2:*/		cpu::op::nop();
		/* 8217422Ch case    2:*/		return 0x82174230;
	}
	return 0x82174230;
} // Block from 82174224h-82174230h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174230);
		  /* 82174230h */ case    0:  		/* mfspr R12, LR */
		/* 82174230h case    0:*/		regs.R12 = regs.LR;
		/* 82174230h case    0:*/		return 0x82174234;
		  /* 82174234h */ case    1:  		/* bl -929764 */
		/* 82174234h case    1:*/		regs.LR = 0x82174238; return 0x82091250;
		/* 82174234h case    1:*/		return 0x82174238;
		  /* 82174238h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82174238h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82174238h case    2:*/		return 0x8217423C;
		  /* 8217423Ch */ case    3:  		/* mr R30, R4 */
		/* 8217423Ch case    3:*/		regs.R30 = regs.R4;
		/* 8217423Ch case    3:*/		return 0x82174240;
		  /* 82174240h */ case    4:  		/* mr R28, R3 */
		/* 82174240h case    4:*/		regs.R28 = regs.R3;
		/* 82174240h case    4:*/		return 0x82174244;
		  /* 82174244h */ case    5:  		/* mr R4, R5 */
		/* 82174244h case    5:*/		regs.R4 = regs.R5;
		/* 82174244h case    5:*/		return 0x82174248;
		  /* 82174248h */ case    6:  		/* mr R3, R30 */
		/* 82174248h case    6:*/		regs.R3 = regs.R30;
		/* 82174248h case    6:*/		return 0x8217424C;
		  /* 8217424Ch */ case    7:  		/* mr R27, R5 */
		/* 8217424Ch case    7:*/		regs.R27 = regs.R5;
		/* 8217424Ch case    7:*/		return 0x82174250;
		  /* 82174250h */ case    8:  		/* bl -8736 */
		/* 82174250h case    8:*/		regs.LR = 0x82174254; return 0x82172030;
		/* 82174250h case    8:*/		return 0x82174254;
		  /* 82174254h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82174254h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82174254h case    9:*/		return 0x82174258;
		  /* 82174258h */ case   10:  		/* bc 4, CR0_EQ, 316 */
		/* 82174258h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82174394;  }
		/* 82174258h case   10:*/		return 0x8217425C;
		  /* 8217425Ch */ case   11:  		/* lwz R9, <#[R27 + 16]> */
		/* 8217425Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000010) );
		/* 8217425Ch case   11:*/		return 0x82174260;
		  /* 82174260h */ case   12:  		/* li R10, 0 */
		/* 82174260h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82174260h case   12:*/		return 0x82174264;
		  /* 82174264h */ case   13:  		/* lwz R8, <#[R27 + 20]> */
		/* 82174264h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000014) );
		/* 82174264h case   13:*/		return 0x82174268;
		  /* 82174268h */ case   14:  		/* lwz R11, <#[R30 + 4]> */
		/* 82174268h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82174268h case   14:*/		return 0x8217426C;
		  /* 8217426Ch */ case   15:  		/* rlwinm R9, R9, 12, 21, 24 */
		/* 8217426Ch case   15:*/		cpu::op::rlwinm<0,12,21,24>(regs,&regs.R9,regs.R9);
		/* 8217426Ch case   15:*/		return 0x82174270;
		  /* 82174270h */ case   16:  		/* rlwinm R8, R8, 7, 25, 31 */
		/* 82174270h case   16:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R8,regs.R8);
		/* 82174270h case   16:*/		return 0x82174274;
		  /* 82174274h */ case   17:  		/* lwz R29, <#[R28 + 728]> */
		/* 82174274h case   17:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x000002D8) );
		/* 82174274h case   17:*/		return 0x82174278;
		  /* 82174278h */ case   18:  		/* rlwinm R7, R11, 0, 31, 31 */
		/* 82174278h case   18:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R7,regs.R11);
		/* 82174278h case   18:*/		return 0x8217427C;
		  /* 8217427Ch */ case   19:  		/* stw R10, <#[R1 + 88]> */
		/* 8217427Ch case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8217427Ch case   19:*/		return 0x82174280;
		  /* 82174280h */ case   20:  		/* or R9, R9, R8 */
		/* 82174280h case   20:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82174280h case   20:*/		return 0x82174284;
		  /* 82174284h */ case   21:  		/* stw R30, <#[R1 + 80]> */
		/* 82174284h case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82174284h case   21:*/		return 0x82174288;
		  /* 82174288h */ case   22:  		/* addic R7, R7, -1 */
		/* 82174288h case   22:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 82174288h case   22:*/		return 0x8217428C;
		  /* 8217428Ch */ case   23:  		/* rlwinm R31, R9, 2, 0, 29 */
		/* 8217428Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R9);
		/* 8217428Ch case   23:*/		return 0x82174290;
		  /* 82174290h */ case   24:  		/* subfe R8, R7, R7 */
		/* 82174290h case   24:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R7,regs.R7);
		/* 82174290h case   24:*/		return 0x82174294;
		  /* 82174294h */ case   25:  		/* add R9, R29, R31 */
		/* 82174294h case   25:*/		cpu::op::add<0>(regs,&regs.R9,regs.R29,regs.R31);
		/* 82174294h case   25:*/		return 0x82174298;
		  /* 82174298h */ case   26:  		/* and R11, R8, R11 */
		/* 82174298h case   26:*/		cpu::op::and<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82174298h case   26:*/		return 0x8217429C;
		  /* 8217429Ch */ case   27:  		/* stw R11, <#[R1 + 84]> */
		/* 8217429Ch case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8217429Ch case   27:*/		return 0x821742A0;
		  /* 821742A0h */ case   28:  		/* lwz R26, <#[R9 - 4]> */
		/* 821742A0h case   28:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 821742A0h case   28:*/		return 0x821742A4;
		  /* 821742A4h */ case   29:  		/* cmplwi CR6, R11, 0 */
		/* 821742A4h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821742A4h case   29:*/		return 0x821742A8;
		  /* 821742A8h */ case   30:  		/* bc 12, CR6_EQ, 20 */
		/* 821742A8h case   30:*/		if ( regs.CR[6].eq ) { return 0x821742BC;  }
		/* 821742A8h case   30:*/		return 0x821742AC;
		  /* 821742ACh */ case   31:  		/* lwz R9, <#[R11 + 8]> */
		/* 821742ACh case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821742ACh case   31:*/		return 0x821742B0;
		  /* 821742B0h */ case   32:  		/* cmplw CR6, R10, R9 */
		/* 821742B0h case   32:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821742B0h case   32:*/		return 0x821742B4;
		  /* 821742B4h */ case   33:  		/* li R9, 0 */
		/* 821742B4h case   33:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821742B4h case   33:*/		return 0x821742B8;
		  /* 821742B8h */ case   34:  		/* bc 4, CR6_EQ, 8 */
		/* 821742B8h case   34:*/		if ( !regs.CR[6].eq ) { return 0x821742C0;  }
		/* 821742B8h case   34:*/		return 0x821742BC;
	}
	return 0x821742BC;
} // Block from 82174230h-821742BCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 821742BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821742BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821742BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821742BC);
		  /* 821742BCh */ case    0:  		/* li R9, 1 */
		/* 821742BCh case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821742BCh case    0:*/		return 0x821742C0;
	}
	return 0x821742C0;
} // Block from 821742BCh-821742C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821742C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821742C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821742C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821742C0);
		  /* 821742C0h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 821742C0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 821742C0h case    0:*/		return 0x821742C4;
		  /* 821742C4h */ case    1:  		/* bc 4, CR0_EQ, 124 */
		/* 821742C4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82174340;  }
		/* 821742C4h case    1:*/		return 0x821742C8;
		  /* 821742C8h */ case    2:  		/* addi R9, R10, 4 */
		/* 821742C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821742C8h case    2:*/		return 0x821742CC;
		  /* 821742CCh */ case    3:  		/* lwz R10, <#[R28 + 724]> */
		/* 821742CCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x000002D4) );
		/* 821742CCh case    3:*/		return 0x821742D0;
		  /* 821742D0h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821742D0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821742D0h case    4:*/		return 0x821742D4;
		  /* 821742D4h */ case    5:  		/* add R8, R10, R31 */
		/* 821742D4h case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R31);
		/* 821742D4h case    5:*/		return 0x821742D8;
		  /* 821742D8h */ case    6:  		/* lwzx R11, <#[R9 + R11]> */
		/* 821742D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821742D8h case    6:*/		return 0x821742DC;
		  /* 821742DCh */ case    7:  		/* lwz R9, <#[R8 - 4]> */
		/* 821742DCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0xFFFFFFFC) );
		/* 821742DCh case    7:*/		return 0x821742E0;
		  /* 821742E0h */ case    8:  		/* lwz R8, <#[R11 + 16]> */
		/* 821742E0h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 821742E0h case    8:*/		return 0x821742E4;
		  /* 821742E4h */ case    9:  		/* lwz R11, <#[R11 + 20]> */
		/* 821742E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821742E4h case    9:*/		return 0x821742E8;
		  /* 821742E8h */ case   10:  		/* rlwinm R8, R8, 12, 21, 24 */
		/* 821742E8h case   10:*/		cpu::op::rlwinm<0,12,21,24>(regs,&regs.R8,regs.R8);
		/* 821742E8h case   10:*/		return 0x821742EC;
		  /* 821742ECh */ case   11:  		/* rlwinm R11, R11, 7, 25, 31 */
		/* 821742ECh case   11:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R11,regs.R11);
		/* 821742ECh case   11:*/		return 0x821742F0;
		  /* 821742F0h */ case   12:  		/* or R11, R8, R11 */
		/* 821742F0h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 821742F0h case   12:*/		return 0x821742F4;
		  /* 821742F4h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821742F4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821742F4h case   13:*/		return 0x821742F8;
		  /* 821742F8h */ case   14:  		/* add R10, R10, R11 */
		/* 821742F8h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821742F8h case   14:*/		return 0x821742FC;
		  /* 821742FCh */ case   15:  		/* lwz R10, <#[R10 - 4]> */
		/* 821742FCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 821742FCh case   15:*/		return 0x82174300;
		  /* 82174300h */ case   16:  		/* cmplw CR6, R9, R10 */
		/* 82174300h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82174300h case   16:*/		return 0x82174304;
		  /* 82174304h */ case   17:  		/* bc 12, CR6_LT, 44 */
		/* 82174304h case   17:*/		if ( regs.CR[6].lt ) { return 0x82174330;  }
		/* 82174304h case   17:*/		return 0x82174308;
		  /* 82174308h */ case   18:  		/* add R11, R11, R29 */
		/* 82174308h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82174308h case   18:*/		return 0x8217430C;
		  /* 8217430Ch */ case   19:  		/* lwz R11, <#[R11 - 4]> */
		/* 8217430Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8217430Ch case   19:*/		return 0x82174310;
		  /* 82174310h */ case   20:  		/* cmpw CR6, R26, R11 */
		/* 82174310h case   20:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R11);
		/* 82174310h case   20:*/		return 0x82174314;
		  /* 82174314h */ case   21:  		/* bc 12, CR6_GT, 8 */
		/* 82174314h case   21:*/		if ( regs.CR[6].gt ) { return 0x8217431C;  }
		/* 82174314h case   21:*/		return 0x82174318;
		  /* 82174318h */ case   22:  		/* bc 12, CR6_LT, 24 */
		/* 82174318h case   22:*/		if ( regs.CR[6].lt ) { return 0x82174330;  }
		/* 82174318h case   22:*/		return 0x8217431C;
	}
	return 0x8217431C;
} // Block from 821742C0h-8217431Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8217431Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217431C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217431C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217431C);
		  /* 8217431Ch */ case    0:  		/* addi R3, R1, 80 */
		/* 8217431Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8217431Ch case    0:*/		return 0x82174320;
	}
	return 0x82174320;
} // Block from 8217431Ch-82174320h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174320h
// Function '?ReassignLocalRegisters@RegOptSimulator@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174320);
		  /* 82174320h */ case    0:  		/* bl 314088 */
		/* 82174320h case    0:*/		regs.LR = 0x82174324; return 0x821C0E08;
		/* 82174320h case    0:*/		return 0x82174324;
		  /* 82174324h */ case    1:  		/* lwz R10, <#[R1 + 88]> */
		/* 82174324h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82174324h case    1:*/		return 0x82174328;
		  /* 82174328h */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 82174328h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82174328h case    2:*/		return 0x8217432C;
		  /* 8217432Ch */ case    3:  		/* b -136 */
		/* 8217432Ch case    3:*/		return 0x821742A4;
		/* 8217432Ch case    3:*/		return 0x82174330;
	}
	return 0x82174330;
} // Block from 82174320h-82174330h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82174330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174330);
		  /* 82174330h */ case    0:  		/* mr R4, R27 */
		/* 82174330h case    0:*/		regs.R4 = regs.R27;
		/* 82174330h case    0:*/		return 0x82174334;
		  /* 82174334h */ case    1:  		/* addi R3, R1, 80 */
		/* 82174334h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82174334h case    1:*/		return 0x82174338;
		  /* 82174338h */ case    2:  		/* bl -8632 */
		/* 82174338h case    2:*/		regs.LR = 0x8217433C; return 0x82172180;
		/* 82174338h case    2:*/		return 0x8217433C;
		  /* 8217433Ch */ case    3:  		/* b 88 */
		/* 8217433Ch case    3:*/		return 0x82174394;
		/* 8217433Ch case    3:*/		return 0x82174340;
	}
	return 0x82174340;
} // Block from 82174330h-82174340h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82174340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174340);
		  /* 82174340h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82174340h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82174340h case    0:*/		return 0x82174344;
		  /* 82174344h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82174344h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82174344h case    1:*/		return 0x82174348;
		  /* 82174348h */ case    2:  		/* bc 4, CR0_EQ, 40 */
		/* 82174348h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82174370;  }
		/* 82174348h case    2:*/		return 0x8217434C;
		  /* 8217434Ch */ case    3:  		/* lwz R11, <#[R30]> */
		/* 8217434Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8217434Ch case    3:*/		return 0x82174350;
		  /* 82174350h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174350h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174350h case    4:*/		return 0x82174354;
		  /* 82174354h */ case    5:  		/* addic. R3, R11, -4 */
		/* 82174354h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82174354h case    5:*/		return 0x82174358;
		  /* 82174358h */ case    6:  		/* bc 12, CR0_EQ, 24 */
		/* 82174358h case    6:*/		if ( regs.CR[0].eq ) { return 0x82174370;  }
		/* 82174358h case    6:*/		return 0x8217435C;
		  /* 8217435Ch */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 8217435Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8217435Ch case    7:*/		return 0x82174360;
		  /* 82174360h */ case    8:  		/* lwz R10, <#[R3 + 12]> */
		/* 82174360h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82174360h case    8:*/		return 0x82174364;
		  /* 82174364h */ case    9:  		/* addi R11, R11, 1 */
		/* 82174364h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82174364h case    9:*/		return 0x82174368;
		  /* 82174368h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 82174368h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82174368h case   10:*/		return 0x8217436C;
		  /* 8217436Ch */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 8217436Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x8217437C;  }
		/* 8217436Ch case   11:*/		return 0x82174370;
	}
	return 0x82174370;
} // Block from 82174340h-82174370h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82174370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174370);
		  /* 82174370h */ case    0:  		/* li R4, 1 */
		/* 82174370h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82174370h case    0:*/		return 0x82174374;
		  /* 82174374h */ case    1:  		/* mr R3, R30 */
		/* 82174374h case    1:*/		regs.R3 = regs.R30;
		/* 82174374h case    1:*/		return 0x82174378;
		  /* 82174378h */ case    2:  		/* bl 101712 */
		/* 82174378h case    2:*/		regs.LR = 0x8217437C; return 0x8218D0C8;
		/* 82174378h case    2:*/		return 0x8217437C;
	}
	return 0x8217437C;
} // Block from 82174370h-8217437Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8217437Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217437C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217437C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217437C);
		  /* 8217437Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8217437Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8217437Ch case    0:*/		return 0x82174380;
		  /* 82174380h */ case    1:  		/* addi R10, R11, 4 */
		/* 82174380h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82174380h case    1:*/		return 0x82174384;
		  /* 82174384h */ case    2:  		/* addi R9, R11, 1 */
		/* 82174384h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82174384h case    2:*/		return 0x82174388;
		  /* 82174388h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82174388h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82174388h case    3:*/		return 0x8217438C;
		  /* 8217438Ch */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 8217438Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8217438Ch case    4:*/		return 0x82174390;
		  /* 82174390h */ case    5:  		/* stwx R27, <#[R11 + R3]> */
		/* 82174390h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82174390h case    5:*/		return 0x82174394;
	}
	return 0x82174394;
} // Block from 8217437Ch-82174394h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82174394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174394);
		  /* 82174394h */ case    0:  		/* addi R1, R1, 160 */
		/* 82174394h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82174394h case    0:*/		return 0x82174398;
		  /* 82174398h */ case    1:  		/* b -930040 */
		/* 82174398h case    1:*/		return 0x820912A0;
		/* 82174398h case    1:*/		return 0x8217439C;
		  /* 8217439Ch */ case    2:  		/* nop */
		/* 8217439Ch case    2:*/		cpu::op::nop();
		/* 8217439Ch case    2:*/		return 0x821743A0;
	}
	return 0x821743A0;
} // Block from 82174394h-821743A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821743A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821743A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821743A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821743A0);
		  /* 821743A0h */ case    0:  		/* mfspr R12, LR */
		/* 821743A0h case    0:*/		regs.R12 = regs.LR;
		/* 821743A0h case    0:*/		return 0x821743A4;
		  /* 821743A4h */ case    1:  		/* bl -930180 */
		/* 821743A4h case    1:*/		regs.LR = 0x821743A8; return 0x82091220;
		/* 821743A4h case    1:*/		return 0x821743A8;
		  /* 821743A8h */ case    2:  		/* stwu R1, <#[R1 - 352]> */
		/* 821743A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEA0);
		/* 821743A8h case    2:*/		return 0x821743AC;
		  /* 821743ACh */ case    3:  		/* mr R17, R5 */
		/* 821743ACh case    3:*/		regs.R17 = regs.R5;
		/* 821743ACh case    3:*/		return 0x821743B0;
		  /* 821743B0h */ case    4:  		/* stw R4, <#[R1 + 380]> */
		/* 821743B0h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000017C) );
		/* 821743B0h case    4:*/		return 0x821743B4;
		  /* 821743B4h */ case    5:  		/* li R5, 0 */
		/* 821743B4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821743B4h case    5:*/		return 0x821743B8;
		  /* 821743B8h */ case    6:  		/* mr R18, R3 */
		/* 821743B8h case    6:*/		regs.R18 = regs.R3;
		/* 821743B8h case    6:*/		return 0x821743BC;
		  /* 821743BCh */ case    7:  		/* mr R20, R4 */
		/* 821743BCh case    7:*/		regs.R20 = regs.R4;
		/* 821743BCh case    7:*/		return 0x821743C0;
		  /* 821743C0h */ case    8:  		/* bl -10224 */
		/* 821743C0h case    8:*/		regs.LR = 0x821743C4; return 0x82171BD0;
		/* 821743C0h case    8:*/		return 0x821743C4;
		  /* 821743C4h */ case    9:  		/* mr R4, R20 */
		/* 821743C4h case    9:*/		regs.R4 = regs.R20;
		/* 821743C4h case    9:*/		return 0x821743C8;
		  /* 821743C8h */ case   10:  		/* li R5, 0 */
		/* 821743C8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821743C8h case   10:*/		return 0x821743CC;
		  /* 821743CCh */ case   11:  		/* mr R3, R18 */
		/* 821743CCh case   11:*/		regs.R3 = regs.R18;
		/* 821743CCh case   11:*/		return 0x821743D0;
		  /* 821743D0h */ case   12:  		/* bl -10088 */
		/* 821743D0h case   12:*/		regs.LR = 0x821743D4; return 0x82171C68;
		/* 821743D0h case   12:*/		return 0x821743D4;
		  /* 821743D4h */ case   13:  		/* mr R5, R17 */
		/* 821743D4h case   13:*/		regs.R5 = regs.R17;
		/* 821743D4h case   13:*/		return 0x821743D8;
		  /* 821743D8h */ case   14:  		/* mr R4, R20 */
		/* 821743D8h case   14:*/		regs.R4 = regs.R20;
		/* 821743D8h case   14:*/		return 0x821743DC;
		  /* 821743DCh */ case   15:  		/* mr R3, R18 */
		/* 821743DCh case   15:*/		regs.R3 = regs.R18;
		/* 821743DCh case   15:*/		return 0x821743E0;
		  /* 821743E0h */ case   16:  		/* bl -4520 */
		/* 821743E0h case   16:*/		regs.LR = 0x821743E4; return 0x82173238;
		/* 821743E0h case   16:*/		return 0x821743E4;
		  /* 821743E4h */ case   17:  		/* lwz R11, <#[R18 + 4]> */
		/* 821743E4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 821743E4h case   17:*/		return 0x821743E8;
	}
	return 0x821743E8;
} // Block from 821743A0h-821743E8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821743E8h
// Function '?SkipInstruction@RegOptSimulator@D3DXShader@@AAA?AW4SkipInstructionDisposition@12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821743E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821743E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821743E8);
		  /* 821743E8h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821743E8h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821743E8h case    0:*/		return 0x821743EC;
		  /* 821743ECh */ case    1:  		/* addic R10, R10, -1 */
		/* 821743ECh case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821743ECh case    1:*/		return 0x821743F0;
		  /* 821743F0h */ case    2:  		/* subfe R10, R10, R10 */
		/* 821743F0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821743F0h case    2:*/		return 0x821743F4;
		  /* 821743F4h */ case    3:  		/* and R11, R10, R11 */
		/* 821743F4h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821743F4h case    3:*/		return 0x821743F8;
		  /* 821743F8h */ case    4:  		/* lwz R11, <#[R11 + 20]> */
		/* 821743F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821743F8h case    4:*/		return 0x821743FC;
		  /* 821743FCh */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821743FCh case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821743FCh case    5:*/		return 0x82174400;
		  /* 82174400h */ case    6:  		/* bc 4, CR0_EQ, 48 */
		/* 82174400h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82174430;  }
		/* 82174400h case    6:*/		return 0x82174404;
		  /* 82174404h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82174404h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82174404h case    7:*/		return 0x82174408;
		  /* 82174408h */ case    8:  		/* bc 12, CR0_EQ, 40 */
		/* 82174408h case    8:*/		if ( regs.CR[0].eq ) { return 0x82174430;  }
		/* 82174408h case    8:*/		return 0x8217440C;
		  /* 8217440Ch */ case    9:  		/* lwz R10, <#[R11 + 8]> */
		/* 8217440Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8217440Ch case    9:*/		return 0x82174410;
		  /* 82174410h */ case   10:  		/* rlwinm R9, R11, 0, 0, 30 */
		/* 82174410h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R11);
		/* 82174410h case   10:*/		return 0x82174414;
		  /* 82174414h */ case   11:  		/* rlwinm R10, R10, 0, 6, 4 */
		/* 82174414h case   11:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R10,regs.R10);
		/* 82174414h case   11:*/		return 0x82174418;
		  /* 82174418h */ case   12:  		/* stw R10, <#[R11 + 8]> */
		/* 82174418h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82174418h case   12:*/		return 0x8217441C;
		  /* 8217441Ch */ case   13:  		/* lwz R11, <#[R9 + 40]> */
		/* 8217441Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000028) );
		/* 8217441Ch case   13:*/		return 0x82174420;
		  /* 82174420h */ case   14:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82174420h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82174420h case   14:*/		return 0x82174424;
		  /* 82174424h */ case   15:  		/* bc 4, CR0_EQ, 12 */
		/* 82174424h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82174430;  }
		/* 82174424h case   15:*/		return 0x82174428;
		  /* 82174428h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 82174428h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82174428h case   16:*/		return 0x8217442C;
		  /* 8217442Ch */ case   17:  		/* bc 4, CR6_EQ, -32 */
		/* 8217442Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x8217440C;  }
		/* 8217442Ch case   17:*/		return 0x82174430;
	}
	return 0x82174430;
} // Block from 821743E8h-82174430h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82174430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174430);
		  /* 82174430h */ case    0:  		/* lwz R11, <#[R20 + 28]> */
		/* 82174430h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x0000001C) );
		/* 82174430h case    0:*/		return 0x82174434;
		  /* 82174434h */ case    1:  		/* addi R19, R20, 24 */
		/* 82174434h case    1:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R20,0x18);
		/* 82174434h case    1:*/		return 0x82174438;
		  /* 82174438h */ case    2:  		/* lwz R15, <#[R17 + 16]> */
		/* 82174438h case    2:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R17 + 0x00000010) );
		/* 82174438h case    2:*/		return 0x8217443C;
		  /* 8217443Ch */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8217443Ch case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8217443Ch case    3:*/		return 0x82174440;
		  /* 82174440h */ case    4:  		/* mr R30, R15 */
		/* 82174440h case    4:*/		regs.R30 = regs.R15;
		/* 82174440h case    4:*/		return 0x82174444;
		  /* 82174444h */ case    5:  		/* bc 4, CR0_EQ, 204 */
		/* 82174444h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82174510;  }
		/* 82174444h case    5:*/		return 0x82174448;
		  /* 82174448h */ case    6:  		/* lwz R11, <#[R19]> */
		/* 82174448h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82174448h case    6:*/		return 0x8217444C;
		  /* 8217444Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8217444Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8217444Ch case    7:*/		return 0x82174450;
		  /* 82174450h */ case    8:  		/* addic. R31, R11, -40 */
		/* 82174450h case    8:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82174450h case    8:*/		return 0x82174454;
		  /* 82174454h */ case    9:  		/* bc 12, CR0_EQ, 188 */
		/* 82174454h case    9:*/		if ( regs.CR[0].eq ) { return 0x82174510;  }
		/* 82174454h case    9:*/		return 0x82174458;
		  /* 82174458h */ case   10:  		/* li R14, 0 */
		/* 82174458h case   10:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82174458h case   10:*/		return 0x8217445C;
		  /* 8217445Ch */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 8217445Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8217445Ch case   11:*/		return 0x82174460;
		  /* 82174460h */ case   12:  		/* mr R4, R31 */
		/* 82174460h case   12:*/		regs.R4 = regs.R31;
		/* 82174460h case   12:*/		return 0x82174464;
		  /* 82174464h */ case   13:  		/* lwz R10, <#[R31 + 16]> */
		/* 82174464h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82174464h case   13:*/		return 0x82174468;
		  /* 82174468h */ case   14:  		/* mr R3, R18 */
		/* 82174468h case   14:*/		regs.R3 = regs.R18;
		/* 82174468h case   14:*/		return 0x8217446C;
		  /* 8217446Ch */ case   15:  		/* lwz R9, <#[R31 + 20]> */
		/* 8217446Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8217446Ch case   15:*/		return 0x82174470;
		  /* 82174470h */ case   16:  		/* rlwinm R11, R11, 0, 6, 4 */
		/* 82174470h case   16:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R11,regs.R11);
		/* 82174470h case   16:*/		return 0x82174474;
		  /* 82174474h */ case   17:  		/* rlwinm R10, R10, 0, 7, 0 */
		/* 82174474h case   17:*/		cpu::op::rlwinm<0,0,7,0>(regs,&regs.R10,regs.R10);
		/* 82174474h case   17:*/		return 0x82174478;
		  /* 82174478h */ case   18:  		/* stw R14, <#[R31 + 32]> */
		/* 82174478h case   18:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x00000020) );
		/* 82174478h case   18:*/		return 0x8217447C;
		  /* 8217447Ch */ case   19:  		/* rlwinm R9, R9, 0, 7, 31 */
		/* 8217447Ch case   19:*/		cpu::op::rlwinm<0,0,7,31>(regs,&regs.R9,regs.R9);
		/* 8217447Ch case   19:*/		return 0x82174480;
		  /* 82174480h */ case   20:  		/* stw R11, <#[R31 + 8]> */
		/* 82174480h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82174480h case   20:*/		return 0x82174484;
		  /* 82174484h */ case   21:  		/* stw R10, <#[R31 + 16]> */
		/* 82174484h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82174484h case   21:*/		return 0x82174488;
		  /* 82174488h */ case   22:  		/* stw R9, <#[R31 + 20]> */
		/* 82174488h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82174488h case   22:*/		return 0x8217448C;
		  /* 8217448Ch */ case   23:  		/* bl 712612 */
		/* 8217448Ch case   23:*/		regs.LR = 0x82174490; return 0x82222430;
		/* 8217448Ch case   23:*/		return 0x82174490;
		  /* 82174490h */ case   24:  		/* lwz R11, <#[R31 + 16]> */
		/* 82174490h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82174490h case   24:*/		return 0x82174494;
		  /* 82174494h */ case   25:  		/* addi R10, R3, 1 */
		/* 82174494h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x1);
		/* 82174494h case   25:*/		return 0x82174498;
		  /* 82174498h */ case   26:  		/* li R7, 0 */
		/* 82174498h case   26:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82174498h case   26:*/		return 0x8217449C;
		  /* 8217449Ch */ case   27:  		/* rlwimi R11, R10, 21, 8, 10 */
		/* 8217449Ch case   27:*/		cpu::op::rlwimi<0,21,8,10>(regs,&regs.R11,regs.R10);
		/* 8217449Ch case   27:*/		return 0x821744A0;
		  /* 821744A0h */ case   28:  		/* mr R6, R17 */
		/* 821744A0h case   28:*/		regs.R6 = regs.R17;
		/* 821744A0h case   28:*/		return 0x821744A4;
		  /* 821744A4h */ case   29:  		/* stw R11, <#[R31 + 16]> */
		/* 821744A4h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821744A4h case   29:*/		return 0x821744A8;
		  /* 821744A8h */ case   30:  		/* mr R5, R20 */
		/* 821744A8h case   30:*/		regs.R5 = regs.R20;
		/* 821744A8h case   30:*/		return 0x821744AC;
		  /* 821744ACh */ case   31:  		/* mr R4, R31 */
		/* 821744ACh case   31:*/		regs.R4 = regs.R31;
		/* 821744ACh case   31:*/		return 0x821744B0;
		  /* 821744B0h */ case   32:  		/* mr R3, R18 */
		/* 821744B0h case   32:*/		regs.R3 = regs.R18;
		/* 821744B0h case   32:*/		return 0x821744B4;
		  /* 821744B4h */ case   33:  		/* bl -4484 */
		/* 821744B4h case   33:*/		regs.LR = 0x821744B8; return 0x82173330;
		/* 821744B4h case   33:*/		return 0x821744B8;
		  /* 821744B8h */ case   34:  		/* lwz R11, <#[R17 + 16]> */
		/* 821744B8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000010) );
		/* 821744B8h case   34:*/		return 0x821744BC;
		  /* 821744BCh */ case   35:  		/* cmplw CR6, R11, R15 */
		/* 821744BCh case   35:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 821744BCh case   35:*/		return 0x821744C0;
		  /* 821744C0h */ case   36:  		/* bc 4, CR6_GT, 8 */
		/* 821744C0h case   36:*/		if ( !regs.CR[6].gt ) { return 0x821744C8;  }
		/* 821744C0h case   36:*/		return 0x821744C4;
		  /* 821744C4h */ case   37:  		/* mr R15, R11 */
		/* 821744C4h case   37:*/		regs.R15 = regs.R11;
		/* 821744C4h case   37:*/		return 0x821744C8;
	}
	return 0x821744C8;
} // Block from 82174430h-821744C8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821744C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821744C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821744C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821744C8);
		  /* 821744C8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821744C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821744C8h case    0:*/		return 0x821744CC;
		  /* 821744CCh */ case    1:  		/* rlwinm. R10, R11, 9, 31, 31 */
		/* 821744CCh case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R11);
		/* 821744CCh case    1:*/		return 0x821744D0;
		  /* 821744D0h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 821744D0h case    2:*/		if ( regs.CR[0].eq ) { return 0x821744EC;  }
		/* 821744D0h case    2:*/		return 0x821744D4;
		  /* 821744D4h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821744D4h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821744D4h case    3:*/		return 0x821744D8;
		  /* 821744D8h */ case    4:  		/* cmplwi CR6, R11, 14080 */
		/* 821744D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821744D8h case    4:*/		return 0x821744DC;
		  /* 821744DCh */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821744DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x821744EC;  }
		/* 821744DCh case    5:*/		return 0x821744E0;
		  /* 821744E0h */ case    6:  		/* mr R4, R31 */
		/* 821744E0h case    6:*/		regs.R4 = regs.R31;
		/* 821744E0h case    6:*/		return 0x821744E4;
		  /* 821744E4h */ case    7:  		/* mr R3, R18 */
		/* 821744E4h case    7:*/		regs.R3 = regs.R18;
		/* 821744E4h case    7:*/		return 0x821744E8;
		  /* 821744E8h */ case    8:  		/* bl -10000 */
		/* 821744E8h case    8:*/		regs.LR = 0x821744EC; return 0x82171DD8;
		/* 821744E8h case    8:*/		return 0x821744EC;
	}
	return 0x821744EC;
} // Block from 821744C8h-821744ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821744ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821744EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821744EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821744EC);
		  /* 821744ECh */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821744ECh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821744ECh case    0:*/		return 0x821744F0;
		  /* 821744F0h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 821744F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821744F0h case    1:*/		return 0x821744F4;
		  /* 821744F4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821744F4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821744F4h case    2:*/		return 0x821744F8;
		  /* 821744F8h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821744F8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82174508;  }
		/* 821744F8h case    3:*/		return 0x821744FC;
		  /* 821744FCh */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821744FCh case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821744FCh case    4:*/		return 0x82174500;
		  /* 82174500h */ case    5:  		/* addic. R31, R11, -40 */
		/* 82174500h case    5:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82174500h case    5:*/		return 0x82174504;
		  /* 82174504h */ case    6:  		/* bc 4, CR0_EQ, -168 */
		/* 82174504h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8217445C;  }
		/* 82174504h case    6:*/		return 0x82174508;
	}
	return 0x82174508;
} // Block from 821744ECh-82174508h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82174508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174508);
		  /* 82174508h */ case    0:  		/* cmplw CR6, R30, R15 */
		/* 82174508h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R15);
		/* 82174508h case    0:*/		return 0x8217450C;
		  /* 8217450Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8217450Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8217451C;  }
		/* 8217450Ch case    1:*/		return 0x82174510;
	}
	return 0x82174510;
} // Block from 82174508h-82174510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174510);
		  /* 82174510h */ case    0:  		/* li R3, 0 */
		/* 82174510h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82174510h case    0:*/		return 0x82174514;
		  /* 82174514h */ case    1:  		/* addi R1, R1, 352 */
		/* 82174514h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x160);
		/* 82174514h case    1:*/		return 0x82174518;
		  /* 82174518h */ case    2:  		/* b -930472 */
		/* 82174518h case    2:*/		return 0x82091270;
		/* 82174518h case    2:*/		return 0x8217451C;
	}
	return 0x8217451C;
} // Block from 82174510h-8217451Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8217451Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217451C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217451C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217451C);
		  /* 8217451Ch */ case    0:  		/* li R5, 44 */
		/* 8217451Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x2C);
		/* 8217451Ch case    0:*/		return 0x82174520;
		  /* 82174520h */ case    1:  		/* li R4, 8 */
		/* 82174520h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82174520h case    1:*/		return 0x82174524;
		  /* 82174524h */ case    2:  		/* mr R3, R18 */
		/* 82174524h case    2:*/		regs.R3 = regs.R18;
		/* 82174524h case    2:*/		return 0x82174528;
		  /* 82174528h */ case    3:  		/* bl -64568 */
		/* 82174528h case    3:*/		regs.LR = 0x8217452C; return 0x821648F0;
		/* 82174528h case    3:*/		return 0x8217452C;
		  /* 8217452Ch */ case    4:  		/* addi R24, R3, 4 */
		/* 8217452Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R3,0x4);
		/* 8217452Ch case    4:*/		return 0x82174530;
		  /* 82174530h */ case    5:  		/* ori R11, R3, 1 */
		/* 82174530h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82174530h case    5:*/		return 0x82174534;
		  /* 82174534h */ case    6:  		/* ori R10, R24, 1 */
		/* 82174534h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R24,0x1);
		/* 82174534h case    6:*/		return 0x82174538;
	}
	return 0x82174538;
} // Block from 8217451Ch-82174538h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82174538h
// Function '?SkipToOriginalLocation@RegOptSimulator@D3DXShader@@AAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174538);
		  /* 82174538h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 82174538h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82174538h case    0:*/		return 0x8217453C;
		  /* 8217453Ch */ case    1:  		/* mr R25, R3 */
		/* 8217453Ch case    1:*/		regs.R25 = regs.R3;
		/* 8217453Ch case    1:*/		return 0x82174540;
		  /* 82174540h */ case    2:  		/* stw R10, <#[R3]> */
		/* 82174540h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82174540h case    2:*/		return 0x82174544;
		  /* 82174544h */ case    3:  		/* lwz R11, <#[R20 + 20]> */
		/* 82174544h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000014) );
		/* 82174544h case    3:*/		return 0x82174548;
		  /* 82174548h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82174548h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82174548h case    4:*/		return 0x8217454C;
		  /* 8217454Ch */ case    5:  		/* bc 4, CR0_EQ, 104 */
		/* 8217454Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821745B4;  }
		/* 8217454Ch case    5:*/		return 0x82174550;
		  /* 82174550h */ case    6:  		/* mr R10, R11 */
		/* 82174550h case    6:*/		regs.R10 = regs.R11;
		/* 82174550h case    6:*/		return 0x82174554;
		  /* 82174554h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82174554h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82174554h case    7:*/		return 0x82174558;
		  /* 82174558h */ case    8:  		/* bc 12, CR0_EQ, 92 */
		/* 82174558h case    8:*/		if ( regs.CR[0].eq ) { return 0x821745B4;  }
		/* 82174558h case    8:*/		return 0x8217455C;
		  /* 8217455Ch */ case    9:  		/* lwz R11, <#[R10 + 8]> */
		/* 8217455Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8217455Ch case    9:*/		return 0x82174560;
		  /* 82174560h */ case   10:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82174560h case   10:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82174560h case   10:*/		return 0x82174564;
		  /* 82174564h */ case   11:  		/* bc 12, CR0_EQ, 52 */
		/* 82174564h case   11:*/		if ( regs.CR[0].eq ) { return 0x82174598;  }
		/* 82174564h case   11:*/		return 0x82174568;
		  /* 82174568h */ case   12:  		/* lwz R11, <#[R10 + 4]> */
		/* 82174568h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82174568h case   12:*/		return 0x8217456C;
		  /* 8217456Ch */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8217456Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217456Ch case   13:*/		return 0x82174570;
		  /* 82174570h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 82174570h case   14:*/		if ( regs.CR[6].eq ) { return 0x82174588;  }
		/* 82174570h case   14:*/		return 0x82174574;
		  /* 82174574h */ case   15:  		/* lwz R9, <#[R11]> */
		/* 82174574h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82174574h case   15:*/		return 0x82174578;
		  /* 82174578h */ case   16:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82174578h case   16:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82174578h case   16:*/		return 0x8217457C;
		  /* 8217457Ch */ case   17:  		/* bc 4, CR0_EQ, 12 */
		/* 8217457Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x82174588;  }
		/* 8217457Ch case   17:*/		return 0x82174580;
		  /* 82174580h */ case   18:  		/* lwz R11, <#[R11 + 8]> */
		/* 82174580h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82174580h case   18:*/		return 0x82174584;
		  /* 82174584h */ case   19:  		/* b -24 */
		/* 82174584h case   19:*/		return 0x8217456C;
		/* 82174584h case   19:*/		return 0x82174588;
	}
	return 0x82174588;
} // Block from 82174538h-82174588h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82174588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174588);
		  /* 82174588h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82174588h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82174588h case    0:*/		return 0x8217458C;
		  /* 8217458Ch */ case    1:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 8217458Ch case    1:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 8217458Ch case    1:*/		return 0x82174590;
		  /* 82174590h */ case    2:  		/* cmplw CR6, R11, R15 */
		/* 82174590h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 82174590h case    2:*/		return 0x82174594;
		  /* 82174594h */ case    3:  		/* bc 12, CR6_EQ, -132 */
		/* 82174594h case    3:*/		if ( regs.CR[6].eq ) { return 0x82174510;  }
		/* 82174594h case    3:*/		return 0x82174598;
	}
	return 0x82174598;
} // Block from 82174588h-82174598h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82174598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174598);
		  /* 82174598h */ case    0:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 82174598h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 82174598h case    0:*/		return 0x8217459C;
		  /* 8217459Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8217459Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8217459Ch case    1:*/		return 0x821745A0;
		  /* 821745A0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821745A0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821745A0h case    2:*/		return 0x821745A4;
		  /* 821745A4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821745A4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821745B4;  }
		/* 821745A4h case    3:*/		return 0x821745A8;
		  /* 821745A8h */ case    4:  		/* mr R10, R11 */
		/* 821745A8h case    4:*/		regs.R10 = regs.R11;
		/* 821745A8h case    4:*/		return 0x821745AC;
		  /* 821745ACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821745ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821745ACh case    5:*/		return 0x821745B0;
		  /* 821745B0h */ case    6:  		/* bc 4, CR6_EQ, -84 */
		/* 821745B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8217455C;  }
		/* 821745B0h case    6:*/		return 0x821745B4;
	}
	return 0x821745B4;
} // Block from 82174598h-821745B4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821745B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821745B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821745B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821745B4);
		  /* 821745B4h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 821745B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 821745B4h case    0:*/		return 0x821745B8;
		  /* 821745B8h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821745B8h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821745B8h case    1:*/		return 0x821745BC;
		  /* 821745BCh */ case    2:  		/* bc 4, CR0_EQ, 452 */
		/* 821745BCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82174780;  }
		/* 821745BCh case    2:*/		return 0x821745C0;
		  /* 821745C0h */ case    3:  		/* mr R29, R11 */
		/* 821745C0h case    3:*/		regs.R29 = regs.R11;
		/* 821745C0h case    3:*/		return 0x821745C4;
		  /* 821745C4h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 821745C4h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821745C4h case    4:*/		return 0x821745C8;
		  /* 821745C8h */ case    5:  		/* bc 12, CR0_EQ, 440 */
		/* 821745C8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82174780;  }
		/* 821745C8h case    5:*/		return 0x821745CC;
		  /* 821745CCh */ case    6:  		/* lwz R11, <#[R29 + 20]> */
		/* 821745CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 821745CCh case    6:*/		return 0x821745D0;
		  /* 821745D0h */ case    7:  		/* rlwinm. R10, R11, 0, 15, 18 */
		/* 821745D0h case    7:*/		cpu::op::rlwinm<1,0,15,18>(regs,&regs.R10,regs.R11);
		/* 821745D0h case    7:*/		return 0x821745D4;
		  /* 821745D4h */ case    8:  		/* bc 4, CR0_EQ, 68 */
		/* 821745D4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82174618;  }
		/* 821745D4h case    8:*/		return 0x821745D8;
		  /* 821745D8h */ case    9:  		/* lwz R11, <#[R29 + 8]> */
		/* 821745D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821745D8h case    9:*/		return 0x821745DC;
		  /* 821745DCh */ case   10:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 821745DCh case   10:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 821745DCh case   10:*/		return 0x821745E0;
		  /* 821745E0h */ case   11:  		/* bc 12, CR0_EQ, 388 */
		/* 821745E0h case   11:*/		if ( regs.CR[0].eq ) { return 0x82174764;  }
		/* 821745E0h case   11:*/		return 0x821745E4;
		  /* 821745E4h */ case   12:  		/* lwz R11, <#[R29 + 4]> */
		/* 821745E4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821745E4h case   12:*/		return 0x821745E8;
		  /* 821745E8h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 821745E8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821745E8h case   13:*/		return 0x821745EC;
		  /* 821745ECh */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 821745ECh case   14:*/		if ( regs.CR[6].eq ) { return 0x82174604;  }
		/* 821745ECh case   14:*/		return 0x821745F0;
		  /* 821745F0h */ case   15:  		/* lwz R10, <#[R11]> */
		/* 821745F0h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821745F0h case   15:*/		return 0x821745F4;
		  /* 821745F4h */ case   16:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821745F4h case   16:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821745F4h case   16:*/		return 0x821745F8;
		  /* 821745F8h */ case   17:  		/* bc 4, CR0_EQ, 12 */
		/* 821745F8h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82174604;  }
		/* 821745F8h case   17:*/		return 0x821745FC;
		  /* 821745FCh */ case   18:  		/* lwz R11, <#[R11 + 8]> */
		/* 821745FCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821745FCh case   18:*/		return 0x82174600;
		  /* 82174600h */ case   19:  		/* b -24 */
		/* 82174600h case   19:*/		return 0x821745E8;
		/* 82174600h case   19:*/		return 0x82174604;
	}
	return 0x82174604;
} // Block from 821745B4h-82174604h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82174604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174604);
		  /* 82174604h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82174604h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82174604h case    0:*/		return 0x82174608;
	}
	return 0x82174608;
} // Block from 82174604h-82174608h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174608h
// Function '??0RegOptSimulator@D3DXShader@@QAA@PAVBlock@1@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@1@PAVInfiniteLocalRegisterSet@1@IPAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174608);
		  /* 82174608h */ case    0:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 82174608h case    0:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 82174608h case    0:*/		return 0x8217460C;
		  /* 8217460Ch */ case    1:  		/* cmplw CR6, R11, R15 */
		/* 8217460Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 8217460Ch case    1:*/		return 0x82174610;
		  /* 82174610h */ case    2:  		/* bc 12, CR6_EQ, -256 */
		/* 82174610h case    2:*/		if ( regs.CR[6].eq ) { return 0x82174510;  }
		/* 82174610h case    2:*/		return 0x82174614;
		  /* 82174614h */ case    3:  		/* b 336 */
		/* 82174614h case    3:*/		return 0x82174764;
		/* 82174614h case    3:*/		return 0x82174618;
	}
	return 0x82174618;
} // Block from 82174608h-82174618h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82174618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174618);
		  /* 82174618h */ case    0:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 82174618h case    0:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 82174618h case    0:*/		return 0x8217461C;
		  /* 8217461Ch */ case    1:  		/* cmplw CR6, R11, R15 */
		/* 8217461Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 8217461Ch case    1:*/		return 0x82174620;
		  /* 82174620h */ case    2:  		/* bc 4, CR6_EQ, 324 */
		/* 82174620h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82174764;  }
		/* 82174620h case    2:*/		return 0x82174624;
		  /* 82174624h */ case    3:  		/* lwz R11, <#[R29 + 8]> */
		/* 82174624h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82174624h case    3:*/		return 0x82174628;
		  /* 82174628h */ case    4:  		/* li R28, 8191 */
		/* 82174628h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x1FFF);
		/* 82174628h case    4:*/		return 0x8217462C;
		  /* 8217462Ch */ case    5:  		/* lwz R10, <#[R29 + 16]> */
		/* 8217462Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8217462Ch case    5:*/		return 0x82174630;
		  /* 82174630h */ case    6:  		/* oris R11, R11, 1024 */
		/* 82174630h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82174630h case    6:*/		return 0x82174634;
		  /* 82174634h */ case    7:  		/* lwz R30, <#[R29 + 4]> */
		/* 82174634h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000004) );
		/* 82174634h case    7:*/		return 0x82174638;
		  /* 82174638h */ case    8:  		/* oris R10, R10, 1024 */
		/* 82174638h case    8:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x400);
		/* 82174638h case    8:*/		return 0x8217463C;
		  /* 8217463Ch */ case    9:  		/* stw R11, <#[R29 + 8]> */
		/* 8217463Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8217463Ch case    9:*/		return 0x82174640;
		  /* 82174640h */ case   10:  		/* stw R10, <#[R29 + 16]> */
		/* 82174640h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 82174640h case   10:*/		return 0x82174644;
		  /* 82174644h */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 82174644h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82174644h case   11:*/		return 0x82174648;
		  /* 82174648h */ case   12:  		/* bc 12, CR6_EQ, 108 */
		/* 82174648h case   12:*/		if ( regs.CR[6].eq ) { return 0x821746B4;  }
		/* 82174648h case   12:*/		return 0x8217464C;
		  /* 8217464Ch */ case   13:  		/* lwz R31, <#[R30 + 16]> */
		/* 8217464Ch case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 8217464Ch case   13:*/		return 0x82174650;
		  /* 82174650h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 82174650h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82174650h case   14:*/		return 0x82174654;
		  /* 82174654h */ case   15:  		/* bc 12, CR6_EQ, 88 */
		/* 82174654h case   15:*/		if ( regs.CR[6].eq ) { return 0x821746AC;  }
		/* 82174654h case   15:*/		return 0x82174658;
		  /* 82174658h */ case   16:  		/* lwz R11, <#[R31 + 28]> */
		/* 82174658h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82174658h case   16:*/		return 0x8217465C;
		  /* 8217465Ch */ case   17:  		/* cmplw CR6, R11, R20 */
		/* 8217465Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 8217465Ch case   17:*/		return 0x82174660;
		  /* 82174660h */ case   18:  		/* bc 4, CR6_EQ, 76 */
		/* 82174660h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821746AC;  }
		/* 82174660h case   18:*/		return 0x82174664;
		  /* 82174664h */ case   19:  		/* lwz R11, <#[R31 + 8]> */
		/* 82174664h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82174664h case   19:*/		return 0x82174668;
		  /* 82174668h */ case   20:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82174668h case   20:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82174668h case   20:*/		return 0x8217466C;
		  /* 8217466Ch */ case   21:  		/* cmplwi CR6, R10, 14336 */
		/* 8217466Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003800);
		/* 8217466Ch case   21:*/		return 0x82174670;
		  /* 82174670h */ case   22:  		/* bc 12, CR6_EQ, 60 */
		/* 82174670h case   22:*/		if ( regs.CR[6].eq ) { return 0x821746AC;  }
		/* 82174670h case   22:*/		return 0x82174674;
		  /* 82174674h */ case   23:  		/* oris R11, R11, 1024 */
		/* 82174674h case   23:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82174674h case   23:*/		return 0x82174678;
		  /* 82174678h */ case   24:  		/* mr R3, R30 */
		/* 82174678h case   24:*/		regs.R3 = regs.R30;
		/* 82174678h case   24:*/		return 0x8217467C;
		  /* 8217467Ch */ case   25:  		/* stw R11, <#[R31 + 8]> */
		/* 8217467Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8217467Ch case   25:*/		return 0x82174680;
		  /* 82174680h */ case   26:  		/* bl -65104 */
		/* 82174680h case   26:*/		regs.LR = 0x82174684; return 0x82164830;
		/* 82174680h case   26:*/		return 0x82174684;
		  /* 82174684h */ case   27:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82174684h case   27:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82174684h case   27:*/		return 0x82174688;
		  /* 82174688h */ case   28:  		/* bc 12, CR0_EQ, 36 */
		/* 82174688h case   28:*/		if ( regs.CR[0].eq ) { return 0x821746AC;  }
		/* 82174688h case   28:*/		return 0x8217468C;
		  /* 8217468Ch */ case   29:  		/* lwz R11, <#[R31 + 16]> */
		/* 8217468Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8217468Ch case   29:*/		return 0x82174690;
		  /* 82174690h */ case   30:  		/* lwz R10, <#[R31 + 20]> */
		/* 82174690h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82174690h case   30:*/		return 0x82174694;
		  /* 82174694h */ case   31:  		/* oris R9, R11, 1024 */
		/* 82174694h case   31:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R11,0x400);
		/* 82174694h case   31:*/		return 0x82174698;
		  /* 82174698h */ case   32:  		/* rlwinm R11, R10, 0, 19, 31 */
		/* 82174698h case   32:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R10);
		/* 82174698h case   32:*/		return 0x8217469C;
		  /* 8217469Ch */ case   33:  		/* stw R9, <#[R31 + 16]> */
		/* 8217469Ch case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8217469Ch case   33:*/		return 0x821746A0;
		  /* 821746A0h */ case   34:  		/* cmplw CR6, R11, R28 */
		/* 821746A0h case   34:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 821746A0h case   34:*/		return 0x821746A4;
		  /* 821746A4h */ case   35:  		/* bc 4, CR6_LT, 8 */
		/* 821746A4h case   35:*/		if ( !regs.CR[6].lt ) { return 0x821746AC;  }
		/* 821746A4h case   35:*/		return 0x821746A8;
		  /* 821746A8h */ case   36:  		/* mr R28, R11 */
		/* 821746A8h case   36:*/		regs.R28 = regs.R11;
		/* 821746A8h case   36:*/		return 0x821746AC;
	}
	return 0x821746AC;
} // Block from 82174618h-821746ACh (37 instructions)

//////////////////////////////////////////////////////
// Block at 821746ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821746AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821746AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821746AC);
		  /* 821746ACh */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 821746ACh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 821746ACh case    0:*/		return 0x821746B0;
		  /* 821746B0h */ case    1:  		/* b -108 */
		/* 821746B0h case    1:*/		return 0x82174644;
		/* 821746B0h case    1:*/		return 0x821746B4;
	}
	return 0x821746B4;
} // Block from 821746ACh-821746B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821746B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821746B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821746B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821746B4);
		  /* 821746B4h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 821746B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821746B4h case    0:*/		return 0x821746B8;
		  /* 821746B8h */ case    1:  		/* lwz R10, <#[R29 + 20]> */
		/* 821746B8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 821746B8h case    1:*/		return 0x821746BC;
		  /* 821746BCh */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821746BCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821746BCh case    2:*/		return 0x821746C0;
		  /* 821746C0h */ case    3:  		/* rlwinm R31, R10, 0, 19, 31 */
		/* 821746C0h case    3:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R31,regs.R10);
		/* 821746C0h case    3:*/		return 0x821746C4;
		  /* 821746C4h */ case    4:  		/* bc 4, CR0_EQ, 40 */
		/* 821746C4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821746EC;  }
		/* 821746C4h case    4:*/		return 0x821746C8;
		  /* 821746C8h */ case    5:  		/* lwz R11, <#[R25]> */
		/* 821746C8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821746C8h case    5:*/		return 0x821746CC;
		  /* 821746CCh */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821746CCh case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821746CCh case    6:*/		return 0x821746D0;
		  /* 821746D0h */ case    7:  		/* addic. R3, R11, -4 */
		/* 821746D0h case    7:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 821746D0h case    7:*/		return 0x821746D4;
		  /* 821746D4h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 821746D4h case    8:*/		if ( regs.CR[0].eq ) { return 0x821746EC;  }
		/* 821746D4h case    8:*/		return 0x821746D8;
		  /* 821746D8h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 821746D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821746D8h case    9:*/		return 0x821746DC;
		  /* 821746DCh */ case   10:  		/* lwz R10, <#[R3 + 12]> */
		/* 821746DCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821746DCh case   10:*/		return 0x821746E0;
		  /* 821746E0h */ case   11:  		/* addi R11, R11, 1 */
		/* 821746E0h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821746E0h case   11:*/		return 0x821746E4;
		  /* 821746E4h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 821746E4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821746E4h case   12:*/		return 0x821746E8;
		  /* 821746E8h */ case   13:  		/* bc 4, CR6_GT, 16 */
		/* 821746E8h case   13:*/		if ( !regs.CR[6].gt ) { return 0x821746F8;  }
		/* 821746E8h case   13:*/		return 0x821746EC;
	}
	return 0x821746EC;
} // Block from 821746B4h-821746ECh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821746ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821746EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821746EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821746EC);
		  /* 821746ECh */ case    0:  		/* li R4, 1 */
		/* 821746ECh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821746ECh case    0:*/		return 0x821746F0;
		  /* 821746F0h */ case    1:  		/* mr R3, R25 */
		/* 821746F0h case    1:*/		regs.R3 = regs.R25;
		/* 821746F0h case    1:*/		return 0x821746F4;
		  /* 821746F4h */ case    2:  		/* bl 100820 */
		/* 821746F4h case    2:*/		regs.LR = 0x821746F8; return 0x8218D0C8;
		/* 821746F4h case    2:*/		return 0x821746F8;
	}
	return 0x821746F8;
} // Block from 821746ECh-821746F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821746F8h
// Function '?PlaceInstruction@RegOptSimulator@D3DXShader@@QAA_NPAVInstruction@2@W4RegOptSolutionStepState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821746F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821746F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821746F8);
		  /* 821746F8h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821746F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821746F8h case    0:*/		return 0x821746FC;
		  /* 821746FCh */ case    1:  		/* addi R10, R11, 4 */
		/* 821746FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821746FCh case    1:*/		return 0x82174700;
		  /* 82174700h */ case    2:  		/* addi R9, R11, 1 */
		/* 82174700h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82174700h case    2:*/		return 0x82174704;
		  /* 82174704h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82174704h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82174704h case    3:*/		return 0x82174708;
		  /* 82174708h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 82174708h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82174708h case    4:*/		return 0x8217470C;
		  /* 8217470Ch */ case    5:  		/* stwx R31, <#[R11 + R3]> */
		/* 8217470Ch case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8217470Ch case    5:*/		return 0x82174710;
		  /* 82174710h */ case    6:  		/* lwz R11, <#[R24]> */
		/* 82174710h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82174710h case    6:*/		return 0x82174714;
		  /* 82174714h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82174714h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82174714h case    7:*/		return 0x82174718;
		  /* 82174718h */ case    8:  		/* bc 4, CR0_EQ, 40 */
		/* 82174718h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82174740;  }
		/* 82174718h case    8:*/		return 0x8217471C;
		  /* 8217471Ch */ case    9:  		/* lwz R11, <#[R25]> */
		/* 8217471Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8217471Ch case    9:*/		return 0x82174720;
		  /* 82174720h */ case   10:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174720h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174720h case   10:*/		return 0x82174724;
		  /* 82174724h */ case   11:  		/* addic. R3, R11, -4 */
		/* 82174724h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82174724h case   11:*/		return 0x82174728;
		  /* 82174728h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 82174728h case   12:*/		if ( regs.CR[0].eq ) { return 0x82174740;  }
		/* 82174728h case   12:*/		return 0x8217472C;
		  /* 8217472Ch */ case   13:  		/* lwz R11, <#[R3 + 8]> */
		/* 8217472Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8217472Ch case   13:*/		return 0x82174730;
		  /* 82174730h */ case   14:  		/* lwz R10, <#[R3 + 12]> */
		/* 82174730h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82174730h case   14:*/		return 0x82174734;
		  /* 82174734h */ case   15:  		/* addi R11, R11, 1 */
		/* 82174734h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82174734h case   15:*/		return 0x82174738;
		  /* 82174738h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 82174738h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82174738h case   16:*/		return 0x8217473C;
		  /* 8217473Ch */ case   17:  		/* bc 4, CR6_GT, 16 */
		/* 8217473Ch case   17:*/		if ( !regs.CR[6].gt ) { return 0x8217474C;  }
		/* 8217473Ch case   17:*/		return 0x82174740;
	}
	return 0x82174740;
} // Block from 821746F8h-82174740h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82174740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174740);
		  /* 82174740h */ case    0:  		/* li R4, 1 */
		/* 82174740h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82174740h case    0:*/		return 0x82174744;
		  /* 82174744h */ case    1:  		/* mr R3, R25 */
		/* 82174744h case    1:*/		regs.R3 = regs.R25;
		/* 82174744h case    1:*/		return 0x82174748;
		  /* 82174748h */ case    2:  		/* bl 100736 */
		/* 82174748h case    2:*/		regs.LR = 0x8217474C; return 0x8218D0C8;
		/* 82174748h case    2:*/		return 0x8217474C;
	}
	return 0x8217474C;
} // Block from 82174740h-8217474Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8217474Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217474C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217474C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217474C);
		  /* 8217474Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8217474Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8217474Ch case    0:*/		return 0x82174750;
		  /* 82174750h */ case    1:  		/* addi R10, R11, 4 */
		/* 82174750h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82174750h case    1:*/		return 0x82174754;
		  /* 82174754h */ case    2:  		/* addi R9, R11, 1 */
		/* 82174754h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82174754h case    2:*/		return 0x82174758;
		  /* 82174758h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82174758h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82174758h case    3:*/		return 0x8217475C;
		  /* 8217475Ch */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 8217475Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8217475Ch case    4:*/		return 0x82174760;
		  /* 82174760h */ case    5:  		/* stwx R28, <#[R11 + R3]> */
		/* 82174760h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82174760h case    5:*/		return 0x82174764;
	}
	return 0x82174764;
} // Block from 8217474Ch-82174764h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82174764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174764);
		  /* 82174764h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82174764h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82174764h case    0:*/		return 0x82174768;
		  /* 82174768h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82174768h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82174768h case    1:*/		return 0x8217476C;
		  /* 8217476Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8217476Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8217476Ch case    2:*/		return 0x82174770;
		  /* 82174770h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82174770h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82174780;  }
		/* 82174770h case    3:*/		return 0x82174774;
		  /* 82174774h */ case    4:  		/* mr R29, R11 */
		/* 82174774h case    4:*/		regs.R29 = regs.R11;
		/* 82174774h case    4:*/		return 0x82174778;
		  /* 82174778h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82174778h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82174778h case    5:*/		return 0x8217477C;
		  /* 8217477Ch */ case    6:  		/* bc 4, CR6_EQ, -432 */
		/* 8217477Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x821745CC;  }
		/* 8217477Ch case    6:*/		return 0x82174780;
	}
	return 0x82174780;
} // Block from 82174764h-82174780h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82174780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174780);
		  /* 82174780h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 82174780h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82174780h case    0:*/		return 0x82174784;
		  /* 82174784h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82174784h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82174784h case    1:*/		return 0x82174788;
		  /* 82174788h */ case    2:  		/* bc 4, CR0_EQ, -632 */
		/* 82174788h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82174510;  }
		/* 82174788h case    2:*/		return 0x8217478C;
		  /* 8217478Ch */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8217478Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8217478Ch case    3:*/		return 0x82174790;
		  /* 82174790h */ case    4:  		/* bc 12, CR0_EQ, -640 */
		/* 82174790h case    4:*/		if ( regs.CR[0].eq ) { return 0x82174510;  }
		/* 82174790h case    4:*/		return 0x82174794;
		  /* 82174794h */ case    5:  		/* lwz R11, <#[R19 + 4]> */
		/* 82174794h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82174794h case    5:*/		return 0x82174798;
		  /* 82174798h */ case    6:  		/* li R26, 8191 */
		/* 82174798h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x1FFF);
		/* 82174798h case    6:*/		return 0x8217479C;
		  /* 8217479Ch */ case    7:  		/* li R27, 8191 */
		/* 8217479Ch case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x1FFF);
		/* 8217479Ch case    7:*/		return 0x821747A0;
		  /* 821747A0h */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821747A0h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821747A0h case    8:*/		return 0x821747A4;
		  /* 821747A4h */ case    9:  		/* bc 4, CR0_EQ, 532 */
		/* 821747A4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821749B8;  }
		/* 821747A4h case    9:*/		return 0x821747A8;
		  /* 821747A8h */ case   10:  		/* lwz R11, <#[R19]> */
		/* 821747A8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 821747A8h case   10:*/		return 0x821747AC;
		  /* 821747ACh */ case   11:  		/* b 512 */
		/* 821747ACh case   11:*/		return 0x821749AC;
		/* 821747ACh case   11:*/		return 0x821747B0;
		  /* 821747B0h */ case   12:  		/* lwz R11, <#[R28 + 20]> */
		/* 821747B0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821747B0h case   12:*/		return 0x821747B4;
		  /* 821747B4h */ case   13:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 821747B4h case   13:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 821747B4h case   13:*/		return 0x821747B8;
		  /* 821747B8h */ case   14:  		/* cmplw CR6, R11, R26 */
		/* 821747B8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821747B8h case   14:*/		return 0x821747BC;
		  /* 821747BCh */ case   15:  		/* bc 12, CR6_GT, 268 */
		/* 821747BCh case   15:*/		if ( regs.CR[6].gt ) { return 0x821748C8;  }
		/* 821747BCh case   15:*/		return 0x821747C0;
		  /* 821747C0h */ case   16:  		/* lwz R10, <#[R24]> */
		/* 821747C0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 821747C0h case   16:*/		return 0x821747C4;
		  /* 821747C4h */ case   17:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 821747C4h case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821747C4h case   17:*/		return 0x821747C8;
		  /* 821747C8h */ case   18:  		/* bc 4, CR0_EQ, 248 */
		/* 821747C8h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821748C0;  }
		/* 821747C8h case   18:*/		return 0x821747CC;
		  /* 821747CCh */ case   19:  		/* cmplwi CR0, R10, 0 */
		/* 821747CCh case   19:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 821747CCh case   19:*/		return 0x821747D0;
		  /* 821747D0h */ case   20:  		/* bc 12, CR0_EQ, 240 */
		/* 821747D0h case   20:*/		if ( regs.CR[0].eq ) { return 0x821748C0;  }
		/* 821747D0h case   20:*/		return 0x821747D4;
		  /* 821747D4h */ case   21:  		/* lwz R11, <#[R25]> */
		/* 821747D4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821747D4h case   21:*/		return 0x821747D8;
		  /* 821747D8h */ case   22:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821747D8h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821747D8h case   22:*/		return 0x821747DC;
		  /* 821747DCh */ case   23:  		/* addi R4, R11, -4 */
		/* 821747DCh case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821747DCh case   23:*/		return 0x821747E0;
		  /* 821747E0h */ case   24:  		/* lwz R11, <#[R11 + 4]> */
		/* 821747E0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821747E0h case   24:*/		return 0x821747E4;
		  /* 821747E4h */ case   25:  		/* addi R10, R11, 3 */
		/* 821747E4h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 821747E4h case   25:*/		return 0x821747E8;
		  /* 821747E8h */ case   26:  		/* addic. R11, R11, -1 */
		/* 821747E8h case   26:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821747E8h case   26:*/		return 0x821747EC;
		  /* 821747ECh */ case   27:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821747ECh case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821747ECh case   27:*/		return 0x821747F0;
		  /* 821747F0h */ case   28:  		/* lwzx R30, <#[R10 + R4]> */
		/* 821747F0h case   28:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 821747F0h case   28:*/		return 0x821747F4;
		  /* 821747F4h */ case   29:  		/* stw R11, <#[R4 + 8]> */
		/* 821747F4h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821747F4h case   29:*/		return 0x821747F8;
		  /* 821747F8h */ case   30:  		/* bc 4, CR0_EQ, 60 */
		/* 821747F8h case   30:*/		if ( !regs.CR[0].eq ) { return 0x82174834;  }
		/* 821747F8h case   30:*/		return 0x821747FC;
		  /* 821747FCh */ case   31:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821747FCh case   31:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821747FCh case   31:*/		return 0x82174800;
		  /* 82174800h */ case   32:  		/* mr R3, R25 */
		/* 82174800h case   32:*/		regs.R3 = regs.R25;
		/* 82174800h case   32:*/		return 0x82174804;
		  /* 82174804h */ case   33:  		/* lwz R10, <#[R11 + 4]> */
		/* 82174804h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82174804h case   33:*/		return 0x82174808;
		  /* 82174808h */ case   34:  		/* lwz R9, <#[R11]> */
		/* 82174808h case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82174808h case   34:*/		return 0x8217480C;
		  /* 8217480Ch */ case   35:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8217480Ch case   35:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8217480Ch case   35:*/		return 0x82174810;
		  /* 82174810h */ case   36:  		/* stw R9, <#[R10]> */
		/* 82174810h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82174810h case   36:*/		return 0x82174814;
		  /* 82174814h */ case   37:  		/* lwz R10, <#[R11 + 4]> */
		/* 82174814h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82174814h case   37:*/		return 0x82174818;
		  /* 82174818h */ case   38:  		/* lwz R11, <#[R11]> */
		/* 82174818h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82174818h case   38:*/		return 0x8217481C;
		  /* 8217481Ch */ case   39:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8217481Ch case   39:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8217481Ch case   39:*/		return 0x82174820;
		  /* 82174820h */ case   40:  		/* stw R10, <#[R11]> */
		/* 82174820h case   40:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82174820h case   40:*/		return 0x82174824;
		  /* 82174824h */ case   41:  		/* lwz R11, <#[R4 + 12]> */
		/* 82174824h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82174824h case   41:*/		return 0x82174828;
		  /* 82174828h */ case   42:  		/* addi R11, R11, 4 */
		/* 82174828h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82174828h case   42:*/		return 0x8217482C;
		  /* 8217482Ch */ case   43:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8217482Ch case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8217482Ch case   43:*/		return 0x82174830;
		  /* 82174830h */ case   44:  		/* bl -141864 */
		/* 82174830h case   44:*/		regs.LR = 0x82174834; return 0x82151E08;
		/* 82174830h case   44:*/		return 0x82174834;
	}
	return 0x82174834;
} // Block from 82174780h-82174834h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82174834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174834);
		  /* 82174834h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 82174834h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82174834h case    0:*/		return 0x82174838;
		  /* 82174838h */ case    1:  		/* mr R26, R30 */
		/* 82174838h case    1:*/		regs.R26 = regs.R30;
		/* 82174838h case    1:*/		return 0x8217483C;
		  /* 8217483Ch */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8217483Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8217483Ch case    2:*/		return 0x82174840;
		  /* 82174840h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82174840h case    3:*/		if ( regs.CR[0].eq ) { return 0x8217484C;  }
		/* 82174840h case    3:*/		return 0x82174844;
		  /* 82174844h */ case    4:  		/* mr R4, R14 */
		/* 82174844h case    4:*/		regs.R4 = regs.R14;
		/* 82174844h case    4:*/		return 0x82174848;
		  /* 82174848h */ case    5:  		/* b 16 */
		/* 82174848h case    5:*/		return 0x82174858;
		/* 82174848h case    5:*/		return 0x8217484C;
	}
	return 0x8217484C;
} // Block from 82174834h-8217484Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8217484Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217484C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217484C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217484C);
		  /* 8217484Ch */ case    0:  		/* lwz R11, <#[R25]> */
		/* 8217484Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8217484Ch case    0:*/		return 0x82174850;
		  /* 82174850h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174850h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174850h case    1:*/		return 0x82174854;
		  /* 82174854h */ case    2:  		/* addi R4, R11, -4 */
		/* 82174854h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 82174854h case    2:*/		return 0x82174858;
	}
	return 0x82174858;
} // Block from 8217484Ch-82174858h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174858);
		  /* 82174858h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 82174858h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82174858h case    0:*/		return 0x8217485C;
		  /* 8217485Ch */ case    1:  		/* addi R10, R11, 3 */
		/* 8217485Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 8217485Ch case    1:*/		return 0x82174860;
		  /* 82174860h */ case    2:  		/* addic. R11, R11, -1 */
		/* 82174860h case    2:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82174860h case    2:*/		return 0x82174864;
		  /* 82174864h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82174864h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82174864h case    3:*/		return 0x82174868;
		  /* 82174868h */ case    4:  		/* lwzx R31, <#[R10 + R4]> */
		/* 82174868h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 82174868h case    4:*/		return 0x8217486C;
		  /* 8217486Ch */ case    5:  		/* stw R11, <#[R4 + 8]> */
		/* 8217486Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8217486Ch case    5:*/		return 0x82174870;
		  /* 82174870h */ case    6:  		/* bc 4, CR0_EQ, 60 */
		/* 82174870h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821748AC;  }
		/* 82174870h case    6:*/		return 0x82174874;
		  /* 82174874h */ case    7:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 82174874h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 82174874h case    7:*/		return 0x82174878;
		  /* 82174878h */ case    8:  		/* mr R3, R25 */
		/* 82174878h case    8:*/		regs.R3 = regs.R25;
		/* 82174878h case    8:*/		return 0x8217487C;
		  /* 8217487Ch */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 8217487Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8217487Ch case    9:*/		return 0x82174880;
		  /* 82174880h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 82174880h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82174880h case   10:*/		return 0x82174884;
		  /* 82174884h */ case   11:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82174884h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82174884h case   11:*/		return 0x82174888;
		  /* 82174888h */ case   12:  		/* stw R9, <#[R10]> */
		/* 82174888h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82174888h case   12:*/		return 0x8217488C;
		  /* 8217488Ch */ case   13:  		/* lwz R10, <#[R11]> */
		/* 8217488Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8217488Ch case   13:*/		return 0x82174890;
		  /* 82174890h */ case   14:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82174890h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82174890h case   14:*/		return 0x82174894;
		  /* 82174894h */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 82174894h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82174894h case   15:*/		return 0x82174898;
		  /* 82174898h */ case   16:  		/* stw R11, <#[R10]> */
		/* 82174898h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82174898h case   16:*/		return 0x8217489C;
		  /* 8217489Ch */ case   17:  		/* lwz R11, <#[R4 + 12]> */
		/* 8217489Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8217489Ch case   17:*/		return 0x821748A0;
		  /* 821748A0h */ case   18:  		/* addi R11, R11, 4 */
		/* 821748A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821748A0h case   18:*/		return 0x821748A4;
		  /* 821748A4h */ case   19:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821748A4h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821748A4h case   19:*/		return 0x821748A8;
		  /* 821748A8h */ case   20:  		/* bl -141984 */
		/* 821748A8h case   20:*/		regs.LR = 0x821748AC; return 0x82151E08;
		/* 821748A8h case   20:*/		return 0x821748AC;
	}
	return 0x821748AC;
} // Block from 82174858h-821748ACh (21 instructions)

//////////////////////////////////////////////////////
// Block at 821748ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821748AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821748AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821748AC);
		  /* 821748ACh */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 821748ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821748ACh case    0:*/		return 0x821748B0;
		  /* 821748B0h */ case    1:  		/* mr R27, R31 */
		/* 821748B0h case    1:*/		regs.R27 = regs.R31;
		/* 821748B0h case    1:*/		return 0x821748B4;
		  /* 821748B4h */ case    2:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 821748B4h case    2:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 821748B4h case    2:*/		return 0x821748B8;
		  /* 821748B8h */ case    3:  		/* cmplw CR6, R11, R30 */
		/* 821748B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821748B8h case    3:*/		return 0x821748BC;
		  /* 821748BCh */ case    4:  		/* bc 4, CR6_GT, -252 */
		/* 821748BCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x821747C0;  }
		/* 821748BCh case    4:*/		return 0x821748C0;
	}
	return 0x821748C0;
} // Block from 821748ACh-821748C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821748C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821748C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821748C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821748C0);
		  /* 821748C0h */ case    0:  		/* cmplw CR6, R11, R26 */
		/* 821748C0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821748C0h case    0:*/		return 0x821748C4;
		  /* 821748C4h */ case    1:  		/* bc 4, CR6_GT, 216 */
		/* 821748C4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8217499C;  }
		/* 821748C4h case    1:*/		return 0x821748C8;
	}
	return 0x821748C8;
} // Block from 821748C0h-821748C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821748C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821748C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821748C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821748C8);
		  /* 821748C8h */ case    0:  		/* lwz R30, <#[R28 + 4]> */
		/* 821748C8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000004) );
		/* 821748C8h case    0:*/		return 0x821748CC;
		  /* 821748CCh */ case    1:  		/* mr R29, R30 */
		/* 821748CCh case    1:*/		regs.R29 = regs.R30;
		/* 821748CCh case    1:*/		return 0x821748D0;
		  /* 821748D0h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 821748D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821748D0h case    2:*/		return 0x821748D4;
		  /* 821748D4h */ case    3:  		/* bc 12, CR6_EQ, 200 */
		/* 821748D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8217499C;  }
		/* 821748D4h case    3:*/		return 0x821748D8;
		  /* 821748D8h */ case    4:  		/* lwz R31, <#[R29 + 16]> */
		/* 821748D8h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000010) );
		/* 821748D8h case    4:*/		return 0x821748DC;
		  /* 821748DCh */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 821748DCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821748DCh case    5:*/		return 0x821748E0;
		  /* 821748E0h */ case    6:  		/* bc 12, CR6_EQ, 64 */
		/* 821748E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82174920;  }
		/* 821748E0h case    6:*/		return 0x821748E4;
		  /* 821748E4h */ case    7:  		/* mr R3, R29 */
		/* 821748E4h case    7:*/		regs.R3 = regs.R29;
		/* 821748E4h case    7:*/		return 0x821748E8;
	}
	return 0x821748E8;
} // Block from 821748C8h-821748E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821748E8h
// Function '?RollBack@RegOptSimulator@D3DXShader@@QAAXPAURegOptSolutionStep@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821748E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821748E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821748E8);
		  /* 821748E8h */ case    0:  		/* bl -65720 */
		/* 821748E8h case    0:*/		regs.LR = 0x821748EC; return 0x82164830;
		/* 821748E8h case    0:*/		return 0x821748EC;
		  /* 821748ECh */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821748ECh case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821748ECh case    1:*/		return 0x821748F0;
		  /* 821748F0h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 821748F0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82174920;  }
		/* 821748F0h case    2:*/		return 0x821748F4;
		  /* 821748F4h */ case    3:  		/* lwz R11, <#[R31 + 28]> */
		/* 821748F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821748F4h case    3:*/		return 0x821748F8;
		  /* 821748F8h */ case    4:  		/* cmplw CR6, R11, R20 */
		/* 821748F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 821748F8h case    4:*/		return 0x821748FC;
		  /* 821748FCh */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 821748FCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x82174920;  }
		/* 821748FCh case    5:*/		return 0x82174900;
		  /* 82174900h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82174900h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82174900h case    6:*/		return 0x82174904;
		  /* 82174904h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82174904h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82174904h case    7:*/		return 0x82174908;
		  /* 82174908h */ case    8:  		/* cmplwi CR6, R11, 14336 */
		/* 82174908h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82174908h case    8:*/		return 0x8217490C;
		  /* 8217490Ch */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 8217490Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82174920;  }
		/* 8217490Ch case    9:*/		return 0x82174910;
		  /* 82174910h */ case   10:  		/* lwz R11, <#[R31 + 20]> */
		/* 82174910h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82174910h case   10:*/		return 0x82174914;
		  /* 82174914h */ case   11:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 82174914h case   11:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 82174914h case   11:*/		return 0x82174918;
		  /* 82174918h */ case   12:  		/* cmplw CR6, R11, R27 */
		/* 82174918h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 82174918h case   12:*/		return 0x8217491C;
		  /* 8217491Ch */ case   13:  		/* bc 12, CR6_LT, 12 */
		/* 8217491Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x82174928;  }
		/* 8217491Ch case   13:*/		return 0x82174920;
	}
	return 0x82174920;
} // Block from 821748E8h-82174920h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82174920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174920);
		  /* 82174920h */ case    0:  		/* lwz R29, <#[R29 + 8]> */
		/* 82174920h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 82174920h case    0:*/		return 0x82174924;
		  /* 82174924h */ case    1:  		/* b -84 */
		/* 82174924h case    1:*/		return 0x821748D0;
		/* 82174924h case    1:*/		return 0x82174928;
	}
	return 0x82174928;
} // Block from 82174920h-82174928h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174928);
		  /* 82174928h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 82174928h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82174928h case    0:*/		return 0x8217492C;
		  /* 8217492Ch */ case    1:  		/* lwz R10, <#[R28 + 16]> */
		/* 8217492Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8217492Ch case    1:*/		return 0x82174930;
		  /* 82174930h */ case    2:  		/* oris R11, R11, 1024 */
		/* 82174930h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82174930h case    2:*/		return 0x82174934;
		  /* 82174934h */ case    3:  		/* oris R10, R10, 1024 */
		/* 82174934h case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x400);
		/* 82174934h case    3:*/		return 0x82174938;
		  /* 82174938h */ case    4:  		/* stw R11, <#[R28 + 8]> */
		/* 82174938h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82174938h case    4:*/		return 0x8217493C;
		  /* 8217493Ch */ case    5:  		/* stw R10, <#[R28 + 16]> */
		/* 8217493Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8217493Ch case    5:*/		return 0x82174940;
		  /* 82174940h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 82174940h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82174940h case    6:*/		return 0x82174944;
		  /* 82174944h */ case    7:  		/* bc 12, CR6_EQ, 88 */
		/* 82174944h case    7:*/		if ( regs.CR[6].eq ) { return 0x8217499C;  }
		/* 82174944h case    7:*/		return 0x82174948;
		  /* 82174948h */ case    8:  		/* lwz R31, <#[R30 + 16]> */
		/* 82174948h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82174948h case    8:*/		return 0x8217494C;
		  /* 8217494Ch */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 8217494Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8217494Ch case    9:*/		return 0x82174950;
		  /* 82174950h */ case   10:  		/* bc 12, CR6_EQ, 68 */
		/* 82174950h case   10:*/		if ( regs.CR[6].eq ) { return 0x82174994;  }
		/* 82174950h case   10:*/		return 0x82174954;
		  /* 82174954h */ case   11:  		/* lwz R11, <#[R31 + 28]> */
		/* 82174954h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82174954h case   11:*/		return 0x82174958;
		  /* 82174958h */ case   12:  		/* cmplw CR6, R11, R20 */
		/* 82174958h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 82174958h case   12:*/		return 0x8217495C;
		  /* 8217495Ch */ case   13:  		/* bc 4, CR6_EQ, 56 */
		/* 8217495Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82174994;  }
		/* 8217495Ch case   13:*/		return 0x82174960;
		  /* 82174960h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 82174960h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82174960h case   14:*/		return 0x82174964;
		  /* 82174964h */ case   15:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82174964h case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82174964h case   15:*/		return 0x82174968;
		  /* 82174968h */ case   16:  		/* cmplwi CR6, R10, 14336 */
		/* 82174968h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003800);
		/* 82174968h case   16:*/		return 0x8217496C;
		  /* 8217496Ch */ case   17:  		/* bc 12, CR6_EQ, 40 */
		/* 8217496Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82174994;  }
		/* 8217496Ch case   17:*/		return 0x82174970;
		  /* 82174970h */ case   18:  		/* oris R11, R11, 1024 */
		/* 82174970h case   18:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82174970h case   18:*/		return 0x82174974;
		  /* 82174974h */ case   19:  		/* mr R3, R30 */
		/* 82174974h case   19:*/		regs.R3 = regs.R30;
		/* 82174974h case   19:*/		return 0x82174978;
		  /* 82174978h */ case   20:  		/* stw R11, <#[R31 + 8]> */
		/* 82174978h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82174978h case   20:*/		return 0x8217497C;
		  /* 8217497Ch */ case   21:  		/* bl -65868 */
		/* 8217497Ch case   21:*/		regs.LR = 0x82174980; return 0x82164830;
		/* 8217497Ch case   21:*/		return 0x82174980;
		  /* 82174980h */ case   22:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82174980h case   22:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82174980h case   22:*/		return 0x82174984;
		  /* 82174984h */ case   23:  		/* bc 12, CR0_EQ, 16 */
		/* 82174984h case   23:*/		if ( regs.CR[0].eq ) { return 0x82174994;  }
		/* 82174984h case   23:*/		return 0x82174988;
		  /* 82174988h */ case   24:  		/* lwz R11, <#[R31 + 16]> */
		/* 82174988h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82174988h case   24:*/		return 0x8217498C;
		  /* 8217498Ch */ case   25:  		/* oris R11, R11, 1024 */
		/* 8217498Ch case   25:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 8217498Ch case   25:*/		return 0x82174990;
		  /* 82174990h */ case   26:  		/* stw R11, <#[R31 + 16]> */
		/* 82174990h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82174990h case   26:*/		return 0x82174994;
	}
	return 0x82174994;
} // Block from 82174928h-82174994h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82174994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174994);
		  /* 82174994h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82174994h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82174994h case    0:*/		return 0x82174998;
		  /* 82174998h */ case    1:  		/* b -88 */
		/* 82174998h case    1:*/		return 0x82174940;
		/* 82174998h case    1:*/		return 0x8217499C;
	}
	return 0x8217499C;
} // Block from 82174994h-8217499Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217499Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217499C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217499C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217499C);
		  /* 8217499Ch */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8217499Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8217499Ch case    0:*/		return 0x821749A0;
		  /* 821749A0h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 821749A0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821749A0h case    1:*/		return 0x821749A4;
		  /* 821749A4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821749A4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821749A4h case    2:*/		return 0x821749A8;
		  /* 821749A8h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821749A8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821749B8;  }
		/* 821749A8h case    3:*/		return 0x821749AC;
	}
	return 0x821749AC;
} // Block from 8217499Ch-821749ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821749ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821749AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821749AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821749AC);
		  /* 821749ACh */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821749ACh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821749ACh case    0:*/		return 0x821749B0;
		  /* 821749B0h */ case    1:  		/* addic. R28, R11, -40 */
		/* 821749B0h case    1:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R11,0xFFFFFFD8);
		/* 821749B0h case    1:*/		return 0x821749B4;
		  /* 821749B4h */ case    2:  		/* bc 4, CR0_EQ, -516 */
		/* 821749B4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821747B0;  }
		/* 821749B4h case    2:*/		return 0x821749B8;
	}
	return 0x821749B8;
} // Block from 821749ACh-821749B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821749B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821749B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821749B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821749B8);
		  /* 821749B8h */ case    0:  		/* li R16, 1 */
		/* 821749B8h case    0:*/		cpu::op::li<0>(regs,&regs.R16,0x1);
		/* 821749B8h case    0:*/		return 0x821749BC;
		  /* 821749BCh */ case    1:  		/* lwz R11, <#[R19 + 4]> */
		/* 821749BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 821749BCh case    1:*/		return 0x821749C0;
		  /* 821749C0h */ case    2:  		/* mr R7, R14 */
		/* 821749C0h case    2:*/		regs.R7 = regs.R14;
		/* 821749C0h case    2:*/		return 0x821749C4;
		  /* 821749C4h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821749C4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821749C4h case    3:*/		return 0x821749C8;
		  /* 821749C8h */ case    4:  		/* bc 4, CR0_EQ, 96 */
		/* 821749C8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82174A28;  }
		/* 821749C8h case    4:*/		return 0x821749CC;
		  /* 821749CCh */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 821749CCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821749CCh case    5:*/		return 0x821749D0;
		  /* 821749D0h */ case    6:  		/* bc 12, CR0_EQ, 88 */
		/* 821749D0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82174A28;  }
		/* 821749D0h case    6:*/		return 0x821749D4;
		  /* 821749D4h */ case    7:  		/* lwz R9, <#[R11 + 8]> */
		/* 821749D4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821749D4h case    7:*/		return 0x821749D8;
		  /* 821749D8h */ case    8:  		/* rlwinm. R10, R9, 6, 31, 31 */
		/* 821749D8h case    8:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R9);
		/* 821749D8h case    8:*/		return 0x821749DC;
		  /* 821749DCh */ case    9:  		/* bc 4, CR0_EQ, 52 */
		/* 821749DCh case    9:*/		if ( !regs.CR[0].eq ) { return 0x82174A10;  }
		/* 821749DCh case    9:*/		return 0x821749E0;
		  /* 821749E0h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 821749E0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821749E0h case   10:*/		return 0x821749E4;
		  /* 821749E4h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 821749E4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821749E4h case   11:*/		return 0x821749E8;
		  /* 821749E8h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 821749E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x82174A10;  }
		/* 821749E8h case   12:*/		return 0x821749EC;
		  /* 821749ECh */ case   13:  		/* lwz R8, <#[R10 + 12]> */
		/* 821749ECh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 821749ECh case   13:*/		return 0x821749F0;
		  /* 821749F0h */ case   14:  		/* lwz R8, <#[R8 + 8]> */
		/* 821749F0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 821749F0h case   14:*/		return 0x821749F4;
		  /* 821749F4h */ case   15:  		/* rlwinm. R8, R8, 6, 31, 31 */
		/* 821749F4h case   15:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R8,regs.R8);
		/* 821749F4h case   15:*/		return 0x821749F8;
		  /* 821749F8h */ case   16:  		/* bc 4, CR0_EQ, 12 */
		/* 821749F8h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82174A04;  }
		/* 821749F8h case   16:*/		return 0x821749FC;
		  /* 821749FCh */ case   17:  		/* lwz R10, <#[R10 + 4]> */
		/* 821749FCh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821749FCh case   17:*/		return 0x82174A00;
	}
	return 0x82174A00;
} // Block from 821749B8h-82174A00h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82174A00h
// Function '?CheckRestOfBlock@RegOptSimulator@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174A00);
		  /* 82174A00h */ case    0:  		/* b -28 */
		/* 82174A00h case    0:*/		return 0x821749E4;
		/* 82174A00h case    0:*/		return 0x82174A04;
	}
	return 0x82174A04;
} // Block from 82174A00h-82174A04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174A04);
		  /* 82174A04h */ case    0:  		/* oris R10, R9, 1024 */
		/* 82174A04h case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R9,0x400);
		/* 82174A04h case    0:*/		return 0x82174A08;
		  /* 82174A08h */ case    1:  		/* mr R7, R16 */
		/* 82174A08h case    1:*/		regs.R7 = regs.R16;
		/* 82174A08h case    1:*/		return 0x82174A0C;
		  /* 82174A0Ch */ case    2:  		/* stw R10, <#[R11 + 8]> */
		/* 82174A0Ch case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82174A0Ch case    2:*/		return 0x82174A10;
	}
	return 0x82174A10;
} // Block from 82174A04h-82174A10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174A10);
		  /* 82174A10h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174A10h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174A10h case    0:*/		return 0x82174A14;
		  /* 82174A14h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82174A14h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82174A14h case    1:*/		return 0x82174A18;
		  /* 82174A18h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82174A18h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82174A18h case    2:*/		return 0x82174A1C;
		  /* 82174A1Ch */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82174A1Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82174A28;  }
		/* 82174A1Ch case    3:*/		return 0x82174A20;
		  /* 82174A20h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82174A20h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82174A20h case    4:*/		return 0x82174A24;
		  /* 82174A24h */ case    5:  		/* bc 4, CR6_EQ, -80 */
		/* 82174A24h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821749D4;  }
		/* 82174A24h case    5:*/		return 0x82174A28;
	}
	return 0x82174A28;
} // Block from 82174A10h-82174A28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82174A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174A28);
		  /* 82174A28h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 82174A28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82174A28h case    0:*/		return 0x82174A2C;
		  /* 82174A2Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82174A2Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82174A2Ch case    1:*/		return 0x82174A30;
		  /* 82174A30h */ case    2:  		/* bc 4, CR0_EQ, 132 */
		/* 82174A30h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82174AB4;  }
		/* 82174A30h case    2:*/		return 0x82174A34;
		  /* 82174A34h */ case    3:  		/* lwz R11, <#[R19]> */
		/* 82174A34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82174A34h case    3:*/		return 0x82174A38;
		  /* 82174A38h */ case    4:  		/* b 112 */
		/* 82174A38h case    4:*/		return 0x82174AA8;
		/* 82174A38h case    4:*/		return 0x82174A3C;
		  /* 82174A3Ch */ case    5:  		/* lwz R8, <#[R11 + 8]> */
		/* 82174A3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82174A3Ch case    5:*/		return 0x82174A40;
		  /* 82174A40h */ case    6:  		/* rlwinm. R10, R8, 6, 31, 31 */
		/* 82174A40h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R8);
		/* 82174A40h case    6:*/		return 0x82174A44;
		  /* 82174A44h */ case    7:  		/* bc 4, CR0_EQ, 84 */
		/* 82174A44h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82174A98;  }
		/* 82174A44h case    7:*/		return 0x82174A48;
		  /* 82174A48h */ case    8:  		/* lwz R9, <#[R11 + 4]> */
		/* 82174A48h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82174A48h case    8:*/		return 0x82174A4C;
		  /* 82174A4Ch */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 82174A4Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82174A4Ch case    9:*/		return 0x82174A50;
		  /* 82174A50h */ case   10:  		/* bc 12, CR6_EQ, 72 */
		/* 82174A50h case   10:*/		if ( regs.CR[6].eq ) { return 0x82174A98;  }
		/* 82174A50h case   10:*/		return 0x82174A54;
		  /* 82174A54h */ case   11:  		/* lwz R10, <#[R9 + 16]> */
		/* 82174A54h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000010) );
		/* 82174A54h case   11:*/		return 0x82174A58;
		  /* 82174A58h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 82174A58h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82174A58h case   12:*/		return 0x82174A5C;
		  /* 82174A5Ch */ case   13:  		/* bc 12, CR6_EQ, 40 */
		/* 82174A5Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82174A84;  }
		/* 82174A5Ch case   13:*/		return 0x82174A60;
		  /* 82174A60h */ case   14:  		/* lwz R6, <#[R10 + 28]> */
		/* 82174A60h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000001C) );
		/* 82174A60h case   14:*/		return 0x82174A64;
		  /* 82174A64h */ case   15:  		/* cmplw CR6, R6, R20 */
		/* 82174A64h case   15:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R20);
		/* 82174A64h case   15:*/		return 0x82174A68;
		  /* 82174A68h */ case   16:  		/* bc 4, CR6_EQ, 28 */
		/* 82174A68h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82174A84;  }
		/* 82174A68h case   16:*/		return 0x82174A6C;
		  /* 82174A6Ch */ case   17:  		/* lwz R10, <#[R10 + 8]> */
		/* 82174A6Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82174A6Ch case   17:*/		return 0x82174A70;
		  /* 82174A70h */ case   18:  		/* rlwinm R6, R10, 0, 18, 24 */
		/* 82174A70h case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R6,regs.R10);
		/* 82174A70h case   18:*/		return 0x82174A74;
		  /* 82174A74h */ case   19:  		/* cmplwi CR6, R6, 14336 */
		/* 82174A74h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00003800);
		/* 82174A74h case   19:*/		return 0x82174A78;
		  /* 82174A78h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 82174A78h case   20:*/		if ( regs.CR[6].eq ) { return 0x82174A84;  }
		/* 82174A78h case   20:*/		return 0x82174A7C;
		  /* 82174A7Ch */ case   21:  		/* rlwinm. R10, R10, 6, 31, 31 */
		/* 82174A7Ch case   21:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R10);
		/* 82174A7Ch case   21:*/		return 0x82174A80;
		  /* 82174A80h */ case   22:  		/* bc 4, CR0_EQ, 12 */
		/* 82174A80h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82174A8C;  }
		/* 82174A80h case   22:*/		return 0x82174A84;
	}
	return 0x82174A84;
} // Block from 82174A28h-82174A84h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82174A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174A84);
		  /* 82174A84h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 82174A84h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82174A84h case    0:*/		return 0x82174A88;
		  /* 82174A88h */ case    1:  		/* b -60 */
		/* 82174A88h case    1:*/		return 0x82174A4C;
		/* 82174A88h case    1:*/		return 0x82174A8C;
	}
	return 0x82174A8C;
} // Block from 82174A84h-82174A8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174A8C);
		  /* 82174A8Ch */ case    0:  		/* oris R10, R8, 1024 */
		/* 82174A8Ch case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R8,0x400);
		/* 82174A8Ch case    0:*/		return 0x82174A90;
		  /* 82174A90h */ case    1:  		/* mr R7, R16 */
		/* 82174A90h case    1:*/		regs.R7 = regs.R16;
		/* 82174A90h case    1:*/		return 0x82174A94;
		  /* 82174A94h */ case    2:  		/* stw R10, <#[R11 + 8]> */
		/* 82174A94h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82174A94h case    2:*/		return 0x82174A98;
	}
	return 0x82174A98;
} // Block from 82174A8Ch-82174A98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174A98);
		  /* 82174A98h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174A98h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174A98h case    0:*/		return 0x82174A9C;
		  /* 82174A9Ch */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82174A9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82174A9Ch case    1:*/		return 0x82174AA0;
		  /* 82174AA0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82174AA0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82174AA0h case    2:*/		return 0x82174AA4;
		  /* 82174AA4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82174AA4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82174AB4;  }
		/* 82174AA4h case    3:*/		return 0x82174AA8;
	}
	return 0x82174AA8;
} // Block from 82174A98h-82174AA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82174AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174AA8);
		  /* 82174AA8h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174AA8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174AA8h case    0:*/		return 0x82174AAC;
		  /* 82174AACh */ case    1:  		/* addic. R11, R11, -40 */
		/* 82174AACh case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82174AACh case    1:*/		return 0x82174AB0;
		  /* 82174AB0h */ case    2:  		/* bc 4, CR0_EQ, -116 */
		/* 82174AB0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82174A3C;  }
		/* 82174AB0h case    2:*/		return 0x82174AB4;
	}
	return 0x82174AB4;
} // Block from 82174AA8h-82174AB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174AB4);
		  /* 82174AB4h */ case    0:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 82174AB4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 82174AB4h case    0:*/		return 0x82174AB8;
		  /* 82174AB8h */ case    1:  		/* bc 4, CR0_EQ, -252 */
		/* 82174AB8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821749BC;  }
		/* 82174AB8h case    1:*/		return 0x82174ABC;
		  /* 82174ABCh */ case    2:  		/* lwz R11, <#[R19 + 4]> */
		/* 82174ABCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82174ABCh case    2:*/		return 0x82174AC0;
		  /* 82174AC0h */ case    3:  		/* mr R26, R16 */
		/* 82174AC0h case    3:*/		regs.R26 = regs.R16;
		/* 82174AC0h case    3:*/		return 0x82174AC4;
		  /* 82174AC4h */ case    4:  		/* mr R28, R14 */
		/* 82174AC4h case    4:*/		regs.R28 = regs.R14;
		/* 82174AC4h case    4:*/		return 0x82174AC8;
	}
	return 0x82174AC8;
} // Block from 82174AB4h-82174AC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82174AC8h
// Function '?AddPendingInstructionToRegOptSolutionStep@Compiler@D3DXShader@@AAAXPAV?$ArrayList@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@2@PAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174AC8);
		  /* 82174AC8h */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82174AC8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82174AC8h case    0:*/		return 0x82174ACC;
		  /* 82174ACCh */ case    1:  		/* mr R23, R14 */
		/* 82174ACCh case    1:*/		regs.R23 = regs.R14;
		/* 82174ACCh case    1:*/		return 0x82174AD0;
		  /* 82174AD0h */ case    2:  		/* mr R21, R14 */
		/* 82174AD0h case    2:*/		regs.R21 = regs.R14;
		/* 82174AD0h case    2:*/		return 0x82174AD4;
		  /* 82174AD4h */ case    3:  		/* mr R22, R14 */
		/* 82174AD4h case    3:*/		regs.R22 = regs.R14;
		/* 82174AD4h case    3:*/		return 0x82174AD8;
		  /* 82174AD8h */ case    4:  		/* bc 4, CR0_EQ, 832 */
		/* 82174AD8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82174E18;  }
		/* 82174AD8h case    4:*/		return 0x82174ADC;
		  /* 82174ADCh */ case    5:  		/* lwz R11, <#[R19]> */
		/* 82174ADCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82174ADCh case    5:*/		return 0x82174AE0;
		  /* 82174AE0h */ case    6:  		/* b 812 */
		/* 82174AE0h case    6:*/		return 0x82174E0C;
		/* 82174AE0h case    6:*/		return 0x82174AE4;
		  /* 82174AE4h */ case    7:  		/* lwz R24, <#[R27 + 8]> */
		/* 82174AE4h case    7:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R27 + 0x00000008) );
		/* 82174AE4h case    7:*/		return 0x82174AE8;
		  /* 82174AE8h */ case    8:  		/* rlwinm. R11, R24, 6, 31, 31 */
		/* 82174AE8h case    8:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R24);
		/* 82174AE8h case    8:*/		return 0x82174AEC;
		  /* 82174AECh */ case    9:  		/* bc 12, CR0_EQ, 784 */
		/* 82174AECh case    9:*/		if ( regs.CR[0].eq ) { return 0x82174DFC;  }
		/* 82174AECh case    9:*/		return 0x82174AF0;
		  /* 82174AF0h */ case   10:  		/* stw R14, <#[R1 + 84]> */
		/* 82174AF0h case   10:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000054) );
		/* 82174AF0h case   10:*/		return 0x82174AF4;
		  /* 82174AF4h */ case   11:  		/* addi R8, R1, 80 */
		/* 82174AF4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82174AF4h case   11:*/		return 0x82174AF8;
		  /* 82174AF8h */ case   12:  		/* mr R7, R15 */
		/* 82174AF8h case   12:*/		regs.R7 = regs.R15;
		/* 82174AF8h case   12:*/		return 0x82174AFC;
		  /* 82174AFCh */ case   13:  		/* stb R14, <#[R1 + 80]> */
		/* 82174AFCh case   13:*/		cpu::mem::store8( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 82174AFCh case   13:*/		return 0x82174B00;
		  /* 82174B00h */ case   14:  		/* addi R6, R1, 84 */
		/* 82174B00h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 82174B00h case   14:*/		return 0x82174B04;
		  /* 82174B04h */ case   15:  		/* mr R5, R26 */
		/* 82174B04h case   15:*/		regs.R5 = regs.R26;
		/* 82174B04h case   15:*/		return 0x82174B08;
		  /* 82174B08h */ case   16:  		/* mr R4, R27 */
		/* 82174B08h case   16:*/		regs.R4 = regs.R27;
		/* 82174B08h case   16:*/		return 0x82174B0C;
		  /* 82174B0Ch */ case   17:  		/* mr R3, R18 */
		/* 82174B0Ch case   17:*/		regs.R3 = regs.R18;
		/* 82174B0Ch case   17:*/		return 0x82174B10;
		  /* 82174B10h */ case   18:  		/* bl -14456 */
		/* 82174B10h case   18:*/		regs.LR = 0x82174B14; return 0x82171298;
		/* 82174B10h case   18:*/		return 0x82174B14;
		  /* 82174B14h */ case   19:  		/* lbz R11, <#[R1 + 80]> */
		/* 82174B14h case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82174B14h case   19:*/		return 0x82174B18;
		  /* 82174B18h */ case   20:  		/* mr R25, R3 */
		/* 82174B18h case   20:*/		regs.R25 = regs.R3;
		/* 82174B18h case   20:*/		return 0x82174B1C;
		  /* 82174B1Ch */ case   21:  		/* mr R29, R11 */
		/* 82174B1Ch case   21:*/		regs.R29 = regs.R11;
		/* 82174B1Ch case   21:*/		return 0x82174B20;
		  /* 82174B20h */ case   22:  		/* mr R20, R11 */
		/* 82174B20h case   22:*/		regs.R20 = regs.R11;
		/* 82174B20h case   22:*/		return 0x82174B24;
		  /* 82174B24h */ case   23:  		/* cmplwi CR0, R11, 0 */
		/* 82174B24h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82174B24h case   23:*/		return 0x82174B28;
		  /* 82174B28h */ case   24:  		/* bc 4, CR0_EQ, 32 */
		/* 82174B28h case   24:*/		if ( !regs.CR[0].eq ) { return 0x82174B48;  }
		/* 82174B28h case   24:*/		return 0x82174B2C;
		  /* 82174B2Ch */ case   25:  		/* lwz R11, <#[R27 + 20]> */
		/* 82174B2Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 82174B2Ch case   25:*/		return 0x82174B30;
		  /* 82174B30h */ case   26:  		/* rlwinm. R10, R11, 0, 15, 18 */
		/* 82174B30h case   26:*/		cpu::op::rlwinm<1,0,15,18>(regs,&regs.R10,regs.R11);
		/* 82174B30h case   26:*/		return 0x82174B34;
		  /* 82174B34h */ case   27:  		/* bc 12, CR0_EQ, 20 */
		/* 82174B34h case   27:*/		if ( regs.CR[0].eq ) { return 0x82174B48;  }
		/* 82174B34h case   27:*/		return 0x82174B38;
		  /* 82174B38h */ case   28:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 82174B38h case   28:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 82174B38h case   28:*/		return 0x82174B3C;
		  /* 82174B3Ch */ case   29:  		/* cmplw CR6, R11, R15 */
		/* 82174B3Ch case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 82174B3Ch case   29:*/		return 0x82174B40;
		  /* 82174B40h */ case   30:  		/* bc 4, CR6_EQ, 8 */
		/* 82174B40h case   30:*/		if ( !regs.CR[6].eq ) { return 0x82174B48;  }
		/* 82174B40h case   30:*/		return 0x82174B44;
		  /* 82174B44h */ case   31:  		/* mr R29, R16 */
		/* 82174B44h case   31:*/		regs.R29 = regs.R16;
		/* 82174B44h case   31:*/		return 0x82174B48;
	}
	return 0x82174B48;
} // Block from 82174AC8h-82174B48h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82174B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174B48);
		  /* 82174B48h */ case    0:  		/* rlwinm. R10, R29, 0, 24, 31 */
		/* 82174B48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R29);
		/* 82174B48h case    0:*/		return 0x82174B4C;
		  /* 82174B4Ch */ case    1:  		/* bc 4, CR0_EQ, 172 */
		/* 82174B4Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82174BF8;  }
		/* 82174B4Ch case    1:*/		return 0x82174B50;
		  /* 82174B50h */ case    2:  		/* lwz R30, <#[R27 + 4]> */
		/* 82174B50h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000004) );
		/* 82174B50h case    2:*/		return 0x82174B54;
		  /* 82174B54h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82174B54h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82174B54h case    3:*/		return 0x82174B58;
		  /* 82174B58h */ case    4:  		/* bc 12, CR6_EQ, 160 */
		/* 82174B58h case    4:*/		if ( regs.CR[6].eq ) { return 0x82174BF8;  }
		/* 82174B58h case    4:*/		return 0x82174B5C;
		  /* 82174B5Ch */ case    5:  		/* lwz R11, <#[R30 + 16]> */
		/* 82174B5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82174B5Ch case    5:*/		return 0x82174B60;
		  /* 82174B60h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82174B60h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82174B60h case    6:*/		return 0x82174B64;
		  /* 82174B64h */ case    7:  		/* bc 12, CR6_EQ, 140 */
		/* 82174B64h case    7:*/		if ( regs.CR[6].eq ) { return 0x82174BF0;  }
		/* 82174B64h case    7:*/		return 0x82174B68;
		  /* 82174B68h */ case    8:  		/* lwz R9, <#[R30]> */
		/* 82174B68h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82174B68h case    8:*/		return 0x82174B6C;
		  /* 82174B6Ch */ case    9:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82174B6Ch case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82174B6Ch case    9:*/		return 0x82174B70;
		  /* 82174B70h */ case   10:  		/* bc 12, CR0_EQ, 128 */
		/* 82174B70h case   10:*/		if ( regs.CR[0].eq ) { return 0x82174BF0;  }
		/* 82174B70h case   10:*/		return 0x82174B74;
		  /* 82174B74h */ case   11:  		/* lwz R9, <#[R11 + 28]> */
		/* 82174B74h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 82174B74h case   11:*/		return 0x82174B78;
		  /* 82174B78h */ case   12:  		/* lwz R8, <#[R1 + 380]> */
		/* 82174B78h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000017C) );
		/* 82174B78h case   12:*/		return 0x82174B7C;
		  /* 82174B7Ch */ case   13:  		/* cmplw CR6, R9, R8 */
		/* 82174B7Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82174B7Ch case   13:*/		return 0x82174B80;
		  /* 82174B80h */ case   14:  		/* bc 4, CR6_EQ, 112 */
		/* 82174B80h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82174BF0;  }
		/* 82174B80h case   14:*/		return 0x82174B84;
		  /* 82174B84h */ case   15:  		/* lwz R9, <#[R11 + 8]> */
		/* 82174B84h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82174B84h case   15:*/		return 0x82174B88;
		  /* 82174B88h */ case   16:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82174B88h case   16:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82174B88h case   16:*/		return 0x82174B8C;
		  /* 82174B8Ch */ case   17:  		/* cmplwi CR6, R9, 14336 */
		/* 82174B8Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003800);
		/* 82174B8Ch case   17:*/		return 0x82174B90;
		  /* 82174B90h */ case   18:  		/* bc 12, CR6_EQ, 96 */
		/* 82174B90h case   18:*/		if ( regs.CR[6].eq ) { return 0x82174BF0;  }
		/* 82174B90h case   18:*/		return 0x82174B94;
		  /* 82174B94h */ case   19:  		/* lwz R31, <#[R11]> */
		/* 82174B94h case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82174B94h case   19:*/		return 0x82174B98;
		  /* 82174B98h */ case   20:  		/* cmplwi CR6, R31, 0 */
		/* 82174B98h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82174B98h case   20:*/		return 0x82174B9C;
		  /* 82174B9Ch */ case   21:  		/* bc 12, CR6_EQ, 76 */
		/* 82174B9Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82174BE8;  }
		/* 82174B9Ch case   21:*/		return 0x82174BA0;
		  /* 82174BA0h */ case   22:  		/* mr R3, R31 */
		/* 82174BA0h case   22:*/		regs.R3 = regs.R31;
		/* 82174BA0h case   22:*/		return 0x82174BA4;
		  /* 82174BA4h */ case   23:  		/* bl -66420 */
		/* 82174BA4h case   23:*/		regs.LR = 0x82174BA8; return 0x82164830;
		/* 82174BA4h case   23:*/		return 0x82174BA8;
		  /* 82174BA8h */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82174BA8h case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82174BA8h case   24:*/		return 0x82174BAC;
		  /* 82174BACh */ case   25:  		/* bc 12, CR0_EQ, 48 */
		/* 82174BACh case   25:*/		if ( regs.CR[0].eq ) { return 0x82174BDC;  }
		/* 82174BACh case   25:*/		return 0x82174BB0;
		  /* 82174BB0h */ case   26:  		/* lwz R11, <#[R31 + 12]> */
		/* 82174BB0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82174BB0h case   26:*/		return 0x82174BB4;
		  /* 82174BB4h */ case   27:  		/* lwz R10, <#[R1 + 380]> */
		/* 82174BB4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000017C) );
		/* 82174BB4h case   27:*/		return 0x82174BB8;
		  /* 82174BB8h */ case   28:  		/* lwz R9, <#[R11 + 28]> */
		/* 82174BB8h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 82174BB8h case   28:*/		return 0x82174BBC;
		  /* 82174BBCh */ case   29:  		/* cmplw CR6, R9, R10 */
		/* 82174BBCh case   29:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82174BBCh case   29:*/		return 0x82174BC0;
		  /* 82174BC0h */ case   30:  		/* bc 4, CR6_EQ, 28 */
		/* 82174BC0h case   30:*/		if ( !regs.CR[6].eq ) { return 0x82174BDC;  }
		/* 82174BC0h case   30:*/		return 0x82174BC4;
		  /* 82174BC4h */ case   31:  		/* lwz R11, <#[R11 + 20]> */
		/* 82174BC4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82174BC4h case   31:*/		return 0x82174BC8;
		  /* 82174BC8h */ case   32:  		/* rlwinm. R10, R11, 0, 15, 18 */
		/* 82174BC8h case   32:*/		cpu::op::rlwinm<1,0,15,18>(regs,&regs.R10,regs.R11);
		/* 82174BC8h case   32:*/		return 0x82174BCC;
		  /* 82174BCCh */ case   33:  		/* bc 12, CR0_EQ, 16 */
		/* 82174BCCh case   33:*/		if ( regs.CR[0].eq ) { return 0x82174BDC;  }
		/* 82174BCCh case   33:*/		return 0x82174BD0;
		  /* 82174BD0h */ case   34:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 82174BD0h case   34:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 82174BD0h case   34:*/		return 0x82174BD4;
		  /* 82174BD4h */ case   35:  		/* cmplw CR6, R11, R15 */
		/* 82174BD4h case   35:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 82174BD4h case   35:*/		return 0x82174BD8;
		  /* 82174BD8h */ case   36:  		/* bc 12, CR6_EQ, 12 */
		/* 82174BD8h case   36:*/		if ( regs.CR[6].eq ) { return 0x82174BE4;  }
		/* 82174BD8h case   36:*/		return 0x82174BDC;
	}
	return 0x82174BDC;
} // Block from 82174B48h-82174BDCh (37 instructions)

//////////////////////////////////////////////////////
// Block at 82174BDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174BDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174BDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174BDC);
		  /* 82174BDCh */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 82174BDCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 82174BDCh case    0:*/		return 0x82174BE0;
		  /* 82174BE0h */ case    1:  		/* b -72 */
		/* 82174BE0h case    1:*/		return 0x82174B98;
		/* 82174BE0h case    1:*/		return 0x82174BE4;
	}
	return 0x82174BE4;
} // Block from 82174BDCh-82174BE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174BE4);
		  /* 82174BE4h */ case    0:  		/* mr R29, R16 */
		/* 82174BE4h case    0:*/		regs.R29 = regs.R16;
		/* 82174BE4h case    0:*/		return 0x82174BE8;
	}
	return 0x82174BE8;
} // Block from 82174BE4h-82174BE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174BE8);
		  /* 82174BE8h */ case    0:  		/* rlwinm. R10, R29, 0, 24, 31 */
		/* 82174BE8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R29);
		/* 82174BE8h case    0:*/		return 0x82174BEC;
		  /* 82174BECh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82174BECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82174BF8;  }
		/* 82174BECh case    1:*/		return 0x82174BF0;
	}
	return 0x82174BF0;
} // Block from 82174BE8h-82174BF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174BF0);
		  /* 82174BF0h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82174BF0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82174BF0h case    0:*/		return 0x82174BF4;
		  /* 82174BF4h */ case    1:  		/* b -160 */
		/* 82174BF4h case    1:*/		return 0x82174B54;
		/* 82174BF4h case    1:*/		return 0x82174BF8;
	}
	return 0x82174BF8;
} // Block from 82174BF0h-82174BF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174BF8);
		  /* 82174BF8h */ case    0:  		/* lwz R30, <#[R1 + 84]> */
		/* 82174BF8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 82174BF8h case    0:*/		return 0x82174BFC;
		  /* 82174BFCh */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82174BFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82174BFCh case    1:*/		return 0x82174C00;
		  /* 82174C00h */ case    2:  		/* bc 4, CR6_EQ, 60 */
		/* 82174C00h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82174C3C;  }
		/* 82174C00h case    2:*/		return 0x82174C04;
		  /* 82174C04h */ case    3:  		/* rlwinm R11, R15, 30, 2, 31 */
		/* 82174C04h case    3:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R15);
		/* 82174C04h case    3:*/		return 0x82174C08;
		  /* 82174C08h */ case    4:  		/* cmplw CR6, R22, R11 */
		/* 82174C08h case    4:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82174C08h case    4:*/		return 0x82174C0C;
		  /* 82174C0Ch */ case    5:  		/* bc 4, CR6_LT, 44 */
		/* 82174C0Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x82174C38;  }
		/* 82174C0Ch case    5:*/		return 0x82174C10;
		  /* 82174C10h */ case    6:  		/* cmpwi CR6, R30, 0 */
		/* 82174C10h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82174C10h case    6:*/		return 0x82174C14;
		  /* 82174C14h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 82174C14h case    7:*/		if ( regs.CR[6].eq ) { return 0x82174C3C;  }
		/* 82174C14h case    7:*/		return 0x82174C18;
		  /* 82174C18h */ case    8:  		/* cmpw CR6, R25, R28 */
		/* 82174C18h case    8:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R28);
		/* 82174C18h case    8:*/		return 0x82174C1C;
		  /* 82174C1Ch */ case    9:  		/* bc 12, CR6_GT, 28 */
		/* 82174C1Ch case    9:*/		if ( regs.CR[6].gt ) { return 0x82174C38;  }
		/* 82174C1Ch case    9:*/		return 0x82174C20;
		  /* 82174C20h */ case   10:  		/* neg R11, R15 */
		/* 82174C20h case   10:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R15);
		/* 82174C20h case   10:*/		return 0x82174C24;
		  /* 82174C24h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82174C24h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82174C24h case   11:*/		return 0x82174C28;
		  /* 82174C28h */ case   12:  		/* srawi R11, R11, 3 */
		/* 82174C28h case   12:*/		cpu::op::srawi<0,3>(regs,&regs.R11,regs.R11);
		/* 82174C28h case   12:*/		return 0x82174C2C;
		  /* 82174C2Ch */ case   13:  		/* addze R11, R11 */
		/* 82174C2Ch case   13:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 82174C2Ch case   13:*/		return 0x82174C30;
		  /* 82174C30h */ case   14:  		/* cmpw CR6, R25, R11 */
		/* 82174C30h case   14:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R11);
		/* 82174C30h case   14:*/		return 0x82174C34;
		  /* 82174C34h */ case   15:  		/* bc 4, CR6_LT, 8 */
		/* 82174C34h case   15:*/		if ( !regs.CR[6].lt ) { return 0x82174C3C;  }
		/* 82174C34h case   15:*/		return 0x82174C38;
	}
	return 0x82174C38;
} // Block from 82174BF8h-82174C38h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82174C38h
// Function '?ReducePeakRegisterUsageInBlock@Compiler@D3DXShader@@AAA_NPAVBlock@2@PAVInfiniteLocalRegisterSet@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174C38);
		  /* 82174C38h */ case    0:  		/* mr R29, R16 */
		/* 82174C38h case    0:*/		regs.R29 = regs.R16;
		/* 82174C38h case    0:*/		return 0x82174C3C;
	}
	return 0x82174C3C;
} // Block from 82174C38h-82174C3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174C3C);
		  /* 82174C3Ch */ case    0:  		/* mr R3, R27 */
		/* 82174C3Ch case    0:*/		regs.R3 = regs.R27;
		/* 82174C3Ch case    0:*/		return 0x82174C40;
		  /* 82174C40h */ case    1:  		/* bl -24392 */
		/* 82174C40h case    1:*/		regs.LR = 0x82174C44; return 0x8216ECF8;
		/* 82174C40h case    1:*/		return 0x82174C44;
		  /* 82174C44h */ case    2:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82174C44h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82174C44h case    2:*/		return 0x82174C48;
		  /* 82174C48h */ case    3:  		/* mr R31, R3 */
		/* 82174C48h case    3:*/		regs.R31 = regs.R3;
		/* 82174C48h case    3:*/		return 0x82174C4C;
		  /* 82174C4Ch */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 82174C4Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x82174C6C;  }
		/* 82174C4Ch case    4:*/		return 0x82174C50;
		  /* 82174C50h */ case    5:  		/* cmpwi CR6, R21, 0 */
		/* 82174C50h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82174C50h case    5:*/		return 0x82174C54;
		  /* 82174C54h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82174C54h case    6:*/		if ( regs.CR[6].eq ) { return 0x82174C6C;  }
		/* 82174C54h case    6:*/		return 0x82174C58;
		  /* 82174C58h */ case    7:  		/* cmpwi CR6, R3, 0 */
		/* 82174C58h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82174C58h case    7:*/		return 0x82174C5C;
		  /* 82174C5Ch */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82174C5Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82174C6C;  }
		/* 82174C5Ch case    8:*/		return 0x82174C60;
		  /* 82174C60h */ case    9:  		/* cmpw CR6, R21, R3 */
		/* 82174C60h case    9:*/		cpu::op::cmpw<6>(regs,regs.R21,regs.R3);
		/* 82174C60h case    9:*/		return 0x82174C64;
		  /* 82174C64h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 82174C64h case   10:*/		if ( regs.CR[6].eq ) { return 0x82174C6C;  }
		/* 82174C64h case   10:*/		return 0x82174C68;
		  /* 82174C68h */ case   11:  		/* mr R29, R16 */
		/* 82174C68h case   11:*/		regs.R29 = regs.R16;
		/* 82174C68h case   11:*/		return 0x82174C6C;
	}
	return 0x82174C6C;
} // Block from 82174C3Ch-82174C6Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82174C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174C6C);
		  /* 82174C6Ch */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82174C6Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82174C6Ch case    0:*/		return 0x82174C70;
		  /* 82174C70h */ case    1:  		/* bc 4, CR0_EQ, 136 */
		/* 82174C70h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82174CF8;  }
		/* 82174C70h case    1:*/		return 0x82174C74;
		  /* 82174C74h */ case    2:  		/* lwz R10, <#[R27 + 4]> */
		/* 82174C74h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 82174C74h case    2:*/		return 0x82174C78;
		  /* 82174C78h */ case    3:  		/* mr R9, R14 */
		/* 82174C78h case    3:*/		regs.R9 = regs.R14;
		/* 82174C78h case    3:*/		return 0x82174C7C;
		  /* 82174C7Ch */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 82174C7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82174C7Ch case    4:*/		return 0x82174C80;
		  /* 82174C80h */ case    5:  		/* bc 12, CR6_EQ, 120 */
		/* 82174C80h case    5:*/		if ( regs.CR[6].eq ) { return 0x82174CF8;  }
		/* 82174C80h case    5:*/		return 0x82174C84;
		  /* 82174C84h */ case    6:  		/* lwz R11, <#[R10 + 16]> */
		/* 82174C84h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82174C84h case    6:*/		return 0x82174C88;
		  /* 82174C88h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82174C88h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82174C88h case    7:*/		return 0x82174C8C;
		  /* 82174C8Ch */ case    8:  		/* bc 12, CR6_EQ, 96 */
		/* 82174C8Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82174CEC;  }
		/* 82174C8Ch case    8:*/		return 0x82174C90;
		  /* 82174C90h */ case    9:  		/* lwz R8, <#[R10]> */
		/* 82174C90h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82174C90h case    9:*/		return 0x82174C94;
		  /* 82174C94h */ case   10:  		/* rlwinm. R8, R8, 0, 4, 6 */
		/* 82174C94h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R8);
		/* 82174C94h case   10:*/		return 0x82174C98;
		  /* 82174C98h */ case   11:  		/* bc 12, CR0_EQ, 84 */
		/* 82174C98h case   11:*/		if ( regs.CR[0].eq ) { return 0x82174CEC;  }
		/* 82174C98h case   11:*/		return 0x82174C9C;
		  /* 82174C9Ch */ case   12:  		/* lwz R8, <#[R11 + 28]> */
		/* 82174C9Ch case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000001C) );
		/* 82174C9Ch case   12:*/		return 0x82174CA0;
		  /* 82174CA0h */ case   13:  		/* lwz R7, <#[R1 + 380]> */
		/* 82174CA0h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000017C) );
		/* 82174CA0h case   13:*/		return 0x82174CA4;
		  /* 82174CA4h */ case   14:  		/* cmplw CR6, R8, R7 */
		/* 82174CA4h case   14:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 82174CA4h case   14:*/		return 0x82174CA8;
		  /* 82174CA8h */ case   15:  		/* bc 4, CR6_EQ, 68 */
		/* 82174CA8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82174CEC;  }
		/* 82174CA8h case   15:*/		return 0x82174CAC;
		  /* 82174CACh */ case   16:  		/* lwz R8, <#[R11 + 8]> */
		/* 82174CACh case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82174CACh case   16:*/		return 0x82174CB0;
		  /* 82174CB0h */ case   17:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 82174CB0h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 82174CB0h case   17:*/		return 0x82174CB4;
		  /* 82174CB4h */ case   18:  		/* cmplwi CR6, R8, 14336 */
		/* 82174CB4h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00003800);
		/* 82174CB4h case   18:*/		return 0x82174CB8;
		  /* 82174CB8h */ case   19:  		/* bc 12, CR6_EQ, 52 */
		/* 82174CB8h case   19:*/		if ( regs.CR[6].eq ) { return 0x82174CEC;  }
		/* 82174CB8h case   19:*/		return 0x82174CBC;
		  /* 82174CBCh */ case   20:  		/* lwz R8, <#[R11 + 20]> */
		/* 82174CBCh case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82174CBCh case   20:*/		return 0x82174CC0;
		  /* 82174CC0h */ case   21:  		/* lwz R11, <#[R11 + 16]> */
		/* 82174CC0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82174CC0h case   21:*/		return 0x82174CC4;
		  /* 82174CC4h */ case   22:  		/* rlwimi R11, R8, 27, 5, 31 */
		/* 82174CC4h case   22:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R11,regs.R8);
		/* 82174CC4h case   22:*/		return 0x82174CC8;
		  /* 82174CC8h */ case   23:  		/* rlwinm R11, R11, 12, 21, 31 */
		/* 82174CC8h case   23:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R11,regs.R11);
		/* 82174CC8h case   23:*/		return 0x82174CCC;
		  /* 82174CCCh */ case   24:  		/* cmplw CR6, R11, R26 */
		/* 82174CCCh case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82174CCCh case   24:*/		return 0x82174CD0;
		  /* 82174CD0h */ case   25:  		/* bc 12, CR6_EQ, 28 */
		/* 82174CD0h case   25:*/		if ( regs.CR[6].eq ) { return 0x82174CEC;  }
		/* 82174CD0h case   25:*/		return 0x82174CD4;
		  /* 82174CD4h */ case   26:  		/* cmplwi CR6, R9, 0 */
		/* 82174CD4h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82174CD4h case   26:*/		return 0x82174CD8;
		  /* 82174CD8h */ case   27:  		/* bc 4, CR6_EQ, 12 */
		/* 82174CD8h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82174CE4;  }
		/* 82174CD8h case   27:*/		return 0x82174CDC;
		  /* 82174CDCh */ case   28:  		/* mr R9, R11 */
		/* 82174CDCh case   28:*/		regs.R9 = regs.R11;
		/* 82174CDCh case   28:*/		return 0x82174CE0;
		  /* 82174CE0h */ case   29:  		/* b 12 */
		/* 82174CE0h case   29:*/		return 0x82174CEC;
		/* 82174CE0h case   29:*/		return 0x82174CE4;
	}
	return 0x82174CE4;
} // Block from 82174C6Ch-82174CE4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82174CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174CE4);
		  /* 82174CE4h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82174CE4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82174CE4h case    0:*/		return 0x82174CE8;
		  /* 82174CE8h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82174CE8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82174CF4;  }
		/* 82174CE8h case    1:*/		return 0x82174CEC;
	}
	return 0x82174CEC;
} // Block from 82174CE4h-82174CECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174CEC);
		  /* 82174CECh */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82174CECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82174CECh case    0:*/		return 0x82174CF0;
		  /* 82174CF0h */ case    1:  		/* b -116 */
		/* 82174CF0h case    1:*/		return 0x82174C7C;
		/* 82174CF0h case    1:*/		return 0x82174CF4;
	}
	return 0x82174CF4;
} // Block from 82174CECh-82174CF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174CF4);
		  /* 82174CF4h */ case    0:  		/* mr R29, R16 */
		/* 82174CF4h case    0:*/		regs.R29 = regs.R16;
		/* 82174CF4h case    0:*/		return 0x82174CF8;
	}
	return 0x82174CF8;
} // Block from 82174CF4h-82174CF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174CF8);
		  /* 82174CF8h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82174CF8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82174CF8h case    0:*/		return 0x82174CFC;
		  /* 82174CFCh */ case    1:  		/* bc 4, CR0_EQ, 92 */
		/* 82174CFCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82174D58;  }
		/* 82174CFCh case    1:*/		return 0x82174D00;
		  /* 82174D00h */ case    2:  		/* rlwinm R11, R24, 25, 25, 31 */
		/* 82174D00h case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R24);
		/* 82174D00h case    2:*/		return 0x82174D04;
		  /* 82174D04h */ case    3:  		/* cmpwi CR6, R11, 3 */
		/* 82174D04h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82174D04h case    3:*/		return 0x82174D08;
		  /* 82174D08h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 82174D08h case    4:*/		if ( regs.CR[6].eq ) { return 0x82174D3C;  }
		/* 82174D08h case    4:*/		return 0x82174D0C;
		  /* 82174D0Ch */ case    5:  		/* cmpwi CR6, R11, 37 */
		/* 82174D0Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000025);
		/* 82174D0Ch case    5:*/		return 0x82174D10;
		  /* 82174D10h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82174D10h case    6:*/		if ( regs.CR[6].eq ) { return 0x82174D20;  }
		/* 82174D10h case    6:*/		return 0x82174D14;
		  /* 82174D14h */ case    7:  		/* cmpwi CR6, R11, 110 */
		/* 82174D14h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 82174D14h case    7:*/		return 0x82174D18;
		  /* 82174D18h */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 82174D18h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82174D58;  }
		/* 82174D18h case    8:*/		return 0x82174D1C;
		  /* 82174D1Ch */ case    9:  		/* b 52 */
		/* 82174D1Ch case    9:*/		return 0x82174D50;
		/* 82174D1Ch case    9:*/		return 0x82174D20;
	}
	return 0x82174D20;
} // Block from 82174CF8h-82174D20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82174D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174D20);
		  /* 82174D20h */ case    0:  		/* lwz R11, <#[R27 + 44]> */
		/* 82174D20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 82174D20h case    0:*/		return 0x82174D24;
		  /* 82174D24h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 82174D24h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82174D24h case    1:*/		return 0x82174D28;
		  /* 82174D28h */ case    2:  		/* rlwinm R10, R11, 30, 2, 31 */
		/* 82174D28h case    2:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R11);
		/* 82174D28h case    2:*/		return 0x82174D2C;
		  /* 82174D2Ch */ case    3:  		/* xor R11, R10, R11 */
		/* 82174D2Ch case    3:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82174D2Ch case    3:*/		return 0x82174D30;
		  /* 82174D30h */ case    4:  		/* rlwinm. R11, R11, 0, 25, 26 */
		/* 82174D30h case    4:*/		cpu::op::rlwinm<1,0,25,26>(regs,&regs.R11,regs.R11);
		/* 82174D30h case    4:*/		return 0x82174D34;
		  /* 82174D34h */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 82174D34h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82174D58;  }
		/* 82174D34h case    5:*/		return 0x82174D38;
		  /* 82174D38h */ case    6:  		/* b 24 */
		/* 82174D38h case    6:*/		return 0x82174D50;
		/* 82174D38h case    6:*/		return 0x82174D3C;
	}
	return 0x82174D3C;
} // Block from 82174D20h-82174D3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82174D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174D3C);
		  /* 82174D3Ch */ case    0:  		/* lwz R4, <#[R27 + 48]> */
		/* 82174D3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000030) );
		/* 82174D3Ch case    0:*/		return 0x82174D40;
		  /* 82174D40h */ case    1:  		/* lwz R3, <#[R27 + 44]> */
		/* 82174D40h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x0000002C) );
		/* 82174D40h case    1:*/		return 0x82174D44;
		  /* 82174D44h */ case    2:  		/* bl -68284 */
		/* 82174D44h case    2:*/		regs.LR = 0x82174D48; return 0x82164288;
		/* 82174D44h case    2:*/		return 0x82174D48;
		  /* 82174D48h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82174D48h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82174D48h case    3:*/		return 0x82174D4C;
		  /* 82174D4Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82174D4Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82174D58;  }
		/* 82174D4Ch case    4:*/		return 0x82174D50;
	}
	return 0x82174D50;
} // Block from 82174D3Ch-82174D50h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82174D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174D50);
		  /* 82174D50h */ case    0:  		/* mr R29, R16 */
		/* 82174D50h case    0:*/		regs.R29 = regs.R16;
		/* 82174D50h case    0:*/		return 0x82174D54;
		  /* 82174D54h */ case    1:  		/* mr R20, R16 */
		/* 82174D54h case    1:*/		regs.R20 = regs.R16;
		/* 82174D54h case    1:*/		return 0x82174D58;
	}
	return 0x82174D58;
} // Block from 82174D50h-82174D58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82174D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174D58);
		  /* 82174D58h */ case    0:  		/* lwz R11, <#[R18 + 52]> */
		/* 82174D58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000034) );
		/* 82174D58h case    0:*/		return 0x82174D5C;
		  /* 82174D5Ch */ case    1:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82174D5Ch case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82174D5Ch case    1:*/		return 0x82174D60;
		  /* 82174D60h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82174D60h case    2:*/		if ( regs.CR[0].eq ) { return 0x82174D6C;  }
		/* 82174D60h case    2:*/		return 0x82174D64;
		  /* 82174D64h */ case    3:  		/* mr R29, R16 */
		/* 82174D64h case    3:*/		regs.R29 = regs.R16;
		/* 82174D64h case    3:*/		return 0x82174D68;
		  /* 82174D68h */ case    4:  		/* mr R20, R16 */
		/* 82174D68h case    4:*/		regs.R20 = regs.R16;
		/* 82174D68h case    4:*/		return 0x82174D6C;
	}
	return 0x82174D6C;
} // Block from 82174D58h-82174D6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82174D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174D6C);
		  /* 82174D6Ch */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 82174D6Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82174D6Ch case    0:*/		return 0x82174D70;
		  /* 82174D70h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 82174D70h case    1:*/		if ( regs.CR[6].eq ) { return 0x82174D98;  }
		/* 82174D70h case    1:*/		return 0x82174D74;
		  /* 82174D74h */ case    2:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82174D74h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82174D74h case    2:*/		return 0x82174D78;
		  /* 82174D78h */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 82174D78h case    3:*/		if ( regs.CR[0].eq ) { return 0x82174D98;  }
		/* 82174D78h case    3:*/		return 0x82174D7C;
		  /* 82174D7Ch */ case    4:  		/* cmplwi CR6, R26, 2047 */
		/* 82174D7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x000007FF);
		/* 82174D7Ch case    4:*/		return 0x82174D80;
		  /* 82174D80h */ case    5:  		/* bc 4, CR6_LT, 184 */
		/* 82174D80h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82174E38;  }
		/* 82174D80h case    5:*/		return 0x82174D84;
		  /* 82174D84h */ case    6:  		/* addi R26, R26, 1 */
		/* 82174D84h case    6:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82174D84h case    6:*/		return 0x82174D88;
		  /* 82174D88h */ case    7:  		/* mr R23, R14 */
		/* 82174D88h case    7:*/		regs.R23 = regs.R14;
		/* 82174D88h case    7:*/		return 0x82174D8C;
		  /* 82174D8Ch */ case    8:  		/* mr R22, R14 */
		/* 82174D8Ch case    8:*/		regs.R22 = regs.R14;
		/* 82174D8Ch case    8:*/		return 0x82174D90;
		  /* 82174D90h */ case    9:  		/* mr R25, R30 */
		/* 82174D90h case    9:*/		regs.R25 = regs.R30;
		/* 82174D90h case    9:*/		return 0x82174D94;
		  /* 82174D94h */ case   10:  		/* mr R21, R31 */
		/* 82174D94h case   10:*/		regs.R21 = regs.R31;
		/* 82174D94h case   10:*/		return 0x82174D98;
	}
	return 0x82174D98;
} // Block from 82174D6Ch-82174D98h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82174D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174D98);
		  /* 82174D98h */ case    0:  		/* lwz R11, <#[R27 + 16]> */
		/* 82174D98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82174D98h case    0:*/		return 0x82174D9C;
		  /* 82174D9Ch */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 82174D9Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82174D9Ch case    1:*/		return 0x82174DA0;
		  /* 82174DA0h */ case    2:  		/* lwz R10, <#[R27 + 20]> */
		/* 82174DA0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 82174DA0h case    2:*/		return 0x82174DA4;
		  /* 82174DA4h */ case    3:  		/* rlwimi R11, R26, 20, 1, 4 */
		/* 82174DA4h case    3:*/		cpu::op::rlwimi<0,20,1,4>(regs,&regs.R11,regs.R26);
		/* 82174DA4h case    3:*/		return 0x82174DA8;
		  /* 82174DA8h */ case    4:  		/* rlwimi R10, R26, 25, 0, 6 */
		/* 82174DA8h case    4:*/		cpu::op::rlwimi<0,25,0,6>(regs,&regs.R10,regs.R26);
		/* 82174DA8h case    4:*/		return 0x82174DAC;
		  /* 82174DACh */ case    5:  		/* stw R11, <#[R27 + 16]> */
		/* 82174DACh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82174DACh case    5:*/		return 0x82174DB0;
		  /* 82174DB0h */ case    6:  		/* stw R10, <#[R27 + 20]> */
		/* 82174DB0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 82174DB0h case    6:*/		return 0x82174DB4;
		  /* 82174DB4h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 82174DB4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82174DBC;  }
		/* 82174DB4h case    7:*/		return 0x82174DB8;
		  /* 82174DB8h */ case    8:  		/* stw R27, <#[R23 + 32]> */
		/* 82174DB8h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R23 + 0x00000020) );
		/* 82174DB8h case    8:*/		return 0x82174DBC;
	}
	return 0x82174DBC;
} // Block from 82174D98h-82174DBCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82174DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174DBC);
		  /* 82174DBCh */ case    0:  		/* mr R23, R27 */
		/* 82174DBCh case    0:*/		regs.R23 = regs.R27;
		/* 82174DBCh case    0:*/		return 0x82174DC0;
		  /* 82174DC0h */ case    1:  		/* addi R22, R22, 1 */
		/* 82174DC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82174DC0h case    1:*/		return 0x82174DC4;
		  /* 82174DC4h */ case    2:  		/* mr R28, R25 */
		/* 82174DC4h case    2:*/		regs.R28 = regs.R25;
		/* 82174DC4h case    2:*/		return 0x82174DC8;
		  /* 82174DC8h */ case    3:  		/* cmpwi CR6, R21, 0 */
		/* 82174DC8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82174DC8h case    3:*/		return 0x82174DCC;
		  /* 82174DCCh */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82174DCCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x82174DD4;  }
		/* 82174DCCh case    4:*/		return 0x82174DD0;
		  /* 82174DD0h */ case    5:  		/* mr R21, R31 */
		/* 82174DD0h case    5:*/		regs.R21 = regs.R31;
		/* 82174DD0h case    5:*/		return 0x82174DD4;
	}
	return 0x82174DD4;
} // Block from 82174DBCh-82174DD4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82174DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174DD4);
		  /* 82174DD4h */ case    0:  		/* rlwinm. R11, R20, 0, 24, 31 */
		/* 82174DD4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R20);
		/* 82174DD4h case    0:*/		return 0x82174DD8;
		  /* 82174DD8h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 82174DD8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82174DF8;  }
		/* 82174DD8h case    1:*/		return 0x82174DDC;
		  /* 82174DDCh */ case    2:  		/* cmplwi CR6, R26, 2047 */
		/* 82174DDCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x000007FF);
		/* 82174DDCh case    2:*/		return 0x82174DE0;
		  /* 82174DE0h */ case    3:  		/* bc 4, CR6_LT, 100 */
		/* 82174DE0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82174E44;  }
		/* 82174DE0h case    3:*/		return 0x82174DE4;
		  /* 82174DE4h */ case    4:  		/* addi R26, R26, 1 */
		/* 82174DE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82174DE4h case    4:*/		return 0x82174DE8;
		  /* 82174DE8h */ case    5:  		/* mr R23, R14 */
		/* 82174DE8h case    5:*/		regs.R23 = regs.R14;
		/* 82174DE8h case    5:*/		return 0x82174DEC;
		  /* 82174DECh */ case    6:  		/* mr R22, R14 */
		/* 82174DECh case    6:*/		regs.R22 = regs.R14;
		/* 82174DECh case    6:*/		return 0x82174DF0;
		  /* 82174DF0h */ case    7:  		/* mr R28, R14 */
		/* 82174DF0h case    7:*/		regs.R28 = regs.R14;
		/* 82174DF0h case    7:*/		return 0x82174DF4;
		  /* 82174DF4h */ case    8:  		/* mr R21, R14 */
		/* 82174DF4h case    8:*/		regs.R21 = regs.R14;
		/* 82174DF4h case    8:*/		return 0x82174DF8;
	}
	return 0x82174DF8;
} // Block from 82174DD4h-82174DF8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82174DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174DF8);
		  /* 82174DF8h */ case    0:  		/* lwz R20, <#[R1 + 380]> */
		/* 82174DF8h case    0:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000017C) );
		/* 82174DF8h case    0:*/		return 0x82174DFC;
	}
	return 0x82174DFC;
} // Block from 82174DF8h-82174DFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174DFC);
		  /* 82174DFCh */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 82174DFCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 82174DFCh case    0:*/		return 0x82174E00;
		  /* 82174E00h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82174E00h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82174E00h case    1:*/		return 0x82174E04;
		  /* 82174E04h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82174E04h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82174E04h case    2:*/		return 0x82174E08;
		  /* 82174E08h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82174E08h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82174E18;  }
		/* 82174E08h case    3:*/		return 0x82174E0C;
	}
	return 0x82174E0C;
} // Block from 82174DFCh-82174E0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82174E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174E0C);
		  /* 82174E0Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82174E0Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82174E0Ch case    0:*/		return 0x82174E10;
		  /* 82174E10h */ case    1:  		/* addic. R27, R11, -40 */
		/* 82174E10h case    1:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R11,0xFFFFFFD8);
		/* 82174E10h case    1:*/		return 0x82174E14;
		  /* 82174E14h */ case    2:  		/* bc 4, CR0_EQ, -816 */
		/* 82174E14h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82174AE4;  }
		/* 82174E14h case    2:*/		return 0x82174E18;
	}
	return 0x82174E18;
} // Block from 82174E0Ch-82174E18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174E18);
		  /* 82174E18h */ case    0:  		/* rlwinm R31, R26, 2, 0, 29 */
		/* 82174E18h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R26);
		/* 82174E18h case    0:*/		return 0x82174E1C;
		  /* 82174E1Ch */ case    1:  		/* addi R30, R18, 972 */
		/* 82174E1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R18,0x3CC);
		/* 82174E1Ch case    1:*/		return 0x82174E20;
		  /* 82174E20h */ case    2:  		/* cmplwi CR6, R31, 132 */
		/* 82174E20h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000084);
		/* 82174E20h case    2:*/		return 0x82174E24;
		  /* 82174E24h */ case    3:  		/* bc 4, CR6_GT, 44 */
		/* 82174E24h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82174E50;  }
		/* 82174E24h case    3:*/		return 0x82174E28;
		  /* 82174E28h */ case    4:  		/* mr R4, R31 */
		/* 82174E28h case    4:*/		regs.R4 = regs.R31;
		/* 82174E28h case    4:*/		return 0x82174E2C;
		  /* 82174E2Ch */ case    5:  		/* mr R3, R30 */
		/* 82174E2Ch case    5:*/		regs.R3 = regs.R30;
		/* 82174E2Ch case    5:*/		return 0x82174E30;
		  /* 82174E30h */ case    6:  		/* bl -65312 */
		/* 82174E30h case    6:*/		regs.LR = 0x82174E34; return 0x82164F10;
		/* 82174E30h case    6:*/		return 0x82174E34;
		  /* 82174E34h */ case    7:  		/* b 132 */
		/* 82174E34h case    7:*/		return 0x82174EB8;
		/* 82174E34h case    7:*/		return 0x82174E38;
	}
	return 0x82174E38;
} // Block from 82174E18h-82174E38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82174E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174E38);
		  /* 82174E38h */ case    0:  		/* li R4, 3641 */
		/* 82174E38h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE39);
		/* 82174E38h case    0:*/		return 0x82174E3C;
		  /* 82174E3Ch */ case    1:  		/* mr R3, R18 */
		/* 82174E3Ch case    1:*/		regs.R3 = regs.R18;
		/* 82174E3Ch case    1:*/		return 0x82174E40;
		  /* 82174E40h */ case    2:  		/* bl -143320 */
		/* 82174E40h case    2:*/		regs.LR = 0x82174E44; return 0x82151E68;
		/* 82174E40h case    2:*/		return 0x82174E44;
	}
	return 0x82174E44;
} // Block from 82174E38h-82174E44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174E44);
		  /* 82174E44h */ case    0:  		/* li R4, 3641 */
		/* 82174E44h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE39);
		/* 82174E44h case    0:*/		return 0x82174E48;
		  /* 82174E48h */ case    1:  		/* mr R3, R18 */
		/* 82174E48h case    1:*/		regs.R3 = regs.R18;
		/* 82174E48h case    1:*/		return 0x82174E4C;
		  /* 82174E4Ch */ case    2:  		/* bl -143332 */
		/* 82174E4Ch case    2:*/		regs.LR = 0x82174E50; return 0x82151E68;
		/* 82174E4Ch case    2:*/		return 0x82174E50;
	}
	return 0x82174E50;
} // Block from 82174E44h-82174E50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174E50);
		  /* 82174E50h */ case    0:  		/* lwz R10, <#[R30 + 140]> */
		/* 82174E50h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000008C) );
		/* 82174E50h case    0:*/		return 0x82174E54;
		  /* 82174E54h */ case    1:  		/* lwz R11, <#[R30 + 144]> */
		/* 82174E54h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000090) );
		/* 82174E54h case    1:*/		return 0x82174E58;
		  /* 82174E58h */ case    2:  		/* subf R10, R11, R10 */
		/* 82174E58h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82174E58h case    2:*/		return 0x82174E5C;
		  /* 82174E5Ch */ case    3:  		/* addi R10, R10, 4096 */
		/* 82174E5Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 82174E5Ch case    3:*/		return 0x82174E60;
		  /* 82174E60h */ case    4:  		/* cmplw CR6, R10, R31 */
		/* 82174E60h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82174E60h case    4:*/		return 0x82174E64;
		  /* 82174E64h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 82174E64h case    5:*/		if ( regs.CR[6].lt ) { return 0x82174E74;  }
		/* 82174E64h case    5:*/		return 0x82174E68;
		  /* 82174E68h */ case    6:  		/* add R10, R11, R31 */
		/* 82174E68h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 82174E68h case    6:*/		return 0x82174E6C;
		  /* 82174E6Ch */ case    7:  		/* stw R10, <#[R30 + 144]> */
		/* 82174E6Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000090) );
		/* 82174E6Ch case    7:*/		return 0x82174E70;
		  /* 82174E70h */ case    8:  		/* b 76 */
		/* 82174E70h case    8:*/		return 0x82174EBC;
		/* 82174E70h case    8:*/		return 0x82174E74;
	}
	return 0x82174E74;
} // Block from 82174E50h-82174E74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82174E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174E74);
		  /* 82174E74h */ case    0:  		/* rlwinm R11, R31, 30, 2, 31 */
		/* 82174E74h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R31);
		/* 82174E74h case    0:*/		return 0x82174E78;
		  /* 82174E78h */ case    1:  		/* addi R11, R11, -1 */
		/* 82174E78h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82174E78h case    1:*/		return 0x82174E7C;
		  /* 82174E7Ch */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82174E7Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82174E7Ch case    2:*/		return 0x82174E80;
		  /* 82174E80h */ case    3:  		/* lwzx R29, <#[R11 + R30]> */
		/* 82174E80h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82174E80h case    3:*/		return 0x82174E84;
		  /* 82174E84h */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 82174E84h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82174E84h case    4:*/		return 0x82174E88;
		  /* 82174E88h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82174E88h case    5:*/		if ( regs.CR[6].eq ) { return 0x82174EAC;  }
		/* 82174E88h case    5:*/		return 0x82174E8C;
		  /* 82174E8Ch */ case    6:  		/* lwz R10, <#[R29]> */
		/* 82174E8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82174E8Ch case    6:*/		return 0x82174E90;
		  /* 82174E90h */ case    7:  		/* mr R5, R31 */
		/* 82174E90h case    7:*/		regs.R5 = regs.R31;
		/* 82174E90h case    7:*/		return 0x82174E94;
		  /* 82174E94h */ case    8:  		/* li R4, 0 */
		/* 82174E94h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82174E94h case    8:*/		return 0x82174E98;
		  /* 82174E98h */ case    9:  		/* mr R3, R29 */
		/* 82174E98h case    9:*/		regs.R3 = regs.R29;
		/* 82174E98h case    9:*/		return 0x82174E9C;
		  /* 82174E9Ch */ case   10:  		/* stwx R10, <#[R11 + R30]> */
		/* 82174E9Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82174E9Ch case   10:*/		return 0x82174EA0;
		  /* 82174EA0h */ case   11:  		/* bl -932704 */
		/* 82174EA0h case   11:*/		regs.LR = 0x82174EA4; return 0x82091340;
		/* 82174EA0h case   11:*/		return 0x82174EA4;
		  /* 82174EA4h */ case   12:  		/* mr R11, R29 */
		/* 82174EA4h case   12:*/		regs.R11 = regs.R29;
		/* 82174EA4h case   12:*/		return 0x82174EA8;
		  /* 82174EA8h */ case   13:  		/* b 20 */
		/* 82174EA8h case   13:*/		return 0x82174EBC;
		/* 82174EA8h case   13:*/		return 0x82174EAC;
	}
	return 0x82174EAC;
} // Block from 82174E74h-82174EACh (14 instructions)

//////////////////////////////////////////////////////
// Block at 82174EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174EAC);
		  /* 82174EACh */ case    0:  		/* mr R4, R31 */
		/* 82174EACh case    0:*/		regs.R4 = regs.R31;
		/* 82174EACh case    0:*/		return 0x82174EB0;
		  /* 82174EB0h */ case    1:  		/* mr R3, R30 */
		/* 82174EB0h case    1:*/		regs.R3 = regs.R30;
		/* 82174EB0h case    1:*/		return 0x82174EB4;
		  /* 82174EB4h */ case    2:  		/* bl -67780 */
		/* 82174EB4h case    2:*/		regs.LR = 0x82174EB8; return 0x821645F0;
		/* 82174EB4h case    2:*/		return 0x82174EB8;
	}
	return 0x82174EB8;
} // Block from 82174EACh-82174EB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174EB8);
		  /* 82174EB8h */ case    0:  		/* mr R11, R3 */
		/* 82174EB8h case    0:*/		regs.R11 = regs.R3;
		/* 82174EB8h case    0:*/		return 0x82174EBC;
	}
	return 0x82174EBC;
} // Block from 82174EB8h-82174EBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174EBC);
		  /* 82174EBCh */ case    0:  		/* stw R11, <#[R18 + 724]> */
		/* 82174EBCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x000002D4) );
		/* 82174EBCh case    0:*/		return 0x82174EC0;
		  /* 82174EC0h */ case    1:  		/* cmplwi CR6, R31, 132 */
		/* 82174EC0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000084);
		/* 82174EC0h case    1:*/		return 0x82174EC4;
		  /* 82174EC4h */ case    2:  		/* bc 4, CR6_GT, 20 */
		/* 82174EC4h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82174ED8;  }
		/* 82174EC4h case    2:*/		return 0x82174EC8;
		  /* 82174EC8h */ case    3:  		/* mr R4, R31 */
		/* 82174EC8h case    3:*/		regs.R4 = regs.R31;
		/* 82174EC8h case    3:*/		return 0x82174ECC;
		  /* 82174ECCh */ case    4:  		/* mr R3, R30 */
		/* 82174ECCh case    4:*/		regs.R3 = regs.R30;
		/* 82174ECCh case    4:*/		return 0x82174ED0;
		  /* 82174ED0h */ case    5:  		/* bl -65472 */
		/* 82174ED0h case    5:*/		regs.LR = 0x82174ED4; return 0x82164F10;
		/* 82174ED0h case    5:*/		return 0x82174ED4;
		  /* 82174ED4h */ case    6:  		/* b 108 */
		/* 82174ED4h case    6:*/		return 0x82174F40;
		/* 82174ED4h case    6:*/		return 0x82174ED8;
	}
	return 0x82174ED8;
} // Block from 82174EBCh-82174ED8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82174ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174ED8);
		  /* 82174ED8h */ case    0:  		/* lwz R10, <#[R30 + 140]> */
		/* 82174ED8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000008C) );
		/* 82174ED8h case    0:*/		return 0x82174EDC;
		  /* 82174EDCh */ case    1:  		/* lwz R11, <#[R30 + 144]> */
		/* 82174EDCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000090) );
		/* 82174EDCh case    1:*/		return 0x82174EE0;
		  /* 82174EE0h */ case    2:  		/* subf R10, R11, R10 */
		/* 82174EE0h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82174EE0h case    2:*/		return 0x82174EE4;
		  /* 82174EE4h */ case    3:  		/* addi R10, R10, 4096 */
		/* 82174EE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 82174EE4h case    3:*/		return 0x82174EE8;
		  /* 82174EE8h */ case    4:  		/* cmplw CR6, R10, R31 */
		/* 82174EE8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82174EE8h case    4:*/		return 0x82174EEC;
		  /* 82174EECh */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 82174EECh case    5:*/		if ( regs.CR[6].lt ) { return 0x82174EFC;  }
		/* 82174EECh case    5:*/		return 0x82174EF0;
		  /* 82174EF0h */ case    6:  		/* add R10, R11, R31 */
		/* 82174EF0h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 82174EF0h case    6:*/		return 0x82174EF4;
		  /* 82174EF4h */ case    7:  		/* stw R10, <#[R30 + 144]> */
		/* 82174EF4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000090) );
		/* 82174EF4h case    7:*/		return 0x82174EF8;
		  /* 82174EF8h */ case    8:  		/* b 76 */
		/* 82174EF8h case    8:*/		return 0x82174F44;
		/* 82174EF8h case    8:*/		return 0x82174EFC;
	}
	return 0x82174EFC;
} // Block from 82174ED8h-82174EFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82174EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174EFC);
		  /* 82174EFCh */ case    0:  		/* rlwinm R11, R31, 30, 2, 31 */
		/* 82174EFCh case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R31);
		/* 82174EFCh case    0:*/		return 0x82174F00;
		  /* 82174F00h */ case    1:  		/* addi R11, R11, -1 */
		/* 82174F00h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82174F00h case    1:*/		return 0x82174F04;
		  /* 82174F04h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82174F04h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82174F04h case    2:*/		return 0x82174F08;
		  /* 82174F08h */ case    3:  		/* lwzx R29, <#[R11 + R30]> */
		/* 82174F08h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82174F08h case    3:*/		return 0x82174F0C;
		  /* 82174F0Ch */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 82174F0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82174F0Ch case    4:*/		return 0x82174F10;
		  /* 82174F10h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82174F10h case    5:*/		if ( regs.CR[6].eq ) { return 0x82174F34;  }
		/* 82174F10h case    5:*/		return 0x82174F14;
		  /* 82174F14h */ case    6:  		/* lwz R10, <#[R29]> */
		/* 82174F14h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82174F14h case    6:*/		return 0x82174F18;
		  /* 82174F18h */ case    7:  		/* mr R5, R31 */
		/* 82174F18h case    7:*/		regs.R5 = regs.R31;
		/* 82174F18h case    7:*/		return 0x82174F1C;
		  /* 82174F1Ch */ case    8:  		/* li R4, 0 */
		/* 82174F1Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82174F1Ch case    8:*/		return 0x82174F20;
		  /* 82174F20h */ case    9:  		/* mr R3, R29 */
		/* 82174F20h case    9:*/		regs.R3 = regs.R29;
		/* 82174F20h case    9:*/		return 0x82174F24;
		  /* 82174F24h */ case   10:  		/* stwx R10, <#[R11 + R30]> */
		/* 82174F24h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82174F24h case   10:*/		return 0x82174F28;
		  /* 82174F28h */ case   11:  		/* bl -932840 */
		/* 82174F28h case   11:*/		regs.LR = 0x82174F2C; return 0x82091340;
		/* 82174F28h case   11:*/		return 0x82174F2C;
		  /* 82174F2Ch */ case   12:  		/* mr R11, R29 */
		/* 82174F2Ch case   12:*/		regs.R11 = regs.R29;
		/* 82174F2Ch case   12:*/		return 0x82174F30;
		  /* 82174F30h */ case   13:  		/* b 20 */
		/* 82174F30h case   13:*/		return 0x82174F44;
		/* 82174F30h case   13:*/		return 0x82174F34;
	}
	return 0x82174F34;
} // Block from 82174EFCh-82174F34h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82174F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174F34);
		  /* 82174F34h */ case    0:  		/* mr R4, R31 */
		/* 82174F34h case    0:*/		regs.R4 = regs.R31;
		/* 82174F34h case    0:*/		return 0x82174F38;
		  /* 82174F38h */ case    1:  		/* mr R3, R30 */
		/* 82174F38h case    1:*/		regs.R3 = regs.R30;
		/* 82174F38h case    1:*/		return 0x82174F3C;
		  /* 82174F3Ch */ case    2:  		/* bl -67916 */
		/* 82174F3Ch case    2:*/		regs.LR = 0x82174F40; return 0x821645F0;
		/* 82174F3Ch case    2:*/		return 0x82174F40;
	}
	return 0x82174F40;
} // Block from 82174F34h-82174F40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174F40);
		  /* 82174F40h */ case    0:  		/* mr R11, R3 */
		/* 82174F40h case    0:*/		regs.R11 = regs.R3;
		/* 82174F40h case    0:*/		return 0x82174F44;
	}
	return 0x82174F44;
} // Block from 82174F40h-82174F44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174F44);
		  /* 82174F44h */ case    0:  		/* cmplwi CR6, R31, 132 */
		/* 82174F44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000084);
		/* 82174F44h case    0:*/		return 0x82174F48;
		  /* 82174F48h */ case    1:  		/* stw R11, <#[R18 + 720]> */
		/* 82174F48h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x000002D0) );
		/* 82174F48h case    1:*/		return 0x82174F4C;
		  /* 82174F4Ch */ case    2:  		/* bc 4, CR6_GT, 20 */
		/* 82174F4Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x82174F60;  }
		/* 82174F4Ch case    2:*/		return 0x82174F50;
		  /* 82174F50h */ case    3:  		/* mr R4, R31 */
		/* 82174F50h case    3:*/		regs.R4 = regs.R31;
		/* 82174F50h case    3:*/		return 0x82174F54;
		  /* 82174F54h */ case    4:  		/* mr R3, R30 */
		/* 82174F54h case    4:*/		regs.R3 = regs.R30;
		/* 82174F54h case    4:*/		return 0x82174F58;
		  /* 82174F58h */ case    5:  		/* bl -65608 */
		/* 82174F58h case    5:*/		regs.LR = 0x82174F5C; return 0x82164F10;
		/* 82174F58h case    5:*/		return 0x82174F5C;
		  /* 82174F5Ch */ case    6:  		/* b 108 */
		/* 82174F5Ch case    6:*/		return 0x82174FC8;
		/* 82174F5Ch case    6:*/		return 0x82174F60;
	}
	return 0x82174F60;
} // Block from 82174F44h-82174F60h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82174F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174F60);
		  /* 82174F60h */ case    0:  		/* lwz R10, <#[R30 + 140]> */
		/* 82174F60h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000008C) );
		/* 82174F60h case    0:*/		return 0x82174F64;
		  /* 82174F64h */ case    1:  		/* lwz R11, <#[R30 + 144]> */
		/* 82174F64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000090) );
		/* 82174F64h case    1:*/		return 0x82174F68;
		  /* 82174F68h */ case    2:  		/* subf R10, R11, R10 */
		/* 82174F68h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82174F68h case    2:*/		return 0x82174F6C;
		  /* 82174F6Ch */ case    3:  		/* addi R10, R10, 4096 */
		/* 82174F6Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 82174F6Ch case    3:*/		return 0x82174F70;
		  /* 82174F70h */ case    4:  		/* cmplw CR6, R10, R31 */
		/* 82174F70h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82174F70h case    4:*/		return 0x82174F74;
		  /* 82174F74h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 82174F74h case    5:*/		if ( regs.CR[6].lt ) { return 0x82174F84;  }
		/* 82174F74h case    5:*/		return 0x82174F78;
		  /* 82174F78h */ case    6:  		/* add R10, R11, R31 */
		/* 82174F78h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 82174F78h case    6:*/		return 0x82174F7C;
		  /* 82174F7Ch */ case    7:  		/* stw R10, <#[R30 + 144]> */
		/* 82174F7Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000090) );
		/* 82174F7Ch case    7:*/		return 0x82174F80;
		  /* 82174F80h */ case    8:  		/* b 76 */
		/* 82174F80h case    8:*/		return 0x82174FCC;
		/* 82174F80h case    8:*/		return 0x82174F84;
	}
	return 0x82174F84;
} // Block from 82174F60h-82174F84h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82174F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174F84);
		  /* 82174F84h */ case    0:  		/* rlwinm R11, R31, 30, 2, 31 */
		/* 82174F84h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R31);
		/* 82174F84h case    0:*/		return 0x82174F88;
		  /* 82174F88h */ case    1:  		/* addi R11, R11, -1 */
		/* 82174F88h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82174F88h case    1:*/		return 0x82174F8C;
		  /* 82174F8Ch */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82174F8Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82174F8Ch case    2:*/		return 0x82174F90;
		  /* 82174F90h */ case    3:  		/* lwzx R29, <#[R11 + R30]> */
		/* 82174F90h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82174F90h case    3:*/		return 0x82174F94;
		  /* 82174F94h */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 82174F94h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82174F94h case    4:*/		return 0x82174F98;
		  /* 82174F98h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82174F98h case    5:*/		if ( regs.CR[6].eq ) { return 0x82174FBC;  }
		/* 82174F98h case    5:*/		return 0x82174F9C;
		  /* 82174F9Ch */ case    6:  		/* lwz R10, <#[R29]> */
		/* 82174F9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82174F9Ch case    6:*/		return 0x82174FA0;
		  /* 82174FA0h */ case    7:  		/* mr R5, R31 */
		/* 82174FA0h case    7:*/		regs.R5 = regs.R31;
		/* 82174FA0h case    7:*/		return 0x82174FA4;
		  /* 82174FA4h */ case    8:  		/* li R4, 0 */
		/* 82174FA4h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82174FA4h case    8:*/		return 0x82174FA8;
		  /* 82174FA8h */ case    9:  		/* mr R3, R29 */
		/* 82174FA8h case    9:*/		regs.R3 = regs.R29;
		/* 82174FA8h case    9:*/		return 0x82174FAC;
		  /* 82174FACh */ case   10:  		/* stwx R10, <#[R11 + R30]> */
		/* 82174FACh case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82174FACh case   10:*/		return 0x82174FB0;
		  /* 82174FB0h */ case   11:  		/* bl -932976 */
		/* 82174FB0h case   11:*/		regs.LR = 0x82174FB4; return 0x82091340;
		/* 82174FB0h case   11:*/		return 0x82174FB4;
		  /* 82174FB4h */ case   12:  		/* mr R11, R29 */
		/* 82174FB4h case   12:*/		regs.R11 = regs.R29;
		/* 82174FB4h case   12:*/		return 0x82174FB8;
		  /* 82174FB8h */ case   13:  		/* b 20 */
		/* 82174FB8h case   13:*/		return 0x82174FCC;
		/* 82174FB8h case   13:*/		return 0x82174FBC;
	}
	return 0x82174FBC;
} // Block from 82174F84h-82174FBCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 82174FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174FBC);
		  /* 82174FBCh */ case    0:  		/* mr R4, R31 */
		/* 82174FBCh case    0:*/		regs.R4 = regs.R31;
		/* 82174FBCh case    0:*/		return 0x82174FC0;
		  /* 82174FC0h */ case    1:  		/* mr R3, R30 */
		/* 82174FC0h case    1:*/		regs.R3 = regs.R30;
		/* 82174FC0h case    1:*/		return 0x82174FC4;
		  /* 82174FC4h */ case    2:  		/* bl -68052 */
		/* 82174FC4h case    2:*/		regs.LR = 0x82174FC8; return 0x821645F0;
		/* 82174FC4h case    2:*/		return 0x82174FC8;
	}
	return 0x82174FC8;
} // Block from 82174FBCh-82174FC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82174FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174FC8);
		  /* 82174FC8h */ case    0:  		/* mr R11, R3 */
		/* 82174FC8h case    0:*/		regs.R11 = regs.R3;
		/* 82174FC8h case    0:*/		return 0x82174FCC;
	}
	return 0x82174FCC;
} // Block from 82174FC8h-82174FCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82174FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82174FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82174FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82174FCC);
		  /* 82174FCCh */ case    0:  		/* stw R11, <#[R18 + 728]> */
		/* 82174FCCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x000002D8) );
		/* 82174FCCh case    0:*/		return 0x82174FD0;
		  /* 82174FD0h */ case    1:  		/* mr R29, R14 */
		/* 82174FD0h case    1:*/		regs.R29 = regs.R14;
		/* 82174FD0h case    1:*/		return 0x82174FD4;
		  /* 82174FD4h */ case    2:  		/* lwz R11, <#[R19 + 4]> */
		/* 82174FD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82174FD4h case    2:*/		return 0x82174FD8;
		  /* 82174FD8h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82174FD8h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82174FD8h case    3:*/		return 0x82174FDC;
		  /* 82174FDCh */ case    4:  		/* bc 4, CR0_EQ, 152 */
		/* 82174FDCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x82175074;  }
		/* 82174FDCh case    4:*/		return 0x82174FE0;
		  /* 82174FE0h */ case    5:  		/* lwz R11, <#[R19]> */
		/* 82174FE0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82174FE0h case    5:*/		return 0x82174FE4;
		  /* 82174FE4h */ case    6:  		/* b 132 */
		/* 82174FE4h case    6:*/		return 0x82175068;
		/* 82174FE4h case    6:*/		return 0x82174FE8;
		  /* 82174FE8h */ case    7:  		/* lwz R11, <#[R30 + 8]> */
		/* 82174FE8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82174FE8h case    7:*/		return 0x82174FEC;
		  /* 82174FECh */ case    8:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 82174FECh case    8:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 82174FECh case    8:*/		return 0x82174FF0;
		  /* 82174FF0h */ case    9:  		/* bc 12, CR0_EQ, 104 */
		/* 82174FF0h case    9:*/		if ( regs.CR[0].eq ) { return 0x82175058;  }
		/* 82174FF0h case    9:*/		return 0x82174FF4;
		  /* 82174FF4h */ case   10:  		/* lwz R11, <#[R30 + 16]> */
		/* 82174FF4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82174FF4h case   10:*/		return 0x82174FF8;
		  /* 82174FF8h */ case   11:  		/* lwz R10, <#[R30 + 20]> */
		/* 82174FF8h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 82174FF8h case   11:*/		return 0x82174FFC;
		  /* 82174FFCh */ case   12:  		/* rlwimi R11, R10, 27, 5, 31 */
		/* 82174FFCh case   12:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 82174FFCh case   12:*/		return 0x82175000;
		  /* 82175000h */ case   13:  		/* rlwinm R5, R11, 12, 21, 31 */
		/* 82175000h case   13:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R5,regs.R11);
		/* 82175000h case   13:*/		return 0x82175004;
		  /* 82175004h */ case   14:  		/* cmplw CR6, R5, R29 */
		/* 82175004h case   14:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R29);
		/* 82175004h case   14:*/		return 0x82175008;
		  /* 82175008h */ case   15:  		/* bc 12, CR6_EQ, 80 */
		/* 82175008h case   15:*/		if ( regs.CR[6].eq ) { return 0x82175058;  }
		/* 82175008h case   15:*/		return 0x8217500C;
		  /* 8217500Ch */ case   16:  		/* lwz R10, <#[R18 + 720]> */
		/* 8217500Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x000002D0) );
		/* 8217500Ch case   16:*/		return 0x82175010;
		  /* 82175010h */ case   17:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 82175010h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 82175010h case   17:*/		return 0x82175014;
		  /* 82175014h */ case   18:  		/* stw R14, <#[R1 + 84]> */
		/* 82175014h case   18:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000054) );
		/* 82175014h case   18:*/		return 0x82175018;
		  /* 82175018h */ case   19:  		/* addi R8, R1, 80 */
		/* 82175018h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82175018h case   19:*/		return 0x8217501C;
		  /* 8217501Ch */ case   20:  		/* add R10, R11, R10 */
		/* 8217501Ch case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8217501Ch case   20:*/		return 0x82175020;
		  /* 82175020h */ case   21:  		/* stb R14, <#[R1 + 80]> */
		/* 82175020h case   21:*/		cpu::mem::store8( regs, regs.R14, (uint32)(regs.R1 + 0x00000050) );
		/* 82175020h case   21:*/		return 0x82175024;
		  /* 82175024h */ case   22:  		/* mr R7, R15 */
		/* 82175024h case   22:*/		regs.R7 = regs.R15;
		/* 82175024h case   22:*/		return 0x82175028;
		  /* 82175028h */ case   23:  		/* addi R6, R1, 84 */
		/* 82175028h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 82175028h case   23:*/		return 0x8217502C;
		  /* 8217502Ch */ case   24:  		/* mr R4, R30 */
		/* 8217502Ch case   24:*/		regs.R4 = regs.R30;
		/* 8217502Ch case   24:*/		return 0x82175030;
		  /* 82175030h */ case   25:  		/* mr R3, R18 */
		/* 82175030h case   25:*/		regs.R3 = regs.R18;
		/* 82175030h case   25:*/		return 0x82175034;
		  /* 82175034h */ case   26:  		/* stw R30, <#[R10 - 4]> */
		/* 82175034h case   26:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 82175034h case   26:*/		return 0x82175038;
		  /* 82175038h */ case   27:  		/* mr R29, R5 */
		/* 82175038h case   27:*/		regs.R29 = regs.R5;
		/* 82175038h case   27:*/		return 0x8217503C;
		  /* 8217503Ch */ case   28:  		/* lwz R10, <#[R18 + 728]> */
		/* 8217503Ch case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x000002D8) );
		/* 8217503Ch case   28:*/		return 0x82175040;
		  /* 82175040h */ case   29:  		/* add R31, R11, R10 */
		/* 82175040h case   29:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 82175040h case   29:*/		return 0x82175044;
		  /* 82175044h */ case   30:  		/* addi R11, R31, -4 */
		/* 82175044h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 82175044h case   30:*/		return 0x82175048;
		  /* 82175048h */ case   31:  		/* bl -15792 */
		/* 82175048h case   31:*/		regs.LR = 0x8217504C; return 0x82171298;
		/* 82175048h case   31:*/		return 0x8217504C;
		  /* 8217504Ch */ case   32:  		/* lwz R11, <#[R31 - 4]> */
		/* 8217504Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 8217504Ch case   32:*/		return 0x82175050;
		  /* 82175050h */ case   33:  		/* add R11, R3, R11 */
		/* 82175050h case   33:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82175050h case   33:*/		return 0x82175054;
		  /* 82175054h */ case   34:  		/* stw R11, <#[R31 - 4]> */
		/* 82175054h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82175054h case   34:*/		return 0x82175058;
	}
	return 0x82175058;
} // Block from 82174FCCh-82175058h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82175058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175058);
		  /* 82175058h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82175058h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82175058h case    0:*/		return 0x8217505C;
		  /* 8217505Ch */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 8217505Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 8217505Ch case    1:*/		return 0x82175060;
		  /* 82175060h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175060h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175060h case    2:*/		return 0x82175064;
		  /* 82175064h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82175064h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82175074;  }
		/* 82175064h case    3:*/		return 0x82175068;
	}
	return 0x82175068;
} // Block from 82175058h-82175068h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82175068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175068);
		  /* 82175068h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175068h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175068h case    0:*/		return 0x8217506C;
		  /* 8217506Ch */ case    1:  		/* addic. R30, R11, -40 */
		/* 8217506Ch case    1:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 8217506Ch case    1:*/		return 0x82175070;
		  /* 82175070h */ case    2:  		/* bc 4, CR0_EQ, -136 */
		/* 82175070h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82174FE8;  }
		/* 82175070h case    2:*/		return 0x82175074;
	}
	return 0x82175074;
} // Block from 82175068h-82175074h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175074);
		  /* 82175074h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 82175074h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82175074h case    0:*/		return 0x82175078;
		  /* 82175078h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175078h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175078h case    1:*/		return 0x8217507C;
		  /* 8217507Ch */ case    2:  		/* bc 4, CR0_EQ, 1164 */
		/* 8217507Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x82175508;  }
		/* 8217507Ch case    2:*/		return 0x82175080;
		  /* 82175080h */ case    3:  		/* mr R26, R11 */
		/* 82175080h case    3:*/		regs.R26 = regs.R11;
		/* 82175080h case    3:*/		return 0x82175084;
		  /* 82175084h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82175084h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82175084h case    4:*/		return 0x82175088;
		  /* 82175088h */ case    5:  		/* bc 12, CR0_EQ, 1152 */
		/* 82175088h case    5:*/		if ( regs.CR[0].eq ) { return 0x82175508;  }
		/* 82175088h case    5:*/		return 0x8217508C;
		  /* 8217508Ch */ case    6:  		/* lwz R11, <#[R26 + 8]> */
		/* 8217508Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8217508Ch case    6:*/		return 0x82175090;
		  /* 82175090h */ case    7:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 82175090h case    7:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 82175090h case    7:*/		return 0x82175094;
		  /* 82175094h */ case    8:  		/* bc 12, CR0_EQ, 1112 */
		/* 82175094h case    8:*/		if ( regs.CR[0].eq ) { return 0x821754EC;  }
		/* 82175094h case    8:*/		return 0x82175098;
		  /* 82175098h */ case    9:  		/* rlwinm. R10, R11, 26, 31, 31 */
		/* 82175098h case    9:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R11);
		/* 82175098h case    9:*/		return 0x8217509C;
		  /* 8217509Ch */ case   10:  		/* bc 4, CR0_EQ, 40 */
		/* 8217509Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x821750C4;  }
		/* 8217509Ch case   10:*/		return 0x821750A0;
		  /* 821750A0h */ case   11:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821750A0h case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821750A0h case   11:*/		return 0x821750A4;
		  /* 821750A4h */ case   12:  		/* cmplwi CR6, R11, 32 */
		/* 821750A4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 821750A4h case   12:*/		return 0x821750A8;
		  /* 821750A8h */ case   13:  		/* bc 12, CR6_LT, 16 */
		/* 821750A8h case   13:*/		if ( regs.CR[6].lt ) { return 0x821750B8;  }
		/* 821750A8h case   13:*/		return 0x821750AC;
		  /* 821750ACh */ case   14:  		/* cmplwi CR6, R11, 82 */
		/* 821750ACh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821750ACh case   14:*/		return 0x821750B0;
		  /* 821750B0h */ case   15:  		/* mr R11, R16 */
		/* 821750B0h case   15:*/		regs.R11 = regs.R16;
		/* 821750B0h case   15:*/		return 0x821750B4;
		  /* 821750B4h */ case   16:  		/* bc 4, CR6_GT, 8 */
		/* 821750B4h case   16:*/		if ( !regs.CR[6].gt ) { return 0x821750BC;  }
		/* 821750B4h case   16:*/		return 0x821750B8;
	}
	return 0x821750B8;
} // Block from 82175074h-821750B8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821750B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821750B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821750B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821750B8);
		  /* 821750B8h */ case    0:  		/* mr R11, R14 */
		/* 821750B8h case    0:*/		regs.R11 = regs.R14;
		/* 821750B8h case    0:*/		return 0x821750BC;
	}
	return 0x821750BC;
} // Block from 821750B8h-821750BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821750BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821750BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821750BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821750BC);
		  /* 821750BCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821750BCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821750BCh case    0:*/		return 0x821750C0;
		  /* 821750C0h */ case    1:  		/* bc 12, CR0_EQ, 1068 */
		/* 821750C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821754EC;  }
		/* 821750C0h case    1:*/		return 0x821750C4;
	}
	return 0x821750C4;
} // Block from 821750BCh-821750C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821750C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821750C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821750C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821750C4);
		  /* 821750C4h */ case    0:  		/* lwz R6, <#[R26 + 4]> */
		/* 821750C4h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000004) );
		/* 821750C4h case    0:*/		return 0x821750C8;
		  /* 821750C8h */ case    1:  		/* addi R25, R26, 4 */
		/* 821750C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R26,0x4);
		/* 821750C8h case    1:*/		return 0x821750CC;
		  /* 821750CCh */ case    2:  		/* mr R24, R16 */
		/* 821750CCh case    2:*/		regs.R24 = regs.R16;
		/* 821750CCh case    2:*/		return 0x821750D0;
		  /* 821750D0h */ case    3:  		/* cmplwi CR6, R6, 0 */
		/* 821750D0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821750D0h case    3:*/		return 0x821750D4;
		  /* 821750D4h */ case    4:  		/* bc 12, CR6_EQ, 240 */
		/* 821750D4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821751C4;  }
		/* 821750D4h case    4:*/		return 0x821750D8;
		  /* 821750D8h */ case    5:  		/* lwz R9, <#[R6 + 16]> */
		/* 821750D8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000010) );
		/* 821750D8h case    5:*/		return 0x821750DC;
		  /* 821750DCh */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 821750DCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821750DCh case    6:*/		return 0x821750E0;
		  /* 821750E0h */ case    7:  		/* bc 12, CR6_EQ, 216 */
		/* 821750E0h case    7:*/		if ( regs.CR[6].eq ) { return 0x821751B8;  }
		/* 821750E0h case    7:*/		return 0x821750E4;
		  /* 821750E4h */ case    8:  		/* lwz R10, <#[R6]> */
		/* 821750E4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 821750E4h case    8:*/		return 0x821750E8;
		  /* 821750E8h */ case    9:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 821750E8h case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 821750E8h case    9:*/		return 0x821750EC;
		  /* 821750ECh */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 821750ECh case   10:*/		if ( regs.CR[0].eq ) { return 0x821750FC;  }
		/* 821750ECh case   10:*/		return 0x821750F0;
		  /* 821750F0h */ case   11:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 821750F0h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 821750F0h case   11:*/		return 0x821750F4;
		  /* 821750F4h */ case   12:  		/* mr R11, R16 */
		/* 821750F4h case   12:*/		regs.R11 = regs.R16;
		/* 821750F4h case   12:*/		return 0x821750F8;
		  /* 821750F8h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 821750F8h case   13:*/		if ( regs.CR[0].eq ) { return 0x82175100;  }
		/* 821750F8h case   13:*/		return 0x821750FC;
	}
	return 0x821750FC;
} // Block from 821750C4h-821750FCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821750FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821750FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821750FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821750FC);
		  /* 821750FCh */ case    0:  		/* mr R11, R14 */
		/* 821750FCh case    0:*/		regs.R11 = regs.R14;
		/* 821750FCh case    0:*/		return 0x82175100;
	}
	return 0x82175100;
} // Block from 821750FCh-82175100h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82175100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175100);
		  /* 82175100h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82175100h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82175100h case    0:*/		return 0x82175104;
		  /* 82175104h */ case    1:  		/* bc 12, CR0_EQ, 180 */
		/* 82175104h case    1:*/		if ( regs.CR[0].eq ) { return 0x821751B8;  }
		/* 82175104h case    1:*/		return 0x82175108;
		  /* 82175108h */ case    2:  		/* rlwinm. R11, R10, 0, 7, 18 */
		/* 82175108h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R10);
		/* 82175108h case    2:*/		return 0x8217510C;
		  /* 8217510Ch */ case    3:  		/* bc 4, CR0_EQ, 172 */
		/* 8217510Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821751B8;  }
		/* 8217510Ch case    3:*/		return 0x82175110;
		  /* 82175110h */ case    4:  		/* lwz R11, <#[R9 + 20]> */
		/* 82175110h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82175110h case    4:*/		return 0x82175114;
		  /* 82175114h */ case    5:  		/* lwz R10, <#[R9 + 16]> */
		/* 82175114h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000010) );
		/* 82175114h case    5:*/		return 0x82175118;
		  /* 82175118h */ case    6:  		/* lwz R9, <#[R26 + 16]> */
		/* 82175118h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000010) );
		/* 82175118h case    6:*/		return 0x8217511C;
		  /* 8217511Ch */ case    7:  		/* lwz R8, <#[R26 + 20]> */
		/* 8217511Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 8217511Ch case    7:*/		return 0x82175120;
		  /* 82175120h */ case    8:  		/* rlwimi R10, R11, 27, 5, 31 */
		/* 82175120h case    8:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 82175120h case    8:*/		return 0x82175124;
		  /* 82175124h */ case    9:  		/* rlwimi R9, R8, 27, 5, 31 */
		/* 82175124h case    9:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R9,regs.R8);
		/* 82175124h case    9:*/		return 0x82175128;
		  /* 82175128h */ case   10:  		/* rlwinm R7, R10, 12, 21, 31 */
		/* 82175128h case   10:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R7,regs.R10);
		/* 82175128h case   10:*/		return 0x8217512C;
		  /* 8217512Ch */ case   11:  		/* rlwinm R11, R9, 12, 21, 31 */
		/* 8217512Ch case   11:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R11,regs.R9);
		/* 8217512Ch case   11:*/		return 0x82175130;
		  /* 82175130h */ case   12:  		/* cmplw CR6, R7, R11 */
		/* 82175130h case   12:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82175130h case   12:*/		return 0x82175134;
		  /* 82175134h */ case   13:  		/* bc 12, CR6_EQ, 132 */
		/* 82175134h case   13:*/		if ( regs.CR[6].eq ) { return 0x821751B8;  }
		/* 82175134h case   13:*/		return 0x82175138;
		  /* 82175138h */ case   14:  		/* lwz R11, <#[R18 + 720]> */
		/* 82175138h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x000002D0) );
		/* 82175138h case   14:*/		return 0x8217513C;
		  /* 8217513Ch */ case   15:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 8217513Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 8217513Ch case   15:*/		return 0x82175140;
		  /* 82175140h */ case   16:  		/* add R11, R10, R11 */
		/* 82175140h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82175140h case   16:*/		return 0x82175144;
		  /* 82175144h */ case   17:  		/* lwz R10, <#[R11 - 4]> */
		/* 82175144h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82175144h case   17:*/		return 0x82175148;
		  /* 82175148h */ case   18:  		/* b 104 */
		/* 82175148h case   18:*/		return 0x821751B0;
		/* 82175148h case   18:*/		return 0x8217514C;
		  /* 8217514Ch */ case   19:  		/* lwz R9, <#[R10]> */
		/* 8217514Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8217514Ch case   19:*/		return 0x82175150;
		  /* 82175150h */ case   20:  		/* cmplwi CR6, R9, 0 */
		/* 82175150h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82175150h case   20:*/		return 0x82175154;
		  /* 82175154h */ case   21:  		/* bc 12, CR6_EQ, 88 */
		/* 82175154h case   21:*/		if ( regs.CR[6].eq ) { return 0x821751AC;  }
		/* 82175154h case   21:*/		return 0x82175158;
		  /* 82175158h */ case   22:  		/* lwz R8, <#[R9]> */
		/* 82175158h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82175158h case   22:*/		return 0x8217515C;
		  /* 8217515Ch */ case   23:  		/* rlwinm. R11, R8, 0, 1, 1 */
		/* 8217515Ch case   23:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R8);
		/* 8217515Ch case   23:*/		return 0x82175160;
		  /* 82175160h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 82175160h case   24:*/		if ( regs.CR[0].eq ) { return 0x82175170;  }
		/* 82175160h case   24:*/		return 0x82175164;
		  /* 82175164h */ case   25:  		/* rlwinm. R11, R8, 0, 4, 6 */
		/* 82175164h case   25:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R8);
		/* 82175164h case   25:*/		return 0x82175168;
		  /* 82175168h */ case   26:  		/* mr R11, R16 */
		/* 82175168h case   26:*/		regs.R11 = regs.R16;
		/* 82175168h case   26:*/		return 0x8217516C;
		  /* 8217516Ch */ case   27:  		/* bc 12, CR0_EQ, 8 */
		/* 8217516Ch case   27:*/		if ( regs.CR[0].eq ) { return 0x82175174;  }
		/* 8217516Ch case   27:*/		return 0x82175170;
	}
	return 0x82175170;
} // Block from 82175100h-82175170h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82175170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175170);
		  /* 82175170h */ case    0:  		/* mr R11, R14 */
		/* 82175170h case    0:*/		regs.R11 = regs.R14;
		/* 82175170h case    0:*/		return 0x82175174;
	}
	return 0x82175174;
} // Block from 82175170h-82175174h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82175174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175174);
		  /* 82175174h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82175174h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82175174h case    0:*/		return 0x82175178;
		  /* 82175178h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 82175178h case    1:*/		if ( regs.CR[0].eq ) { return 0x821751A4;  }
		/* 82175178h case    1:*/		return 0x8217517C;
		  /* 8217517Ch */ case    2:  		/* rlwinm R11, R8, 0, 7, 18 */
		/* 8217517Ch case    2:*/		cpu::op::rlwinm<0,0,7,18>(regs,&regs.R11,regs.R8);
		/* 8217517Ch case    2:*/		return 0x82175180;
		  /* 82175180h */ case    3:  		/* cmplwi CR6, R11, 49152 */
		/* 82175180h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000C000);
		/* 82175180h case    3:*/		return 0x82175184;
		  /* 82175184h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 82175184h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821751A4;  }
		/* 82175184h case    4:*/		return 0x82175188;
		  /* 82175188h */ case    5:  		/* lwz R11, <#[R9 + 12]> */
		/* 82175188h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82175188h case    5:*/		return 0x8217518C;
		  /* 8217518Ch */ case    6:  		/* lwz R8, <#[R11 + 20]> */
		/* 8217518Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 8217518Ch case    6:*/		return 0x82175190;
		  /* 82175190h */ case    7:  		/* lwz R11, <#[R11 + 16]> */
		/* 82175190h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82175190h case    7:*/		return 0x82175194;
		  /* 82175194h */ case    8:  		/* rlwimi R11, R8, 27, 5, 31 */
		/* 82175194h case    8:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R11,regs.R8);
		/* 82175194h case    8:*/		return 0x82175198;
		  /* 82175198h */ case    9:  		/* rlwinm R11, R11, 12, 21, 31 */
		/* 82175198h case    9:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R11,regs.R11);
		/* 82175198h case    9:*/		return 0x8217519C;
		  /* 8217519Ch */ case   10:  		/* cmplw CR6, R11, R7 */
		/* 8217519Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8217519Ch case   10:*/		return 0x821751A0;
		  /* 821751A0h */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 821751A0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821751C0;  }
		/* 821751A0h case   11:*/		return 0x821751A4;
	}
	return 0x821751A4;
} // Block from 82175174h-821751A4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821751A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751A4);
		  /* 821751A4h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 821751A4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821751A4h case    0:*/		return 0x821751A8;
		  /* 821751A8h */ case    1:  		/* b -88 */
		/* 821751A8h case    1:*/		return 0x82175150;
		/* 821751A8h case    1:*/		return 0x821751AC;
	}
	return 0x821751AC;
} // Block from 821751A4h-821751ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821751ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751AC);
		  /* 821751ACh */ case    0:  		/* lwz R10, <#[R10 + 32]> */
		/* 821751ACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000020) );
		/* 821751ACh case    0:*/		return 0x821751B0;
	}
	return 0x821751B0;
} // Block from 821751ACh-821751B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821751B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751B0);
		  /* 821751B0h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821751B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821751B0h case    0:*/		return 0x821751B4;
		  /* 821751B4h */ case    1:  		/* bc 4, CR6_EQ, -104 */
		/* 821751B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8217514C;  }
		/* 821751B4h case    1:*/		return 0x821751B8;
	}
	return 0x821751B8;
} // Block from 821751B0h-821751B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821751B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751B8);
		  /* 821751B8h */ case    0:  		/* lwz R6, <#[R6 + 8]> */
		/* 821751B8h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000008) );
		/* 821751B8h case    0:*/		return 0x821751BC;
		  /* 821751BCh */ case    1:  		/* b -236 */
		/* 821751BCh case    1:*/		return 0x821750D0;
		/* 821751BCh case    1:*/		return 0x821751C0;
	}
	return 0x821751C0;
} // Block from 821751B8h-821751C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821751C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751C0);
		  /* 821751C0h */ case    0:  		/* mr R24, R14 */
		/* 821751C0h case    0:*/		regs.R24 = regs.R14;
		/* 821751C0h case    0:*/		return 0x821751C4;
	}
	return 0x821751C4;
} // Block from 821751C0h-821751C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821751C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751C4);
		  /* 821751C4h */ case    0:  		/* mr R11, R25 */
		/* 821751C4h case    0:*/		regs.R11 = regs.R25;
		/* 821751C4h case    0:*/		return 0x821751C8;
		  /* 821751C8h */ case    1:  		/* lwz R9, <#[R11]> */
		/* 821751C8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821751C8h case    1:*/		return 0x821751CC;
		  /* 821751CCh */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 821751CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821751CCh case    2:*/		return 0x821751D0;
		  /* 821751D0h */ case    3:  		/* bc 12, CR6_EQ, 796 */
		/* 821751D0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821754EC;  }
		/* 821751D0h case    3:*/		return 0x821751D4;
		  /* 821751D4h */ case    4:  		/* lwz R29, <#[R9 + 16]> */
		/* 821751D4h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x00000010) );
		/* 821751D4h case    4:*/		return 0x821751D8;
		  /* 821751D8h */ case    5:  		/* cmplwi CR6, R29, 0 */
		/* 821751D8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821751D8h case    5:*/		return 0x821751DC;
		  /* 821751DCh */ case    6:  		/* bc 12, CR6_EQ, 164 */
		/* 821751DCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82175280;  }
		/* 821751DCh case    6:*/		return 0x821751E0;
		  /* 821751E0h */ case    7:  		/* lwz R10, <#[R9]> */
		/* 821751E0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 821751E0h case    7:*/		return 0x821751E4;
		  /* 821751E4h */ case    8:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 821751E4h case    8:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 821751E4h case    8:*/		return 0x821751E8;
		  /* 821751E8h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 821751E8h case    9:*/		if ( regs.CR[0].eq ) { return 0x821751F8;  }
		/* 821751E8h case    9:*/		return 0x821751EC;
		  /* 821751ECh */ case   10:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 821751ECh case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 821751ECh case   10:*/		return 0x821751F0;
		  /* 821751F0h */ case   11:  		/* mr R11, R16 */
		/* 821751F0h case   11:*/		regs.R11 = regs.R16;
		/* 821751F0h case   11:*/		return 0x821751F4;
		  /* 821751F4h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 821751F4h case   12:*/		if ( regs.CR[0].eq ) { return 0x821751FC;  }
		/* 821751F4h case   12:*/		return 0x821751F8;
	}
	return 0x821751F8;
} // Block from 821751C4h-821751F8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821751F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751F8);
		  /* 821751F8h */ case    0:  		/* mr R11, R14 */
		/* 821751F8h case    0:*/		regs.R11 = regs.R14;
		/* 821751F8h case    0:*/		return 0x821751FC;
	}
	return 0x821751FC;
} // Block from 821751F8h-821751FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821751FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821751FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821751FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821751FC);
		  /* 821751FCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821751FCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821751FCh case    0:*/		return 0x82175200;
		  /* 82175200h */ case    1:  		/* bc 12, CR0_EQ, 128 */
		/* 82175200h case    1:*/		if ( regs.CR[0].eq ) { return 0x82175280;  }
		/* 82175200h case    1:*/		return 0x82175204;
		  /* 82175204h */ case    2:  		/* rlwinm. R27, R10, 19, 20, 31 */
		/* 82175204h case    2:*/		cpu::op::rlwinm<1,19,20,31>(regs,&regs.R27,regs.R10);
		/* 82175204h case    2:*/		return 0x82175208;
		  /* 82175208h */ case    3:  		/* bc 12, CR0_LT, 120 */
		/* 82175208h case    3:*/		if ( regs.CR[0].lt ) { return 0x82175280;  }
		/* 82175208h case    3:*/		return 0x8217520C;
		  /* 8217520Ch */ case    4:  		/* cmpwi CR6, R27, 6 */
		/* 8217520Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000006);
		/* 8217520Ch case    4:*/		return 0x82175210;
		  /* 82175210h */ case    5:  		/* bc 12, CR6_GT, 112 */
		/* 82175210h case    5:*/		if ( regs.CR[6].gt ) { return 0x82175280;  }
		/* 82175210h case    5:*/		return 0x82175214;
		  /* 82175214h */ case    6:  		/* cmpwi CR6, R27, 8 */
		/* 82175214h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000008);
		/* 82175214h case    6:*/		return 0x82175218;
		  /* 82175218h */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 82175218h case    7:*/		if ( regs.CR[6].eq ) { return 0x82175280;  }
		/* 82175218h case    7:*/		return 0x8217521C;
		  /* 8217521Ch */ case    8:  		/* cmpwi CR6, R27, 5 */
		/* 8217521Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000005);
		/* 8217521Ch case    8:*/		return 0x82175220;
		  /* 82175220h */ case    9:  		/* bc 12, CR6_EQ, 96 */
		/* 82175220h case    9:*/		if ( regs.CR[6].eq ) { return 0x82175280;  }
		/* 82175220h case    9:*/		return 0x82175224;
		  /* 82175224h */ case   10:  		/* cmpwi CR6, R27, 4 */
		/* 82175224h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000004);
		/* 82175224h case   10:*/		return 0x82175228;
		  /* 82175228h */ case   11:  		/* bc 12, CR6_EQ, 88 */
		/* 82175228h case   11:*/		if ( regs.CR[6].eq ) { return 0x82175280;  }
		/* 82175228h case   11:*/		return 0x8217522C;
		  /* 8217522Ch */ case   12:  		/* lwz R11, <#[R29 + 20]> */
		/* 8217522Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 8217522Ch case   12:*/		return 0x82175230;
		  /* 82175230h */ case   13:  		/* lwz R10, <#[R29 + 16]> */
		/* 82175230h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 82175230h case   13:*/		return 0x82175234;
		  /* 82175234h */ case   14:  		/* lwz R8, <#[R26 + 16]> */
		/* 82175234h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000010) );
		/* 82175234h case   14:*/		return 0x82175238;
		  /* 82175238h */ case   15:  		/* lwz R7, <#[R26 + 20]> */
		/* 82175238h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82175238h case   15:*/		return 0x8217523C;
		  /* 8217523Ch */ case   16:  		/* rlwimi R10, R11, 27, 5, 31 */
		/* 8217523Ch case   16:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8217523Ch case   16:*/		return 0x82175240;
		  /* 82175240h */ case   17:  		/* rlwimi R8, R7, 27, 5, 31 */
		/* 82175240h case   17:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R8,regs.R7);
		/* 82175240h case   17:*/		return 0x82175244;
		  /* 82175244h */ case   18:  		/* rlwinm R28, R10, 12, 21, 31 */
		/* 82175244h case   18:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R28,regs.R10);
		/* 82175244h case   18:*/		return 0x82175248;
		  /* 82175248h */ case   19:  		/* rlwinm R11, R8, 12, 21, 31 */
		/* 82175248h case   19:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R11,regs.R8);
		/* 82175248h case   19:*/		return 0x8217524C;
		  /* 8217524Ch */ case   20:  		/* cmplw CR6, R28, R11 */
		/* 8217524Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8217524Ch case   20:*/		return 0x82175250;
		  /* 82175250h */ case   21:  		/* bc 12, CR6_EQ, 48 */
		/* 82175250h case   21:*/		if ( regs.CR[6].eq ) { return 0x82175280;  }
		/* 82175250h case   21:*/		return 0x82175254;
		  /* 82175254h */ case   22:  		/* cmplwi CR6, R27, 1 */
		/* 82175254h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 82175254h case   22:*/		return 0x82175258;
		  /* 82175258h */ case   23:  		/* bc 12, CR6_LT, 32 */
		/* 82175258h case   23:*/		if ( regs.CR[6].lt ) { return 0x82175278;  }
		/* 82175258h case   23:*/		return 0x8217525C;
		  /* 8217525Ch */ case   24:  		/* cmplwi CR6, R27, 4 */
		/* 8217525Ch case   24:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000004);
		/* 8217525Ch case   24:*/		return 0x82175260;
		  /* 82175260h */ case   25:  		/* bc 12, CR6_LT, 40 */
		/* 82175260h case   25:*/		if ( regs.CR[6].lt ) { return 0x82175288;  }
		/* 82175260h case   25:*/		return 0x82175264;
		  /* 82175264h */ case   26:  		/* cmplwi CR6, R27, 6 */
		/* 82175264h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000006);
		/* 82175264h case   26:*/		return 0x82175268;
		  /* 82175268h */ case   27:  		/* bc 12, CR6_EQ, 24 */
		/* 82175268h case   27:*/		if ( regs.CR[6].eq ) { return 0x82175280;  }
		/* 82175268h case   27:*/		return 0x8217526C;
		  /* 8217526Ch */ case   28:  		/* li R4, 4800 */
		/* 8217526Ch case   28:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8217526Ch case   28:*/		return 0x82175270;
		  /* 82175270h */ case   29:  		/* mr R3, R18 */
		/* 82175270h case   29:*/		regs.R3 = regs.R18;
		/* 82175270h case   29:*/		return 0x82175274;
		  /* 82175274h */ case   30:  		/* bl -144396 */
		/* 82175274h case   30:*/		regs.LR = 0x82175278; return 0x82151E68;
		/* 82175274h case   30:*/		return 0x82175278;
	}
	return 0x82175278;
} // Block from 821751FCh-82175278h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82175278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175278);
		  /* 82175278h */ case    0:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 82175278h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 82175278h case    0:*/		return 0x8217527C;
		  /* 8217527Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8217527Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82175288;  }
		/* 8217527Ch case    1:*/		return 0x82175280;
	}
	return 0x82175280;
} // Block from 82175278h-82175280h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175280);
		  /* 82175280h */ case    0:  		/* addi R11, R9, 8 */
		/* 82175280h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x8);
		/* 82175280h case    0:*/		return 0x82175284;
		  /* 82175284h */ case    1:  		/* b -188 */
		/* 82175284h case    1:*/		return 0x821751C8;
		/* 82175284h case    1:*/		return 0x82175288;
	}
	return 0x82175288;
} // Block from 82175280h-82175288h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175288);
		  /* 82175288h */ case    0:  		/* lwz R30, <#[R26 + 44]> */
		/* 82175288h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x0000002C) );
		/* 82175288h case    0:*/		return 0x8217528C;
		  /* 8217528Ch */ case    1:  		/* lwz R31, <#[R30 + 12]> */
		/* 8217528Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x0000000C) );
		/* 8217528Ch case    1:*/		return 0x82175290;
		  /* 82175290h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82175290h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82175290h case    2:*/		return 0x82175294;
		  /* 82175294h */ case    3:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82175294h case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82175294h case    3:*/		return 0x82175298;
		  /* 82175298h */ case    4:  		/* bc 12, CR0_EQ, 140 */
		/* 82175298h case    4:*/		if ( regs.CR[0].eq ) { return 0x82175324;  }
		/* 82175298h case    4:*/		return 0x8217529C;
		  /* 8217529Ch */ case    5:  		/* mr R5, R31 */
		/* 8217529Ch case    5:*/		regs.R5 = regs.R31;
		/* 8217529Ch case    5:*/		return 0x821752A0;
		  /* 821752A0h */ case    6:  		/* mr R4, R30 */
		/* 821752A0h case    6:*/		regs.R4 = regs.R30;
		/* 821752A0h case    6:*/		return 0x821752A4;
		  /* 821752A4h */ case    7:  		/* mr R3, R18 */
		/* 821752A4h case    7:*/		regs.R3 = regs.R18;
		/* 821752A4h case    7:*/		return 0x821752A8;
		  /* 821752A8h */ case    8:  		/* bl -16824 */
		/* 821752A8h case    8:*/		regs.LR = 0x821752AC; return 0x821710F0;
		/* 821752A8h case    8:*/		return 0x821752AC;
		  /* 821752ACh */ case    9:  		/* mr R30, R3 */
		/* 821752ACh case    9:*/		regs.R30 = regs.R3;
		/* 821752ACh case    9:*/		return 0x821752B0;
		  /* 821752B0h */ case   10:  		/* mr R6, R3 */
		/* 821752B0h case   10:*/		regs.R6 = regs.R3;
		/* 821752B0h case   10:*/		return 0x821752B4;
		  /* 821752B4h */ case   11:  		/* rlwinm R5, R26, 0, 0, 29 */
		/* 821752B4h case   11:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R5,regs.R26);
		/* 821752B4h case   11:*/		return 0x821752B8;
		  /* 821752B8h */ case   12:  		/* mr R4, R20 */
		/* 821752B8h case   12:*/		regs.R4 = regs.R20;
		/* 821752B8h case   12:*/		return 0x821752BC;
		  /* 821752BCh */ case   13:  		/* mr R3, R18 */
		/* 821752BCh case   13:*/		regs.R3 = regs.R18;
		/* 821752BCh case   13:*/		return 0x821752C0;
		  /* 821752C0h */ case   14:  		/* bl 739768 */
		/* 821752C0h case   14:*/		regs.LR = 0x821752C4; return 0x82229C78;
		/* 821752C0h case   14:*/		return 0x821752C4;
		  /* 821752C4h */ case   15:  		/* lwz R11, <#[R30 + 12]> */
		/* 821752C4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821752C4h case   15:*/		return 0x821752C8;
		  /* 821752C8h */ case   16:  		/* lwz R10, <#[R11 + 8]> */
		/* 821752C8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821752C8h case   16:*/		return 0x821752CC;
		  /* 821752CCh */ case   17:  		/* lwz R9, <#[R11 + 16]> */
		/* 821752CCh case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821752CCh case   17:*/		return 0x821752D0;
		  /* 821752D0h */ case   18:  		/* oris R10, R10, 1024 */
		/* 821752D0h case   18:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x400);
		/* 821752D0h case   18:*/		return 0x821752D4;
		  /* 821752D4h */ case   19:  		/* lwz R8, <#[R11 + 20]> */
		/* 821752D4h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 821752D4h case   19:*/		return 0x821752D8;
		  /* 821752D8h */ case   20:  		/* stw R10, <#[R11 + 8]> */
		/* 821752D8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821752D8h case   20:*/		return 0x821752DC;
		  /* 821752DCh */ case   21:  		/* lwz R7, <#[R26 + 16]> */
		/* 821752DCh case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000010) );
		/* 821752DCh case   21:*/		return 0x821752E0;
		  /* 821752E0h */ case   22:  		/* lwz R10, <#[R26 + 20]> */
		/* 821752E0h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821752E0h case   22:*/		return 0x821752E4;
		  /* 821752E4h */ case   23:  		/* rlwimi R7, R10, 27, 5, 31 */
		/* 821752E4h case   23:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R7,regs.R10);
		/* 821752E4h case   23:*/		return 0x821752E8;
		  /* 821752E8h */ case   24:  		/* rlwinm R10, R7, 12, 21, 31 */
		/* 821752E8h case   24:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R10,regs.R7);
		/* 821752E8h case   24:*/		return 0x821752EC;
		  /* 821752ECh */ case   25:  		/* rlwimi R9, R10, 20, 1, 4 */
		/* 821752ECh case   25:*/		cpu::op::rlwimi<0,20,1,4>(regs,&regs.R9,regs.R10);
		/* 821752ECh case   25:*/		return 0x821752F0;
		  /* 821752F0h */ case   26:  		/* rlwimi R8, R10, 25, 0, 6 */
		/* 821752F0h case   26:*/		cpu::op::rlwimi<0,25,0,6>(regs,&regs.R8,regs.R10);
		/* 821752F0h case   26:*/		return 0x821752F4;
		  /* 821752F4h */ case   27:  		/* stw R9, <#[R11 + 16]> */
		/* 821752F4h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821752F4h case   27:*/		return 0x821752F8;
		  /* 821752F8h */ case   28:  		/* stw R8, <#[R11 + 20]> */
		/* 821752F8h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 821752F8h case   28:*/		return 0x821752FC;
		  /* 821752FCh */ case   29:  		/* lwz R10, <#[R26 + 32]> */
		/* 821752FCh case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000020) );
		/* 821752FCh case   29:*/		return 0x82175300;
		  /* 82175300h */ case   30:  		/* stw R10, <#[R11 + 32]> */
		/* 82175300h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 82175300h case   30:*/		return 0x82175304;
		  /* 82175304h */ case   31:  		/* stw R11, <#[R26 + 32]> */
		/* 82175304h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000020) );
		/* 82175304h case   31:*/		return 0x82175308;
		  /* 82175308h */ case   32:  		/* lwz R11, <#[R31 + 8]> */
		/* 82175308h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82175308h case   32:*/		return 0x8217530C;
		  /* 8217530Ch */ case   33:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8217530Ch case   33:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8217530Ch case   33:*/		return 0x82175310;
		  /* 82175310h */ case   34:  		/* cmplwi CR6, R11, 14080 */
		/* 82175310h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 82175310h case   34:*/		return 0x82175314;
		  /* 82175314h */ case   35:  		/* bc 12, CR6_EQ, 16 */
		/* 82175314h case   35:*/		if ( regs.CR[6].eq ) { return 0x82175324;  }
		/* 82175314h case   35:*/		return 0x82175318;
		  /* 82175318h */ case   36:  		/* mr R4, R31 */
		/* 82175318h case   36:*/		regs.R4 = regs.R31;
		/* 82175318h case   36:*/		return 0x8217531C;
		  /* 8217531Ch */ case   37:  		/* mr R3, R18 */
		/* 8217531Ch case   37:*/		regs.R3 = regs.R18;
		/* 8217531Ch case   37:*/		return 0x82175320;
		  /* 82175320h */ case   38:  		/* bl -13640 */
		/* 82175320h case   38:*/		regs.LR = 0x82175324; return 0x82171DD8;
		/* 82175320h case   38:*/		return 0x82175324;
	}
	return 0x82175324;
} // Block from 82175288h-82175324h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82175324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175324);
		  /* 82175324h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82175324h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82175324h case    0:*/		return 0x82175328;
		  /* 82175328h */ case    1:  		/* li R8, 0 */
		/* 82175328h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82175328h case    1:*/		return 0x8217532C;
		  /* 8217532Ch */ case    2:  		/* li R7, 1 */
		/* 8217532Ch case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8217532Ch case    2:*/		return 0x82175330;
		  /* 82175330h */ case    3:  		/* rlwinm R6, R11, 25, 25, 31 */
		/* 82175330h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R6,regs.R11);
		/* 82175330h case    3:*/		return 0x82175334;
		  /* 82175334h */ case    4:  		/* li R5, 0 */
		/* 82175334h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82175334h case    4:*/		return 0x82175338;
		  /* 82175338h */ case    5:  		/* mr R4, R20 */
		/* 82175338h case    5:*/		regs.R4 = regs.R20;
		/* 82175338h case    5:*/		return 0x8217533C;
		  /* 8217533Ch */ case    6:  		/* mr R3, R18 */
		/* 8217533Ch case    6:*/		regs.R3 = regs.R18;
		/* 8217533Ch case    6:*/		return 0x82175340;
		  /* 82175340h */ case    7:  		/* bl 718424 */
		/* 82175340h case    7:*/		regs.LR = 0x82175344; return 0x82224998;
		/* 82175340h case    7:*/		return 0x82175344;
		  /* 82175344h */ case    8:  		/* mr R4, R30 */
		/* 82175344h case    8:*/		regs.R4 = regs.R30;
		/* 82175344h case    8:*/		return 0x82175348;
		  /* 82175348h */ case    9:  		/* mr R31, R3 */
		/* 82175348h case    9:*/		regs.R31 = regs.R3;
		/* 82175348h case    9:*/		return 0x8217534C;
		  /* 8217534Ch */ case   10:  		/* bl 11900 */
		/* 8217534Ch case   10:*/		regs.LR = 0x82175350; return 0x821781C8;
		/* 8217534Ch case   10:*/		return 0x82175350;
		  /* 82175350h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 82175350h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82175350h case   11:*/		return 0x82175354;
		  /* 82175354h */ case   12:  		/* stw R3, <#[R31 + 44]> */
		/* 82175354h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82175354h case   12:*/		return 0x82175358;
		  /* 82175358h */ case   13:  		/* oris R11, R11, 256 */
		/* 82175358h case   13:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82175358h case   13:*/		return 0x8217535C;
		  /* 8217535Ch */ case   14:  		/* stw R11, <#[R31 + 8]> */
		/* 8217535Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8217535Ch case   14:*/		return 0x82175360;
		  /* 82175360h */ case   15:  		/* lwz R30, <#[R26]> */
		/* 82175360h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 82175360h case   15:*/		return 0x82175364;
		  /* 82175364h */ case   16:  		/* cmplwi CR6, R30, 0 */
		/* 82175364h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82175364h case   16:*/		return 0x82175368;
		  /* 82175368h */ case   17:  		/* bc 12, CR6_EQ, 36 */
		/* 82175368h case   17:*/		if ( regs.CR[6].eq ) { return 0x8217538C;  }
		/* 82175368h case   17:*/		return 0x8217536C;
		  /* 8217536Ch */ case   18:  		/* lwz R11, <#[R30]> */
		/* 8217536Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8217536Ch case   18:*/		return 0x82175370;
		  /* 82175370h */ case   19:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82175370h case   19:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82175370h case   19:*/		return 0x82175374;
		  /* 82175374h */ case   20:  		/* bc 4, CR0_EQ, 16 */
		/* 82175374h case   20:*/		if ( !regs.CR[0].eq ) { return 0x82175384;  }
		/* 82175374h case   20:*/		return 0x82175378;
		  /* 82175378h */ case   21:  		/* mr R4, R30 */
		/* 82175378h case   21:*/		regs.R4 = regs.R30;
		/* 82175378h case   21:*/		return 0x8217537C;
		  /* 8217537Ch */ case   22:  		/* mr R3, R31 */
		/* 8217537Ch case   22:*/		regs.R3 = regs.R31;
		/* 8217537Ch case   22:*/		return 0x82175380;
		  /* 82175380h */ case   23:  		/* bl 11848 */
		/* 82175380h case   23:*/		regs.LR = 0x82175384; return 0x821781C8;
		/* 82175380h case   23:*/		return 0x82175384;
	}
	return 0x82175384;
} // Block from 82175324h-82175384h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82175384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175384);
		  /* 82175384h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82175384h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82175384h case    0:*/		return 0x82175388;
		  /* 82175388h */ case    1:  		/* b -36 */
		/* 82175388h case    1:*/		return 0x82175364;
		/* 82175388h case    1:*/		return 0x8217538C;
	}
	return 0x8217538C;
} // Block from 82175384h-8217538Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8217538Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217538C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217538C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217538C);
		  /* 8217538Ch */ case    0:  		/* mr R8, R29 */
		/* 8217538Ch case    0:*/		regs.R8 = regs.R29;
		/* 8217538Ch case    0:*/		return 0x82175390;
		  /* 82175390h */ case    1:  		/* mr R11, R8 */
		/* 82175390h case    1:*/		regs.R11 = regs.R8;
		/* 82175390h case    1:*/		return 0x82175394;
		  /* 82175394h */ case    2:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175394h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175394h case    2:*/		return 0x82175398;
		  /* 82175398h */ case    3:  		/* lwz R11, <#[R11 + 36]> */
		/* 82175398h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82175398h case    3:*/		return 0x8217539C;
		  /* 8217539Ch */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8217539Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8217539Ch case    4:*/		return 0x821753A0;
		  /* 821753A0h */ case    5:  		/* bc 4, CR0_EQ, 60 */
		/* 821753A0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821753DC;  }
		/* 821753A0h case    5:*/		return 0x821753A4;
		  /* 821753A4h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821753A4h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821753A4h case    6:*/		return 0x821753A8;
		  /* 821753A8h */ case    7:  		/* addic. R11, R11, -40 */
		/* 821753A8h case    7:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 821753A8h case    7:*/		return 0x821753AC;
		  /* 821753ACh */ case    8:  		/* bc 12, CR0_EQ, 48 */
		/* 821753ACh case    8:*/		if ( regs.CR[0].eq ) { return 0x821753DC;  }
		/* 821753ACh case    8:*/		return 0x821753B0;
		  /* 821753B0h */ case    9:  		/* lwz R10, <#[R11 + 8]> */
		/* 821753B0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821753B0h case    9:*/		return 0x821753B4;
		  /* 821753B4h */ case   10:  		/* rlwinm. R10, R10, 6, 31, 31 */
		/* 821753B4h case   10:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R10);
		/* 821753B4h case   10:*/		return 0x821753B8;
		  /* 821753B8h */ case   11:  		/* bc 12, CR0_EQ, -36 */
		/* 821753B8h case   11:*/		if ( regs.CR[0].eq ) { return 0x82175394;  }
		/* 821753B8h case   11:*/		return 0x821753BC;
		  /* 821753BCh */ case   12:  		/* lwz R10, <#[R11 + 20]> */
		/* 821753BCh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821753BCh case   12:*/		return 0x821753C0;
		  /* 821753C0h */ case   13:  		/* lwz R9, <#[R11 + 16]> */
		/* 821753C0h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821753C0h case   13:*/		return 0x821753C4;
		  /* 821753C4h */ case   14:  		/* rlwimi R9, R10, 27, 5, 31 */
		/* 821753C4h case   14:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R9,regs.R10);
		/* 821753C4h case   14:*/		return 0x821753C8;
		  /* 821753C8h */ case   15:  		/* rlwinm R10, R9, 12, 21, 31 */
		/* 821753C8h case   15:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R10,regs.R9);
		/* 821753C8h case   15:*/		return 0x821753CC;
		  /* 821753CCh */ case   16:  		/* cmplw CR6, R10, R28 */
		/* 821753CCh case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 821753CCh case   16:*/		return 0x821753D0;
		  /* 821753D0h */ case   17:  		/* bc 4, CR6_EQ, 12 */
		/* 821753D0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821753DC;  }
		/* 821753D0h case   17:*/		return 0x821753D4;
		  /* 821753D4h */ case   18:  		/* mr R8, R11 */
		/* 821753D4h case   18:*/		regs.R8 = regs.R11;
		/* 821753D4h case   18:*/		return 0x821753D8;
		  /* 821753D8h */ case   19:  		/* b -72 */
		/* 821753D8h case   19:*/		return 0x82175390;
		/* 821753D8h case   19:*/		return 0x821753DC;
	}
	return 0x821753DC;
} // Block from 8217538Ch-821753DCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 821753DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821753DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821753DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821753DC);
		  /* 821753DCh */ case    0:  		/* rlwinm R11, R8, 0, 0, 30 */
		/* 821753DCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R8);
		/* 821753DCh case    0:*/		return 0x821753E0;
		  /* 821753E0h */ case    1:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821753E0h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821753E0h case    1:*/		return 0x821753E4;
		  /* 821753E4h */ case    2:  		/* addi R11, R11, 36 */
		/* 821753E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821753E4h case    2:*/		return 0x821753E8;
		  /* 821753E8h */ case    3:  		/* addi R10, R10, 36 */
		/* 821753E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821753E8h case    3:*/		return 0x821753EC;
		  /* 821753ECh */ case    4:  		/* addi R6, R11, -36 */
		/* 821753ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 821753ECh case    4:*/		return 0x821753F0;
		  /* 821753F0h */ case    5:  		/* addi R5, R10, -36 */
		/* 821753F0h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFFFDC);
		/* 821753F0h case    5:*/		return 0x821753F4;
		  /* 821753F4h */ case    6:  		/* addi R9, R10, 4 */
		/* 821753F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821753F4h case    6:*/		return 0x821753F8;
		  /* 821753F8h */ case    7:  		/* lwz R4, <#[R11]> */
		/* 821753F8h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 821753F8h case    7:*/		return 0x821753FC;
		  /* 821753FCh */ case    8:  		/* mr R7, R25 */
		/* 821753FCh case    8:*/		regs.R7 = regs.R25;
		/* 821753FCh case    8:*/		return 0x82175400;
		  /* 82175400h */ case    9:  		/* stw R4, <#[R10]> */
		/* 82175400h case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 82175400h case    9:*/		return 0x82175404;
		  /* 82175404h */ case   10:  		/* lwz R4, <#[R11]> */
		/* 82175404h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 82175404h case   10:*/		return 0x82175408;
		  /* 82175408h */ case   11:  		/* rlwinm R4, R4, 0, 0, 30 */
		/* 82175408h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R4,regs.R4);
		/* 82175408h case   11:*/		return 0x8217540C;
		  /* 8217540Ch */ case   12:  		/* stw R5, <#[R4]> */
		/* 8217540Ch case   12:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x00000000) );
		/* 8217540Ch case   12:*/		return 0x82175410;
		  /* 82175410h */ case   13:  		/* stw R6, <#[R10 + 4]> */
		/* 82175410h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82175410h case   13:*/		return 0x82175414;
		  /* 82175414h */ case   14:  		/* stw R9, <#[R11]> */
		/* 82175414h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82175414h case   14:*/		return 0x82175418;
		  /* 82175418h */ case   15:  		/* lwz R9, <#[R31 + 8]> */
		/* 82175418h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82175418h case   15:*/		return 0x8217541C;
		  /* 8217541Ch */ case   16:  		/* lwz R10, <#[R31 + 20]> */
		/* 8217541Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8217541Ch case   16:*/		return 0x82175420;
		  /* 82175420h */ case   17:  		/* rlwimi R10, R28, 25, 0, 6 */
		/* 82175420h case   17:*/		cpu::op::rlwimi<0,25,0,6>(regs,&regs.R10,regs.R28);
		/* 82175420h case   17:*/		return 0x82175424;
		  /* 82175424h */ case   18:  		/* lwz R11, <#[R31 + 16]> */
		/* 82175424h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82175424h case   18:*/		return 0x82175428;
		  /* 82175428h */ case   19:  		/* oris R9, R9, 1024 */
		/* 82175428h case   19:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x400);
		/* 82175428h case   19:*/		return 0x8217542C;
		  /* 8217542Ch */ case   20:  		/* stw R10, <#[R31 + 20]> */
		/* 8217542Ch case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8217542Ch case   20:*/		return 0x82175430;
		  /* 82175430h */ case   21:  		/* rlwimi R11, R28, 20, 1, 4 */
		/* 82175430h case   21:*/		cpu::op::rlwimi<0,20,1,4>(regs,&regs.R11,regs.R28);
		/* 82175430h case   21:*/		return 0x82175434;
		  /* 82175434h */ case   22:  		/* stw R9, <#[R31 + 8]> */
		/* 82175434h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82175434h case   22:*/		return 0x82175438;
		  /* 82175438h */ case   23:  		/* stw R11, <#[R31 + 16]> */
		/* 82175438h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82175438h case   23:*/		return 0x8217543C;
		  /* 8217543Ch */ case   24:  		/* stw R31, <#[R8 + 32]> */
		/* 8217543Ch case   24:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R8 + 0x00000020) );
		/* 8217543Ch case   24:*/		return 0x82175440;
		  /* 82175440h */ case   25:  		/* lwz R11, <#[R7]> */
		/* 82175440h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82175440h case   25:*/		return 0x82175444;
		  /* 82175444h */ case   26:  		/* cmplwi CR6, R11, 0 */
		/* 82175444h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175444h case   26:*/		return 0x82175448;
		  /* 82175448h */ case   27:  		/* bc 12, CR6_EQ, -644 */
		/* 82175448h case   27:*/		if ( regs.CR[6].eq ) { return 0x821751C4;  }
		/* 82175448h case   27:*/		return 0x8217544C;
		  /* 8217544Ch */ case   28:  		/* lwz R8, <#[R11 + 16]> */
		/* 8217544Ch case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8217544Ch case   28:*/		return 0x82175450;
		  /* 82175450h */ case   29:  		/* cmplwi CR6, R8, 0 */
		/* 82175450h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82175450h case   29:*/		return 0x82175454;
		  /* 82175454h */ case   30:  		/* bc 12, CR6_EQ, 132 */
		/* 82175454h case   30:*/		if ( regs.CR[6].eq ) { return 0x821754D8;  }
		/* 82175454h case   30:*/		return 0x82175458;
		  /* 82175458h */ case   31:  		/* lwz R9, <#[R11]> */
		/* 82175458h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82175458h case   31:*/		return 0x8217545C;
		  /* 8217545Ch */ case   32:  		/* rlwinm. R10, R9, 0, 1, 1 */
		/* 8217545Ch case   32:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R9);
		/* 8217545Ch case   32:*/		return 0x82175460;
		  /* 82175460h */ case   33:  		/* bc 12, CR0_EQ, 16 */
		/* 82175460h case   33:*/		if ( regs.CR[0].eq ) { return 0x82175470;  }
		/* 82175460h case   33:*/		return 0x82175464;
		  /* 82175464h */ case   34:  		/* rlwinm. R10, R9, 0, 4, 6 */
		/* 82175464h case   34:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R9);
		/* 82175464h case   34:*/		return 0x82175468;
		  /* 82175468h */ case   35:  		/* mr R10, R16 */
		/* 82175468h case   35:*/		regs.R10 = regs.R16;
		/* 82175468h case   35:*/		return 0x8217546C;
		  /* 8217546Ch */ case   36:  		/* bc 12, CR0_EQ, 8 */
		/* 8217546Ch case   36:*/		if ( regs.CR[0].eq ) { return 0x82175474;  }
		/* 8217546Ch case   36:*/		return 0x82175470;
	}
	return 0x82175470;
} // Block from 821753DCh-82175470h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82175470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175470);
		  /* 82175470h */ case    0:  		/* mr R10, R14 */
		/* 82175470h case    0:*/		regs.R10 = regs.R14;
		/* 82175470h case    0:*/		return 0x82175474;
	}
	return 0x82175474;
} // Block from 82175470h-82175474h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82175474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175474);
		  /* 82175474h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82175474h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82175474h case    0:*/		return 0x82175478;
		  /* 82175478h */ case    1:  		/* bc 12, CR0_EQ, 96 */
		/* 82175478h case    1:*/		if ( regs.CR[0].eq ) { return 0x821754D8;  }
		/* 82175478h case    1:*/		return 0x8217547C;
		  /* 8217547Ch */ case    2:  		/* rlwinm R10, R9, 19, 20, 31 */
		/* 8217547Ch case    2:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R10,regs.R9);
		/* 8217547Ch case    2:*/		return 0x82175480;
		  /* 82175480h */ case    3:  		/* cmpw CR6, R10, R27 */
		/* 82175480h case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R27);
		/* 82175480h case    3:*/		return 0x82175484;
		  /* 82175484h */ case    4:  		/* bc 4, CR6_EQ, 84 */
		/* 82175484h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821754D8;  }
		/* 82175484h case    4:*/		return 0x82175488;
		  /* 82175488h */ case    5:  		/* lwz R10, <#[R8 + 20]> */
		/* 82175488h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000014) );
		/* 82175488h case    5:*/		return 0x8217548C;
		  /* 8217548Ch */ case    6:  		/* lwz R9, <#[R8 + 16]> */
		/* 8217548Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000010) );
		/* 8217548Ch case    6:*/		return 0x82175490;
		  /* 82175490h */ case    7:  		/* rlwimi R9, R10, 27, 5, 31 */
		/* 82175490h case    7:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R9,regs.R10);
		/* 82175490h case    7:*/		return 0x82175494;
		  /* 82175494h */ case    8:  		/* rlwinm R10, R9, 12, 21, 31 */
		/* 82175494h case    8:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R10,regs.R9);
		/* 82175494h case    8:*/		return 0x82175498;
		  /* 82175498h */ case    9:  		/* cmplw CR6, R10, R28 */
		/* 82175498h case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 82175498h case    9:*/		return 0x8217549C;
		  /* 8217549Ch */ case   10:  		/* bc 4, CR6_EQ, 60 */
		/* 8217549Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x821754D8;  }
		/* 8217549Ch case   10:*/		return 0x821754A0;
		  /* 821754A0h */ case   11:  		/* lwz R10, <#[R11 + 12]> */
		/* 821754A0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821754A0h case   11:*/		return 0x821754A4;
		  /* 821754A4h */ case   12:  		/* addi R10, R10, 4 */
		/* 821754A4h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821754A4h case   12:*/		return 0x821754A8;
		  /* 821754A8h */ case   13:  		/* lwz R9, <#[R10]> */
		/* 821754A8h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821754A8h case   13:*/		return 0x821754AC;
		  /* 821754ACh */ case   14:  		/* b 12 */
		/* 821754ACh case   14:*/		return 0x821754B8;
		/* 821754ACh case   14:*/		return 0x821754B0;
		  /* 821754B0h */ case   15:  		/* addi R10, R9, 8 */
		/* 821754B0h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821754B0h case   15:*/		return 0x821754B4;
		  /* 821754B4h */ case   16:  		/* lwz R9, <#[R9 + 8]> */
		/* 821754B4h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821754B4h case   16:*/		return 0x821754B8;
	}
	return 0x821754B8;
} // Block from 82175474h-821754B8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821754B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821754B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821754B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821754B8);
		  /* 821754B8h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821754B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821754B8h case    0:*/		return 0x821754BC;
		  /* 821754BCh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821754BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821754B0;  }
		/* 821754BCh case    1:*/		return 0x821754C0;
		  /* 821754C0h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821754C0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821754C0h case    2:*/		return 0x821754C4;
		  /* 821754C4h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821754C4h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821754C4h case    3:*/		return 0x821754C8;
		  /* 821754C8h */ case    4:  		/* lwz R10, <#[R31 + 4]> */
		/* 821754C8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821754C8h case    4:*/		return 0x821754CC;
		  /* 821754CCh */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821754CCh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821754CCh case    5:*/		return 0x821754D0;
		  /* 821754D0h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 821754D0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821754D0h case    6:*/		return 0x821754D4;
		  /* 821754D4h */ case    7:  		/* stw R31, <#[R11 + 12]> */
		/* 821754D4h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821754D4h case    7:*/		return 0x821754D8;
	}
	return 0x821754D8;
} // Block from 821754B8h-821754D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821754D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821754D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821754D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821754D8);
		  /* 821754D8h */ case    0:  		/* lwz R10, <#[R7]> */
		/* 821754D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 821754D8h case    0:*/		return 0x821754DC;
		  /* 821754DCh */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821754DCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821754DCh case    1:*/		return 0x821754E0;
		  /* 821754E0h */ case    2:  		/* bc 4, CR6_EQ, -160 */
		/* 821754E0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82175440;  }
		/* 821754E0h case    2:*/		return 0x821754E4;
		  /* 821754E4h */ case    3:  		/* addi R7, R11, 8 */
		/* 821754E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x8);
		/* 821754E4h case    3:*/		return 0x821754E8;
		  /* 821754E8h */ case    4:  		/* b -168 */
		/* 821754E8h case    4:*/		return 0x82175440;
		/* 821754E8h case    4:*/		return 0x821754EC;
	}
	return 0x821754EC;
} // Block from 821754D8h-821754ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821754ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821754EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821754EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821754EC);
		  /* 821754ECh */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821754ECh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821754ECh case    0:*/		return 0x821754F0;
		  /* 821754F0h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821754F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821754F0h case    1:*/		return 0x821754F4;
		  /* 821754F4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821754F4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821754F4h case    2:*/		return 0x821754F8;
		  /* 821754F8h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821754F8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82175508;  }
		/* 821754F8h case    3:*/		return 0x821754FC;
		  /* 821754FCh */ case    4:  		/* mr R26, R11 */
		/* 821754FCh case    4:*/		regs.R26 = regs.R11;
		/* 821754FCh case    4:*/		return 0x82175500;
		  /* 82175500h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82175500h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175500h case    5:*/		return 0x82175504;
		  /* 82175504h */ case    6:  		/* bc 4, CR6_EQ, -1144 */
		/* 82175504h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8217508C;  }
		/* 82175504h case    6:*/		return 0x82175508;
	}
	return 0x82175508;
} // Block from 821754ECh-82175508h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82175508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175508);
		  /* 82175508h */ case    0:  		/* li R5, 0 */
		/* 82175508h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82175508h case    0:*/		return 0x8217550C;
		  /* 8217550Ch */ case    1:  		/* mr R4, R20 */
		/* 8217550Ch case    1:*/		regs.R4 = regs.R20;
		/* 8217550Ch case    1:*/		return 0x82175510;
		  /* 82175510h */ case    2:  		/* mr R3, R18 */
		/* 82175510h case    2:*/		regs.R3 = regs.R18;
		/* 82175510h case    2:*/		return 0x82175514;
		  /* 82175514h */ case    3:  		/* bl -14508 */
		/* 82175514h case    3:*/		regs.LR = 0x82175518; return 0x82171C68;
		/* 82175514h case    3:*/		return 0x82175518;
		  /* 82175518h */ case    4:  		/* lwz R11, <#[R19 + 4]> */
		/* 82175518h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82175518h case    4:*/		return 0x8217551C;
		  /* 8217551Ch */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8217551Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8217551Ch case    5:*/		return 0x82175520;
		  /* 82175520h */ case    6:  		/* bc 4, CR0_EQ, 240 */
		/* 82175520h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82175610;  }
		/* 82175520h case    6:*/		return 0x82175524;
		  /* 82175524h */ case    7:  		/* mr R27, R11 */
		/* 82175524h case    7:*/		regs.R27 = regs.R11;
		/* 82175524h case    7:*/		return 0x82175528;
		  /* 82175528h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82175528h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82175528h case    8:*/		return 0x8217552C;
		  /* 8217552Ch */ case    9:  		/* bc 12, CR0_EQ, 228 */
		/* 8217552Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82175610;  }
		/* 8217552Ch case    9:*/		return 0x82175530;
		  /* 82175530h */ case   10:  		/* lwz R11, <#[R27 + 8]> */
		/* 82175530h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82175530h case   10:*/		return 0x82175534;
		  /* 82175534h */ case   11:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 82175534h case   11:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 82175534h case   11:*/		return 0x82175538;
		  /* 82175538h */ case   12:  		/* bc 12, CR0_EQ, 188 */
		/* 82175538h case   12:*/		if ( regs.CR[0].eq ) { return 0x821755F4;  }
		/* 82175538h case   12:*/		return 0x8217553C;
		  /* 8217553Ch */ case   13:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8217553Ch case   13:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8217553Ch case   13:*/		return 0x82175540;
		  /* 82175540h */ case   14:  		/* bc 4, CR0_EQ, 180 */
		/* 82175540h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821755F4;  }
		/* 82175540h case   14:*/		return 0x82175544;
		  /* 82175544h */ case   15:  		/* lwz R11, <#[R27 + 4]> */
		/* 82175544h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82175544h case   15:*/		return 0x82175548;
		  /* 82175548h */ case   16:  		/* addi R9, R27, 4 */
		/* 82175548h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x4);
		/* 82175548h case   16:*/		return 0x8217554C;
		  /* 8217554Ch */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 8217554Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8217554Ch case   17:*/		return 0x82175550;
		  /* 82175550h */ case   18:  		/* bc 12, CR6_EQ, 164 */
		/* 82175550h case   18:*/		if ( regs.CR[6].eq ) { return 0x821755F4;  }
		/* 82175550h case   18:*/		return 0x82175554;
		  /* 82175554h */ case   19:  		/* lwz R10, <#[R11 + 16]> */
		/* 82175554h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82175554h case   19:*/		return 0x82175558;
		  /* 82175558h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 82175558h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82175558h case   20:*/		return 0x8217555C;
		  /* 8217555Ch */ case   21:  		/* bc 12, CR6_EQ, 36 */
		/* 8217555Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82175580;  }
		/* 8217555Ch case   21:*/		return 0x82175560;
		  /* 82175560h */ case   22:  		/* lwz R8, <#[R11]> */
		/* 82175560h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82175560h case   22:*/		return 0x82175564;
		  /* 82175564h */ case   23:  		/* rlwinm. R8, R8, 0, 4, 6 */
		/* 82175564h case   23:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R8);
		/* 82175564h case   23:*/		return 0x82175568;
		  /* 82175568h */ case   24:  		/* bc 12, CR0_EQ, 24 */
		/* 82175568h case   24:*/		if ( regs.CR[0].eq ) { return 0x82175580;  }
		/* 82175568h case   24:*/		return 0x8217556C;
		  /* 8217556Ch */ case   25:  		/* lwz R8, <#[R10 + 8]> */
		/* 8217556Ch case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 8217556Ch case   25:*/		return 0x82175570;
		  /* 82175570h */ case   26:  		/* mr R28, R10 */
		/* 82175570h case   26:*/		regs.R28 = regs.R10;
		/* 82175570h case   26:*/		return 0x82175574;
		  /* 82175574h */ case   27:  		/* rlwinm R10, R8, 0, 18, 24 */
		/* 82175574h case   27:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R8);
		/* 82175574h case   27:*/		return 0x82175578;
		  /* 82175578h */ case   28:  		/* cmplwi CR6, R10, 14080 */
		/* 82175578h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 82175578h case   28:*/		return 0x8217557C;
		  /* 8217557Ch */ case   29:  		/* bc 12, CR6_EQ, 12 */
		/* 8217557Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x82175588;  }
		/* 8217557Ch case   29:*/		return 0x82175580;
	}
	return 0x82175580;
} // Block from 82175508h-82175580h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82175580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175580);
		  /* 82175580h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82175580h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82175580h case    0:*/		return 0x82175584;
		  /* 82175584h */ case    1:  		/* b -56 */
		/* 82175584h case    1:*/		return 0x8217554C;
		/* 82175584h case    1:*/		return 0x82175588;
	}
	return 0x82175588;
} // Block from 82175580h-82175588h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175588);
		  /* 82175588h */ case    0:  		/* mr R29, R9 */
		/* 82175588h case    0:*/		regs.R29 = regs.R9;
		/* 82175588h case    0:*/		return 0x8217558C;
		  /* 8217558Ch */ case    1:  		/* lwz R30, <#[R29]> */
		/* 8217558Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 8217558Ch case    1:*/		return 0x82175590;
		  /* 82175590h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 82175590h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82175590h case    2:*/		return 0x82175594;
		  /* 82175594h */ case    3:  		/* bc 12, CR6_EQ, 96 */
		/* 82175594h case    3:*/		if ( regs.CR[6].eq ) { return 0x821755F4;  }
		/* 82175594h case    3:*/		return 0x82175598;
		  /* 82175598h */ case    4:  		/* lwz R31, <#[R30 + 16]> */
		/* 82175598h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82175598h case    4:*/		return 0x8217559C;
		  /* 8217559Ch */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 8217559Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8217559Ch case    5:*/		return 0x821755A0;
		  /* 821755A0h */ case    6:  		/* bc 12, CR6_EQ, 64 */
		/* 821755A0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821755E0;  }
		/* 821755A0h case    6:*/		return 0x821755A4;
		  /* 821755A4h */ case    7:  		/* mr R3, R30 */
		/* 821755A4h case    7:*/		regs.R3 = regs.R30;
		/* 821755A4h case    7:*/		return 0x821755A8;
		  /* 821755A8h */ case    8:  		/* bl -68984 */
		/* 821755A8h case    8:*/		regs.LR = 0x821755AC; return 0x82164830;
		/* 821755A8h case    8:*/		return 0x821755AC;
		  /* 821755ACh */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821755ACh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821755ACh case    9:*/		return 0x821755B0;
		  /* 821755B0h */ case   10:  		/* bc 12, CR0_EQ, 48 */
		/* 821755B0h case   10:*/		if ( regs.CR[0].eq ) { return 0x821755E0;  }
		/* 821755B0h case   10:*/		return 0x821755B4;
		  /* 821755B4h */ case   11:  		/* cmplw CR6, R31, R28 */
		/* 821755B4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 821755B4h case   11:*/		return 0x821755B8;
		  /* 821755B8h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 821755B8h case   12:*/		if ( regs.CR[6].eq ) { return 0x821755E0;  }
		/* 821755B8h case   12:*/		return 0x821755BC;
		  /* 821755BCh */ case   13:  		/* mr R4, R28 */
		/* 821755BCh case   13:*/		regs.R4 = regs.R28;
		/* 821755BCh case   13:*/		return 0x821755C0;
		  /* 821755C0h */ case   14:  		/* mr R3, R31 */
		/* 821755C0h case   14:*/		regs.R3 = regs.R31;
		/* 821755C0h case   14:*/		return 0x821755C4;
		  /* 821755C4h */ case   15:  		/* bl -15612 */
		/* 821755C4h case   15:*/		regs.LR = 0x821755C8; return 0x821718C8;
		/* 821755C4h case   15:*/		return 0x821755C8;
		  /* 821755C8h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821755C8h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821755C8h case   16:*/		return 0x821755CC;
		  /* 821755CCh */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 821755CCh case   17:*/		if ( regs.CR[0].eq ) { return 0x821755E0;  }
		/* 821755CCh case   17:*/		return 0x821755D0;
		  /* 821755D0h */ case   18:  		/* mr R5, R18 */
		/* 821755D0h case   18:*/		regs.R5 = regs.R18;
		/* 821755D0h case   18:*/		return 0x821755D4;
		  /* 821755D4h */ case   19:  		/* mr R4, R31 */
		/* 821755D4h case   19:*/		regs.R4 = regs.R31;
		/* 821755D4h case   19:*/		return 0x821755D8;
		  /* 821755D8h */ case   20:  		/* mr R3, R28 */
		/* 821755D8h case   20:*/		regs.R3 = regs.R28;
		/* 821755D8h case   20:*/		return 0x821755DC;
		  /* 821755DCh */ case   21:  		/* bl 11444 */
		/* 821755DCh case   21:*/		regs.LR = 0x821755E0; return 0x82178290;
		/* 821755DCh case   21:*/		return 0x821755E0;
	}
	return 0x821755E0;
} // Block from 82175588h-821755E0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821755E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821755E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821755E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821755E0);
		  /* 821755E0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821755E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821755E0h case    0:*/		return 0x821755E4;
		  /* 821755E4h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 821755E4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821755E4h case    1:*/		return 0x821755E8;
		  /* 821755E8h */ case    2:  		/* bc 4, CR6_EQ, -92 */
		/* 821755E8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8217558C;  }
		/* 821755E8h case    2:*/		return 0x821755EC;
		  /* 821755ECh */ case    3:  		/* addi R29, R30, 8 */
		/* 821755ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x8);
		/* 821755ECh case    3:*/		return 0x821755F0;
		  /* 821755F0h */ case    4:  		/* b -100 */
		/* 821755F0h case    4:*/		return 0x8217558C;
		/* 821755F0h case    4:*/		return 0x821755F4;
	}
	return 0x821755F4;
} // Block from 821755E0h-821755F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821755F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821755F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821755F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821755F4);
		  /* 821755F4h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 821755F4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 821755F4h case    0:*/		return 0x821755F8;
		  /* 821755F8h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821755F8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821755F8h case    1:*/		return 0x821755FC;
		  /* 821755FCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821755FCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821755FCh case    2:*/		return 0x82175600;
		  /* 82175600h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82175600h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82175610;  }
		/* 82175600h case    3:*/		return 0x82175604;
		  /* 82175604h */ case    4:  		/* mr R27, R11 */
		/* 82175604h case    4:*/		regs.R27 = regs.R11;
		/* 82175604h case    4:*/		return 0x82175608;
		  /* 82175608h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82175608h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175608h case    5:*/		return 0x8217560C;
		  /* 8217560Ch */ case    6:  		/* bc 4, CR6_EQ, -220 */
		/* 8217560Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82175530;  }
		/* 8217560Ch case    6:*/		return 0x82175610;
	}
	return 0x82175610;
} // Block from 821755F4h-82175610h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82175610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175610);
		  /* 82175610h */ case    0:  		/* lwz R31, <#[R19 + 4]> */
		/* 82175610h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R19 + 0x00000004) );
		/* 82175610h case    0:*/		return 0x82175614;
		  /* 82175614h */ case    1:  		/* rlwinm. R29, R31, 0, 31, 31 */
		/* 82175614h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R29,regs.R31);
		/* 82175614h case    1:*/		return 0x82175618;
		  /* 82175618h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82175618h case    2:*/		if ( regs.CR[0].eq ) { return 0x82175624;  }
		/* 82175618h case    2:*/		return 0x8217561C;
		  /* 8217561Ch */ case    3:  		/* mr R30, R14 */
		/* 8217561Ch case    3:*/		regs.R30 = regs.R14;
		/* 8217561Ch case    3:*/		return 0x82175620;
		  /* 82175620h */ case    4:  		/* b 16 */
		/* 82175620h case    4:*/		return 0x82175630;
		/* 82175620h case    4:*/		return 0x82175624;
	}
	return 0x82175624;
} // Block from 82175610h-82175624h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82175624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175624);
		  /* 82175624h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 82175624h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82175624h case    0:*/		return 0x82175628;
		  /* 82175628h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175628h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175628h case    1:*/		return 0x8217562C;
		  /* 8217562Ch */ case    2:  		/* addi R30, R11, -40 */
		/* 8217562Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFD8);
		/* 8217562Ch case    2:*/		return 0x82175630;
	}
	return 0x82175630;
} // Block from 82175624h-82175630h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175630);
		  /* 82175630h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82175630h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82175630h case    0:*/		return 0x82175634;
		  /* 82175634h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82175634h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82175634h case    1:*/		return 0x82175638;
		  /* 82175638h */ case    2:  		/* cmplwi CR6, R11, 86 */
		/* 82175638h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 82175638h case    2:*/		return 0x8217563C;
		  /* 8217563Ch */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8217563Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8217566C;  }
		/* 8217563Ch case    3:*/		return 0x82175640;
		  /* 82175640h */ case    4:  		/* cmplwi CR6, R11, 87 */
		/* 82175640h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 82175640h case    4:*/		return 0x82175644;
		  /* 82175644h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 82175644h case    5:*/		if ( regs.CR[6].eq ) { return 0x8217566C;  }
		/* 82175644h case    5:*/		return 0x82175648;
		  /* 82175648h */ case    6:  		/* cmplwi CR6, R11, 89 */
		/* 82175648h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 82175648h case    6:*/		return 0x8217564C;
		  /* 8217564Ch */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8217564Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8217566C;  }
		/* 8217564Ch case    7:*/		return 0x82175650;
		  /* 82175650h */ case    8:  		/* cmplwi CR6, R11, 90 */
		/* 82175650h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 82175650h case    8:*/		return 0x82175654;
		  /* 82175654h */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 82175654h case    9:*/		if ( regs.CR[6].eq ) { return 0x8217566C;  }
		/* 82175654h case    9:*/		return 0x82175658;
		  /* 82175658h */ case   10:  		/* cmplwi CR6, R11, 84 */
		/* 82175658h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000054);
		/* 82175658h case   10:*/		return 0x8217565C;
		  /* 8217565Ch */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 8217565Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8217566C;  }
		/* 8217565Ch case   11:*/		return 0x82175660;
		  /* 82175660h */ case   12:  		/* cmplwi CR6, R11, 85 */
		/* 82175660h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000055);
		/* 82175660h case   12:*/		return 0x82175664;
		  /* 82175664h */ case   13:  		/* mr R11, R14 */
		/* 82175664h case   13:*/		regs.R11 = regs.R14;
		/* 82175664h case   13:*/		return 0x82175668;
		  /* 82175668h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 82175668h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82175670;  }
		/* 82175668h case   14:*/		return 0x8217566C;
	}
	return 0x8217566C;
} // Block from 82175630h-8217566Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8217566Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217566C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217566C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217566C);
		  /* 8217566Ch */ case    0:  		/* mr R11, R16 */
		/* 8217566Ch case    0:*/		regs.R11 = regs.R16;
		/* 8217566Ch case    0:*/		return 0x82175670;
	}
	return 0x82175670;
} // Block from 8217566Ch-82175670h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82175670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175670);
		  /* 82175670h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82175670h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82175670h case    0:*/		return 0x82175674;
		  /* 82175674h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 82175674h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82175688;  }
		/* 82175674h case    1:*/		return 0x82175678;
		  /* 82175678h */ case    2:  		/* mr R3, R30 */
		/* 82175678h case    2:*/		regs.R3 = regs.R30;
		/* 82175678h case    2:*/		return 0x8217567C;
		  /* 8217567Ch */ case    3:  		/* bl -71116 */
		/* 8217567Ch case    3:*/		regs.LR = 0x82175680; return 0x821640B0;
		/* 8217567Ch case    3:*/		return 0x82175680;
		  /* 82175680h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82175680h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82175680h case    4:*/		return 0x82175684;
		  /* 82175684h */ case    5:  		/* bc 12, CR0_EQ, 84 */
		/* 82175684h case    5:*/		if ( regs.CR[0].eq ) { return 0x821756D8;  }
		/* 82175684h case    5:*/		return 0x82175688;
	}
	return 0x82175688;
} // Block from 82175670h-82175688h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82175688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175688);
		  /* 82175688h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82175688h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82175688h case    0:*/		return 0x8217568C;
		  /* 8217568Ch */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 8217568Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821756D8;  }
		/* 8217568Ch case    1:*/		return 0x82175690;
		  /* 82175690h */ case    2:  		/* cmplwi CR0, R31, 0 */
		/* 82175690h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 82175690h case    2:*/		return 0x82175694;
		  /* 82175694h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 82175694h case    3:*/		if ( regs.CR[0].eq ) { return 0x821756D8;  }
		/* 82175694h case    3:*/		return 0x82175698;
		  /* 82175698h */ case    4:  		/* cmplw CR6, R31, R30 */
		/* 82175698h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82175698h case    4:*/		return 0x8217569C;
		  /* 8217569Ch */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 8217569Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821756D8;  }
		/* 8217569Ch case    5:*/		return 0x821756A0;
		  /* 821756A0h */ case    6:  		/* mr R3, R31 */
		/* 821756A0h case    6:*/		regs.R3 = regs.R31;
		/* 821756A0h case    6:*/		return 0x821756A4;
		  /* 821756A4h */ case    7:  		/* bl -35100 */
		/* 821756A4h case    7:*/		regs.LR = 0x821756A8; return 0x8216CD88;
		/* 821756A4h case    7:*/		return 0x821756A8;
		  /* 821756A8h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821756A8h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821756A8h case    8:*/		return 0x821756AC;
		  /* 821756ACh */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 821756ACh case    9:*/		if ( regs.CR[0].eq ) { return 0x821756C0;  }
		/* 821756ACh case    9:*/		return 0x821756B0;
		  /* 821756B0h */ case   10:  		/* mr R5, R18 */
		/* 821756B0h case   10:*/		regs.R5 = regs.R18;
		/* 821756B0h case   10:*/		return 0x821756B4;
		  /* 821756B4h */ case   11:  		/* mr R4, R31 */
		/* 821756B4h case   11:*/		regs.R4 = regs.R31;
		/* 821756B4h case   11:*/		return 0x821756B8;
		  /* 821756B8h */ case   12:  		/* mr R3, R30 */
		/* 821756B8h case   12:*/		regs.R3 = regs.R30;
		/* 821756B8h case   12:*/		return 0x821756BC;
		  /* 821756BCh */ case   13:  		/* bl 11220 */
		/* 821756BCh case   13:*/		regs.LR = 0x821756C0; return 0x82178290;
		/* 821756BCh case   13:*/		return 0x821756C0;
	}
	return 0x821756C0;
} // Block from 82175688h-821756C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821756C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821756C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821756C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821756C0);
		  /* 821756C0h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821756C0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821756C0h case    0:*/		return 0x821756C4;
		  /* 821756C4h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 821756C4h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 821756C4h case    1:*/		return 0x821756C8;
		  /* 821756C8h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821756C8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821756C8h case    2:*/		return 0x821756CC;
		  /* 821756CCh */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821756CCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821756D8;  }
		/* 821756CCh case    3:*/		return 0x821756D0;
		  /* 821756D0h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821756D0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821756D0h case    4:*/		return 0x821756D4;
		  /* 821756D4h */ case    5:  		/* bc 4, CR6_EQ, -60 */
		/* 821756D4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82175698;  }
		/* 821756D4h case    5:*/		return 0x821756D8;
	}
	return 0x821756D8;
} // Block from 821756C0h-821756D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821756D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821756D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821756D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821756D8);
		  /* 821756D8h */ case    0:  		/* li R5, 0 */
		/* 821756D8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821756D8h case    0:*/		return 0x821756DC;
		  /* 821756DCh */ case    1:  		/* mr R4, R20 */
		/* 821756DCh case    1:*/		regs.R4 = regs.R20;
		/* 821756DCh case    1:*/		return 0x821756E0;
		  /* 821756E0h */ case    2:  		/* mr R3, R18 */
		/* 821756E0h case    2:*/		regs.R3 = regs.R18;
		/* 821756E0h case    2:*/		return 0x821756E4;
		  /* 821756E4h */ case    3:  		/* bl -15124 */
		/* 821756E4h case    3:*/		regs.LR = 0x821756E8; return 0x82171BD0;
		/* 821756E4h case    3:*/		return 0x821756E8;
		  /* 821756E8h */ case    4:  		/* stw R14, <#[R18 + 712]> */
		/* 821756E8h case    4:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R18 + 0x000002C8) );
		/* 821756E8h case    4:*/		return 0x821756EC;
		  /* 821756ECh */ case    5:  		/* stw R14, <#[R18 + 716]> */
		/* 821756ECh case    5:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R18 + 0x000002CC) );
		/* 821756ECh case    5:*/		return 0x821756F0;
		  /* 821756F0h */ case    6:  		/* li R5, 53 */
		/* 821756F0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x35);
		/* 821756F0h case    6:*/		return 0x821756F4;
		  /* 821756F4h */ case    7:  		/* li R4, 8 */
		/* 821756F4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 821756F4h case    7:*/		return 0x821756F8;
		  /* 821756F8h */ case    8:  		/* mr R3, R18 */
		/* 821756F8h case    8:*/		regs.R3 = regs.R18;
		/* 821756F8h case    8:*/		return 0x821756FC;
		  /* 821756FCh */ case    9:  		/* bl -69132 */
		/* 821756FCh case    9:*/		regs.LR = 0x82175700; return 0x821648F0;
		/* 821756FCh case    9:*/		return 0x82175700;
		  /* 82175700h */ case   10:  		/* mr R24, R3 */
		/* 82175700h case   10:*/		regs.R24 = regs.R3;
		/* 82175700h case   10:*/		return 0x82175704;
		  /* 82175704h */ case   11:  		/* mr R3, R18 */
		/* 82175704h case   11:*/		regs.R3 = regs.R18;
		/* 82175704h case   11:*/		return 0x82175708;
		  /* 82175708h */ case   12:  		/* addi R22, R24, 4 */
		/* 82175708h case   12:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R24,0x4);
		/* 82175708h case   12:*/		return 0x8217570C;
		  /* 8217570Ch */ case   13:  		/* ori R11, R24, 1 */
		/* 8217570Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R24,0x1);
		/* 8217570Ch case   13:*/		return 0x82175710;
		  /* 82175710h */ case   14:  		/* ori R10, R22, 1 */
		/* 82175710h case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R22,0x1);
		/* 82175710h case   14:*/		return 0x82175714;
		  /* 82175714h */ case   15:  		/* stw R11, <#[R24 + 4]> */
		/* 82175714h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 82175714h case   15:*/		return 0x82175718;
		  /* 82175718h */ case   16:  		/* stw R10, <#[R24]> */
		/* 82175718h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 82175718h case   16:*/		return 0x8217571C;
		  /* 8217571Ch */ case   17:  		/* bl -12468 */
		/* 8217571Ch case   17:*/		regs.LR = 0x82175720; return 0x82172668;
		/* 8217571Ch case   17:*/		return 0x82175720;
		  /* 82175720h */ case   18:  		/* lwz R11, <#[R24 + 4]> */
		/* 82175720h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 82175720h case   18:*/		return 0x82175724;
		  /* 82175724h */ case   19:  		/* mr R23, R3 */
		/* 82175724h case   19:*/		regs.R23 = regs.R3;
		/* 82175724h case   19:*/		return 0x82175728;
		  /* 82175728h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82175728h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82175728h case   20:*/		return 0x8217572C;
		  /* 8217572Ch */ case   21:  		/* bc 4, CR0_EQ, 40 */
		/* 8217572Ch case   21:*/		if ( !regs.CR[0].eq ) { return 0x82175754;  }
		/* 8217572Ch case   21:*/		return 0x82175730;
		  /* 82175730h */ case   22:  		/* lwz R11, <#[R24]> */
		/* 82175730h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82175730h case   22:*/		return 0x82175734;
		  /* 82175734h */ case   23:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175734h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175734h case   23:*/		return 0x82175738;
		  /* 82175738h */ case   24:  		/* addic. R3, R11, -4 */
		/* 82175738h case   24:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82175738h case   24:*/		return 0x8217573C;
		  /* 8217573Ch */ case   25:  		/* bc 12, CR0_EQ, 24 */
		/* 8217573Ch case   25:*/		if ( regs.CR[0].eq ) { return 0x82175754;  }
		/* 8217573Ch case   25:*/		return 0x82175740;
		  /* 82175740h */ case   26:  		/* lwz R11, <#[R3 + 8]> */
		/* 82175740h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82175740h case   26:*/		return 0x82175744;
		  /* 82175744h */ case   27:  		/* lwz R10, <#[R3 + 12]> */
		/* 82175744h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82175744h case   27:*/		return 0x82175748;
		  /* 82175748h */ case   28:  		/* addi R11, R11, 1 */
		/* 82175748h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82175748h case   28:*/		return 0x8217574C;
		  /* 8217574Ch */ case   29:  		/* cmplw CR6, R11, R10 */
		/* 8217574Ch case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8217574Ch case   29:*/		return 0x82175750;
		  /* 82175750h */ case   30:  		/* bc 4, CR6_GT, 16 */
		/* 82175750h case   30:*/		if ( !regs.CR[6].gt ) { return 0x82175760;  }
		/* 82175750h case   30:*/		return 0x82175754;
	}
	return 0x82175754;
} // Block from 821756D8h-82175754h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82175754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175754);
		  /* 82175754h */ case    0:  		/* li R4, 1 */
		/* 82175754h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82175754h case    0:*/		return 0x82175758;
		  /* 82175758h */ case    1:  		/* mr R3, R24 */
		/* 82175758h case    1:*/		regs.R3 = regs.R24;
		/* 82175758h case    1:*/		return 0x8217575C;
		  /* 8217575Ch */ case    2:  		/* bl 96620 */
		/* 8217575Ch case    2:*/		regs.LR = 0x82175760; return 0x8218D0C8;
		/* 8217575Ch case    2:*/		return 0x82175760;
	}
	return 0x82175760;
} // Block from 82175754h-82175760h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175760);
		  /* 82175760h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82175760h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82175760h case    0:*/		return 0x82175764;
		  /* 82175764h */ case    1:  		/* mr R29, R14 */
		/* 82175764h case    1:*/		regs.R29 = regs.R14;
		/* 82175764h case    1:*/		return 0x82175768;
		  /* 82175768h */ case    2:  		/* mr R30, R14 */
		/* 82175768h case    2:*/		regs.R30 = regs.R14;
		/* 82175768h case    2:*/		return 0x8217576C;
		  /* 8217576Ch */ case    3:  		/* addi R10, R11, 1 */
		/* 8217576Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 8217576Ch case    3:*/		return 0x82175770;
		  /* 82175770h */ case    4:  		/* addi R11, R11, 4 */
		/* 82175770h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82175770h case    4:*/		return 0x82175774;
		  /* 82175774h */ case    5:  		/* stw R10, <#[R3 + 8]> */
		/* 82175774h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82175774h case    5:*/		return 0x82175778;
		  /* 82175778h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82175778h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82175778h case    6:*/		return 0x8217577C;
		  /* 8217577Ch */ case    7:  		/* stwx R23, <#[R11 + R3]> */
		/* 8217577Ch case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8217577Ch case    7:*/		return 0x82175780;
		  /* 82175780h */ case    8:  		/* lwz R11, <#[R19 + 4]> */
		/* 82175780h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82175780h case    8:*/		return 0x82175784;
		  /* 82175784h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82175784h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82175784h case    9:*/		return 0x82175788;
		  /* 82175788h */ case   10:  		/* bc 4, CR0_EQ, 288 */
		/* 82175788h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821758A8;  }
		/* 82175788h case   10:*/		return 0x8217578C;
		  /* 8217578Ch */ case   11:  		/* lwz R11, <#[R19]> */
		/* 8217578Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8217578Ch case   11:*/		return 0x82175790;
		  /* 82175790h */ case   12:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175790h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175790h case   12:*/		return 0x82175794;
		  /* 82175794h */ case   13:  		/* addic. R31, R11, -40 */
		/* 82175794h case   13:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82175794h case   13:*/		return 0x82175798;
		  /* 82175798h */ case   14:  		/* bc 12, CR0_EQ, 272 */
		/* 82175798h case   14:*/		if ( regs.CR[0].eq ) { return 0x821758A8;  }
		/* 82175798h case   14:*/		return 0x8217579C;
		  /* 8217579Ch */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 8217579Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8217579Ch case   15:*/		return 0x821757A0;
		  /* 821757A0h */ case   16:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821757A0h case   16:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821757A0h case   16:*/		return 0x821757A4;
		  /* 821757A4h */ case   17:  		/* bc 12, CR0_EQ, 104 */
		/* 821757A4h case   17:*/		if ( regs.CR[0].eq ) { return 0x8217580C;  }
		/* 821757A4h case   17:*/		return 0x821757A8;
		  /* 821757A8h */ case   18:  		/* lwz R11, <#[R31 + 16]> */
		/* 821757A8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821757A8h case   18:*/		return 0x821757AC;
		  /* 821757ACh */ case   19:  		/* lwz R10, <#[R31 + 20]> */
		/* 821757ACh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821757ACh case   19:*/		return 0x821757B0;
		  /* 821757B0h */ case   20:  		/* rlwimi R11, R10, 27, 5, 31 */
		/* 821757B0h case   20:*/		cpu::op::rlwimi<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 821757B0h case   20:*/		return 0x821757B4;
		  /* 821757B4h */ case   21:  		/* rlwinm R11, R11, 12, 21, 31 */
		/* 821757B4h case   21:*/		cpu::op::rlwinm<0,12,21,31>(regs,&regs.R11,regs.R11);
		/* 821757B4h case   21:*/		return 0x821757B8;
		  /* 821757B8h */ case   22:  		/* cmplw CR6, R11, R29 */
		/* 821757B8h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 821757B8h case   22:*/		return 0x821757BC;
		  /* 821757BCh */ case   23:  		/* bc 12, CR6_EQ, 40 */
		/* 821757BCh case   23:*/		if ( regs.CR[6].eq ) { return 0x821757E4;  }
		/* 821757BCh case   23:*/		return 0x821757C0;
		  /* 821757C0h */ case   24:  		/* mr R3, R31 */
		/* 821757C0h case   24:*/		regs.R3 = regs.R31;
		/* 821757C0h case   24:*/		return 0x821757C4;
		  /* 821757C4h */ case   25:  		/* mr R29, R11 */
		/* 821757C4h case   25:*/		regs.R29 = regs.R11;
		/* 821757C4h case   25:*/		return 0x821757C8;
		  /* 821757C8h */ case   26:  		/* bl -18656 */
		/* 821757C8h case   26:*/		regs.LR = 0x821757CC; return 0x82170EE8;
		/* 821757C8h case   26:*/		return 0x821757CC;
		  /* 821757CCh */ case   27:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821757CCh case   27:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821757CCh case   27:*/		return 0x821757D0;
		  /* 821757D0h */ case   28:  		/* bc 12, CR0_EQ, 20 */
		/* 821757D0h case   28:*/		if ( regs.CR[0].eq ) { return 0x821757E4;  }
		/* 821757D0h case   28:*/		return 0x821757D4;
		  /* 821757D4h */ case   29:  		/* mr R5, R31 */
		/* 821757D4h case   29:*/		regs.R5 = regs.R31;
		/* 821757D4h case   29:*/		return 0x821757D8;
		  /* 821757D8h */ case   30:  		/* lwz R4, <#[R23 + 4]> */
		/* 821757D8h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000004) );
		/* 821757D8h case   30:*/		return 0x821757DC;
		  /* 821757DCh */ case   31:  		/* mr R3, R18 */
		/* 821757DCh case   31:*/		regs.R3 = regs.R18;
		/* 821757DCh case   31:*/		return 0x821757E0;
		  /* 821757E0h */ case   32:  		/* bl -5552 */
		/* 821757E0h case   32:*/		regs.LR = 0x821757E4; return 0x82174230;
		/* 821757E0h case   32:*/		return 0x821757E4;
	}
	return 0x821757E4;
} // Block from 82175760h-821757E4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821757E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821757E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821757E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821757E4);
		  /* 821757E4h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821757E4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821757E4h case    0:*/		return 0x821757E8;
		  /* 821757E8h */ case    1:  		/* addi R11, R11, 36 */
		/* 821757E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821757E8h case    1:*/		return 0x821757EC;
		  /* 821757ECh */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 821757ECh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821757ECh case    2:*/		return 0x821757F0;
		  /* 821757F0h */ case    3:  		/* lwz R9, <#[R11]> */
		/* 821757F0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821757F0h case    3:*/		return 0x821757F4;
		  /* 821757F4h */ case    4:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821757F4h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821757F4h case    4:*/		return 0x821757F8;
		  /* 821757F8h */ case    5:  		/* stw R9, <#[R10 + 36]> */
		/* 821757F8h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 821757F8h case    5:*/		return 0x821757FC;
		  /* 821757FCh */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 821757FCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821757FCh case    6:*/		return 0x82175800;
		  /* 82175800h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 82175800h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82175800h case    7:*/		return 0x82175804;
		  /* 82175804h */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175804h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175804h case    8:*/		return 0x82175808;
		  /* 82175808h */ case    9:  		/* stw R10, <#[R11]> */
		/* 82175808h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82175808h case    9:*/		return 0x8217580C;
	}
	return 0x8217580C;
} // Block from 821757E4h-8217580Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8217580Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217580C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217580C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217580C);
		  /* 8217580Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8217580Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8217580Ch case    0:*/		return 0x82175810;
		  /* 82175810h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 82175810h case    1:*/		if ( regs.CR[6].eq ) { return 0x82175864;  }
		/* 82175810h case    1:*/		return 0x82175814;
		  /* 82175814h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82175814h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82175814h case    2:*/		return 0x82175818;
		  /* 82175818h */ case    3:  		/* lwz R10, <#[R11 + 36]> */
		/* 82175818h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82175818h case    3:*/		return 0x8217581C;
		  /* 8217581Ch */ case    4:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 8217581Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8217581Ch case    4:*/		return 0x82175820;
		  /* 82175820h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82175820h case    5:*/		if ( regs.CR[0].eq ) { return 0x8217582C;  }
		/* 82175820h case    5:*/		return 0x82175824;
		  /* 82175824h */ case    6:  		/* mr R11, R14 */
		/* 82175824h case    6:*/		regs.R11 = regs.R14;
		/* 82175824h case    6:*/		return 0x82175828;
		  /* 82175828h */ case    7:  		/* b 12 */
		/* 82175828h case    7:*/		return 0x82175834;
		/* 82175828h case    7:*/		return 0x8217582C;
	}
	return 0x8217582C;
} // Block from 8217580Ch-8217582Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8217582Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217582C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217582C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217582C);
		  /* 8217582Ch */ case    0:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 8217582Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 8217582Ch case    0:*/		return 0x82175830;
		  /* 82175830h */ case    1:  		/* addi R11, R11, -40 */
		/* 82175830h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82175830h case    1:*/		return 0x82175834;
	}
	return 0x82175834;
} // Block from 8217582Ch-82175834h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175834);
		  /* 82175834h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 82175834h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82175834h case    0:*/		return 0x82175838;
		  /* 82175838h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82175838h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82175854;  }
		/* 82175838h case    1:*/		return 0x8217583C;
		  /* 8217583Ch */ case    2:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8217583Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8217583Ch case    2:*/		return 0x82175840;
		  /* 82175840h */ case    3:  		/* mr R30, R31 */
		/* 82175840h case    3:*/		regs.R30 = regs.R31;
		/* 82175840h case    3:*/		return 0x82175844;
		  /* 82175844h */ case    4:  		/* lwz R11, <#[R11 + 36]> */
		/* 82175844h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82175844h case    4:*/		return 0x82175848;
		  /* 82175848h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175848h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175848h case    5:*/		return 0x8217584C;
		  /* 8217584Ch */ case    6:  		/* bc 4, CR0_EQ, 92 */
		/* 8217584Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x821758A8;  }
		/* 8217584Ch case    6:*/		return 0x82175850;
		  /* 82175850h */ case    7:  		/* b 72 */
		/* 82175850h case    7:*/		return 0x82175898;
		/* 82175850h case    7:*/		return 0x82175854;
	}
	return 0x82175854;
} // Block from 82175834h-82175854h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82175854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175854);
		  /* 82175854h */ case    0:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 82175854h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 82175854h case    0:*/		return 0x82175858;
		  /* 82175858h */ case    1:  		/* bc 4, CR0_EQ, 80 */
		/* 82175858h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821758A8;  }
		/* 82175858h case    1:*/		return 0x8217585C;
		  /* 8217585Ch */ case    2:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 8217585Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 8217585Ch case    2:*/		return 0x82175860;
		  /* 82175860h */ case    3:  		/* b 60 */
		/* 82175860h case    3:*/		return 0x8217589C;
		/* 82175860h case    3:*/		return 0x82175864;
	}
	return 0x82175864;
} // Block from 82175854h-82175864h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82175864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175864);
		  /* 82175864h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 82175864h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82175864h case    0:*/		return 0x82175868;
		  /* 82175868h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175868h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175868h case    1:*/		return 0x8217586C;
		  /* 8217586Ch */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8217586Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82175878;  }
		/* 8217586Ch case    2:*/		return 0x82175870;
		  /* 82175870h */ case    3:  		/* mr R11, R14 */
		/* 82175870h case    3:*/		regs.R11 = regs.R14;
		/* 82175870h case    3:*/		return 0x82175874;
		  /* 82175874h */ case    4:  		/* b 16 */
		/* 82175874h case    4:*/		return 0x82175884;
		/* 82175874h case    4:*/		return 0x82175878;
	}
	return 0x82175878;
} // Block from 82175864h-82175878h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82175878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175878);
		  /* 82175878h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 82175878h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82175878h case    0:*/		return 0x8217587C;
		  /* 8217587Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8217587Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8217587Ch case    1:*/		return 0x82175880;
		  /* 82175880h */ case    2:  		/* addi R11, R11, -40 */
		/* 82175880h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82175880h case    2:*/		return 0x82175884;
	}
	return 0x82175884;
} // Block from 82175878h-82175884h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175884);
		  /* 82175884h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 82175884h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82175884h case    0:*/		return 0x82175888;
		  /* 82175888h */ case    1:  		/* bc 12, CR6_EQ, -76 */
		/* 82175888h case    1:*/		if ( regs.CR[6].eq ) { return 0x8217583C;  }
		/* 82175888h case    1:*/		return 0x8217588C;
		  /* 8217588Ch */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8217588Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8217588Ch case    2:*/		return 0x82175890;
		  /* 82175890h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82175890h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821758A8;  }
		/* 82175890h case    3:*/		return 0x82175894;
		  /* 82175894h */ case    4:  		/* lwz R11, <#[R19]> */
		/* 82175894h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82175894h case    4:*/		return 0x82175898;
	}
	return 0x82175898;
} // Block from 82175884h-82175898h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82175898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175898);
		  /* 82175898h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175898h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175898h case    0:*/		return 0x8217589C;
	}
	return 0x8217589C;
} // Block from 82175898h-8217589Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8217589Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217589C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217589C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217589C);
		  /* 8217589Ch */ case    0:  		/* addi R31, R11, -40 */
		/* 8217589Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 8217589Ch case    0:*/		return 0x821758A0;
		  /* 821758A0h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821758A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821758A0h case    1:*/		return 0x821758A4;
		  /* 821758A4h */ case    2:  		/* bc 4, CR6_EQ, -264 */
		/* 821758A4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8217579C;  }
		/* 821758A4h case    2:*/		return 0x821758A8;
	}
	return 0x821758A8;
} // Block from 8217589Ch-821758A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821758A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821758A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821758A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821758A8);
		  /* 821758A8h */ case    0:  		/* mr R3, R17 */
		/* 821758A8h case    0:*/		regs.R3 = regs.R17;
		/* 821758A8h case    0:*/		return 0x821758AC;
		  /* 821758ACh */ case    1:  		/* bl -15908 */
		/* 821758ACh case    1:*/		regs.LR = 0x821758B0; return 0x82171A88;
		/* 821758ACh case    1:*/		return 0x821758B0;
		  /* 821758B0h */ case    2:  		/* mr R5, R17 */
		/* 821758B0h case    2:*/		regs.R5 = regs.R17;
		/* 821758B0h case    2:*/		return 0x821758B4;
		  /* 821758B4h */ case    3:  		/* mr R4, R20 */
		/* 821758B4h case    3:*/		regs.R4 = regs.R20;
		/* 821758B4h case    3:*/		return 0x821758B8;
		  /* 821758B8h */ case    4:  		/* mr R3, R18 */
		/* 821758B8h case    4:*/		regs.R3 = regs.R18;
		/* 821758B8h case    4:*/		return 0x821758BC;
		  /* 821758BCh */ case    5:  		/* bl -9860 */
		/* 821758BCh case    5:*/		regs.LR = 0x821758C0; return 0x82173238;
		/* 821758BCh case    5:*/		return 0x821758C0;
		  /* 821758C0h */ case    6:  		/* mr R8, R18 */
		/* 821758C0h case    6:*/		regs.R8 = regs.R18;
		/* 821758C0h case    6:*/		return 0x821758C4;
		  /* 821758C4h */ case    7:  		/* mr R7, R15 */
		/* 821758C4h case    7:*/		regs.R7 = regs.R15;
		/* 821758C4h case    7:*/		return 0x821758C8;
		  /* 821758C8h */ case    8:  		/* mr R6, R17 */
		/* 821758C8h case    8:*/		regs.R6 = regs.R17;
		/* 821758C8h case    8:*/		return 0x821758CC;
		  /* 821758CCh */ case    9:  		/* mr R5, R19 */
		/* 821758CCh case    9:*/		regs.R5 = regs.R19;
		/* 821758CCh case    9:*/		return 0x821758D0;
		  /* 821758D0h */ case   10:  		/* mr R4, R20 */
		/* 821758D0h case   10:*/		regs.R4 = regs.R20;
		/* 821758D0h case   10:*/		return 0x821758D4;
		  /* 821758D4h */ case   11:  		/* addi R3, R1, 112 */
		/* 821758D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 821758D4h case   11:*/		return 0x821758D8;
		  /* 821758D8h */ case   12:  		/* bl -7016 */
		/* 821758D8h case   12:*/		regs.LR = 0x821758DC; return 0x82173D70;
		/* 821758D8h case   12:*/		return 0x821758DC;
		  /* 821758DCh */ case   13:  		/* lwz R11, <#[R1 + 172]> */
		/* 821758DCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000AC) );
		/* 821758DCh case   13:*/		return 0x821758E0;
		  /* 821758E0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821758E0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821758E0h case   14:*/		return 0x821758E4;
		  /* 821758E4h */ case   15:  		/* stw R11, <#[R23 + 12]> */
		/* 821758E4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 821758E4h case   15:*/		return 0x821758E8;
		  /* 821758E8h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 821758E8h case   16:*/		if ( regs.CR[6].eq ) { return 0x821758F8;  }
		/* 821758E8h case   16:*/		return 0x821758EC;
		  /* 821758ECh */ case   17:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821758ECh case   17:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821758ECh case   17:*/		return 0x821758F0;
		  /* 821758F0h */ case   18:  		/* lwz R11, <#[R11 + 40]> */
		/* 821758F0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821758F0h case   18:*/		return 0x821758F4;
		  /* 821758F4h */ case   19:  		/* b 12 */
		/* 821758F4h case   19:*/		return 0x82175900;
		/* 821758F4h case   19:*/		return 0x821758F8;
	}
	return 0x821758F8;
} // Block from 821758A8h-821758F8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821758F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821758F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821758F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821758F8);
		  /* 821758F8h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 821758F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 821758F8h case    0:*/		return 0x821758FC;
		  /* 821758FCh */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821758FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821758FCh case    1:*/		return 0x82175900;
	}
	return 0x82175900;
} // Block from 821758F8h-82175900h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175900);
		  /* 82175900h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82175900h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175900h case    0:*/		return 0x82175904;
		  /* 82175904h */ case    1:  		/* addic R10, R10, -1 */
		/* 82175904h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82175904h case    1:*/		return 0x82175908;
		  /* 82175908h */ case    2:  		/* subfe R10, R10, R10 */
		/* 82175908h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82175908h case    2:*/		return 0x8217590C;
		  /* 8217590Ch */ case    3:  		/* and R11, R10, R11 */
		/* 8217590Ch case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8217590Ch case    3:*/		return 0x82175910;
		  /* 82175910h */ case    4:  		/* stw R11, <#[R23 + 16]> */
		/* 82175910h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 82175910h case    4:*/		return 0x82175914;
		  /* 82175914h */ case    5:  		/* lwz R11, <#[R1 + 168]> */
		/* 82175914h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82175914h case    5:*/		return 0x82175918;
		  /* 82175918h */ case    6:  		/* lwz R11, <#[R11 + 16]> */
		/* 82175918h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82175918h case    6:*/		return 0x8217591C;
		  /* 8217591Ch */ case    7:  		/* stw R11, <#[R23 + 20]> */
		/* 8217591Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 8217591Ch case    7:*/		return 0x82175920;
		  /* 82175920h */ case    8:  		/* bl -971560 */
		/* 82175920h case    8:*/		regs.LR = 0x82175924; return 0x820885F8;
		/* 82175920h case    8:*/		return 0x82175924;
		  /* 82175924h */ case    9:  		/* addi R25, R3, 10000 */
		/* 82175924h case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R3,0x2710);
		/* 82175924h case    9:*/		return 0x82175928;
		  /* 82175928h */ case   10:  		/* lwz R11, <#[R22]> */
		/* 82175928h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82175928h case   10:*/		return 0x8217592C;
		  /* 8217592Ch */ case   11:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8217592Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8217592Ch case   11:*/		return 0x82175930;
		  /* 82175930h */ case   12:  		/* bc 4, CR0_EQ, 1140 */
		/* 82175930h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82175DA4;  }
		/* 82175930h case   12:*/		return 0x82175934;
		  /* 82175934h */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 82175934h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82175934h case   13:*/		return 0x82175938;
		  /* 82175938h */ case   14:  		/* bc 12, CR0_EQ, 1132 */
		/* 82175938h case   14:*/		if ( regs.CR[0].eq ) { return 0x82175DA4;  }
		/* 82175938h case   14:*/		return 0x8217593C;
		  /* 8217593Ch */ case   15:  		/* bl -971588 */
		/* 8217593Ch case   15:*/		regs.LR = 0x82175940; return 0x820885F8;
		/* 8217593Ch case   15:*/		return 0x82175940;
		  /* 82175940h */ case   16:  		/* cmplw CR6, R3, R25 */
		/* 82175940h case   16:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R25);
		/* 82175940h case   16:*/		return 0x82175944;
		  /* 82175944h */ case   17:  		/* bc 4, CR6_LT, 1120 */
		/* 82175944h case   17:*/		if ( !regs.CR[6].lt ) { return 0x82175DA4;  }
		/* 82175944h case   17:*/		return 0x82175948;
		  /* 82175948h */ case   18:  		/* lwz R11, <#[R22]> */
		/* 82175948h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82175948h case   18:*/		return 0x8217594C;
		  /* 8217594Ch */ case   19:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8217594Ch case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8217594Ch case   19:*/		return 0x82175950;
		  /* 82175950h */ case   20:  		/* bc 12, CR0_EQ, 12 */
		/* 82175950h case   20:*/		if ( regs.CR[0].eq ) { return 0x8217595C;  }
		/* 82175950h case   20:*/		return 0x82175954;
		  /* 82175954h */ case   21:  		/* mr R11, R14 */
		/* 82175954h case   21:*/		regs.R11 = regs.R14;
		/* 82175954h case   21:*/		return 0x82175958;
		  /* 82175958h */ case   22:  		/* b 16 */
		/* 82175958h case   22:*/		return 0x82175968;
		/* 82175958h case   22:*/		return 0x8217595C;
	}
	return 0x8217595C;
} // Block from 82175900h-8217595Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8217595Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217595C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217595C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217595C);
		  /* 8217595Ch */ case    0:  		/* lwz R11, <#[R24]> */
		/* 8217595Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8217595Ch case    0:*/		return 0x82175960;
		  /* 82175960h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175960h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175960h case    1:*/		return 0x82175964;
		  /* 82175964h */ case    2:  		/* addi R11, R11, -4 */
		/* 82175964h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82175964h case    2:*/		return 0x82175968;
	}
	return 0x82175968;
} // Block from 8217595Ch-82175968h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175968);
		  /* 82175968h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175968h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175968h case    0:*/		return 0x8217596C;
		  /* 8217596Ch */ case    1:  		/* addi R10, R10, 3 */
		/* 8217596Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3);
		/* 8217596Ch case    1:*/		return 0x82175970;
		  /* 82175970h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82175970h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82175970h case    2:*/		return 0x82175974;
		  /* 82175974h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82175974h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82175974h case    3:*/		return 0x82175978;
		  /* 82175978h */ case    4:  		/* lwz R10, <#[R31 + 4]> */
		/* 82175978h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82175978h case    4:*/		return 0x8217597C;
		  /* 8217597Ch */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 8217597Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8217597Ch case    5:*/		return 0x82175980;
		  /* 82175980h */ case    6:  		/* b 12 */
		/* 82175980h case    6:*/		return 0x8217598C;
		/* 82175980h case    6:*/		return 0x82175984;
		  /* 82175984h */ case    7:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82175984h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82175984h case    7:*/		return 0x82175988;
		  /* 82175988h */ case    8:  		/* subf R11, R9, R11 */
		/* 82175988h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82175988h case    8:*/		return 0x8217598C;
	}
	return 0x8217598C;
} // Block from 82175968h-8217598Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8217598Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8217598C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8217598C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8217598C);
		  /* 8217598Ch */ case    0:  		/* lwz R10, <#[R10 + 4]> */
		/* 8217598Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8217598Ch case    0:*/		return 0x82175990;
		  /* 82175990h */ case    1:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 82175990h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82175990h case    1:*/		return 0x82175994;
		  /* 82175994h */ case    2:  		/* addic R9, R9, -1 */
		/* 82175994h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82175994h case    2:*/		return 0x82175998;
		  /* 82175998h */ case    3:  		/* subfe R9, R9, R9 */
		/* 82175998h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 82175998h case    3:*/		return 0x8217599C;
		  /* 8217599Ch */ case    4:  		/* and R10, R9, R10 */
		/* 8217599Ch case    4:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8217599Ch case    4:*/		return 0x821759A0;
		  /* 821759A0h */ case    5:  		/* lwz R9, <#[R10 + 8]> */
		/* 821759A0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821759A0h case    5:*/		return 0x821759A4;
		  /* 821759A4h */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 821759A4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821759A4h case    6:*/		return 0x821759A8;
		  /* 821759A8h */ case    7:  		/* bc 4, CR6_LT, -36 */
		/* 821759A8h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82175984;  }
		/* 821759A8h case    7:*/		return 0x821759AC;
		  /* 821759ACh */ case    8:  		/* addi R11, R11, 4 */
		/* 821759ACh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821759ACh case    8:*/		return 0x821759B0;
		  /* 821759B0h */ case    9:  		/* mr R4, R31 */
		/* 821759B0h case    9:*/		regs.R4 = regs.R31;
		/* 821759B0h case    9:*/		return 0x821759B4;
		  /* 821759B4h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821759B4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821759B4h case   10:*/		return 0x821759B8;
		  /* 821759B8h */ case   11:  		/* addi R3, R1, 112 */
		/* 821759B8h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 821759B8h case   11:*/		return 0x821759BC;
		  /* 821759BCh */ case   12:  		/* lwzx R26, <#[R11 + R10]> */
		/* 821759BCh case   12:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821759BCh case   12:*/		return 0x821759C0;
		  /* 821759C0h */ case   13:  		/* bl -6512 */
		/* 821759C0h case   13:*/		regs.LR = 0x821759C4; return 0x82174050;
		/* 821759C0h case   13:*/		return 0x821759C4;
		  /* 821759C4h */ case   14:  		/* lbz R11, <#[R1 + 184]> */
		/* 821759C4h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B8) );
		/* 821759C4h case   14:*/		return 0x821759C8;
		  /* 821759C8h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 821759C8h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821759C8h case   15:*/		return 0x821759CC;
		  /* 821759CCh */ case   16:  		/* bc 4, CR0_EQ, -164 */
		/* 821759CCh case   16:*/		if ( !regs.CR[0].eq ) { return 0x82175928;  }
		/* 821759CCh case   16:*/		return 0x821759D0;
		  /* 821759D0h */ case   17:  		/* lwz R11, <#[R26 + 16]> */
		/* 821759D0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 821759D0h case   17:*/		return 0x821759D4;
		  /* 821759D4h */ case   18:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 821759D4h case   18:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 821759D4h case   18:*/		return 0x821759D8;
		  /* 821759D8h */ case   19:  		/* bc 4, CR0_EQ, 744 */
		/* 821759D8h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82175CC0;  }
		/* 821759D8h case   19:*/		return 0x821759DC;
		  /* 821759DCh */ case   20:  		/* lwz R11, <#[R31]> */
		/* 821759DCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821759DCh case   20:*/		return 0x821759E0;
		  /* 821759E0h */ case   21:  		/* cmpwi CR6, R11, 0 */
		/* 821759E0h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821759E0h case   21:*/		return 0x821759E4;
		  /* 821759E4h */ case   22:  		/* bc 4, CR6_EQ, 732 */
		/* 821759E4h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82175CC0;  }
		/* 821759E4h case   22:*/		return 0x821759E8;
		  /* 821759E8h */ case   23:  		/* li R11, 2 */
		/* 821759E8h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 821759E8h case   23:*/		return 0x821759EC;
		  /* 821759ECh */ case   24:  		/* li R5, 2 */
		/* 821759ECh case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 821759ECh case   24:*/		return 0x821759F0;
		  /* 821759F0h */ case   25:  		/* stw R11, <#[R31]> */
		/* 821759F0h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821759F0h case   25:*/		return 0x821759F4;
		  /* 821759F4h */ case   26:  		/* mr R4, R26 */
		/* 821759F4h case   26:*/		regs.R4 = regs.R26;
		/* 821759F4h case   26:*/		return 0x821759F8;
		  /* 821759F8h */ case   27:  		/* addi R3, R1, 112 */
		/* 821759F8h case   27:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 821759F8h case   27:*/		return 0x821759FC;
		  /* 821759FCh */ case   28:  		/* bl -7068 */
		/* 821759FCh case   28:*/		regs.LR = 0x82175A00; return 0x82173E60;
		/* 821759FCh case   28:*/		return 0x82175A00;
		  /* 82175A00h */ case   29:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82175A00h case   29:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82175A00h case   29:*/		return 0x82175A04;
		  /* 82175A04h */ case   30:  		/* bc 12, CR0_EQ, -220 */
		/* 82175A04h case   30:*/		if ( regs.CR[0].eq ) { return 0x82175928;  }
		/* 82175A04h case   30:*/		return 0x82175A08;
		  /* 82175A08h */ case   31:  		/* mr R3, R18 */
		/* 82175A08h case   31:*/		regs.R3 = regs.R18;
		/* 82175A08h case   31:*/		return 0x82175A0C;
		  /* 82175A0Ch */ case   32:  		/* bl -13220 */
		/* 82175A0Ch case   32:*/		regs.LR = 0x82175A10; return 0x82172668;
		/* 82175A0Ch case   32:*/		return 0x82175A10;
		  /* 82175A10h */ case   33:  		/* lwz R11, <#[R1 + 172]> */
		/* 82175A10h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000AC) );
		/* 82175A10h case   33:*/		return 0x82175A14;
		  /* 82175A14h */ case   34:  		/* mr R27, R3 */
		/* 82175A14h case   34:*/		regs.R27 = regs.R3;
		/* 82175A14h case   34:*/		return 0x82175A18;
		  /* 82175A18h */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 82175A18h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175A18h case   35:*/		return 0x82175A1C;
		  /* 82175A1Ch */ case   36:  		/* stw R11, <#[R3 + 12]> */
		/* 82175A1Ch case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82175A1Ch case   36:*/		return 0x82175A20;
		  /* 82175A20h */ case   37:  		/* bc 12, CR6_EQ, 16 */
		/* 82175A20h case   37:*/		if ( regs.CR[6].eq ) { return 0x82175A30;  }
		/* 82175A20h case   37:*/		return 0x82175A24;
		  /* 82175A24h */ case   38:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175A24h case   38:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175A24h case   38:*/		return 0x82175A28;
		  /* 82175A28h */ case   39:  		/* lwz R11, <#[R11 + 40]> */
		/* 82175A28h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82175A28h case   39:*/		return 0x82175A2C;
		  /* 82175A2Ch */ case   40:  		/* b 12 */
		/* 82175A2Ch case   40:*/		return 0x82175A38;
		/* 82175A2Ch case   40:*/		return 0x82175A30;
	}
	return 0x82175A30;
} // Block from 8217598Ch-82175A30h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82175A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175A30);
		  /* 82175A30h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 82175A30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82175A30h case    0:*/		return 0x82175A34;
		  /* 82175A34h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175A34h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175A34h case    1:*/		return 0x82175A38;
	}
	return 0x82175A38;
} // Block from 82175A30h-82175A38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175A38);
		  /* 82175A38h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82175A38h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175A38h case    0:*/		return 0x82175A3C;
		  /* 82175A3Ch */ case    1:  		/* mr R28, R14 */
		/* 82175A3Ch case    1:*/		regs.R28 = regs.R14;
		/* 82175A3Ch case    1:*/		return 0x82175A40;
		  /* 82175A40h */ case    2:  		/* addic R10, R10, -1 */
		/* 82175A40h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82175A40h case    2:*/		return 0x82175A44;
		  /* 82175A44h */ case    3:  		/* subfe R10, R10, R10 */
		/* 82175A44h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82175A44h case    3:*/		return 0x82175A48;
		  /* 82175A48h */ case    4:  		/* and R11, R10, R11 */
		/* 82175A48h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82175A48h case    4:*/		return 0x82175A4C;
		  /* 82175A4Ch */ case    5:  		/* stw R11, <#[R27 + 16]> */
		/* 82175A4Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82175A4Ch case    5:*/		return 0x82175A50;
		  /* 82175A50h */ case    6:  		/* lwz R11, <#[R1 + 168]> */
		/* 82175A50h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82175A50h case    6:*/		return 0x82175A54;
		  /* 82175A54h */ case    7:  		/* lwz R11, <#[R11 + 16]> */
		/* 82175A54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82175A54h case    7:*/		return 0x82175A58;
		  /* 82175A58h */ case    8:  		/* stw R11, <#[R27 + 20]> */
		/* 82175A58h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 82175A58h case    8:*/		return 0x82175A5C;
		  /* 82175A5Ch */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 82175A5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82175A5Ch case    9:*/		return 0x82175A60;
		  /* 82175A60h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175A60h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175A60h case   10:*/		return 0x82175A64;
		  /* 82175A64h */ case   11:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175A64h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175A64h case   11:*/		return 0x82175A68;
		  /* 82175A68h */ case   12:  		/* bc 4, CR0_EQ, 44 */
		/* 82175A68h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82175A94;  }
		/* 82175A68h case   12:*/		return 0x82175A6C;
		  /* 82175A6Ch */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 82175A6Ch case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82175A6Ch case   13:*/		return 0x82175A70;
		  /* 82175A70h */ case   14:  		/* bc 12, CR0_EQ, 36 */
		/* 82175A70h case   14:*/		if ( regs.CR[0].eq ) { return 0x82175A94;  }
		/* 82175A70h case   14:*/		return 0x82175A74;
		  /* 82175A74h */ case   15:  		/* rlwinm R10, R11, 0, 0, 30 */
		/* 82175A74h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R11);
		/* 82175A74h case   15:*/		return 0x82175A78;
		  /* 82175A78h */ case   16:  		/* lwz R11, <#[R11 + 8]> */
		/* 82175A78h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82175A78h case   16:*/		return 0x82175A7C;
		  /* 82175A7Ch */ case   17:  		/* add R28, R11, R28 */
		/* 82175A7Ch case   17:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 82175A7Ch case   17:*/		return 0x82175A80;
		  /* 82175A80h */ case   18:  		/* lwz R11, <#[R10 + 4]> */
		/* 82175A80h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82175A80h case   18:*/		return 0x82175A84;
		  /* 82175A84h */ case   19:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175A84h case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175A84h case   19:*/		return 0x82175A88;
		  /* 82175A88h */ case   20:  		/* bc 4, CR0_EQ, 12 */
		/* 82175A88h case   20:*/		if ( !regs.CR[0].eq ) { return 0x82175A94;  }
		/* 82175A88h case   20:*/		return 0x82175A8C;
		  /* 82175A8Ch */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 82175A8Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175A8Ch case   21:*/		return 0x82175A90;
		  /* 82175A90h */ case   22:  		/* bc 4, CR6_EQ, -28 */
		/* 82175A90h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82175A74;  }
		/* 82175A90h case   22:*/		return 0x82175A94;
	}
	return 0x82175A94;
} // Block from 82175A38h-82175A94h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82175A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175A94);
		  /* 82175A94h */ case    0:  		/* mr R30, R14 */
		/* 82175A94h case    0:*/		regs.R30 = regs.R14;
		/* 82175A94h case    0:*/		return 0x82175A98;
		  /* 82175A98h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 82175A98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82175A98h case    1:*/		return 0x82175A9C;
		  /* 82175A9Ch */ case    2:  		/* bc 12, CR6_EQ, 220 */
		/* 82175A9Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82175B78;  }
		/* 82175A9Ch case    2:*/		return 0x82175AA0;
		  /* 82175AA0h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 82175AA0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82175AA0h case    3:*/		return 0x82175AA4;
		  /* 82175AA4h */ case    4:  		/* cmplw CR6, R30, R11 */
		/* 82175AA4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82175AA4h case    4:*/		return 0x82175AA8;
		  /* 82175AA8h */ case    5:  		/* bc 12, CR6_EQ, 196 */
		/* 82175AA8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82175B6C;  }
		/* 82175AA8h case    5:*/		return 0x82175AAC;
		  /* 82175AACh */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 82175AACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82175AACh case    6:*/		return 0x82175AB0;
		  /* 82175AB0h */ case    7:  		/* mr R9, R30 */
		/* 82175AB0h case    7:*/		regs.R9 = regs.R30;
		/* 82175AB0h case    7:*/		return 0x82175AB4;
		  /* 82175AB4h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175AB4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175AB4h case    8:*/		return 0x82175AB8;
		  /* 82175AB8h */ case    9:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82175AB8h case    9:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175AB8h case    9:*/		return 0x82175ABC;
		  /* 82175ABCh */ case   10:  		/* addic R10, R10, -1 */
		/* 82175ABCh case   10:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82175ABCh case   10:*/		return 0x82175AC0;
		  /* 82175AC0h */ case   11:  		/* subfe R10, R10, R10 */
		/* 82175AC0h case   11:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82175AC0h case   11:*/		return 0x82175AC4;
		  /* 82175AC4h */ case   12:  		/* and R11, R10, R11 */
		/* 82175AC4h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82175AC4h case   12:*/		return 0x82175AC8;
		  /* 82175AC8h */ case   13:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175AC8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175AC8h case   13:*/		return 0x82175ACC;
		  /* 82175ACCh */ case   14:  		/* cmplw CR6, R30, R10 */
		/* 82175ACCh case   14:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 82175ACCh case   14:*/		return 0x82175AD0;
		  /* 82175AD0h */ case   15:  		/* bc 12, CR6_LT, 44 */
		/* 82175AD0h case   15:*/		if ( regs.CR[6].lt ) { return 0x82175AFC;  }
		/* 82175AD0h case   15:*/		return 0x82175AD4;
		  /* 82175AD4h */ case   16:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175AD4h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175AD4h case   16:*/		return 0x82175AD8;
		  /* 82175AD8h */ case   17:  		/* subf R9, R10, R9 */
		/* 82175AD8h case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82175AD8h case   17:*/		return 0x82175ADC;
		  /* 82175ADCh */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175ADCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175ADCh case   18:*/		return 0x82175AE0;
		  /* 82175AE0h */ case   19:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82175AE0h case   19:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175AE0h case   19:*/		return 0x82175AE4;
		  /* 82175AE4h */ case   20:  		/* addic R10, R10, -1 */
		/* 82175AE4h case   20:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82175AE4h case   20:*/		return 0x82175AE8;
		  /* 82175AE8h */ case   21:  		/* subfe R10, R10, R10 */
		/* 82175AE8h case   21:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82175AE8h case   21:*/		return 0x82175AEC;
		  /* 82175AECh */ case   22:  		/* and R11, R10, R11 */
		/* 82175AECh case   22:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82175AECh case   22:*/		return 0x82175AF0;
		  /* 82175AF0h */ case   23:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175AF0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175AF0h case   23:*/		return 0x82175AF4;
		  /* 82175AF4h */ case   24:  		/* cmplw CR6, R9, R10 */
		/* 82175AF4h case   24:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82175AF4h case   24:*/		return 0x82175AF8;
		  /* 82175AF8h */ case   25:  		/* bc 4, CR6_LT, -36 */
		/* 82175AF8h case   25:*/		if ( !regs.CR[6].lt ) { return 0x82175AD4;  }
		/* 82175AF8h case   25:*/		return 0x82175AFC;
	}
	return 0x82175AFC;
} // Block from 82175A94h-82175AFCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 82175AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175AFC);
		  /* 82175AFCh */ case    0:  		/* addi R10, R9, 4 */
		/* 82175AFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 82175AFCh case    0:*/		return 0x82175B00;
		  /* 82175B00h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82175B00h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82175B00h case    1:*/		return 0x82175B04;
		  /* 82175B04h */ case    2:  		/* lwzx R29, <#[R10 + R11]> */
		/* 82175B04h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82175B04h case    2:*/		return 0x82175B08;
		  /* 82175B08h */ case    3:  		/* lwz R11, <#[R29 + 16]> */
		/* 82175B08h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82175B08h case    3:*/		return 0x82175B0C;
		  /* 82175B0Ch */ case    4:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 82175B0Ch case    4:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 82175B0Ch case    4:*/		return 0x82175B10;
		  /* 82175B10h */ case    5:  		/* bc 4, CR0_EQ, 92 */
		/* 82175B10h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82175B6C;  }
		/* 82175B10h case    5:*/		return 0x82175B14;
		  /* 82175B14h */ case    6:  		/* lwz R3, <#[R27 + 4]> */
		/* 82175B14h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000004) );
		/* 82175B14h case    6:*/		return 0x82175B18;
		  /* 82175B18h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 82175B18h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82175B18h case    7:*/		return 0x82175B1C;
		  /* 82175B1Ch */ case    8:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82175B1Ch case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82175B1Ch case    8:*/		return 0x82175B20;
		  /* 82175B20h */ case    9:  		/* bc 4, CR0_EQ, 40 */
		/* 82175B20h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82175B48;  }
		/* 82175B20h case    9:*/		return 0x82175B24;
		  /* 82175B24h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 82175B24h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82175B24h case   10:*/		return 0x82175B28;
		  /* 82175B28h */ case   11:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175B28h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175B28h case   11:*/		return 0x82175B2C;
		  /* 82175B2Ch */ case   12:  		/* addic. R11, R11, -4 */
		/* 82175B2Ch case   12:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82175B2Ch case   12:*/		return 0x82175B30;
		  /* 82175B30h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82175B30h case   13:*/		if ( regs.CR[0].eq ) { return 0x82175B48;  }
		/* 82175B30h case   13:*/		return 0x82175B34;
		  /* 82175B34h */ case   14:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175B34h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175B34h case   14:*/		return 0x82175B38;
		  /* 82175B38h */ case   15:  		/* lwz R9, <#[R11 + 12]> */
		/* 82175B38h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82175B38h case   15:*/		return 0x82175B3C;
		  /* 82175B3Ch */ case   16:  		/* addi R10, R10, 1 */
		/* 82175B3Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82175B3Ch case   16:*/		return 0x82175B40;
		  /* 82175B40h */ case   17:  		/* cmplw CR6, R10, R9 */
		/* 82175B40h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82175B40h case   17:*/		return 0x82175B44;
		  /* 82175B44h */ case   18:  		/* bc 4, CR6_GT, 16 */
		/* 82175B44h case   18:*/		if ( !regs.CR[6].gt ) { return 0x82175B54;  }
		/* 82175B44h case   18:*/		return 0x82175B48;
	}
	return 0x82175B48;
} // Block from 82175AFCh-82175B48h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82175B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175B48);
		  /* 82175B48h */ case    0:  		/* li R4, 1 */
		/* 82175B48h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82175B48h case    0:*/		return 0x82175B4C;
		  /* 82175B4Ch */ case    1:  		/* bl 95612 */
		/* 82175B4Ch case    1:*/		regs.LR = 0x82175B50; return 0x8218D0C8;
		/* 82175B4Ch case    1:*/		return 0x82175B50;
		  /* 82175B50h */ case    2:  		/* mr R11, R3 */
		/* 82175B50h case    2:*/		regs.R11 = regs.R3;
		/* 82175B50h case    2:*/		return 0x82175B54;
	}
	return 0x82175B54;
} // Block from 82175B48h-82175B54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175B54);
		  /* 82175B54h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175B54h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175B54h case    0:*/		return 0x82175B58;
		  /* 82175B58h */ case    1:  		/* addi R9, R10, 4 */
		/* 82175B58h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 82175B58h case    1:*/		return 0x82175B5C;
		  /* 82175B5Ch */ case    2:  		/* addi R8, R10, 1 */
		/* 82175B5Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82175B5Ch case    2:*/		return 0x82175B60;
		  /* 82175B60h */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82175B60h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82175B60h case    3:*/		return 0x82175B64;
		  /* 82175B64h */ case    4:  		/* stw R8, <#[R11 + 8]> */
		/* 82175B64h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82175B64h case    4:*/		return 0x82175B68;
		  /* 82175B68h */ case    5:  		/* stwx R29, <#[R10 + R11]> */
		/* 82175B68h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82175B68h case    5:*/		return 0x82175B6C;
	}
	return 0x82175B6C;
} // Block from 82175B54h-82175B6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82175B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175B6C);
		  /* 82175B6Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 82175B6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82175B6Ch case    0:*/		return 0x82175B70;
		  /* 82175B70h */ case    1:  		/* cmplw CR6, R30, R28 */
		/* 82175B70h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 82175B70h case    1:*/		return 0x82175B74;
		  /* 82175B74h */ case    2:  		/* bc 12, CR6_LT, -212 */
		/* 82175B74h case    2:*/		if ( regs.CR[6].lt ) { return 0x82175AA0;  }
		/* 82175B74h case    2:*/		return 0x82175B78;
	}
	return 0x82175B78;
} // Block from 82175B6Ch-82175B78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175B78);
		  /* 82175B78h */ case    0:  		/* mr R29, R26 */
		/* 82175B78h case    0:*/		regs.R29 = regs.R26;
		/* 82175B78h case    0:*/		return 0x82175B7C;
		  /* 82175B7Ch */ case    1:  		/* lwz R30, <#[R29]> */
		/* 82175B7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 82175B7Ch case    1:*/		return 0x82175B80;
		  /* 82175B80h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 82175B80h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82175B80h case    2:*/		return 0x82175B84;
		  /* 82175B84h */ case    3:  		/* bc 12, CR6_EQ, 104 */
		/* 82175B84h case    3:*/		if ( regs.CR[6].eq ) { return 0x82175BEC;  }
		/* 82175B84h case    3:*/		return 0x82175B88;
		  /* 82175B88h */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 82175B88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82175B88h case    4:*/		return 0x82175B8C;
		  /* 82175B8Ch */ case    5:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175B8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175B8Ch case    5:*/		return 0x82175B90;
		  /* 82175B90h */ case    6:  		/* rlwinm. R10, R10, 6, 31, 31 */
		/* 82175B90h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R10);
		/* 82175B90h case    6:*/		return 0x82175B94;
		  /* 82175B94h */ case    7:  		/* bc 12, CR0_EQ, 80 */
		/* 82175B94h case    7:*/		if ( regs.CR[0].eq ) { return 0x82175BE4;  }
		/* 82175B94h case    7:*/		return 0x82175B98;
		  /* 82175B98h */ case    8:  		/* lwz R10, <#[R11 + 16]> */
		/* 82175B98h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82175B98h case    8:*/		return 0x82175B9C;
		  /* 82175B9Ch */ case    9:  		/* rlwinm. R9, R10, 7, 31, 31 */
		/* 82175B9Ch case    9:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R9,regs.R10);
		/* 82175B9Ch case    9:*/		return 0x82175BA0;
		  /* 82175BA0h */ case   10:  		/* bc 4, CR0_EQ, 68 */
		/* 82175BA0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82175BE4;  }
		/* 82175BA0h case   10:*/		return 0x82175BA4;
		  /* 82175BA4h */ case   11:  		/* lwz R9, <#[R11 + 20]> */
		/* 82175BA4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82175BA4h case   11:*/		return 0x82175BA8;
		  /* 82175BA8h */ case   12:  		/* rlwinm R10, R10, 12, 21, 24 */
		/* 82175BA8h case   12:*/		cpu::op::rlwinm<0,12,21,24>(regs,&regs.R10,regs.R10);
		/* 82175BA8h case   12:*/		return 0x82175BAC;
		  /* 82175BACh */ case   13:  		/* lwz R11, <#[R18 + 720]> */
		/* 82175BACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x000002D0) );
		/* 82175BACh case   13:*/		return 0x82175BB0;
		  /* 82175BB0h */ case   14:  		/* rlwinm R9, R9, 7, 25, 31 */
		/* 82175BB0h case   14:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R9,regs.R9);
		/* 82175BB0h case   14:*/		return 0x82175BB4;
		  /* 82175BB4h */ case   15:  		/* or R10, R10, R9 */
		/* 82175BB4h case   15:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82175BB4h case   15:*/		return 0x82175BB8;
		  /* 82175BB8h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82175BB8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82175BB8h case   16:*/		return 0x82175BBC;
		  /* 82175BBCh */ case   17:  		/* add R11, R10, R11 */
		/* 82175BBCh case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82175BBCh case   17:*/		return 0x82175BC0;
		  /* 82175BC0h */ case   18:  		/* lwz R31, <#[R11 - 4]> */
		/* 82175BC0h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82175BC0h case   18:*/		return 0x82175BC4;
		  /* 82175BC4h */ case   19:  		/* mr R3, R31 */
		/* 82175BC4h case   19:*/		regs.R3 = regs.R31;
		/* 82175BC4h case   19:*/		return 0x82175BC8;
		  /* 82175BC8h */ case   20:  		/* bl -19680 */
		/* 82175BC8h case   20:*/		regs.LR = 0x82175BCC; return 0x82170EE8;
		/* 82175BC8h case   20:*/		return 0x82175BCC;
		  /* 82175BCCh */ case   21:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82175BCCh case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82175BCCh case   21:*/		return 0x82175BD0;
		  /* 82175BD0h */ case   22:  		/* bc 12, CR0_EQ, 20 */
		/* 82175BD0h case   22:*/		if ( regs.CR[0].eq ) { return 0x82175BE4;  }
		/* 82175BD0h case   22:*/		return 0x82175BD4;
		  /* 82175BD4h */ case   23:  		/* mr R5, R31 */
		/* 82175BD4h case   23:*/		regs.R5 = regs.R31;
		/* 82175BD4h case   23:*/		return 0x82175BD8;
		  /* 82175BD8h */ case   24:  		/* lwz R4, <#[R27 + 4]> */
		/* 82175BD8h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000004) );
		/* 82175BD8h case   24:*/		return 0x82175BDC;
		  /* 82175BDCh */ case   25:  		/* mr R3, R18 */
		/* 82175BDCh case   25:*/		regs.R3 = regs.R18;
		/* 82175BDCh case   25:*/		return 0x82175BE0;
		  /* 82175BE0h */ case   26:  		/* bl -6576 */
		/* 82175BE0h case   26:*/		regs.LR = 0x82175BE4; return 0x82174230;
		/* 82175BE0h case   26:*/		return 0x82175BE4;
	}
	return 0x82175BE4;
} // Block from 82175B78h-82175BE4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82175BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175BE4);
		  /* 82175BE4h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82175BE4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82175BE4h case    0:*/		return 0x82175BE8;
		  /* 82175BE8h */ case    1:  		/* b -104 */
		/* 82175BE8h case    1:*/		return 0x82175B80;
		/* 82175BE8h case    1:*/		return 0x82175BEC;
	}
	return 0x82175BEC;
} // Block from 82175BE4h-82175BECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175BEC);
		  /* 82175BECh */ case    0:  		/* lwz R29, <#[R29 + 32]> */
		/* 82175BECh case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000020) );
		/* 82175BECh case    0:*/		return 0x82175BF0;
		  /* 82175BF0h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 82175BF0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82175BF0h case    1:*/		return 0x82175BF4;
		  /* 82175BF4h */ case    2:  		/* bc 4, CR6_EQ, -120 */
		/* 82175BF4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82175B7C;  }
		/* 82175BF4h case    2:*/		return 0x82175BF8;
		  /* 82175BF8h */ case    3:  		/* lwz R11, <#[R27 + 4]> */
		/* 82175BF8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82175BF8h case    3:*/		return 0x82175BFC;
		  /* 82175BFCh */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175BFCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175BFCh case    4:*/		return 0x82175C00;
		  /* 82175C00h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175C00h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175C00h case    5:*/		return 0x82175C04;
		  /* 82175C04h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82175C04h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82175C10;  }
		/* 82175C04h case    6:*/		return 0x82175C08;
		  /* 82175C08h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82175C08h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82175C08h case    7:*/		return 0x82175C0C;
		  /* 82175C0Ch */ case    8:  		/* bc 4, CR0_EQ, 60 */
		/* 82175C0Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x82175C48;  }
		/* 82175C0Ch case    8:*/		return 0x82175C10;
	}
	return 0x82175C10;
} // Block from 82175BECh-82175C10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82175C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175C10);
		  /* 82175C10h */ case    0:  		/* mr R4, R27 */
		/* 82175C10h case    0:*/		regs.R4 = regs.R27;
		/* 82175C10h case    0:*/		return 0x82175C14;
		  /* 82175C14h */ case    1:  		/* mr R3, R18 */
		/* 82175C14h case    1:*/		regs.R3 = regs.R18;
		/* 82175C14h case    1:*/		return 0x82175C18;
		  /* 82175C18h */ case    2:  		/* bl -13632 */
		/* 82175C18h case    2:*/		regs.LR = 0x82175C1C; return 0x821726D8;
		/* 82175C18h case    2:*/		return 0x82175C1C;
		  /* 82175C1Ch */ case    3:  		/* addi R3, R1, 112 */
		/* 82175C1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82175C1Ch case    3:*/		return 0x82175C20;
		  /* 82175C20h */ case    4:  		/* bl -6840 */
		/* 82175C20h case    4:*/		regs.LR = 0x82175C24; return 0x82174168;
		/* 82175C20h case    4:*/		return 0x82175C24;
		  /* 82175C24h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82175C24h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82175C24h case    5:*/		return 0x82175C28;
		  /* 82175C28h */ case    6:  		/* bc 12, CR0_EQ, -768 */
		/* 82175C28h case    6:*/		if ( regs.CR[0].eq ) { return 0x82175928;  }
		/* 82175C28h case    6:*/		return 0x82175C2C;
		  /* 82175C2Ch */ case    7:  		/* mr R31, R16 */
		/* 82175C2Ch case    7:*/		regs.R31 = regs.R16;
		/* 82175C2Ch case    7:*/		return 0x82175C30;
		  /* 82175C30h */ case    8:  		/* li R5, 1 */
		/* 82175C30h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82175C30h case    8:*/		return 0x82175C34;
		  /* 82175C34h */ case    9:  		/* mr R4, R20 */
		/* 82175C34h case    9:*/		regs.R4 = regs.R20;
		/* 82175C34h case    9:*/		return 0x82175C38;
		  /* 82175C38h */ case   10:  		/* mr R3, R18 */
		/* 82175C38h case   10:*/		regs.R3 = regs.R18;
		/* 82175C38h case   10:*/		return 0x82175C3C;
		  /* 82175C3Ch */ case   11:  		/* bl -16340 */
		/* 82175C3Ch case   11:*/		regs.LR = 0x82175C40; return 0x82171C68;
		/* 82175C3Ch case   11:*/		return 0x82175C40;
		  /* 82175C40h */ case   12:  		/* mr R3, R31 */
		/* 82175C40h case   12:*/		regs.R3 = regs.R31;
		/* 82175C40h case   12:*/		return 0x82175C44;
		  /* 82175C44h */ case   13:  		/* b -5936 */
		/* 82175C44h case   13:*/		return 0x82174514;
		/* 82175C44h case   13:*/		return 0x82175C48;
	}
	return 0x82175C48;
} // Block from 82175C10h-82175C48h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82175C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175C48);
		  /* 82175C48h */ case    0:  		/* mr R4, R27 */
		/* 82175C48h case    0:*/		regs.R4 = regs.R27;
		/* 82175C48h case    0:*/		return 0x82175C4C;
		  /* 82175C4Ch */ case    1:  		/* mr R3, R18 */
		/* 82175C4Ch case    1:*/		regs.R3 = regs.R18;
		/* 82175C4Ch case    1:*/		return 0x82175C50;
		  /* 82175C50h */ case    2:  		/* bl -13136 */
		/* 82175C50h case    2:*/		regs.LR = 0x82175C54; return 0x82172900;
		/* 82175C50h case    2:*/		return 0x82175C54;
		  /* 82175C54h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82175C54h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82175C54h case    3:*/		return 0x82175C58;
		  /* 82175C58h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82175C58h case    4:*/		if ( regs.CR[0].eq ) { return 0x82175C68;  }
		/* 82175C58h case    4:*/		return 0x82175C5C;
		  /* 82175C5Ch */ case    5:  		/* mr R3, R18 */
		/* 82175C5Ch case    5:*/		regs.R3 = regs.R18;
		/* 82175C5Ch case    5:*/		return 0x82175C60;
		  /* 82175C60h */ case    6:  		/* bl -13704 */
		/* 82175C60h case    6:*/		regs.LR = 0x82175C64; return 0x821726D8;
		/* 82175C60h case    6:*/		return 0x82175C64;
		  /* 82175C64h */ case    7:  		/* b -828 */
		/* 82175C64h case    7:*/		return 0x82175928;
		/* 82175C64h case    7:*/		return 0x82175C68;
	}
	return 0x82175C68;
} // Block from 82175C48h-82175C68h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82175C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175C68);
		  /* 82175C68h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 82175C68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82175C68h case    0:*/		return 0x82175C6C;
		  /* 82175C6Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82175C6Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82175C6Ch case    1:*/		return 0x82175C70;
		  /* 82175C70h */ case    2:  		/* bc 4, CR0_EQ, 40 */
		/* 82175C70h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82175C98;  }
		/* 82175C70h case    2:*/		return 0x82175C74;
		  /* 82175C74h */ case    3:  		/* lwz R11, <#[R24]> */
		/* 82175C74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82175C74h case    3:*/		return 0x82175C78;
		  /* 82175C78h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175C78h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175C78h case    4:*/		return 0x82175C7C;
		  /* 82175C7Ch */ case    5:  		/* addic. R3, R11, -4 */
		/* 82175C7Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82175C7Ch case    5:*/		return 0x82175C80;
		  /* 82175C80h */ case    6:  		/* bc 12, CR0_EQ, 24 */
		/* 82175C80h case    6:*/		if ( regs.CR[0].eq ) { return 0x82175C98;  }
		/* 82175C80h case    6:*/		return 0x82175C84;
		  /* 82175C84h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 82175C84h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82175C84h case    7:*/		return 0x82175C88;
		  /* 82175C88h */ case    8:  		/* lwz R10, <#[R3 + 12]> */
		/* 82175C88h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82175C88h case    8:*/		return 0x82175C8C;
		  /* 82175C8Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 82175C8Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82175C8Ch case    9:*/		return 0x82175C90;
		  /* 82175C90h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 82175C90h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82175C90h case   10:*/		return 0x82175C94;
		  /* 82175C94h */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 82175C94h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82175CA4;  }
		/* 82175C94h case   11:*/		return 0x82175C98;
	}
	return 0x82175C98;
} // Block from 82175C68h-82175C98h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82175C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175C98);
		  /* 82175C98h */ case    0:  		/* li R4, 1 */
		/* 82175C98h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82175C98h case    0:*/		return 0x82175C9C;
		  /* 82175C9Ch */ case    1:  		/* mr R3, R24 */
		/* 82175C9Ch case    1:*/		regs.R3 = regs.R24;
		/* 82175C9Ch case    1:*/		return 0x82175CA0;
		  /* 82175CA0h */ case    2:  		/* bl 95272 */
		/* 82175CA0h case    2:*/		regs.LR = 0x82175CA4; return 0x8218D0C8;
		/* 82175CA0h case    2:*/		return 0x82175CA4;
	}
	return 0x82175CA4;
} // Block from 82175C98h-82175CA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175CA4);
		  /* 82175CA4h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82175CA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82175CA4h case    0:*/		return 0x82175CA8;
		  /* 82175CA8h */ case    1:  		/* addi R10, R11, 4 */
		/* 82175CA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82175CA8h case    1:*/		return 0x82175CAC;
		  /* 82175CACh */ case    2:  		/* addi R9, R11, 1 */
		/* 82175CACh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82175CACh case    2:*/		return 0x82175CB0;
		  /* 82175CB0h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82175CB0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82175CB0h case    3:*/		return 0x82175CB4;
		  /* 82175CB4h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 82175CB4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82175CB4h case    4:*/		return 0x82175CB8;
		  /* 82175CB8h */ case    5:  		/* stwx R27, <#[R11 + R3]> */
		/* 82175CB8h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82175CB8h case    5:*/		return 0x82175CBC;
		  /* 82175CBCh */ case    6:  		/* b -916 */
		/* 82175CBCh case    6:*/		return 0x82175928;
		/* 82175CBCh case    6:*/		return 0x82175CC0;
	}
	return 0x82175CC0;
} // Block from 82175CA4h-82175CC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82175CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175CC0);
		  /* 82175CC0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82175CC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82175CC0h case    0:*/		return 0x82175CC4;
		  /* 82175CC4h */ case    1:  		/* mr R10, R14 */
		/* 82175CC4h case    1:*/		regs.R10 = regs.R14;
		/* 82175CC4h case    1:*/		return 0x82175CC8;
		  /* 82175CC8h */ case    2:  		/* lwz R8, <#[R31 + 4]> */
		/* 82175CC8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82175CC8h case    2:*/		return 0x82175CCC;
		  /* 82175CCCh */ case    3:  		/* addi R9, R11, 1 */
		/* 82175CCCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82175CCCh case    3:*/		return 0x82175CD0;
		  /* 82175CD0h */ case    4:  		/* stw R9, <#[R31 + 8]> */
		/* 82175CD0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82175CD0h case    4:*/		return 0x82175CD4;
		  /* 82175CD4h */ case    5:  		/* lwz R11, <#[R8 + 4]> */
		/* 82175CD4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82175CD4h case    5:*/		return 0x82175CD8;
		  /* 82175CD8h */ case    6:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 82175CD8h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 82175CD8h case    6:*/		return 0x82175CDC;
		  /* 82175CDCh */ case    7:  		/* bc 4, CR0_EQ, 44 */
		/* 82175CDCh case    7:*/		if ( !regs.CR[0].eq ) { return 0x82175D08;  }
		/* 82175CDCh case    7:*/		return 0x82175CE0;
		  /* 82175CE0h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82175CE0h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82175CE0h case    8:*/		return 0x82175CE4;
		  /* 82175CE4h */ case    9:  		/* bc 12, CR0_EQ, 36 */
		/* 82175CE4h case    9:*/		if ( regs.CR[0].eq ) { return 0x82175D08;  }
		/* 82175CE4h case    9:*/		return 0x82175CE8;
		  /* 82175CE8h */ case   10:  		/* rlwinm R8, R11, 0, 0, 30 */
		/* 82175CE8h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R11);
		/* 82175CE8h case   10:*/		return 0x82175CEC;
		  /* 82175CECh */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 82175CECh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82175CECh case   11:*/		return 0x82175CF0;
		  /* 82175CF0h */ case   12:  		/* add R10, R11, R10 */
		/* 82175CF0h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82175CF0h case   12:*/		return 0x82175CF4;
		  /* 82175CF4h */ case   13:  		/* lwz R11, <#[R8 + 4]> */
		/* 82175CF4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82175CF4h case   13:*/		return 0x82175CF8;
		  /* 82175CF8h */ case   14:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 82175CF8h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 82175CF8h case   14:*/		return 0x82175CFC;
		  /* 82175CFCh */ case   15:  		/* bc 4, CR0_EQ, 12 */
		/* 82175CFCh case   15:*/		if ( !regs.CR[0].eq ) { return 0x82175D08;  }
		/* 82175CFCh case   15:*/		return 0x82175D00;
		  /* 82175D00h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 82175D00h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175D00h case   16:*/		return 0x82175D04;
		  /* 82175D04h */ case   17:  		/* bc 4, CR6_EQ, -28 */
		/* 82175D04h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82175CE8;  }
		/* 82175D04h case   17:*/		return 0x82175D08;
	}
	return 0x82175D08;
} // Block from 82175CC0h-82175D08h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82175D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175D08);
		  /* 82175D08h */ case    0:  		/* cmplw CR6, R9, R10 */
		/* 82175D08h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82175D08h case    0:*/		return 0x82175D0C;
		  /* 82175D0Ch */ case    1:  		/* bc 4, CR6_EQ, 144 */
		/* 82175D0Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82175D9C;  }
		/* 82175D0Ch case    1:*/		return 0x82175D10;
		  /* 82175D10h */ case    2:  		/* mr R5, R20 */
		/* 82175D10h case    2:*/		regs.R5 = regs.R20;
		/* 82175D10h case    2:*/		return 0x82175D14;
		  /* 82175D14h */ case    3:  		/* mr R4, R31 */
		/* 82175D14h case    3:*/		regs.R4 = regs.R31;
		/* 82175D14h case    3:*/		return 0x82175D18;
		  /* 82175D18h */ case    4:  		/* mr R3, R18 */
		/* 82175D18h case    4:*/		regs.R3 = regs.R18;
		/* 82175D18h case    4:*/		return 0x82175D1C;
		  /* 82175D1Ch */ case    5:  		/* bl -13596 */
		/* 82175D1Ch case    5:*/		regs.LR = 0x82175D20; return 0x82172800;
		/* 82175D1Ch case    5:*/		return 0x82175D20;
		  /* 82175D20h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82175D20h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82175D20h case    6:*/		return 0x82175D24;
		  /* 82175D24h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 82175D24h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82175D30;  }
		/* 82175D24h case    7:*/		return 0x82175D28;
		  /* 82175D28h */ case    8:  		/* stb R16, <#[R1 + 184]> */
		/* 82175D28h case    8:*/		cpu::mem::store8( regs, regs.R16, (uint32)(regs.R1 + 0x000000B8) );
		/* 82175D28h case    8:*/		return 0x82175D2C;
		  /* 82175D2Ch */ case    9:  		/* stb R16, <#[R1 + 185]> */
		/* 82175D2Ch case    9:*/		cpu::mem::store8( regs, regs.R16, (uint32)(regs.R1 + 0x000000B9) );
		/* 82175D2Ch case    9:*/		return 0x82175D30;
	}
	return 0x82175D30;
} // Block from 82175D08h-82175D30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82175D30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175D30);
		  /* 82175D30h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 82175D30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82175D30h case    0:*/		return 0x82175D34;
		  /* 82175D34h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82175D34h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82175D34h case    1:*/		return 0x82175D38;
		  /* 82175D38h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82175D38h case    2:*/		if ( regs.CR[0].eq ) { return 0x82175D44;  }
		/* 82175D38h case    2:*/		return 0x82175D3C;
		  /* 82175D3Ch */ case    3:  		/* mr R4, R14 */
		/* 82175D3Ch case    3:*/		regs.R4 = regs.R14;
		/* 82175D3Ch case    3:*/		return 0x82175D40;
		  /* 82175D40h */ case    4:  		/* b 16 */
		/* 82175D40h case    4:*/		return 0x82175D50;
		/* 82175D40h case    4:*/		return 0x82175D44;
	}
	return 0x82175D44;
} // Block from 82175D30h-82175D44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82175D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175D44);
		  /* 82175D44h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 82175D44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82175D44h case    0:*/		return 0x82175D48;
		  /* 82175D48h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175D48h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175D48h case    1:*/		return 0x82175D4C;
		  /* 82175D4Ch */ case    2:  		/* addi R4, R11, -4 */
		/* 82175D4Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 82175D4Ch case    2:*/		return 0x82175D50;
	}
	return 0x82175D50;
} // Block from 82175D44h-82175D50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175D50);
		  /* 82175D50h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 82175D50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82175D50h case    0:*/		return 0x82175D54;
		  /* 82175D54h */ case    1:  		/* addic. R11, R11, -1 */
		/* 82175D54h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82175D54h case    1:*/		return 0x82175D58;
		  /* 82175D58h */ case    2:  		/* stw R11, <#[R4 + 8]> */
		/* 82175D58h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82175D58h case    2:*/		return 0x82175D5C;
		  /* 82175D5Ch */ case    3:  		/* bc 4, CR0_EQ, -1076 */
		/* 82175D5Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82175928;  }
		/* 82175D5Ch case    3:*/		return 0x82175D60;
		  /* 82175D60h */ case    4:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 82175D60h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 82175D60h case    4:*/		return 0x82175D64;
		  /* 82175D64h */ case    5:  		/* mr R3, R24 */
		/* 82175D64h case    5:*/		regs.R3 = regs.R24;
		/* 82175D64h case    5:*/		return 0x82175D68;
		  /* 82175D68h */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 82175D68h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82175D68h case    6:*/		return 0x82175D6C;
		  /* 82175D6Ch */ case    7:  		/* lwz R9, <#[R11]> */
		/* 82175D6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82175D6Ch case    7:*/		return 0x82175D70;
		  /* 82175D70h */ case    8:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82175D70h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82175D70h case    8:*/		return 0x82175D74;
		  /* 82175D74h */ case    9:  		/* stw R9, <#[R10]> */
		/* 82175D74h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82175D74h case    9:*/		return 0x82175D78;
		  /* 82175D78h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 82175D78h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82175D78h case   10:*/		return 0x82175D7C;
		  /* 82175D7Ch */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175D7Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175D7Ch case   11:*/		return 0x82175D80;
		  /* 82175D80h */ case   12:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82175D80h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82175D80h case   12:*/		return 0x82175D84;
		  /* 82175D84h */ case   13:  		/* stw R11, <#[R10]> */
		/* 82175D84h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82175D84h case   13:*/		return 0x82175D88;
		  /* 82175D88h */ case   14:  		/* lwz R11, <#[R4 + 12]> */
		/* 82175D88h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82175D88h case   14:*/		return 0x82175D8C;
		  /* 82175D8Ch */ case   15:  		/* addi R11, R11, 4 */
		/* 82175D8Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82175D8Ch case   15:*/		return 0x82175D90;
		  /* 82175D90h */ case   16:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82175D90h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82175D90h case   16:*/		return 0x82175D94;
		  /* 82175D94h */ case   17:  		/* bl -147340 */
		/* 82175D94h case   17:*/		regs.LR = 0x82175D98; return 0x82151E08;
		/* 82175D94h case   17:*/		return 0x82175D98;
		  /* 82175D98h */ case   18:  		/* b -1136 */
		/* 82175D98h case   18:*/		return 0x82175928;
		/* 82175D98h case   18:*/		return 0x82175D9C;
	}
	return 0x82175D9C;
} // Block from 82175D50h-82175D9Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82175D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175D9C);
		  /* 82175D9Ch */ case    0:  		/* stw R14, <#[R31]> */
		/* 82175D9Ch case    0:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x00000000) );
		/* 82175D9Ch case    0:*/		return 0x82175DA0;
		  /* 82175DA0h */ case    1:  		/* b -1144 */
		/* 82175DA0h case    1:*/		return 0x82175928;
		/* 82175DA0h case    1:*/		return 0x82175DA4;
	}
	return 0x82175DA4;
} // Block from 82175D9Ch-82175DA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175DA4);
		  /* 82175DA4h */ case    0:  		/* lwz R11, <#[R18 + 792]> */
		/* 82175DA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000318) );
		/* 82175DA4h case    0:*/		return 0x82175DA8;
		  /* 82175DA8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82175DA8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175DA8h case    1:*/		return 0x82175DAC;
		  /* 82175DACh */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 82175DACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82175DB4;  }
		/* 82175DACh case    2:*/		return 0x82175DB0;
		  /* 82175DB0h */ case    3:  		/* li R11, 32 */
		/* 82175DB0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 82175DB0h case    3:*/		return 0x82175DB4;
	}
	return 0x82175DB4;
} // Block from 82175DA4h-82175DB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82175DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175DB4);
		  /* 82175DB4h */ case    0:  		/* cmplw CR6, R15, R11 */
		/* 82175DB4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R11);
		/* 82175DB4h case    0:*/		return 0x82175DB8;
		  /* 82175DB8h */ case    1:  		/* bc 4, CR6_LT, 808 */
		/* 82175DB8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821760E0;  }
		/* 82175DB8h case    1:*/		return 0x82175DBC;
		  /* 82175DBCh */ case    2:  		/* stb R14, <#[R1 + 185]> */
		/* 82175DBCh case    2:*/		cpu::mem::store8( regs, regs.R14, (uint32)(regs.R1 + 0x000000B9) );
		/* 82175DBCh case    2:*/		return 0x82175DC0;
		  /* 82175DC0h */ case    3:  		/* mr R4, R23 */
		/* 82175DC0h case    3:*/		regs.R4 = regs.R23;
		/* 82175DC0h case    3:*/		return 0x82175DC4;
		  /* 82175DC4h */ case    4:  		/* stb R16, <#[R1 + 186]> */
		/* 82175DC4h case    4:*/		cpu::mem::store8( regs, regs.R16, (uint32)(regs.R1 + 0x000000BA) );
		/* 82175DC4h case    4:*/		return 0x82175DC8;
		  /* 82175DC8h */ case    5:  		/* addi R3, R1, 112 */
		/* 82175DC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82175DC8h case    5:*/		return 0x82175DCC;
		  /* 82175DCCh */ case    6:  		/* bl -7548 */
		/* 82175DCCh case    6:*/		regs.LR = 0x82175DD0; return 0x82174050;
		/* 82175DCCh case    6:*/		return 0x82175DD0;
		  /* 82175DD0h */ case    7:  		/* mr R3, R18 */
		/* 82175DD0h case    7:*/		regs.R3 = regs.R18;
		/* 82175DD0h case    7:*/		return 0x82175DD4;
		  /* 82175DD4h */ case    8:  		/* bl -14188 */
		/* 82175DD4h case    8:*/		regs.LR = 0x82175DD8; return 0x82172668;
		/* 82175DD4h case    8:*/		return 0x82175DD8;
		  /* 82175DD8h */ case    9:  		/* lwz R11, <#[R1 + 172]> */
		/* 82175DD8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000AC) );
		/* 82175DD8h case    9:*/		return 0x82175DDC;
		  /* 82175DDCh */ case   10:  		/* mr R27, R3 */
		/* 82175DDCh case   10:*/		regs.R27 = regs.R3;
		/* 82175DDCh case   10:*/		return 0x82175DE0;
		  /* 82175DE0h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82175DE0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175DE0h case   11:*/		return 0x82175DE4;
		  /* 82175DE4h */ case   12:  		/* stw R11, <#[R3 + 12]> */
		/* 82175DE4h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82175DE4h case   12:*/		return 0x82175DE8;
		  /* 82175DE8h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 82175DE8h case   13:*/		if ( regs.CR[6].eq ) { return 0x82175DF8;  }
		/* 82175DE8h case   13:*/		return 0x82175DEC;
		  /* 82175DECh */ case   14:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82175DECh case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82175DECh case   14:*/		return 0x82175DF0;
		  /* 82175DF0h */ case   15:  		/* lwz R11, <#[R11 + 40]> */
		/* 82175DF0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82175DF0h case   15:*/		return 0x82175DF4;
		  /* 82175DF4h */ case   16:  		/* b 12 */
		/* 82175DF4h case   16:*/		return 0x82175E00;
		/* 82175DF4h case   16:*/		return 0x82175DF8;
	}
	return 0x82175DF8;
} // Block from 82175DB4h-82175DF8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82175DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175DF8);
		  /* 82175DF8h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 82175DF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82175DF8h case    0:*/		return 0x82175DFC;
		  /* 82175DFCh */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175DFCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175DFCh case    1:*/		return 0x82175E00;
	}
	return 0x82175E00;
} // Block from 82175DF8h-82175E00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175E00);
		  /* 82175E00h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82175E00h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175E00h case    0:*/		return 0x82175E04;
		  /* 82175E04h */ case    1:  		/* stw R14, <#[R1 + 96]> */
		/* 82175E04h case    1:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000060) );
		/* 82175E04h case    1:*/		return 0x82175E08;
		  /* 82175E08h */ case    2:  		/* addic R10, R10, -1 */
		/* 82175E08h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82175E08h case    2:*/		return 0x82175E0C;
		  /* 82175E0Ch */ case    3:  		/* subfe R10, R10, R10 */
		/* 82175E0Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82175E0Ch case    3:*/		return 0x82175E10;
		  /* 82175E10h */ case    4:  		/* and R11, R10, R11 */
		/* 82175E10h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82175E10h case    4:*/		return 0x82175E14;
		  /* 82175E14h */ case    5:  		/* stw R11, <#[R27 + 16]> */
		/* 82175E14h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82175E14h case    5:*/		return 0x82175E18;
		  /* 82175E18h */ case    6:  		/* lwz R11, <#[R1 + 168]> */
		/* 82175E18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82175E18h case    6:*/		return 0x82175E1C;
		  /* 82175E1Ch */ case    7:  		/* lwz R11, <#[R11 + 16]> */
		/* 82175E1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82175E1Ch case    7:*/		return 0x82175E20;
		  /* 82175E20h */ case    8:  		/* stw R11, <#[R27 + 20]> */
		/* 82175E20h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 82175E20h case    8:*/		return 0x82175E24;
		  /* 82175E24h */ case    9:  		/* lwz R11, <#[R23 + 4]> */
		/* 82175E24h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82175E24h case    9:*/		return 0x82175E28;
		  /* 82175E28h */ case   10:  		/* lwz R10, <#[R11 + 4]> */
		/* 82175E28h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82175E28h case   10:*/		return 0x82175E2C;
		  /* 82175E2Ch */ case   11:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 82175E2Ch case   11:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82175E2Ch case   11:*/		return 0x82175E30;
		  /* 82175E30h */ case   12:  		/* addic R9, R9, -1 */
		/* 82175E30h case   12:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82175E30h case   12:*/		return 0x82175E34;
		  /* 82175E34h */ case   13:  		/* stw R11, <#[R1 + 88]> */
		/* 82175E34h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82175E34h case   13:*/		return 0x82175E38;
		  /* 82175E38h */ case   14:  		/* subfe R11, R9, R9 */
		/* 82175E38h case   14:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R9);
		/* 82175E38h case   14:*/		return 0x82175E3C;
		  /* 82175E3Ch */ case   15:  		/* and R10, R11, R10 */
		/* 82175E3Ch case   15:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82175E3Ch case   15:*/		return 0x82175E40;
		  /* 82175E40h */ case   16:  		/* stw R10, <#[R1 + 92]> */
		/* 82175E40h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82175E40h case   16:*/		return 0x82175E44;
		  /* 82175E44h */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 82175E44h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82175E44h case   17:*/		return 0x82175E48;
		  /* 82175E48h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 82175E48h case   18:*/		if ( regs.CR[6].eq ) { return 0x82175E60;  }
		/* 82175E48h case   18:*/		return 0x82175E4C;
		  /* 82175E4Ch */ case   19:  		/* lwz R11, <#[R10 + 8]> */
		/* 82175E4Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82175E4Ch case   19:*/		return 0x82175E50;
		  /* 82175E50h */ case   20:  		/* lwz R10, <#[R1 + 96]> */
		/* 82175E50h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82175E50h case   20:*/		return 0x82175E54;
		  /* 82175E54h */ case   21:  		/* cmplw CR6, R10, R11 */
		/* 82175E54h case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82175E54h case   21:*/		return 0x82175E58;
		  /* 82175E58h */ case   22:  		/* mr R11, R14 */
		/* 82175E58h case   22:*/		regs.R11 = regs.R14;
		/* 82175E58h case   22:*/		return 0x82175E5C;
		  /* 82175E5Ch */ case   23:  		/* bc 4, CR6_EQ, 8 */
		/* 82175E5Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x82175E64;  }
		/* 82175E5Ch case   23:*/		return 0x82175E60;
	}
	return 0x82175E60;
} // Block from 82175E00h-82175E60h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82175E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175E60);
		  /* 82175E60h */ case    0:  		/* mr R11, R16 */
		/* 82175E60h case    0:*/		regs.R11 = regs.R16;
		/* 82175E60h case    0:*/		return 0x82175E64;
	}
	return 0x82175E64;
} // Block from 82175E60h-82175E64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82175E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175E64);
		  /* 82175E64h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82175E64h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82175E64h case    0:*/		return 0x82175E68;
		  /* 82175E68h */ case    1:  		/* bc 4, CR0_EQ, 112 */
		/* 82175E68h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82175ED8;  }
		/* 82175E68h case    1:*/		return 0x82175E6C;
		  /* 82175E6Ch */ case    2:  		/* addi R3, R1, 88 */
		/* 82175E6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82175E6Ch case    2:*/		return 0x82175E70;
		  /* 82175E70h */ case    3:  		/* bl 307096 */
		/* 82175E70h case    3:*/		regs.LR = 0x82175E74; return 0x821C0E08;
		/* 82175E70h case    3:*/		return 0x82175E74;
		  /* 82175E74h */ case    4:  		/* lwz R11, <#[R27 + 4]> */
		/* 82175E74h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82175E74h case    4:*/		return 0x82175E78;
		  /* 82175E78h */ case    5:  		/* lwz R31, <#[R3]> */
		/* 82175E78h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82175E78h case    5:*/		return 0x82175E7C;
		  /* 82175E7Ch */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 82175E7Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82175E7Ch case    6:*/		return 0x82175E80;
		  /* 82175E80h */ case    7:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82175E80h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82175E80h case    7:*/		return 0x82175E84;
		  /* 82175E84h */ case    8:  		/* bc 4, CR0_EQ, 40 */
		/* 82175E84h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82175EAC;  }
		/* 82175E84h case    8:*/		return 0x82175E88;
		  /* 82175E88h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 82175E88h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82175E88h case    9:*/		return 0x82175E8C;
		  /* 82175E8Ch */ case   10:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82175E8Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82175E8Ch case   10:*/		return 0x82175E90;
		  /* 82175E90h */ case   11:  		/* addic. R3, R10, -4 */
		/* 82175E90h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R10,0xFFFFFFFC);
		/* 82175E90h case   11:*/		return 0x82175E94;
		  /* 82175E94h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 82175E94h case   12:*/		if ( regs.CR[0].eq ) { return 0x82175EAC;  }
		/* 82175E94h case   12:*/		return 0x82175E98;
		  /* 82175E98h */ case   13:  		/* lwz R10, <#[R3 + 8]> */
		/* 82175E98h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82175E98h case   13:*/		return 0x82175E9C;
		  /* 82175E9Ch */ case   14:  		/* lwz R9, <#[R3 + 12]> */
		/* 82175E9Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 82175E9Ch case   14:*/		return 0x82175EA0;
		  /* 82175EA0h */ case   15:  		/* addi R10, R10, 1 */
		/* 82175EA0h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82175EA0h case   15:*/		return 0x82175EA4;
		  /* 82175EA4h */ case   16:  		/* cmplw CR6, R10, R9 */
		/* 82175EA4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82175EA4h case   16:*/		return 0x82175EA8;
		  /* 82175EA8h */ case   17:  		/* bc 4, CR6_GT, 16 */
		/* 82175EA8h case   17:*/		if ( !regs.CR[6].gt ) { return 0x82175EB8;  }
		/* 82175EA8h case   17:*/		return 0x82175EAC;
	}
	return 0x82175EAC;
} // Block from 82175E64h-82175EACh (18 instructions)

//////////////////////////////////////////////////////
// Block at 82175EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175EAC);
		  /* 82175EACh */ case    0:  		/* li R4, 1 */
		/* 82175EACh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82175EACh case    0:*/		return 0x82175EB0;
		  /* 82175EB0h */ case    1:  		/* mr R3, R11 */
		/* 82175EB0h case    1:*/		regs.R3 = regs.R11;
		/* 82175EB0h case    1:*/		return 0x82175EB4;
		  /* 82175EB4h */ case    2:  		/* bl 94740 */
		/* 82175EB4h case    2:*/		regs.LR = 0x82175EB8; return 0x8218D0C8;
		/* 82175EB4h case    2:*/		return 0x82175EB8;
	}
	return 0x82175EB8;
} // Block from 82175EACh-82175EB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82175EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175EB8);
		  /* 82175EB8h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82175EB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82175EB8h case    0:*/		return 0x82175EBC;
		  /* 82175EBCh */ case    1:  		/* lwz R10, <#[R1 + 92]> */
		/* 82175EBCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82175EBCh case    1:*/		return 0x82175EC0;
		  /* 82175EC0h */ case    2:  		/* addi R9, R11, 4 */
		/* 82175EC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82175EC0h case    2:*/		return 0x82175EC4;
		  /* 82175EC4h */ case    3:  		/* addi R8, R11, 1 */
		/* 82175EC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 82175EC4h case    3:*/		return 0x82175EC8;
		  /* 82175EC8h */ case    4:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 82175EC8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 82175EC8h case    4:*/		return 0x82175ECC;
		  /* 82175ECCh */ case    5:  		/* stw R8, <#[R3 + 8]> */
		/* 82175ECCh case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 82175ECCh case    5:*/		return 0x82175ED0;
		  /* 82175ED0h */ case    6:  		/* stwx R31, <#[R11 + R3]> */
		/* 82175ED0h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82175ED0h case    6:*/		return 0x82175ED4;
		  /* 82175ED4h */ case    7:  		/* b -144 */
		/* 82175ED4h case    7:*/		return 0x82175E44;
		/* 82175ED4h case    7:*/		return 0x82175ED8;
	}
	return 0x82175ED8;
} // Block from 82175EB8h-82175ED8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82175ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175ED8);
		  /* 82175ED8h */ case    0:  		/* lwz R30, <#[R27 + 4]> */
		/* 82175ED8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000004) );
		/* 82175ED8h case    0:*/		return 0x82175EDC;
		  /* 82175EDCh */ case    1:  		/* lwz R11, <#[R30 + 4]> */
		/* 82175EDCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82175EDCh case    1:*/		return 0x82175EE0;
		  /* 82175EE0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82175EE0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175EE0h case    2:*/		return 0x82175EE4;
		  /* 82175EE4h */ case    3:  		/* bc 4, CR0_EQ, 472 */
		/* 82175EE4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821760BC;  }
		/* 82175EE4h case    3:*/		return 0x82175EE8;
		  /* 82175EE8h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82175EE8h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82175EE8h case    4:*/		return 0x82175EEC;
		  /* 82175EECh */ case    5:  		/* bc 12, CR0_EQ, 464 */
		/* 82175EECh case    5:*/		if ( regs.CR[0].eq ) { return 0x821760BC;  }
		/* 82175EECh case    5:*/		return 0x82175EF0;
		  /* 82175EF0h */ case    6:  		/* mr R11, R30 */
		/* 82175EF0h case    6:*/		regs.R11 = regs.R30;
		/* 82175EF0h case    6:*/		return 0x82175EF4;
		  /* 82175EF4h */ case    7:  		/* stw R14, <#[R1 + 96]> */
		/* 82175EF4h case    7:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000060) );
		/* 82175EF4h case    7:*/		return 0x82175EF8;
		  /* 82175EF8h */ case    8:  		/* mr R31, R14 */
		/* 82175EF8h case    8:*/		regs.R31 = regs.R14;
		/* 82175EF8h case    8:*/		return 0x82175EFC;
		  /* 82175EFCh */ case    9:  		/* stw R30, <#[R1 + 88]> */
		/* 82175EFCh case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 82175EFCh case    9:*/		return 0x82175F00;
		  /* 82175F00h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 82175F00h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82175F00h case   10:*/		return 0x82175F04;
		  /* 82175F04h */ case   11:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82175F04h case   11:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82175F04h case   11:*/		return 0x82175F08;
		  /* 82175F08h */ case   12:  		/* addic R10, R10, -1 */
		/* 82175F08h case   12:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82175F08h case   12:*/		return 0x82175F0C;
		  /* 82175F0Ch */ case   13:  		/* subfe R10, R10, R10 */
		/* 82175F0Ch case   13:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82175F0Ch case   13:*/		return 0x82175F10;
		  /* 82175F10h */ case   14:  		/* and R11, R10, R11 */
		/* 82175F10h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82175F10h case   14:*/		return 0x82175F14;
		  /* 82175F14h */ case   15:  		/* stw R11, <#[R1 + 92]> */
		/* 82175F14h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82175F14h case   15:*/		return 0x82175F18;
		  /* 82175F18h */ case   16:  		/* lwz R11, <#[R1 + 92]> */
		/* 82175F18h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82175F18h case   16:*/		return 0x82175F1C;
		  /* 82175F1Ch */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 82175F1Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82175F1Ch case   17:*/		return 0x82175F20;
		  /* 82175F20h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 82175F20h case   18:*/		if ( regs.CR[6].eq ) { return 0x82175F38;  }
		/* 82175F20h case   18:*/		return 0x82175F24;
		  /* 82175F24h */ case   19:  		/* lwz R11, <#[R11 + 8]> */
		/* 82175F24h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82175F24h case   19:*/		return 0x82175F28;
		  /* 82175F28h */ case   20:  		/* lwz R10, <#[R1 + 96]> */
		/* 82175F28h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82175F28h case   20:*/		return 0x82175F2C;
		  /* 82175F2Ch */ case   21:  		/* cmplw CR6, R10, R11 */
		/* 82175F2Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82175F2Ch case   21:*/		return 0x82175F30;
		  /* 82175F30h */ case   22:  		/* mr R11, R14 */
		/* 82175F30h case   22:*/		regs.R11 = regs.R14;
		/* 82175F30h case   22:*/		return 0x82175F34;
		  /* 82175F34h */ case   23:  		/* bc 4, CR6_EQ, 8 */
		/* 82175F34h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82175F3C;  }
		/* 82175F34h case   23:*/		return 0x82175F38;
	}
	return 0x82175F38;
} // Block from 82175ED8h-82175F38h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82175F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175F38);
		  /* 82175F38h */ case    0:  		/* mr R11, R16 */
		/* 82175F38h case    0:*/		regs.R11 = regs.R16;
		/* 82175F38h case    0:*/		return 0x82175F3C;
	}
	return 0x82175F3C;
} // Block from 82175F38h-82175F3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82175F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175F3C);
		  /* 82175F3Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82175F3Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82175F3Ch case    0:*/		return 0x82175F40;
		  /* 82175F40h */ case    1:  		/* bc 4, CR0_EQ, 100 */
		/* 82175F40h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82175FA4;  }
		/* 82175F40h case    1:*/		return 0x82175F44;
		  /* 82175F44h */ case    2:  		/* addi R3, R1, 88 */
		/* 82175F44h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82175F44h case    2:*/		return 0x82175F48;
		  /* 82175F48h */ case    3:  		/* bl 306880 */
		/* 82175F48h case    3:*/		regs.LR = 0x82175F4C; return 0x821C0E08;
		/* 82175F48h case    3:*/		return 0x82175F4C;
		  /* 82175F4Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 82175F4Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82175F4Ch case    4:*/		return 0x82175F50;
		  /* 82175F50h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 82175F50h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82175F50h case    5:*/		return 0x82175F54;
		  /* 82175F54h */ case    6:  		/* bc 12, CR6_EQ, 72 */
		/* 82175F54h case    6:*/		if ( regs.CR[6].eq ) { return 0x82175F9C;  }
		/* 82175F54h case    6:*/		return 0x82175F58;
		  /* 82175F58h */ case    7:  		/* lwz R10, <#[R31 + 20]> */
		/* 82175F58h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82175F58h case    7:*/		return 0x82175F5C;
		  /* 82175F5Ch */ case    8:  		/* lwz R9, <#[R11 + 20]> */
		/* 82175F5Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82175F5Ch case    8:*/		return 0x82175F60;
		  /* 82175F60h */ case    9:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 82175F60h case    9:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82175F60h case    9:*/		return 0x82175F64;
		  /* 82175F64h */ case   10:  		/* rlwinm R9, R9, 0, 19, 31 */
		/* 82175F64h case   10:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R9,regs.R9);
		/* 82175F64h case   10:*/		return 0x82175F68;
		  /* 82175F68h */ case   11:  		/* cmplw CR6, R9, R10 */
		/* 82175F68h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82175F68h case   11:*/		return 0x82175F6C;
		  /* 82175F6Ch */ case   12:  		/* bc 12, CR6_LT, 48 */
		/* 82175F6Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x82175F9C;  }
		/* 82175F6Ch case   12:*/		return 0x82175F70;
		  /* 82175F70h */ case   13:  		/* bc 4, CR6_EQ, -88 */
		/* 82175F70h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82175F18;  }
		/* 82175F70h case   13:*/		return 0x82175F74;
		  /* 82175F74h */ case   14:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175F74h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175F74h case   14:*/		return 0x82175F78;
		  /* 82175F78h */ case   15:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 82175F78h case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 82175F78h case   15:*/		return 0x82175F7C;
		  /* 82175F7Ch */ case   16:  		/* cmplwi CR6, R10, 32 */
		/* 82175F7Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 82175F7Ch case   16:*/		return 0x82175F80;
		  /* 82175F80h */ case   17:  		/* bc 12, CR6_LT, 16 */
		/* 82175F80h case   17:*/		if ( regs.CR[6].lt ) { return 0x82175F90;  }
		/* 82175F80h case   17:*/		return 0x82175F84;
		  /* 82175F84h */ case   18:  		/* cmplwi CR6, R10, 82 */
		/* 82175F84h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 82175F84h case   18:*/		return 0x82175F88;
		  /* 82175F88h */ case   19:  		/* mr R10, R16 */
		/* 82175F88h case   19:*/		regs.R10 = regs.R16;
		/* 82175F88h case   19:*/		return 0x82175F8C;
		  /* 82175F8Ch */ case   20:  		/* bc 4, CR6_GT, 8 */
		/* 82175F8Ch case   20:*/		if ( !regs.CR[6].gt ) { return 0x82175F94;  }
		/* 82175F8Ch case   20:*/		return 0x82175F90;
	}
	return 0x82175F90;
} // Block from 82175F3Ch-82175F90h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82175F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175F90);
		  /* 82175F90h */ case    0:  		/* mr R10, R14 */
		/* 82175F90h case    0:*/		regs.R10 = regs.R14;
		/* 82175F90h case    0:*/		return 0x82175F94;
	}
	return 0x82175F94;
} // Block from 82175F90h-82175F94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82175F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175F94);
		  /* 82175F94h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82175F94h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82175F94h case    0:*/		return 0x82175F98;
		  /* 82175F98h */ case    1:  		/* bc 12, CR0_EQ, -128 */
		/* 82175F98h case    1:*/		if ( regs.CR[0].eq ) { return 0x82175F18;  }
		/* 82175F98h case    1:*/		return 0x82175F9C;
	}
	return 0x82175F9C;
} // Block from 82175F94h-82175F9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175F9C);
		  /* 82175F9Ch */ case    0:  		/* mr R31, R11 */
		/* 82175F9Ch case    0:*/		regs.R31 = regs.R11;
		/* 82175F9Ch case    0:*/		return 0x82175FA0;
		  /* 82175FA0h */ case    1:  		/* b -136 */
		/* 82175FA0h case    1:*/		return 0x82175F18;
		/* 82175FA0h case    1:*/		return 0x82175FA4;
	}
	return 0x82175FA4;
} // Block from 82175F9Ch-82175FA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82175FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82175FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82175FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82175FA4);
		  /* 82175FA4h */ case    0:  		/* mr R4, R31 */
		/* 82175FA4h case    0:*/		regs.R4 = regs.R31;
		/* 82175FA4h case    0:*/		return 0x82175FA8;
		  /* 82175FA8h */ case    1:  		/* mr R3, R30 */
		/* 82175FA8h case    1:*/		regs.R3 = regs.R30;
		/* 82175FA8h case    1:*/		return 0x82175FAC;
		  /* 82175FACh */ case    2:  		/* bl -16132 */
		/* 82175FACh case    2:*/		regs.LR = 0x82175FB0; return 0x821720A8;
		/* 82175FACh case    2:*/		return 0x82175FB0;
		  /* 82175FB0h */ case    3:  		/* li R5, 1 */
		/* 82175FB0h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82175FB0h case    3:*/		return 0x82175FB4;
		  /* 82175FB4h */ case    4:  		/* mr R4, R31 */
		/* 82175FB4h case    4:*/		regs.R4 = regs.R31;
		/* 82175FB4h case    4:*/		return 0x82175FB8;
		  /* 82175FB8h */ case    5:  		/* addi R3, R1, 112 */
		/* 82175FB8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82175FB8h case    5:*/		return 0x82175FBC;
		  /* 82175FBCh */ case    6:  		/* bl -8540 */
		/* 82175FBCh case    6:*/		regs.LR = 0x82175FC0; return 0x82173E60;
		/* 82175FBCh case    6:*/		return 0x82175FC0;
		  /* 82175FC0h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82175FC0h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82175FC0h case    7:*/		return 0x82175FC4;
		  /* 82175FC4h */ case    8:  		/* bc 12, CR0_EQ, 236 */
		/* 82175FC4h case    8:*/		if ( regs.CR[0].eq ) { return 0x821760B0;  }
		/* 82175FC4h case    8:*/		return 0x82175FC8;
		  /* 82175FC8h */ case    9:  		/* mr R28, R31 */
		/* 82175FC8h case    9:*/		regs.R28 = regs.R31;
		/* 82175FC8h case    9:*/		return 0x82175FCC;
		  /* 82175FCCh */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 82175FCCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82175FCCh case   10:*/		return 0x82175FD0;
		  /* 82175FD0h */ case   11:  		/* bc 12, CR6_EQ, -248 */
		/* 82175FD0h case   11:*/		if ( regs.CR[6].eq ) { return 0x82175ED8;  }
		/* 82175FD0h case   11:*/		return 0x82175FD4;
		  /* 82175FD4h */ case   12:  		/* lwz R29, <#[R28]> */
		/* 82175FD4h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000000) );
		/* 82175FD4h case   12:*/		return 0x82175FD8;
		  /* 82175FD8h */ case   13:  		/* cmplwi CR6, R29, 0 */
		/* 82175FD8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82175FD8h case   13:*/		return 0x82175FDC;
		  /* 82175FDCh */ case   14:  		/* bc 12, CR6_EQ, 196 */
		/* 82175FDCh case   14:*/		if ( regs.CR[6].eq ) { return 0x821760A0;  }
		/* 82175FDCh case   14:*/		return 0x82175FE0;
		  /* 82175FE0h */ case   15:  		/* lwz R11, <#[R29 + 12]> */
		/* 82175FE0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82175FE0h case   15:*/		return 0x82175FE4;
		  /* 82175FE4h */ case   16:  		/* lwz R10, <#[R11 + 8]> */
		/* 82175FE4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82175FE4h case   16:*/		return 0x82175FE8;
		  /* 82175FE8h */ case   17:  		/* rlwinm. R10, R10, 6, 31, 31 */
		/* 82175FE8h case   17:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R10);
		/* 82175FE8h case   17:*/		return 0x82175FEC;
		  /* 82175FECh */ case   18:  		/* bc 12, CR0_EQ, 172 */
		/* 82175FECh case   18:*/		if ( regs.CR[0].eq ) { return 0x82176098;  }
		/* 82175FECh case   18:*/		return 0x82175FF0;
		  /* 82175FF0h */ case   19:  		/* lwz R10, <#[R11 + 16]> */
		/* 82175FF0h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82175FF0h case   19:*/		return 0x82175FF4;
		  /* 82175FF4h */ case   20:  		/* rlwinm. R9, R10, 7, 31, 31 */
		/* 82175FF4h case   20:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R9,regs.R10);
		/* 82175FF4h case   20:*/		return 0x82175FF8;
		  /* 82175FF8h */ case   21:  		/* bc 4, CR0_EQ, 160 */
		/* 82175FF8h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82176098;  }
		/* 82175FF8h case   21:*/		return 0x82175FFC;
		  /* 82175FFCh */ case   22:  		/* lwz R9, <#[R11 + 20]> */
		/* 82175FFCh case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82175FFCh case   22:*/		return 0x82176000;
		  /* 82176000h */ case   23:  		/* rlwinm R10, R10, 12, 21, 24 */
		/* 82176000h case   23:*/		cpu::op::rlwinm<0,12,21,24>(regs,&regs.R10,regs.R10);
		/* 82176000h case   23:*/		return 0x82176004;
		  /* 82176004h */ case   24:  		/* lwz R11, <#[R18 + 720]> */
		/* 82176004h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x000002D0) );
		/* 82176004h case   24:*/		return 0x82176008;
		  /* 82176008h */ case   25:  		/* rlwinm R9, R9, 7, 25, 31 */
		/* 82176008h case   25:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R9,regs.R9);
		/* 82176008h case   25:*/		return 0x8217600C;
		  /* 8217600Ch */ case   26:  		/* or R10, R10, R9 */
		/* 8217600Ch case   26:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8217600Ch case   26:*/		return 0x82176010;
		  /* 82176010h */ case   27:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82176010h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82176010h case   27:*/		return 0x82176014;
		  /* 82176014h */ case   28:  		/* add R11, R10, R11 */
		/* 82176014h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82176014h case   28:*/		return 0x82176018;
		  /* 82176018h */ case   29:  		/* lwz R31, <#[R11 - 4]> */
		/* 82176018h case   29:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82176018h case   29:*/		return 0x8217601C;
		  /* 8217601Ch */ case   30:  		/* mr R3, R31 */
		/* 8217601Ch case   30:*/		regs.R3 = regs.R31;
		/* 8217601Ch case   30:*/		return 0x82176020;
		  /* 82176020h */ case   31:  		/* bl -20792 */
		/* 82176020h case   31:*/		regs.LR = 0x82176024; return 0x82170EE8;
		/* 82176020h case   31:*/		return 0x82176024;
		  /* 82176024h */ case   32:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82176024h case   32:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82176024h case   32:*/		return 0x82176028;
		  /* 82176028h */ case   33:  		/* bc 12, CR0_EQ, 112 */
		/* 82176028h case   33:*/		if ( regs.CR[0].eq ) { return 0x82176098;  }
		/* 82176028h case   33:*/		return 0x8217602C;
		  /* 8217602Ch */ case   34:  		/* lwz R30, <#[R27 + 4]> */
		/* 8217602Ch case   34:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000004) );
		/* 8217602Ch case   34:*/		return 0x82176030;
		  /* 82176030h */ case   35:  		/* mr R4, R31 */
		/* 82176030h case   35:*/		regs.R4 = regs.R31;
		/* 82176030h case   35:*/		return 0x82176034;
		  /* 82176034h */ case   36:  		/* mr R3, R30 */
		/* 82176034h case   36:*/		regs.R3 = regs.R30;
		/* 82176034h case   36:*/		return 0x82176038;
		  /* 82176038h */ case   37:  		/* bl -16392 */
		/* 82176038h case   37:*/		regs.LR = 0x8217603C; return 0x82172030;
		/* 82176038h case   37:*/		return 0x8217603C;
		  /* 8217603Ch */ case   38:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8217603Ch case   38:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8217603Ch case   38:*/		return 0x82176040;
		  /* 82176040h */ case   39:  		/* bc 4, CR0_EQ, 88 */
		/* 82176040h case   39:*/		if ( !regs.CR[0].eq ) { return 0x82176098;  }
		/* 82176040h case   39:*/		return 0x82176044;
		  /* 82176044h */ case   40:  		/* lwz R11, <#[R30 + 4]> */
		/* 82176044h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82176044h case   40:*/		return 0x82176048;
		  /* 82176048h */ case   41:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82176048h case   41:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82176048h case   41:*/		return 0x8217604C;
		  /* 8217604Ch */ case   42:  		/* bc 4, CR0_EQ, 40 */
		/* 8217604Ch case   42:*/		if ( !regs.CR[0].eq ) { return 0x82176074;  }
		/* 8217604Ch case   42:*/		return 0x82176050;
		  /* 82176050h */ case   43:  		/* lwz R11, <#[R30]> */
		/* 82176050h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82176050h case   43:*/		return 0x82176054;
		  /* 82176054h */ case   44:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82176054h case   44:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82176054h case   44:*/		return 0x82176058;
		  /* 82176058h */ case   45:  		/* addic. R3, R11, -4 */
		/* 82176058h case   45:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82176058h case   45:*/		return 0x8217605C;
		  /* 8217605Ch */ case   46:  		/* bc 12, CR0_EQ, 24 */
		/* 8217605Ch case   46:*/		if ( regs.CR[0].eq ) { return 0x82176074;  }
		/* 8217605Ch case   46:*/		return 0x82176060;
		  /* 82176060h */ case   47:  		/* lwz R11, <#[R3 + 8]> */
		/* 82176060h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82176060h case   47:*/		return 0x82176064;
		  /* 82176064h */ case   48:  		/* lwz R10, <#[R3 + 12]> */
		/* 82176064h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82176064h case   48:*/		return 0x82176068;
		  /* 82176068h */ case   49:  		/* addi R11, R11, 1 */
		/* 82176068h case   49:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82176068h case   49:*/		return 0x8217606C;
		  /* 8217606Ch */ case   50:  		/* cmplw CR6, R11, R10 */
		/* 8217606Ch case   50:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8217606Ch case   50:*/		return 0x82176070;
		  /* 82176070h */ case   51:  		/* bc 4, CR6_GT, 16 */
		/* 82176070h case   51:*/		if ( !regs.CR[6].gt ) { return 0x82176080;  }
		/* 82176070h case   51:*/		return 0x82176074;
	}
	return 0x82176074;
} // Block from 82175FA4h-82176074h (52 instructions)

//////////////////////////////////////////////////////
// Block at 82176074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82176074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82176074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82176074);
		  /* 82176074h */ case    0:  		/* li R4, 1 */
		/* 82176074h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82176074h case    0:*/		return 0x82176078;
		  /* 82176078h */ case    1:  		/* mr R3, R30 */
		/* 82176078h case    1:*/		regs.R3 = regs.R30;
		/* 82176078h case    1:*/		return 0x8217607C;
		  /* 8217607Ch */ case    2:  		/* bl 94284 */
		/* 8217607Ch case    2:*/		regs.LR = 0x82176080; return 0x8218D0C8;
		/* 8217607Ch case    2:*/		return 0x82176080;
	}
	return 0x82176080;
} // Block from 82176074h-82176080h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82176080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82176080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82176080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82176080);
		  /* 82176080h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82176080h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82176080h case    0:*/		return 0x82176084;
		  /* 82176084h */ case    1:  		/* addi R10, R11, 4 */
		/* 82176084h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82176084h case    1:*/		return 0x82176088;
		  /* 82176088h */ case    2:  		/* addi R9, R11, 1 */
		/* 82176088h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82176088h case    2:*/		return 0x8217608C;
		  /* 8217608Ch */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8217608Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8217608Ch case    3:*/		return 0x82176090;
		  /* 82176090h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 82176090h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82176090h case    4:*/		return 0x82176094;
		  /* 82176094h */ case    5:  		/* stwx R31, <#[R11 + R3]> */
		/* 82176094h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82176094h case    5:*/		return 0x82176098;
	}
	return 0x82176098;
} // Block from 82176080h-82176098h (6 instructions)

