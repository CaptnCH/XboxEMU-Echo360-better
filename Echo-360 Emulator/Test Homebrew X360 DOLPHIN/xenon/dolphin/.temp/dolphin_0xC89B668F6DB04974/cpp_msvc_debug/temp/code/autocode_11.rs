#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 820CAC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAC20);
		  /* 820CAC20h */ case    0:  		/* mr R3, R31 */
		/* 820CAC20h case    0:*/		regs.R3 = regs.R31;
		/* 820CAC20h case    0:*/		return 0x820CAC24;
	}
	return 0x820CAC24;
} // Block from 820CAC20h-820CAC24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAC24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAC24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAC24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAC24);
		  /* 820CAC24h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CAC24h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CAC24h case    0:*/		return 0x820CAC28;
		  /* 820CAC28h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CAC28h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAC28h case    1:*/		return 0x820CAC2C;
		  /* 820CAC2Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CAC2Ch case    2:*/		regs.LR = regs.R12;
		/* 820CAC2Ch case    2:*/		return 0x820CAC30;
		  /* 820CAC30h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CAC30h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CAC30h case    3:*/		return 0x820CAC34;
		  /* 820CAC34h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CAC34h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CAC34h case    4:*/		return 0x820CAC38;
		  /* 820CAC38h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CAC38h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAC38h case    5:*/		return 0x820CAC3C;
	}
	return 0x820CAC3C;
} // Block from 820CAC24h-820CAC3Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CAC3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAC3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAC3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAC3C);
		  /* 820CAC3Ch */ case    0:  		/* nop */
		/* 820CAC3Ch case    0:*/		cpu::op::nop();
		/* 820CAC3Ch case    0:*/		return 0x820CAC40;
		  /* 820CAC40h */ case    1:  		/* lis R10, -32255 */
		/* 820CAC40h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CAC40h case    1:*/		return 0x820CAC44;
		  /* 820CAC44h */ case    2:  		/* li R11, 0 */
		/* 820CAC44h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CAC44h case    2:*/		return 0x820CAC48;
	}
	return 0x820CAC48;
} // Block from 820CAC3Ch-820CAC48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CAC48h
// Function '??0CNodeCBuffer@D3DXShader@@QAA@PAVCNode@1@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAC48);
		  /* 820CAC48h */ case    0:  		/* li R9, 9 */
		/* 820CAC48h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x9);
		/* 820CAC48h case    0:*/		return 0x820CAC4C;
		  /* 820CAC4Ch */ case    1:  		/* addi R10, R10, 10628 */
		/* 820CAC4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2984);
		/* 820CAC4Ch case    1:*/		return 0x820CAC50;
		  /* 820CAC50h */ case    2:  		/* stw R11, <#[R3 + 8]> */
		/* 820CAC50h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CAC50h case    2:*/		return 0x820CAC54;
		  /* 820CAC54h */ case    3:  		/* li R8, 10 */
		/* 820CAC54h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 820CAC54h case    3:*/		return 0x820CAC58;
		  /* 820CAC58h */ case    4:  		/* stw R9, <#[R3 + 4]> */
		/* 820CAC58h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CAC58h case    4:*/		return 0x820CAC5C;
		  /* 820CAC5Ch */ case    5:  		/* stw R10, <#[R3]> */
		/* 820CAC5Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAC5Ch case    5:*/		return 0x820CAC60;
		  /* 820CAC60h */ case    6:  		/* stw R11, <#[R3 + 12]> */
		/* 820CAC60h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CAC60h case    6:*/		return 0x820CAC64;
		  /* 820CAC64h */ case    7:  		/* stw R11, <#[R3 + 16]> */
		/* 820CAC64h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CAC64h case    7:*/		return 0x820CAC68;
		  /* 820CAC68h */ case    8:  		/* stw R8, <#[R3 + 20]> */
		/* 820CAC68h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820CAC68h case    8:*/		return 0x820CAC6C;
		  /* 820CAC6Ch */ case    9:  		/* stw R11, <#[R3 + 24]> */
		/* 820CAC6Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CAC6Ch case    9:*/		return 0x820CAC70;
		  /* 820CAC70h */ case   10:  		/* stw R11, <#[R3 + 28]> */
		/* 820CAC70h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CAC70h case   10:*/		return 0x820CAC74;
		  /* 820CAC74h */ case   11:  		/* stw R11, <#[R3 + 32]> */
		/* 820CAC74h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CAC74h case   11:*/		return 0x820CAC78;
		  /* 820CAC78h */ case   12:  		/* stw R11, <#[R3 + 36]> */
		/* 820CAC78h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CAC78h case   12:*/		return 0x820CAC7C;
		  /* 820CAC7Ch */ case   13:  		/* bclr 20, CR0_LT */
		/* 820CAC7Ch case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAC7Ch case   13:*/		return 0x820CAC80;
	}
	return 0x820CAC80;
} // Block from 820CAC48h-820CAC80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CAC80h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAC80);
		  /* 820CAC80h */ case    0:  		/* lis R10, -32255 */
		/* 820CAC80h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CAC80h case    0:*/		return 0x820CAC84;
		  /* 820CAC84h */ case    1:  		/* stw R5, <#[R3 + 20]> */
		/* 820CAC84h case    1:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820CAC84h case    1:*/		return 0x820CAC88;
	}
	return 0x820CAC88;
} // Block from 820CAC80h-820CAC88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CAC88h
// Function '?IsEqual@CNodeCBuffer@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAC88);
		  /* 820CAC88h */ case    0:  		/* li R11, 0 */
		/* 820CAC88h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CAC88h case    0:*/		return 0x820CAC8C;
		  /* 820CAC8Ch */ case    1:  		/* stw R4, <#[R3 + 16]> */
		/* 820CAC8Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CAC8Ch case    1:*/		return 0x820CAC90;
		  /* 820CAC90h */ case    2:  		/* li R5, 9 */
		/* 820CAC90h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x9);
		/* 820CAC90h case    2:*/		return 0x820CAC94;
		  /* 820CAC94h */ case    3:  		/* stw R6, <#[R3 + 24]> */
		/* 820CAC94h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 820CAC94h case    3:*/		return 0x820CAC98;
		  /* 820CAC98h */ case    4:  		/* addi R10, R10, 10628 */
		/* 820CAC98h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2984);
		/* 820CAC98h case    4:*/		return 0x820CAC9C;
		  /* 820CAC9Ch */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820CAC9Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CAC9Ch case    5:*/		return 0x820CACA0;
		  /* 820CACA0h */ case    6:  		/* stw R5, <#[R3 + 4]> */
		/* 820CACA0h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		/* 820CACA0h case    6:*/		return 0x820CACA4;
		  /* 820CACA4h */ case    7:  		/* stw R10, <#[R3]> */
		/* 820CACA4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CACA4h case    7:*/		return 0x820CACA8;
		  /* 820CACA8h */ case    8:  		/* stw R11, <#[R3 + 12]> */
		/* 820CACA8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CACA8h case    8:*/		return 0x820CACAC;
		  /* 820CACACh */ case    9:  		/* stw R7, <#[R3 + 28]> */
		/* 820CACACh case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CACACh case    9:*/		return 0x820CACB0;
		  /* 820CACB0h */ case   10:  		/* stw R8, <#[R3 + 32]> */
		/* 820CACB0h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000020) );
		/* 820CACB0h case   10:*/		return 0x820CACB4;
		  /* 820CACB4h */ case   11:  		/* stw R9, <#[R3 + 36]> */
		/* 820CACB4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000024) );
		/* 820CACB4h case   11:*/		return 0x820CACB8;
		  /* 820CACB8h */ case   12:  		/* bclr 20, CR0_LT */
		/* 820CACB8h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CACB8h case   12:*/		return 0x820CACBC;
	}
	return 0x820CACBC;
} // Block from 820CAC88h-820CACBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CACBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CACBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CACBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CACBC);
		  /* 820CACBCh */ case    0:  		/* nop */
		/* 820CACBCh case    0:*/		cpu::op::nop();
		/* 820CACBCh case    0:*/		return 0x820CACC0;
	}
	return 0x820CACC0;
} // Block from 820CACBCh-820CACC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CACC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CACC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CACC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CACC0);
		  /* 820CACC0h */ case    0:  		/* mfspr R12, LR */
		/* 820CACC0h case    0:*/		regs.R12 = regs.LR;
		/* 820CACC0h case    0:*/		return 0x820CACC4;
		  /* 820CACC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CACC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CACC4h case    1:*/		return 0x820CACC8;
		  /* 820CACC8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CACC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CACC8h case    2:*/		return 0x820CACCC;
		  /* 820CACCCh */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820CACCCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CACCCh case    3:*/		return 0x820CACD0;
		  /* 820CACD0h */ case    4:  		/* bc 12, CR6_EQ, 160 */
		/* 820CACD0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CAD70;  }
		/* 820CACD0h case    4:*/		return 0x820CACD4;
		  /* 820CACD4h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CACD4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CACD4h case    5:*/		return 0x820CACD8;
		  /* 820CACD8h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CACD8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CACD8h case    6:*/		return 0x820CACDC;
		  /* 820CACDCh */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820CACDCh case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CACDCh case    7:*/		return 0x820CACE0;
		  /* 820CACE0h */ case    8:  		/* bc 4, CR6_EQ, 144 */
		/* 820CACE0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CAD70;  }
		/* 820CACE0h case    8:*/		return 0x820CACE4;
		  /* 820CACE4h */ case    9:  		/* lwz R11, <#[R3 + 16]> */
		/* 820CACE4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CACE4h case    9:*/		return 0x820CACE8;
		  /* 820CACE8h */ case   10:  		/* lwz R10, <#[R4 + 16]> */
		/* 820CACE8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820CACE8h case   10:*/		return 0x820CACEC;
		  /* 820CACECh */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CACECh case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CACECh case   11:*/		return 0x820CACF0;
		  /* 820CACF0h */ case   12:  		/* bc 4, CR6_EQ, 128 */
		/* 820CACF0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CAD70;  }
		/* 820CACF0h case   12:*/		return 0x820CACF4;
		  /* 820CACF4h */ case   13:  		/* lwz R11, <#[R3 + 20]> */
		/* 820CACF4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CACF4h case   13:*/		return 0x820CACF8;
		  /* 820CACF8h */ case   14:  		/* lwz R10, <#[R4 + 20]> */
		/* 820CACF8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820CACF8h case   14:*/		return 0x820CACFC;
		  /* 820CACFCh */ case   15:  		/* cmpw CR6, R11, R10 */
		/* 820CACFCh case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CACFCh case   15:*/		return 0x820CAD00;
		  /* 820CAD00h */ case   16:  		/* bc 4, CR6_EQ, 112 */
		/* 820CAD00h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820CAD70;  }
		/* 820CAD00h case   16:*/		return 0x820CAD04;
		  /* 820CAD04h */ case   17:  		/* lwz R11, <#[R3 + 28]> */
		/* 820CAD04h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CAD04h case   17:*/		return 0x820CAD08;
		  /* 820CAD08h */ case   18:  		/* lwz R10, <#[R4 + 28]> */
		/* 820CAD08h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 820CAD08h case   18:*/		return 0x820CAD0C;
		  /* 820CAD0Ch */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820CAD0Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAD0Ch case   19:*/		return 0x820CAD10;
		  /* 820CAD10h */ case   20:  		/* bc 4, CR6_EQ, 96 */
		/* 820CAD10h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820CAD70;  }
		/* 820CAD10h case   20:*/		return 0x820CAD14;
		  /* 820CAD14h */ case   21:  		/* lwz R11, <#[R3 + 32]> */
		/* 820CAD14h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CAD14h case   21:*/		return 0x820CAD18;
		  /* 820CAD18h */ case   22:  		/* lwz R10, <#[R4 + 32]> */
		/* 820CAD18h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000020) );
		/* 820CAD18h case   22:*/		return 0x820CAD1C;
		  /* 820CAD1Ch */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820CAD1Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAD1Ch case   23:*/		return 0x820CAD20;
		  /* 820CAD20h */ case   24:  		/* bc 4, CR6_EQ, 80 */
		/* 820CAD20h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820CAD70;  }
		/* 820CAD20h case   24:*/		return 0x820CAD24;
		  /* 820CAD24h */ case   25:  		/* lwz R11, <#[R3 + 36]> */
		/* 820CAD24h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CAD24h case   25:*/		return 0x820CAD28;
		  /* 820CAD28h */ case   26:  		/* lwz R10, <#[R4 + 36]> */
		/* 820CAD28h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000024) );
		/* 820CAD28h case   26:*/		return 0x820CAD2C;
		  /* 820CAD2Ch */ case   27:  		/* cmplw CR6, R11, R10 */
		/* 820CAD2Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAD2Ch case   27:*/		return 0x820CAD30;
		  /* 820CAD30h */ case   28:  		/* bc 4, CR6_EQ, 64 */
		/* 820CAD30h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820CAD70;  }
		/* 820CAD30h case   28:*/		return 0x820CAD34;
		  /* 820CAD34h */ case   29:  		/* lwz R3, <#[R3 + 24]> */
		/* 820CAD34h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000018) );
		/* 820CAD34h case   29:*/		return 0x820CAD38;
		  /* 820CAD38h */ case   30:  		/* lwz R4, <#[R4 + 24]> */
		/* 820CAD38h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000018) );
		/* 820CAD38h case   30:*/		return 0x820CAD3C;
		  /* 820CAD3Ch */ case   31:  		/* cmplwi CR6, R3, 0 */
		/* 820CAD3Ch case   31:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CAD3Ch case   31:*/		return 0x820CAD40;
		  /* 820CAD40h */ case   32:  		/* bc 12, CR6_EQ, 24 */
		/* 820CAD40h case   32:*/		if ( regs.CR[6].eq ) { return 0x820CAD58;  }
		/* 820CAD40h case   32:*/		return 0x820CAD44;
		  /* 820CAD44h */ case   33:  		/* lwz R11, <#[R3]> */
		/* 820CAD44h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAD44h case   33:*/		return 0x820CAD48;
		  /* 820CAD48h */ case   34:  		/* lwz R11, <#[R11]> */
		/* 820CAD48h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CAD48h case   34:*/		return 0x820CAD4C;
		  /* 820CAD4Ch */ case   35:  		/* mtspr CTR, R11 */
		/* 820CAD4Ch case   35:*/		regs.CTR = regs.R11;
		/* 820CAD4Ch case   35:*/		return 0x820CAD50;
		  /* 820CAD50h */ case   36:  		/* bcctrl 20, CR0_LT */
		/* 820CAD50h case   36:*/		if ( 1 ) { regs.LR = 0x820CAD54; return (uint32)regs.CTR; }
		/* 820CAD50h case   36:*/		return 0x820CAD54;
		  /* 820CAD54h */ case   37:  		/* b 16 */
		/* 820CAD54h case   37:*/		return 0x820CAD64;
		/* 820CAD54h case   37:*/		return 0x820CAD58;
	}
	return 0x820CAD58;
} // Block from 820CACC0h-820CAD58h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820CAD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAD58);
		  /* 820CAD58h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CAD58h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CAD58h case    0:*/		return 0x820CAD5C;
		  /* 820CAD5Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CAD5Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CAD5Ch case    1:*/		return 0x820CAD60;
		  /* 820CAD60h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CAD60h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CAD60h case    2:*/		return 0x820CAD64;
	}
	return 0x820CAD64;
} // Block from 820CAD58h-820CAD64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CAD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAD64);
		  /* 820CAD64h */ case    0:  		/* addic R11, R3, -1 */
		/* 820CAD64h case    0:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820CAD64h case    0:*/		return 0x820CAD68;
		  /* 820CAD68h */ case    1:  		/* subfe R3, R11, R3 */
		/* 820CAD68h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820CAD68h case    1:*/		return 0x820CAD6C;
		  /* 820CAD6Ch */ case    2:  		/* b 8 */
		/* 820CAD6Ch case    2:*/		return 0x820CAD74;
		/* 820CAD6Ch case    2:*/		return 0x820CAD70;
	}
	return 0x820CAD70;
} // Block from 820CAD64h-820CAD70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CAD70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAD70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAD70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAD70);
		  /* 820CAD70h */ case    0:  		/* li R3, 0 */
		/* 820CAD70h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CAD70h case    0:*/		return 0x820CAD74;
	}
	return 0x820CAD74;
} // Block from 820CAD70h-820CAD74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAD74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAD74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAD74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAD74);
		  /* 820CAD74h */ case    0:  		/* addi R1, R1, 96 */
		/* 820CAD74h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CAD74h case    0:*/		return 0x820CAD78;
		  /* 820CAD78h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CAD78h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAD78h case    1:*/		return 0x820CAD7C;
		  /* 820CAD7Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CAD7Ch case    2:*/		regs.LR = regs.R12;
		/* 820CAD7Ch case    2:*/		return 0x820CAD80;
		  /* 820CAD80h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CAD80h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAD80h case    3:*/		return 0x820CAD84;
	}
	return 0x820CAD84;
} // Block from 820CAD74h-820CAD84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CAD84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAD84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAD84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAD84);
		  /* 820CAD84h */ case    0:  		/* nop */
		/* 820CAD84h case    0:*/		cpu::op::nop();
		/* 820CAD84h case    0:*/		return 0x820CAD88;
	}
	return 0x820CAD88;
} // Block from 820CAD84h-820CAD88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAD88);
		  /* 820CAD88h */ case    0:  		/* mfspr R12, LR */
		/* 820CAD88h case    0:*/		regs.R12 = regs.LR;
		/* 820CAD88h case    0:*/		return 0x820CAD8C;
		  /* 820CAD8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CAD8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAD8Ch case    1:*/		return 0x820CAD90;
		  /* 820CAD90h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CAD90h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CAD90h case    2:*/		return 0x820CAD94;
		  /* 820CAD94h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CAD94h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CAD94h case    3:*/		return 0x820CAD98;
		  /* 820CAD98h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CAD98h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CAD98h case    4:*/		return 0x820CAD9C;
		  /* 820CAD9Ch */ case    5:  		/* mr R30, R3 */
		/* 820CAD9Ch case    5:*/		regs.R30 = regs.R3;
		/* 820CAD9Ch case    5:*/		return 0x820CADA0;
		  /* 820CADA0h */ case    6:  		/* bl 8848 */
		/* 820CADA0h case    6:*/		regs.LR = 0x820CADA4; return 0x820CD030;
		/* 820CADA0h case    6:*/		return 0x820CADA4;
		  /* 820CADA4h */ case    7:  		/* li R5, 16 */
		/* 820CADA4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CADA4h case    7:*/		return 0x820CADA8;
		  /* 820CADA8h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CADA8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CADA8h case    8:*/		return 0x820CADAC;
		  /* 820CADACh */ case    9:  		/* li R4, 40 */
		/* 820CADACh case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 820CADACh case    9:*/		return 0x820CADB0;
		  /* 820CADB0h */ case   10:  		/* bl -7376 */
		/* 820CADB0h case   10:*/		regs.LR = 0x820CADB4; return 0x820C90E0;
		/* 820CADB0h case   10:*/		return 0x820CADB4;
		  /* 820CADB4h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CADB4h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CADB4h case   11:*/		return 0x820CADB8;
	}
	return 0x820CADB8;
} // Block from 820CAD88h-820CADB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CADB8h
// Function '?Copy@CNodeCBuffer@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CADB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CADB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CADB8);
		  /* 820CADB8h */ case    0:  		/* bc 12, CR0_EQ, 72 */
		/* 820CADB8h case    0:*/		if ( regs.CR[0].eq ) { return 0x820CAE00;  }
		/* 820CADB8h case    0:*/		return 0x820CADBC;
		  /* 820CADBCh */ case    1:  		/* lis R10, -32255 */
		/* 820CADBCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CADBCh case    1:*/		return 0x820CADC0;
		  /* 820CADC0h */ case    2:  		/* li R11, 0 */
		/* 820CADC0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CADC0h case    2:*/		return 0x820CADC4;
		  /* 820CADC4h */ case    3:  		/* li R9, 9 */
		/* 820CADC4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x9);
		/* 820CADC4h case    3:*/		return 0x820CADC8;
		  /* 820CADC8h */ case    4:  		/* addi R10, R10, 10628 */
		/* 820CADC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2984);
		/* 820CADC8h case    4:*/		return 0x820CADCC;
		  /* 820CADCCh */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820CADCCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CADCCh case    5:*/		return 0x820CADD0;
		  /* 820CADD0h */ case    6:  		/* li R8, 10 */
		/* 820CADD0h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 820CADD0h case    6:*/		return 0x820CADD4;
		  /* 820CADD4h */ case    7:  		/* stw R9, <#[R3 + 4]> */
		/* 820CADD4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CADD4h case    7:*/		return 0x820CADD8;
		  /* 820CADD8h */ case    8:  		/* stw R10, <#[R3]> */
		/* 820CADD8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CADD8h case    8:*/		return 0x820CADDC;
		  /* 820CADDCh */ case    9:  		/* mr R31, R3 */
		/* 820CADDCh case    9:*/		regs.R31 = regs.R3;
		/* 820CADDCh case    9:*/		return 0x820CADE0;
		  /* 820CADE0h */ case   10:  		/* stw R11, <#[R3 + 12]> */
		/* 820CADE0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CADE0h case   10:*/		return 0x820CADE4;
		  /* 820CADE4h */ case   11:  		/* stw R11, <#[R3 + 16]> */
		/* 820CADE4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CADE4h case   11:*/		return 0x820CADE8;
		  /* 820CADE8h */ case   12:  		/* stw R8, <#[R3 + 20]> */
		/* 820CADE8h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820CADE8h case   12:*/		return 0x820CADEC;
		  /* 820CADECh */ case   13:  		/* stw R11, <#[R3 + 24]> */
		/* 820CADECh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CADECh case   13:*/		return 0x820CADF0;
		  /* 820CADF0h */ case   14:  		/* stw R11, <#[R3 + 28]> */
		/* 820CADF0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CADF0h case   14:*/		return 0x820CADF4;
		  /* 820CADF4h */ case   15:  		/* stw R11, <#[R3 + 32]> */
		/* 820CADF4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CADF4h case   15:*/		return 0x820CADF8;
		  /* 820CADF8h */ case   16:  		/* stw R11, <#[R3 + 36]> */
		/* 820CADF8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CADF8h case   16:*/		return 0x820CADFC;
		  /* 820CADFCh */ case   17:  		/* b 8 */
		/* 820CADFCh case   17:*/		return 0x820CAE04;
		/* 820CADFCh case   17:*/		return 0x820CAE00;
	}
	return 0x820CAE00;
} // Block from 820CADB8h-820CAE00h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CAE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAE00);
		  /* 820CAE00h */ case    0:  		/* li R31, 0 */
		/* 820CAE00h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CAE00h case    0:*/		return 0x820CAE04;
	}
	return 0x820CAE04;
} // Block from 820CAE00h-820CAE04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAE04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAE04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAE04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAE04);
		  /* 820CAE04h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CAE04h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CAE04h case    0:*/		return 0x820CAE08;
		  /* 820CAE08h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CAE08h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CAE14;  }
		/* 820CAE08h case    1:*/		return 0x820CAE0C;
		  /* 820CAE0Ch */ case    2:  		/* li R3, 0 */
		/* 820CAE0Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CAE0Ch case    2:*/		return 0x820CAE10;
		  /* 820CAE10h */ case    3:  		/* b 96 */
		/* 820CAE10h case    3:*/		return 0x820CAE70;
		/* 820CAE10h case    3:*/		return 0x820CAE14;
	}
	return 0x820CAE14;
} // Block from 820CAE04h-820CAE14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CAE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAE14);
		  /* 820CAE14h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CAE14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CAE14h case    0:*/		return 0x820CAE18;
		  /* 820CAE18h */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820CAE18h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CAE18h case    1:*/		return 0x820CAE1C;
		  /* 820CAE1Ch */ case    2:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CAE1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CAE1Ch case    2:*/		return 0x820CAE20;
		  /* 820CAE20h */ case    3:  		/* stw R11, <#[R31 + 20]> */
		/* 820CAE20h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CAE20h case    3:*/		return 0x820CAE24;
		  /* 820CAE24h */ case    4:  		/* lwz R11, <#[R30 + 28]> */
		/* 820CAE24h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CAE24h case    4:*/		return 0x820CAE28;
		  /* 820CAE28h */ case    5:  		/* stw R11, <#[R31 + 28]> */
		/* 820CAE28h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CAE28h case    5:*/		return 0x820CAE2C;
		  /* 820CAE2Ch */ case    6:  		/* lwz R11, <#[R30 + 32]> */
		/* 820CAE2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820CAE2Ch case    6:*/		return 0x820CAE30;
		  /* 820CAE30h */ case    7:  		/* stw R11, <#[R31 + 32]> */
		/* 820CAE30h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820CAE30h case    7:*/		return 0x820CAE34;
		  /* 820CAE34h */ case    8:  		/* lwz R11, <#[R30 + 36]> */
		/* 820CAE34h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820CAE34h case    8:*/		return 0x820CAE38;
		  /* 820CAE38h */ case    9:  		/* stw R11, <#[R31 + 36]> */
		/* 820CAE38h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820CAE38h case    9:*/		return 0x820CAE3C;
		  /* 820CAE3Ch */ case   10:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CAE3Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CAE3Ch case   10:*/		return 0x820CAE40;
		  /* 820CAE40h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820CAE40h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CAE40h case   11:*/		return 0x820CAE44;
		  /* 820CAE44h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 820CAE44h case   12:*/		if ( regs.CR[6].eq ) { return 0x820CAE6C;  }
		/* 820CAE44h case   12:*/		return 0x820CAE48;
		  /* 820CAE48h */ case   13:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CAE48h case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CAE48h case   13:*/		return 0x820CAE4C;
		  /* 820CAE4Ch */ case   14:  		/* lwz R11, <#[R3]> */
		/* 820CAE4Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAE4Ch case   14:*/		return 0x820CAE50;
		  /* 820CAE50h */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CAE50h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CAE50h case   15:*/		return 0x820CAE54;
		  /* 820CAE54h */ case   16:  		/* mtspr CTR, R11 */
		/* 820CAE54h case   16:*/		regs.CTR = regs.R11;
		/* 820CAE54h case   16:*/		return 0x820CAE58;
		  /* 820CAE58h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820CAE58h case   17:*/		if ( 1 ) { regs.LR = 0x820CAE5C; return (uint32)regs.CTR; }
		/* 820CAE58h case   17:*/		return 0x820CAE5C;
		  /* 820CAE5Ch */ case   18:  		/* stw R3, <#[R31 + 24]> */
		/* 820CAE5Ch case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CAE5Ch case   18:*/		return 0x820CAE60;
		  /* 820CAE60h */ case   19:  		/* cmplwi CR0, R3, 0 */
		/* 820CAE60h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CAE60h case   19:*/		return 0x820CAE64;
		  /* 820CAE64h */ case   20:  		/* li R3, 0 */
		/* 820CAE64h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CAE64h case   20:*/		return 0x820CAE68;
		  /* 820CAE68h */ case   21:  		/* bc 12, CR0_EQ, 8 */
		/* 820CAE68h case   21:*/		if ( regs.CR[0].eq ) { return 0x820CAE70;  }
		/* 820CAE68h case   21:*/		return 0x820CAE6C;
	}
	return 0x820CAE6C;
} // Block from 820CAE14h-820CAE6Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CAE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAE6C);
		  /* 820CAE6Ch */ case    0:  		/* mr R3, R31 */
		/* 820CAE6Ch case    0:*/		regs.R3 = regs.R31;
		/* 820CAE6Ch case    0:*/		return 0x820CAE70;
	}
	return 0x820CAE70;
} // Block from 820CAE6Ch-820CAE70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAE70);
		  /* 820CAE70h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CAE70h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CAE70h case    0:*/		return 0x820CAE74;
		  /* 820CAE74h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CAE74h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAE74h case    1:*/		return 0x820CAE78;
		  /* 820CAE78h */ case    2:  		/* mtspr LR, R12 */
		/* 820CAE78h case    2:*/		regs.LR = regs.R12;
		/* 820CAE78h case    2:*/		return 0x820CAE7C;
		  /* 820CAE7Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CAE7Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CAE7Ch case    3:*/		return 0x820CAE80;
		  /* 820CAE80h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CAE80h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CAE80h case    4:*/		return 0x820CAE84;
		  /* 820CAE84h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CAE84h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAE84h case    5:*/		return 0x820CAE88;
	}
	return 0x820CAE88;
} // Block from 820CAE70h-820CAE88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CAE88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAE88);
		  /* 820CAE88h */ case    0:  		/* lis R10, -32255 */
		/* 820CAE88h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CAE88h case    0:*/		return 0x820CAE8C;
		  /* 820CAE8Ch */ case    1:  		/* li R11, 0 */
		/* 820CAE8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CAE8Ch case    1:*/		return 0x820CAE90;
		  /* 820CAE90h */ case    2:  		/* li R9, 10 */
		/* 820CAE90h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 820CAE90h case    2:*/		return 0x820CAE94;
		  /* 820CAE94h */ case    3:  		/* addi R10, R10, 10640 */
		/* 820CAE94h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2990);
		/* 820CAE94h case    3:*/		return 0x820CAE98;
		  /* 820CAE98h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820CAE98h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CAE98h case    4:*/		return 0x820CAE9C;
		  /* 820CAE9Ch */ case    5:  		/* stw R9, <#[R3 + 4]> */
		/* 820CAE9Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CAE9Ch case    5:*/		return 0x820CAEA0;
		  /* 820CAEA0h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820CAEA0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAEA0h case    6:*/		return 0x820CAEA4;
		  /* 820CAEA4h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820CAEA4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CAEA4h case    7:*/		return 0x820CAEA8;
		  /* 820CAEA8h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 820CAEA8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CAEA8h case    8:*/		return 0x820CAEAC;
		  /* 820CAEACh */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 820CAEACh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CAEACh case    9:*/		return 0x820CAEB0;
		  /* 820CAEB0h */ case   10:  		/* stw R11, <#[R3 + 24]> */
		/* 820CAEB0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CAEB0h case   10:*/		return 0x820CAEB4;
		  /* 820CAEB4h */ case   11:  		/* stw R11, <#[R3 + 28]> */
		/* 820CAEB4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CAEB4h case   11:*/		return 0x820CAEB8;
		  /* 820CAEB8h */ case   12:  		/* stw R11, <#[R3 + 32]> */
		/* 820CAEB8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CAEB8h case   12:*/		return 0x820CAEBC;
		  /* 820CAEBCh */ case   13:  		/* stw R11, <#[R3 + 36]> */
		/* 820CAEBCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CAEBCh case   13:*/		return 0x820CAEC0;
		  /* 820CAEC0h */ case   14:  		/* stw R11, <#[R3 + 40]> */
		/* 820CAEC0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CAEC0h case   14:*/		return 0x820CAEC4;
		  /* 820CAEC4h */ case   15:  		/* stw R11, <#[R3 + 44]> */
		/* 820CAEC4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CAEC4h case   15:*/		return 0x820CAEC8;
		  /* 820CAEC8h */ case   16:  		/* stw R11, <#[R3 + 48]> */
		/* 820CAEC8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CAEC8h case   16:*/		return 0x820CAECC;
		  /* 820CAECCh */ case   17:  		/* stw R11, <#[R3 + 52]> */
		/* 820CAECCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 820CAECCh case   17:*/		return 0x820CAED0;
		  /* 820CAED0h */ case   18:  		/* stw R11, <#[R3 + 56]> */
		/* 820CAED0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CAED0h case   18:*/		return 0x820CAED4;
		  /* 820CAED4h */ case   19:  		/* stw R11, <#[R3 + 60]> */
		/* 820CAED4h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CAED4h case   19:*/		return 0x820CAED8;
		  /* 820CAED8h */ case   20:  		/* stw R11, <#[R3 + 64]> */
		/* 820CAED8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CAED8h case   20:*/		return 0x820CAEDC;
		  /* 820CAEDCh */ case   21:  		/* stw R11, <#[R3 + 68]> */
		/* 820CAEDCh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 820CAEDCh case   21:*/		return 0x820CAEE0;
		  /* 820CAEE0h */ case   22:  		/* stw R11, <#[R3 + 72]> */
		/* 820CAEE0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 820CAEE0h case   22:*/		return 0x820CAEE4;
		  /* 820CAEE4h */ case   23:  		/* stw R11, <#[R3 + 76]> */
		/* 820CAEE4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 820CAEE4h case   23:*/		return 0x820CAEE8;
		  /* 820CAEE8h */ case   24:  		/* bclr 20, CR0_LT */
		/* 820CAEE8h case   24:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAEE8h case   24:*/		return 0x820CAEEC;
	}
	return 0x820CAEEC;
} // Block from 820CAE88h-820CAEECh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820CAEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAEEC);
		  /* 820CAEECh */ case    0:  		/* nop */
		/* 820CAEECh case    0:*/		cpu::op::nop();
		/* 820CAEECh case    0:*/		return 0x820CAEF0;
	}
	return 0x820CAEF0;
} // Block from 820CAEECh-820CAEF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAEF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAEF0);
		  /* 820CAEF0h */ case    0:  		/* mfspr R12, LR */
		/* 820CAEF0h case    0:*/		regs.R12 = regs.LR;
		/* 820CAEF0h case    0:*/		return 0x820CAEF4;
		  /* 820CAEF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CAEF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAEF4h case    1:*/		return 0x820CAEF8;
	}
	return 0x820CAEF8;
} // Block from 820CAEF0h-820CAEF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CAEF8h
// Function '??0CNodeAttribute@D3DXShader@@QAA@PAVCNode@1@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAEF8);
		  /* 820CAEF8h */ case    0:  		/* std R30, <#[R1 - 24]> */
		/* 820CAEF8h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CAEF8h case    0:*/		return 0x820CAEFC;
		  /* 820CAEFCh */ case    1:  		/* std R31, <#[R1 - 16]> */
		/* 820CAEFCh case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CAEFCh case    1:*/		return 0x820CAF00;
		  /* 820CAF00h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CAF00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CAF00h case    2:*/		return 0x820CAF04;
		  /* 820CAF04h */ case    3:  		/* mr R30, R3 */
		/* 820CAF04h case    3:*/		regs.R30 = regs.R3;
		/* 820CAF04h case    3:*/		return 0x820CAF08;
		  /* 820CAF08h */ case    4:  		/* mr R31, R4 */
		/* 820CAF08h case    4:*/		regs.R31 = regs.R4;
		/* 820CAF08h case    4:*/		return 0x820CAF0C;
		  /* 820CAF0Ch */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820CAF0Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CAF0Ch case    5:*/		return 0x820CAF10;
		  /* 820CAF10h */ case    6:  		/* bc 12, CR6_EQ, 640 */
		/* 820CAF10h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF10h case    6:*/		return 0x820CAF14;
		  /* 820CAF14h */ case    7:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CAF14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CAF14h case    7:*/		return 0x820CAF18;
		  /* 820CAF18h */ case    8:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CAF18h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CAF18h case    8:*/		return 0x820CAF1C;
		  /* 820CAF1Ch */ case    9:  		/* cmpw CR6, R11, R10 */
		/* 820CAF1Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CAF1Ch case    9:*/		return 0x820CAF20;
		  /* 820CAF20h */ case   10:  		/* bc 4, CR6_EQ, 624 */
		/* 820CAF20h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF20h case   10:*/		return 0x820CAF24;
		  /* 820CAF24h */ case   11:  		/* lwz R11, <#[R3 + 16]> */
		/* 820CAF24h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CAF24h case   11:*/		return 0x820CAF28;
	}
	return 0x820CAF28;
} // Block from 820CAEF8h-820CAF28h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CAF28h
// Function '?IsEqual@CNodeAttribute@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAF28);
		  /* 820CAF28h */ case    0:  		/* lwz R10, <#[R4 + 16]> */
		/* 820CAF28h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820CAF28h case    0:*/		return 0x820CAF2C;
		  /* 820CAF2Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820CAF2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAF2Ch case    1:*/		return 0x820CAF30;
		  /* 820CAF30h */ case    2:  		/* bc 4, CR6_EQ, 608 */
		/* 820CAF30h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF30h case    2:*/		return 0x820CAF34;
		  /* 820CAF34h */ case    3:  		/* lwz R11, <#[R3 + 20]> */
		/* 820CAF34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CAF34h case    3:*/		return 0x820CAF38;
		  /* 820CAF38h */ case    4:  		/* lwz R10, <#[R4 + 20]> */
		/* 820CAF38h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820CAF38h case    4:*/		return 0x820CAF3C;
		  /* 820CAF3Ch */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820CAF3Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAF3Ch case    5:*/		return 0x820CAF40;
		  /* 820CAF40h */ case    6:  		/* bc 4, CR6_EQ, 592 */
		/* 820CAF40h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF40h case    6:*/		return 0x820CAF44;
		  /* 820CAF44h */ case    7:  		/* lwz R11, <#[R3 + 24]> */
		/* 820CAF44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CAF44h case    7:*/		return 0x820CAF48;
		  /* 820CAF48h */ case    8:  		/* lwz R10, <#[R4 + 24]> */
		/* 820CAF48h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820CAF48h case    8:*/		return 0x820CAF4C;
		  /* 820CAF4Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820CAF4Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAF4Ch case    9:*/		return 0x820CAF50;
		  /* 820CAF50h */ case   10:  		/* bc 4, CR6_EQ, 576 */
		/* 820CAF50h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF50h case   10:*/		return 0x820CAF54;
		  /* 820CAF54h */ case   11:  		/* lwz R11, <#[R3 + 28]> */
		/* 820CAF54h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CAF54h case   11:*/		return 0x820CAF58;
		  /* 820CAF58h */ case   12:  		/* lwz R10, <#[R4 + 28]> */
		/* 820CAF58h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 820CAF58h case   12:*/		return 0x820CAF5C;
		  /* 820CAF5Ch */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820CAF5Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAF5Ch case   13:*/		return 0x820CAF60;
		  /* 820CAF60h */ case   14:  		/* bc 4, CR6_EQ, 560 */
		/* 820CAF60h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF60h case   14:*/		return 0x820CAF64;
		  /* 820CAF64h */ case   15:  		/* lwz R11, <#[R3 + 32]> */
		/* 820CAF64h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CAF64h case   15:*/		return 0x820CAF68;
		  /* 820CAF68h */ case   16:  		/* lwz R10, <#[R4 + 32]> */
		/* 820CAF68h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000020) );
		/* 820CAF68h case   16:*/		return 0x820CAF6C;
		  /* 820CAF6Ch */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820CAF6Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAF6Ch case   17:*/		return 0x820CAF70;
		  /* 820CAF70h */ case   18:  		/* bc 4, CR6_EQ, 544 */
		/* 820CAF70h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF70h case   18:*/		return 0x820CAF74;
		  /* 820CAF74h */ case   19:  		/* lwz R11, <#[R3 + 72]> */
		/* 820CAF74h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 820CAF74h case   19:*/		return 0x820CAF78;
		  /* 820CAF78h */ case   20:  		/* lwz R10, <#[R4 + 72]> */
		/* 820CAF78h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000048) );
		/* 820CAF78h case   20:*/		return 0x820CAF7C;
		  /* 820CAF7Ch */ case   21:  		/* cmpw CR6, R11, R10 */
		/* 820CAF7Ch case   21:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CAF7Ch case   21:*/		return 0x820CAF80;
		  /* 820CAF80h */ case   22:  		/* bc 4, CR6_EQ, 528 */
		/* 820CAF80h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF80h case   22:*/		return 0x820CAF84;
		  /* 820CAF84h */ case   23:  		/* lwz R11, <#[R3 + 76]> */
		/* 820CAF84h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 820CAF84h case   23:*/		return 0x820CAF88;
		  /* 820CAF88h */ case   24:  		/* lwz R10, <#[R4 + 76]> */
		/* 820CAF88h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000004C) );
		/* 820CAF88h case   24:*/		return 0x820CAF8C;
		  /* 820CAF8Ch */ case   25:  		/* cmpw CR6, R11, R10 */
		/* 820CAF8Ch case   25:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CAF8Ch case   25:*/		return 0x820CAF90;
		  /* 820CAF90h */ case   26:  		/* bc 4, CR6_EQ, 512 */
		/* 820CAF90h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAF90h case   26:*/		return 0x820CAF94;
		  /* 820CAF94h */ case   27:  		/* lwz R3, <#[R3 + 36]> */
		/* 820CAF94h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000024) );
		/* 820CAF94h case   27:*/		return 0x820CAF98;
		  /* 820CAF98h */ case   28:  		/* lwz R4, <#[R4 + 36]> */
		/* 820CAF98h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000024) );
		/* 820CAF98h case   28:*/		return 0x820CAF9C;
		  /* 820CAF9Ch */ case   29:  		/* cmplwi CR6, R3, 0 */
		/* 820CAF9Ch case   29:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CAF9Ch case   29:*/		return 0x820CAFA0;
		  /* 820CAFA0h */ case   30:  		/* bc 12, CR6_EQ, 24 */
		/* 820CAFA0h case   30:*/		if ( regs.CR[6].eq ) { return 0x820CAFB8;  }
		/* 820CAFA0h case   30:*/		return 0x820CAFA4;
		  /* 820CAFA4h */ case   31:  		/* lwz R11, <#[R3]> */
		/* 820CAFA4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAFA4h case   31:*/		return 0x820CAFA8;
		  /* 820CAFA8h */ case   32:  		/* lwz R11, <#[R11]> */
		/* 820CAFA8h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CAFA8h case   32:*/		return 0x820CAFAC;
		  /* 820CAFACh */ case   33:  		/* mtspr CTR, R11 */
		/* 820CAFACh case   33:*/		regs.CTR = regs.R11;
		/* 820CAFACh case   33:*/		return 0x820CAFB0;
		  /* 820CAFB0h */ case   34:  		/* bcctrl 20, CR0_LT */
		/* 820CAFB0h case   34:*/		if ( 1 ) { regs.LR = 0x820CAFB4; return (uint32)regs.CTR; }
		/* 820CAFB0h case   34:*/		return 0x820CAFB4;
		  /* 820CAFB4h */ case   35:  		/* b 16 */
		/* 820CAFB4h case   35:*/		return 0x820CAFC4;
		/* 820CAFB4h case   35:*/		return 0x820CAFB8;
	}
	return 0x820CAFB8;
} // Block from 820CAF28h-820CAFB8h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820CAFB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAFB8);
		  /* 820CAFB8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CAFB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CAFB8h case    0:*/		return 0x820CAFBC;
		  /* 820CAFBCh */ case    1:  		/* cntlzw R11, R11 */
		/* 820CAFBCh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CAFBCh case    1:*/		return 0x820CAFC0;
		  /* 820CAFC0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CAFC0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CAFC0h case    2:*/		return 0x820CAFC4;
	}
	return 0x820CAFC4;
} // Block from 820CAFB8h-820CAFC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CAFC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAFC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAFC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAFC4);
		  /* 820CAFC4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CAFC4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CAFC4h case    0:*/		return 0x820CAFC8;
		  /* 820CAFC8h */ case    1:  		/* bc 12, CR6_EQ, 456 */
		/* 820CAFC8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CAFC8h case    1:*/		return 0x820CAFCC;
		  /* 820CAFCCh */ case    2:  		/* lwz R3, <#[R30 + 40]> */
		/* 820CAFCCh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000028) );
		/* 820CAFCCh case    2:*/		return 0x820CAFD0;
		  /* 820CAFD0h */ case    3:  		/* lwz R4, <#[R31 + 40]> */
		/* 820CAFD0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000028) );
		/* 820CAFD0h case    3:*/		return 0x820CAFD4;
		  /* 820CAFD4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CAFD4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CAFD4h case    4:*/		return 0x820CAFD8;
		  /* 820CAFD8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CAFD8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CAFF0;  }
		/* 820CAFD8h case    5:*/		return 0x820CAFDC;
		  /* 820CAFDCh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CAFDCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAFDCh case    6:*/		return 0x820CAFE0;
		  /* 820CAFE0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CAFE0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CAFE0h case    7:*/		return 0x820CAFE4;
		  /* 820CAFE4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CAFE4h case    8:*/		regs.CTR = regs.R11;
		/* 820CAFE4h case    8:*/		return 0x820CAFE8;
		  /* 820CAFE8h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CAFE8h case    9:*/		if ( 1 ) { regs.LR = 0x820CAFEC; return (uint32)regs.CTR; }
		/* 820CAFE8h case    9:*/		return 0x820CAFEC;
		  /* 820CAFECh */ case   10:  		/* b 16 */
		/* 820CAFECh case   10:*/		return 0x820CAFFC;
		/* 820CAFECh case   10:*/		return 0x820CAFF0;
	}
	return 0x820CAFF0;
} // Block from 820CAFC4h-820CAFF0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CAFF0h
// Function '?Copy@CNodeAttribute@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAFF0);
		  /* 820CAFF0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CAFF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CAFF0h case    0:*/		return 0x820CAFF4;
		  /* 820CAFF4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CAFF4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CAFF4h case    1:*/		return 0x820CAFF8;
		  /* 820CAFF8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CAFF8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CAFF8h case    2:*/		return 0x820CAFFC;
	}
	return 0x820CAFFC;
} // Block from 820CAFF0h-820CAFFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CAFFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAFFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAFFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAFFC);
		  /* 820CAFFCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CAFFCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CAFFCh case    0:*/		return 0x820CB000;
		  /* 820CB000h */ case    1:  		/* bc 12, CR6_EQ, 400 */
		/* 820CB000h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CB000h case    1:*/		return 0x820CB004;
		  /* 820CB004h */ case    2:  		/* lwz R3, <#[R30 + 44]> */
		/* 820CB004h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 820CB004h case    2:*/		return 0x820CB008;
		  /* 820CB008h */ case    3:  		/* lwz R4, <#[R31 + 44]> */
		/* 820CB008h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000002C) );
		/* 820CB008h case    3:*/		return 0x820CB00C;
		  /* 820CB00Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB00Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB00Ch case    4:*/		return 0x820CB010;
		  /* 820CB010h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB010h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB028;  }
		/* 820CB010h case    5:*/		return 0x820CB014;
		  /* 820CB014h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB014h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB014h case    6:*/		return 0x820CB018;
		  /* 820CB018h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB018h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB018h case    7:*/		return 0x820CB01C;
		  /* 820CB01Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB01Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CB01Ch case    8:*/		return 0x820CB020;
		  /* 820CB020h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB020h case    9:*/		if ( 1 ) { regs.LR = 0x820CB024; return (uint32)regs.CTR; }
		/* 820CB020h case    9:*/		return 0x820CB024;
		  /* 820CB024h */ case   10:  		/* b 16 */
		/* 820CB024h case   10:*/		return 0x820CB034;
		/* 820CB024h case   10:*/		return 0x820CB028;
	}
	return 0x820CB028;
} // Block from 820CAFFCh-820CB028h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB028);
		  /* 820CB028h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB028h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB028h case    0:*/		return 0x820CB02C;
		  /* 820CB02Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB02Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB02Ch case    1:*/		return 0x820CB030;
		  /* 820CB030h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB030h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB030h case    2:*/		return 0x820CB034;
	}
	return 0x820CB034;
} // Block from 820CB028h-820CB034h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB034);
		  /* 820CB034h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB034h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB034h case    0:*/		return 0x820CB038;
		  /* 820CB038h */ case    1:  		/* bc 12, CR6_EQ, 344 */
		/* 820CB038h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CB038h case    1:*/		return 0x820CB03C;
		  /* 820CB03Ch */ case    2:  		/* lwz R3, <#[R30 + 48]> */
		/* 820CB03Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 820CB03Ch case    2:*/		return 0x820CB040;
		  /* 820CB040h */ case    3:  		/* lwz R4, <#[R31 + 48]> */
		/* 820CB040h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000030) );
		/* 820CB040h case    3:*/		return 0x820CB044;
		  /* 820CB044h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB044h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB044h case    4:*/		return 0x820CB048;
		  /* 820CB048h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB048h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB060;  }
		/* 820CB048h case    5:*/		return 0x820CB04C;
		  /* 820CB04Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB04Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB04Ch case    6:*/		return 0x820CB050;
		  /* 820CB050h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB050h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB050h case    7:*/		return 0x820CB054;
		  /* 820CB054h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB054h case    8:*/		regs.CTR = regs.R11;
		/* 820CB054h case    8:*/		return 0x820CB058;
		  /* 820CB058h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB058h case    9:*/		if ( 1 ) { regs.LR = 0x820CB05C; return (uint32)regs.CTR; }
		/* 820CB058h case    9:*/		return 0x820CB05C;
		  /* 820CB05Ch */ case   10:  		/* b 16 */
		/* 820CB05Ch case   10:*/		return 0x820CB06C;
		/* 820CB05Ch case   10:*/		return 0x820CB060;
	}
	return 0x820CB060;
} // Block from 820CB034h-820CB060h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB060);
		  /* 820CB060h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB060h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB060h case    0:*/		return 0x820CB064;
		  /* 820CB064h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB064h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB064h case    1:*/		return 0x820CB068;
		  /* 820CB068h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB068h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB068h case    2:*/		return 0x820CB06C;
	}
	return 0x820CB06C;
} // Block from 820CB060h-820CB06Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB06Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB06C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB06C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB06C);
		  /* 820CB06Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB06Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB06Ch case    0:*/		return 0x820CB070;
		  /* 820CB070h */ case    1:  		/* bc 12, CR6_EQ, 288 */
		/* 820CB070h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CB070h case    1:*/		return 0x820CB074;
		  /* 820CB074h */ case    2:  		/* lwz R3, <#[R30 + 52]> */
		/* 820CB074h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 820CB074h case    2:*/		return 0x820CB078;
		  /* 820CB078h */ case    3:  		/* lwz R4, <#[R31 + 52]> */
		/* 820CB078h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000034) );
		/* 820CB078h case    3:*/		return 0x820CB07C;
		  /* 820CB07Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB07Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB07Ch case    4:*/		return 0x820CB080;
		  /* 820CB080h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB080h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB098;  }
		/* 820CB080h case    5:*/		return 0x820CB084;
		  /* 820CB084h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB084h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB084h case    6:*/		return 0x820CB088;
		  /* 820CB088h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB088h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB088h case    7:*/		return 0x820CB08C;
		  /* 820CB08Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB08Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CB08Ch case    8:*/		return 0x820CB090;
		  /* 820CB090h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB090h case    9:*/		if ( 1 ) { regs.LR = 0x820CB094; return (uint32)regs.CTR; }
		/* 820CB090h case    9:*/		return 0x820CB094;
		  /* 820CB094h */ case   10:  		/* b 16 */
		/* 820CB094h case   10:*/		return 0x820CB0A4;
		/* 820CB094h case   10:*/		return 0x820CB098;
	}
	return 0x820CB098;
} // Block from 820CB06Ch-820CB098h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB098);
		  /* 820CB098h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB098h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB098h case    0:*/		return 0x820CB09C;
		  /* 820CB09Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB09Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB09Ch case    1:*/		return 0x820CB0A0;
		  /* 820CB0A0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB0A0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB0A0h case    2:*/		return 0x820CB0A4;
	}
	return 0x820CB0A4;
} // Block from 820CB098h-820CB0A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB0A4);
		  /* 820CB0A4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB0A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB0A4h case    0:*/		return 0x820CB0A8;
		  /* 820CB0A8h */ case    1:  		/* bc 12, CR6_EQ, 232 */
		/* 820CB0A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CB0A8h case    1:*/		return 0x820CB0AC;
		  /* 820CB0ACh */ case    2:  		/* lwz R3, <#[R30 + 56]> */
		/* 820CB0ACh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 820CB0ACh case    2:*/		return 0x820CB0B0;
		  /* 820CB0B0h */ case    3:  		/* lwz R4, <#[R31 + 56]> */
		/* 820CB0B0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 820CB0B0h case    3:*/		return 0x820CB0B4;
		  /* 820CB0B4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB0B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB0B4h case    4:*/		return 0x820CB0B8;
		  /* 820CB0B8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB0B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB0D0;  }
		/* 820CB0B8h case    5:*/		return 0x820CB0BC;
		  /* 820CB0BCh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB0BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB0BCh case    6:*/		return 0x820CB0C0;
		  /* 820CB0C0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB0C0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB0C0h case    7:*/		return 0x820CB0C4;
		  /* 820CB0C4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB0C4h case    8:*/		regs.CTR = regs.R11;
		/* 820CB0C4h case    8:*/		return 0x820CB0C8;
		  /* 820CB0C8h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB0C8h case    9:*/		if ( 1 ) { regs.LR = 0x820CB0CC; return (uint32)regs.CTR; }
		/* 820CB0C8h case    9:*/		return 0x820CB0CC;
		  /* 820CB0CCh */ case   10:  		/* b 16 */
		/* 820CB0CCh case   10:*/		return 0x820CB0DC;
		/* 820CB0CCh case   10:*/		return 0x820CB0D0;
	}
	return 0x820CB0D0;
} // Block from 820CB0A4h-820CB0D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB0D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB0D0);
		  /* 820CB0D0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB0D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB0D0h case    0:*/		return 0x820CB0D4;
		  /* 820CB0D4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB0D4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB0D4h case    1:*/		return 0x820CB0D8;
		  /* 820CB0D8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB0D8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB0D8h case    2:*/		return 0x820CB0DC;
	}
	return 0x820CB0DC;
} // Block from 820CB0D0h-820CB0DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB0DC);
		  /* 820CB0DCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB0DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB0DCh case    0:*/		return 0x820CB0E0;
	}
	return 0x820CB0E0;
} // Block from 820CB0DCh-820CB0E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB0E0h
// Function '??0CNodeCaseCondition@D3DXShader@@QAA@PAVCNode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB0E0);
		  /* 820CB0E0h */ case    0:  		/* bc 12, CR6_EQ, 176 */
		/* 820CB0E0h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CB0E0h case    0:*/		return 0x820CB0E4;
		  /* 820CB0E4h */ case    1:  		/* lwz R3, <#[R30 + 60]> */
		/* 820CB0E4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000003C) );
		/* 820CB0E4h case    1:*/		return 0x820CB0E8;
		  /* 820CB0E8h */ case    2:  		/* lwz R4, <#[R31 + 60]> */
		/* 820CB0E8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CB0E8h case    2:*/		return 0x820CB0EC;
		  /* 820CB0ECh */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820CB0ECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB0ECh case    3:*/		return 0x820CB0F0;
		  /* 820CB0F0h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB0F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CB108;  }
		/* 820CB0F0h case    4:*/		return 0x820CB0F4;
		  /* 820CB0F4h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820CB0F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB0F4h case    5:*/		return 0x820CB0F8;
		  /* 820CB0F8h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820CB0F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB0F8h case    6:*/		return 0x820CB0FC;
		  /* 820CB0FCh */ case    7:  		/* mtspr CTR, R11 */
		/* 820CB0FCh case    7:*/		regs.CTR = regs.R11;
		/* 820CB0FCh case    7:*/		return 0x820CB100;
		  /* 820CB100h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820CB100h case    8:*/		if ( 1 ) { regs.LR = 0x820CB104; return (uint32)regs.CTR; }
		/* 820CB100h case    8:*/		return 0x820CB104;
		  /* 820CB104h */ case    9:  		/* b 16 */
		/* 820CB104h case    9:*/		return 0x820CB114;
		/* 820CB104h case    9:*/		return 0x820CB108;
	}
	return 0x820CB108;
} // Block from 820CB0E0h-820CB108h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CB108h
// Function '?IsEqual@CNodeCaseCondition@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB108);
		  /* 820CB108h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB108h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB108h case    0:*/		return 0x820CB10C;
		  /* 820CB10Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB10Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB10Ch case    1:*/		return 0x820CB110;
		  /* 820CB110h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB110h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB110h case    2:*/		return 0x820CB114;
	}
	return 0x820CB114;
} // Block from 820CB108h-820CB114h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB114);
		  /* 820CB114h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB114h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB114h case    0:*/		return 0x820CB118;
		  /* 820CB118h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820CB118h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CB118h case    1:*/		return 0x820CB11C;
		  /* 820CB11Ch */ case    2:  		/* lwz R3, <#[R30 + 68]> */
		/* 820CB11Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000044) );
		/* 820CB11Ch case    2:*/		return 0x820CB120;
		  /* 820CB120h */ case    3:  		/* lwz R4, <#[R31 + 68]> */
		/* 820CB120h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000044) );
		/* 820CB120h case    3:*/		return 0x820CB124;
		  /* 820CB124h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB124h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB124h case    4:*/		return 0x820CB128;
		  /* 820CB128h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB128h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB140;  }
		/* 820CB128h case    5:*/		return 0x820CB12C;
		  /* 820CB12Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB12Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB12Ch case    6:*/		return 0x820CB130;
		  /* 820CB130h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB130h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB130h case    7:*/		return 0x820CB134;
		  /* 820CB134h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB134h case    8:*/		regs.CTR = regs.R11;
		/* 820CB134h case    8:*/		return 0x820CB138;
		  /* 820CB138h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB138h case    9:*/		if ( 1 ) { regs.LR = 0x820CB13C; return (uint32)regs.CTR; }
		/* 820CB138h case    9:*/		return 0x820CB13C;
		  /* 820CB13Ch */ case   10:  		/* b 16 */
		/* 820CB13Ch case   10:*/		return 0x820CB14C;
		/* 820CB13Ch case   10:*/		return 0x820CB140;
	}
	return 0x820CB140;
} // Block from 820CB114h-820CB140h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB140);
		  /* 820CB140h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB140h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB140h case    0:*/		return 0x820CB144;
		  /* 820CB144h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB144h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB144h case    1:*/		return 0x820CB148;
		  /* 820CB148h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB148h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB148h case    2:*/		return 0x820CB14C;
	}
	return 0x820CB14C;
} // Block from 820CB140h-820CB14Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB14C);
		  /* 820CB14Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB14Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB14Ch case    0:*/		return 0x820CB150;
		  /* 820CB150h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CB150h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB190;  }
		/* 820CB150h case    1:*/		return 0x820CB154;
		  /* 820CB154h */ case    2:  		/* lwz R3, <#[R30 + 64]> */
		/* 820CB154h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000040) );
		/* 820CB154h case    2:*/		return 0x820CB158;
		  /* 820CB158h */ case    3:  		/* lwz R4, <#[R31 + 64]> */
		/* 820CB158h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000040) );
		/* 820CB158h case    3:*/		return 0x820CB15C;
		  /* 820CB15Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB15Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB15Ch case    4:*/		return 0x820CB160;
		  /* 820CB160h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB160h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB178;  }
		/* 820CB160h case    5:*/		return 0x820CB164;
		  /* 820CB164h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB164h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB164h case    6:*/		return 0x820CB168;
		  /* 820CB168h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB168h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB168h case    7:*/		return 0x820CB16C;
		  /* 820CB16Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB16Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CB16Ch case    8:*/		return 0x820CB170;
		  /* 820CB170h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB170h case    9:*/		if ( 1 ) { regs.LR = 0x820CB174; return (uint32)regs.CTR; }
		/* 820CB170h case    9:*/		return 0x820CB174;
		  /* 820CB174h */ case   10:  		/* b 16 */
		/* 820CB174h case   10:*/		return 0x820CB184;
		/* 820CB174h case   10:*/		return 0x820CB178;
	}
	return 0x820CB178;
} // Block from 820CB14Ch-820CB178h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB178);
		  /* 820CB178h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB178h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB178h case    0:*/		return 0x820CB17C;
		  /* 820CB17Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB17Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB17Ch case    1:*/		return 0x820CB180;
	}
	return 0x820CB180;
} // Block from 820CB178h-820CB180h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CB180h
// Function '?Copy@CNodeCaseCondition@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB180);
		  /* 820CB180h */ case    0:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB180h case    0:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB180h case    0:*/		return 0x820CB184;
	}
	return 0x820CB184;
} // Block from 820CB180h-820CB184h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB184);
		  /* 820CB184h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB184h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB184h case    0:*/		return 0x820CB188;
		  /* 820CB188h */ case    1:  		/* li R3, 1 */
		/* 820CB188h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CB188h case    1:*/		return 0x820CB18C;
		  /* 820CB18Ch */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CB18Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CB194;  }
		/* 820CB18Ch case    2:*/		return 0x820CB190;
	}
	return 0x820CB190;
} // Block from 820CB184h-820CB190h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB190);
		  /* 820CB190h */ case    0:  		/* li R3, 0 */
		/* 820CB190h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CB190h case    0:*/		return 0x820CB194;
	}
	return 0x820CB194;
} // Block from 820CB190h-820CB194h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB194);
		  /* 820CB194h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CB194h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CB194h case    0:*/		return 0x820CB198;
		  /* 820CB198h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CB198h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CB198h case    1:*/		return 0x820CB19C;
		  /* 820CB19Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CB19Ch case    2:*/		regs.LR = regs.R12;
		/* 820CB19Ch case    2:*/		return 0x820CB1A0;
		  /* 820CB1A0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CB1A0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CB1A0h case    3:*/		return 0x820CB1A4;
		  /* 820CB1A4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CB1A4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CB1A4h case    4:*/		return 0x820CB1A8;
		  /* 820CB1A8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CB1A8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CB1A8h case    5:*/		return 0x820CB1AC;
	}
	return 0x820CB1AC;
} // Block from 820CB194h-820CB1ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CB1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB1AC);
		  /* 820CB1ACh */ case    0:  		/* nop */
		/* 820CB1ACh case    0:*/		cpu::op::nop();
		/* 820CB1ACh case    0:*/		return 0x820CB1B0;
	}
	return 0x820CB1B0;
} // Block from 820CB1ACh-820CB1B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB1B0);
		  /* 820CB1B0h */ case    0:  		/* mfspr R12, LR */
		/* 820CB1B0h case    0:*/		regs.R12 = regs.LR;
		/* 820CB1B0h case    0:*/		return 0x820CB1B4;
		  /* 820CB1B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CB1B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CB1B4h case    1:*/		return 0x820CB1B8;
		  /* 820CB1B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CB1B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CB1B8h case    2:*/		return 0x820CB1BC;
		  /* 820CB1BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CB1BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CB1BCh case    3:*/		return 0x820CB1C0;
		  /* 820CB1C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CB1C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CB1C0h case    4:*/		return 0x820CB1C4;
		  /* 820CB1C4h */ case    5:  		/* mr R31, R3 */
		/* 820CB1C4h case    5:*/		regs.R31 = regs.R3;
		/* 820CB1C4h case    5:*/		return 0x820CB1C8;
		  /* 820CB1C8h */ case    6:  		/* bl 7784 */
		/* 820CB1C8h case    6:*/		regs.LR = 0x820CB1CC; return 0x820CD030;
		/* 820CB1C8h case    6:*/		return 0x820CB1CC;
		  /* 820CB1CCh */ case    7:  		/* li R5, 16 */
		/* 820CB1CCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CB1CCh case    7:*/		return 0x820CB1D0;
		  /* 820CB1D0h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CB1D0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB1D0h case    8:*/		return 0x820CB1D4;
		  /* 820CB1D4h */ case    9:  		/* li R4, 80 */
		/* 820CB1D4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x50);
		/* 820CB1D4h case    9:*/		return 0x820CB1D8;
		  /* 820CB1D8h */ case   10:  		/* bl -8440 */
		/* 820CB1D8h case   10:*/		regs.LR = 0x820CB1DC; return 0x820C90E0;
		/* 820CB1D8h case   10:*/		return 0x820CB1DC;
		  /* 820CB1DCh */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CB1DCh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB1DCh case   11:*/		return 0x820CB1E0;
		  /* 820CB1E0h */ case   12:  		/* bc 12, CR0_EQ, 108 */
		/* 820CB1E0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CB24C;  }
		/* 820CB1E0h case   12:*/		return 0x820CB1E4;
		  /* 820CB1E4h */ case   13:  		/* lis R10, -32255 */
		/* 820CB1E4h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CB1E4h case   13:*/		return 0x820CB1E8;
		  /* 820CB1E8h */ case   14:  		/* li R11, 0 */
		/* 820CB1E8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CB1E8h case   14:*/		return 0x820CB1EC;
		  /* 820CB1ECh */ case   15:  		/* li R9, 10 */
		/* 820CB1ECh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0xA);
		/* 820CB1ECh case   15:*/		return 0x820CB1F0;
		  /* 820CB1F0h */ case   16:  		/* addi R10, R10, 10640 */
		/* 820CB1F0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2990);
		/* 820CB1F0h case   16:*/		return 0x820CB1F4;
		  /* 820CB1F4h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CB1F4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CB1F4h case   17:*/		return 0x820CB1F8;
		  /* 820CB1F8h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820CB1F8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CB1F8h case   18:*/		return 0x820CB1FC;
		  /* 820CB1FCh */ case   19:  		/* mr R30, R3 */
		/* 820CB1FCh case   19:*/		regs.R30 = regs.R3;
		/* 820CB1FCh case   19:*/		return 0x820CB200;
		  /* 820CB200h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CB200h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB200h case   20:*/		return 0x820CB204;
		  /* 820CB204h */ case   21:  		/* stw R11, <#[R3 + 12]> */
		/* 820CB204h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CB204h case   21:*/		return 0x820CB208;
		  /* 820CB208h */ case   22:  		/* stw R11, <#[R3 + 16]> */
		/* 820CB208h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CB208h case   22:*/		return 0x820CB20C;
		  /* 820CB20Ch */ case   23:  		/* stw R11, <#[R3 + 20]> */
		/* 820CB20Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CB20Ch case   23:*/		return 0x820CB210;
		  /* 820CB210h */ case   24:  		/* stw R11, <#[R3 + 24]> */
		/* 820CB210h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CB210h case   24:*/		return 0x820CB214;
		  /* 820CB214h */ case   25:  		/* stw R11, <#[R3 + 28]> */
		/* 820CB214h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CB214h case   25:*/		return 0x820CB218;
		  /* 820CB218h */ case   26:  		/* stw R11, <#[R3 + 32]> */
		/* 820CB218h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CB218h case   26:*/		return 0x820CB21C;
		  /* 820CB21Ch */ case   27:  		/* stw R11, <#[R3 + 36]> */
		/* 820CB21Ch case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CB21Ch case   27:*/		return 0x820CB220;
		  /* 820CB220h */ case   28:  		/* stw R11, <#[R3 + 40]> */
		/* 820CB220h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CB220h case   28:*/		return 0x820CB224;
		  /* 820CB224h */ case   29:  		/* stw R11, <#[R3 + 44]> */
		/* 820CB224h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CB224h case   29:*/		return 0x820CB228;
		  /* 820CB228h */ case   30:  		/* stw R11, <#[R3 + 48]> */
		/* 820CB228h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CB228h case   30:*/		return 0x820CB22C;
		  /* 820CB22Ch */ case   31:  		/* stw R11, <#[R3 + 52]> */
		/* 820CB22Ch case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 820CB22Ch case   31:*/		return 0x820CB230;
		  /* 820CB230h */ case   32:  		/* stw R11, <#[R3 + 56]> */
		/* 820CB230h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CB230h case   32:*/		return 0x820CB234;
		  /* 820CB234h */ case   33:  		/* stw R11, <#[R3 + 60]> */
		/* 820CB234h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CB234h case   33:*/		return 0x820CB238;
		  /* 820CB238h */ case   34:  		/* stw R11, <#[R3 + 64]> */
		/* 820CB238h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CB238h case   34:*/		return 0x820CB23C;
		  /* 820CB23Ch */ case   35:  		/* stw R11, <#[R3 + 68]> */
		/* 820CB23Ch case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 820CB23Ch case   35:*/		return 0x820CB240;
	}
	return 0x820CB240;
} // Block from 820CB1B0h-820CB240h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820CB240h
// Function '??0CNodeUsage@D3DXShader@@QAA@KPAVCNode@1@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB240);
		  /* 820CB240h */ case    0:  		/* stw R11, <#[R3 + 72]> */
		/* 820CB240h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 820CB240h case    0:*/		return 0x820CB244;
		  /* 820CB244h */ case    1:  		/* stw R11, <#[R3 + 76]> */
		/* 820CB244h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 820CB244h case    1:*/		return 0x820CB248;
		  /* 820CB248h */ case    2:  		/* b 8 */
		/* 820CB248h case    2:*/		return 0x820CB250;
		/* 820CB248h case    2:*/		return 0x820CB24C;
	}
	return 0x820CB24C;
} // Block from 820CB240h-820CB24Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB24C);
		  /* 820CB24Ch */ case    0:  		/* li R30, 0 */
		/* 820CB24Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CB24Ch case    0:*/		return 0x820CB250;
	}
	return 0x820CB250;
} // Block from 820CB24Ch-820CB250h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB250);
		  /* 820CB250h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820CB250h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CB250h case    0:*/		return 0x820CB254;
		  /* 820CB254h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CB254h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CB260;  }
		/* 820CB254h case    1:*/		return 0x820CB258;
		  /* 820CB258h */ case    2:  		/* li R3, 0 */
		/* 820CB258h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CB258h case    2:*/		return 0x820CB25C;
		  /* 820CB25Ch */ case    3:  		/* b 460 */
		/* 820CB25Ch case    3:*/		return 0x820CB428;
		/* 820CB25Ch case    3:*/		return 0x820CB260;
	}
	return 0x820CB260;
} // Block from 820CB250h-820CB260h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CB260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB260);
		  /* 820CB260h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820CB260h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CB260h case    0:*/		return 0x820CB264;
		  /* 820CB264h */ case    1:  		/* stw R11, <#[R30 + 16]> */
		/* 820CB264h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CB264h case    1:*/		return 0x820CB268;
		  /* 820CB268h */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 820CB268h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CB268h case    2:*/		return 0x820CB26C;
		  /* 820CB26Ch */ case    3:  		/* stw R11, <#[R30 + 20]> */
		/* 820CB26Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CB26Ch case    3:*/		return 0x820CB270;
		  /* 820CB270h */ case    4:  		/* lwz R11, <#[R31 + 24]> */
		/* 820CB270h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CB270h case    4:*/		return 0x820CB274;
		  /* 820CB274h */ case    5:  		/* stw R11, <#[R30 + 24]> */
		/* 820CB274h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CB274h case    5:*/		return 0x820CB278;
	}
	return 0x820CB278;
} // Block from 820CB260h-820CB278h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CB278h
// Function '?IsEqual@CNodeUsage@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB278);
		  /* 820CB278h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 820CB278h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CB278h case    0:*/		return 0x820CB27C;
		  /* 820CB27Ch */ case    1:  		/* stw R11, <#[R30 + 28]> */
		/* 820CB27Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CB27Ch case    1:*/		return 0x820CB280;
		  /* 820CB280h */ case    2:  		/* lwz R11, <#[R31 + 32]> */
		/* 820CB280h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820CB280h case    2:*/		return 0x820CB284;
		  /* 820CB284h */ case    3:  		/* stw R11, <#[R30 + 32]> */
		/* 820CB284h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820CB284h case    3:*/		return 0x820CB288;
		  /* 820CB288h */ case    4:  		/* lwz R11, <#[R31 + 72]> */
		/* 820CB288h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820CB288h case    4:*/		return 0x820CB28C;
		  /* 820CB28Ch */ case    5:  		/* stw R11, <#[R30 + 72]> */
		/* 820CB28Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 820CB28Ch case    5:*/		return 0x820CB290;
		  /* 820CB290h */ case    6:  		/* lwz R11, <#[R31 + 76]> */
		/* 820CB290h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820CB290h case    6:*/		return 0x820CB294;
		  /* 820CB294h */ case    7:  		/* stw R11, <#[R30 + 76]> */
		/* 820CB294h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 820CB294h case    7:*/		return 0x820CB298;
		  /* 820CB298h */ case    8:  		/* lwz R11, <#[R31 + 36]> */
		/* 820CB298h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820CB298h case    8:*/		return 0x820CB29C;
		  /* 820CB29Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820CB29Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB29Ch case    9:*/		return 0x820CB2A0;
		  /* 820CB2A0h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB2A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820CB2C4;  }
		/* 820CB2A0h case   10:*/		return 0x820CB2A4;
		  /* 820CB2A4h */ case   11:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB2A4h case   11:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB2A4h case   11:*/		return 0x820CB2A8;
		  /* 820CB2A8h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 820CB2A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB2A8h case   12:*/		return 0x820CB2AC;
		  /* 820CB2ACh */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB2ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB2ACh case   13:*/		return 0x820CB2B0;
		  /* 820CB2B0h */ case   14:  		/* mtspr CTR, R11 */
		/* 820CB2B0h case   14:*/		regs.CTR = regs.R11;
		/* 820CB2B0h case   14:*/		return 0x820CB2B4;
		  /* 820CB2B4h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 820CB2B4h case   15:*/		if ( 1 ) { regs.LR = 0x820CB2B8; return (uint32)regs.CTR; }
		/* 820CB2B4h case   15:*/		return 0x820CB2B8;
		  /* 820CB2B8h */ case   16:  		/* stw R3, <#[R30 + 36]> */
		/* 820CB2B8h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000024) );
		/* 820CB2B8h case   16:*/		return 0x820CB2BC;
		  /* 820CB2BCh */ case   17:  		/* cmplwi CR0, R3, 0 */
		/* 820CB2BCh case   17:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB2BCh case   17:*/		return 0x820CB2C0;
		  /* 820CB2C0h */ case   18:  		/* bc 12, CR0_EQ, -104 */
		/* 820CB2C0h case   18:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB2C0h case   18:*/		return 0x820CB2C4;
	}
	return 0x820CB2C4;
} // Block from 820CB278h-820CB2C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CB2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB2C4);
		  /* 820CB2C4h */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 820CB2C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820CB2C4h case    0:*/		return 0x820CB2C8;
		  /* 820CB2C8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB2C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB2C8h case    1:*/		return 0x820CB2CC;
		  /* 820CB2CCh */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB2CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB2F0;  }
		/* 820CB2CCh case    2:*/		return 0x820CB2D0;
		  /* 820CB2D0h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB2D0h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB2D0h case    3:*/		return 0x820CB2D4;
		  /* 820CB2D4h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB2D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB2D4h case    4:*/		return 0x820CB2D8;
		  /* 820CB2D8h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB2D8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB2D8h case    5:*/		return 0x820CB2DC;
		  /* 820CB2DCh */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB2DCh case    6:*/		regs.CTR = regs.R11;
		/* 820CB2DCh case    6:*/		return 0x820CB2E0;
		  /* 820CB2E0h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB2E0h case    7:*/		if ( 1 ) { regs.LR = 0x820CB2E4; return (uint32)regs.CTR; }
		/* 820CB2E0h case    7:*/		return 0x820CB2E4;
		  /* 820CB2E4h */ case    8:  		/* stw R3, <#[R30 + 40]> */
		/* 820CB2E4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000028) );
		/* 820CB2E4h case    8:*/		return 0x820CB2E8;
		  /* 820CB2E8h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB2E8h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB2E8h case    9:*/		return 0x820CB2EC;
		  /* 820CB2ECh */ case   10:  		/* bc 12, CR0_EQ, -148 */
		/* 820CB2ECh case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB2ECh case   10:*/		return 0x820CB2F0;
	}
	return 0x820CB2F0;
} // Block from 820CB2C4h-820CB2F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB2F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB2F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB2F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB2F0);
		  /* 820CB2F0h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 820CB2F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820CB2F0h case    0:*/		return 0x820CB2F4;
		  /* 820CB2F4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB2F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB2F4h case    1:*/		return 0x820CB2F8;
		  /* 820CB2F8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB2F8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB31C;  }
		/* 820CB2F8h case    2:*/		return 0x820CB2FC;
		  /* 820CB2FCh */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB2FCh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB2FCh case    3:*/		return 0x820CB300;
		  /* 820CB300h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB300h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB300h case    4:*/		return 0x820CB304;
		  /* 820CB304h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB304h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB304h case    5:*/		return 0x820CB308;
		  /* 820CB308h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB308h case    6:*/		regs.CTR = regs.R11;
		/* 820CB308h case    6:*/		return 0x820CB30C;
		  /* 820CB30Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB30Ch case    7:*/		if ( 1 ) { regs.LR = 0x820CB310; return (uint32)regs.CTR; }
		/* 820CB30Ch case    7:*/		return 0x820CB310;
		  /* 820CB310h */ case    8:  		/* stw R3, <#[R30 + 44]> */
		/* 820CB310h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 820CB310h case    8:*/		return 0x820CB314;
		  /* 820CB314h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB314h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB314h case    9:*/		return 0x820CB318;
		  /* 820CB318h */ case   10:  		/* bc 12, CR0_EQ, -192 */
		/* 820CB318h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB318h case   10:*/		return 0x820CB31C;
	}
	return 0x820CB31C;
} // Block from 820CB2F0h-820CB31Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB31Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB31C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB31C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB31C);
		  /* 820CB31Ch */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 820CB31Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820CB31Ch case    0:*/		return 0x820CB320;
		  /* 820CB320h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB320h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB320h case    1:*/		return 0x820CB324;
		  /* 820CB324h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB324h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB348;  }
		/* 820CB324h case    2:*/		return 0x820CB328;
		  /* 820CB328h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB328h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB328h case    3:*/		return 0x820CB32C;
		  /* 820CB32Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB32Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB32Ch case    4:*/		return 0x820CB330;
		  /* 820CB330h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB330h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB330h case    5:*/		return 0x820CB334;
		  /* 820CB334h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB334h case    6:*/		regs.CTR = regs.R11;
		/* 820CB334h case    6:*/		return 0x820CB338;
		  /* 820CB338h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB338h case    7:*/		if ( 1 ) { regs.LR = 0x820CB33C; return (uint32)regs.CTR; }
		/* 820CB338h case    7:*/		return 0x820CB33C;
		  /* 820CB33Ch */ case    8:  		/* stw R3, <#[R30 + 48]> */
		/* 820CB33Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 820CB33Ch case    8:*/		return 0x820CB340;
		  /* 820CB340h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB340h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB340h case    9:*/		return 0x820CB344;
		  /* 820CB344h */ case   10:  		/* bc 12, CR0_EQ, -236 */
		/* 820CB344h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB344h case   10:*/		return 0x820CB348;
	}
	return 0x820CB348;
} // Block from 820CB31Ch-820CB348h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB348);
		  /* 820CB348h */ case    0:  		/* lwz R11, <#[R31 + 52]> */
		/* 820CB348h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 820CB348h case    0:*/		return 0x820CB34C;
		  /* 820CB34Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB34Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB34Ch case    1:*/		return 0x820CB350;
		  /* 820CB350h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB350h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB374;  }
		/* 820CB350h case    2:*/		return 0x820CB354;
		  /* 820CB354h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB354h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB354h case    3:*/		return 0x820CB358;
		  /* 820CB358h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB358h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB358h case    4:*/		return 0x820CB35C;
		  /* 820CB35Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB35Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB35Ch case    5:*/		return 0x820CB360;
		  /* 820CB360h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB360h case    6:*/		regs.CTR = regs.R11;
		/* 820CB360h case    6:*/		return 0x820CB364;
		  /* 820CB364h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB364h case    7:*/		if ( 1 ) { regs.LR = 0x820CB368; return (uint32)regs.CTR; }
		/* 820CB364h case    7:*/		return 0x820CB368;
		  /* 820CB368h */ case    8:  		/* stw R3, <#[R30 + 52]> */
		/* 820CB368h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 820CB368h case    8:*/		return 0x820CB36C;
		  /* 820CB36Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB36Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB36Ch case    9:*/		return 0x820CB370;
		  /* 820CB370h */ case   10:  		/* bc 12, CR0_EQ, -280 */
		/* 820CB370h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB370h case   10:*/		return 0x820CB374;
	}
	return 0x820CB374;
} // Block from 820CB348h-820CB374h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB374);
		  /* 820CB374h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820CB374h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820CB374h case    0:*/		return 0x820CB378;
		  /* 820CB378h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB378h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB378h case    1:*/		return 0x820CB37C;
		  /* 820CB37Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB37Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB3A0;  }
		/* 820CB37Ch case    2:*/		return 0x820CB380;
		  /* 820CB380h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB380h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB380h case    3:*/		return 0x820CB384;
		  /* 820CB384h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB384h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB384h case    4:*/		return 0x820CB388;
	}
	return 0x820CB388;
} // Block from 820CB374h-820CB388h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CB388h
// Function '?Copy@CNodeUsage@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB388);
		  /* 820CB388h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB388h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB388h case    0:*/		return 0x820CB38C;
		  /* 820CB38Ch */ case    1:  		/* mtspr CTR, R11 */
		/* 820CB38Ch case    1:*/		regs.CTR = regs.R11;
		/* 820CB38Ch case    1:*/		return 0x820CB390;
		  /* 820CB390h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 820CB390h case    2:*/		if ( 1 ) { regs.LR = 0x820CB394; return (uint32)regs.CTR; }
		/* 820CB390h case    2:*/		return 0x820CB394;
		  /* 820CB394h */ case    3:  		/* stw R3, <#[R30 + 56]> */
		/* 820CB394h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 820CB394h case    3:*/		return 0x820CB398;
		  /* 820CB398h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820CB398h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB398h case    4:*/		return 0x820CB39C;
		  /* 820CB39Ch */ case    5:  		/* bc 12, CR0_EQ, -324 */
		/* 820CB39Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB39Ch case    5:*/		return 0x820CB3A0;
	}
	return 0x820CB3A0;
} // Block from 820CB388h-820CB3A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CB3A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB3A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB3A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB3A0);
		  /* 820CB3A0h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820CB3A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CB3A0h case    0:*/		return 0x820CB3A4;
		  /* 820CB3A4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB3A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB3A4h case    1:*/		return 0x820CB3A8;
		  /* 820CB3A8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB3A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB3CC;  }
		/* 820CB3A8h case    2:*/		return 0x820CB3AC;
		  /* 820CB3ACh */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB3ACh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB3ACh case    3:*/		return 0x820CB3B0;
		  /* 820CB3B0h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB3B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB3B0h case    4:*/		return 0x820CB3B4;
		  /* 820CB3B4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB3B4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB3B4h case    5:*/		return 0x820CB3B8;
		  /* 820CB3B8h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB3B8h case    6:*/		regs.CTR = regs.R11;
		/* 820CB3B8h case    6:*/		return 0x820CB3BC;
		  /* 820CB3BCh */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB3BCh case    7:*/		if ( 1 ) { regs.LR = 0x820CB3C0; return (uint32)regs.CTR; }
		/* 820CB3BCh case    7:*/		return 0x820CB3C0;
		  /* 820CB3C0h */ case    8:  		/* stw R3, <#[R30 + 60]> */
		/* 820CB3C0h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000003C) );
		/* 820CB3C0h case    8:*/		return 0x820CB3C4;
		  /* 820CB3C4h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB3C4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB3C4h case    9:*/		return 0x820CB3C8;
		  /* 820CB3C8h */ case   10:  		/* bc 12, CR0_EQ, -368 */
		/* 820CB3C8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB3C8h case   10:*/		return 0x820CB3CC;
	}
	return 0x820CB3CC;
} // Block from 820CB3A0h-820CB3CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB3CC);
		  /* 820CB3CCh */ case    0:  		/* lwz R11, <#[R31 + 68]> */
		/* 820CB3CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820CB3CCh case    0:*/		return 0x820CB3D0;
		  /* 820CB3D0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB3D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB3D0h case    1:*/		return 0x820CB3D4;
		  /* 820CB3D4h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB3D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB3F8;  }
		/* 820CB3D4h case    2:*/		return 0x820CB3D8;
		  /* 820CB3D8h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB3D8h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB3D8h case    3:*/		return 0x820CB3DC;
		  /* 820CB3DCh */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB3DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB3DCh case    4:*/		return 0x820CB3E0;
		  /* 820CB3E0h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB3E0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB3E0h case    5:*/		return 0x820CB3E4;
		  /* 820CB3E4h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB3E4h case    6:*/		regs.CTR = regs.R11;
		/* 820CB3E4h case    6:*/		return 0x820CB3E8;
		  /* 820CB3E8h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB3E8h case    7:*/		if ( 1 ) { regs.LR = 0x820CB3EC; return (uint32)regs.CTR; }
		/* 820CB3E8h case    7:*/		return 0x820CB3EC;
		  /* 820CB3ECh */ case    8:  		/* stw R3, <#[R30 + 68]> */
		/* 820CB3ECh case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000044) );
		/* 820CB3ECh case    8:*/		return 0x820CB3F0;
		  /* 820CB3F0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB3F0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB3F0h case    9:*/		return 0x820CB3F4;
		  /* 820CB3F4h */ case   10:  		/* bc 12, CR0_EQ, -412 */
		/* 820CB3F4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB3F4h case   10:*/		return 0x820CB3F8;
	}
	return 0x820CB3F8;
} // Block from 820CB3CCh-820CB3F8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB3F8);
		  /* 820CB3F8h */ case    0:  		/* lwz R11, <#[R31 + 64]> */
		/* 820CB3F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820CB3F8h case    0:*/		return 0x820CB3FC;
		  /* 820CB3FCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB3FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB3FCh case    1:*/		return 0x820CB400;
		  /* 820CB400h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB400h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB424;  }
		/* 820CB400h case    2:*/		return 0x820CB404;
		  /* 820CB404h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB404h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB404h case    3:*/		return 0x820CB408;
		  /* 820CB408h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB408h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB408h case    4:*/		return 0x820CB40C;
		  /* 820CB40Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB40Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB40Ch case    5:*/		return 0x820CB410;
		  /* 820CB410h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB410h case    6:*/		regs.CTR = regs.R11;
		/* 820CB410h case    6:*/		return 0x820CB414;
		  /* 820CB414h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB414h case    7:*/		if ( 1 ) { regs.LR = 0x820CB418; return (uint32)regs.CTR; }
		/* 820CB414h case    7:*/		return 0x820CB418;
		  /* 820CB418h */ case    8:  		/* stw R3, <#[R30 + 64]> */
		/* 820CB418h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000040) );
		/* 820CB418h case    8:*/		return 0x820CB41C;
		  /* 820CB41Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB41Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB41Ch case    9:*/		return 0x820CB420;
		  /* 820CB420h */ case   10:  		/* bc 12, CR0_EQ, -456 */
		/* 820CB420h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB258;  }
		/* 820CB420h case   10:*/		return 0x820CB424;
	}
	return 0x820CB424;
} // Block from 820CB3F8h-820CB424h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB424);
		  /* 820CB424h */ case    0:  		/* mr R3, R30 */
		/* 820CB424h case    0:*/		regs.R3 = regs.R30;
		/* 820CB424h case    0:*/		return 0x820CB428;
	}
	return 0x820CB428;
} // Block from 820CB424h-820CB428h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB428);
		  /* 820CB428h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CB428h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CB428h case    0:*/		return 0x820CB42C;
		  /* 820CB42Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CB42Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CB42Ch case    1:*/		return 0x820CB430;
		  /* 820CB430h */ case    2:  		/* mtspr LR, R12 */
		/* 820CB430h case    2:*/		regs.LR = regs.R12;
		/* 820CB430h case    2:*/		return 0x820CB434;
		  /* 820CB434h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CB434h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CB434h case    3:*/		return 0x820CB438;
		  /* 820CB438h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CB438h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CB438h case    4:*/		return 0x820CB43C;
		  /* 820CB43Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CB43Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CB43Ch case    5:*/		return 0x820CB440;
	}
	return 0x820CB440;
} // Block from 820CB428h-820CB440h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CB440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB440);
		  /* 820CB440h */ case    0:  		/* lis R9, -32255 */
		/* 820CB440h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CB440h case    0:*/		return 0x820CB444;
		  /* 820CB444h */ case    1:  		/* li R11, 0 */
		/* 820CB444h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CB444h case    1:*/		return 0x820CB448;
		  /* 820CB448h */ case    2:  		/* li R10, -1 */
		/* 820CB448h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820CB448h case    2:*/		return 0x820CB44C;
		  /* 820CB44Ch */ case    3:  		/* li R8, 11 */
		/* 820CB44Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0xB);
		/* 820CB44Ch case    3:*/		return 0x820CB450;
		  /* 820CB450h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820CB450h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CB450h case    4:*/		return 0x820CB454;
		  /* 820CB454h */ case    5:  		/* addi R9, R9, 10652 */
		/* 820CB454h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x299C);
		/* 820CB454h case    5:*/		return 0x820CB458;
		  /* 820CB458h */ case    6:  		/* stw R11, <#[R3 + 12]> */
		/* 820CB458h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CB458h case    6:*/		return 0x820CB45C;
		  /* 820CB45Ch */ case    7:  		/* stw R8, <#[R3 + 4]> */
		/* 820CB45Ch case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 820CB45Ch case    7:*/		return 0x820CB460;
		  /* 820CB460h */ case    8:  		/* stw R9, <#[R3]> */
		/* 820CB460h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB460h case    8:*/		return 0x820CB464;
		  /* 820CB464h */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 820CB464h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CB464h case    9:*/		return 0x820CB468;
		  /* 820CB468h */ case   10:  		/* stw R11, <#[R3 + 20]> */
		/* 820CB468h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CB468h case   10:*/		return 0x820CB46C;
		  /* 820CB46Ch */ case   11:  		/* stw R11, <#[R3 + 40]> */
		/* 820CB46Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CB46Ch case   11:*/		return 0x820CB470;
		  /* 820CB470h */ case   12:  		/* stw R11, <#[R3 + 44]> */
		/* 820CB470h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CB470h case   12:*/		return 0x820CB474;
		  /* 820CB474h */ case   13:  		/* stw R11, <#[R3 + 48]> */
		/* 820CB474h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CB474h case   13:*/		return 0x820CB478;
		  /* 820CB478h */ case   14:  		/* stw R11, <#[R3 + 52]> */
		/* 820CB478h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 820CB478h case   14:*/		return 0x820CB47C;
		  /* 820CB47Ch */ case   15:  		/* stw R11, <#[R3 + 56]> */
		/* 820CB47Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CB47Ch case   15:*/		return 0x820CB480;
		  /* 820CB480h */ case   16:  		/* stw R11, <#[R3 + 60]> */
		/* 820CB480h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CB480h case   16:*/		return 0x820CB484;
		  /* 820CB484h */ case   17:  		/* stw R11, <#[R3 + 64]> */
		/* 820CB484h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CB484h case   17:*/		return 0x820CB488;
		  /* 820CB488h */ case   18:  		/* stw R11, <#[R3 + 72]> */
		/* 820CB488h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 820CB488h case   18:*/		return 0x820CB48C;
		  /* 820CB48Ch */ case   19:  		/* stw R11, <#[R3 + 76]> */
		/* 820CB48Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 820CB48Ch case   19:*/		return 0x820CB490;
		  /* 820CB490h */ case   20:  		/* stw R11, <#[R3 + 80]> */
		/* 820CB490h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 820CB490h case   20:*/		return 0x820CB494;
		  /* 820CB494h */ case   21:  		/* stw R11, <#[R3 + 84]> */
		/* 820CB494h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 820CB494h case   21:*/		return 0x820CB498;
		  /* 820CB498h */ case   22:  		/* stw R11, <#[R3 + 68]> */
		/* 820CB498h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 820CB498h case   22:*/		return 0x820CB49C;
		  /* 820CB49Ch */ case   23:  		/* stw R10, <#[R3 + 24]> */
		/* 820CB49Ch case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820CB49Ch case   23:*/		return 0x820CB4A0;
		  /* 820CB4A0h */ case   24:  		/* stw R10, <#[R3 + 28]> */
		/* 820CB4A0h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CB4A0h case   24:*/		return 0x820CB4A4;
		  /* 820CB4A4h */ case   25:  		/* stw R10, <#[R3 + 32]> */
		/* 820CB4A4h case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 820CB4A4h case   25:*/		return 0x820CB4A8;
		  /* 820CB4A8h */ case   26:  		/* stw R10, <#[R3 + 36]> */
		/* 820CB4A8h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 820CB4A8h case   26:*/		return 0x820CB4AC;
		  /* 820CB4ACh */ case   27:  		/* bclr 20, CR0_LT */
		/* 820CB4ACh case   27:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CB4ACh case   27:*/		return 0x820CB4B0;
	}
	return 0x820CB4B0;
} // Block from 820CB440h-820CB4B0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820CB4B0h
// Function '??0CNodeArray@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB4B0);
		  /* 820CB4B0h */ case    0:  		/* mfspr R12, LR */
		/* 820CB4B0h case    0:*/		regs.R12 = regs.LR;
		/* 820CB4B0h case    0:*/		return 0x820CB4B4;
		  /* 820CB4B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CB4B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CB4B4h case    1:*/		return 0x820CB4B8;
		  /* 820CB4B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CB4B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CB4B8h case    2:*/		return 0x820CB4BC;
		  /* 820CB4BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CB4BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CB4BCh case    3:*/		return 0x820CB4C0;
		  /* 820CB4C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CB4C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CB4C0h case    4:*/		return 0x820CB4C4;
		  /* 820CB4C4h */ case    5:  		/* mr R31, R3 */
		/* 820CB4C4h case    5:*/		regs.R31 = regs.R3;
		/* 820CB4C4h case    5:*/		return 0x820CB4C8;
		  /* 820CB4C8h */ case    6:  		/* mr R30, R4 */
		/* 820CB4C8h case    6:*/		regs.R30 = regs.R4;
		/* 820CB4C8h case    6:*/		return 0x820CB4CC;
		  /* 820CB4CCh */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820CB4CCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CB4CCh case    7:*/		return 0x820CB4D0;
		  /* 820CB4D0h */ case    8:  		/* bc 12, CR6_EQ, 640 */
		/* 820CB4D0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB4D0h case    8:*/		return 0x820CB4D4;
		  /* 820CB4D4h */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CB4D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CB4D4h case    9:*/		return 0x820CB4D8;
		  /* 820CB4D8h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CB4D8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CB4D8h case   10:*/		return 0x820CB4DC;
		  /* 820CB4DCh */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CB4DCh case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CB4DCh case   11:*/		return 0x820CB4E0;
	}
	return 0x820CB4E0;
} // Block from 820CB4B0h-820CB4E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CB4E0h
// Function '??0CNodeArray@D3DXShader@@QAA@PAVCNode@1@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB4E0);
		  /* 820CB4E0h */ case    0:  		/* bc 4, CR6_EQ, 624 */
		/* 820CB4E0h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB4E0h case    0:*/		return 0x820CB4E4;
		  /* 820CB4E4h */ case    1:  		/* lwz R11, <#[R3 + 16]> */
		/* 820CB4E4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CB4E4h case    1:*/		return 0x820CB4E8;
		  /* 820CB4E8h */ case    2:  		/* lwz R10, <#[R4 + 16]> */
		/* 820CB4E8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820CB4E8h case    2:*/		return 0x820CB4EC;
		  /* 820CB4ECh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820CB4ECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CB4ECh case    3:*/		return 0x820CB4F0;
		  /* 820CB4F0h */ case    4:  		/* bc 4, CR6_EQ, 608 */
		/* 820CB4F0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB4F0h case    4:*/		return 0x820CB4F4;
		  /* 820CB4F4h */ case    5:  		/* lwz R11, <#[R3 + 20]> */
		/* 820CB4F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CB4F4h case    5:*/		return 0x820CB4F8;
		  /* 820CB4F8h */ case    6:  		/* lwz R10, <#[R4 + 20]> */
		/* 820CB4F8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820CB4F8h case    6:*/		return 0x820CB4FC;
		  /* 820CB4FCh */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820CB4FCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CB4FCh case    7:*/		return 0x820CB500;
		  /* 820CB500h */ case    8:  		/* bc 4, CR6_EQ, 592 */
		/* 820CB500h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB500h case    8:*/		return 0x820CB504;
		  /* 820CB504h */ case    9:  		/* lwz R11, <#[R3 + 40]> */
		/* 820CB504h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CB504h case    9:*/		return 0x820CB508;
		  /* 820CB508h */ case   10:  		/* lwz R10, <#[R4 + 40]> */
		/* 820CB508h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000028) );
		/* 820CB508h case   10:*/		return 0x820CB50C;
		  /* 820CB50Ch */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CB50Ch case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CB50Ch case   11:*/		return 0x820CB510;
	}
	return 0x820CB510;
} // Block from 820CB4E0h-820CB510h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CB510h
// Function '?IsEqual@CNodeArray@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB510);
		  /* 820CB510h */ case    0:  		/* bc 4, CR6_EQ, 576 */
		/* 820CB510h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB510h case    0:*/		return 0x820CB514;
		  /* 820CB514h */ case    1:  		/* lwz R11, <#[R3 + 44]> */
		/* 820CB514h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CB514h case    1:*/		return 0x820CB518;
		  /* 820CB518h */ case    2:  		/* lwz R10, <#[R4 + 44]> */
		/* 820CB518h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000002C) );
		/* 820CB518h case    2:*/		return 0x820CB51C;
		  /* 820CB51Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820CB51Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CB51Ch case    3:*/		return 0x820CB520;
		  /* 820CB520h */ case    4:  		/* bc 4, CR6_EQ, 560 */
		/* 820CB520h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB520h case    4:*/		return 0x820CB524;
		  /* 820CB524h */ case    5:  		/* lwz R11, <#[R4 + 76]> */
		/* 820CB524h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000004C) );
		/* 820CB524h case    5:*/		return 0x820CB528;
		  /* 820CB528h */ case    6:  		/* lwz R10, <#[R3 + 76]> */
		/* 820CB528h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000004C) );
		/* 820CB528h case    6:*/		return 0x820CB52C;
		  /* 820CB52Ch */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 820CB52Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820CB52Ch case    7:*/		return 0x820CB530;
		  /* 820CB530h */ case    8:  		/* bc 4, CR6_EQ, 544 */
		/* 820CB530h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB530h case    8:*/		return 0x820CB534;
		  /* 820CB534h */ case    9:  		/* lwz R11, <#[R3 + 24]> */
		/* 820CB534h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CB534h case    9:*/		return 0x820CB538;
		  /* 820CB538h */ case   10:  		/* lwz R10, <#[R4 + 24]> */
		/* 820CB538h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820CB538h case   10:*/		return 0x820CB53C;
		  /* 820CB53Ch */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820CB53Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CB53Ch case   11:*/		return 0x820CB540;
		  /* 820CB540h */ case   12:  		/* bc 4, CR6_EQ, 528 */
		/* 820CB540h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB540h case   12:*/		return 0x820CB544;
		  /* 820CB544h */ case   13:  		/* lwz R11, <#[R3 + 28]> */
		/* 820CB544h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CB544h case   13:*/		return 0x820CB548;
		  /* 820CB548h */ case   14:  		/* lwz R10, <#[R4 + 28]> */
		/* 820CB548h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 820CB548h case   14:*/		return 0x820CB54C;
		  /* 820CB54Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820CB54Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CB54Ch case   15:*/		return 0x820CB550;
		  /* 820CB550h */ case   16:  		/* bc 4, CR6_EQ, 512 */
		/* 820CB550h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB550h case   16:*/		return 0x820CB554;
		  /* 820CB554h */ case   17:  		/* lwz R11, <#[R3 + 32]> */
		/* 820CB554h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CB554h case   17:*/		return 0x820CB558;
		  /* 820CB558h */ case   18:  		/* lwz R10, <#[R4 + 32]> */
		/* 820CB558h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000020) );
		/* 820CB558h case   18:*/		return 0x820CB55C;
		  /* 820CB55Ch */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820CB55Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CB55Ch case   19:*/		return 0x820CB560;
		  /* 820CB560h */ case   20:  		/* bc 4, CR6_EQ, 496 */
		/* 820CB560h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB560h case   20:*/		return 0x820CB564;
		  /* 820CB564h */ case   21:  		/* lwz R11, <#[R3 + 36]> */
		/* 820CB564h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CB564h case   21:*/		return 0x820CB568;
		  /* 820CB568h */ case   22:  		/* lwz R10, <#[R4 + 36]> */
		/* 820CB568h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000024) );
		/* 820CB568h case   22:*/		return 0x820CB56C;
		  /* 820CB56Ch */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820CB56Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CB56Ch case   23:*/		return 0x820CB570;
		  /* 820CB570h */ case   24:  		/* bc 4, CR6_EQ, 480 */
		/* 820CB570h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB570h case   24:*/		return 0x820CB574;
		  /* 820CB574h */ case   25:  		/* lwz R3, <#[R3 + 48]> */
		/* 820CB574h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 820CB574h case   25:*/		return 0x820CB578;
		  /* 820CB578h */ case   26:  		/* lwz R4, <#[R4 + 48]> */
		/* 820CB578h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000030) );
		/* 820CB578h case   26:*/		return 0x820CB57C;
		  /* 820CB57Ch */ case   27:  		/* cmplwi CR6, R3, 0 */
		/* 820CB57Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB57Ch case   27:*/		return 0x820CB580;
		  /* 820CB580h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB580h case   28:*/		if ( regs.CR[6].eq ) { return 0x820CB598;  }
		/* 820CB580h case   28:*/		return 0x820CB584;
		  /* 820CB584h */ case   29:  		/* lwz R11, <#[R3]> */
		/* 820CB584h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB584h case   29:*/		return 0x820CB588;
		  /* 820CB588h */ case   30:  		/* lwz R11, <#[R11]> */
		/* 820CB588h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB588h case   30:*/		return 0x820CB58C;
		  /* 820CB58Ch */ case   31:  		/* mtspr CTR, R11 */
		/* 820CB58Ch case   31:*/		regs.CTR = regs.R11;
		/* 820CB58Ch case   31:*/		return 0x820CB590;
		  /* 820CB590h */ case   32:  		/* bcctrl 20, CR0_LT */
		/* 820CB590h case   32:*/		if ( 1 ) { regs.LR = 0x820CB594; return (uint32)regs.CTR; }
		/* 820CB590h case   32:*/		return 0x820CB594;
		  /* 820CB594h */ case   33:  		/* b 16 */
		/* 820CB594h case   33:*/		return 0x820CB5A4;
		/* 820CB594h case   33:*/		return 0x820CB598;
	}
	return 0x820CB598;
} // Block from 820CB510h-820CB598h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820CB598h
// Function '?Copy@CNodeArray@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB598);
		  /* 820CB598h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB598h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB598h case    0:*/		return 0x820CB59C;
		  /* 820CB59Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB59Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB59Ch case    1:*/		return 0x820CB5A0;
		  /* 820CB5A0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB5A0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB5A0h case    2:*/		return 0x820CB5A4;
	}
	return 0x820CB5A4;
} // Block from 820CB598h-820CB5A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB5A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB5A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB5A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB5A4);
		  /* 820CB5A4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB5A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB5A4h case    0:*/		return 0x820CB5A8;
		  /* 820CB5A8h */ case    1:  		/* bc 12, CR6_EQ, 424 */
		/* 820CB5A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB5A8h case    1:*/		return 0x820CB5AC;
		  /* 820CB5ACh */ case    2:  		/* lwz R3, <#[R31 + 52]> */
		/* 820CB5ACh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 820CB5ACh case    2:*/		return 0x820CB5B0;
		  /* 820CB5B0h */ case    3:  		/* lwz R4, <#[R30 + 52]> */
		/* 820CB5B0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000034) );
		/* 820CB5B0h case    3:*/		return 0x820CB5B4;
		  /* 820CB5B4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB5B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB5B4h case    4:*/		return 0x820CB5B8;
		  /* 820CB5B8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB5B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB5D0;  }
		/* 820CB5B8h case    5:*/		return 0x820CB5BC;
		  /* 820CB5BCh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB5BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB5BCh case    6:*/		return 0x820CB5C0;
		  /* 820CB5C0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB5C0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB5C0h case    7:*/		return 0x820CB5C4;
		  /* 820CB5C4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB5C4h case    8:*/		regs.CTR = regs.R11;
		/* 820CB5C4h case    8:*/		return 0x820CB5C8;
		  /* 820CB5C8h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB5C8h case    9:*/		if ( 1 ) { regs.LR = 0x820CB5CC; return (uint32)regs.CTR; }
		/* 820CB5C8h case    9:*/		return 0x820CB5CC;
		  /* 820CB5CCh */ case   10:  		/* b 16 */
		/* 820CB5CCh case   10:*/		return 0x820CB5DC;
		/* 820CB5CCh case   10:*/		return 0x820CB5D0;
	}
	return 0x820CB5D0;
} // Block from 820CB5A4h-820CB5D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB5D0);
		  /* 820CB5D0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB5D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB5D0h case    0:*/		return 0x820CB5D4;
		  /* 820CB5D4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB5D4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB5D4h case    1:*/		return 0x820CB5D8;
		  /* 820CB5D8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB5D8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB5D8h case    2:*/		return 0x820CB5DC;
	}
	return 0x820CB5DC;
} // Block from 820CB5D0h-820CB5DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB5DC);
		  /* 820CB5DCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB5DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB5DCh case    0:*/		return 0x820CB5E0;
		  /* 820CB5E0h */ case    1:  		/* bc 12, CR6_EQ, 368 */
		/* 820CB5E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB5E0h case    1:*/		return 0x820CB5E4;
		  /* 820CB5E4h */ case    2:  		/* lwz R3, <#[R31 + 56]> */
		/* 820CB5E4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 820CB5E4h case    2:*/		return 0x820CB5E8;
		  /* 820CB5E8h */ case    3:  		/* lwz R4, <#[R30 + 56]> */
		/* 820CB5E8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000038) );
		/* 820CB5E8h case    3:*/		return 0x820CB5EC;
		  /* 820CB5ECh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB5ECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB5ECh case    4:*/		return 0x820CB5F0;
		  /* 820CB5F0h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB5F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB608;  }
		/* 820CB5F0h case    5:*/		return 0x820CB5F4;
		  /* 820CB5F4h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB5F4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB5F4h case    6:*/		return 0x820CB5F8;
		  /* 820CB5F8h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB5F8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB5F8h case    7:*/		return 0x820CB5FC;
		  /* 820CB5FCh */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB5FCh case    8:*/		regs.CTR = regs.R11;
		/* 820CB5FCh case    8:*/		return 0x820CB600;
		  /* 820CB600h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB600h case    9:*/		if ( 1 ) { regs.LR = 0x820CB604; return (uint32)regs.CTR; }
		/* 820CB600h case    9:*/		return 0x820CB604;
		  /* 820CB604h */ case   10:  		/* b 16 */
		/* 820CB604h case   10:*/		return 0x820CB614;
		/* 820CB604h case   10:*/		return 0x820CB608;
	}
	return 0x820CB608;
} // Block from 820CB5DCh-820CB608h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB608);
		  /* 820CB608h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB608h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB608h case    0:*/		return 0x820CB60C;
		  /* 820CB60Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB60Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB60Ch case    1:*/		return 0x820CB610;
		  /* 820CB610h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB610h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB610h case    2:*/		return 0x820CB614;
	}
	return 0x820CB614;
} // Block from 820CB608h-820CB614h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB614);
		  /* 820CB614h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB614h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB614h case    0:*/		return 0x820CB618;
		  /* 820CB618h */ case    1:  		/* bc 12, CR6_EQ, 312 */
		/* 820CB618h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB618h case    1:*/		return 0x820CB61C;
		  /* 820CB61Ch */ case    2:  		/* lwz R3, <#[R31 + 60]> */
		/* 820CB61Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CB61Ch case    2:*/		return 0x820CB620;
		  /* 820CB620h */ case    3:  		/* lwz R4, <#[R30 + 60]> */
		/* 820CB620h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000003C) );
		/* 820CB620h case    3:*/		return 0x820CB624;
		  /* 820CB624h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB624h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB624h case    4:*/		return 0x820CB628;
		  /* 820CB628h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB628h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB640;  }
		/* 820CB628h case    5:*/		return 0x820CB62C;
		  /* 820CB62Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB62Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB62Ch case    6:*/		return 0x820CB630;
		  /* 820CB630h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB630h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB630h case    7:*/		return 0x820CB634;
		  /* 820CB634h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB634h case    8:*/		regs.CTR = regs.R11;
		/* 820CB634h case    8:*/		return 0x820CB638;
		  /* 820CB638h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB638h case    9:*/		if ( 1 ) { regs.LR = 0x820CB63C; return (uint32)regs.CTR; }
		/* 820CB638h case    9:*/		return 0x820CB63C;
		  /* 820CB63Ch */ case   10:  		/* b 16 */
		/* 820CB63Ch case   10:*/		return 0x820CB64C;
		/* 820CB63Ch case   10:*/		return 0x820CB640;
	}
	return 0x820CB640;
} // Block from 820CB614h-820CB640h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB640);
		  /* 820CB640h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB640h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB640h case    0:*/		return 0x820CB644;
		  /* 820CB644h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB644h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB644h case    1:*/		return 0x820CB648;
		  /* 820CB648h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB648h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB648h case    2:*/		return 0x820CB64C;
	}
	return 0x820CB64C;
} // Block from 820CB640h-820CB64Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB64C);
		  /* 820CB64Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB64Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB64Ch case    0:*/		return 0x820CB650;
		  /* 820CB650h */ case    1:  		/* bc 12, CR6_EQ, 256 */
		/* 820CB650h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB650h case    1:*/		return 0x820CB654;
		  /* 820CB654h */ case    2:  		/* lwz R3, <#[R31 + 64]> */
		/* 820CB654h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 820CB654h case    2:*/		return 0x820CB658;
		  /* 820CB658h */ case    3:  		/* lwz R4, <#[R30 + 64]> */
		/* 820CB658h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000040) );
		/* 820CB658h case    3:*/		return 0x820CB65C;
		  /* 820CB65Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB65Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB65Ch case    4:*/		return 0x820CB660;
		  /* 820CB660h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB660h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB678;  }
		/* 820CB660h case    5:*/		return 0x820CB664;
		  /* 820CB664h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB664h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB664h case    6:*/		return 0x820CB668;
	}
	return 0x820CB668;
} // Block from 820CB64Ch-820CB668h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CB668h
// Function '??0CNodeType@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB668);
		  /* 820CB668h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 820CB668h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB668h case    0:*/		return 0x820CB66C;
		  /* 820CB66Ch */ case    1:  		/* mtspr CTR, R11 */
		/* 820CB66Ch case    1:*/		regs.CTR = regs.R11;
		/* 820CB66Ch case    1:*/		return 0x820CB670;
		  /* 820CB670h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 820CB670h case    2:*/		if ( 1 ) { regs.LR = 0x820CB674; return (uint32)regs.CTR; }
		/* 820CB670h case    2:*/		return 0x820CB674;
		  /* 820CB674h */ case    3:  		/* b 16 */
		/* 820CB674h case    3:*/		return 0x820CB684;
		/* 820CB674h case    3:*/		return 0x820CB678;
	}
	return 0x820CB678;
} // Block from 820CB668h-820CB678h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CB678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB678);
		  /* 820CB678h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB678h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB678h case    0:*/		return 0x820CB67C;
		  /* 820CB67Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB67Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB67Ch case    1:*/		return 0x820CB680;
		  /* 820CB680h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB680h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB680h case    2:*/		return 0x820CB684;
	}
	return 0x820CB684;
} // Block from 820CB678h-820CB684h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB684);
		  /* 820CB684h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB684h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB684h case    0:*/		return 0x820CB688;
		  /* 820CB688h */ case    1:  		/* bc 12, CR6_EQ, 200 */
		/* 820CB688h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB688h case    1:*/		return 0x820CB68C;
		  /* 820CB68Ch */ case    2:  		/* lwz R3, <#[R31 + 72]> */
		/* 820CB68Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000048) );
		/* 820CB68Ch case    2:*/		return 0x820CB690;
		  /* 820CB690h */ case    3:  		/* lwz R4, <#[R30 + 72]> */
		/* 820CB690h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000048) );
		/* 820CB690h case    3:*/		return 0x820CB694;
		  /* 820CB694h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB694h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB694h case    4:*/		return 0x820CB698;
		  /* 820CB698h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB698h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB6B0;  }
		/* 820CB698h case    5:*/		return 0x820CB69C;
		  /* 820CB69Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB69Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB69Ch case    6:*/		return 0x820CB6A0;
		  /* 820CB6A0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB6A0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB6A0h case    7:*/		return 0x820CB6A4;
		  /* 820CB6A4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB6A4h case    8:*/		regs.CTR = regs.R11;
		/* 820CB6A4h case    8:*/		return 0x820CB6A8;
	}
	return 0x820CB6A8;
} // Block from 820CB684h-820CB6A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CB6A8h
// Function '??0CNodeType@D3DXShader@@QAA@W4_D3DTYPE_TEMPLATE@1@W4_D3DCOMPONENT_TYPE@1@PAVCNode@1@IIK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB6A8);
		  /* 820CB6A8h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 820CB6A8h case    0:*/		if ( 1 ) { regs.LR = 0x820CB6AC; return (uint32)regs.CTR; }
		/* 820CB6A8h case    0:*/		return 0x820CB6AC;
		  /* 820CB6ACh */ case    1:  		/* b 16 */
		/* 820CB6ACh case    1:*/		return 0x820CB6BC;
		/* 820CB6ACh case    1:*/		return 0x820CB6B0;
	}
	return 0x820CB6B0;
} // Block from 820CB6A8h-820CB6B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CB6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB6B0);
		  /* 820CB6B0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB6B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB6B0h case    0:*/		return 0x820CB6B4;
		  /* 820CB6B4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB6B4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB6B4h case    1:*/		return 0x820CB6B8;
		  /* 820CB6B8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB6B8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB6B8h case    2:*/		return 0x820CB6BC;
	}
	return 0x820CB6BC;
} // Block from 820CB6B0h-820CB6BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB6BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB6BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB6BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB6BC);
		  /* 820CB6BCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB6BCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB6BCh case    0:*/		return 0x820CB6C0;
		  /* 820CB6C0h */ case    1:  		/* bc 12, CR6_EQ, 144 */
		/* 820CB6C0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB6C0h case    1:*/		return 0x820CB6C4;
		  /* 820CB6C4h */ case    2:  		/* lwz R3, <#[R31 + 68]> */
		/* 820CB6C4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000044) );
		/* 820CB6C4h case    2:*/		return 0x820CB6C8;
		  /* 820CB6C8h */ case    3:  		/* lwz R4, <#[R30 + 68]> */
		/* 820CB6C8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000044) );
		/* 820CB6C8h case    3:*/		return 0x820CB6CC;
		  /* 820CB6CCh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CB6CCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CB6CCh case    4:*/		return 0x820CB6D0;
		  /* 820CB6D0h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CB6D0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CB6E8;  }
		/* 820CB6D0h case    5:*/		return 0x820CB6D4;
		  /* 820CB6D4h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CB6D4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB6D4h case    6:*/		return 0x820CB6D8;
		  /* 820CB6D8h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CB6D8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB6D8h case    7:*/		return 0x820CB6DC;
		  /* 820CB6DCh */ case    8:  		/* mtspr CTR, R11 */
		/* 820CB6DCh case    8:*/		regs.CTR = regs.R11;
		/* 820CB6DCh case    8:*/		return 0x820CB6E0;
		  /* 820CB6E0h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CB6E0h case    9:*/		if ( 1 ) { regs.LR = 0x820CB6E4; return (uint32)regs.CTR; }
		/* 820CB6E0h case    9:*/		return 0x820CB6E4;
		  /* 820CB6E4h */ case   10:  		/* b 16 */
		/* 820CB6E4h case   10:*/		return 0x820CB6F4;
		/* 820CB6E4h case   10:*/		return 0x820CB6E8;
	}
	return 0x820CB6E8;
} // Block from 820CB6BCh-820CB6E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB6E8h
// Function '?IsEqual@CNodeType@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB6E8);
		  /* 820CB6E8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CB6E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CB6E8h case    0:*/		return 0x820CB6EC;
		  /* 820CB6ECh */ case    1:  		/* cntlzw R11, R11 */
		/* 820CB6ECh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CB6ECh case    1:*/		return 0x820CB6F0;
		  /* 820CB6F0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CB6F0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CB6F0h case    2:*/		return 0x820CB6F4;
	}
	return 0x820CB6F4;
} // Block from 820CB6E8h-820CB6F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB6F4);
		  /* 820CB6F4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CB6F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CB6F4h case    0:*/		return 0x820CB6F8;
		  /* 820CB6F8h */ case    1:  		/* bc 12, CR6_EQ, 88 */
		/* 820CB6F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CB750;  }
		/* 820CB6F8h case    1:*/		return 0x820CB6FC;
		  /* 820CB6FCh */ case    2:  		/* lwz R11, <#[R31 + 76]> */
		/* 820CB6FCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820CB6FCh case    2:*/		return 0x820CB700;
		  /* 820CB700h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820CB700h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB700h case    3:*/		return 0x820CB704;
		  /* 820CB704h */ case    4:  		/* bc 12, CR6_EQ, 68 */
		/* 820CB704h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CB748;  }
		/* 820CB704h case    4:*/		return 0x820CB708;
		  /* 820CB708h */ case    5:  		/* rlwinm. R10, R11, 2, 0, 29 */
		/* 820CB708h case    5:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820CB708h case    5:*/		return 0x820CB70C;
		  /* 820CB70Ch */ case    6:  		/* lwz R9, <#[R30 + 80]> */
		/* 820CB70Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000050) );
		/* 820CB70Ch case    6:*/		return 0x820CB710;
		  /* 820CB710h */ case    7:  		/* lwz R11, <#[R31 + 80]> */
		/* 820CB710h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 820CB710h case    7:*/		return 0x820CB714;
		  /* 820CB714h */ case    8:  		/* li R8, 0 */
		/* 820CB714h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820CB714h case    8:*/		return 0x820CB718;
		  /* 820CB718h */ case    9:  		/* bc 12, CR0_EQ, 40 */
		/* 820CB718h case    9:*/		if ( regs.CR[0].eq ) { return 0x820CB740;  }
		/* 820CB718h case    9:*/		return 0x820CB71C;
		  /* 820CB71Ch */ case   10:  		/* add R10, R11, R10 */
		/* 820CB71Ch case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820CB71Ch case   10:*/		return 0x820CB720;
		  /* 820CB720h */ case   11:  		/* lbz R8, <#[R11]> */
		/* 820CB720h case   11:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820CB720h case   11:*/		return 0x820CB724;
		  /* 820CB724h */ case   12:  		/* lbz R7, <#[R9]> */
		/* 820CB724h case   12:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820CB724h case   12:*/		return 0x820CB728;
		  /* 820CB728h */ case   13:  		/* subf. R8, R7, R8 */
		/* 820CB728h case   13:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820CB728h case   13:*/		return 0x820CB72C;
		  /* 820CB72Ch */ case   14:  		/* bc 4, CR0_EQ, 20 */
		/* 820CB72Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x820CB740;  }
		/* 820CB72Ch case   14:*/		return 0x820CB730;
		  /* 820CB730h */ case   15:  		/* addi R11, R11, 1 */
		/* 820CB730h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CB730h case   15:*/		return 0x820CB734;
		  /* 820CB734h */ case   16:  		/* addi R9, R9, 1 */
		/* 820CB734h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820CB734h case   16:*/		return 0x820CB738;
		  /* 820CB738h */ case   17:  		/* cmpw CR6, R11, R10 */
		/* 820CB738h case   17:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CB738h case   17:*/		return 0x820CB73C;
		  /* 820CB73Ch */ case   18:  		/* bc 4, CR6_EQ, -28 */
		/* 820CB73Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x820CB720;  }
		/* 820CB73Ch case   18:*/		return 0x820CB740;
	}
	return 0x820CB740;
} // Block from 820CB6F4h-820CB740h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CB740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB740);
		  /* 820CB740h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820CB740h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820CB740h case    0:*/		return 0x820CB744;
		  /* 820CB744h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CB744h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CB750;  }
		/* 820CB744h case    1:*/		return 0x820CB748;
	}
	return 0x820CB748;
} // Block from 820CB740h-820CB748h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CB748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB748);
		  /* 820CB748h */ case    0:  		/* li R3, 1 */
		/* 820CB748h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CB748h case    0:*/		return 0x820CB74C;
		  /* 820CB74Ch */ case    1:  		/* b 8 */
		/* 820CB74Ch case    1:*/		return 0x820CB754;
		/* 820CB74Ch case    1:*/		return 0x820CB750;
	}
	return 0x820CB750;
} // Block from 820CB748h-820CB750h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CB750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB750);
		  /* 820CB750h */ case    0:  		/* li R3, 0 */
		/* 820CB750h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CB750h case    0:*/		return 0x820CB754;
	}
	return 0x820CB754;
} // Block from 820CB750h-820CB754h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB754);
		  /* 820CB754h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CB754h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CB754h case    0:*/		return 0x820CB758;
		  /* 820CB758h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CB758h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CB758h case    1:*/		return 0x820CB75C;
		  /* 820CB75Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CB75Ch case    2:*/		regs.LR = regs.R12;
		/* 820CB75Ch case    2:*/		return 0x820CB760;
		  /* 820CB760h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CB760h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CB760h case    3:*/		return 0x820CB764;
		  /* 820CB764h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CB764h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CB764h case    4:*/		return 0x820CB768;
		  /* 820CB768h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CB768h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CB768h case    5:*/		return 0x820CB76C;
	}
	return 0x820CB76C;
} // Block from 820CB754h-820CB76Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CB76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB76C);
		  /* 820CB76Ch */ case    0:  		/* nop */
		/* 820CB76Ch case    0:*/		cpu::op::nop();
		/* 820CB76Ch case    0:*/		return 0x820CB770;
	}
	return 0x820CB770;
} // Block from 820CB76Ch-820CB770h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB770);
		  /* 820CB770h */ case    0:  		/* mfspr R12, LR */
		/* 820CB770h case    0:*/		regs.R12 = regs.LR;
		/* 820CB770h case    0:*/		return 0x820CB774;
		  /* 820CB774h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CB774h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CB774h case    1:*/		return 0x820CB778;
		  /* 820CB778h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CB778h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CB778h case    2:*/		return 0x820CB77C;
		  /* 820CB77Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CB77Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CB77Ch case    3:*/		return 0x820CB780;
		  /* 820CB780h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CB780h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CB780h case    4:*/		return 0x820CB784;
		  /* 820CB784h */ case    5:  		/* mr R31, R3 */
		/* 820CB784h case    5:*/		regs.R31 = regs.R3;
		/* 820CB784h case    5:*/		return 0x820CB788;
		  /* 820CB788h */ case    6:  		/* bl 6312 */
		/* 820CB788h case    6:*/		regs.LR = 0x820CB78C; return 0x820CD030;
		/* 820CB788h case    6:*/		return 0x820CB78C;
		  /* 820CB78Ch */ case    7:  		/* li R5, 16 */
		/* 820CB78Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CB78Ch case    7:*/		return 0x820CB790;
		  /* 820CB790h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CB790h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB790h case    8:*/		return 0x820CB794;
		  /* 820CB794h */ case    9:  		/* li R4, 88 */
		/* 820CB794h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x58);
		/* 820CB794h case    9:*/		return 0x820CB798;
		  /* 820CB798h */ case   10:  		/* bl -9912 */
		/* 820CB798h case   10:*/		regs.LR = 0x820CB79C; return 0x820C90E0;
		/* 820CB798h case   10:*/		return 0x820CB79C;
		  /* 820CB79Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CB79Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB79Ch case   11:*/		return 0x820CB7A0;
		  /* 820CB7A0h */ case   12:  		/* bc 12, CR0_EQ, 120 */
		/* 820CB7A0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CB818;  }
		/* 820CB7A0h case   12:*/		return 0x820CB7A4;
		  /* 820CB7A4h */ case   13:  		/* lis R9, -32255 */
		/* 820CB7A4h case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CB7A4h case   13:*/		return 0x820CB7A8;
		  /* 820CB7A8h */ case   14:  		/* li R11, 0 */
		/* 820CB7A8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CB7A8h case   14:*/		return 0x820CB7AC;
		  /* 820CB7ACh */ case   15:  		/* li R10, -1 */
		/* 820CB7ACh case   15:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820CB7ACh case   15:*/		return 0x820CB7B0;
	}
	return 0x820CB7B0;
} // Block from 820CB770h-820CB7B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CB7B0h
// Function '?Copy@CNodeType@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB7B0);
		  /* 820CB7B0h */ case    0:  		/* li R8, 11 */
		/* 820CB7B0h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0xB);
		/* 820CB7B0h case    0:*/		return 0x820CB7B4;
		  /* 820CB7B4h */ case    1:  		/* stw R11, <#[R3 + 8]> */
		/* 820CB7B4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CB7B4h case    1:*/		return 0x820CB7B8;
		  /* 820CB7B8h */ case    2:  		/* addi R9, R9, 10652 */
		/* 820CB7B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x299C);
		/* 820CB7B8h case    2:*/		return 0x820CB7BC;
		  /* 820CB7BCh */ case    3:  		/* stw R11, <#[R3 + 12]> */
		/* 820CB7BCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CB7BCh case    3:*/		return 0x820CB7C0;
		  /* 820CB7C0h */ case    4:  		/* stw R8, <#[R3 + 4]> */
		/* 820CB7C0h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 820CB7C0h case    4:*/		return 0x820CB7C4;
		  /* 820CB7C4h */ case    5:  		/* mr R30, R3 */
		/* 820CB7C4h case    5:*/		regs.R30 = regs.R3;
		/* 820CB7C4h case    5:*/		return 0x820CB7C8;
		  /* 820CB7C8h */ case    6:  		/* stw R9, <#[R3]> */
		/* 820CB7C8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB7C8h case    6:*/		return 0x820CB7CC;
		  /* 820CB7CCh */ case    7:  		/* stw R11, <#[R3 + 16]> */
		/* 820CB7CCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CB7CCh case    7:*/		return 0x820CB7D0;
		  /* 820CB7D0h */ case    8:  		/* stw R11, <#[R3 + 20]> */
		/* 820CB7D0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CB7D0h case    8:*/		return 0x820CB7D4;
		  /* 820CB7D4h */ case    9:  		/* stw R11, <#[R3 + 40]> */
		/* 820CB7D4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CB7D4h case    9:*/		return 0x820CB7D8;
		  /* 820CB7D8h */ case   10:  		/* stw R11, <#[R3 + 44]> */
		/* 820CB7D8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CB7D8h case   10:*/		return 0x820CB7DC;
		  /* 820CB7DCh */ case   11:  		/* stw R11, <#[R3 + 48]> */
		/* 820CB7DCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CB7DCh case   11:*/		return 0x820CB7E0;
		  /* 820CB7E0h */ case   12:  		/* stw R11, <#[R3 + 52]> */
		/* 820CB7E0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 820CB7E0h case   12:*/		return 0x820CB7E4;
		  /* 820CB7E4h */ case   13:  		/* stw R11, <#[R3 + 56]> */
		/* 820CB7E4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CB7E4h case   13:*/		return 0x820CB7E8;
		  /* 820CB7E8h */ case   14:  		/* stw R11, <#[R3 + 60]> */
		/* 820CB7E8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CB7E8h case   14:*/		return 0x820CB7EC;
		  /* 820CB7ECh */ case   15:  		/* stw R11, <#[R3 + 64]> */
		/* 820CB7ECh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CB7ECh case   15:*/		return 0x820CB7F0;
		  /* 820CB7F0h */ case   16:  		/* stw R11, <#[R3 + 72]> */
		/* 820CB7F0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 820CB7F0h case   16:*/		return 0x820CB7F4;
		  /* 820CB7F4h */ case   17:  		/* stw R11, <#[R3 + 76]> */
		/* 820CB7F4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 820CB7F4h case   17:*/		return 0x820CB7F8;
		  /* 820CB7F8h */ case   18:  		/* stw R11, <#[R3 + 80]> */
		/* 820CB7F8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 820CB7F8h case   18:*/		return 0x820CB7FC;
		  /* 820CB7FCh */ case   19:  		/* stw R11, <#[R3 + 84]> */
		/* 820CB7FCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 820CB7FCh case   19:*/		return 0x820CB800;
		  /* 820CB800h */ case   20:  		/* stw R11, <#[R3 + 68]> */
		/* 820CB800h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 820CB800h case   20:*/		return 0x820CB804;
		  /* 820CB804h */ case   21:  		/* stw R10, <#[R3 + 24]> */
		/* 820CB804h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820CB804h case   21:*/		return 0x820CB808;
		  /* 820CB808h */ case   22:  		/* stw R10, <#[R3 + 28]> */
		/* 820CB808h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CB808h case   22:*/		return 0x820CB80C;
		  /* 820CB80Ch */ case   23:  		/* stw R10, <#[R3 + 32]> */
		/* 820CB80Ch case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 820CB80Ch case   23:*/		return 0x820CB810;
		  /* 820CB810h */ case   24:  		/* stw R10, <#[R3 + 36]> */
		/* 820CB810h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 820CB810h case   24:*/		return 0x820CB814;
		  /* 820CB814h */ case   25:  		/* b 8 */
		/* 820CB814h case   25:*/		return 0x820CB81C;
		/* 820CB814h case   25:*/		return 0x820CB818;
	}
	return 0x820CB818;
} // Block from 820CB7B0h-820CB818h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820CB818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB818);
		  /* 820CB818h */ case    0:  		/* li R30, 0 */
		/* 820CB818h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CB818h case    0:*/		return 0x820CB81C;
	}
	return 0x820CB81C;
} // Block from 820CB818h-820CB81Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CB81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB81C);
		  /* 820CB81Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820CB81Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CB81Ch case    0:*/		return 0x820CB820;
		  /* 820CB820h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CB820h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CB82C;  }
		/* 820CB820h case    1:*/		return 0x820CB824;
		  /* 820CB824h */ case    2:  		/* li R3, 0 */
		/* 820CB824h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CB824h case    2:*/		return 0x820CB828;
		  /* 820CB828h */ case    3:  		/* b 492 */
		/* 820CB828h case    3:*/		return 0x820CBA14;
		/* 820CB828h case    3:*/		return 0x820CB82C;
	}
	return 0x820CB82C;
} // Block from 820CB81Ch-820CB82Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CB82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB82C);
		  /* 820CB82Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820CB82Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CB82Ch case    0:*/		return 0x820CB830;
		  /* 820CB830h */ case    1:  		/* stw R11, <#[R30 + 16]> */
		/* 820CB830h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CB830h case    1:*/		return 0x820CB834;
		  /* 820CB834h */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 820CB834h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CB834h case    2:*/		return 0x820CB838;
		  /* 820CB838h */ case    3:  		/* stw R11, <#[R30 + 20]> */
		/* 820CB838h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CB838h case    3:*/		return 0x820CB83C;
		  /* 820CB83Ch */ case    4:  		/* lwz R11, <#[R31 + 40]> */
		/* 820CB83Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820CB83Ch case    4:*/		return 0x820CB840;
		  /* 820CB840h */ case    5:  		/* stw R11, <#[R30 + 40]> */
		/* 820CB840h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820CB840h case    5:*/		return 0x820CB844;
		  /* 820CB844h */ case    6:  		/* lwz R11, <#[R31 + 44]> */
		/* 820CB844h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820CB844h case    6:*/		return 0x820CB848;
		  /* 820CB848h */ case    7:  		/* stw R11, <#[R30 + 44]> */
		/* 820CB848h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820CB848h case    7:*/		return 0x820CB84C;
		  /* 820CB84Ch */ case    8:  		/* lwz R11, <#[R31 + 76]> */
		/* 820CB84Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820CB84Ch case    8:*/		return 0x820CB850;
		  /* 820CB850h */ case    9:  		/* stw R11, <#[R30 + 76]> */
		/* 820CB850h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 820CB850h case    9:*/		return 0x820CB854;
		  /* 820CB854h */ case   10:  		/* lwz R11, <#[R31 + 24]> */
		/* 820CB854h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CB854h case   10:*/		return 0x820CB858;
		  /* 820CB858h */ case   11:  		/* stw R11, <#[R30 + 24]> */
		/* 820CB858h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CB858h case   11:*/		return 0x820CB85C;
		  /* 820CB85Ch */ case   12:  		/* lwz R11, <#[R31 + 28]> */
		/* 820CB85Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CB85Ch case   12:*/		return 0x820CB860;
		  /* 820CB860h */ case   13:  		/* stw R11, <#[R30 + 28]> */
		/* 820CB860h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CB860h case   13:*/		return 0x820CB864;
		  /* 820CB864h */ case   14:  		/* lwz R11, <#[R31 + 32]> */
		/* 820CB864h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820CB864h case   14:*/		return 0x820CB868;
		  /* 820CB868h */ case   15:  		/* stw R11, <#[R30 + 32]> */
		/* 820CB868h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820CB868h case   15:*/		return 0x820CB86C;
		  /* 820CB86Ch */ case   16:  		/* lwz R11, <#[R31 + 36]> */
		/* 820CB86Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820CB86Ch case   16:*/		return 0x820CB870;
		  /* 820CB870h */ case   17:  		/* stw R11, <#[R30 + 36]> */
		/* 820CB870h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820CB870h case   17:*/		return 0x820CB874;
		  /* 820CB874h */ case   18:  		/* lwz R11, <#[R31 + 48]> */
		/* 820CB874h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820CB874h case   18:*/		return 0x820CB878;
		  /* 820CB878h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 820CB878h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB878h case   19:*/		return 0x820CB87C;
		  /* 820CB87Ch */ case   20:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB87Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x820CB8A0;  }
		/* 820CB87Ch case   20:*/		return 0x820CB880;
		  /* 820CB880h */ case   21:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB880h case   21:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB880h case   21:*/		return 0x820CB884;
		  /* 820CB884h */ case   22:  		/* lwz R11, <#[R3]> */
		/* 820CB884h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB884h case   22:*/		return 0x820CB888;
		  /* 820CB888h */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB888h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB888h case   23:*/		return 0x820CB88C;
		  /* 820CB88Ch */ case   24:  		/* mtspr CTR, R11 */
		/* 820CB88Ch case   24:*/		regs.CTR = regs.R11;
		/* 820CB88Ch case   24:*/		return 0x820CB890;
		  /* 820CB890h */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 820CB890h case   25:*/		if ( 1 ) { regs.LR = 0x820CB894; return (uint32)regs.CTR; }
		/* 820CB890h case   25:*/		return 0x820CB894;
		  /* 820CB894h */ case   26:  		/* stw R3, <#[R30 + 48]> */
		/* 820CB894h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 820CB894h case   26:*/		return 0x820CB898;
		  /* 820CB898h */ case   27:  		/* cmplwi CR0, R3, 0 */
		/* 820CB898h case   27:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB898h case   27:*/		return 0x820CB89C;
		  /* 820CB89Ch */ case   28:  		/* bc 12, CR0_EQ, -120 */
		/* 820CB89Ch case   28:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB89Ch case   28:*/		return 0x820CB8A0;
	}
	return 0x820CB8A0;
} // Block from 820CB82Ch-820CB8A0h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820CB8A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB8A0);
		  /* 820CB8A0h */ case    0:  		/* lwz R11, <#[R31 + 52]> */
		/* 820CB8A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 820CB8A0h case    0:*/		return 0x820CB8A4;
		  /* 820CB8A4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB8A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB8A4h case    1:*/		return 0x820CB8A8;
		  /* 820CB8A8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB8A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB8CC;  }
		/* 820CB8A8h case    2:*/		return 0x820CB8AC;
		  /* 820CB8ACh */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB8ACh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB8ACh case    3:*/		return 0x820CB8B0;
	}
	return 0x820CB8B0;
} // Block from 820CB8A0h-820CB8B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CB8B0h
// Function '??0CNodeFunction@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB8B0);
		  /* 820CB8B0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820CB8B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB8B0h case    0:*/		return 0x820CB8B4;
		  /* 820CB8B4h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB8B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB8B4h case    1:*/		return 0x820CB8B8;
		  /* 820CB8B8h */ case    2:  		/* mtspr CTR, R11 */
		/* 820CB8B8h case    2:*/		regs.CTR = regs.R11;
		/* 820CB8B8h case    2:*/		return 0x820CB8BC;
		  /* 820CB8BCh */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820CB8BCh case    3:*/		if ( 1 ) { regs.LR = 0x820CB8C0; return (uint32)regs.CTR; }
		/* 820CB8BCh case    3:*/		return 0x820CB8C0;
		  /* 820CB8C0h */ case    4:  		/* stw R3, <#[R30 + 52]> */
		/* 820CB8C0h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 820CB8C0h case    4:*/		return 0x820CB8C4;
		  /* 820CB8C4h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820CB8C4h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB8C4h case    5:*/		return 0x820CB8C8;
		  /* 820CB8C8h */ case    6:  		/* bc 12, CR0_EQ, -164 */
		/* 820CB8C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB8C8h case    6:*/		return 0x820CB8CC;
	}
	return 0x820CB8CC;
} // Block from 820CB8B0h-820CB8CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CB8CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB8CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB8CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB8CC);
		  /* 820CB8CCh */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820CB8CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820CB8CCh case    0:*/		return 0x820CB8D0;
		  /* 820CB8D0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB8D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB8D0h case    1:*/		return 0x820CB8D4;
		  /* 820CB8D4h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB8D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB8F8;  }
		/* 820CB8D4h case    2:*/		return 0x820CB8D8;
		  /* 820CB8D8h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB8D8h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB8D8h case    3:*/		return 0x820CB8DC;
		  /* 820CB8DCh */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB8DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB8DCh case    4:*/		return 0x820CB8E0;
		  /* 820CB8E0h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB8E0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB8E0h case    5:*/		return 0x820CB8E4;
		  /* 820CB8E4h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB8E4h case    6:*/		regs.CTR = regs.R11;
		/* 820CB8E4h case    6:*/		return 0x820CB8E8;
		  /* 820CB8E8h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB8E8h case    7:*/		if ( 1 ) { regs.LR = 0x820CB8EC; return (uint32)regs.CTR; }
		/* 820CB8E8h case    7:*/		return 0x820CB8EC;
		  /* 820CB8ECh */ case    8:  		/* stw R3, <#[R30 + 56]> */
		/* 820CB8ECh case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 820CB8ECh case    8:*/		return 0x820CB8F0;
		  /* 820CB8F0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB8F0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB8F0h case    9:*/		return 0x820CB8F4;
		  /* 820CB8F4h */ case   10:  		/* bc 12, CR0_EQ, -208 */
		/* 820CB8F4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB8F4h case   10:*/		return 0x820CB8F8;
	}
	return 0x820CB8F8;
} // Block from 820CB8CCh-820CB8F8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB8F8);
		  /* 820CB8F8h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820CB8F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CB8F8h case    0:*/		return 0x820CB8FC;
		  /* 820CB8FCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB8FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB8FCh case    1:*/		return 0x820CB900;
		  /* 820CB900h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB900h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB924;  }
		/* 820CB900h case    2:*/		return 0x820CB904;
		  /* 820CB904h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB904h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB904h case    3:*/		return 0x820CB908;
		  /* 820CB908h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB908h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB908h case    4:*/		return 0x820CB90C;
		  /* 820CB90Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB90Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB90Ch case    5:*/		return 0x820CB910;
		  /* 820CB910h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB910h case    6:*/		regs.CTR = regs.R11;
		/* 820CB910h case    6:*/		return 0x820CB914;
		  /* 820CB914h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB914h case    7:*/		if ( 1 ) { regs.LR = 0x820CB918; return (uint32)regs.CTR; }
		/* 820CB914h case    7:*/		return 0x820CB918;
	}
	return 0x820CB918;
} // Block from 820CB8F8h-820CB918h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CB918h
// Function '?IsEqual@CNodeFunction@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB918);
		  /* 820CB918h */ case    0:  		/* stw R3, <#[R30 + 60]> */
		/* 820CB918h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000003C) );
		/* 820CB918h case    0:*/		return 0x820CB91C;
		  /* 820CB91Ch */ case    1:  		/* cmplwi CR0, R3, 0 */
		/* 820CB91Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB91Ch case    1:*/		return 0x820CB920;
		  /* 820CB920h */ case    2:  		/* bc 12, CR0_EQ, -252 */
		/* 820CB920h case    2:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB920h case    2:*/		return 0x820CB924;
	}
	return 0x820CB924;
} // Block from 820CB918h-820CB924h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CB924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB924);
		  /* 820CB924h */ case    0:  		/* lwz R11, <#[R31 + 64]> */
		/* 820CB924h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820CB924h case    0:*/		return 0x820CB928;
		  /* 820CB928h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB928h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB928h case    1:*/		return 0x820CB92C;
		  /* 820CB92Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB92Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB950;  }
		/* 820CB92Ch case    2:*/		return 0x820CB930;
		  /* 820CB930h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB930h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB930h case    3:*/		return 0x820CB934;
		  /* 820CB934h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB934h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB934h case    4:*/		return 0x820CB938;
		  /* 820CB938h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB938h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB938h case    5:*/		return 0x820CB93C;
		  /* 820CB93Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB93Ch case    6:*/		regs.CTR = regs.R11;
		/* 820CB93Ch case    6:*/		return 0x820CB940;
		  /* 820CB940h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB940h case    7:*/		if ( 1 ) { regs.LR = 0x820CB944; return (uint32)regs.CTR; }
		/* 820CB940h case    7:*/		return 0x820CB944;
		  /* 820CB944h */ case    8:  		/* stw R3, <#[R30 + 64]> */
		/* 820CB944h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000040) );
		/* 820CB944h case    8:*/		return 0x820CB948;
		  /* 820CB948h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB948h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB948h case    9:*/		return 0x820CB94C;
		  /* 820CB94Ch */ case   10:  		/* bc 12, CR0_EQ, -296 */
		/* 820CB94Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB94Ch case   10:*/		return 0x820CB950;
	}
	return 0x820CB950;
} // Block from 820CB924h-820CB950h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB950);
		  /* 820CB950h */ case    0:  		/* lwz R11, <#[R31 + 72]> */
		/* 820CB950h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820CB950h case    0:*/		return 0x820CB954;
		  /* 820CB954h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB954h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB954h case    1:*/		return 0x820CB958;
		  /* 820CB958h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB958h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB97C;  }
		/* 820CB958h case    2:*/		return 0x820CB95C;
		  /* 820CB95Ch */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB95Ch case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB95Ch case    3:*/		return 0x820CB960;
		  /* 820CB960h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB960h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB960h case    4:*/		return 0x820CB964;
		  /* 820CB964h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB964h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB964h case    5:*/		return 0x820CB968;
		  /* 820CB968h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB968h case    6:*/		regs.CTR = regs.R11;
		/* 820CB968h case    6:*/		return 0x820CB96C;
		  /* 820CB96Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB96Ch case    7:*/		if ( 1 ) { regs.LR = 0x820CB970; return (uint32)regs.CTR; }
		/* 820CB96Ch case    7:*/		return 0x820CB970;
		  /* 820CB970h */ case    8:  		/* stw R3, <#[R30 + 72]> */
		/* 820CB970h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000048) );
		/* 820CB970h case    8:*/		return 0x820CB974;
		  /* 820CB974h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB974h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB974h case    9:*/		return 0x820CB978;
		  /* 820CB978h */ case   10:  		/* bc 12, CR0_EQ, -340 */
		/* 820CB978h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB978h case   10:*/		return 0x820CB97C;
	}
	return 0x820CB97C;
} // Block from 820CB950h-820CB97Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB97C);
		  /* 820CB97Ch */ case    0:  		/* lwz R11, <#[R31 + 68]> */
		/* 820CB97Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820CB97Ch case    0:*/		return 0x820CB980;
		  /* 820CB980h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB980h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB980h case    1:*/		return 0x820CB984;
		  /* 820CB984h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CB984h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CB9A8;  }
		/* 820CB984h case    2:*/		return 0x820CB988;
		  /* 820CB988h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CB988h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CB988h case    3:*/		return 0x820CB98C;
		  /* 820CB98Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CB98Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CB98Ch case    4:*/		return 0x820CB990;
		  /* 820CB990h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CB990h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CB990h case    5:*/		return 0x820CB994;
		  /* 820CB994h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CB994h case    6:*/		regs.CTR = regs.R11;
		/* 820CB994h case    6:*/		return 0x820CB998;
		  /* 820CB998h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CB998h case    7:*/		if ( 1 ) { regs.LR = 0x820CB99C; return (uint32)regs.CTR; }
		/* 820CB998h case    7:*/		return 0x820CB99C;
		  /* 820CB99Ch */ case    8:  		/* stw R3, <#[R30 + 68]> */
		/* 820CB99Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000044) );
		/* 820CB99Ch case    8:*/		return 0x820CB9A0;
		  /* 820CB9A0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CB9A0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB9A0h case    9:*/		return 0x820CB9A4;
		  /* 820CB9A4h */ case   10:  		/* bc 12, CR0_EQ, -384 */
		/* 820CB9A4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB9A4h case   10:*/		return 0x820CB9A8;
	}
	return 0x820CB9A8;
} // Block from 820CB97Ch-820CB9A8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CB9A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CB9A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CB9A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CB9A8);
		  /* 820CB9A8h */ case    0:  		/* lwz R11, <#[R31 + 76]> */
		/* 820CB9A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820CB9A8h case    0:*/		return 0x820CB9AC;
		  /* 820CB9ACh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CB9ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CB9ACh case    1:*/		return 0x820CB9B0;
		  /* 820CB9B0h */ case    2:  		/* bc 12, CR6_EQ, 96 */
		/* 820CB9B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CBA10;  }
		/* 820CB9B0h case    2:*/		return 0x820CB9B4;
		  /* 820CB9B4h */ case    3:  		/* li R4, 16 */
		/* 820CB9B4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820CB9B4h case    3:*/		return 0x820CB9B8;
		  /* 820CB9B8h */ case    4:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820CB9B8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820CB9B8h case    4:*/		return 0x820CB9BC;
		  /* 820CB9BCh */ case    5:  		/* bl -10204 */
		/* 820CB9BCh case    5:*/		regs.LR = 0x820CB9C0; return 0x820C91E0;
		/* 820CB9BCh case    5:*/		return 0x820CB9C0;
		  /* 820CB9C0h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820CB9C0h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB9C0h case    6:*/		return 0x820CB9C4;
		  /* 820CB9C4h */ case    7:  		/* stw R3, <#[R30 + 80]> */
		/* 820CB9C4h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000050) );
		/* 820CB9C4h case    7:*/		return 0x820CB9C8;
		  /* 820CB9C8h */ case    8:  		/* bc 12, CR0_EQ, -420 */
		/* 820CB9C8h case    8:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB9C8h case    8:*/		return 0x820CB9CC;
		  /* 820CB9CCh */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 820CB9CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CB9CCh case    9:*/		return 0x820CB9D0;
		  /* 820CB9D0h */ case   10:  		/* li R4, 16 */
		/* 820CB9D0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820CB9D0h case   10:*/		return 0x820CB9D4;
		  /* 820CB9D4h */ case   11:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820CB9D4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820CB9D4h case   11:*/		return 0x820CB9D8;
		  /* 820CB9D8h */ case   12:  		/* bl -10232 */
		/* 820CB9D8h case   12:*/		regs.LR = 0x820CB9DC; return 0x820C91E0;
		/* 820CB9D8h case   12:*/		return 0x820CB9DC;
		  /* 820CB9DCh */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 820CB9DCh case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CB9DCh case   13:*/		return 0x820CB9E0;
		  /* 820CB9E0h */ case   14:  		/* stw R3, <#[R30 + 84]> */
		/* 820CB9E0h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000054) );
		/* 820CB9E0h case   14:*/		return 0x820CB9E4;
		  /* 820CB9E4h */ case   15:  		/* bc 12, CR0_EQ, -448 */
		/* 820CB9E4h case   15:*/		if ( regs.CR[0].eq ) { return 0x820CB824;  }
		/* 820CB9E4h case   15:*/		return 0x820CB9E8;
		  /* 820CB9E8h */ case   16:  		/* lwz R11, <#[R31 + 76]> */
		/* 820CB9E8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820CB9E8h case   16:*/		return 0x820CB9EC;
		  /* 820CB9ECh */ case   17:  		/* lwz R4, <#[R31 + 80]> */
		/* 820CB9ECh case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000050) );
		/* 820CB9ECh case   17:*/		return 0x820CB9F0;
		  /* 820CB9F0h */ case   18:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820CB9F0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820CB9F0h case   18:*/		return 0x820CB9F4;
		  /* 820CB9F4h */ case   19:  		/* lwz R3, <#[R30 + 80]> */
		/* 820CB9F4h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000050) );
		/* 820CB9F4h case   19:*/		return 0x820CB9F8;
		  /* 820CB9F8h */ case   20:  		/* bl -237640 */
		/* 820CB9F8h case   20:*/		regs.LR = 0x820CB9FC; return 0x820919B0;
		/* 820CB9F8h case   20:*/		return 0x820CB9FC;
		  /* 820CB9FCh */ case   21:  		/* lwz R11, <#[R31 + 20]> */
		/* 820CB9FCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CB9FCh case   21:*/		return 0x820CBA00;
		  /* 820CBA00h */ case   22:  		/* lwz R4, <#[R31 + 84]> */
		/* 820CBA00h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000054) );
		/* 820CBA00h case   22:*/		return 0x820CBA04;
		  /* 820CBA04h */ case   23:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820CBA04h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820CBA04h case   23:*/		return 0x820CBA08;
		  /* 820CBA08h */ case   24:  		/* lwz R3, <#[R30 + 84]> */
		/* 820CBA08h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000054) );
		/* 820CBA08h case   24:*/		return 0x820CBA0C;
		  /* 820CBA0Ch */ case   25:  		/* bl -237660 */
		/* 820CBA0Ch case   25:*/		regs.LR = 0x820CBA10; return 0x820919B0;
		/* 820CBA0Ch case   25:*/		return 0x820CBA10;
	}
	return 0x820CBA10;
} // Block from 820CB9A8h-820CBA10h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820CBA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBA10);
		  /* 820CBA10h */ case    0:  		/* mr R3, R30 */
		/* 820CBA10h case    0:*/		regs.R3 = regs.R30;
		/* 820CBA10h case    0:*/		return 0x820CBA14;
	}
	return 0x820CBA14;
} // Block from 820CBA10h-820CBA14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBA14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBA14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBA14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBA14);
		  /* 820CBA14h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CBA14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CBA14h case    0:*/		return 0x820CBA18;
		  /* 820CBA18h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CBA18h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBA18h case    1:*/		return 0x820CBA1C;
		  /* 820CBA1Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CBA1Ch case    2:*/		regs.LR = regs.R12;
		/* 820CBA1Ch case    2:*/		return 0x820CBA20;
		  /* 820CBA20h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CBA20h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CBA20h case    3:*/		return 0x820CBA24;
		  /* 820CBA24h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CBA24h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CBA24h case    4:*/		return 0x820CBA28;
		  /* 820CBA28h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CBA28h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBA28h case    5:*/		return 0x820CBA2C;
	}
	return 0x820CBA2C;
} // Block from 820CBA14h-820CBA2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CBA2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBA2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBA2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBA2C);
		  /* 820CBA2Ch */ case    0:  		/* nop */
		/* 820CBA2Ch case    0:*/		cpu::op::nop();
		/* 820CBA2Ch case    0:*/		return 0x820CBA30;
		  /* 820CBA30h */ case    1:  		/* lis R10, -32255 */
		/* 820CBA30h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CBA30h case    1:*/		return 0x820CBA34;
		  /* 820CBA34h */ case    2:  		/* li R11, 0 */
		/* 820CBA34h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CBA34h case    2:*/		return 0x820CBA38;
		  /* 820CBA38h */ case    3:  		/* li R9, 12 */
		/* 820CBA38h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 820CBA38h case    3:*/		return 0x820CBA3C;
		  /* 820CBA3Ch */ case    4:  		/* addi R10, R10, 10664 */
		/* 820CBA3Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29A8);
		/* 820CBA3Ch case    4:*/		return 0x820CBA40;
		  /* 820CBA40h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820CBA40h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CBA40h case    5:*/		return 0x820CBA44;
		  /* 820CBA44h */ case    6:  		/* stw R9, <#[R3 + 4]> */
		/* 820CBA44h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CBA44h case    6:*/		return 0x820CBA48;
		  /* 820CBA48h */ case    7:  		/* stw R10, <#[R3]> */
		/* 820CBA48h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBA48h case    7:*/		return 0x820CBA4C;
		  /* 820CBA4Ch */ case    8:  		/* stw R11, <#[R3 + 12]> */
		/* 820CBA4Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CBA4Ch case    8:*/		return 0x820CBA50;
		  /* 820CBA50h */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 820CBA50h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CBA50h case    9:*/		return 0x820CBA54;
		  /* 820CBA54h */ case   10:  		/* stw R11, <#[R3 + 20]> */
		/* 820CBA54h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CBA54h case   10:*/		return 0x820CBA58;
		  /* 820CBA58h */ case   11:  		/* stw R11, <#[R3 + 24]> */
		/* 820CBA58h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CBA58h case   11:*/		return 0x820CBA5C;
		  /* 820CBA5Ch */ case   12:  		/* stw R11, <#[R3 + 28]> */
		/* 820CBA5Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CBA5Ch case   12:*/		return 0x820CBA60;
		  /* 820CBA60h */ case   13:  		/* stw R11, <#[R3 + 32]> */
		/* 820CBA60h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CBA60h case   13:*/		return 0x820CBA64;
		  /* 820CBA64h */ case   14:  		/* stw R11, <#[R3 + 36]> */
		/* 820CBA64h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CBA64h case   14:*/		return 0x820CBA68;
		  /* 820CBA68h */ case   15:  		/* stw R11, <#[R3 + 40]> */
		/* 820CBA68h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CBA68h case   15:*/		return 0x820CBA6C;
		  /* 820CBA6Ch */ case   16:  		/* stw R11, <#[R3 + 44]> */
		/* 820CBA6Ch case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CBA6Ch case   16:*/		return 0x820CBA70;
		  /* 820CBA70h */ case   17:  		/* stw R11, <#[R3 + 48]> */
		/* 820CBA70h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CBA70h case   17:*/		return 0x820CBA74;
		  /* 820CBA74h */ case   18:  		/* bclr 20, CR0_LT */
		/* 820CBA74h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBA74h case   18:*/		return 0x820CBA78;
	}
	return 0x820CBA78;
} // Block from 820CBA2Ch-820CBA78h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CBA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBA78);
		  /* 820CBA78h */ case    0:  		/* mfspr R12, LR */
		/* 820CBA78h case    0:*/		regs.R12 = regs.LR;
		/* 820CBA78h case    0:*/		return 0x820CBA7C;
		  /* 820CBA7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CBA7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBA7Ch case    1:*/		return 0x820CBA80;
		  /* 820CBA80h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CBA80h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CBA80h case    2:*/		return 0x820CBA84;
		  /* 820CBA84h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CBA84h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CBA84h case    3:*/		return 0x820CBA88;
		  /* 820CBA88h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CBA88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CBA88h case    4:*/		return 0x820CBA8C;
		  /* 820CBA8Ch */ case    5:  		/* mr R30, R3 */
		/* 820CBA8Ch case    5:*/		regs.R30 = regs.R3;
		/* 820CBA8Ch case    5:*/		return 0x820CBA90;
		  /* 820CBA90h */ case    6:  		/* mr R31, R4 */
		/* 820CBA90h case    6:*/		regs.R31 = regs.R4;
		/* 820CBA90h case    6:*/		return 0x820CBA94;
		  /* 820CBA94h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820CBA94h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CBA94h case    7:*/		return 0x820CBA98;
		  /* 820CBA98h */ case    8:  		/* bc 12, CR6_EQ, 448 */
		/* 820CBA98h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBA98h case    8:*/		return 0x820CBA9C;
		  /* 820CBA9Ch */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CBA9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CBA9Ch case    9:*/		return 0x820CBAA0;
		  /* 820CBAA0h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CBAA0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CBAA0h case   10:*/		return 0x820CBAA4;
		  /* 820CBAA4h */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CBAA4h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CBAA4h case   11:*/		return 0x820CBAA8;
		  /* 820CBAA8h */ case   12:  		/* bc 4, CR6_EQ, 432 */
		/* 820CBAA8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBAA8h case   12:*/		return 0x820CBAAC;
		  /* 820CBAACh */ case   13:  		/* lwz R11, <#[R3 + 16]> */
		/* 820CBAACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CBAACh case   13:*/		return 0x820CBAB0;
		  /* 820CBAB0h */ case   14:  		/* lwz R10, <#[R4 + 16]> */
		/* 820CBAB0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820CBAB0h case   14:*/		return 0x820CBAB4;
		  /* 820CBAB4h */ case   15:  		/* cmpw CR6, R11, R10 */
		/* 820CBAB4h case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CBAB4h case   15:*/		return 0x820CBAB8;
		  /* 820CBAB8h */ case   16:  		/* bc 4, CR6_EQ, 416 */
		/* 820CBAB8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBAB8h case   16:*/		return 0x820CBABC;
		  /* 820CBABCh */ case   17:  		/* lwz R11, <#[R3 + 48]> */
		/* 820CBABCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CBABCh case   17:*/		return 0x820CBAC0;
		  /* 820CBAC0h */ case   18:  		/* lwz R10, <#[R4 + 48]> */
		/* 820CBAC0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000030) );
		/* 820CBAC0h case   18:*/		return 0x820CBAC4;
		  /* 820CBAC4h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820CBAC4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CBAC4h case   19:*/		return 0x820CBAC8;
		  /* 820CBAC8h */ case   20:  		/* bc 4, CR6_EQ, 400 */
		/* 820CBAC8h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBAC8h case   20:*/		return 0x820CBACC;
		  /* 820CBACCh */ case   21:  		/* lwz R3, <#[R3 + 20]> */
		/* 820CBACCh case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000014) );
		/* 820CBACCh case   21:*/		return 0x820CBAD0;
		  /* 820CBAD0h */ case   22:  		/* lwz R4, <#[R4 + 20]> */
		/* 820CBAD0h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000014) );
		/* 820CBAD0h case   22:*/		return 0x820CBAD4;
		  /* 820CBAD4h */ case   23:  		/* cmplwi CR6, R3, 0 */
		/* 820CBAD4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBAD4h case   23:*/		return 0x820CBAD8;
		  /* 820CBAD8h */ case   24:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBAD8h case   24:*/		if ( regs.CR[6].eq ) { return 0x820CBAF0;  }
		/* 820CBAD8h case   24:*/		return 0x820CBADC;
		  /* 820CBADCh */ case   25:  		/* lwz R11, <#[R3]> */
		/* 820CBADCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBADCh case   25:*/		return 0x820CBAE0;
		  /* 820CBAE0h */ case   26:  		/* lwz R11, <#[R11]> */
		/* 820CBAE0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBAE0h case   26:*/		return 0x820CBAE4;
		  /* 820CBAE4h */ case   27:  		/* mtspr CTR, R11 */
		/* 820CBAE4h case   27:*/		regs.CTR = regs.R11;
		/* 820CBAE4h case   27:*/		return 0x820CBAE8;
		  /* 820CBAE8h */ case   28:  		/* bcctrl 20, CR0_LT */
		/* 820CBAE8h case   28:*/		if ( 1 ) { regs.LR = 0x820CBAEC; return (uint32)regs.CTR; }
		/* 820CBAE8h case   28:*/		return 0x820CBAEC;
		  /* 820CBAECh */ case   29:  		/* b 16 */
		/* 820CBAECh case   29:*/		return 0x820CBAFC;
		/* 820CBAECh case   29:*/		return 0x820CBAF0;
	}
	return 0x820CBAF0;
} // Block from 820CBA78h-820CBAF0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820CBAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBAF0);
		  /* 820CBAF0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBAF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBAF0h case    0:*/		return 0x820CBAF4;
		  /* 820CBAF4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBAF4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBAF4h case    1:*/		return 0x820CBAF8;
		  /* 820CBAF8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBAF8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBAF8h case    2:*/		return 0x820CBAFC;
	}
	return 0x820CBAFC;
} // Block from 820CBAF0h-820CBAFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBAFC);
		  /* 820CBAFCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CBAFCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CBAFCh case    0:*/		return 0x820CBB00;
		  /* 820CBB00h */ case    1:  		/* bc 12, CR6_EQ, 344 */
		/* 820CBB00h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBB00h case    1:*/		return 0x820CBB04;
		  /* 820CBB04h */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820CBB04h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820CBB04h case    2:*/		return 0x820CBB08;
		  /* 820CBB08h */ case    3:  		/* lwz R4, <#[R31 + 24]> */
		/* 820CBB08h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820CBB08h case    3:*/		return 0x820CBB0C;
		  /* 820CBB0Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CBB0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBB0Ch case    4:*/		return 0x820CBB10;
		  /* 820CBB10h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBB10h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CBB28;  }
		/* 820CBB10h case    5:*/		return 0x820CBB14;
		  /* 820CBB14h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CBB14h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBB14h case    6:*/		return 0x820CBB18;
		  /* 820CBB18h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CBB18h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBB18h case    7:*/		return 0x820CBB1C;
		  /* 820CBB1Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CBB1Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CBB1Ch case    8:*/		return 0x820CBB20;
		  /* 820CBB20h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CBB20h case    9:*/		if ( 1 ) { regs.LR = 0x820CBB24; return (uint32)regs.CTR; }
		/* 820CBB20h case    9:*/		return 0x820CBB24;
		  /* 820CBB24h */ case   10:  		/* b 16 */
		/* 820CBB24h case   10:*/		return 0x820CBB34;
		/* 820CBB24h case   10:*/		return 0x820CBB28;
	}
	return 0x820CBB28;
} // Block from 820CBAFCh-820CBB28h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBB28);
		  /* 820CBB28h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBB28h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBB28h case    0:*/		return 0x820CBB2C;
		  /* 820CBB2Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBB2Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBB2Ch case    1:*/		return 0x820CBB30;
		  /* 820CBB30h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBB30h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBB30h case    2:*/		return 0x820CBB34;
	}
	return 0x820CBB34;
} // Block from 820CBB28h-820CBB34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBB34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBB34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBB34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBB34);
		  /* 820CBB34h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CBB34h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CBB34h case    0:*/		return 0x820CBB38;
		  /* 820CBB38h */ case    1:  		/* bc 12, CR6_EQ, 288 */
		/* 820CBB38h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBB38h case    1:*/		return 0x820CBB3C;
		  /* 820CBB3Ch */ case    2:  		/* lwz R3, <#[R30 + 28]> */
		/* 820CBB3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CBB3Ch case    2:*/		return 0x820CBB40;
		  /* 820CBB40h */ case    3:  		/* lwz R4, <#[R31 + 28]> */
		/* 820CBB40h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CBB40h case    3:*/		return 0x820CBB44;
		  /* 820CBB44h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CBB44h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBB44h case    4:*/		return 0x820CBB48;
		  /* 820CBB48h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBB48h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CBB60;  }
		/* 820CBB48h case    5:*/		return 0x820CBB4C;
		  /* 820CBB4Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CBB4Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBB4Ch case    6:*/		return 0x820CBB50;
		  /* 820CBB50h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CBB50h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBB50h case    7:*/		return 0x820CBB54;
		  /* 820CBB54h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CBB54h case    8:*/		regs.CTR = regs.R11;
		/* 820CBB54h case    8:*/		return 0x820CBB58;
		  /* 820CBB58h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CBB58h case    9:*/		if ( 1 ) { regs.LR = 0x820CBB5C; return (uint32)regs.CTR; }
		/* 820CBB58h case    9:*/		return 0x820CBB5C;
		  /* 820CBB5Ch */ case   10:  		/* b 16 */
		/* 820CBB5Ch case   10:*/		return 0x820CBB6C;
		/* 820CBB5Ch case   10:*/		return 0x820CBB60;
	}
	return 0x820CBB60;
} // Block from 820CBB34h-820CBB60h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBB60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBB60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBB60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBB60);
		  /* 820CBB60h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBB60h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBB60h case    0:*/		return 0x820CBB64;
		  /* 820CBB64h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBB64h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBB64h case    1:*/		return 0x820CBB68;
		  /* 820CBB68h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBB68h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBB68h case    2:*/		return 0x820CBB6C;
	}
	return 0x820CBB6C;
} // Block from 820CBB60h-820CBB6Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBB6C);
		  /* 820CBB6Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CBB6Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CBB6Ch case    0:*/		return 0x820CBB70;
		  /* 820CBB70h */ case    1:  		/* bc 12, CR6_EQ, 232 */
		/* 820CBB70h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBB70h case    1:*/		return 0x820CBB74;
		  /* 820CBB74h */ case    2:  		/* lwz R3, <#[R30 + 32]> */
		/* 820CBB74h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000020) );
		/* 820CBB74h case    2:*/		return 0x820CBB78;
		  /* 820CBB78h */ case    3:  		/* lwz R4, <#[R31 + 32]> */
		/* 820CBB78h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000020) );
		/* 820CBB78h case    3:*/		return 0x820CBB7C;
		  /* 820CBB7Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CBB7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBB7Ch case    4:*/		return 0x820CBB80;
		  /* 820CBB80h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBB80h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CBB98;  }
		/* 820CBB80h case    5:*/		return 0x820CBB84;
		  /* 820CBB84h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CBB84h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBB84h case    6:*/		return 0x820CBB88;
		  /* 820CBB88h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CBB88h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBB88h case    7:*/		return 0x820CBB8C;
		  /* 820CBB8Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CBB8Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CBB8Ch case    8:*/		return 0x820CBB90;
		  /* 820CBB90h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CBB90h case    9:*/		if ( 1 ) { regs.LR = 0x820CBB94; return (uint32)regs.CTR; }
		/* 820CBB90h case    9:*/		return 0x820CBB94;
		  /* 820CBB94h */ case   10:  		/* b 16 */
		/* 820CBB94h case   10:*/		return 0x820CBBA4;
		/* 820CBB94h case   10:*/		return 0x820CBB98;
	}
	return 0x820CBB98;
} // Block from 820CBB6Ch-820CBB98h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBB98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBB98);
		  /* 820CBB98h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBB98h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBB98h case    0:*/		return 0x820CBB9C;
		  /* 820CBB9Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBB9Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBB9Ch case    1:*/		return 0x820CBBA0;
		  /* 820CBBA0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBBA0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBBA0h case    2:*/		return 0x820CBBA4;
	}
	return 0x820CBBA4;
} // Block from 820CBB98h-820CBBA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBBA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBBA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBBA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBBA4);
		  /* 820CBBA4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CBBA4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CBBA4h case    0:*/		return 0x820CBBA8;
		  /* 820CBBA8h */ case    1:  		/* bc 12, CR6_EQ, 176 */
		/* 820CBBA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBBA8h case    1:*/		return 0x820CBBAC;
		  /* 820CBBACh */ case    2:  		/* lwz R3, <#[R30 + 36]> */
		/* 820CBBACh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000024) );
		/* 820CBBACh case    2:*/		return 0x820CBBB0;
		  /* 820CBBB0h */ case    3:  		/* lwz R4, <#[R31 + 36]> */
		/* 820CBBB0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000024) );
		/* 820CBBB0h case    3:*/		return 0x820CBBB4;
		  /* 820CBBB4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CBBB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBBB4h case    4:*/		return 0x820CBBB8;
		  /* 820CBBB8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBBB8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CBBD0;  }
		/* 820CBBB8h case    5:*/		return 0x820CBBBC;
		  /* 820CBBBCh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CBBBCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBBBCh case    6:*/		return 0x820CBBC0;
		  /* 820CBBC0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CBBC0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBBC0h case    7:*/		return 0x820CBBC4;
		  /* 820CBBC4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CBBC4h case    8:*/		regs.CTR = regs.R11;
		/* 820CBBC4h case    8:*/		return 0x820CBBC8;
		  /* 820CBBC8h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CBBC8h case    9:*/		if ( 1 ) { regs.LR = 0x820CBBCC; return (uint32)regs.CTR; }
		/* 820CBBC8h case    9:*/		return 0x820CBBCC;
		  /* 820CBBCCh */ case   10:  		/* b 16 */
		/* 820CBBCCh case   10:*/		return 0x820CBBDC;
		/* 820CBBCCh case   10:*/		return 0x820CBBD0;
	}
	return 0x820CBBD0;
} // Block from 820CBBA4h-820CBBD0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBBD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBBD0);
		  /* 820CBBD0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBBD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBBD0h case    0:*/		return 0x820CBBD4;
		  /* 820CBBD4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBBD4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBBD4h case    1:*/		return 0x820CBBD8;
	}
	return 0x820CBBD8;
} // Block from 820CBBD0h-820CBBD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CBBD8h
// Function '?Copy@CNodeFunction@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBBD8);
		  /* 820CBBD8h */ case    0:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBBD8h case    0:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBBD8h case    0:*/		return 0x820CBBDC;
	}
	return 0x820CBBDC;
} // Block from 820CBBD8h-820CBBDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBBDC);
		  /* 820CBBDCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CBBDCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CBBDCh case    0:*/		return 0x820CBBE0;
		  /* 820CBBE0h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820CBBE0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBBE0h case    1:*/		return 0x820CBBE4;
		  /* 820CBBE4h */ case    2:  		/* lwz R3, <#[R30 + 40]> */
		/* 820CBBE4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000028) );
		/* 820CBBE4h case    2:*/		return 0x820CBBE8;
		  /* 820CBBE8h */ case    3:  		/* lwz R4, <#[R31 + 40]> */
		/* 820CBBE8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000028) );
		/* 820CBBE8h case    3:*/		return 0x820CBBEC;
		  /* 820CBBECh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CBBECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBBECh case    4:*/		return 0x820CBBF0;
		  /* 820CBBF0h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBBF0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CBC08;  }
		/* 820CBBF0h case    5:*/		return 0x820CBBF4;
		  /* 820CBBF4h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CBBF4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBBF4h case    6:*/		return 0x820CBBF8;
		  /* 820CBBF8h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CBBF8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBBF8h case    7:*/		return 0x820CBBFC;
		  /* 820CBBFCh */ case    8:  		/* mtspr CTR, R11 */
		/* 820CBBFCh case    8:*/		regs.CTR = regs.R11;
		/* 820CBBFCh case    8:*/		return 0x820CBC00;
		  /* 820CBC00h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CBC00h case    9:*/		if ( 1 ) { regs.LR = 0x820CBC04; return (uint32)regs.CTR; }
		/* 820CBC00h case    9:*/		return 0x820CBC04;
		  /* 820CBC04h */ case   10:  		/* b 16 */
		/* 820CBC04h case   10:*/		return 0x820CBC14;
		/* 820CBC04h case   10:*/		return 0x820CBC08;
	}
	return 0x820CBC08;
} // Block from 820CBBDCh-820CBC08h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC08);
		  /* 820CBC08h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBC08h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBC08h case    0:*/		return 0x820CBC0C;
		  /* 820CBC0Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBC0Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBC0Ch case    1:*/		return 0x820CBC10;
		  /* 820CBC10h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBC10h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBC10h case    2:*/		return 0x820CBC14;
	}
	return 0x820CBC14;
} // Block from 820CBC08h-820CBC14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC14);
		  /* 820CBC14h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CBC14h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CBC14h case    0:*/		return 0x820CBC18;
		  /* 820CBC18h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CBC18h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CBC58;  }
		/* 820CBC18h case    1:*/		return 0x820CBC1C;
		  /* 820CBC1Ch */ case    2:  		/* lwz R3, <#[R30 + 44]> */
		/* 820CBC1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 820CBC1Ch case    2:*/		return 0x820CBC20;
		  /* 820CBC20h */ case    3:  		/* lwz R4, <#[R31 + 44]> */
		/* 820CBC20h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000002C) );
		/* 820CBC20h case    3:*/		return 0x820CBC24;
		  /* 820CBC24h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CBC24h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBC24h case    4:*/		return 0x820CBC28;
		  /* 820CBC28h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBC28h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CBC40;  }
		/* 820CBC28h case    5:*/		return 0x820CBC2C;
		  /* 820CBC2Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CBC2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBC2Ch case    6:*/		return 0x820CBC30;
		  /* 820CBC30h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CBC30h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBC30h case    7:*/		return 0x820CBC34;
		  /* 820CBC34h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CBC34h case    8:*/		regs.CTR = regs.R11;
		/* 820CBC34h case    8:*/		return 0x820CBC38;
		  /* 820CBC38h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CBC38h case    9:*/		if ( 1 ) { regs.LR = 0x820CBC3C; return (uint32)regs.CTR; }
		/* 820CBC38h case    9:*/		return 0x820CBC3C;
		  /* 820CBC3Ch */ case   10:  		/* b 16 */
		/* 820CBC3Ch case   10:*/		return 0x820CBC4C;
		/* 820CBC3Ch case   10:*/		return 0x820CBC40;
	}
	return 0x820CBC40;
} // Block from 820CBC14h-820CBC40h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC40);
		  /* 820CBC40h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBC40h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBC40h case    0:*/		return 0x820CBC44;
		  /* 820CBC44h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBC44h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBC44h case    1:*/		return 0x820CBC48;
		  /* 820CBC48h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBC48h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBC48h case    2:*/		return 0x820CBC4C;
	}
	return 0x820CBC4C;
} // Block from 820CBC40h-820CBC4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC4C);
		  /* 820CBC4Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CBC4Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CBC4Ch case    0:*/		return 0x820CBC50;
		  /* 820CBC50h */ case    1:  		/* li R3, 1 */
		/* 820CBC50h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CBC50h case    1:*/		return 0x820CBC54;
		  /* 820CBC54h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CBC54h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CBC5C;  }
		/* 820CBC54h case    2:*/		return 0x820CBC58;
	}
	return 0x820CBC58;
} // Block from 820CBC4Ch-820CBC58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC58);
		  /* 820CBC58h */ case    0:  		/* li R3, 0 */
		/* 820CBC58h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CBC58h case    0:*/		return 0x820CBC5C;
	}
	return 0x820CBC5C;
} // Block from 820CBC58h-820CBC5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC5C);
		  /* 820CBC5Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820CBC5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CBC5Ch case    0:*/		return 0x820CBC60;
		  /* 820CBC60h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CBC60h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBC60h case    1:*/		return 0x820CBC64;
		  /* 820CBC64h */ case    2:  		/* mtspr LR, R12 */
		/* 820CBC64h case    2:*/		regs.LR = regs.R12;
		/* 820CBC64h case    2:*/		return 0x820CBC68;
		  /* 820CBC68h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CBC68h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CBC68h case    3:*/		return 0x820CBC6C;
		  /* 820CBC6Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CBC6Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CBC6Ch case    4:*/		return 0x820CBC70;
		  /* 820CBC70h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CBC70h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBC70h case    5:*/		return 0x820CBC74;
	}
	return 0x820CBC74;
} // Block from 820CBC5Ch-820CBC74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC74);
		  /* 820CBC74h */ case    0:  		/* nop */
		/* 820CBC74h case    0:*/		cpu::op::nop();
		/* 820CBC74h case    0:*/		return 0x820CBC78;
	}
	return 0x820CBC78;
} // Block from 820CBC74h-820CBC78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBC78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBC78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBC78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBC78);
		  /* 820CBC78h */ case    0:  		/* mfspr R12, LR */
		/* 820CBC78h case    0:*/		regs.R12 = regs.LR;
		/* 820CBC78h case    0:*/		return 0x820CBC7C;
		  /* 820CBC7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CBC7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBC7Ch case    1:*/		return 0x820CBC80;
		  /* 820CBC80h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CBC80h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CBC80h case    2:*/		return 0x820CBC84;
		  /* 820CBC84h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CBC84h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CBC84h case    3:*/		return 0x820CBC88;
		  /* 820CBC88h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CBC88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CBC88h case    4:*/		return 0x820CBC8C;
		  /* 820CBC8Ch */ case    5:  		/* mr R31, R3 */
		/* 820CBC8Ch case    5:*/		regs.R31 = regs.R3;
		/* 820CBC8Ch case    5:*/		return 0x820CBC90;
		  /* 820CBC90h */ case    6:  		/* bl 5024 */
		/* 820CBC90h case    6:*/		regs.LR = 0x820CBC94; return 0x820CD030;
		/* 820CBC90h case    6:*/		return 0x820CBC94;
		  /* 820CBC94h */ case    7:  		/* li R5, 16 */
		/* 820CBC94h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CBC94h case    7:*/		return 0x820CBC98;
		  /* 820CBC98h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CBC98h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBC98h case    8:*/		return 0x820CBC9C;
		  /* 820CBC9Ch */ case    9:  		/* li R4, 52 */
		/* 820CBC9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 820CBC9Ch case    9:*/		return 0x820CBCA0;
		  /* 820CBCA0h */ case   10:  		/* bl -11200 */
		/* 820CBCA0h case   10:*/		regs.LR = 0x820CBCA4; return 0x820C90E0;
		/* 820CBCA0h case   10:*/		return 0x820CBCA4;
		  /* 820CBCA4h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CBCA4h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBCA4h case   11:*/		return 0x820CBCA8;
		  /* 820CBCA8h */ case   12:  		/* bc 12, CR0_EQ, 80 */
		/* 820CBCA8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CBCF8;  }
		/* 820CBCA8h case   12:*/		return 0x820CBCAC;
		  /* 820CBCACh */ case   13:  		/* lis R10, -32255 */
		/* 820CBCACh case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CBCACh case   13:*/		return 0x820CBCB0;
		  /* 820CBCB0h */ case   14:  		/* li R11, 0 */
		/* 820CBCB0h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CBCB0h case   14:*/		return 0x820CBCB4;
		  /* 820CBCB4h */ case   15:  		/* li R9, 12 */
		/* 820CBCB4h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 820CBCB4h case   15:*/		return 0x820CBCB8;
		  /* 820CBCB8h */ case   16:  		/* addi R10, R10, 10664 */
		/* 820CBCB8h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29A8);
		/* 820CBCB8h case   16:*/		return 0x820CBCBC;
		  /* 820CBCBCh */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CBCBCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CBCBCh case   17:*/		return 0x820CBCC0;
		  /* 820CBCC0h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820CBCC0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CBCC0h case   18:*/		return 0x820CBCC4;
		  /* 820CBCC4h */ case   19:  		/* mr R30, R3 */
		/* 820CBCC4h case   19:*/		regs.R30 = regs.R3;
		/* 820CBCC4h case   19:*/		return 0x820CBCC8;
		  /* 820CBCC8h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CBCC8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBCC8h case   20:*/		return 0x820CBCCC;
		  /* 820CBCCCh */ case   21:  		/* stw R11, <#[R3 + 12]> */
		/* 820CBCCCh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CBCCCh case   21:*/		return 0x820CBCD0;
		  /* 820CBCD0h */ case   22:  		/* stw R11, <#[R3 + 16]> */
		/* 820CBCD0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CBCD0h case   22:*/		return 0x820CBCD4;
		  /* 820CBCD4h */ case   23:  		/* stw R11, <#[R3 + 20]> */
		/* 820CBCD4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CBCD4h case   23:*/		return 0x820CBCD8;
		  /* 820CBCD8h */ case   24:  		/* stw R11, <#[R3 + 24]> */
		/* 820CBCD8h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CBCD8h case   24:*/		return 0x820CBCDC;
		  /* 820CBCDCh */ case   25:  		/* stw R11, <#[R3 + 28]> */
		/* 820CBCDCh case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CBCDCh case   25:*/		return 0x820CBCE0;
		  /* 820CBCE0h */ case   26:  		/* stw R11, <#[R3 + 32]> */
		/* 820CBCE0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CBCE0h case   26:*/		return 0x820CBCE4;
		  /* 820CBCE4h */ case   27:  		/* stw R11, <#[R3 + 36]> */
		/* 820CBCE4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CBCE4h case   27:*/		return 0x820CBCE8;
		  /* 820CBCE8h */ case   28:  		/* stw R11, <#[R3 + 40]> */
		/* 820CBCE8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CBCE8h case   28:*/		return 0x820CBCEC;
		  /* 820CBCECh */ case   29:  		/* stw R11, <#[R3 + 44]> */
		/* 820CBCECh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CBCECh case   29:*/		return 0x820CBCF0;
		  /* 820CBCF0h */ case   30:  		/* stw R11, <#[R3 + 48]> */
		/* 820CBCF0h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CBCF0h case   30:*/		return 0x820CBCF4;
		  /* 820CBCF4h */ case   31:  		/* b 8 */
		/* 820CBCF4h case   31:*/		return 0x820CBCFC;
		/* 820CBCF4h case   31:*/		return 0x820CBCF8;
	}
	return 0x820CBCF8;
} // Block from 820CBC78h-820CBCF8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820CBCF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBCF8);
		  /* 820CBCF8h */ case    0:  		/* li R30, 0 */
		/* 820CBCF8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CBCF8h case    0:*/		return 0x820CBCFC;
	}
	return 0x820CBCFC;
} // Block from 820CBCF8h-820CBCFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBCFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBCFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBCFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBCFC);
		  /* 820CBCFCh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820CBCFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CBCFCh case    0:*/		return 0x820CBD00;
		  /* 820CBD00h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CBD00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CBD0C;  }
		/* 820CBD00h case    1:*/		return 0x820CBD04;
		  /* 820CBD04h */ case    2:  		/* li R3, 0 */
		/* 820CBD04h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CBD04h case    2:*/		return 0x820CBD08;
		  /* 820CBD08h */ case    3:  		/* b 332 */
		/* 820CBD08h case    3:*/		return 0x820CBE54;
		/* 820CBD08h case    3:*/		return 0x820CBD0C;
	}
	return 0x820CBD0C;
} // Block from 820CBCFCh-820CBD0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CBD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBD0C);
		  /* 820CBD0Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820CBD0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CBD0Ch case    0:*/		return 0x820CBD10;
		  /* 820CBD10h */ case    1:  		/* stw R11, <#[R30 + 16]> */
		/* 820CBD10h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CBD10h case    1:*/		return 0x820CBD14;
		  /* 820CBD14h */ case    2:  		/* lwz R11, <#[R31 + 48]> */
		/* 820CBD14h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820CBD14h case    2:*/		return 0x820CBD18;
		  /* 820CBD18h */ case    3:  		/* stw R11, <#[R30 + 48]> */
		/* 820CBD18h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 820CBD18h case    3:*/		return 0x820CBD1C;
		  /* 820CBD1Ch */ case    4:  		/* lwz R11, <#[R31 + 20]> */
		/* 820CBD1Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CBD1Ch case    4:*/		return 0x820CBD20;
		  /* 820CBD20h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820CBD20h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CBD20h case    5:*/		return 0x820CBD24;
		  /* 820CBD24h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 820CBD24h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CBD48;  }
		/* 820CBD24h case    6:*/		return 0x820CBD28;
		  /* 820CBD28h */ case    7:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CBD28h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CBD28h case    7:*/		return 0x820CBD2C;
		  /* 820CBD2Ch */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820CBD2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBD2Ch case    8:*/		return 0x820CBD30;
		  /* 820CBD30h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CBD30h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CBD30h case    9:*/		return 0x820CBD34;
		  /* 820CBD34h */ case   10:  		/* mtspr CTR, R11 */
		/* 820CBD34h case   10:*/		regs.CTR = regs.R11;
		/* 820CBD34h case   10:*/		return 0x820CBD38;
		  /* 820CBD38h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820CBD38h case   11:*/		if ( 1 ) { regs.LR = 0x820CBD3C; return (uint32)regs.CTR; }
		/* 820CBD38h case   11:*/		return 0x820CBD3C;
		  /* 820CBD3Ch */ case   12:  		/* stw R3, <#[R30 + 20]> */
		/* 820CBD3Ch case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 820CBD3Ch case   12:*/		return 0x820CBD40;
		  /* 820CBD40h */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 820CBD40h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBD40h case   13:*/		return 0x820CBD44;
		  /* 820CBD44h */ case   14:  		/* bc 12, CR0_EQ, -64 */
		/* 820CBD44h case   14:*/		if ( regs.CR[0].eq ) { return 0x820CBD04;  }
		/* 820CBD44h case   14:*/		return 0x820CBD48;
	}
	return 0x820CBD48;
} // Block from 820CBD0Ch-820CBD48h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820CBD48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBD48);
		  /* 820CBD48h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820CBD48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CBD48h case    0:*/		return 0x820CBD4C;
		  /* 820CBD4Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CBD4Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CBD4Ch case    1:*/		return 0x820CBD50;
		  /* 820CBD50h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CBD50h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CBD74;  }
		/* 820CBD50h case    2:*/		return 0x820CBD54;
		  /* 820CBD54h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CBD54h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CBD54h case    3:*/		return 0x820CBD58;
		  /* 820CBD58h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CBD58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBD58h case    4:*/		return 0x820CBD5C;
		  /* 820CBD5Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CBD5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CBD5Ch case    5:*/		return 0x820CBD60;
		  /* 820CBD60h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CBD60h case    6:*/		regs.CTR = regs.R11;
		/* 820CBD60h case    6:*/		return 0x820CBD64;
		  /* 820CBD64h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CBD64h case    7:*/		if ( 1 ) { regs.LR = 0x820CBD68; return (uint32)regs.CTR; }
		/* 820CBD64h case    7:*/		return 0x820CBD68;
		  /* 820CBD68h */ case    8:  		/* stw R3, <#[R30 + 24]> */
		/* 820CBD68h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820CBD68h case    8:*/		return 0x820CBD6C;
		  /* 820CBD6Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CBD6Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBD6Ch case    9:*/		return 0x820CBD70;
		  /* 820CBD70h */ case   10:  		/* bc 12, CR0_EQ, -108 */
		/* 820CBD70h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CBD04;  }
		/* 820CBD70h case   10:*/		return 0x820CBD74;
	}
	return 0x820CBD74;
} // Block from 820CBD48h-820CBD74h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBD74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBD74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBD74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBD74);
		  /* 820CBD74h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 820CBD74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CBD74h case    0:*/		return 0x820CBD78;
		  /* 820CBD78h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CBD78h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CBD78h case    1:*/		return 0x820CBD7C;
		  /* 820CBD7Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CBD7Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CBDA0;  }
		/* 820CBD7Ch case    2:*/		return 0x820CBD80;
		  /* 820CBD80h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CBD80h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CBD80h case    3:*/		return 0x820CBD84;
		  /* 820CBD84h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CBD84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBD84h case    4:*/		return 0x820CBD88;
		  /* 820CBD88h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CBD88h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CBD88h case    5:*/		return 0x820CBD8C;
		  /* 820CBD8Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820CBD8Ch case    6:*/		regs.CTR = regs.R11;
		/* 820CBD8Ch case    6:*/		return 0x820CBD90;
		  /* 820CBD90h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CBD90h case    7:*/		if ( 1 ) { regs.LR = 0x820CBD94; return (uint32)regs.CTR; }
		/* 820CBD90h case    7:*/		return 0x820CBD94;
		  /* 820CBD94h */ case    8:  		/* stw R3, <#[R30 + 28]> */
		/* 820CBD94h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CBD94h case    8:*/		return 0x820CBD98;
		  /* 820CBD98h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CBD98h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBD98h case    9:*/		return 0x820CBD9C;
		  /* 820CBD9Ch */ case   10:  		/* bc 12, CR0_EQ, -152 */
		/* 820CBD9Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820CBD04;  }
		/* 820CBD9Ch case   10:*/		return 0x820CBDA0;
	}
	return 0x820CBDA0;
} // Block from 820CBD74h-820CBDA0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBDA0);
		  /* 820CBDA0h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 820CBDA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820CBDA0h case    0:*/		return 0x820CBDA4;
		  /* 820CBDA4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CBDA4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CBDA4h case    1:*/		return 0x820CBDA8;
		  /* 820CBDA8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CBDA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CBDCC;  }
		/* 820CBDA8h case    2:*/		return 0x820CBDAC;
		  /* 820CBDACh */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CBDACh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CBDACh case    3:*/		return 0x820CBDB0;
		  /* 820CBDB0h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CBDB0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBDB0h case    4:*/		return 0x820CBDB4;
		  /* 820CBDB4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CBDB4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CBDB4h case    5:*/		return 0x820CBDB8;
		  /* 820CBDB8h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CBDB8h case    6:*/		regs.CTR = regs.R11;
		/* 820CBDB8h case    6:*/		return 0x820CBDBC;
		  /* 820CBDBCh */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CBDBCh case    7:*/		if ( 1 ) { regs.LR = 0x820CBDC0; return (uint32)regs.CTR; }
		/* 820CBDBCh case    7:*/		return 0x820CBDC0;
		  /* 820CBDC0h */ case    8:  		/* stw R3, <#[R30 + 32]> */
		/* 820CBDC0h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000020) );
		/* 820CBDC0h case    8:*/		return 0x820CBDC4;
		  /* 820CBDC4h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CBDC4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBDC4h case    9:*/		return 0x820CBDC8;
		  /* 820CBDC8h */ case   10:  		/* bc 12, CR0_EQ, -196 */
		/* 820CBDC8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CBD04;  }
		/* 820CBDC8h case   10:*/		return 0x820CBDCC;
	}
	return 0x820CBDCC;
} // Block from 820CBDA0h-820CBDCCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBDCC);
		  /* 820CBDCCh */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 820CBDCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820CBDCCh case    0:*/		return 0x820CBDD0;
		  /* 820CBDD0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CBDD0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CBDD0h case    1:*/		return 0x820CBDD4;
		  /* 820CBDD4h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CBDD4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CBDF8;  }
		/* 820CBDD4h case    2:*/		return 0x820CBDD8;
		  /* 820CBDD8h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CBDD8h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CBDD8h case    3:*/		return 0x820CBDDC;
		  /* 820CBDDCh */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CBDDCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBDDCh case    4:*/		return 0x820CBDE0;
		  /* 820CBDE0h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CBDE0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CBDE0h case    5:*/		return 0x820CBDE4;
		  /* 820CBDE4h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CBDE4h case    6:*/		regs.CTR = regs.R11;
		/* 820CBDE4h case    6:*/		return 0x820CBDE8;
		  /* 820CBDE8h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CBDE8h case    7:*/		if ( 1 ) { regs.LR = 0x820CBDEC; return (uint32)regs.CTR; }
		/* 820CBDE8h case    7:*/		return 0x820CBDEC;
		  /* 820CBDECh */ case    8:  		/* stw R3, <#[R30 + 36]> */
		/* 820CBDECh case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000024) );
		/* 820CBDECh case    8:*/		return 0x820CBDF0;
		  /* 820CBDF0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CBDF0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBDF0h case    9:*/		return 0x820CBDF4;
		  /* 820CBDF4h */ case   10:  		/* bc 12, CR0_EQ, -240 */
		/* 820CBDF4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CBD04;  }
		/* 820CBDF4h case   10:*/		return 0x820CBDF8;
	}
	return 0x820CBDF8;
} // Block from 820CBDCCh-820CBDF8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBDF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBDF8);
		  /* 820CBDF8h */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 820CBDF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820CBDF8h case    0:*/		return 0x820CBDFC;
		  /* 820CBDFCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CBDFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CBDFCh case    1:*/		return 0x820CBE00;
		  /* 820CBE00h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CBE00h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CBE24;  }
		/* 820CBE00h case    2:*/		return 0x820CBE04;
		  /* 820CBE04h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CBE04h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CBE04h case    3:*/		return 0x820CBE08;
		  /* 820CBE08h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CBE08h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBE08h case    4:*/		return 0x820CBE0C;
		  /* 820CBE0Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CBE0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CBE0Ch case    5:*/		return 0x820CBE10;
		  /* 820CBE10h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CBE10h case    6:*/		regs.CTR = regs.R11;
		/* 820CBE10h case    6:*/		return 0x820CBE14;
		  /* 820CBE14h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CBE14h case    7:*/		if ( 1 ) { regs.LR = 0x820CBE18; return (uint32)regs.CTR; }
		/* 820CBE14h case    7:*/		return 0x820CBE18;
		  /* 820CBE18h */ case    8:  		/* stw R3, <#[R30 + 40]> */
		/* 820CBE18h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000028) );
		/* 820CBE18h case    8:*/		return 0x820CBE1C;
		  /* 820CBE1Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CBE1Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBE1Ch case    9:*/		return 0x820CBE20;
		  /* 820CBE20h */ case   10:  		/* bc 12, CR0_EQ, -284 */
		/* 820CBE20h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CBD04;  }
		/* 820CBE20h case   10:*/		return 0x820CBE24;
	}
	return 0x820CBE24;
} // Block from 820CBDF8h-820CBE24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBE24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBE24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBE24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBE24);
		  /* 820CBE24h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 820CBE24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820CBE24h case    0:*/		return 0x820CBE28;
		  /* 820CBE28h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CBE28h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CBE28h case    1:*/		return 0x820CBE2C;
		  /* 820CBE2Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CBE2Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CBE50;  }
		/* 820CBE2Ch case    2:*/		return 0x820CBE30;
		  /* 820CBE30h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CBE30h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CBE30h case    3:*/		return 0x820CBE34;
		  /* 820CBE34h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CBE34h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBE34h case    4:*/		return 0x820CBE38;
		  /* 820CBE38h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CBE38h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CBE38h case    5:*/		return 0x820CBE3C;
		  /* 820CBE3Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820CBE3Ch case    6:*/		regs.CTR = regs.R11;
		/* 820CBE3Ch case    6:*/		return 0x820CBE40;
		  /* 820CBE40h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CBE40h case    7:*/		if ( 1 ) { regs.LR = 0x820CBE44; return (uint32)regs.CTR; }
		/* 820CBE40h case    7:*/		return 0x820CBE44;
		  /* 820CBE44h */ case    8:  		/* stw R3, <#[R30 + 44]> */
		/* 820CBE44h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 820CBE44h case    8:*/		return 0x820CBE48;
		  /* 820CBE48h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CBE48h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CBE48h case    9:*/		return 0x820CBE4C;
		  /* 820CBE4Ch */ case   10:  		/* bc 12, CR0_EQ, -328 */
		/* 820CBE4Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820CBD04;  }
		/* 820CBE4Ch case   10:*/		return 0x820CBE50;
	}
	return 0x820CBE50;
} // Block from 820CBE24h-820CBE50h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CBE50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBE50);
		  /* 820CBE50h */ case    0:  		/* mr R3, R30 */
		/* 820CBE50h case    0:*/		regs.R3 = regs.R30;
		/* 820CBE50h case    0:*/		return 0x820CBE54;
	}
	return 0x820CBE54;
} // Block from 820CBE50h-820CBE54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBE54);
		  /* 820CBE54h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CBE54h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CBE54h case    0:*/		return 0x820CBE58;
		  /* 820CBE58h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CBE58h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBE58h case    1:*/		return 0x820CBE5C;
		  /* 820CBE5Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CBE5Ch case    2:*/		regs.LR = regs.R12;
		/* 820CBE5Ch case    2:*/		return 0x820CBE60;
		  /* 820CBE60h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CBE60h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CBE60h case    3:*/		return 0x820CBE64;
		  /* 820CBE64h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CBE64h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CBE64h case    4:*/		return 0x820CBE68;
	}
	return 0x820CBE68;
} // Block from 820CBE54h-820CBE68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CBE68h
// Function '??0CNodeVariable@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBE68);
		  /* 820CBE68h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820CBE68h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBE68h case    0:*/		return 0x820CBE6C;
	}
	return 0x820CBE6C;
} // Block from 820CBE68h-820CBE6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBE6C);
		  /* 820CBE6Ch */ case    0:  		/* nop */
		/* 820CBE6Ch case    0:*/		cpu::op::nop();
		/* 820CBE6Ch case    0:*/		return 0x820CBE70;
		  /* 820CBE70h */ case    1:  		/* lis R10, -32255 */
		/* 820CBE70h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CBE70h case    1:*/		return 0x820CBE74;
		  /* 820CBE74h */ case    2:  		/* li R11, 0 */
		/* 820CBE74h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CBE74h case    2:*/		return 0x820CBE78;
		  /* 820CBE78h */ case    3:  		/* li R9, 13 */
		/* 820CBE78h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xD);
		/* 820CBE78h case    3:*/		return 0x820CBE7C;
		  /* 820CBE7Ch */ case    4:  		/* addi R10, R10, 10676 */
		/* 820CBE7Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29B4);
		/* 820CBE7Ch case    4:*/		return 0x820CBE80;
		  /* 820CBE80h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820CBE80h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CBE80h case    5:*/		return 0x820CBE84;
		  /* 820CBE84h */ case    6:  		/* stw R9, <#[R3 + 4]> */
		/* 820CBE84h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CBE84h case    6:*/		return 0x820CBE88;
		  /* 820CBE88h */ case    7:  		/* stw R10, <#[R3]> */
		/* 820CBE88h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBE88h case    7:*/		return 0x820CBE8C;
		  /* 820CBE8Ch */ case    8:  		/* stw R11, <#[R3 + 12]> */
		/* 820CBE8Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CBE8Ch case    8:*/		return 0x820CBE90;
		  /* 820CBE90h */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 820CBE90h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CBE90h case    9:*/		return 0x820CBE94;
		  /* 820CBE94h */ case   10:  		/* stw R11, <#[R3 + 20]> */
		/* 820CBE94h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CBE94h case   10:*/		return 0x820CBE98;
		  /* 820CBE98h */ case   11:  		/* bclr 20, CR0_LT */
		/* 820CBE98h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBE98h case   11:*/		return 0x820CBE9C;
	}
	return 0x820CBE9C;
} // Block from 820CBE6Ch-820CBE9Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CBE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBE9C);
		  /* 820CBE9Ch */ case    0:  		/* nop */
		/* 820CBE9Ch case    0:*/		cpu::op::nop();
		/* 820CBE9Ch case    0:*/		return 0x820CBEA0;
	}
	return 0x820CBEA0;
} // Block from 820CBE9Ch-820CBEA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBEA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBEA0);
		  /* 820CBEA0h */ case    0:  		/* mfspr R12, LR */
		/* 820CBEA0h case    0:*/		regs.R12 = regs.LR;
		/* 820CBEA0h case    0:*/		return 0x820CBEA4;
		  /* 820CBEA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CBEA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBEA4h case    1:*/		return 0x820CBEA8;
		  /* 820CBEA8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CBEA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CBEA8h case    2:*/		return 0x820CBEAC;
		  /* 820CBEACh */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820CBEACh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CBEACh case    3:*/		return 0x820CBEB0;
		  /* 820CBEB0h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 820CBEB0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CBEC4;  }
		/* 820CBEB0h case    4:*/		return 0x820CBEB4;
		  /* 820CBEB4h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CBEB4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CBEB4h case    5:*/		return 0x820CBEB8;
		  /* 820CBEB8h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CBEB8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CBEB8h case    6:*/		return 0x820CBEBC;
		  /* 820CBEBCh */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820CBEBCh case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CBEBCh case    7:*/		return 0x820CBEC0;
		  /* 820CBEC0h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820CBEC0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CBECC;  }
		/* 820CBEC0h case    8:*/		return 0x820CBEC4;
	}
	return 0x820CBEC4;
} // Block from 820CBEA0h-820CBEC4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CBEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBEC4);
		  /* 820CBEC4h */ case    0:  		/* li R3, 0 */
		/* 820CBEC4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CBEC4h case    0:*/		return 0x820CBEC8;
		  /* 820CBEC8h */ case    1:  		/* b 76 */
		/* 820CBEC8h case    1:*/		return 0x820CBF14;
		/* 820CBEC8h case    1:*/		return 0x820CBECC;
	}
	return 0x820CBECC;
} // Block from 820CBEC4h-820CBECCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CBECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBECC);
		  /* 820CBECCh */ case    0:  		/* lwz R11, <#[R3 + 16]> */
		/* 820CBECCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CBECCh case    0:*/		return 0x820CBED0;
		  /* 820CBED0h */ case    1:  		/* lwz R10, <#[R4 + 16]> */
		/* 820CBED0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820CBED0h case    1:*/		return 0x820CBED4;
		  /* 820CBED4h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 820CBED4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CBED4h case    2:*/		return 0x820CBED8;
	}
	return 0x820CBED8;
} // Block from 820CBECCh-820CBED8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBED8h
// Function '?IsEqual@CNodeVariable@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBED8);
		  /* 820CBED8h */ case    0:  		/* bc 4, CR6_EQ, -20 */
		/* 820CBED8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820CBEC4;  }
		/* 820CBED8h case    0:*/		return 0x820CBEDC;
		  /* 820CBEDCh */ case    1:  		/* lwz R3, <#[R3 + 20]> */
		/* 820CBEDCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000014) );
		/* 820CBEDCh case    1:*/		return 0x820CBEE0;
		  /* 820CBEE0h */ case    2:  		/* lwz R4, <#[R4 + 20]> */
		/* 820CBEE0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000014) );
		/* 820CBEE0h case    2:*/		return 0x820CBEE4;
		  /* 820CBEE4h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820CBEE4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CBEE4h case    3:*/		return 0x820CBEE8;
		  /* 820CBEE8h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820CBEE8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CBF00;  }
		/* 820CBEE8h case    4:*/		return 0x820CBEEC;
		  /* 820CBEECh */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820CBEECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBEECh case    5:*/		return 0x820CBEF0;
		  /* 820CBEF0h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820CBEF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CBEF0h case    6:*/		return 0x820CBEF4;
		  /* 820CBEF4h */ case    7:  		/* mtspr CTR, R11 */
		/* 820CBEF4h case    7:*/		regs.CTR = regs.R11;
		/* 820CBEF4h case    7:*/		return 0x820CBEF8;
		  /* 820CBEF8h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820CBEF8h case    8:*/		if ( 1 ) { regs.LR = 0x820CBEFC; return (uint32)regs.CTR; }
		/* 820CBEF8h case    8:*/		return 0x820CBEFC;
		  /* 820CBEFCh */ case    9:  		/* b 16 */
		/* 820CBEFCh case    9:*/		return 0x820CBF0C;
		/* 820CBEFCh case    9:*/		return 0x820CBF00;
	}
	return 0x820CBF00;
} // Block from 820CBED8h-820CBF00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CBF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBF00);
		  /* 820CBF00h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CBF00h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CBF00h case    0:*/		return 0x820CBF04;
		  /* 820CBF04h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CBF04h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CBF04h case    1:*/		return 0x820CBF08;
		  /* 820CBF08h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CBF08h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CBF08h case    2:*/		return 0x820CBF0C;
	}
	return 0x820CBF0C;
} // Block from 820CBF00h-820CBF0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CBF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBF0C);
		  /* 820CBF0Ch */ case    0:  		/* addic R11, R3, -1 */
		/* 820CBF0Ch case    0:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820CBF0Ch case    0:*/		return 0x820CBF10;
		  /* 820CBF10h */ case    1:  		/* subfe R3, R11, R3 */
		/* 820CBF10h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820CBF10h case    1:*/		return 0x820CBF14;
	}
	return 0x820CBF14;
} // Block from 820CBF0Ch-820CBF14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CBF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBF14);
		  /* 820CBF14h */ case    0:  		/* addi R1, R1, 96 */
		/* 820CBF14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CBF14h case    0:*/		return 0x820CBF18;
		  /* 820CBF18h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CBF18h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBF18h case    1:*/		return 0x820CBF1C;
		  /* 820CBF1Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CBF1Ch case    2:*/		regs.LR = regs.R12;
		/* 820CBF1Ch case    2:*/		return 0x820CBF20;
		  /* 820CBF20h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CBF20h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBF20h case    3:*/		return 0x820CBF24;
	}
	return 0x820CBF24;
} // Block from 820CBF14h-820CBF24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CBF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBF24);
		  /* 820CBF24h */ case    0:  		/* nop */
		/* 820CBF24h case    0:*/		cpu::op::nop();
		/* 820CBF24h case    0:*/		return 0x820CBF28;
		  /* 820CBF28h */ case    1:  		/* lis R10, -32255 */
		/* 820CBF28h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CBF28h case    1:*/		return 0x820CBF2C;
		  /* 820CBF2Ch */ case    2:  		/* li R11, 0 */
		/* 820CBF2Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CBF2Ch case    2:*/		return 0x820CBF30;
		  /* 820CBF30h */ case    3:  		/* li R9, 14 */
		/* 820CBF30h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xE);
		/* 820CBF30h case    3:*/		return 0x820CBF34;
		  /* 820CBF34h */ case    4:  		/* addi R10, R10, 10688 */
		/* 820CBF34h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29C0);
		/* 820CBF34h case    4:*/		return 0x820CBF38;
		  /* 820CBF38h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820CBF38h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CBF38h case    5:*/		return 0x820CBF3C;
		  /* 820CBF3Ch */ case    6:  		/* li R8, 1 */
		/* 820CBF3Ch case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820CBF3Ch case    6:*/		return 0x820CBF40;
		  /* 820CBF40h */ case    7:  		/* stw R9, <#[R3 + 4]> */
		/* 820CBF40h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CBF40h case    7:*/		return 0x820CBF44;
		  /* 820CBF44h */ case    8:  		/* stw R10, <#[R3]> */
		/* 820CBF44h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBF44h case    8:*/		return 0x820CBF48;
		  /* 820CBF48h */ case    9:  		/* stw R11, <#[R3 + 12]> */
		/* 820CBF48h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CBF48h case    9:*/		return 0x820CBF4C;
		  /* 820CBF4Ch */ case   10:  		/* stw R11, <#[R3 + 16]> */
		/* 820CBF4Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CBF4Ch case   10:*/		return 0x820CBF50;
		  /* 820CBF50h */ case   11:  		/* stw R11, <#[R3 + 20]> */
		/* 820CBF50h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CBF50h case   11:*/		return 0x820CBF54;
		  /* 820CBF54h */ case   12:  		/* stw R11, <#[R3 + 24]> */
		/* 820CBF54h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CBF54h case   12:*/		return 0x820CBF58;
		  /* 820CBF58h */ case   13:  		/* stw R11, <#[R3 + 28]> */
		/* 820CBF58h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CBF58h case   13:*/		return 0x820CBF5C;
		  /* 820CBF5Ch */ case   14:  		/* stw R11, <#[R3 + 32]> */
		/* 820CBF5Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CBF5Ch case   14:*/		return 0x820CBF60;
		  /* 820CBF60h */ case   15:  		/* stw R11, <#[R3 + 36]> */
		/* 820CBF60h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CBF60h case   15:*/		return 0x820CBF64;
		  /* 820CBF64h */ case   16:  		/* stw R8, <#[R3 + 40]> */
		/* 820CBF64h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000028) );
		/* 820CBF64h case   16:*/		return 0x820CBF68;
		  /* 820CBF68h */ case   17:  		/* stw R11, <#[R3 + 44]> */
		/* 820CBF68h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CBF68h case   17:*/		return 0x820CBF6C;
		  /* 820CBF6Ch */ case   18:  		/* std R11, <#[R3 + 48]> */
		/* 820CBF6Ch case   18:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CBF6Ch case   18:*/		return 0x820CBF70;
		  /* 820CBF70h */ case   19:  		/* std R11, <#[R3 + 56]> */
		/* 820CBF70h case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CBF70h case   19:*/		return 0x820CBF74;
		  /* 820CBF74h */ case   20:  		/* std R11, <#[R3 + 64]> */
		/* 820CBF74h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CBF74h case   20:*/		return 0x820CBF78;
		  /* 820CBF78h */ case   21:  		/* std R11, <#[R3 + 72]> */
		/* 820CBF78h case   21:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 820CBF78h case   21:*/		return 0x820CBF7C;
		  /* 820CBF7Ch */ case   22:  		/* std R11, <#[R3 + 80]> */
		/* 820CBF7Ch case   22:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 820CBF7Ch case   22:*/		return 0x820CBF80;
		  /* 820CBF80h */ case   23:  		/* bclr 20, CR0_LT */
		/* 820CBF80h case   23:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBF80h case   23:*/		return 0x820CBF84;
	}
	return 0x820CBF84;
} // Block from 820CBF24h-820CBF84h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820CBF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBF84);
		  /* 820CBF84h */ case    0:  		/* nop */
		/* 820CBF84h case    0:*/		cpu::op::nop();
		/* 820CBF84h case    0:*/		return 0x820CBF88;
	}
	return 0x820CBF88;
} // Block from 820CBF84h-820CBF88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBF88);
		  /* 820CBF88h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 820CBF88h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBF88h case    0:*/		return 0x820CBF8C;
		  /* 820CBF8Ch */ case    1:  		/* lis R31, -32255 */
		/* 820CBF8Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820CBF8Ch case    1:*/		return 0x820CBF90;
		  /* 820CBF90h */ case    2:  		/* stw R5, <#[R3 + 28]> */
		/* 820CBF90h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CBF90h case    2:*/		return 0x820CBF94;
		  /* 820CBF94h */ case    3:  		/* li R10, 5 */
		/* 820CBF94h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820CBF94h case    3:*/		return 0x820CBF98;
		  /* 820CBF98h */ case    4:  		/* stw R6, <#[R3 + 32]> */
		/* 820CBF98h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820CBF98h case    4:*/		return 0x820CBF9C;
		  /* 820CBF9Ch */ case    5:  		/* li R11, 0 */
		/* 820CBF9Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CBF9Ch case    5:*/		return 0x820CBFA0;
		  /* 820CBFA0h */ case    6:  		/* stw R7, <#[R3 + 36]> */
		/* 820CBFA0h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000024) );
		/* 820CBFA0h case    6:*/		return 0x820CBFA4;
		  /* 820CBFA4h */ case    7:  		/* addi R5, R31, 10688 */
		/* 820CBFA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x29C0);
		/* 820CBFA4h case    7:*/		return 0x820CBFA8;
		  /* 820CBFA8h */ case    8:  		/* stw R4, <#[R3 + 16]> */
		/* 820CBFA8h case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CBFA8h case    8:*/		return 0x820CBFAC;
		  /* 820CBFACh */ case    9:  		/* li R6, 14 */
		/* 820CBFACh case    9:*/		cpu::op::li<0>(regs,&regs.R6,0xE);
		/* 820CBFACh case    9:*/		return 0x820CBFB0;
		  /* 820CBFB0h */ case   10:  		/* stw R11, <#[R3 + 8]> */
		/* 820CBFB0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CBFB0h case   10:*/		return 0x820CBFB4;
		  /* 820CBFB4h */ case   11:  		/* stw R11, <#[R3 + 12]> */
		/* 820CBFB4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CBFB4h case   11:*/		return 0x820CBFB8;
		  /* 820CBFB8h */ case   12:  		/* addi R7, R3, 40 */
		/* 820CBFB8h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R3,0x28);
		/* 820CBFB8h case   12:*/		return 0x820CBFBC;
		  /* 820CBFBCh */ case   13:  		/* stw R11, <#[R3 + 20]> */
		/* 820CBFBCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CBFBCh case   13:*/		return 0x820CBFC0;
		  /* 820CBFC0h */ case   14:  		/* mtspr CTR, R10 */
		/* 820CBFC0h case   14:*/		regs.CTR = regs.R10;
		/* 820CBFC0h case   14:*/		return 0x820CBFC4;
		  /* 820CBFC4h */ case   15:  		/* stw R11, <#[R3 + 24]> */
		/* 820CBFC4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CBFC4h case   15:*/		return 0x820CBFC8;
		  /* 820CBFC8h */ case   16:  		/* addi R11, R9, -8 */
		/* 820CBFC8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFF8);
		/* 820CBFC8h case   16:*/		return 0x820CBFCC;
		  /* 820CBFCCh */ case   17:  		/* stw R5, <#[R3]> */
		/* 820CBFCCh case   17:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000000) );
		/* 820CBFCCh case   17:*/		return 0x820CBFD0;
		  /* 820CBFD0h */ case   18:  		/* stw R6, <#[R3 + 4]> */
		/* 820CBFD0h case   18:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		/* 820CBFD0h case   18:*/		return 0x820CBFD4;
		  /* 820CBFD4h */ case   19:  		/* stw R8, <#[R3 + 40]> */
		/* 820CBFD4h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000028) );
		/* 820CBFD4h case   19:*/		return 0x820CBFD8;
		  /* 820CBFD8h */ case   20:  		/* ldu R10, <#[R11 + 8]> */
		/* 820CBFD8h case   20:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 820CBFD8h case   20:*/		return 0x820CBFDC;
		  /* 820CBFDCh */ case   21:  		/* stdu R10, <#[R7 + 8]> */
		/* 820CBFDCh case   21:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R7 + 0x00000008) );
		regs.R7 = (uint32)(regs.R7 + 0x00000008);
		/* 820CBFDCh case   21:*/		return 0x820CBFE0;
		  /* 820CBFE0h */ case   22:  		/* bc 16, CR0_LT, -8 */
		/* 820CBFE0h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CBFD8;  }
		/* 820CBFE0h case   22:*/		return 0x820CBFE4;
		  /* 820CBFE4h */ case   23:  		/* ld R31, <#[R1 - 8]> */
		/* 820CBFE4h case   23:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBFE4h case   23:*/		return 0x820CBFE8;
		  /* 820CBFE8h */ case   24:  		/* bclr 20, CR0_LT */
		/* 820CBFE8h case   24:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CBFE8h case   24:*/		return 0x820CBFEC;
	}
	return 0x820CBFEC;
} // Block from 820CBF88h-820CBFECh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820CBFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBFEC);
		  /* 820CBFECh */ case    0:  		/* nop */
		/* 820CBFECh case    0:*/		cpu::op::nop();
		/* 820CBFECh case    0:*/		return 0x820CBFF0;
	}
	return 0x820CBFF0;
} // Block from 820CBFECh-820CBFF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CBFF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CBFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CBFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CBFF0);
		  /* 820CBFF0h */ case    0:  		/* mfspr R12, LR */
		/* 820CBFF0h case    0:*/		regs.R12 = regs.LR;
		/* 820CBFF0h case    0:*/		return 0x820CBFF4;
		  /* 820CBFF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CBFF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CBFF4h case    1:*/		return 0x820CBFF8;
		  /* 820CBFF8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CBFF8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CBFF8h case    2:*/		return 0x820CBFFC;
		  /* 820CBFFCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CBFFCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CBFFCh case    3:*/		return 0x820CC000;
		  /* 820CC000h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CC000h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CC000h case    4:*/		return 0x820CC004;
		  /* 820CC004h */ case    5:  		/* mr R30, R3 */
		/* 820CC004h case    5:*/		regs.R30 = regs.R3;
		/* 820CC004h case    5:*/		return 0x820CC008;
		  /* 820CC008h */ case    6:  		/* mr R31, R4 */
		/* 820CC008h case    6:*/		regs.R31 = regs.R4;
		/* 820CC008h case    6:*/		return 0x820CC00C;
		  /* 820CC00Ch */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820CC00Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CC00Ch case    7:*/		return 0x820CC010;
		  /* 820CC010h */ case    8:  		/* bc 12, CR6_EQ, 292 */
		/* 820CC010h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC010h case    8:*/		return 0x820CC014;
		  /* 820CC014h */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CC014h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CC014h case    9:*/		return 0x820CC018;
		  /* 820CC018h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CC018h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC018h case   10:*/		return 0x820CC01C;
		  /* 820CC01Ch */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CC01Ch case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CC01Ch case   11:*/		return 0x820CC020;
		  /* 820CC020h */ case   12:  		/* bc 4, CR6_EQ, 276 */
		/* 820CC020h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC020h case   12:*/		return 0x820CC024;
		  /* 820CC024h */ case   13:  		/* lwz R11, <#[R3 + 20]> */
		/* 820CC024h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CC024h case   13:*/		return 0x820CC028;
		  /* 820CC028h */ case   14:  		/* lwz R10, <#[R4 + 20]> */
		/* 820CC028h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820CC028h case   14:*/		return 0x820CC02C;
		  /* 820CC02Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820CC02Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CC02Ch case   15:*/		return 0x820CC030;
		  /* 820CC030h */ case   16:  		/* bc 4, CR6_EQ, 260 */
		/* 820CC030h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC030h case   16:*/		return 0x820CC034;
		  /* 820CC034h */ case   17:  		/* lwz R11, <#[R3 + 24]> */
		/* 820CC034h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC034h case   17:*/		return 0x820CC038;
		  /* 820CC038h */ case   18:  		/* lwz R10, <#[R4 + 24]> */
		/* 820CC038h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820CC038h case   18:*/		return 0x820CC03C;
		  /* 820CC03Ch */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820CC03Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CC03Ch case   19:*/		return 0x820CC040;
		  /* 820CC040h */ case   20:  		/* bc 4, CR6_EQ, 244 */
		/* 820CC040h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC040h case   20:*/		return 0x820CC044;
		  /* 820CC044h */ case   21:  		/* lwz R11, <#[R3 + 28]> */
		/* 820CC044h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CC044h case   21:*/		return 0x820CC048;
		  /* 820CC048h */ case   22:  		/* lwz R10, <#[R4 + 28]> */
		/* 820CC048h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 820CC048h case   22:*/		return 0x820CC04C;
		  /* 820CC04Ch */ case   23:  		/* cmpw CR6, R11, R10 */
		/* 820CC04Ch case   23:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CC04Ch case   23:*/		return 0x820CC050;
		  /* 820CC050h */ case   24:  		/* bc 4, CR6_EQ, 228 */
		/* 820CC050h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC050h case   24:*/		return 0x820CC054;
		  /* 820CC054h */ case   25:  		/* lwz R11, <#[R3 + 40]> */
		/* 820CC054h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CC054h case   25:*/		return 0x820CC058;
		  /* 820CC058h */ case   26:  		/* lwz R10, <#[R4 + 40]> */
		/* 820CC058h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000028) );
		/* 820CC058h case   26:*/		return 0x820CC05C;
		  /* 820CC05Ch */ case   27:  		/* cmpw CR6, R11, R10 */
		/* 820CC05Ch case   27:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CC05Ch case   27:*/		return 0x820CC060;
		  /* 820CC060h */ case   28:  		/* bc 4, CR6_EQ, 212 */
		/* 820CC060h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC060h case   28:*/		return 0x820CC064;
		  /* 820CC064h */ case   29:  		/* lwz R11, <#[R3 + 44]> */
		/* 820CC064h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CC064h case   29:*/		return 0x820CC068;
		  /* 820CC068h */ case   30:  		/* lwz R10, <#[R4 + 44]> */
		/* 820CC068h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000002C) );
		/* 820CC068h case   30:*/		return 0x820CC06C;
		  /* 820CC06Ch */ case   31:  		/* cmplw CR6, R11, R10 */
		/* 820CC06Ch case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CC06Ch case   31:*/		return 0x820CC070;
		  /* 820CC070h */ case   32:  		/* bc 4, CR6_EQ, 196 */
		/* 820CC070h case   32:*/		if ( !regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC070h case   32:*/		return 0x820CC074;
		  /* 820CC074h */ case   33:  		/* addi R4, R4, 48 */
		/* 820CC074h case   33:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x30);
		/* 820CC074h case   33:*/		return 0x820CC078;
		  /* 820CC078h */ case   34:  		/* addi R3, R3, 48 */
		/* 820CC078h case   34:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x30);
		/* 820CC078h case   34:*/		return 0x820CC07C;
		  /* 820CC07Ch */ case   35:  		/* bl -10604 */
		/* 820CC07Ch case   35:*/		regs.LR = 0x820CC080; return 0x820C9710;
		/* 820CC07Ch case   35:*/		return 0x820CC080;
		  /* 820CC080h */ case   36:  		/* cmpwi CR0, R3, 0 */
		/* 820CC080h case   36:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CC080h case   36:*/		return 0x820CC084;
		  /* 820CC084h */ case   37:  		/* bc 12, CR0_EQ, 176 */
		/* 820CC084h case   37:*/		if ( regs.CR[0].eq ) { return 0x820CC134;  }
		/* 820CC084h case   37:*/		return 0x820CC088;
		  /* 820CC088h */ case   38:  		/* lwz R3, <#[R30 + 16]> */
		/* 820CC088h case   38:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 820CC088h case   38:*/		return 0x820CC08C;
		  /* 820CC08Ch */ case   39:  		/* lwz R4, <#[R31 + 16]> */
		/* 820CC08Ch case   39:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 820CC08Ch case   39:*/		return 0x820CC090;
		  /* 820CC090h */ case   40:  		/* cmplwi CR6, R3, 0 */
		/* 820CC090h case   40:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CC090h case   40:*/		return 0x820CC094;
		  /* 820CC094h */ case   41:  		/* bc 12, CR6_EQ, 24 */
		/* 820CC094h case   41:*/		if ( regs.CR[6].eq ) { return 0x820CC0AC;  }
		/* 820CC094h case   41:*/		return 0x820CC098;
		  /* 820CC098h */ case   42:  		/* lwz R11, <#[R3]> */
		/* 820CC098h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC098h case   42:*/		return 0x820CC09C;
		  /* 820CC09Ch */ case   43:  		/* lwz R11, <#[R11]> */
		/* 820CC09Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CC09Ch case   43:*/		return 0x820CC0A0;
		  /* 820CC0A0h */ case   44:  		/* mtspr CTR, R11 */
		/* 820CC0A0h case   44:*/		regs.CTR = regs.R11;
		/* 820CC0A0h case   44:*/		return 0x820CC0A4;
		  /* 820CC0A4h */ case   45:  		/* bcctrl 20, CR0_LT */
		/* 820CC0A4h case   45:*/		if ( 1 ) { regs.LR = 0x820CC0A8; return (uint32)regs.CTR; }
		/* 820CC0A4h case   45:*/		return 0x820CC0A8;
		  /* 820CC0A8h */ case   46:  		/* b 16 */
		/* 820CC0A8h case   46:*/		return 0x820CC0B8;
		/* 820CC0A8h case   46:*/		return 0x820CC0AC;
	}
	return 0x820CC0AC;
} // Block from 820CBFF0h-820CC0ACh (47 instructions)

//////////////////////////////////////////////////////
// Block at 820CC0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC0AC);
		  /* 820CC0ACh */ case    0:  		/* addi R11, R4, 0 */
		/* 820CC0ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CC0ACh case    0:*/		return 0x820CC0B0;
		  /* 820CC0B0h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CC0B0h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CC0B0h case    1:*/		return 0x820CC0B4;
		  /* 820CC0B4h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CC0B4h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CC0B4h case    2:*/		return 0x820CC0B8;
	}
	return 0x820CC0B8;
} // Block from 820CC0ACh-820CC0B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CC0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC0B8);
		  /* 820CC0B8h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CC0B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CC0B8h case    0:*/		return 0x820CC0BC;
		  /* 820CC0BCh */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820CC0BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC0BCh case    1:*/		return 0x820CC0C0;
		  /* 820CC0C0h */ case    2:  		/* lwz R3, <#[R30 + 32]> */
		/* 820CC0C0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000020) );
		/* 820CC0C0h case    2:*/		return 0x820CC0C4;
		  /* 820CC0C4h */ case    3:  		/* lwz R4, <#[R31 + 32]> */
		/* 820CC0C4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000020) );
		/* 820CC0C4h case    3:*/		return 0x820CC0C8;
		  /* 820CC0C8h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CC0C8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CC0C8h case    4:*/		return 0x820CC0CC;
		  /* 820CC0CCh */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CC0CCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820CC0E4;  }
		/* 820CC0CCh case    5:*/		return 0x820CC0D0;
		  /* 820CC0D0h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CC0D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC0D0h case    6:*/		return 0x820CC0D4;
		  /* 820CC0D4h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CC0D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CC0D4h case    7:*/		return 0x820CC0D8;
		  /* 820CC0D8h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CC0D8h case    8:*/		regs.CTR = regs.R11;
		/* 820CC0D8h case    8:*/		return 0x820CC0DC;
		  /* 820CC0DCh */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CC0DCh case    9:*/		if ( 1 ) { regs.LR = 0x820CC0E0; return (uint32)regs.CTR; }
		/* 820CC0DCh case    9:*/		return 0x820CC0E0;
		  /* 820CC0E0h */ case   10:  		/* b 16 */
		/* 820CC0E0h case   10:*/		return 0x820CC0F0;
		/* 820CC0E0h case   10:*/		return 0x820CC0E4;
	}
	return 0x820CC0E4;
} // Block from 820CC0B8h-820CC0E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC0E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC0E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC0E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC0E4);
		  /* 820CC0E4h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CC0E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CC0E4h case    0:*/		return 0x820CC0E8;
		  /* 820CC0E8h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CC0E8h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CC0E8h case    1:*/		return 0x820CC0EC;
		  /* 820CC0ECh */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CC0ECh case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CC0ECh case    2:*/		return 0x820CC0F0;
	}
	return 0x820CC0F0;
} // Block from 820CC0E4h-820CC0F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CC0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC0F0);
		  /* 820CC0F0h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CC0F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CC0F0h case    0:*/		return 0x820CC0F4;
		  /* 820CC0F4h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CC0F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CC134;  }
		/* 820CC0F4h case    1:*/		return 0x820CC0F8;
		  /* 820CC0F8h */ case    2:  		/* lwz R3, <#[R30 + 36]> */
		/* 820CC0F8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000024) );
		/* 820CC0F8h case    2:*/		return 0x820CC0FC;
		  /* 820CC0FCh */ case    3:  		/* lwz R4, <#[R31 + 36]> */
		/* 820CC0FCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000024) );
		/* 820CC0FCh case    3:*/		return 0x820CC100;
		  /* 820CC100h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CC100h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CC100h case    4:*/		return 0x820CC104;
		  /* 820CC104h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CC104h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CC11C;  }
		/* 820CC104h case    5:*/		return 0x820CC108;
		  /* 820CC108h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CC108h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC108h case    6:*/		return 0x820CC10C;
		  /* 820CC10Ch */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CC10Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CC10Ch case    7:*/		return 0x820CC110;
		  /* 820CC110h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CC110h case    8:*/		regs.CTR = regs.R11;
		/* 820CC110h case    8:*/		return 0x820CC114;
		  /* 820CC114h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CC114h case    9:*/		if ( 1 ) { regs.LR = 0x820CC118; return (uint32)regs.CTR; }
		/* 820CC114h case    9:*/		return 0x820CC118;
		  /* 820CC118h */ case   10:  		/* b 16 */
		/* 820CC118h case   10:*/		return 0x820CC128;
		/* 820CC118h case   10:*/		return 0x820CC11C;
	}
	return 0x820CC11C;
} // Block from 820CC0F0h-820CC11Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC11Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC11C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC11C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC11C);
		  /* 820CC11Ch */ case    0:  		/* addi R11, R4, 0 */
		/* 820CC11Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CC11Ch case    0:*/		return 0x820CC120;
		  /* 820CC120h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CC120h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CC120h case    1:*/		return 0x820CC124;
		  /* 820CC124h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CC124h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CC124h case    2:*/		return 0x820CC128;
	}
	return 0x820CC128;
} // Block from 820CC11Ch-820CC128h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CC128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC128);
		  /* 820CC128h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CC128h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CC128h case    0:*/		return 0x820CC12C;
		  /* 820CC12Ch */ case    1:  		/* li R3, 1 */
		/* 820CC12Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CC12Ch case    1:*/		return 0x820CC130;
		  /* 820CC130h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CC130h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CC138;  }
		/* 820CC130h case    2:*/		return 0x820CC134;
	}
	return 0x820CC134;
} // Block from 820CC128h-820CC134h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CC134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC134);
		  /* 820CC134h */ case    0:  		/* li R3, 0 */
		/* 820CC134h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC134h case    0:*/		return 0x820CC138;
	}
	return 0x820CC138;
} // Block from 820CC134h-820CC138h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC138);
		  /* 820CC138h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CC138h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CC138h case    0:*/		return 0x820CC13C;
		  /* 820CC13Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC13Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC13Ch case    1:*/		return 0x820CC140;
		  /* 820CC140h */ case    2:  		/* mtspr LR, R12 */
		/* 820CC140h case    2:*/		regs.LR = regs.R12;
		/* 820CC140h case    2:*/		return 0x820CC144;
		  /* 820CC144h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CC144h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC144h case    3:*/		return 0x820CC148;
		  /* 820CC148h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CC148h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC148h case    4:*/		return 0x820CC14C;
		  /* 820CC14Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CC14Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC14Ch case    5:*/		return 0x820CC150;
	}
	return 0x820CC150;
} // Block from 820CC138h-820CC150h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CC150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC150);
		  /* 820CC150h */ case    0:  		/* mfspr R12, LR */
		/* 820CC150h case    0:*/		regs.R12 = regs.LR;
		/* 820CC150h case    0:*/		return 0x820CC154;
		  /* 820CC154h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC154h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC154h case    1:*/		return 0x820CC158;
		  /* 820CC158h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CC158h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC158h case    2:*/		return 0x820CC15C;
		  /* 820CC15Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CC15Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC15Ch case    3:*/		return 0x820CC160;
		  /* 820CC160h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CC160h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CC160h case    4:*/		return 0x820CC164;
		  /* 820CC164h */ case    5:  		/* mr R30, R3 */
		/* 820CC164h case    5:*/		regs.R30 = regs.R3;
		/* 820CC164h case    5:*/		return 0x820CC168;
		  /* 820CC168h */ case    6:  		/* bl 3784 */
		/* 820CC168h case    6:*/		regs.LR = 0x820CC16C; return 0x820CD030;
		/* 820CC168h case    6:*/		return 0x820CC16C;
		  /* 820CC16Ch */ case    7:  		/* li R5, 16 */
		/* 820CC16Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CC16Ch case    7:*/		return 0x820CC170;
		  /* 820CC170h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CC170h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC170h case    8:*/		return 0x820CC174;
		  /* 820CC174h */ case    9:  		/* li R4, 88 */
		/* 820CC174h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x58);
		/* 820CC174h case    9:*/		return 0x820CC178;
		  /* 820CC178h */ case   10:  		/* bl -12440 */
		/* 820CC178h case   10:*/		regs.LR = 0x820CC17C; return 0x820C90E0;
		/* 820CC178h case   10:*/		return 0x820CC17C;
		  /* 820CC17Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CC17Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC17Ch case   11:*/		return 0x820CC180;
		  /* 820CC180h */ case   12:  		/* bc 12, CR0_EQ, 100 */
		/* 820CC180h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CC1E4;  }
		/* 820CC180h case   12:*/		return 0x820CC184;
		  /* 820CC184h */ case   13:  		/* lis R10, -32255 */
		/* 820CC184h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC184h case   13:*/		return 0x820CC188;
		  /* 820CC188h */ case   14:  		/* li R11, 0 */
		/* 820CC188h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC188h case   14:*/		return 0x820CC18C;
		  /* 820CC18Ch */ case   15:  		/* li R9, 14 */
		/* 820CC18Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0xE);
		/* 820CC18Ch case   15:*/		return 0x820CC190;
		  /* 820CC190h */ case   16:  		/* addi R10, R10, 10688 */
		/* 820CC190h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29C0);
		/* 820CC190h case   16:*/		return 0x820CC194;
		  /* 820CC194h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC194h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC194h case   17:*/		return 0x820CC198;
	}
	return 0x820CC198;
} // Block from 820CC150h-820CC198h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CC198h
// Function '?Copy@CNodeVariable@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC198);
		  /* 820CC198h */ case    0:  		/* li R8, 1 */
		/* 820CC198h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820CC198h case    0:*/		return 0x820CC19C;
		  /* 820CC19Ch */ case    1:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC19Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC19Ch case    1:*/		return 0x820CC1A0;
		  /* 820CC1A0h */ case    2:  		/* stw R10, <#[R3]> */
		/* 820CC1A0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC1A0h case    2:*/		return 0x820CC1A4;
		  /* 820CC1A4h */ case    3:  		/* mr R31, R3 */
		/* 820CC1A4h case    3:*/		regs.R31 = regs.R3;
		/* 820CC1A4h case    3:*/		return 0x820CC1A8;
		  /* 820CC1A8h */ case    4:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC1A8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC1A8h case    4:*/		return 0x820CC1AC;
		  /* 820CC1ACh */ case    5:  		/* stw R11, <#[R3 + 16]> */
		/* 820CC1ACh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC1ACh case    5:*/		return 0x820CC1B0;
		  /* 820CC1B0h */ case    6:  		/* stw R11, <#[R3 + 20]> */
		/* 820CC1B0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CC1B0h case    6:*/		return 0x820CC1B4;
		  /* 820CC1B4h */ case    7:  		/* stw R11, <#[R3 + 24]> */
		/* 820CC1B4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC1B4h case    7:*/		return 0x820CC1B8;
		  /* 820CC1B8h */ case    8:  		/* stw R11, <#[R3 + 28]> */
		/* 820CC1B8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CC1B8h case    8:*/		return 0x820CC1BC;
		  /* 820CC1BCh */ case    9:  		/* stw R11, <#[R3 + 32]> */
		/* 820CC1BCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CC1BCh case    9:*/		return 0x820CC1C0;
		  /* 820CC1C0h */ case   10:  		/* stw R11, <#[R3 + 36]> */
		/* 820CC1C0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CC1C0h case   10:*/		return 0x820CC1C4;
		  /* 820CC1C4h */ case   11:  		/* stw R8, <#[R3 + 40]> */
		/* 820CC1C4h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000028) );
		/* 820CC1C4h case   11:*/		return 0x820CC1C8;
		  /* 820CC1C8h */ case   12:  		/* stw R11, <#[R3 + 44]> */
		/* 820CC1C8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CC1C8h case   12:*/		return 0x820CC1CC;
		  /* 820CC1CCh */ case   13:  		/* std R11, <#[R3 + 48]> */
		/* 820CC1CCh case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CC1CCh case   13:*/		return 0x820CC1D0;
		  /* 820CC1D0h */ case   14:  		/* std R11, <#[R3 + 56]> */
		/* 820CC1D0h case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CC1D0h case   14:*/		return 0x820CC1D4;
		  /* 820CC1D4h */ case   15:  		/* std R11, <#[R3 + 64]> */
		/* 820CC1D4h case   15:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CC1D4h case   15:*/		return 0x820CC1D8;
		  /* 820CC1D8h */ case   16:  		/* std R11, <#[R3 + 72]> */
		/* 820CC1D8h case   16:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000048) );
		/* 820CC1D8h case   16:*/		return 0x820CC1DC;
		  /* 820CC1DCh */ case   17:  		/* std R11, <#[R3 + 80]> */
		/* 820CC1DCh case   17:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 820CC1DCh case   17:*/		return 0x820CC1E0;
		  /* 820CC1E0h */ case   18:  		/* b 8 */
		/* 820CC1E0h case   18:*/		return 0x820CC1E8;
		/* 820CC1E0h case   18:*/		return 0x820CC1E4;
	}
	return 0x820CC1E4;
} // Block from 820CC198h-820CC1E4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CC1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC1E4);
		  /* 820CC1E4h */ case    0:  		/* li R31, 0 */
		/* 820CC1E4h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CC1E4h case    0:*/		return 0x820CC1E8;
	}
	return 0x820CC1E8;
} // Block from 820CC1E4h-820CC1E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC1E8);
		  /* 820CC1E8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CC1E8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CC1E8h case    0:*/		return 0x820CC1EC;
		  /* 820CC1ECh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CC1ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CC1F8;  }
		/* 820CC1ECh case    1:*/		return 0x820CC1F0;
		  /* 820CC1F0h */ case    2:  		/* li R3, 0 */
		/* 820CC1F0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC1F0h case    2:*/		return 0x820CC1F4;
		  /* 820CC1F4h */ case    3:  		/* b 208 */
		/* 820CC1F4h case    3:*/		return 0x820CC2C4;
		/* 820CC1F4h case    3:*/		return 0x820CC1F8;
	}
	return 0x820CC1F8;
} // Block from 820CC1E8h-820CC1F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC1F8);
		  /* 820CC1F8h */ case    0:  		/* lwz R8, <#[R30 + 20]> */
		/* 820CC1F8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000014) );
		/* 820CC1F8h case    0:*/		return 0x820CC1FC;
		  /* 820CC1FCh */ case    1:  		/* li R11, 5 */
		/* 820CC1FCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CC1FCh case    1:*/		return 0x820CC200;
		  /* 820CC200h */ case    2:  		/* addi R10, R30, 40 */
		/* 820CC200h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x28);
		/* 820CC200h case    2:*/		return 0x820CC204;
		  /* 820CC204h */ case    3:  		/* addi R9, R31, 40 */
		/* 820CC204h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x28);
		/* 820CC204h case    3:*/		return 0x820CC208;
		  /* 820CC208h */ case    4:  		/* stw R8, <#[R31 + 20]> */
		/* 820CC208h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820CC208h case    4:*/		return 0x820CC20C;
		  /* 820CC20Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 820CC20Ch case    5:*/		regs.CTR = regs.R11;
		/* 820CC20Ch case    5:*/		return 0x820CC210;
		  /* 820CC210h */ case    6:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CC210h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CC210h case    6:*/		return 0x820CC214;
		  /* 820CC214h */ case    7:  		/* stw R11, <#[R31 + 24]> */
		/* 820CC214h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CC214h case    7:*/		return 0x820CC218;
		  /* 820CC218h */ case    8:  		/* lwz R11, <#[R30 + 28]> */
		/* 820CC218h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CC218h case    8:*/		return 0x820CC21C;
		  /* 820CC21Ch */ case    9:  		/* stw R11, <#[R31 + 28]> */
		/* 820CC21Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CC21Ch case    9:*/		return 0x820CC220;
		  /* 820CC220h */ case   10:  		/* lwz R11, <#[R30 + 40]> */
		/* 820CC220h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820CC220h case   10:*/		return 0x820CC224;
		  /* 820CC224h */ case   11:  		/* stw R11, <#[R31 + 40]> */
		/* 820CC224h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820CC224h case   11:*/		return 0x820CC228;
		  /* 820CC228h */ case   12:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CC228h case   12:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CC228h case   12:*/		return 0x820CC22C;
		  /* 820CC22Ch */ case   13:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CC22Ch case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC22Ch case   13:*/		return 0x820CC230;
		  /* 820CC230h */ case   14:  		/* bc 16, CR0_LT, -8 */
		/* 820CC230h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC228;  }
		/* 820CC230h case   14:*/		return 0x820CC234;
		  /* 820CC234h */ case   15:  		/* lwz R11, <#[R30 + 44]> */
		/* 820CC234h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820CC234h case   15:*/		return 0x820CC238;
		  /* 820CC238h */ case   16:  		/* stw R11, <#[R31 + 44]> */
		/* 820CC238h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820CC238h case   16:*/		return 0x820CC23C;
		  /* 820CC23Ch */ case   17:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CC23Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CC23Ch case   17:*/		return 0x820CC240;
		  /* 820CC240h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820CC240h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CC240h case   18:*/		return 0x820CC244;
		  /* 820CC244h */ case   19:  		/* bc 12, CR6_EQ, 36 */
		/* 820CC244h case   19:*/		if ( regs.CR[6].eq ) { return 0x820CC268;  }
		/* 820CC244h case   19:*/		return 0x820CC248;
		  /* 820CC248h */ case   20:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CC248h case   20:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CC248h case   20:*/		return 0x820CC24C;
		  /* 820CC24Ch */ case   21:  		/* lwz R11, <#[R3]> */
		/* 820CC24Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC24Ch case   21:*/		return 0x820CC250;
		  /* 820CC250h */ case   22:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC250h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC250h case   22:*/		return 0x820CC254;
		  /* 820CC254h */ case   23:  		/* mtspr CTR, R11 */
		/* 820CC254h case   23:*/		regs.CTR = regs.R11;
		/* 820CC254h case   23:*/		return 0x820CC258;
		  /* 820CC258h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 820CC258h case   24:*/		if ( 1 ) { regs.LR = 0x820CC25C; return (uint32)regs.CTR; }
		/* 820CC258h case   24:*/		return 0x820CC25C;
		  /* 820CC25Ch */ case   25:  		/* stw R3, <#[R31 + 16]> */
		/* 820CC25Ch case   25:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CC25Ch case   25:*/		return 0x820CC260;
		  /* 820CC260h */ case   26:  		/* cmplwi CR0, R3, 0 */
		/* 820CC260h case   26:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC260h case   26:*/		return 0x820CC264;
		  /* 820CC264h */ case   27:  		/* bc 12, CR0_EQ, -116 */
		/* 820CC264h case   27:*/		if ( regs.CR[0].eq ) { return 0x820CC1F0;  }
		/* 820CC264h case   27:*/		return 0x820CC268;
	}
	return 0x820CC268;
} // Block from 820CC1F8h-820CC268h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820CC268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC268);
		  /* 820CC268h */ case    0:  		/* lwz R11, <#[R30 + 32]> */
		/* 820CC268h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820CC268h case    0:*/		return 0x820CC26C;
		  /* 820CC26Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CC26Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CC26Ch case    1:*/		return 0x820CC270;
		  /* 820CC270h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CC270h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CC294;  }
		/* 820CC270h case    2:*/		return 0x820CC274;
		  /* 820CC274h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CC274h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CC274h case    3:*/		return 0x820CC278;
		  /* 820CC278h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CC278h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC278h case    4:*/		return 0x820CC27C;
		  /* 820CC27Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC27Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC27Ch case    5:*/		return 0x820CC280;
		  /* 820CC280h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CC280h case    6:*/		regs.CTR = regs.R11;
		/* 820CC280h case    6:*/		return 0x820CC284;
		  /* 820CC284h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CC284h case    7:*/		if ( 1 ) { regs.LR = 0x820CC288; return (uint32)regs.CTR; }
		/* 820CC284h case    7:*/		return 0x820CC288;
		  /* 820CC288h */ case    8:  		/* stw R3, <#[R31 + 32]> */
		/* 820CC288h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 820CC288h case    8:*/		return 0x820CC28C;
		  /* 820CC28Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CC28Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC28Ch case    9:*/		return 0x820CC290;
		  /* 820CC290h */ case   10:  		/* bc 12, CR0_EQ, -160 */
		/* 820CC290h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CC1F0;  }
		/* 820CC290h case   10:*/		return 0x820CC294;
	}
	return 0x820CC294;
} // Block from 820CC268h-820CC294h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC294);
		  /* 820CC294h */ case    0:  		/* lwz R11, <#[R30 + 36]> */
		/* 820CC294h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820CC294h case    0:*/		return 0x820CC298;
		  /* 820CC298h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CC298h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CC298h case    1:*/		return 0x820CC29C;
		  /* 820CC29Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CC29Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CC2C0;  }
		/* 820CC29Ch case    2:*/		return 0x820CC2A0;
		  /* 820CC2A0h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CC2A0h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CC2A0h case    3:*/		return 0x820CC2A4;
		  /* 820CC2A4h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CC2A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC2A4h case    4:*/		return 0x820CC2A8;
		  /* 820CC2A8h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC2A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC2A8h case    5:*/		return 0x820CC2AC;
		  /* 820CC2ACh */ case    6:  		/* mtspr CTR, R11 */
		/* 820CC2ACh case    6:*/		regs.CTR = regs.R11;
		/* 820CC2ACh case    6:*/		return 0x820CC2B0;
		  /* 820CC2B0h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CC2B0h case    7:*/		if ( 1 ) { regs.LR = 0x820CC2B4; return (uint32)regs.CTR; }
		/* 820CC2B0h case    7:*/		return 0x820CC2B4;
		  /* 820CC2B4h */ case    8:  		/* stw R3, <#[R31 + 36]> */
		/* 820CC2B4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000024) );
		/* 820CC2B4h case    8:*/		return 0x820CC2B8;
		  /* 820CC2B8h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CC2B8h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC2B8h case    9:*/		return 0x820CC2BC;
		  /* 820CC2BCh */ case   10:  		/* bc 12, CR0_EQ, -204 */
		/* 820CC2BCh case   10:*/		if ( regs.CR[0].eq ) { return 0x820CC1F0;  }
		/* 820CC2BCh case   10:*/		return 0x820CC2C0;
	}
	return 0x820CC2C0;
} // Block from 820CC294h-820CC2C0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC2C0);
		  /* 820CC2C0h */ case    0:  		/* mr R3, R31 */
		/* 820CC2C0h case    0:*/		regs.R3 = regs.R31;
		/* 820CC2C0h case    0:*/		return 0x820CC2C4;
	}
	return 0x820CC2C4;
} // Block from 820CC2C0h-820CC2C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC2C4);
		  /* 820CC2C4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CC2C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CC2C4h case    0:*/		return 0x820CC2C8;
		  /* 820CC2C8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC2C8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC2C8h case    1:*/		return 0x820CC2CC;
		  /* 820CC2CCh */ case    2:  		/* mtspr LR, R12 */
		/* 820CC2CCh case    2:*/		regs.LR = regs.R12;
		/* 820CC2CCh case    2:*/		return 0x820CC2D0;
		  /* 820CC2D0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CC2D0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC2D0h case    3:*/		return 0x820CC2D4;
		  /* 820CC2D4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CC2D4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC2D4h case    4:*/		return 0x820CC2D8;
		  /* 820CC2D8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CC2D8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC2D8h case    5:*/		return 0x820CC2DC;
	}
	return 0x820CC2DC;
} // Block from 820CC2C4h-820CC2DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CC2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC2DC);
		  /* 820CC2DCh */ case    0:  		/* nop */
		/* 820CC2DCh case    0:*/		cpu::op::nop();
		/* 820CC2DCh case    0:*/		return 0x820CC2E0;
		  /* 820CC2E0h */ case    1:  		/* lis R10, -32255 */
		/* 820CC2E0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC2E0h case    1:*/		return 0x820CC2E4;
		  /* 820CC2E4h */ case    2:  		/* li R11, 0 */
		/* 820CC2E4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC2E4h case    2:*/		return 0x820CC2E8;
		  /* 820CC2E8h */ case    3:  		/* li R9, 15 */
		/* 820CC2E8h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xF);
		/* 820CC2E8h case    3:*/		return 0x820CC2EC;
		  /* 820CC2ECh */ case    4:  		/* addi R10, R10, 10700 */
		/* 820CC2ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29CC);
		/* 820CC2ECh case    4:*/		return 0x820CC2F0;
		  /* 820CC2F0h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC2F0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC2F0h case    5:*/		return 0x820CC2F4;
		  /* 820CC2F4h */ case    6:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC2F4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC2F4h case    6:*/		return 0x820CC2F8;
		  /* 820CC2F8h */ case    7:  		/* li R8, 3 */
		/* 820CC2F8h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 820CC2F8h case    7:*/		return 0x820CC2FC;
		  /* 820CC2FCh */ case    8:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC2FCh case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC2FCh case    8:*/		return 0x820CC300;
		  /* 820CC300h */ case    9:  		/* stw R10, <#[R3]> */
		/* 820CC300h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC300h case    9:*/		return 0x820CC304;
		  /* 820CC304h */ case   10:  		/* std R11, <#[R3 + 16]> */
		/* 820CC304h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC304h case   10:*/		return 0x820CC308;
		  /* 820CC308h */ case   11:  		/* std R11, <#[R3 + 24]> */
		/* 820CC308h case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC308h case   11:*/		return 0x820CC30C;
		  /* 820CC30Ch */ case   12:  		/* std R11, <#[R3 + 32]> */
		/* 820CC30Ch case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CC30Ch case   12:*/		return 0x820CC310;
		  /* 820CC310h */ case   13:  		/* std R11, <#[R3 + 40]> */
		/* 820CC310h case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CC310h case   13:*/		return 0x820CC314;
		  /* 820CC314h */ case   14:  		/* std R11, <#[R3 + 48]> */
		/* 820CC314h case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CC314h case   14:*/		return 0x820CC318;
		  /* 820CC318h */ case   15:  		/* std R11, <#[R3 + 56]> */
		/* 820CC318h case   15:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CC318h case   15:*/		return 0x820CC31C;
		  /* 820CC31Ch */ case   16:  		/* std R11, <#[R3 + 64]> */
		/* 820CC31Ch case   16:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CC31Ch case   16:*/		return 0x820CC320;
		  /* 820CC320h */ case   17:  		/* addi R11, R3, 16 */
		/* 820CC320h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 820CC320h case   17:*/		return 0x820CC324;
		  /* 820CC324h */ case   18:  		/* stw R8, <#[R3 + 16]> */
		/* 820CC324h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC324h case   18:*/		return 0x820CC328;
		  /* 820CC328h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820CC328h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC328h case   19:*/		return 0x820CC32C;
	}
	return 0x820CC32C;
} // Block from 820CC2DCh-820CC32Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820CC32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC32C);
		  /* 820CC32Ch */ case    0:  		/* nop */
		/* 820CC32Ch case    0:*/		cpu::op::nop();
		/* 820CC32Ch case    0:*/		return 0x820CC330;
	}
	return 0x820CC330;
} // Block from 820CC32Ch-820CC330h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC330);
		  /* 820CC330h */ case    0:  		/* mfspr R12, LR */
		/* 820CC330h case    0:*/		regs.R12 = regs.LR;
		/* 820CC330h case    0:*/		return 0x820CC334;
		  /* 820CC334h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC334h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC334h case    1:*/		return 0x820CC338;
		  /* 820CC338h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820CC338h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC338h case    2:*/		return 0x820CC33C;
		  /* 820CC33Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CC33Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CC33Ch case    3:*/		return 0x820CC340;
		  /* 820CC340h */ case    4:  		/* lis R11, -32255 */
		/* 820CC340h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CC340h case    4:*/		return 0x820CC344;
		  /* 820CC344h */ case    5:  		/* li R9, 0 */
		/* 820CC344h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CC344h case    5:*/		return 0x820CC348;
		  /* 820CC348h */ case    6:  		/* addi R11, R11, 10700 */
		/* 820CC348h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x29CC);
		/* 820CC348h case    6:*/		return 0x820CC34C;
		  /* 820CC34Ch */ case    7:  		/* li R8, 15 */
		/* 820CC34Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0xF);
		/* 820CC34Ch case    7:*/		return 0x820CC350;
		  /* 820CC350h */ case    8:  		/* stw R9, <#[R3 + 8]> */
		/* 820CC350h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC350h case    8:*/		return 0x820CC354;
		  /* 820CC354h */ case    9:  		/* li R10, 5 */
		/* 820CC354h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820CC354h case    9:*/		return 0x820CC358;
		  /* 820CC358h */ case   10:  		/* stw R9, <#[R3 + 12]> */
		/* 820CC358h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC358h case   10:*/		return 0x820CC35C;
		  /* 820CC35Ch */ case   11:  		/* stw R11, <#[R3]> */
		/* 820CC35Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC35Ch case   11:*/		return 0x820CC360;
		  /* 820CC360h */ case   12:  		/* mr R31, R3 */
		/* 820CC360h case   12:*/		regs.R31 = regs.R3;
		/* 820CC360h case   12:*/		return 0x820CC364;
		  /* 820CC364h */ case   13:  		/* stw R8, <#[R3 + 4]> */
		/* 820CC364h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC364h case   13:*/		return 0x820CC368;
		  /* 820CC368h */ case   14:  		/* addi R11, R3, 16 */
		/* 820CC368h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 820CC368h case   14:*/		return 0x820CC36C;
		  /* 820CC36Ch */ case   15:  		/* ld R7, <#[R4]> */
		/* 820CC36Ch case   15:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 820CC36Ch case   15:*/		return 0x820CC370;
		  /* 820CC370h */ case   16:  		/* addi R8, R3, 24 */
		/* 820CC370h case   16:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0x18);
		/* 820CC370h case   16:*/		return 0x820CC374;
		  /* 820CC374h */ case   17:  		/* std R7, <#[R3 + 16]> */
		/* 820CC374h case   17:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC374h case   17:*/		return 0x820CC378;
		  /* 820CC378h */ case   18:  		/* addi R9, R5, -8 */
		/* 820CC378h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0xFFFFFFF8);
		/* 820CC378h case   18:*/		return 0x820CC37C;
		  /* 820CC37Ch */ case   19:  		/* ld R7, <#[R4 + 8]> */
		/* 820CC37Ch case   19:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 820CC37Ch case   19:*/		return 0x820CC380;
		  /* 820CC380h */ case   20:  		/* mtspr CTR, R10 */
		/* 820CC380h case   20:*/		regs.CTR = regs.R10;
		/* 820CC380h case   20:*/		return 0x820CC384;
		  /* 820CC384h */ case   21:  		/* std R7, <#[R3 + 24]> */
		/* 820CC384h case   21:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC384h case   21:*/		return 0x820CC388;
		  /* 820CC388h */ case   22:  		/* ldu R10, <#[R9 + 8]> */
		/* 820CC388h case   22:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC388h case   22:*/		return 0x820CC38C;
		  /* 820CC38Ch */ case   23:  		/* stdu R10, <#[R8 + 8]> */
		/* 820CC38Ch case   23:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820CC38Ch case   23:*/		return 0x820CC390;
		  /* 820CC390h */ case   24:  		/* bc 16, CR0_LT, -8 */
		/* 820CC390h case   24:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC388;  }
		/* 820CC390h case   24:*/		return 0x820CC394;
		  /* 820CC394h */ case   25:  		/* lwz R11, <#[R11]> */
		/* 820CC394h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CC394h case   25:*/		return 0x820CC398;
		  /* 820CC398h */ case   26:  		/* cmpwi CR6, R11, 4 */
		/* 820CC398h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820CC398h case   26:*/		return 0x820CC39C;
		  /* 820CC39Ch */ case   27:  		/* bc 4, CR6_EQ, 36 */
		/* 820CC39Ch case   27:*/		if ( !regs.CR[6].eq ) { return 0x820CC3C0;  }
		/* 820CC39Ch case   27:*/		return 0x820CC3A0;
		  /* 820CC3A0h */ case   28:  		/* lwz R3, <#[R31 + 24]> */
		/* 820CC3A0h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CC3A0h case   28:*/		return 0x820CC3A4;
		  /* 820CC3A4h */ case   29:  		/* cmplwi CR6, R3, 0 */
		/* 820CC3A4h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CC3A4h case   29:*/		return 0x820CC3A8;
		  /* 820CC3A8h */ case   30:  		/* bc 12, CR6_EQ, 24 */
		/* 820CC3A8h case   30:*/		if ( regs.CR[6].eq ) { return 0x820CC3C0;  }
		/* 820CC3A8h case   30:*/		return 0x820CC3AC;
		  /* 820CC3ACh */ case   31:  		/* lwz R11, <#[R3]> */
		/* 820CC3ACh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC3ACh case   31:*/		return 0x820CC3B0;
		  /* 820CC3B0h */ case   32:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC3B0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC3B0h case   32:*/		return 0x820CC3B4;
		  /* 820CC3B4h */ case   33:  		/* mtspr CTR, R11 */
		/* 820CC3B4h case   33:*/		regs.CTR = regs.R11;
		/* 820CC3B4h case   33:*/		return 0x820CC3B8;
		  /* 820CC3B8h */ case   34:  		/* bcctrl 20, CR0_LT */
		/* 820CC3B8h case   34:*/		if ( 1 ) { regs.LR = 0x820CC3BC; return (uint32)regs.CTR; }
		/* 820CC3B8h case   34:*/		return 0x820CC3BC;
		  /* 820CC3BCh */ case   35:  		/* stw R3, <#[R31 + 24]> */
		/* 820CC3BCh case   35:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CC3BCh case   35:*/		return 0x820CC3C0;
	}
	return 0x820CC3C0;
} // Block from 820CC330h-820CC3C0h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820CC3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC3C0);
		  /* 820CC3C0h */ case    0:  		/* mr R3, R31 */
		/* 820CC3C0h case    0:*/		regs.R3 = regs.R31;
		/* 820CC3C0h case    0:*/		return 0x820CC3C4;
		  /* 820CC3C4h */ case    1:  		/* addi R1, R1, 96 */
		/* 820CC3C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CC3C4h case    1:*/		return 0x820CC3C8;
		  /* 820CC3C8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC3C8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC3C8h case    2:*/		return 0x820CC3CC;
		  /* 820CC3CCh */ case    3:  		/* mtspr LR, R12 */
		/* 820CC3CCh case    3:*/		regs.LR = regs.R12;
		/* 820CC3CCh case    3:*/		return 0x820CC3D0;
		  /* 820CC3D0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CC3D0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC3D0h case    4:*/		return 0x820CC3D4;
		  /* 820CC3D4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CC3D4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC3D4h case    5:*/		return 0x820CC3D8;
	}
	return 0x820CC3D8;
} // Block from 820CC3C0h-820CC3D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CC3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC3D8);
		  /* 820CC3D8h */ case    0:  		/* lis R9, -32255 */
		/* 820CC3D8h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CC3D8h case    0:*/		return 0x820CC3DC;
		  /* 820CC3DCh */ case    1:  		/* stw R4, <#[R3 + 16]> */
		/* 820CC3DCh case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC3DCh case    1:*/		return 0x820CC3E0;
		  /* 820CC3E0h */ case    2:  		/* li R11, 5 */
		/* 820CC3E0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CC3E0h case    2:*/		return 0x820CC3E4;
		  /* 820CC3E4h */ case    3:  		/* stw R5, <#[R3 + 24]> */
		/* 820CC3E4h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC3E4h case    3:*/		return 0x820CC3E8;
		  /* 820CC3E8h */ case    4:  		/* li R10, 0 */
		/* 820CC3E8h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CC3E8h case    4:*/		return 0x820CC3EC;
		  /* 820CC3ECh */ case    5:  		/* addi R8, R9, 10700 */
		/* 820CC3ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x29CC);
		/* 820CC3ECh case    5:*/		return 0x820CC3F0;
		  /* 820CC3F0h */ case    6:  		/* li R7, 15 */
		/* 820CC3F0h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0xF);
		/* 820CC3F0h case    6:*/		return 0x820CC3F4;
		  /* 820CC3F4h */ case    7:  		/* stw R10, <#[R3 + 8]> */
		/* 820CC3F4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC3F4h case    7:*/		return 0x820CC3F8;
		  /* 820CC3F8h */ case    8:  		/* stw R10, <#[R3 + 12]> */
		/* 820CC3F8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC3F8h case    8:*/		return 0x820CC3FC;
		  /* 820CC3FCh */ case    9:  		/* addi R9, R3, 24 */
		/* 820CC3FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x18);
		/* 820CC3FCh case    9:*/		return 0x820CC400;
		  /* 820CC400h */ case   10:  		/* stw R8, <#[R3]> */
		/* 820CC400h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC400h case   10:*/		return 0x820CC404;
		  /* 820CC404h */ case   11:  		/* addi R10, R6, -8 */
		/* 820CC404h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFF8);
		/* 820CC404h case   11:*/		return 0x820CC408;
		  /* 820CC408h */ case   12:  		/* stw R7, <#[R3 + 4]> */
		/* 820CC408h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC408h case   12:*/		return 0x820CC40C;
		  /* 820CC40Ch */ case   13:  		/* mtspr CTR, R11 */
		/* 820CC40Ch case   13:*/		regs.CTR = regs.R11;
		/* 820CC40Ch case   13:*/		return 0x820CC410;
		  /* 820CC410h */ case   14:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CC410h case   14:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CC410h case   14:*/		return 0x820CC414;
		  /* 820CC414h */ case   15:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CC414h case   15:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC414h case   15:*/		return 0x820CC418;
		  /* 820CC418h */ case   16:  		/* bc 16, CR0_LT, -8 */
		/* 820CC418h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC410;  }
		/* 820CC418h case   16:*/		return 0x820CC41C;
		  /* 820CC41Ch */ case   17:  		/* bclr 20, CR0_LT */
		/* 820CC41Ch case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC41Ch case   17:*/		return 0x820CC420;
	}
	return 0x820CC420;
} // Block from 820CC3D8h-820CC420h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CC420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC420);
		  /* 820CC420h */ case    0:  		/* lis R9, -32255 */
		/* 820CC420h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CC420h case    0:*/		return 0x820CC424;
		  /* 820CC424h */ case    1:  		/* stfd FR1, <#[R3 + 24]> */
		/* 820CC424h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC424h case    1:*/		return 0x820CC428;
		  /* 820CC428h */ case    2:  		/* li R11, 5 */
		/* 820CC428h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CC428h case    2:*/		return 0x820CC42C;
		  /* 820CC42Ch */ case    3:  		/* stw R4, <#[R3 + 16]> */
		/* 820CC42Ch case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC42Ch case    3:*/		return 0x820CC430;
		  /* 820CC430h */ case    4:  		/* li R10, 0 */
		/* 820CC430h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CC430h case    4:*/		return 0x820CC434;
		  /* 820CC434h */ case    5:  		/* addi R8, R9, 10700 */
		/* 820CC434h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x29CC);
		/* 820CC434h case    5:*/		return 0x820CC438;
		  /* 820CC438h */ case    6:  		/* li R7, 15 */
		/* 820CC438h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0xF);
		/* 820CC438h case    6:*/		return 0x820CC43C;
		  /* 820CC43Ch */ case    7:  		/* stw R10, <#[R3 + 8]> */
		/* 820CC43Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC43Ch case    7:*/		return 0x820CC440;
		  /* 820CC440h */ case    8:  		/* stw R10, <#[R3 + 12]> */
		/* 820CC440h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC440h case    8:*/		return 0x820CC444;
		  /* 820CC444h */ case    9:  		/* addi R9, R3, 24 */
		/* 820CC444h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x18);
		/* 820CC444h case    9:*/		return 0x820CC448;
		  /* 820CC448h */ case   10:  		/* stw R8, <#[R3]> */
		/* 820CC448h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC448h case   10:*/		return 0x820CC44C;
		  /* 820CC44Ch */ case   11:  		/* addi R10, R6, -8 */
		/* 820CC44Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFF8);
		/* 820CC44Ch case   11:*/		return 0x820CC450;
		  /* 820CC450h */ case   12:  		/* stw R7, <#[R3 + 4]> */
		/* 820CC450h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC450h case   12:*/		return 0x820CC454;
		  /* 820CC454h */ case   13:  		/* mtspr CTR, R11 */
		/* 820CC454h case   13:*/		regs.CTR = regs.R11;
		/* 820CC454h case   13:*/		return 0x820CC458;
	}
	return 0x820CC458;
} // Block from 820CC420h-820CC458h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CC458h
// Function '??0CNodeStatement@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC458);
		  /* 820CC458h */ case    0:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CC458h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CC458h case    0:*/		return 0x820CC45C;
		  /* 820CC45Ch */ case    1:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CC45Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC45Ch case    1:*/		return 0x820CC460;
		  /* 820CC460h */ case    2:  		/* bc 16, CR0_LT, -8 */
		/* 820CC460h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC458;  }
		/* 820CC460h case    2:*/		return 0x820CC464;
		  /* 820CC464h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CC464h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC464h case    3:*/		return 0x820CC468;
	}
	return 0x820CC468;
} // Block from 820CC458h-820CC468h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC468);
		  /* 820CC468h */ case    0:  		/* lis R9, -32255 */
		/* 820CC468h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CC468h case    0:*/		return 0x820CC46C;
		  /* 820CC46Ch */ case    1:  		/* stw R6, <#[R3 + 28]> */
		/* 820CC46Ch case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CC46Ch case    1:*/		return 0x820CC470;
		  /* 820CC470h */ case    2:  		/* li R11, 5 */
		/* 820CC470h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CC470h case    2:*/		return 0x820CC474;
		  /* 820CC474h */ case    3:  		/* stw R4, <#[R3 + 16]> */
		/* 820CC474h case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC474h case    3:*/		return 0x820CC478;
		  /* 820CC478h */ case    4:  		/* li R10, 0 */
		/* 820CC478h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CC478h case    4:*/		return 0x820CC47C;
		  /* 820CC47Ch */ case    5:  		/* stw R5, <#[R3 + 24]> */
		/* 820CC47Ch case    5:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC47Ch case    5:*/		return 0x820CC480;
		  /* 820CC480h */ case    6:  		/* addi R8, R9, 10700 */
		/* 820CC480h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x29CC);
		/* 820CC480h case    6:*/		return 0x820CC484;
		  /* 820CC484h */ case    7:  		/* li R6, 15 */
		/* 820CC484h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0xF);
		/* 820CC484h case    7:*/		return 0x820CC488;
		  /* 820CC488h */ case    8:  		/* stw R10, <#[R3 + 8]> */
		/* 820CC488h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC488h case    8:*/		return 0x820CC48C;
		  /* 820CC48Ch */ case    9:  		/* stw R10, <#[R3 + 12]> */
		/* 820CC48Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC48Ch case    9:*/		return 0x820CC490;
		  /* 820CC490h */ case   10:  		/* addi R9, R3, 24 */
		/* 820CC490h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x18);
		/* 820CC490h case   10:*/		return 0x820CC494;
		  /* 820CC494h */ case   11:  		/* stw R8, <#[R3]> */
		/* 820CC494h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC494h case   11:*/		return 0x820CC498;
		  /* 820CC498h */ case   12:  		/* addi R10, R7, -8 */
		/* 820CC498h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFFFF8);
		/* 820CC498h case   12:*/		return 0x820CC49C;
		  /* 820CC49Ch */ case   13:  		/* stw R6, <#[R3 + 4]> */
		/* 820CC49Ch case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC49Ch case   13:*/		return 0x820CC4A0;
	}
	return 0x820CC4A0;
} // Block from 820CC468h-820CC4A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CC4A0h
// Function '?IsEqual@CNodeStatement@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC4A0);
		  /* 820CC4A0h */ case    0:  		/* mtspr CTR, R11 */
		/* 820CC4A0h case    0:*/		regs.CTR = regs.R11;
		/* 820CC4A0h case    0:*/		return 0x820CC4A4;
		  /* 820CC4A4h */ case    1:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CC4A4h case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CC4A4h case    1:*/		return 0x820CC4A8;
		  /* 820CC4A8h */ case    2:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CC4A8h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC4A8h case    2:*/		return 0x820CC4AC;
		  /* 820CC4ACh */ case    3:  		/* bc 16, CR0_LT, -8 */
		/* 820CC4ACh case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC4A4;  }
		/* 820CC4ACh case    3:*/		return 0x820CC4B0;
		  /* 820CC4B0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820CC4B0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC4B0h case    4:*/		return 0x820CC4B4;
	}
	return 0x820CC4B4;
} // Block from 820CC4A0h-820CC4B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CC4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC4B4);
		  /* 820CC4B4h */ case    0:  		/* nop */
		/* 820CC4B4h case    0:*/		cpu::op::nop();
		/* 820CC4B4h case    0:*/		return 0x820CC4B8;
	}
	return 0x820CC4B8;
} // Block from 820CC4B4h-820CC4B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC4B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC4B8);
		  /* 820CC4B8h */ case    0:  		/* mfspr R12, LR */
		/* 820CC4B8h case    0:*/		regs.R12 = regs.LR;
		/* 820CC4B8h case    0:*/		return 0x820CC4BC;
		  /* 820CC4BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC4BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC4BCh case    1:*/		return 0x820CC4C0;
		  /* 820CC4C0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CC4C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CC4C0h case    2:*/		return 0x820CC4C4;
		  /* 820CC4C4h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820CC4C4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CC4C4h case    3:*/		return 0x820CC4C8;
		  /* 820CC4C8h */ case    4:  		/* bc 12, CR6_EQ, 164 */
		/* 820CC4C8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CC56C;  }
		/* 820CC4C8h case    4:*/		return 0x820CC4CC;
		  /* 820CC4CCh */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CC4CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CC4CCh case    5:*/		return 0x820CC4D0;
		  /* 820CC4D0h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CC4D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC4D0h case    6:*/		return 0x820CC4D4;
		  /* 820CC4D4h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820CC4D4h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CC4D4h case    7:*/		return 0x820CC4D8;
		  /* 820CC4D8h */ case    8:  		/* bc 4, CR6_EQ, 148 */
		/* 820CC4D8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CC56C;  }
		/* 820CC4D8h case    8:*/		return 0x820CC4DC;
		  /* 820CC4DCh */ case    9:  		/* lwz R9, <#[R4 + 16]> */
		/* 820CC4DCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000010) );
		/* 820CC4DCh case    9:*/		return 0x820CC4E0;
		  /* 820CC4E0h */ case   10:  		/* addi R10, R4, 16 */
		/* 820CC4E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x10);
		/* 820CC4E0h case   10:*/		return 0x820CC4E4;
		  /* 820CC4E4h */ case   11:  		/* lwz R7, <#[R3 + 16]> */
		/* 820CC4E4h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC4E4h case   11:*/		return 0x820CC4E8;
		  /* 820CC4E8h */ case   12:  		/* addi R11, R3, 16 */
		/* 820CC4E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 820CC4E8h case   12:*/		return 0x820CC4EC;
		  /* 820CC4ECh */ case   13:  		/* cmpw CR6, R7, R9 */
		/* 820CC4ECh case   13:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R9);
		/* 820CC4ECh case   13:*/		return 0x820CC4F0;
		  /* 820CC4F0h */ case   14:  		/* bc 4, CR6_EQ, 124 */
		/* 820CC4F0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820CC56C;  }
		/* 820CC4F0h case   14:*/		return 0x820CC4F4;
		  /* 820CC4F4h */ case   15:  		/* addi R8, R11, 16 */
		/* 820CC4F4h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x10);
		/* 820CC4F4h case   15:*/		return 0x820CC4F8;
		  /* 820CC4F8h */ case   16:  		/* lbz R9, <#[R11]> */
		/* 820CC4F8h case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CC4F8h case   16:*/		return 0x820CC4FC;
		  /* 820CC4FCh */ case   17:  		/* lbz R6, <#[R10]> */
		/* 820CC4FCh case   17:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820CC4FCh case   17:*/		return 0x820CC500;
		  /* 820CC500h */ case   18:  		/* subf. R9, R6, R9 */
		/* 820CC500h case   18:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820CC500h case   18:*/		return 0x820CC504;
		  /* 820CC504h */ case   19:  		/* bc 4, CR0_EQ, 20 */
		/* 820CC504h case   19:*/		if ( !regs.CR[0].eq ) { return 0x820CC518;  }
		/* 820CC504h case   19:*/		return 0x820CC508;
		  /* 820CC508h */ case   20:  		/* addi R11, R11, 1 */
		/* 820CC508h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CC508h case   20:*/		return 0x820CC50C;
		  /* 820CC50Ch */ case   21:  		/* addi R10, R10, 1 */
		/* 820CC50Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CC50Ch case   21:*/		return 0x820CC510;
		  /* 820CC510h */ case   22:  		/* cmpw CR6, R11, R8 */
		/* 820CC510h case   22:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CC510h case   22:*/		return 0x820CC514;
		  /* 820CC514h */ case   23:  		/* bc 4, CR6_EQ, -28 */
		/* 820CC514h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820CC4F8;  }
		/* 820CC514h case   23:*/		return 0x820CC518;
	}
	return 0x820CC518;
} // Block from 820CC4B8h-820CC518h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820CC518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC518);
		  /* 820CC518h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CC518h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CC518h case    0:*/		return 0x820CC51C;
		  /* 820CC51Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CC51Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CC528;  }
		/* 820CC51Ch case    1:*/		return 0x820CC520;
		  /* 820CC520h */ case    2:  		/* li R3, 1 */
		/* 820CC520h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CC520h case    2:*/		return 0x820CC524;
		  /* 820CC524h */ case    3:  		/* b 76 */
		/* 820CC524h case    3:*/		return 0x820CC570;
		/* 820CC524h case    3:*/		return 0x820CC528;
	}
	return 0x820CC528;
} // Block from 820CC518h-820CC528h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC528);
		  /* 820CC528h */ case    0:  		/* cmpwi CR6, R7, 4 */
		/* 820CC528h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000004);
		/* 820CC528h case    0:*/		return 0x820CC52C;
		  /* 820CC52Ch */ case    1:  		/* bc 4, CR6_EQ, 64 */
		/* 820CC52Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CC56C;  }
		/* 820CC52Ch case    1:*/		return 0x820CC530;
		  /* 820CC530h */ case    2:  		/* lwz R3, <#[R3 + 24]> */
		/* 820CC530h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC530h case    2:*/		return 0x820CC534;
		  /* 820CC534h */ case    3:  		/* lwz R4, <#[R4 + 24]> */
		/* 820CC534h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000018) );
		/* 820CC534h case    3:*/		return 0x820CC538;
		  /* 820CC538h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CC538h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CC538h case    4:*/		return 0x820CC53C;
		  /* 820CC53Ch */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CC53Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820CC554;  }
		/* 820CC53Ch case    5:*/		return 0x820CC540;
		  /* 820CC540h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CC540h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC540h case    6:*/		return 0x820CC544;
		  /* 820CC544h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CC544h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CC544h case    7:*/		return 0x820CC548;
		  /* 820CC548h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CC548h case    8:*/		regs.CTR = regs.R11;
		/* 820CC548h case    8:*/		return 0x820CC54C;
		  /* 820CC54Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CC54Ch case    9:*/		if ( 1 ) { regs.LR = 0x820CC550; return (uint32)regs.CTR; }
		/* 820CC54Ch case    9:*/		return 0x820CC550;
		  /* 820CC550h */ case   10:  		/* b 16 */
		/* 820CC550h case   10:*/		return 0x820CC560;
		/* 820CC550h case   10:*/		return 0x820CC554;
	}
	return 0x820CC554;
} // Block from 820CC528h-820CC554h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC554);
		  /* 820CC554h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CC554h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CC554h case    0:*/		return 0x820CC558;
		  /* 820CC558h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CC558h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CC558h case    1:*/		return 0x820CC55C;
		  /* 820CC55Ch */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CC55Ch case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CC55Ch case    2:*/		return 0x820CC560;
	}
	return 0x820CC560;
} // Block from 820CC554h-820CC560h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CC560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC560);
		  /* 820CC560h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CC560h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CC560h case    0:*/		return 0x820CC564;
		  /* 820CC564h */ case    1:  		/* li R3, 1 */
		/* 820CC564h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CC564h case    1:*/		return 0x820CC568;
		  /* 820CC568h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CC568h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CC570;  }
		/* 820CC568h case    2:*/		return 0x820CC56C;
	}
	return 0x820CC56C;
} // Block from 820CC560h-820CC56Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CC56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC56C);
		  /* 820CC56Ch */ case    0:  		/* li R3, 0 */
		/* 820CC56Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC56Ch case    0:*/		return 0x820CC570;
	}
	return 0x820CC570;
} // Block from 820CC56Ch-820CC570h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC570);
		  /* 820CC570h */ case    0:  		/* addi R1, R1, 96 */
		/* 820CC570h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CC570h case    0:*/		return 0x820CC574;
		  /* 820CC574h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC574h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC574h case    1:*/		return 0x820CC578;
		  /* 820CC578h */ case    2:  		/* mtspr LR, R12 */
		/* 820CC578h case    2:*/		regs.LR = regs.R12;
		/* 820CC578h case    2:*/		return 0x820CC57C;
		  /* 820CC57Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CC57Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC57Ch case    3:*/		return 0x820CC580;
	}
	return 0x820CC580;
} // Block from 820CC570h-820CC580h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC580);
		  /* 820CC580h */ case    0:  		/* mfspr R12, LR */
		/* 820CC580h case    0:*/		regs.R12 = regs.LR;
		/* 820CC580h case    0:*/		return 0x820CC584;
		  /* 820CC584h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC584h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC584h case    1:*/		return 0x820CC588;
		  /* 820CC588h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CC588h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC588h case    2:*/		return 0x820CC58C;
		  /* 820CC58Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CC58Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC58Ch case    3:*/		return 0x820CC590;
		  /* 820CC590h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CC590h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CC590h case    4:*/		return 0x820CC594;
		  /* 820CC594h */ case    5:  		/* mr R30, R3 */
		/* 820CC594h case    5:*/		regs.R30 = regs.R3;
		/* 820CC594h case    5:*/		return 0x820CC598;
		  /* 820CC598h */ case    6:  		/* bl 2712 */
		/* 820CC598h case    6:*/		regs.LR = 0x820CC59C; return 0x820CD030;
		/* 820CC598h case    6:*/		return 0x820CC59C;
		  /* 820CC59Ch */ case    7:  		/* li R5, 16 */
		/* 820CC59Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CC59Ch case    7:*/		return 0x820CC5A0;
		  /* 820CC5A0h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CC5A0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC5A0h case    8:*/		return 0x820CC5A4;
		  /* 820CC5A4h */ case    9:  		/* li R4, 72 */
		/* 820CC5A4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 820CC5A4h case    9:*/		return 0x820CC5A8;
		  /* 820CC5A8h */ case   10:  		/* bl -13512 */
		/* 820CC5A8h case   10:*/		regs.LR = 0x820CC5AC; return 0x820C90E0;
		/* 820CC5A8h case   10:*/		return 0x820CC5AC;
		  /* 820CC5ACh */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CC5ACh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC5ACh case   11:*/		return 0x820CC5B0;
		  /* 820CC5B0h */ case   12:  		/* bc 12, CR0_EQ, 84 */
		/* 820CC5B0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CC604;  }
		/* 820CC5B0h case   12:*/		return 0x820CC5B4;
		  /* 820CC5B4h */ case   13:  		/* lis R10, -32255 */
		/* 820CC5B4h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC5B4h case   13:*/		return 0x820CC5B8;
		  /* 820CC5B8h */ case   14:  		/* li R11, 0 */
		/* 820CC5B8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC5B8h case   14:*/		return 0x820CC5BC;
		  /* 820CC5BCh */ case   15:  		/* li R9, 15 */
		/* 820CC5BCh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0xF);
		/* 820CC5BCh case   15:*/		return 0x820CC5C0;
		  /* 820CC5C0h */ case   16:  		/* addi R10, R10, 10700 */
		/* 820CC5C0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29CC);
		/* 820CC5C0h case   16:*/		return 0x820CC5C4;
		  /* 820CC5C4h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC5C4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC5C4h case   17:*/		return 0x820CC5C8;
		  /* 820CC5C8h */ case   18:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC5C8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC5C8h case   18:*/		return 0x820CC5CC;
		  /* 820CC5CCh */ case   19:  		/* li R8, 3 */
		/* 820CC5CCh case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 820CC5CCh case   19:*/		return 0x820CC5D0;
		  /* 820CC5D0h */ case   20:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC5D0h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC5D0h case   20:*/		return 0x820CC5D4;
		  /* 820CC5D4h */ case   21:  		/* mr R31, R3 */
		/* 820CC5D4h case   21:*/		regs.R31 = regs.R3;
		/* 820CC5D4h case   21:*/		return 0x820CC5D8;
		  /* 820CC5D8h */ case   22:  		/* stw R10, <#[R3]> */
		/* 820CC5D8h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC5D8h case   22:*/		return 0x820CC5DC;
		  /* 820CC5DCh */ case   23:  		/* std R11, <#[R3 + 16]> */
		/* 820CC5DCh case   23:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC5DCh case   23:*/		return 0x820CC5E0;
		  /* 820CC5E0h */ case   24:  		/* std R11, <#[R3 + 24]> */
		/* 820CC5E0h case   24:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC5E0h case   24:*/		return 0x820CC5E4;
		  /* 820CC5E4h */ case   25:  		/* std R11, <#[R3 + 32]> */
		/* 820CC5E4h case   25:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CC5E4h case   25:*/		return 0x820CC5E8;
		  /* 820CC5E8h */ case   26:  		/* std R11, <#[R3 + 40]> */
		/* 820CC5E8h case   26:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820CC5E8h case   26:*/		return 0x820CC5EC;
		  /* 820CC5ECh */ case   27:  		/* std R11, <#[R3 + 48]> */
		/* 820CC5ECh case   27:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CC5ECh case   27:*/		return 0x820CC5F0;
		  /* 820CC5F0h */ case   28:  		/* std R11, <#[R3 + 56]> */
		/* 820CC5F0h case   28:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CC5F0h case   28:*/		return 0x820CC5F4;
		  /* 820CC5F4h */ case   29:  		/* std R11, <#[R3 + 64]> */
		/* 820CC5F4h case   29:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000040) );
		/* 820CC5F4h case   29:*/		return 0x820CC5F8;
		  /* 820CC5F8h */ case   30:  		/* addi R11, R3, 16 */
		/* 820CC5F8h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 820CC5F8h case   30:*/		return 0x820CC5FC;
		  /* 820CC5FCh */ case   31:  		/* stw R8, <#[R3 + 16]> */
		/* 820CC5FCh case   31:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC5FCh case   31:*/		return 0x820CC600;
		  /* 820CC600h */ case   32:  		/* b 8 */
		/* 820CC600h case   32:*/		return 0x820CC608;
		/* 820CC600h case   32:*/		return 0x820CC604;
	}
	return 0x820CC604;
} // Block from 820CC580h-820CC604h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820CC604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC604);
		  /* 820CC604h */ case    0:  		/* li R31, 0 */
		/* 820CC604h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CC604h case    0:*/		return 0x820CC608;
	}
	return 0x820CC608;
} // Block from 820CC604h-820CC608h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC608);
		  /* 820CC608h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CC608h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CC608h case    0:*/		return 0x820CC60C;
		  /* 820CC60Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CC60Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CC618;  }
		/* 820CC60Ch case    1:*/		return 0x820CC610;
		  /* 820CC610h */ case    2:  		/* li R3, 0 */
		/* 820CC610h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC610h case    2:*/		return 0x820CC614;
		  /* 820CC614h */ case    3:  		/* b 120 */
		/* 820CC614h case    3:*/		return 0x820CC68C;
		/* 820CC614h case    3:*/		return 0x820CC618;
	}
	return 0x820CC618;
} // Block from 820CC608h-820CC618h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC618);
		  /* 820CC618h */ case    0:  		/* ld R7, <#[R30 + 16]> */
		/* 820CC618h case    0:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R30 + 0x00000010) );
		/* 820CC618h case    0:*/		return 0x820CC61C;
		  /* 820CC61Ch */ case    1:  		/* li R10, 5 */
		/* 820CC61Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820CC61Ch case    1:*/		return 0x820CC620;
		  /* 820CC620h */ case    2:  		/* addi R8, R31, 32 */
		/* 820CC620h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x20);
		/* 820CC620h case    2:*/		return 0x820CC624;
		  /* 820CC624h */ case    3:  		/* addi R9, R31, 16 */
		/* 820CC624h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x10);
		/* 820CC624h case    3:*/		return 0x820CC628;
		  /* 820CC628h */ case    4:  		/* addi R11, R30, 16 */
		/* 820CC628h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x10);
		/* 820CC628h case    4:*/		return 0x820CC62C;
		  /* 820CC62Ch */ case    5:  		/* addi R9, R30, 24 */
		/* 820CC62Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x18);
		/* 820CC62Ch case    5:*/		return 0x820CC630;
		  /* 820CC630h */ case    6:  		/* std R7, <#[R31 + 16]> */
		/* 820CC630h case    6:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 820CC630h case    6:*/		return 0x820CC634;
		  /* 820CC634h */ case    7:  		/* addi R8, R8, -8 */
		/* 820CC634h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFF8);
		/* 820CC634h case    7:*/		return 0x820CC638;
		  /* 820CC638h */ case    8:  		/* ld R7, <#[R30 + 24]> */
		/* 820CC638h case    8:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R30 + 0x00000018) );
		/* 820CC638h case    8:*/		return 0x820CC63C;
		  /* 820CC63Ch */ case    9:  		/* mtspr CTR, R10 */
		/* 820CC63Ch case    9:*/		regs.CTR = regs.R10;
		/* 820CC63Ch case    9:*/		return 0x820CC640;
		  /* 820CC640h */ case   10:  		/* std R7, <#[R31 + 24]> */
		/* 820CC640h case   10:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 820CC640h case   10:*/		return 0x820CC644;
		  /* 820CC644h */ case   11:  		/* ldu R10, <#[R9 + 8]> */
		/* 820CC644h case   11:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC644h case   11:*/		return 0x820CC648;
		  /* 820CC648h */ case   12:  		/* stdu R10, <#[R8 + 8]> */
		/* 820CC648h case   12:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820CC648h case   12:*/		return 0x820CC64C;
		  /* 820CC64Ch */ case   13:  		/* bc 16, CR0_LT, -8 */
		/* 820CC64Ch case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC644;  }
		/* 820CC64Ch case   13:*/		return 0x820CC650;
		  /* 820CC650h */ case   14:  		/* lwz R11, <#[R11]> */
		/* 820CC650h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CC650h case   14:*/		return 0x820CC654;
		  /* 820CC654h */ case   15:  		/* cmpwi CR6, R11, 4 */
		/* 820CC654h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820CC654h case   15:*/		return 0x820CC658;
		  /* 820CC658h */ case   16:  		/* bc 4, CR6_EQ, 48 */
		/* 820CC658h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820CC688;  }
		/* 820CC658h case   16:*/		return 0x820CC65C;
		  /* 820CC65Ch */ case   17:  		/* lwz R3, <#[R30 + 24]> */
		/* 820CC65Ch case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820CC65Ch case   17:*/		return 0x820CC660;
		  /* 820CC660h */ case   18:  		/* cmplwi CR6, R3, 0 */
		/* 820CC660h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CC660h case   18:*/		return 0x820CC664;
		  /* 820CC664h */ case   19:  		/* bc 12, CR6_EQ, 36 */
		/* 820CC664h case   19:*/		if ( regs.CR[6].eq ) { return 0x820CC688;  }
		/* 820CC664h case   19:*/		return 0x820CC668;
		  /* 820CC668h */ case   20:  		/* lwz R11, <#[R3]> */
		/* 820CC668h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC668h case   20:*/		return 0x820CC66C;
		  /* 820CC66Ch */ case   21:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC66Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC66Ch case   21:*/		return 0x820CC670;
		  /* 820CC670h */ case   22:  		/* mtspr CTR, R11 */
		/* 820CC670h case   22:*/		regs.CTR = regs.R11;
		/* 820CC670h case   22:*/		return 0x820CC674;
		  /* 820CC674h */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 820CC674h case   23:*/		if ( 1 ) { regs.LR = 0x820CC678; return (uint32)regs.CTR; }
		/* 820CC674h case   23:*/		return 0x820CC678;
		  /* 820CC678h */ case   24:  		/* stw R3, <#[R30 + 24]> */
		/* 820CC678h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820CC678h case   24:*/		return 0x820CC67C;
		  /* 820CC67Ch */ case   25:  		/* cmplwi CR0, R3, 0 */
		/* 820CC67Ch case   25:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC67Ch case   25:*/		return 0x820CC680;
		  /* 820CC680h */ case   26:  		/* li R3, 0 */
		/* 820CC680h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC680h case   26:*/		return 0x820CC684;
		  /* 820CC684h */ case   27:  		/* bc 12, CR0_EQ, 8 */
		/* 820CC684h case   27:*/		if ( regs.CR[0].eq ) { return 0x820CC68C;  }
		/* 820CC684h case   27:*/		return 0x820CC688;
	}
	return 0x820CC688;
} // Block from 820CC618h-820CC688h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820CC688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC688);
		  /* 820CC688h */ case    0:  		/* mr R3, R31 */
		/* 820CC688h case    0:*/		regs.R3 = regs.R31;
		/* 820CC688h case    0:*/		return 0x820CC68C;
	}
	return 0x820CC68C;
} // Block from 820CC688h-820CC68Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC68C);
		  /* 820CC68Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820CC68Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CC68Ch case    0:*/		return 0x820CC690;
		  /* 820CC690h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC690h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC690h case    1:*/		return 0x820CC694;
		  /* 820CC694h */ case    2:  		/* mtspr LR, R12 */
		/* 820CC694h case    2:*/		regs.LR = regs.R12;
		/* 820CC694h case    2:*/		return 0x820CC698;
		  /* 820CC698h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CC698h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC698h case    3:*/		return 0x820CC69C;
		  /* 820CC69Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CC69Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC69Ch case    4:*/		return 0x820CC6A0;
	}
	return 0x820CC6A0;
} // Block from 820CC68Ch-820CC6A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CC6A0h
// Function '?Copy@CNodeStatement@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC6A0);
		  /* 820CC6A0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820CC6A0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC6A0h case    0:*/		return 0x820CC6A4;
	}
	return 0x820CC6A4;
} // Block from 820CC6A0h-820CC6A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC6A4);
		  /* 820CC6A4h */ case    0:  		/* nop */
		/* 820CC6A4h case    0:*/		cpu::op::nop();
		/* 820CC6A4h case    0:*/		return 0x820CC6A8;
		  /* 820CC6A8h */ case    1:  		/* lis R10, -32255 */
		/* 820CC6A8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC6A8h case    1:*/		return 0x820CC6AC;
		  /* 820CC6ACh */ case    2:  		/* stw R4, <#[R3 + 16]> */
		/* 820CC6ACh case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC6ACh case    2:*/		return 0x820CC6B0;
		  /* 820CC6B0h */ case    3:  		/* li R11, 0 */
		/* 820CC6B0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC6B0h case    3:*/		return 0x820CC6B4;
		  /* 820CC6B4h */ case    4:  		/* stw R5, <#[R3 + 20]> */
		/* 820CC6B4h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820CC6B4h case    4:*/		return 0x820CC6B8;
		  /* 820CC6B8h */ case    5:  		/* li R9, 17 */
		/* 820CC6B8h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x11);
		/* 820CC6B8h case    5:*/		return 0x820CC6BC;
		  /* 820CC6BCh */ case    6:  		/* stw R6, <#[R3 + 24]> */
		/* 820CC6BCh case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC6BCh case    6:*/		return 0x820CC6C0;
		  /* 820CC6C0h */ case    7:  		/* addi R10, R10, 10712 */
		/* 820CC6C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29D8);
		/* 820CC6C0h case    7:*/		return 0x820CC6C4;
		  /* 820CC6C4h */ case    8:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC6C4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC6C4h case    8:*/		return 0x820CC6C8;
		  /* 820CC6C8h */ case    9:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC6C8h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC6C8h case    9:*/		return 0x820CC6CC;
		  /* 820CC6CCh */ case   10:  		/* stw R10, <#[R3]> */
		/* 820CC6CCh case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC6CCh case   10:*/		return 0x820CC6D0;
		  /* 820CC6D0h */ case   11:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC6D0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC6D0h case   11:*/		return 0x820CC6D4;
		  /* 820CC6D4h */ case   12:  		/* bclr 20, CR0_LT */
		/* 820CC6D4h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC6D4h case   12:*/		return 0x820CC6D8;
	}
	return 0x820CC6D8;
} // Block from 820CC6A4h-820CC6D8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CC6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC6D8);
		  /* 820CC6D8h */ case    0:  		/* mfspr R12, LR */
		/* 820CC6D8h case    0:*/		regs.R12 = regs.LR;
		/* 820CC6D8h case    0:*/		return 0x820CC6DC;
		  /* 820CC6DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC6DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC6DCh case    1:*/		return 0x820CC6E0;
		  /* 820CC6E0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CC6E0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC6E0h case    2:*/		return 0x820CC6E4;
		  /* 820CC6E4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CC6E4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC6E4h case    3:*/		return 0x820CC6E8;
		  /* 820CC6E8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CC6E8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CC6E8h case    4:*/		return 0x820CC6EC;
		  /* 820CC6ECh */ case    5:  		/* mr R30, R3 */
		/* 820CC6ECh case    5:*/		regs.R30 = regs.R3;
		/* 820CC6ECh case    5:*/		return 0x820CC6F0;
		  /* 820CC6F0h */ case    6:  		/* bl 2368 */
		/* 820CC6F0h case    6:*/		regs.LR = 0x820CC6F4; return 0x820CD030;
		/* 820CC6F0h case    6:*/		return 0x820CC6F4;
		  /* 820CC6F4h */ case    7:  		/* li R5, 16 */
		/* 820CC6F4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CC6F4h case    7:*/		return 0x820CC6F8;
		  /* 820CC6F8h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CC6F8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC6F8h case    8:*/		return 0x820CC6FC;
		  /* 820CC6FCh */ case    9:  		/* li R4, 28 */
		/* 820CC6FCh case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 820CC6FCh case    9:*/		return 0x820CC700;
		  /* 820CC700h */ case   10:  		/* bl -13856 */
		/* 820CC700h case   10:*/		regs.LR = 0x820CC704; return 0x820C90E0;
		/* 820CC700h case   10:*/		return 0x820CC704;
		  /* 820CC704h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CC704h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC704h case   11:*/		return 0x820CC708;
		  /* 820CC708h */ case   12:  		/* bc 12, CR0_EQ, 56 */
		/* 820CC708h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CC740;  }
		/* 820CC708h case   12:*/		return 0x820CC70C;
		  /* 820CC70Ch */ case   13:  		/* lis R10, -32255 */
		/* 820CC70Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC70Ch case   13:*/		return 0x820CC710;
		  /* 820CC710h */ case   14:  		/* li R11, 0 */
		/* 820CC710h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC710h case   14:*/		return 0x820CC714;
		  /* 820CC714h */ case   15:  		/* li R9, 17 */
		/* 820CC714h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x11);
		/* 820CC714h case   15:*/		return 0x820CC718;
		  /* 820CC718h */ case   16:  		/* addi R10, R10, 10712 */
		/* 820CC718h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29D8);
		/* 820CC718h case   16:*/		return 0x820CC71C;
		  /* 820CC71Ch */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC71Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC71Ch case   17:*/		return 0x820CC720;
		  /* 820CC720h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC720h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC720h case   18:*/		return 0x820CC724;
		  /* 820CC724h */ case   19:  		/* mr R31, R3 */
		/* 820CC724h case   19:*/		regs.R31 = regs.R3;
		/* 820CC724h case   19:*/		return 0x820CC728;
		  /* 820CC728h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CC728h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC728h case   20:*/		return 0x820CC72C;
		  /* 820CC72Ch */ case   21:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC72Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC72Ch case   21:*/		return 0x820CC730;
		  /* 820CC730h */ case   22:  		/* stw R11, <#[R3 + 16]> */
		/* 820CC730h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC730h case   22:*/		return 0x820CC734;
		  /* 820CC734h */ case   23:  		/* stw R11, <#[R3 + 20]> */
		/* 820CC734h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CC734h case   23:*/		return 0x820CC738;
		  /* 820CC738h */ case   24:  		/* stw R11, <#[R3 + 24]> */
		/* 820CC738h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC738h case   24:*/		return 0x820CC73C;
		  /* 820CC73Ch */ case   25:  		/* b 8 */
		/* 820CC73Ch case   25:*/		return 0x820CC744;
		/* 820CC73Ch case   25:*/		return 0x820CC740;
	}
	return 0x820CC740;
} // Block from 820CC6D8h-820CC740h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820CC740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC740);
		  /* 820CC740h */ case    0:  		/* li R31, 0 */
		/* 820CC740h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CC740h case    0:*/		return 0x820CC744;
	}
	return 0x820CC744;
} // Block from 820CC740h-820CC744h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC744);
		  /* 820CC744h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CC744h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CC744h case    0:*/		return 0x820CC748;
		  /* 820CC748h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CC748h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CC754;  }
		/* 820CC748h case    1:*/		return 0x820CC74C;
		  /* 820CC74Ch */ case    2:  		/* li R3, 0 */
		/* 820CC74Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC74Ch case    2:*/		return 0x820CC750;
		  /* 820CC750h */ case    3:  		/* b 140 */
		/* 820CC750h case    3:*/		return 0x820CC7DC;
		/* 820CC750h case    3:*/		return 0x820CC754;
	}
	return 0x820CC754;
} // Block from 820CC744h-820CC754h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC754);
		  /* 820CC754h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CC754h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CC754h case    0:*/		return 0x820CC758;
		  /* 820CC758h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CC758h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CC758h case    1:*/		return 0x820CC75C;
		  /* 820CC75Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CC75Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CC780;  }
		/* 820CC75Ch case    2:*/		return 0x820CC760;
		  /* 820CC760h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CC760h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CC760h case    3:*/		return 0x820CC764;
		  /* 820CC764h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CC764h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC764h case    4:*/		return 0x820CC768;
		  /* 820CC768h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC768h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC768h case    5:*/		return 0x820CC76C;
		  /* 820CC76Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820CC76Ch case    6:*/		regs.CTR = regs.R11;
		/* 820CC76Ch case    6:*/		return 0x820CC770;
		  /* 820CC770h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CC770h case    7:*/		if ( 1 ) { regs.LR = 0x820CC774; return (uint32)regs.CTR; }
		/* 820CC770h case    7:*/		return 0x820CC774;
		  /* 820CC774h */ case    8:  		/* stw R3, <#[R31 + 16]> */
		/* 820CC774h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CC774h case    8:*/		return 0x820CC778;
		  /* 820CC778h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CC778h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC778h case    9:*/		return 0x820CC77C;
		  /* 820CC77Ch */ case   10:  		/* bc 12, CR0_EQ, -48 */
		/* 820CC77Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820CC74C;  }
		/* 820CC77Ch case   10:*/		return 0x820CC780;
	}
	return 0x820CC780;
} // Block from 820CC754h-820CC780h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC780);
		  /* 820CC780h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CC780h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CC780h case    0:*/		return 0x820CC784;
		  /* 820CC784h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CC784h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CC784h case    1:*/		return 0x820CC788;
		  /* 820CC788h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CC788h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CC7AC;  }
		/* 820CC788h case    2:*/		return 0x820CC78C;
		  /* 820CC78Ch */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CC78Ch case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CC78Ch case    3:*/		return 0x820CC790;
		  /* 820CC790h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CC790h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC790h case    4:*/		return 0x820CC794;
		  /* 820CC794h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC794h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC794h case    5:*/		return 0x820CC798;
		  /* 820CC798h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CC798h case    6:*/		regs.CTR = regs.R11;
		/* 820CC798h case    6:*/		return 0x820CC79C;
		  /* 820CC79Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CC79Ch case    7:*/		if ( 1 ) { regs.LR = 0x820CC7A0; return (uint32)regs.CTR; }
		/* 820CC79Ch case    7:*/		return 0x820CC7A0;
		  /* 820CC7A0h */ case    8:  		/* stw R3, <#[R31 + 20]> */
		/* 820CC7A0h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CC7A0h case    8:*/		return 0x820CC7A4;
		  /* 820CC7A4h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CC7A4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC7A4h case    9:*/		return 0x820CC7A8;
		  /* 820CC7A8h */ case   10:  		/* bc 12, CR0_EQ, -92 */
		/* 820CC7A8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CC74C;  }
		/* 820CC7A8h case   10:*/		return 0x820CC7AC;
	}
	return 0x820CC7AC;
} // Block from 820CC780h-820CC7ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC7ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC7AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC7AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC7AC);
		  /* 820CC7ACh */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CC7ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CC7ACh case    0:*/		return 0x820CC7B0;
		  /* 820CC7B0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CC7B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CC7B0h case    1:*/		return 0x820CC7B4;
		  /* 820CC7B4h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CC7B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CC7D8;  }
		/* 820CC7B4h case    2:*/		return 0x820CC7B8;
		  /* 820CC7B8h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CC7B8h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CC7B8h case    3:*/		return 0x820CC7BC;
		  /* 820CC7BCh */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CC7BCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC7BCh case    4:*/		return 0x820CC7C0;
		  /* 820CC7C0h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CC7C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CC7C0h case    5:*/		return 0x820CC7C4;
		  /* 820CC7C4h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CC7C4h case    6:*/		regs.CTR = regs.R11;
		/* 820CC7C4h case    6:*/		return 0x820CC7C8;
		  /* 820CC7C8h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CC7C8h case    7:*/		if ( 1 ) { regs.LR = 0x820CC7CC; return (uint32)regs.CTR; }
		/* 820CC7C8h case    7:*/		return 0x820CC7CC;
		  /* 820CC7CCh */ case    8:  		/* stw R3, <#[R31 + 24]> */
		/* 820CC7CCh case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CC7CCh case    8:*/		return 0x820CC7D0;
		  /* 820CC7D0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CC7D0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC7D0h case    9:*/		return 0x820CC7D4;
		  /* 820CC7D4h */ case   10:  		/* bc 12, CR0_EQ, -136 */
		/* 820CC7D4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CC74C;  }
		/* 820CC7D4h case   10:*/		return 0x820CC7D8;
	}
	return 0x820CC7D8;
} // Block from 820CC7ACh-820CC7D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC7D8);
		  /* 820CC7D8h */ case    0:  		/* mr R3, R31 */
		/* 820CC7D8h case    0:*/		regs.R3 = regs.R31;
		/* 820CC7D8h case    0:*/		return 0x820CC7DC;
	}
	return 0x820CC7DC;
} // Block from 820CC7D8h-820CC7DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC7DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC7DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC7DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC7DC);
		  /* 820CC7DCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820CC7DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CC7DCh case    0:*/		return 0x820CC7E0;
		  /* 820CC7E0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC7E0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC7E0h case    1:*/		return 0x820CC7E4;
		  /* 820CC7E4h */ case    2:  		/* mtspr LR, R12 */
		/* 820CC7E4h case    2:*/		regs.LR = regs.R12;
		/* 820CC7E4h case    2:*/		return 0x820CC7E8;
		  /* 820CC7E8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CC7E8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC7E8h case    3:*/		return 0x820CC7EC;
		  /* 820CC7ECh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CC7ECh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC7ECh case    4:*/		return 0x820CC7F0;
		  /* 820CC7F0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CC7F0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC7F0h case    5:*/		return 0x820CC7F4;
	}
	return 0x820CC7F4;
} // Block from 820CC7DCh-820CC7F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CC7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC7F4);
		  /* 820CC7F4h */ case    0:  		/* nop */
		/* 820CC7F4h case    0:*/		cpu::op::nop();
		/* 820CC7F4h case    0:*/		return 0x820CC7F8;
		  /* 820CC7F8h */ case    1:  		/* lis R9, -32255 */
		/* 820CC7F8h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CC7F8h case    1:*/		return 0x820CC7FC;
		  /* 820CC7FCh */ case    2:  		/* li R11, 5 */
		/* 820CC7FCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CC7FCh case    2:*/		return 0x820CC800;
		  /* 820CC800h */ case    3:  		/* li R10, 0 */
		/* 820CC800h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CC800h case    3:*/		return 0x820CC804;
		  /* 820CC804h */ case    4:  		/* addi R8, R9, 10724 */
		/* 820CC804h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x29E4);
		/* 820CC804h case    4:*/		return 0x820CC808;
		  /* 820CC808h */ case    5:  		/* li R7, 16 */
		/* 820CC808h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 820CC808h case    5:*/		return 0x820CC80C;
		  /* 820CC80Ch */ case    6:  		/* stw R10, <#[R3 + 8]> */
		/* 820CC80Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC80Ch case    6:*/		return 0x820CC810;
		  /* 820CC810h */ case    7:  		/* stw R10, <#[R3 + 12]> */
		/* 820CC810h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC810h case    7:*/		return 0x820CC814;
		  /* 820CC814h */ case    8:  		/* addi R9, R3, 8 */
		/* 820CC814h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 820CC814h case    8:*/		return 0x820CC818;
		  /* 820CC818h */ case    9:  		/* stw R8, <#[R3]> */
		/* 820CC818h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC818h case    9:*/		return 0x820CC81C;
		  /* 820CC81Ch */ case   10:  		/* addi R10, R4, -8 */
		/* 820CC81Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFF8);
		/* 820CC81Ch case   10:*/		return 0x820CC820;
		  /* 820CC820h */ case   11:  		/* stw R7, <#[R3 + 4]> */
		/* 820CC820h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC820h case   11:*/		return 0x820CC824;
		  /* 820CC824h */ case   12:  		/* mtspr CTR, R11 */
		/* 820CC824h case   12:*/		regs.CTR = regs.R11;
		/* 820CC824h case   12:*/		return 0x820CC828;
		  /* 820CC828h */ case   13:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CC828h case   13:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CC828h case   13:*/		return 0x820CC82C;
		  /* 820CC82Ch */ case   14:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CC82Ch case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC82Ch case   14:*/		return 0x820CC830;
		  /* 820CC830h */ case   15:  		/* bc 16, CR0_LT, -8 */
		/* 820CC830h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC828;  }
		/* 820CC830h case   15:*/		return 0x820CC834;
		  /* 820CC834h */ case   16:  		/* stw R5, <#[R3 + 56]> */
		/* 820CC834h case   16:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000038) );
		/* 820CC834h case   16:*/		return 0x820CC838;
		  /* 820CC838h */ case   17:  		/* stw R6, <#[R3 + 60]> */
		/* 820CC838h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CC838h case   17:*/		return 0x820CC83C;
		  /* 820CC83Ch */ case   18:  		/* bclr 20, CR0_LT */
		/* 820CC83Ch case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC83Ch case   18:*/		return 0x820CC840;
	}
	return 0x820CC840;
} // Block from 820CC7F4h-820CC840h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CC840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC840);
		  /* 820CC840h */ case    0:  		/* mfspr R12, LR */
		/* 820CC840h case    0:*/		regs.R12 = regs.LR;
		/* 820CC840h case    0:*/		return 0x820CC844;
		  /* 820CC844h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC844h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC844h case    1:*/		return 0x820CC848;
		  /* 820CC848h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CC848h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CC848h case    2:*/		return 0x820CC84C;
		  /* 820CC84Ch */ case    3:  		/* mr R6, R3 */
		/* 820CC84Ch case    3:*/		regs.R6 = regs.R3;
		/* 820CC84Ch case    3:*/		return 0x820CC850;
		  /* 820CC850h */ case    4:  		/* mr R7, R4 */
		/* 820CC850h case    4:*/		regs.R7 = regs.R4;
		/* 820CC850h case    4:*/		return 0x820CC854;
		  /* 820CC854h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820CC854h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CC854h case    5:*/		return 0x820CC858;
		  /* 820CC858h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820CC858h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CC86C;  }
		/* 820CC858h case    6:*/		return 0x820CC85C;
		  /* 820CC85Ch */ case    7:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CC85Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CC85Ch case    7:*/		return 0x820CC860;
		  /* 820CC860h */ case    8:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CC860h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC860h case    8:*/		return 0x820CC864;
		  /* 820CC864h */ case    9:  		/* cmpw CR6, R11, R10 */
		/* 820CC864h case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CC864h case    9:*/		return 0x820CC868;
		  /* 820CC868h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820CC868h case   10:*/		if ( regs.CR[6].eq ) { return 0x820CC874;  }
		/* 820CC868h case   10:*/		return 0x820CC86C;
	}
	return 0x820CC86C;
} // Block from 820CC840h-820CC86Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CC86Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC86C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC86C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC86C);
		  /* 820CC86Ch */ case    0:  		/* li R3, 0 */
		/* 820CC86Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC86Ch case    0:*/		return 0x820CC870;
		  /* 820CC870h */ case    1:  		/* b 60 */
		/* 820CC870h case    1:*/		return 0x820CC8AC;
		/* 820CC870h case    1:*/		return 0x820CC874;
	}
	return 0x820CC874;
} // Block from 820CC86Ch-820CC874h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CC874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC874);
		  /* 820CC874h */ case    0:  		/* addi R4, R7, 16 */
		/* 820CC874h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R7,0x10);
		/* 820CC874h case    0:*/		return 0x820CC878;
		  /* 820CC878h */ case    1:  		/* addi R3, R6, 16 */
		/* 820CC878h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R6,0x10);
		/* 820CC878h case    1:*/		return 0x820CC87C;
		  /* 820CC87Ch */ case    2:  		/* bl -12652 */
		/* 820CC87Ch case    2:*/		regs.LR = 0x820CC880; return 0x820C9710;
		/* 820CC87Ch case    2:*/		return 0x820CC880;
		  /* 820CC880h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820CC880h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CC880h case    3:*/		return 0x820CC884;
		  /* 820CC884h */ case    4:  		/* bc 12, CR0_EQ, -24 */
		/* 820CC884h case    4:*/		if ( regs.CR[0].eq ) { return 0x820CC86C;  }
		/* 820CC884h case    4:*/		return 0x820CC888;
		  /* 820CC888h */ case    5:  		/* lwz R11, <#[R7 + 56]> */
		/* 820CC888h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000038) );
		/* 820CC888h case    5:*/		return 0x820CC88C;
		  /* 820CC88Ch */ case    6:  		/* lwz R10, <#[R6 + 56]> */
		/* 820CC88Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000038) );
		/* 820CC88Ch case    6:*/		return 0x820CC890;
		  /* 820CC890h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820CC890h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CC890h case    7:*/		return 0x820CC894;
		  /* 820CC894h */ case    8:  		/* bc 4, CR6_EQ, -40 */
		/* 820CC894h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CC86C;  }
		/* 820CC894h case    8:*/		return 0x820CC898;
	}
	return 0x820CC898;
} // Block from 820CC874h-820CC898h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CC898h
// Function '??0CNodeStateBlockFunctionCall@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC898);
		  /* 820CC898h */ case    0:  		/* lwz R11, <#[R7 + 60]> */
		/* 820CC898h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000003C) );
		/* 820CC898h case    0:*/		return 0x820CC89C;
		  /* 820CC89Ch */ case    1:  		/* lwz R10, <#[R6 + 60]> */
		/* 820CC89Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000003C) );
		/* 820CC89Ch case    1:*/		return 0x820CC8A0;
		  /* 820CC8A0h */ case    2:  		/* subf R11, R11, R10 */
		/* 820CC8A0h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820CC8A0h case    2:*/		return 0x820CC8A4;
		  /* 820CC8A4h */ case    3:  		/* cntlzw R11, R11 */
		/* 820CC8A4h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CC8A4h case    3:*/		return 0x820CC8A8;
		  /* 820CC8A8h */ case    4:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CC8A8h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CC8A8h case    4:*/		return 0x820CC8AC;
	}
	return 0x820CC8AC;
} // Block from 820CC898h-820CC8ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CC8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC8AC);
		  /* 820CC8ACh */ case    0:  		/* addi R1, R1, 96 */
		/* 820CC8ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CC8ACh case    0:*/		return 0x820CC8B0;
		  /* 820CC8B0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC8B0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC8B0h case    1:*/		return 0x820CC8B4;
		  /* 820CC8B4h */ case    2:  		/* mtspr LR, R12 */
		/* 820CC8B4h case    2:*/		regs.LR = regs.R12;
		/* 820CC8B4h case    2:*/		return 0x820CC8B8;
		  /* 820CC8B8h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CC8B8h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC8B8h case    3:*/		return 0x820CC8BC;
	}
	return 0x820CC8BC;
} // Block from 820CC8ACh-820CC8BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC8BC);
		  /* 820CC8BCh */ case    0:  		/* nop */
		/* 820CC8BCh case    0:*/		cpu::op::nop();
		/* 820CC8BCh case    0:*/		return 0x820CC8C0;
	}
	return 0x820CC8C0;
} // Block from 820CC8BCh-820CC8C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC8C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC8C0);
		  /* 820CC8C0h */ case    0:  		/* mfspr R12, LR */
		/* 820CC8C0h case    0:*/		regs.R12 = regs.LR;
		/* 820CC8C0h case    0:*/		return 0x820CC8C4;
		  /* 820CC8C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC8C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC8C4h case    1:*/		return 0x820CC8C8;
	}
	return 0x820CC8C8;
} // Block from 820CC8C0h-820CC8C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CC8C8h
// Function '?IsEqual@CNodeStateBlockFunctionCall@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC8C8);
		  /* 820CC8C8h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 820CC8C8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC8C8h case    0:*/		return 0x820CC8CC;
		  /* 820CC8CCh */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CC8CCh case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CC8CCh case    1:*/		return 0x820CC8D0;
		  /* 820CC8D0h */ case    2:  		/* mr R31, R3 */
		/* 820CC8D0h case    2:*/		regs.R31 = regs.R3;
		/* 820CC8D0h case    2:*/		return 0x820CC8D4;
		  /* 820CC8D4h */ case    3:  		/* bl 1884 */
		/* 820CC8D4h case    3:*/		regs.LR = 0x820CC8D8; return 0x820CD030;
		/* 820CC8D4h case    3:*/		return 0x820CC8D8;
		  /* 820CC8D8h */ case    4:  		/* li R5, 16 */
		/* 820CC8D8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CC8D8h case    4:*/		return 0x820CC8DC;
		  /* 820CC8DCh */ case    5:  		/* lwz R3, <#[R3]> */
		/* 820CC8DCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC8DCh case    5:*/		return 0x820CC8E0;
		  /* 820CC8E0h */ case    6:  		/* li R4, 64 */
		/* 820CC8E0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x40);
		/* 820CC8E0h case    6:*/		return 0x820CC8E4;
		  /* 820CC8E4h */ case    7:  		/* bl -14340 */
		/* 820CC8E4h case    7:*/		regs.LR = 0x820CC8E8; return 0x820C90E0;
		/* 820CC8E4h case    7:*/		return 0x820CC8E8;
		  /* 820CC8E8h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820CC8E8h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CC8E8h case    8:*/		return 0x820CC8EC;
		  /* 820CC8ECh */ case    9:  		/* bc 12, CR0_EQ, 48 */
		/* 820CC8ECh case    9:*/		if ( regs.CR[0].eq ) { return 0x820CC91C;  }
		/* 820CC8ECh case    9:*/		return 0x820CC8F0;
		  /* 820CC8F0h */ case   10:  		/* lis R10, -32255 */
		/* 820CC8F0h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC8F0h case   10:*/		return 0x820CC8F4;
		  /* 820CC8F4h */ case   11:  		/* li R11, 0 */
		/* 820CC8F4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC8F4h case   11:*/		return 0x820CC8F8;
		  /* 820CC8F8h */ case   12:  		/* li R9, 16 */
		/* 820CC8F8h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820CC8F8h case   12:*/		return 0x820CC8FC;
		  /* 820CC8FCh */ case   13:  		/* addi R10, R10, 10724 */
		/* 820CC8FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29E4);
		/* 820CC8FCh case   13:*/		return 0x820CC900;
		  /* 820CC900h */ case   14:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC900h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC900h case   14:*/		return 0x820CC904;
		  /* 820CC904h */ case   15:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC904h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC904h case   15:*/		return 0x820CC908;
		  /* 820CC908h */ case   16:  		/* stw R10, <#[R3]> */
		/* 820CC908h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC908h case   16:*/		return 0x820CC90C;
		  /* 820CC90Ch */ case   17:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC90Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC90Ch case   17:*/		return 0x820CC910;
		  /* 820CC910h */ case   18:  		/* stw R11, <#[R3 + 56]> */
		/* 820CC910h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CC910h case   18:*/		return 0x820CC914;
		  /* 820CC914h */ case   19:  		/* stw R11, <#[R3 + 60]> */
		/* 820CC914h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CC914h case   19:*/		return 0x820CC918;
		  /* 820CC918h */ case   20:  		/* b 8 */
		/* 820CC918h case   20:*/		return 0x820CC920;
		/* 820CC918h case   20:*/		return 0x820CC91C;
	}
	return 0x820CC91C;
} // Block from 820CC8C8h-820CC91Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820CC91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC91C);
		  /* 820CC91Ch */ case    0:  		/* li R3, 0 */
		/* 820CC91Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CC91Ch case    0:*/		return 0x820CC920;
	}
	return 0x820CC920;
} // Block from 820CC91Ch-820CC920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC920);
		  /* 820CC920h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820CC920h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CC920h case    0:*/		return 0x820CC924;
		  /* 820CC924h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 820CC924h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CC954;  }
		/* 820CC924h case    1:*/		return 0x820CC928;
		  /* 820CC928h */ case    2:  		/* li R11, 5 */
		/* 820CC928h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CC928h case    2:*/		return 0x820CC92C;
		  /* 820CC92Ch */ case    3:  		/* addi R10, R31, 8 */
		/* 820CC92Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x8);
		/* 820CC92Ch case    3:*/		return 0x820CC930;
		  /* 820CC930h */ case    4:  		/* addi R9, R3, 8 */
		/* 820CC930h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 820CC930h case    4:*/		return 0x820CC934;
		  /* 820CC934h */ case    5:  		/* mtspr CTR, R11 */
		/* 820CC934h case    5:*/		regs.CTR = regs.R11;
		/* 820CC934h case    5:*/		return 0x820CC938;
		  /* 820CC938h */ case    6:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CC938h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CC938h case    6:*/		return 0x820CC93C;
		  /* 820CC93Ch */ case    7:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CC93Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CC93Ch case    7:*/		return 0x820CC940;
		  /* 820CC940h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820CC940h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CC938;  }
		/* 820CC940h case    8:*/		return 0x820CC944;
		  /* 820CC944h */ case    9:  		/* lwz R11, <#[R31 + 56]> */
		/* 820CC944h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820CC944h case    9:*/		return 0x820CC948;
		  /* 820CC948h */ case   10:  		/* stw R11, <#[R3 + 56]> */
		/* 820CC948h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820CC948h case   10:*/		return 0x820CC94C;
		  /* 820CC94Ch */ case   11:  		/* lwz R11, <#[R31 + 60]> */
		/* 820CC94Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CC94Ch case   11:*/		return 0x820CC950;
	}
	return 0x820CC950;
} // Block from 820CC920h-820CC950h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CC950h
// Function '??0CNodeExpression@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC950);
		  /* 820CC950h */ case    0:  		/* stw R11, <#[R3 + 60]> */
		/* 820CC950h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CC950h case    0:*/		return 0x820CC954;
	}
	return 0x820CC954;
} // Block from 820CC950h-820CC954h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC954);
		  /* 820CC954h */ case    0:  		/* addi R1, R1, 96 */
		/* 820CC954h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CC954h case    0:*/		return 0x820CC958;
		  /* 820CC958h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CC958h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC958h case    1:*/		return 0x820CC95C;
		  /* 820CC95Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CC95Ch case    2:*/		regs.LR = regs.R12;
		/* 820CC95Ch case    2:*/		return 0x820CC960;
		  /* 820CC960h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820CC960h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC960h case    3:*/		return 0x820CC964;
		  /* 820CC964h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820CC964h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC964h case    4:*/		return 0x820CC968;
	}
	return 0x820CC968;
} // Block from 820CC954h-820CC968h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CC968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC968);
		  /* 820CC968h */ case    0:  		/* lis R10, -32255 */
		/* 820CC968h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC968h case    0:*/		return 0x820CC96C;
		  /* 820CC96Ch */ case    1:  		/* li R11, 0 */
		/* 820CC96Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC96Ch case    1:*/		return 0x820CC970;
		  /* 820CC970h */ case    2:  		/* li R9, 18 */
		/* 820CC970h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x12);
		/* 820CC970h case    2:*/		return 0x820CC974;
		  /* 820CC974h */ case    3:  		/* addi R10, R10, 10736 */
		/* 820CC974h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29F0);
		/* 820CC974h case    3:*/		return 0x820CC978;
		  /* 820CC978h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC978h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC978h case    4:*/		return 0x820CC97C;
		  /* 820CC97Ch */ case    5:  		/* li R8, 2 */
		/* 820CC97Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 820CC97Ch case    5:*/		return 0x820CC980;
		  /* 820CC980h */ case    6:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC980h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC980h case    6:*/		return 0x820CC984;
		  /* 820CC984h */ case    7:  		/* stw R10, <#[R3]> */
		/* 820CC984h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC984h case    7:*/		return 0x820CC988;
		  /* 820CC988h */ case    8:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC988h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC988h case    8:*/		return 0x820CC98C;
		  /* 820CC98Ch */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 820CC98Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC98Ch case    9:*/		return 0x820CC990;
		  /* 820CC990h */ case   10:  		/* stw R11, <#[R3 + 20]> */
		/* 820CC990h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CC990h case   10:*/		return 0x820CC994;
		  /* 820CC994h */ case   11:  		/* stw R8, <#[R3 + 28]> */
		/* 820CC994h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CC994h case   11:*/		return 0x820CC998;
		  /* 820CC998h */ case   12:  		/* stw R11, <#[R3 + 24]> */
		/* 820CC998h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC998h case   12:*/		return 0x820CC99C;
		  /* 820CC99Ch */ case   13:  		/* bclr 20, CR0_LT */
		/* 820CC99Ch case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC99Ch case   13:*/		return 0x820CC9A0;
	}
	return 0x820CC9A0;
} // Block from 820CC968h-820CC9A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CC9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC9A0);
		  /* 820CC9A0h */ case    0:  		/* lis R10, -32255 */
		/* 820CC9A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CC9A0h case    0:*/		return 0x820CC9A4;
		  /* 820CC9A4h */ case    1:  		/* stw R5, <#[R3 + 16]> */
		/* 820CC9A4h case    1:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000010) );
		/* 820CC9A4h case    1:*/		return 0x820CC9A8;
		  /* 820CC9A8h */ case    2:  		/* li R11, 0 */
		/* 820CC9A8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CC9A8h case    2:*/		return 0x820CC9AC;
		  /* 820CC9ACh */ case    3:  		/* stw R6, <#[R3 + 20]> */
		/* 820CC9ACh case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 820CC9ACh case    3:*/		return 0x820CC9B0;
	}
	return 0x820CC9B0;
} // Block from 820CC9A0h-820CC9B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CC9B0h
// Function '??0CNodeExpression@D3DXShader@@QAA@PAVCNode@1@W4_D3DEXPR_OP@1@00HPBUD3DXTOKEN@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC9B0);
		  /* 820CC9B0h */ case    0:  		/* li R9, 18 */
		/* 820CC9B0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x12);
		/* 820CC9B0h case    0:*/		return 0x820CC9B4;
		  /* 820CC9B4h */ case    1:  		/* stw R4, <#[R3 + 28]> */
		/* 820CC9B4h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CC9B4h case    1:*/		return 0x820CC9B8;
		  /* 820CC9B8h */ case    2:  		/* addi R10, R10, 10736 */
		/* 820CC9B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29F0);
		/* 820CC9B8h case    2:*/		return 0x820CC9BC;
		  /* 820CC9BCh */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 820CC9BCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CC9BCh case    3:*/		return 0x820CC9C0;
		  /* 820CC9C0h */ case    4:  		/* stw R9, <#[R3 + 4]> */
		/* 820CC9C0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CC9C0h case    4:*/		return 0x820CC9C4;
		  /* 820CC9C4h */ case    5:  		/* stw R10, <#[R3]> */
		/* 820CC9C4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CC9C4h case    5:*/		return 0x820CC9C8;
		  /* 820CC9C8h */ case    6:  		/* stw R11, <#[R3 + 12]> */
		/* 820CC9C8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CC9C8h case    6:*/		return 0x820CC9CC;
		  /* 820CC9CCh */ case    7:  		/* stw R7, <#[R3 + 24]> */
		/* 820CC9CCh case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000018) );
		/* 820CC9CCh case    7:*/		return 0x820CC9D0;
		  /* 820CC9D0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820CC9D0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CC9D0h case    8:*/		return 0x820CC9D4;
	}
	return 0x820CC9D4;
} // Block from 820CC9B0h-820CC9D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CC9D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC9D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC9D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC9D4);
		  /* 820CC9D4h */ case    0:  		/* nop */
		/* 820CC9D4h case    0:*/		cpu::op::nop();
		/* 820CC9D4h case    0:*/		return 0x820CC9D8;
	}
	return 0x820CC9D8;
} // Block from 820CC9D4h-820CC9D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CC9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CC9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CC9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CC9D8);
		  /* 820CC9D8h */ case    0:  		/* mfspr R12, LR */
		/* 820CC9D8h case    0:*/		regs.R12 = regs.LR;
		/* 820CC9D8h case    0:*/		return 0x820CC9DC;
		  /* 820CC9DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CC9DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CC9DCh case    1:*/		return 0x820CC9E0;
		  /* 820CC9E0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CC9E0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CC9E0h case    2:*/		return 0x820CC9E4;
		  /* 820CC9E4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CC9E4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CC9E4h case    3:*/		return 0x820CC9E8;
		  /* 820CC9E8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CC9E8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CC9E8h case    4:*/		return 0x820CC9EC;
		  /* 820CC9ECh */ case    5:  		/* mr R30, R3 */
		/* 820CC9ECh case    5:*/		regs.R30 = regs.R3;
		/* 820CC9ECh case    5:*/		return 0x820CC9F0;
		  /* 820CC9F0h */ case    6:  		/* mr R31, R4 */
		/* 820CC9F0h case    6:*/		regs.R31 = regs.R4;
		/* 820CC9F0h case    6:*/		return 0x820CC9F4;
		  /* 820CC9F4h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820CC9F4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CC9F4h case    7:*/		return 0x820CC9F8;
		  /* 820CC9F8h */ case    8:  		/* bc 12, CR6_EQ, 208 */
		/* 820CC9F8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CCAC8;  }
		/* 820CC9F8h case    8:*/		return 0x820CC9FC;
		  /* 820CC9FCh */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CC9FCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CC9FCh case    9:*/		return 0x820CCA00;
		  /* 820CCA00h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CCA00h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CCA00h case   10:*/		return 0x820CCA04;
		  /* 820CCA04h */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CCA04h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CCA04h case   11:*/		return 0x820CCA08;
		  /* 820CCA08h */ case   12:  		/* bc 4, CR6_EQ, 192 */
		/* 820CCA08h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CCAC8;  }
		/* 820CCA08h case   12:*/		return 0x820CCA0C;
		  /* 820CCA0Ch */ case   13:  		/* lwz R11, <#[R3 + 28]> */
		/* 820CCA0Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CCA0Ch case   13:*/		return 0x820CCA10;
		  /* 820CCA10h */ case   14:  		/* lwz R10, <#[R4 + 28]> */
		/* 820CCA10h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 820CCA10h case   14:*/		return 0x820CCA14;
		  /* 820CCA14h */ case   15:  		/* cmpw CR6, R11, R10 */
		/* 820CCA14h case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CCA14h case   15:*/		return 0x820CCA18;
	}
	return 0x820CCA18;
} // Block from 820CC9D8h-820CCA18h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CCA18h
// Function '?IsEqual@CNodeExpression@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCA18);
		  /* 820CCA18h */ case    0:  		/* bc 4, CR6_EQ, 176 */
		/* 820CCA18h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820CCAC8;  }
		/* 820CCA18h case    0:*/		return 0x820CCA1C;
		  /* 820CCA1Ch */ case    1:  		/* lwz R3, <#[R3 + 16]> */
		/* 820CCA1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820CCA1Ch case    1:*/		return 0x820CCA20;
		  /* 820CCA20h */ case    2:  		/* lwz R4, <#[R4 + 16]> */
		/* 820CCA20h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000010) );
		/* 820CCA20h case    2:*/		return 0x820CCA24;
		  /* 820CCA24h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820CCA24h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CCA24h case    3:*/		return 0x820CCA28;
		  /* 820CCA28h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820CCA28h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CCA40;  }
		/* 820CCA28h case    4:*/		return 0x820CCA2C;
		  /* 820CCA2Ch */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820CCA2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCA2Ch case    5:*/		return 0x820CCA30;
		  /* 820CCA30h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820CCA30h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CCA30h case    6:*/		return 0x820CCA34;
		  /* 820CCA34h */ case    7:  		/* mtspr CTR, R11 */
		/* 820CCA34h case    7:*/		regs.CTR = regs.R11;
		/* 820CCA34h case    7:*/		return 0x820CCA38;
		  /* 820CCA38h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820CCA38h case    8:*/		if ( 1 ) { regs.LR = 0x820CCA3C; return (uint32)regs.CTR; }
		/* 820CCA38h case    8:*/		return 0x820CCA3C;
		  /* 820CCA3Ch */ case    9:  		/* b 16 */
		/* 820CCA3Ch case    9:*/		return 0x820CCA4C;
		/* 820CCA3Ch case    9:*/		return 0x820CCA40;
	}
	return 0x820CCA40;
} // Block from 820CCA18h-820CCA40h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CCA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCA40);
		  /* 820CCA40h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CCA40h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CCA40h case    0:*/		return 0x820CCA44;
		  /* 820CCA44h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CCA44h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CCA44h case    1:*/		return 0x820CCA48;
		  /* 820CCA48h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CCA48h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CCA48h case    2:*/		return 0x820CCA4C;
	}
	return 0x820CCA4C;
} // Block from 820CCA40h-820CCA4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCA4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCA4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCA4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCA4C);
		  /* 820CCA4Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CCA4Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CCA4Ch case    0:*/		return 0x820CCA50;
		  /* 820CCA50h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820CCA50h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CCAC8;  }
		/* 820CCA50h case    1:*/		return 0x820CCA54;
		  /* 820CCA54h */ case    2:  		/* lwz R3, <#[R30 + 20]> */
		/* 820CCA54h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 820CCA54h case    2:*/		return 0x820CCA58;
		  /* 820CCA58h */ case    3:  		/* lwz R4, <#[R31 + 20]> */
		/* 820CCA58h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 820CCA58h case    3:*/		return 0x820CCA5C;
		  /* 820CCA5Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CCA5Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CCA5Ch case    4:*/		return 0x820CCA60;
		  /* 820CCA60h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CCA60h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CCA78;  }
		/* 820CCA60h case    5:*/		return 0x820CCA64;
		  /* 820CCA64h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CCA64h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCA64h case    6:*/		return 0x820CCA68;
		  /* 820CCA68h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CCA68h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CCA68h case    7:*/		return 0x820CCA6C;
		  /* 820CCA6Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CCA6Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CCA6Ch case    8:*/		return 0x820CCA70;
		  /* 820CCA70h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CCA70h case    9:*/		if ( 1 ) { regs.LR = 0x820CCA74; return (uint32)regs.CTR; }
		/* 820CCA70h case    9:*/		return 0x820CCA74;
		  /* 820CCA74h */ case   10:  		/* b 16 */
		/* 820CCA74h case   10:*/		return 0x820CCA84;
		/* 820CCA74h case   10:*/		return 0x820CCA78;
	}
	return 0x820CCA78;
} // Block from 820CCA4Ch-820CCA78h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CCA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCA78);
		  /* 820CCA78h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CCA78h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CCA78h case    0:*/		return 0x820CCA7C;
		  /* 820CCA7Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CCA7Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CCA7Ch case    1:*/		return 0x820CCA80;
		  /* 820CCA80h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CCA80h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CCA80h case    2:*/		return 0x820CCA84;
	}
	return 0x820CCA84;
} // Block from 820CCA78h-820CCA84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCA84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCA84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCA84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCA84);
		  /* 820CCA84h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CCA84h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CCA84h case    0:*/		return 0x820CCA88;
		  /* 820CCA88h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CCA88h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CCAC8;  }
		/* 820CCA88h case    1:*/		return 0x820CCA8C;
		  /* 820CCA8Ch */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820CCA8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820CCA8Ch case    2:*/		return 0x820CCA90;
		  /* 820CCA90h */ case    3:  		/* lwz R4, <#[R31 + 24]> */
		/* 820CCA90h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820CCA90h case    3:*/		return 0x820CCA94;
		  /* 820CCA94h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CCA94h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CCA94h case    4:*/		return 0x820CCA98;
		  /* 820CCA98h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CCA98h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CCAB0;  }
		/* 820CCA98h case    5:*/		return 0x820CCA9C;
		  /* 820CCA9Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CCA9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCA9Ch case    6:*/		return 0x820CCAA0;
		  /* 820CCAA0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CCAA0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CCAA0h case    7:*/		return 0x820CCAA4;
		  /* 820CCAA4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CCAA4h case    8:*/		regs.CTR = regs.R11;
		/* 820CCAA4h case    8:*/		return 0x820CCAA8;
		  /* 820CCAA8h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CCAA8h case    9:*/		if ( 1 ) { regs.LR = 0x820CCAAC; return (uint32)regs.CTR; }
		/* 820CCAA8h case    9:*/		return 0x820CCAAC;
		  /* 820CCAACh */ case   10:  		/* b 16 */
		/* 820CCAACh case   10:*/		return 0x820CCABC;
		/* 820CCAACh case   10:*/		return 0x820CCAB0;
	}
	return 0x820CCAB0;
} // Block from 820CCA84h-820CCAB0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CCAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCAB0);
		  /* 820CCAB0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CCAB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CCAB0h case    0:*/		return 0x820CCAB4;
		  /* 820CCAB4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CCAB4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CCAB4h case    1:*/		return 0x820CCAB8;
		  /* 820CCAB8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CCAB8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CCAB8h case    2:*/		return 0x820CCABC;
	}
	return 0x820CCABC;
} // Block from 820CCAB0h-820CCABCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCABC);
		  /* 820CCABCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CCABCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CCABCh case    0:*/		return 0x820CCAC0;
		  /* 820CCAC0h */ case    1:  		/* li R3, 1 */
		/* 820CCAC0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CCAC0h case    1:*/		return 0x820CCAC4;
		  /* 820CCAC4h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CCAC4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CCACC;  }
		/* 820CCAC4h case    2:*/		return 0x820CCAC8;
	}
	return 0x820CCAC8;
} // Block from 820CCABCh-820CCAC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCAC8);
		  /* 820CCAC8h */ case    0:  		/* li R3, 0 */
		/* 820CCAC8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CCAC8h case    0:*/		return 0x820CCACC;
	}
	return 0x820CCACC;
} // Block from 820CCAC8h-820CCACCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCACC);
		  /* 820CCACCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820CCACCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CCACCh case    0:*/		return 0x820CCAD0;
		  /* 820CCAD0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CCAD0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCAD0h case    1:*/		return 0x820CCAD4;
		  /* 820CCAD4h */ case    2:  		/* mtspr LR, R12 */
		/* 820CCAD4h case    2:*/		regs.LR = regs.R12;
		/* 820CCAD4h case    2:*/		return 0x820CCAD8;
		  /* 820CCAD8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CCAD8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCAD8h case    3:*/		return 0x820CCADC;
		  /* 820CCADCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CCADCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCADCh case    4:*/		return 0x820CCAE0;
		  /* 820CCAE0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CCAE0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CCAE0h case    5:*/		return 0x820CCAE4;
	}
	return 0x820CCAE4;
} // Block from 820CCACCh-820CCAE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CCAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCAE4);
		  /* 820CCAE4h */ case    0:  		/* nop */
		/* 820CCAE4h case    0:*/		cpu::op::nop();
		/* 820CCAE4h case    0:*/		return 0x820CCAE8;
	}
	return 0x820CCAE8;
} // Block from 820CCAE4h-820CCAE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCAE8);
		  /* 820CCAE8h */ case    0:  		/* mfspr R12, LR */
		/* 820CCAE8h case    0:*/		regs.R12 = regs.LR;
		/* 820CCAE8h case    0:*/		return 0x820CCAEC;
		  /* 820CCAECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CCAECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCAECh case    1:*/		return 0x820CCAF0;
		  /* 820CCAF0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CCAF0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCAF0h case    2:*/		return 0x820CCAF4;
		  /* 820CCAF4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CCAF4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCAF4h case    3:*/		return 0x820CCAF8;
		  /* 820CCAF8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CCAF8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CCAF8h case    4:*/		return 0x820CCAFC;
		  /* 820CCAFCh */ case    5:  		/* mr R30, R3 */
		/* 820CCAFCh case    5:*/		regs.R30 = regs.R3;
		/* 820CCAFCh case    5:*/		return 0x820CCB00;
		  /* 820CCB00h */ case    6:  		/* bl 1328 */
		/* 820CCB00h case    6:*/		regs.LR = 0x820CCB04; return 0x820CD030;
		/* 820CCB00h case    6:*/		return 0x820CCB04;
		  /* 820CCB04h */ case    7:  		/* li R5, 16 */
		/* 820CCB04h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CCB04h case    7:*/		return 0x820CCB08;
		  /* 820CCB08h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CCB08h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCB08h case    8:*/		return 0x820CCB0C;
		  /* 820CCB0Ch */ case    9:  		/* li R4, 32 */
		/* 820CCB0Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820CCB0Ch case    9:*/		return 0x820CCB10;
		  /* 820CCB10h */ case   10:  		/* bl -14896 */
		/* 820CCB10h case   10:*/		regs.LR = 0x820CCB14; return 0x820C90E0;
		/* 820CCB10h case   10:*/		return 0x820CCB14;
		  /* 820CCB14h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CCB14h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCB14h case   11:*/		return 0x820CCB18;
		  /* 820CCB18h */ case   12:  		/* bc 12, CR0_EQ, 64 */
		/* 820CCB18h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CCB58;  }
		/* 820CCB18h case   12:*/		return 0x820CCB1C;
		  /* 820CCB1Ch */ case   13:  		/* lis R10, -32255 */
		/* 820CCB1Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CCB1Ch case   13:*/		return 0x820CCB20;
		  /* 820CCB20h */ case   14:  		/* li R11, 0 */
		/* 820CCB20h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CCB20h case   14:*/		return 0x820CCB24;
		  /* 820CCB24h */ case   15:  		/* li R9, 18 */
		/* 820CCB24h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x12);
		/* 820CCB24h case   15:*/		return 0x820CCB28;
		  /* 820CCB28h */ case   16:  		/* addi R10, R10, 10736 */
		/* 820CCB28h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29F0);
		/* 820CCB28h case   16:*/		return 0x820CCB2C;
		  /* 820CCB2Ch */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CCB2Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CCB2Ch case   17:*/		return 0x820CCB30;
		  /* 820CCB30h */ case   18:  		/* li R8, 2 */
		/* 820CCB30h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 820CCB30h case   18:*/		return 0x820CCB34;
		  /* 820CCB34h */ case   19:  		/* stw R9, <#[R3 + 4]> */
		/* 820CCB34h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CCB34h case   19:*/		return 0x820CCB38;
		  /* 820CCB38h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CCB38h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCB38h case   20:*/		return 0x820CCB3C;
		  /* 820CCB3Ch */ case   21:  		/* mr R31, R3 */
		/* 820CCB3Ch case   21:*/		regs.R31 = regs.R3;
		/* 820CCB3Ch case   21:*/		return 0x820CCB40;
		  /* 820CCB40h */ case   22:  		/* stw R11, <#[R3 + 12]> */
		/* 820CCB40h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CCB40h case   22:*/		return 0x820CCB44;
		  /* 820CCB44h */ case   23:  		/* stw R11, <#[R3 + 16]> */
		/* 820CCB44h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CCB44h case   23:*/		return 0x820CCB48;
		  /* 820CCB48h */ case   24:  		/* stw R11, <#[R3 + 20]> */
		/* 820CCB48h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CCB48h case   24:*/		return 0x820CCB4C;
		  /* 820CCB4Ch */ case   25:  		/* stw R8, <#[R3 + 28]> */
		/* 820CCB4Ch case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CCB4Ch case   25:*/		return 0x820CCB50;
		  /* 820CCB50h */ case   26:  		/* stw R11, <#[R3 + 24]> */
		/* 820CCB50h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CCB50h case   26:*/		return 0x820CCB54;
		  /* 820CCB54h */ case   27:  		/* b 8 */
		/* 820CCB54h case   27:*/		return 0x820CCB5C;
		/* 820CCB54h case   27:*/		return 0x820CCB58;
	}
	return 0x820CCB58;
} // Block from 820CCAE8h-820CCB58h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820CCB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCB58);
		  /* 820CCB58h */ case    0:  		/* li R31, 0 */
		/* 820CCB58h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CCB58h case    0:*/		return 0x820CCB5C;
	}
	return 0x820CCB5C;
} // Block from 820CCB58h-820CCB5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCB5C);
		  /* 820CCB5Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CCB5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CCB5Ch case    0:*/		return 0x820CCB60;
		  /* 820CCB60h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CCB60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CCB6C;  }
		/* 820CCB60h case    1:*/		return 0x820CCB64;
		  /* 820CCB64h */ case    2:  		/* li R3, 0 */
		/* 820CCB64h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CCB64h case    2:*/		return 0x820CCB68;
		  /* 820CCB68h */ case    3:  		/* b 148 */
		/* 820CCB68h case    3:*/		return 0x820CCBFC;
		/* 820CCB68h case    3:*/		return 0x820CCB6C;
	}
	return 0x820CCB6C;
} // Block from 820CCB5Ch-820CCB6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CCB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCB6C);
		  /* 820CCB6Ch */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 820CCB6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CCB6Ch case    0:*/		return 0x820CCB70;
		  /* 820CCB70h */ case    1:  		/* stw R11, <#[R31 + 28]> */
		/* 820CCB70h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CCB70h case    1:*/		return 0x820CCB74;
		  /* 820CCB74h */ case    2:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CCB74h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CCB74h case    2:*/		return 0x820CCB78;
	}
	return 0x820CCB78;
} // Block from 820CCB6Ch-820CCB78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCB78h
// Function '?Copy@CNodeExpression@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCB78);
		  /* 820CCB78h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820CCB78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCB78h case    0:*/		return 0x820CCB7C;
		  /* 820CCB7Ch */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820CCB7Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820CCBA0;  }
		/* 820CCB7Ch case    1:*/		return 0x820CCB80;
		  /* 820CCB80h */ case    2:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCB80h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCB80h case    2:*/		return 0x820CCB84;
		  /* 820CCB84h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820CCB84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCB84h case    3:*/		return 0x820CCB88;
		  /* 820CCB88h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCB88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCB88h case    4:*/		return 0x820CCB8C;
		  /* 820CCB8Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 820CCB8Ch case    5:*/		regs.CTR = regs.R11;
		/* 820CCB8Ch case    5:*/		return 0x820CCB90;
		  /* 820CCB90h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820CCB90h case    6:*/		if ( 1 ) { regs.LR = 0x820CCB94; return (uint32)regs.CTR; }
		/* 820CCB90h case    6:*/		return 0x820CCB94;
		  /* 820CCB94h */ case    7:  		/* stw R3, <#[R31 + 16]> */
		/* 820CCB94h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CCB94h case    7:*/		return 0x820CCB98;
		  /* 820CCB98h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820CCB98h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCB98h case    8:*/		return 0x820CCB9C;
		  /* 820CCB9Ch */ case    9:  		/* bc 12, CR0_EQ, -56 */
		/* 820CCB9Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820CCB64;  }
		/* 820CCB9Ch case    9:*/		return 0x820CCBA0;
	}
	return 0x820CCBA0;
} // Block from 820CCB78h-820CCBA0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CCBA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCBA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCBA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCBA0);
		  /* 820CCBA0h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CCBA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CCBA0h case    0:*/		return 0x820CCBA4;
		  /* 820CCBA4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CCBA4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCBA4h case    1:*/		return 0x820CCBA8;
		  /* 820CCBA8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CCBA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CCBCC;  }
		/* 820CCBA8h case    2:*/		return 0x820CCBAC;
		  /* 820CCBACh */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCBACh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCBACh case    3:*/		return 0x820CCBB0;
		  /* 820CCBB0h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CCBB0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCBB0h case    4:*/		return 0x820CCBB4;
		  /* 820CCBB4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCBB4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCBB4h case    5:*/		return 0x820CCBB8;
		  /* 820CCBB8h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CCBB8h case    6:*/		regs.CTR = regs.R11;
		/* 820CCBB8h case    6:*/		return 0x820CCBBC;
		  /* 820CCBBCh */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CCBBCh case    7:*/		if ( 1 ) { regs.LR = 0x820CCBC0; return (uint32)regs.CTR; }
		/* 820CCBBCh case    7:*/		return 0x820CCBC0;
		  /* 820CCBC0h */ case    8:  		/* stw R3, <#[R31 + 20]> */
		/* 820CCBC0h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CCBC0h case    8:*/		return 0x820CCBC4;
		  /* 820CCBC4h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CCBC4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCBC4h case    9:*/		return 0x820CCBC8;
		  /* 820CCBC8h */ case   10:  		/* bc 12, CR0_EQ, -100 */
		/* 820CCBC8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CCB64;  }
		/* 820CCBC8h case   10:*/		return 0x820CCBCC;
	}
	return 0x820CCBCC;
} // Block from 820CCBA0h-820CCBCCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CCBCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCBCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCBCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCBCC);
		  /* 820CCBCCh */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CCBCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CCBCCh case    0:*/		return 0x820CCBD0;
		  /* 820CCBD0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CCBD0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCBD0h case    1:*/		return 0x820CCBD4;
		  /* 820CCBD4h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CCBD4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CCBF8;  }
		/* 820CCBD4h case    2:*/		return 0x820CCBD8;
		  /* 820CCBD8h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCBD8h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCBD8h case    3:*/		return 0x820CCBDC;
		  /* 820CCBDCh */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CCBDCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCBDCh case    4:*/		return 0x820CCBE0;
		  /* 820CCBE0h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCBE0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCBE0h case    5:*/		return 0x820CCBE4;
		  /* 820CCBE4h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CCBE4h case    6:*/		regs.CTR = regs.R11;
		/* 820CCBE4h case    6:*/		return 0x820CCBE8;
		  /* 820CCBE8h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CCBE8h case    7:*/		if ( 1 ) { regs.LR = 0x820CCBEC; return (uint32)regs.CTR; }
		/* 820CCBE8h case    7:*/		return 0x820CCBEC;
		  /* 820CCBECh */ case    8:  		/* stw R3, <#[R31 + 24]> */
		/* 820CCBECh case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CCBECh case    8:*/		return 0x820CCBF0;
		  /* 820CCBF0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CCBF0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCBF0h case    9:*/		return 0x820CCBF4;
		  /* 820CCBF4h */ case   10:  		/* bc 12, CR0_EQ, -144 */
		/* 820CCBF4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CCB64;  }
		/* 820CCBF4h case   10:*/		return 0x820CCBF8;
	}
	return 0x820CCBF8;
} // Block from 820CCBCCh-820CCBF8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CCBF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCBF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCBF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCBF8);
		  /* 820CCBF8h */ case    0:  		/* mr R3, R31 */
		/* 820CCBF8h case    0:*/		regs.R3 = regs.R31;
		/* 820CCBF8h case    0:*/		return 0x820CCBFC;
	}
	return 0x820CCBFC;
} // Block from 820CCBF8h-820CCBFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCBFC);
		  /* 820CCBFCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820CCBFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CCBFCh case    0:*/		return 0x820CCC00;
		  /* 820CCC00h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CCC00h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCC00h case    1:*/		return 0x820CCC04;
		  /* 820CCC04h */ case    2:  		/* mtspr LR, R12 */
		/* 820CCC04h case    2:*/		regs.LR = regs.R12;
		/* 820CCC04h case    2:*/		return 0x820CCC08;
		  /* 820CCC08h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CCC08h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCC08h case    3:*/		return 0x820CCC0C;
		  /* 820CCC0Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CCC0Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCC0Ch case    4:*/		return 0x820CCC10;
		  /* 820CCC10h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CCC10h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CCC10h case    5:*/		return 0x820CCC14;
	}
	return 0x820CCC14;
} // Block from 820CCBFCh-820CCC14h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CCC14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCC14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCC14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCC14);
		  /* 820CCC14h */ case    0:  		/* nop */
		/* 820CCC14h case    0:*/		cpu::op::nop();
		/* 820CCC14h case    0:*/		return 0x820CCC18;
		  /* 820CCC18h */ case    1:  		/* lis R10, -32255 */
		/* 820CCC18h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CCC18h case    1:*/		return 0x820CCC1C;
		  /* 820CCC1Ch */ case    2:  		/* stw R4, <#[R3 + 16]> */
		/* 820CCC1Ch case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CCC1Ch case    2:*/		return 0x820CCC20;
		  /* 820CCC20h */ case    3:  		/* li R11, 0 */
		/* 820CCC20h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CCC20h case    3:*/		return 0x820CCC24;
		  /* 820CCC24h */ case    4:  		/* stw R5, <#[R3 + 20]> */
		/* 820CCC24h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820CCC24h case    4:*/		return 0x820CCC28;
		  /* 820CCC28h */ case    5:  		/* li R9, 26 */
		/* 820CCC28h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x1A);
		/* 820CCC28h case    5:*/		return 0x820CCC2C;
		  /* 820CCC2Ch */ case    6:  		/* stw R6, <#[R3 + 24]> */
		/* 820CCC2Ch case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 820CCC2Ch case    6:*/		return 0x820CCC30;
		  /* 820CCC30h */ case    7:  		/* addi R10, R10, 10748 */
		/* 820CCC30h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29FC);
		/* 820CCC30h case    7:*/		return 0x820CCC34;
		  /* 820CCC34h */ case    8:  		/* stw R11, <#[R3 + 8]> */
		/* 820CCC34h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CCC34h case    8:*/		return 0x820CCC38;
		  /* 820CCC38h */ case    9:  		/* stw R9, <#[R3 + 4]> */
		/* 820CCC38h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CCC38h case    9:*/		return 0x820CCC3C;
		  /* 820CCC3Ch */ case   10:  		/* stw R10, <#[R3]> */
		/* 820CCC3Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCC3Ch case   10:*/		return 0x820CCC40;
		  /* 820CCC40h */ case   11:  		/* stw R11, <#[R3 + 12]> */
		/* 820CCC40h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CCC40h case   11:*/		return 0x820CCC44;
		  /* 820CCC44h */ case   12:  		/* bclr 20, CR0_LT */
		/* 820CCC44h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CCC44h case   12:*/		return 0x820CCC48;
	}
	return 0x820CCC48;
} // Block from 820CCC14h-820CCC48h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CCC48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCC48);
		  /* 820CCC48h */ case    0:  		/* mfspr R12, LR */
		/* 820CCC48h case    0:*/		regs.R12 = regs.LR;
		/* 820CCC48h case    0:*/		return 0x820CCC4C;
		  /* 820CCC4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CCC4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCC4Ch case    1:*/		return 0x820CCC50;
		  /* 820CCC50h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CCC50h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCC50h case    2:*/		return 0x820CCC54;
		  /* 820CCC54h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CCC54h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCC54h case    3:*/		return 0x820CCC58;
		  /* 820CCC58h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CCC58h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CCC58h case    4:*/		return 0x820CCC5C;
		  /* 820CCC5Ch */ case    5:  		/* mr R30, R3 */
		/* 820CCC5Ch case    5:*/		regs.R30 = regs.R3;
		/* 820CCC5Ch case    5:*/		return 0x820CCC60;
		  /* 820CCC60h */ case    6:  		/* mr R31, R4 */
		/* 820CCC60h case    6:*/		regs.R31 = regs.R4;
		/* 820CCC60h case    6:*/		return 0x820CCC64;
		  /* 820CCC64h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820CCC64h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CCC64h case    7:*/		return 0x820CCC68;
		  /* 820CCC68h */ case    8:  		/* bc 12, CR6_EQ, 192 */
		/* 820CCC68h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CCD28;  }
		/* 820CCC68h case    8:*/		return 0x820CCC6C;
		  /* 820CCC6Ch */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CCC6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CCC6Ch case    9:*/		return 0x820CCC70;
		  /* 820CCC70h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CCC70h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CCC70h case   10:*/		return 0x820CCC74;
		  /* 820CCC74h */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CCC74h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CCC74h case   11:*/		return 0x820CCC78;
		  /* 820CCC78h */ case   12:  		/* bc 4, CR6_EQ, 176 */
		/* 820CCC78h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CCD28;  }
		/* 820CCC78h case   12:*/		return 0x820CCC7C;
		  /* 820CCC7Ch */ case   13:  		/* lwz R3, <#[R3 + 16]> */
		/* 820CCC7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820CCC7Ch case   13:*/		return 0x820CCC80;
		  /* 820CCC80h */ case   14:  		/* lwz R4, <#[R4 + 16]> */
		/* 820CCC80h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000010) );
		/* 820CCC80h case   14:*/		return 0x820CCC84;
		  /* 820CCC84h */ case   15:  		/* cmplwi CR6, R3, 0 */
		/* 820CCC84h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CCC84h case   15:*/		return 0x820CCC88;
		  /* 820CCC88h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 820CCC88h case   16:*/		if ( regs.CR[6].eq ) { return 0x820CCCA0;  }
		/* 820CCC88h case   16:*/		return 0x820CCC8C;
		  /* 820CCC8Ch */ case   17:  		/* lwz R11, <#[R3]> */
		/* 820CCC8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCC8Ch case   17:*/		return 0x820CCC90;
		  /* 820CCC90h */ case   18:  		/* lwz R11, <#[R11]> */
		/* 820CCC90h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CCC90h case   18:*/		return 0x820CCC94;
		  /* 820CCC94h */ case   19:  		/* mtspr CTR, R11 */
		/* 820CCC94h case   19:*/		regs.CTR = regs.R11;
		/* 820CCC94h case   19:*/		return 0x820CCC98;
		  /* 820CCC98h */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 820CCC98h case   20:*/		if ( 1 ) { regs.LR = 0x820CCC9C; return (uint32)regs.CTR; }
		/* 820CCC98h case   20:*/		return 0x820CCC9C;
		  /* 820CCC9Ch */ case   21:  		/* b 16 */
		/* 820CCC9Ch case   21:*/		return 0x820CCCAC;
		/* 820CCC9Ch case   21:*/		return 0x820CCCA0;
	}
	return 0x820CCCA0;
} // Block from 820CCC48h-820CCCA0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CCCA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCCA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCCA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCCA0);
		  /* 820CCCA0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CCCA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CCCA0h case    0:*/		return 0x820CCCA4;
		  /* 820CCCA4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CCCA4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CCCA4h case    1:*/		return 0x820CCCA8;
		  /* 820CCCA8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CCCA8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CCCA8h case    2:*/		return 0x820CCCAC;
	}
	return 0x820CCCAC;
} // Block from 820CCCA0h-820CCCACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCCACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCCAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCCAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCCAC);
		  /* 820CCCACh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CCCACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CCCACh case    0:*/		return 0x820CCCB0;
		  /* 820CCCB0h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820CCCB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CCD28;  }
		/* 820CCCB0h case    1:*/		return 0x820CCCB4;
		  /* 820CCCB4h */ case    2:  		/* lwz R3, <#[R30 + 20]> */
		/* 820CCCB4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 820CCCB4h case    2:*/		return 0x820CCCB8;
		  /* 820CCCB8h */ case    3:  		/* lwz R4, <#[R31 + 20]> */
		/* 820CCCB8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 820CCCB8h case    3:*/		return 0x820CCCBC;
		  /* 820CCCBCh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CCCBCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CCCBCh case    4:*/		return 0x820CCCC0;
		  /* 820CCCC0h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CCCC0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CCCD8;  }
		/* 820CCCC0h case    5:*/		return 0x820CCCC4;
		  /* 820CCCC4h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CCCC4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCCC4h case    6:*/		return 0x820CCCC8;
		  /* 820CCCC8h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CCCC8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CCCC8h case    7:*/		return 0x820CCCCC;
		  /* 820CCCCCh */ case    8:  		/* mtspr CTR, R11 */
		/* 820CCCCCh case    8:*/		regs.CTR = regs.R11;
		/* 820CCCCCh case    8:*/		return 0x820CCCD0;
		  /* 820CCCD0h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CCCD0h case    9:*/		if ( 1 ) { regs.LR = 0x820CCCD4; return (uint32)regs.CTR; }
		/* 820CCCD0h case    9:*/		return 0x820CCCD4;
		  /* 820CCCD4h */ case   10:  		/* b 16 */
		/* 820CCCD4h case   10:*/		return 0x820CCCE4;
		/* 820CCCD4h case   10:*/		return 0x820CCCD8;
	}
	return 0x820CCCD8;
} // Block from 820CCCACh-820CCCD8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CCCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCCD8);
		  /* 820CCCD8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CCCD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CCCD8h case    0:*/		return 0x820CCCDC;
		  /* 820CCCDCh */ case    1:  		/* cntlzw R11, R11 */
		/* 820CCCDCh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CCCDCh case    1:*/		return 0x820CCCE0;
		  /* 820CCCE0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CCCE0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CCCE0h case    2:*/		return 0x820CCCE4;
	}
	return 0x820CCCE4;
} // Block from 820CCCD8h-820CCCE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCCE4);
		  /* 820CCCE4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CCCE4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CCCE4h case    0:*/		return 0x820CCCE8;
		  /* 820CCCE8h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CCCE8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CCD28;  }
		/* 820CCCE8h case    1:*/		return 0x820CCCEC;
		  /* 820CCCECh */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820CCCECh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820CCCECh case    2:*/		return 0x820CCCF0;
		  /* 820CCCF0h */ case    3:  		/* lwz R4, <#[R31 + 24]> */
		/* 820CCCF0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820CCCF0h case    3:*/		return 0x820CCCF4;
		  /* 820CCCF4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CCCF4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CCCF4h case    4:*/		return 0x820CCCF8;
		  /* 820CCCF8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CCCF8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CCD10;  }
		/* 820CCCF8h case    5:*/		return 0x820CCCFC;
		  /* 820CCCFCh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CCCFCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCCFCh case    6:*/		return 0x820CCD00;
		  /* 820CCD00h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CCD00h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CCD00h case    7:*/		return 0x820CCD04;
		  /* 820CCD04h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CCD04h case    8:*/		regs.CTR = regs.R11;
		/* 820CCD04h case    8:*/		return 0x820CCD08;
	}
	return 0x820CCD08;
} // Block from 820CCCE4h-820CCD08h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD08h
// Function '??0CNodeValue@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD08);
		  /* 820CCD08h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 820CCD08h case    0:*/		if ( 1 ) { regs.LR = 0x820CCD0C; return (uint32)regs.CTR; }
		/* 820CCD08h case    0:*/		return 0x820CCD0C;
		  /* 820CCD0Ch */ case    1:  		/* b 16 */
		/* 820CCD0Ch case    1:*/		return 0x820CCD1C;
		/* 820CCD0Ch case    1:*/		return 0x820CCD10;
	}
	return 0x820CCD10;
} // Block from 820CCD08h-820CCD10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD10);
		  /* 820CCD10h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CCD10h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CCD10h case    0:*/		return 0x820CCD14;
		  /* 820CCD14h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CCD14h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CCD14h case    1:*/		return 0x820CCD18;
		  /* 820CCD18h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CCD18h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CCD18h case    2:*/		return 0x820CCD1C;
	}
	return 0x820CCD1C;
} // Block from 820CCD10h-820CCD1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD1C);
		  /* 820CCD1Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CCD1Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CCD1Ch case    0:*/		return 0x820CCD20;
		  /* 820CCD20h */ case    1:  		/* li R3, 1 */
		/* 820CCD20h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CCD20h case    1:*/		return 0x820CCD24;
		  /* 820CCD24h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CCD24h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CCD2C;  }
		/* 820CCD24h case    2:*/		return 0x820CCD28;
	}
	return 0x820CCD28;
} // Block from 820CCD1Ch-820CCD28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD28);
		  /* 820CCD28h */ case    0:  		/* li R3, 0 */
		/* 820CCD28h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CCD28h case    0:*/		return 0x820CCD2C;
	}
	return 0x820CCD2C;
} // Block from 820CCD28h-820CCD2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD2C);
		  /* 820CCD2Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820CCD2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CCD2Ch case    0:*/		return 0x820CCD30;
		  /* 820CCD30h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CCD30h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCD30h case    1:*/		return 0x820CCD34;
		  /* 820CCD34h */ case    2:  		/* mtspr LR, R12 */
		/* 820CCD34h case    2:*/		regs.LR = regs.R12;
		/* 820CCD34h case    2:*/		return 0x820CCD38;
		  /* 820CCD38h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CCD38h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCD38h case    3:*/		return 0x820CCD3C;
		  /* 820CCD3Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CCD3Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCD3Ch case    4:*/		return 0x820CCD40;
		  /* 820CCD40h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CCD40h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CCD40h case    5:*/		return 0x820CCD44;
	}
	return 0x820CCD44;
} // Block from 820CCD2Ch-820CCD44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD44);
		  /* 820CCD44h */ case    0:  		/* nop */
		/* 820CCD44h case    0:*/		cpu::op::nop();
		/* 820CCD44h case    0:*/		return 0x820CCD48;
	}
	return 0x820CCD48;
} // Block from 820CCD44h-820CCD48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD48);
		  /* 820CCD48h */ case    0:  		/* mfspr R12, LR */
		/* 820CCD48h case    0:*/		regs.R12 = regs.LR;
		/* 820CCD48h case    0:*/		return 0x820CCD4C;
		  /* 820CCD4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CCD4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCD4Ch case    1:*/		return 0x820CCD50;
		  /* 820CCD50h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CCD50h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCD50h case    2:*/		return 0x820CCD54;
		  /* 820CCD54h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CCD54h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCD54h case    3:*/		return 0x820CCD58;
	}
	return 0x820CCD58;
} // Block from 820CCD48h-820CCD58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CCD58h
// Function '??0CNodeValue@D3DXShader@@QAA@PBU_D3DVALUE@1@PBUD3DXTOKEN@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCD58);
		  /* 820CCD58h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CCD58h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CCD58h case    0:*/		return 0x820CCD5C;
		  /* 820CCD5Ch */ case    1:  		/* mr R30, R3 */
		/* 820CCD5Ch case    1:*/		regs.R30 = regs.R3;
		/* 820CCD5Ch case    1:*/		return 0x820CCD60;
		  /* 820CCD60h */ case    2:  		/* bl 720 */
		/* 820CCD60h case    2:*/		regs.LR = 0x820CCD64; return 0x820CD030;
		/* 820CCD60h case    2:*/		return 0x820CCD64;
		  /* 820CCD64h */ case    3:  		/* li R5, 16 */
		/* 820CCD64h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CCD64h case    3:*/		return 0x820CCD68;
		  /* 820CCD68h */ case    4:  		/* lwz R3, <#[R3]> */
		/* 820CCD68h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCD68h case    4:*/		return 0x820CCD6C;
		  /* 820CCD6Ch */ case    5:  		/* li R4, 28 */
		/* 820CCD6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 820CCD6Ch case    5:*/		return 0x820CCD70;
		  /* 820CCD70h */ case    6:  		/* bl -15504 */
		/* 820CCD70h case    6:*/		regs.LR = 0x820CCD74; return 0x820C90E0;
		/* 820CCD70h case    6:*/		return 0x820CCD74;
		  /* 820CCD74h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820CCD74h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCD74h case    7:*/		return 0x820CCD78;
		  /* 820CCD78h */ case    8:  		/* bc 12, CR0_EQ, 56 */
		/* 820CCD78h case    8:*/		if ( regs.CR[0].eq ) { return 0x820CCDB0;  }
		/* 820CCD78h case    8:*/		return 0x820CCD7C;
		  /* 820CCD7Ch */ case    9:  		/* lis R10, -32255 */
		/* 820CCD7Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CCD7Ch case    9:*/		return 0x820CCD80;
		  /* 820CCD80h */ case   10:  		/* li R11, 0 */
		/* 820CCD80h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CCD80h case   10:*/		return 0x820CCD84;
		  /* 820CCD84h */ case   11:  		/* li R9, 26 */
		/* 820CCD84h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x1A);
		/* 820CCD84h case   11:*/		return 0x820CCD88;
		  /* 820CCD88h */ case   12:  		/* addi R10, R10, 10748 */
		/* 820CCD88h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29FC);
		/* 820CCD88h case   12:*/		return 0x820CCD8C;
		  /* 820CCD8Ch */ case   13:  		/* stw R11, <#[R3 + 8]> */
		/* 820CCD8Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CCD8Ch case   13:*/		return 0x820CCD90;
		  /* 820CCD90h */ case   14:  		/* stw R9, <#[R3 + 4]> */
		/* 820CCD90h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CCD90h case   14:*/		return 0x820CCD94;
		  /* 820CCD94h */ case   15:  		/* mr R31, R3 */
		/* 820CCD94h case   15:*/		regs.R31 = regs.R3;
		/* 820CCD94h case   15:*/		return 0x820CCD98;
		  /* 820CCD98h */ case   16:  		/* stw R10, <#[R3]> */
		/* 820CCD98h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCD98h case   16:*/		return 0x820CCD9C;
		  /* 820CCD9Ch */ case   17:  		/* stw R11, <#[R3 + 12]> */
		/* 820CCD9Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CCD9Ch case   17:*/		return 0x820CCDA0;
		  /* 820CCDA0h */ case   18:  		/* stw R11, <#[R3 + 16]> */
		/* 820CCDA0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CCDA0h case   18:*/		return 0x820CCDA4;
		  /* 820CCDA4h */ case   19:  		/* stw R11, <#[R3 + 20]> */
		/* 820CCDA4h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CCDA4h case   19:*/		return 0x820CCDA8;
		  /* 820CCDA8h */ case   20:  		/* stw R11, <#[R3 + 24]> */
		/* 820CCDA8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CCDA8h case   20:*/		return 0x820CCDAC;
		  /* 820CCDACh */ case   21:  		/* b 8 */
		/* 820CCDACh case   21:*/		return 0x820CCDB4;
		/* 820CCDACh case   21:*/		return 0x820CCDB0;
	}
	return 0x820CCDB0;
} // Block from 820CCD58h-820CCDB0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CCDB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCDB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCDB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCDB0);
		  /* 820CCDB0h */ case    0:  		/* li R31, 0 */
		/* 820CCDB0h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CCDB0h case    0:*/		return 0x820CCDB4;
	}
	return 0x820CCDB4;
} // Block from 820CCDB0h-820CCDB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCDB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCDB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCDB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCDB4);
		  /* 820CCDB4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CCDB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CCDB4h case    0:*/		return 0x820CCDB8;
		  /* 820CCDB8h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CCDB8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CCDC4;  }
		/* 820CCDB8h case    1:*/		return 0x820CCDBC;
		  /* 820CCDBCh */ case    2:  		/* li R3, 0 */
		/* 820CCDBCh case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CCDBCh case    2:*/		return 0x820CCDC0;
		  /* 820CCDC0h */ case    3:  		/* b 140 */
		/* 820CCDC0h case    3:*/		return 0x820CCE4C;
		/* 820CCDC0h case    3:*/		return 0x820CCDC4;
	}
	return 0x820CCDC4;
} // Block from 820CCDB4h-820CCDC4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CCDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCDC4);
		  /* 820CCDC4h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CCDC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CCDC4h case    0:*/		return 0x820CCDC8;
		  /* 820CCDC8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CCDC8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCDC8h case    1:*/		return 0x820CCDCC;
		  /* 820CCDCCh */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CCDCCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820CCDF0;  }
		/* 820CCDCCh case    2:*/		return 0x820CCDD0;
		  /* 820CCDD0h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCDD0h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCDD0h case    3:*/		return 0x820CCDD4;
		  /* 820CCDD4h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CCDD4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCDD4h case    4:*/		return 0x820CCDD8;
		  /* 820CCDD8h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCDD8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCDD8h case    5:*/		return 0x820CCDDC;
		  /* 820CCDDCh */ case    6:  		/* mtspr CTR, R11 */
		/* 820CCDDCh case    6:*/		regs.CTR = regs.R11;
		/* 820CCDDCh case    6:*/		return 0x820CCDE0;
		  /* 820CCDE0h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CCDE0h case    7:*/		if ( 1 ) { regs.LR = 0x820CCDE4; return (uint32)regs.CTR; }
		/* 820CCDE0h case    7:*/		return 0x820CCDE4;
		  /* 820CCDE4h */ case    8:  		/* stw R3, <#[R31 + 16]> */
		/* 820CCDE4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CCDE4h case    8:*/		return 0x820CCDE8;
		  /* 820CCDE8h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CCDE8h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCDE8h case    9:*/		return 0x820CCDEC;
		  /* 820CCDECh */ case   10:  		/* bc 12, CR0_EQ, -48 */
		/* 820CCDECh case   10:*/		if ( regs.CR[0].eq ) { return 0x820CCDBC;  }
		/* 820CCDECh case   10:*/		return 0x820CCDF0;
	}
	return 0x820CCDF0;
} // Block from 820CCDC4h-820CCDF0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CCDF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCDF0);
		  /* 820CCDF0h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CCDF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CCDF0h case    0:*/		return 0x820CCDF4;
		  /* 820CCDF4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CCDF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCDF4h case    1:*/		return 0x820CCDF8;
		  /* 820CCDF8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CCDF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CCE1C;  }
		/* 820CCDF8h case    2:*/		return 0x820CCDFC;
		  /* 820CCDFCh */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCDFCh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCDFCh case    3:*/		return 0x820CCE00;
	}
	return 0x820CCE00;
} // Block from 820CCDF0h-820CCE00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CCE00h
// Function '??0CNodeValue@D3DXShader@@QAA@W4_D3DVALUE_TYPE@1@PAVCNode@1@PBUD3DXTOKEN@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCE00);
		  /* 820CCE00h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820CCE00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCE00h case    0:*/		return 0x820CCE04;
		  /* 820CCE04h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCE04h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCE04h case    1:*/		return 0x820CCE08;
		  /* 820CCE08h */ case    2:  		/* mtspr CTR, R11 */
		/* 820CCE08h case    2:*/		regs.CTR = regs.R11;
		/* 820CCE08h case    2:*/		return 0x820CCE0C;
		  /* 820CCE0Ch */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820CCE0Ch case    3:*/		if ( 1 ) { regs.LR = 0x820CCE10; return (uint32)regs.CTR; }
		/* 820CCE0Ch case    3:*/		return 0x820CCE10;
		  /* 820CCE10h */ case    4:  		/* stw R3, <#[R31 + 20]> */
		/* 820CCE10h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CCE10h case    4:*/		return 0x820CCE14;
		  /* 820CCE14h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820CCE14h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCE14h case    5:*/		return 0x820CCE18;
		  /* 820CCE18h */ case    6:  		/* bc 12, CR0_EQ, -92 */
		/* 820CCE18h case    6:*/		if ( regs.CR[0].eq ) { return 0x820CCDBC;  }
		/* 820CCE18h case    6:*/		return 0x820CCE1C;
	}
	return 0x820CCE1C;
} // Block from 820CCE00h-820CCE1Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CCE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCE1C);
		  /* 820CCE1Ch */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CCE1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CCE1Ch case    0:*/		return 0x820CCE20;
		  /* 820CCE20h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CCE20h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCE20h case    1:*/		return 0x820CCE24;
		  /* 820CCE24h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CCE24h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CCE48;  }
		/* 820CCE24h case    2:*/		return 0x820CCE28;
		  /* 820CCE28h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCE28h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCE28h case    3:*/		return 0x820CCE2C;
		  /* 820CCE2Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CCE2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCE2Ch case    4:*/		return 0x820CCE30;
		  /* 820CCE30h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCE30h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCE30h case    5:*/		return 0x820CCE34;
		  /* 820CCE34h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CCE34h case    6:*/		regs.CTR = regs.R11;
		/* 820CCE34h case    6:*/		return 0x820CCE38;
		  /* 820CCE38h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CCE38h case    7:*/		if ( 1 ) { regs.LR = 0x820CCE3C; return (uint32)regs.CTR; }
		/* 820CCE38h case    7:*/		return 0x820CCE3C;
		  /* 820CCE3Ch */ case    8:  		/* stw R3, <#[R31 + 24]> */
		/* 820CCE3Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CCE3Ch case    8:*/		return 0x820CCE40;
		  /* 820CCE40h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CCE40h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCE40h case    9:*/		return 0x820CCE44;
		  /* 820CCE44h */ case   10:  		/* bc 12, CR0_EQ, -136 */
		/* 820CCE44h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CCDBC;  }
		/* 820CCE44h case   10:*/		return 0x820CCE48;
	}
	return 0x820CCE48;
} // Block from 820CCE1Ch-820CCE48h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CCE48h
// Function '??0CNodeValue@D3DXShader@@QAA@W4_D3DVALUE_TYPE@1@NPBUD3DXTOKEN@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCE48);
		  /* 820CCE48h */ case    0:  		/* mr R3, R31 */
		/* 820CCE48h case    0:*/		regs.R3 = regs.R31;
		/* 820CCE48h case    0:*/		return 0x820CCE4C;
	}
	return 0x820CCE4C;
} // Block from 820CCE48h-820CCE4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCE4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCE4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCE4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCE4C);
		  /* 820CCE4Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820CCE4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CCE4Ch case    0:*/		return 0x820CCE50;
		  /* 820CCE50h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CCE50h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCE50h case    1:*/		return 0x820CCE54;
		  /* 820CCE54h */ case    2:  		/* mtspr LR, R12 */
		/* 820CCE54h case    2:*/		regs.LR = regs.R12;
		/* 820CCE54h case    2:*/		return 0x820CCE58;
		  /* 820CCE58h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CCE58h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCE58h case    3:*/		return 0x820CCE5C;
		  /* 820CCE5Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CCE5Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCE5Ch case    4:*/		return 0x820CCE60;
		  /* 820CCE60h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CCE60h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CCE60h case    5:*/		return 0x820CCE64;
	}
	return 0x820CCE64;
} // Block from 820CCE4Ch-820CCE64h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CCE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCE64);
		  /* 820CCE64h */ case    0:  		/* nop */
		/* 820CCE64h case    0:*/		cpu::op::nop();
		/* 820CCE64h case    0:*/		return 0x820CCE68;
	}
	return 0x820CCE68;
} // Block from 820CCE64h-820CCE68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCE68);
		  /* 820CCE68h */ case    0:  		/* mfspr R12, LR */
		/* 820CCE68h case    0:*/		regs.R12 = regs.LR;
		/* 820CCE68h case    0:*/		return 0x820CCE6C;
		  /* 820CCE6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CCE6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCE6Ch case    1:*/		return 0x820CCE70;
		  /* 820CCE70h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CCE70h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCE70h case    2:*/		return 0x820CCE74;
		  /* 820CCE74h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CCE74h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCE74h case    3:*/		return 0x820CCE78;
		  /* 820CCE78h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CCE78h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CCE78h case    4:*/		return 0x820CCE7C;
		  /* 820CCE7Ch */ case    5:  		/* mr R30, R3 */
		/* 820CCE7Ch case    5:*/		regs.R30 = regs.R3;
		/* 820CCE7Ch case    5:*/		return 0x820CCE80;
		  /* 820CCE80h */ case    6:  		/* bl 432 */
		/* 820CCE80h case    6:*/		regs.LR = 0x820CCE84; return 0x820CD030;
		/* 820CCE80h case    6:*/		return 0x820CCE84;
		  /* 820CCE84h */ case    7:  		/* li R5, 16 */
		/* 820CCE84h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CCE84h case    7:*/		return 0x820CCE88;
		  /* 820CCE88h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CCE88h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCE88h case    8:*/		return 0x820CCE8C;
		  /* 820CCE8Ch */ case    9:  		/* li R4, 24 */
		/* 820CCE8Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820CCE8Ch case    9:*/		return 0x820CCE90;
	}
	return 0x820CCE90;
} // Block from 820CCE68h-820CCE90h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CCE90h
// Function '??0CNodeValue@D3DXShader@@QAA@W4_D3DVALUE_TYPE@1@IIPBUD3DXTOKEN@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCE90);
		  /* 820CCE90h */ case    0:  		/* bl -15792 */
		/* 820CCE90h case    0:*/		regs.LR = 0x820CCE94; return 0x820C90E0;
		/* 820CCE90h case    0:*/		return 0x820CCE94;
		  /* 820CCE94h */ case    1:  		/* cmplwi CR0, R3, 0 */
		/* 820CCE94h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCE94h case    1:*/		return 0x820CCE98;
		  /* 820CCE98h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 820CCE98h case    2:*/		if ( regs.CR[0].eq ) { return 0x820CCECC;  }
		/* 820CCE98h case    2:*/		return 0x820CCE9C;
		  /* 820CCE9Ch */ case    3:  		/* lis R10, -32255 */
		/* 820CCE9Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CCE9Ch case    3:*/		return 0x820CCEA0;
		  /* 820CCEA0h */ case    4:  		/* li R11, 0 */
		/* 820CCEA0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CCEA0h case    4:*/		return 0x820CCEA4;
		  /* 820CCEA4h */ case    5:  		/* li R9, 2 */
		/* 820CCEA4h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 820CCEA4h case    5:*/		return 0x820CCEA8;
		  /* 820CCEA8h */ case    6:  		/* addi R10, R10, 10508 */
		/* 820CCEA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x290C);
		/* 820CCEA8h case    6:*/		return 0x820CCEAC;
		  /* 820CCEACh */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 820CCEACh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CCEACh case    7:*/		return 0x820CCEB0;
		  /* 820CCEB0h */ case    8:  		/* stw R9, <#[R3 + 4]> */
		/* 820CCEB0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CCEB0h case    8:*/		return 0x820CCEB4;
		  /* 820CCEB4h */ case    9:  		/* mr R31, R3 */
		/* 820CCEB4h case    9:*/		regs.R31 = regs.R3;
		/* 820CCEB4h case    9:*/		return 0x820CCEB8;
		  /* 820CCEB8h */ case   10:  		/* stw R10, <#[R3]> */
		/* 820CCEB8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCEB8h case   10:*/		return 0x820CCEBC;
		  /* 820CCEBCh */ case   11:  		/* stw R11, <#[R3 + 12]> */
		/* 820CCEBCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CCEBCh case   11:*/		return 0x820CCEC0;
		  /* 820CCEC0h */ case   12:  		/* stw R11, <#[R3 + 16]> */
		/* 820CCEC0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CCEC0h case   12:*/		return 0x820CCEC4;
		  /* 820CCEC4h */ case   13:  		/* stw R11, <#[R3 + 20]> */
		/* 820CCEC4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CCEC4h case   13:*/		return 0x820CCEC8;
		  /* 820CCEC8h */ case   14:  		/* b 8 */
		/* 820CCEC8h case   14:*/		return 0x820CCED0;
		/* 820CCEC8h case   14:*/		return 0x820CCECC;
	}
	return 0x820CCECC;
} // Block from 820CCE90h-820CCECCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820CCECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCECC);
		  /* 820CCECCh */ case    0:  		/* li R31, 0 */
		/* 820CCECCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CCECCh case    0:*/		return 0x820CCED0;
	}
	return 0x820CCED0;
} // Block from 820CCECCh-820CCED0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCED0);
		  /* 820CCED0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CCED0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CCED0h case    0:*/		return 0x820CCED4;
		  /* 820CCED4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CCED4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CCEE0;  }
		/* 820CCED4h case    1:*/		return 0x820CCED8;
		  /* 820CCED8h */ case    2:  		/* li R3, 0 */
		/* 820CCED8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CCED8h case    2:*/		return 0x820CCEDC;
		  /* 820CCEDCh */ case    3:  		/* b 108 */
		/* 820CCEDCh case    3:*/		return 0x820CCF48;
		/* 820CCEDCh case    3:*/		return 0x820CCEE0;
	}
	return 0x820CCEE0;
} // Block from 820CCED0h-820CCEE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CCEE0h
// Function '?IsEqual@CNodeValue@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCEE0);
		  /* 820CCEE0h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CCEE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CCEE0h case    0:*/		return 0x820CCEE4;
		  /* 820CCEE4h */ case    1:  		/* stw R11, <#[R31 + 20]> */
		/* 820CCEE4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CCEE4h case    1:*/		return 0x820CCEE8;
		  /* 820CCEE8h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 820CCEE8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820CCEE8h case    2:*/		return 0x820CCEEC;
		  /* 820CCEECh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820CCEECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCEECh case    3:*/		return 0x820CCEF0;
		  /* 820CCEF0h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820CCEF0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CCF14;  }
		/* 820CCEF0h case    4:*/		return 0x820CCEF4;
		  /* 820CCEF4h */ case    5:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCEF4h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCEF4h case    5:*/		return 0x820CCEF8;
		  /* 820CCEF8h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CCEF8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCEF8h case    6:*/		return 0x820CCEFC;
		  /* 820CCEFCh */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCEFCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCEFCh case    7:*/		return 0x820CCF00;
		  /* 820CCF00h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CCF00h case    8:*/		regs.CTR = regs.R11;
		/* 820CCF00h case    8:*/		return 0x820CCF04;
		  /* 820CCF04h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CCF04h case    9:*/		if ( 1 ) { regs.LR = 0x820CCF08; return (uint32)regs.CTR; }
		/* 820CCF04h case    9:*/		return 0x820CCF08;
		  /* 820CCF08h */ case   10:  		/* stw R3, <#[R31 + 8]> */
		/* 820CCF08h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820CCF08h case   10:*/		return 0x820CCF0C;
		  /* 820CCF0Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CCF0Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCF0Ch case   11:*/		return 0x820CCF10;
		  /* 820CCF10h */ case   12:  		/* bc 12, CR0_EQ, -56 */
		/* 820CCF10h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CCED8;  }
		/* 820CCF10h case   12:*/		return 0x820CCF14;
	}
	return 0x820CCF14;
} // Block from 820CCEE0h-820CCF14h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CCF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCF14);
		  /* 820CCF14h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 820CCF14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820CCF14h case    0:*/		return 0x820CCF18;
		  /* 820CCF18h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CCF18h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCF18h case    1:*/		return 0x820CCF1C;
		  /* 820CCF1Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820CCF1Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CCF44;  }
		/* 820CCF1Ch case    2:*/		return 0x820CCF20;
		  /* 820CCF20h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCF20h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCF20h case    3:*/		return 0x820CCF24;
		  /* 820CCF24h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CCF24h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCF24h case    4:*/		return 0x820CCF28;
		  /* 820CCF28h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCF28h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCF28h case    5:*/		return 0x820CCF2C;
		  /* 820CCF2Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820CCF2Ch case    6:*/		regs.CTR = regs.R11;
		/* 820CCF2Ch case    6:*/		return 0x820CCF30;
		  /* 820CCF30h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CCF30h case    7:*/		if ( 1 ) { regs.LR = 0x820CCF34; return (uint32)regs.CTR; }
		/* 820CCF30h case    7:*/		return 0x820CCF34;
		  /* 820CCF34h */ case    8:  		/* stw R3, <#[R31 + 12]> */
		/* 820CCF34h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820CCF34h case    8:*/		return 0x820CCF38;
		  /* 820CCF38h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CCF38h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCF38h case    9:*/		return 0x820CCF3C;
		  /* 820CCF3Ch */ case   10:  		/* li R3, 0 */
		/* 820CCF3Ch case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CCF3Ch case   10:*/		return 0x820CCF40;
		  /* 820CCF40h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 820CCF40h case   11:*/		if ( regs.CR[0].eq ) { return 0x820CCF48;  }
		/* 820CCF40h case   11:*/		return 0x820CCF44;
	}
	return 0x820CCF44;
} // Block from 820CCF14h-820CCF44h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CCF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCF44);
		  /* 820CCF44h */ case    0:  		/* mr R3, R31 */
		/* 820CCF44h case    0:*/		regs.R3 = regs.R31;
		/* 820CCF44h case    0:*/		return 0x820CCF48;
	}
	return 0x820CCF48;
} // Block from 820CCF44h-820CCF48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCF48);
		  /* 820CCF48h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CCF48h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CCF48h case    0:*/		return 0x820CCF4C;
		  /* 820CCF4Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CCF4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCF4Ch case    1:*/		return 0x820CCF50;
		  /* 820CCF50h */ case    2:  		/* mtspr LR, R12 */
		/* 820CCF50h case    2:*/		regs.LR = regs.R12;
		/* 820CCF50h case    2:*/		return 0x820CCF54;
		  /* 820CCF54h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CCF54h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCF54h case    3:*/		return 0x820CCF58;
		  /* 820CCF58h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CCF58h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCF58h case    4:*/		return 0x820CCF5C;
		  /* 820CCF5Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CCF5Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CCF5Ch case    5:*/		return 0x820CCF60;
	}
	return 0x820CCF60;
} // Block from 820CCF48h-820CCF60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CCF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCF60);
		  /* 820CCF60h */ case    0:  		/* mfspr R12, LR */
		/* 820CCF60h case    0:*/		regs.R12 = regs.LR;
		/* 820CCF60h case    0:*/		return 0x820CCF64;
		  /* 820CCF64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CCF64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CCF64h case    1:*/		return 0x820CCF68;
		  /* 820CCF68h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CCF68h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CCF68h case    2:*/		return 0x820CCF6C;
		  /* 820CCF6Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CCF6Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CCF6Ch case    3:*/		return 0x820CCF70;
		  /* 820CCF70h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CCF70h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CCF70h case    4:*/		return 0x820CCF74;
		  /* 820CCF74h */ case    5:  		/* mr R30, R3 */
		/* 820CCF74h case    5:*/		regs.R30 = regs.R3;
		/* 820CCF74h case    5:*/		return 0x820CCF78;
		  /* 820CCF78h */ case    6:  		/* bl 184 */
		/* 820CCF78h case    6:*/		regs.LR = 0x820CCF7C; return 0x820CD030;
		/* 820CCF78h case    6:*/		return 0x820CCF7C;
		  /* 820CCF7Ch */ case    7:  		/* li R5, 16 */
		/* 820CCF7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CCF7Ch case    7:*/		return 0x820CCF80;
		  /* 820CCF80h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CCF80h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCF80h case    8:*/		return 0x820CCF84;
		  /* 820CCF84h */ case    9:  		/* li R4, 24 */
		/* 820CCF84h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820CCF84h case    9:*/		return 0x820CCF88;
		  /* 820CCF88h */ case   10:  		/* bl -16040 */
		/* 820CCF88h case   10:*/		regs.LR = 0x820CCF8C; return 0x820C90E0;
		/* 820CCF88h case   10:*/		return 0x820CCF8C;
		  /* 820CCF8Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CCF8Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CCF8Ch case   11:*/		return 0x820CCF90;
		  /* 820CCF90h */ case   12:  		/* bc 12, CR0_EQ, 52 */
		/* 820CCF90h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CCFC4;  }
		/* 820CCF90h case   12:*/		return 0x820CCF94;
		  /* 820CCF94h */ case   13:  		/* lis R10, -32255 */
		/* 820CCF94h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CCF94h case   13:*/		return 0x820CCF98;
		  /* 820CCF98h */ case   14:  		/* li R11, 0 */
		/* 820CCF98h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CCF98h case   14:*/		return 0x820CCF9C;
		  /* 820CCF9Ch */ case   15:  		/* li R9, 13 */
		/* 820CCF9Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0xD);
		/* 820CCF9Ch case   15:*/		return 0x820CCFA0;
		  /* 820CCFA0h */ case   16:  		/* addi R10, R10, 10676 */
		/* 820CCFA0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x29B4);
		/* 820CCFA0h case   16:*/		return 0x820CCFA4;
		  /* 820CCFA4h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CCFA4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CCFA4h case   17:*/		return 0x820CCFA8;
	}
	return 0x820CCFA8;
} // Block from 820CCF60h-820CCFA8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CCFA8h
// Function '?Copy@CNodeValue@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCFA8);
		  /* 820CCFA8h */ case    0:  		/* stw R9, <#[R3 + 4]> */
		/* 820CCFA8h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CCFA8h case    0:*/		return 0x820CCFAC;
		  /* 820CCFACh */ case    1:  		/* mr R31, R3 */
		/* 820CCFACh case    1:*/		regs.R31 = regs.R3;
		/* 820CCFACh case    1:*/		return 0x820CCFB0;
		  /* 820CCFB0h */ case    2:  		/* stw R10, <#[R3]> */
		/* 820CCFB0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCFB0h case    2:*/		return 0x820CCFB4;
		  /* 820CCFB4h */ case    3:  		/* stw R11, <#[R3 + 12]> */
		/* 820CCFB4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CCFB4h case    3:*/		return 0x820CCFB8;
		  /* 820CCFB8h */ case    4:  		/* stw R11, <#[R3 + 16]> */
		/* 820CCFB8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CCFB8h case    4:*/		return 0x820CCFBC;
		  /* 820CCFBCh */ case    5:  		/* stw R11, <#[R3 + 20]> */
		/* 820CCFBCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CCFBCh case    5:*/		return 0x820CCFC0;
		  /* 820CCFC0h */ case    6:  		/* b 8 */
		/* 820CCFC0h case    6:*/		return 0x820CCFC8;
		/* 820CCFC0h case    6:*/		return 0x820CCFC4;
	}
	return 0x820CCFC4;
} // Block from 820CCFA8h-820CCFC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CCFC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCFC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCFC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCFC4);
		  /* 820CCFC4h */ case    0:  		/* li R31, 0 */
		/* 820CCFC4h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CCFC4h case    0:*/		return 0x820CCFC8;
	}
	return 0x820CCFC8;
} // Block from 820CCFC4h-820CCFC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CCFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCFC8);
		  /* 820CCFC8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CCFC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CCFC8h case    0:*/		return 0x820CCFCC;
		  /* 820CCFCCh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CCFCCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CCFD8;  }
		/* 820CCFCCh case    1:*/		return 0x820CCFD0;
		  /* 820CCFD0h */ case    2:  		/* li R3, 0 */
		/* 820CCFD0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CCFD0h case    2:*/		return 0x820CCFD4;
		  /* 820CCFD4h */ case    3:  		/* b 64 */
		/* 820CCFD4h case    3:*/		return 0x820CD014;
		/* 820CCFD4h case    3:*/		return 0x820CCFD8;
	}
	return 0x820CCFD8;
} // Block from 820CCFC8h-820CCFD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CCFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CCFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CCFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CCFD8);
		  /* 820CCFD8h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CCFD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CCFD8h case    0:*/		return 0x820CCFDC;
		  /* 820CCFDCh */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820CCFDCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CCFDCh case    1:*/		return 0x820CCFE0;
		  /* 820CCFE0h */ case    2:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CCFE0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CCFE0h case    2:*/		return 0x820CCFE4;
		  /* 820CCFE4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820CCFE4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CCFE4h case    3:*/		return 0x820CCFE8;
		  /* 820CCFE8h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 820CCFE8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CD010;  }
		/* 820CCFE8h case    4:*/		return 0x820CCFEC;
		  /* 820CCFECh */ case    5:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CCFECh case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CCFECh case    5:*/		return 0x820CCFF0;
		  /* 820CCFF0h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CCFF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CCFF0h case    6:*/		return 0x820CCFF4;
		  /* 820CCFF4h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CCFF4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CCFF4h case    7:*/		return 0x820CCFF8;
		  /* 820CCFF8h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CCFF8h case    8:*/		regs.CTR = regs.R11;
		/* 820CCFF8h case    8:*/		return 0x820CCFFC;
		  /* 820CCFFCh */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CCFFCh case    9:*/		if ( 1 ) { regs.LR = 0x820CD000; return (uint32)regs.CTR; }
		/* 820CCFFCh case    9:*/		return 0x820CD000;
		  /* 820CD000h */ case   10:  		/* stw R3, <#[R31 + 20]> */
		/* 820CD000h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CD000h case   10:*/		return 0x820CD004;
		  /* 820CD004h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CD004h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CD004h case   11:*/		return 0x820CD008;
		  /* 820CD008h */ case   12:  		/* li R3, 0 */
		/* 820CD008h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD008h case   12:*/		return 0x820CD00C;
		  /* 820CD00Ch */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 820CD00Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x820CD014;  }
		/* 820CD00Ch case   13:*/		return 0x820CD010;
	}
	return 0x820CD010;
} // Block from 820CCFD8h-820CD010h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CD010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD010);
		  /* 820CD010h */ case    0:  		/* mr R3, R31 */
		/* 820CD010h case    0:*/		regs.R3 = regs.R31;
		/* 820CD010h case    0:*/		return 0x820CD014;
	}
	return 0x820CD014;
} // Block from 820CD010h-820CD014h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD014);
		  /* 820CD014h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CD014h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CD014h case    0:*/		return 0x820CD018;
		  /* 820CD018h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CD018h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CD018h case    1:*/		return 0x820CD01C;
		  /* 820CD01Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CD01Ch case    2:*/		regs.LR = regs.R12;
		/* 820CD01Ch case    2:*/		return 0x820CD020;
		  /* 820CD020h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CD020h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CD020h case    3:*/		return 0x820CD024;
		  /* 820CD024h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CD024h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CD024h case    4:*/		return 0x820CD028;
		  /* 820CD028h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CD028h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CD028h case    5:*/		return 0x820CD02C;
	}
	return 0x820CD02C;
} // Block from 820CD014h-820CD02Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CD02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD02C);
		  /* 820CD02Ch */ case    0:  		/* nop */
		/* 820CD02Ch case    0:*/		cpu::op::nop();
		/* 820CD02Ch case    0:*/		return 0x820CD030;
	}
	return 0x820CD030;
} // Block from 820CD02Ch-820CD030h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD030h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD030);
		  /* 820CD030h */ case    0:  		/* lis R11, -32217 */
		/* 820CD030h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820CD030h case    0:*/		return 0x820CD034;
		  /* 820CD034h */ case    1:  		/* li R3, 0 */
		/* 820CD034h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD034h case    1:*/		return 0x820CD038;
		  /* 820CD038h */ case    2:  		/* lwz R11, <#[R11 + 11036]> */
		/* 820CD038h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002B1C) );
		/* 820CD038h case    2:*/		return 0x820CD03C;
		  /* 820CD03Ch */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 820CD03Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820CD03Ch case    3:*/		return 0x820CD040;
		  /* 820CD040h */ case    4:  		/* bclr 12, CR6_EQ */
		/* 820CD040h case    4:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820CD040h case    4:*/		return 0x820CD044;
	}
	return 0x820CD044;
} // Block from 820CD030h-820CD044h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CD044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD044);
		  /* 820CD044h */ case    0:  		/* mr R3, R11 */
		/* 820CD044h case    0:*/		regs.R3 = regs.R11;
		/* 820CD044h case    0:*/		return 0x820CD048;
		  /* 820CD048h */ case    1:  		/* b 1705104 */
		/* 820CD048h case    1:*/		return 0x8226D4D8;
		/* 820CD048h case    1:*/		return 0x820CD04C;
		  /* 820CD04Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 820CD04Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CD04Ch case    2:*/		return 0x820CD050;
	}
	return 0x820CD050;
} // Block from 820CD044h-820CD050h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CD050h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD050);
		  /* 820CD050h */ case    0:  		/* mfspr R12, LR */
		/* 820CD050h case    0:*/		regs.R12 = regs.LR;
		/* 820CD050h case    0:*/		return 0x820CD054;
		  /* 820CD054h */ case    1:  		/* bl -245248 */
		/* 820CD054h case    1:*/		regs.LR = 0x820CD058; return 0x82091254;
		/* 820CD054h case    1:*/		return 0x820CD058;
		  /* 820CD058h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CD058h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CD058h case    2:*/		return 0x820CD05C;
		  /* 820CD05Ch */ case    3:  		/* lis R11, -32215 */
		/* 820CD05Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 820CD05Ch case    3:*/		return 0x820CD060;
		  /* 820CD060h */ case    4:  		/* li R28, 0 */
		/* 820CD060h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820CD060h case    4:*/		return 0x820CD064;
		  /* 820CD064h */ case    5:  		/* addi R30, R11, -30116 */
		/* 820CD064h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFF8A5C);
		/* 820CD064h case    5:*/		return 0x820CD068;
		  /* 820CD068h */ case    6:  		/* li R31, 1 */
		/* 820CD068h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820CD068h case    6:*/		return 0x820CD06C;
		  /* 820CD06Ch */ case    7:  		/* mr R27, R28 */
		/* 820CD06Ch case    7:*/		regs.R27 = regs.R28;
		/* 820CD06Ch case    7:*/		return 0x820CD070;
		  /* 820CD070h */ case    8:  		/* addi R8, R30, 4 */
		/* 820CD070h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x4);
		/* 820CD070h case    8:*/		return 0x820CD074;
		  /* 820CD074h */ case    9:  		/* mfmsr R9, MSR */
		/* 820CD074h case    9:*/		regs.R9 = regs.MSR;
		/* 820CD074h case    9:*/		return 0x820CD078;
		  /* 820CD078h */ case   10:  		/* mtmsrd MSR, R13 */
		/* 820CD078h case   10:*/		regs.MSR = regs.R13;
		/* 820CD078h case   10:*/		return 0x820CD07C;
		  /* 820CD07Ch */ case   11:  		/* lwarx R10, <#[R8]> */
		/* 820CD07Ch case   11:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820CD07Ch case   11:*/		return 0x820CD080;
		  /* 820CD080h */ case   12:  		/* cmpw CR6, R10, R28 */
		/* 820CD080h case   12:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R28);
		/* 820CD080h case   12:*/		return 0x820CD084;
		  /* 820CD084h */ case   13:  		/* bc 4, CR6_EQ, 20 */
		/* 820CD084h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820CD098;  }
		/* 820CD084h case   13:*/		return 0x820CD088;
		  /* 820CD088h */ case   14:  		/* stwcx. R31, <#[R8]> */
		/* 820CD088h case   14:*/		cpu::mem::stwcx( regs, regs.R31, (uint32)(regs.R8 + 0x00000000) );
		/* 820CD088h case   14:*/		return 0x820CD08C;
		  /* 820CD08Ch */ case   15:  		/* mtmsrd MSR, R9 */
		/* 820CD08Ch case   15:*/		regs.MSR = regs.R9;
		/* 820CD08Ch case   15:*/		return 0x820CD090;
		  /* 820CD090h */ case   16:  		/* bc 4, CR0_EQ, -28 */
		/* 820CD090h case   16:*/		if ( !regs.CR[0].eq ) { return 0x820CD074;  }
		/* 820CD090h case   16:*/		return 0x820CD094;
		  /* 820CD094h */ case   17:  		/* b 12 */
		/* 820CD094h case   17:*/		return 0x820CD0A0;
		/* 820CD094h case   17:*/		return 0x820CD098;
	}
	return 0x820CD098;
} // Block from 820CD050h-820CD098h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CD098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD098);
		  /* 820CD098h */ case    0:  		/* stwcx. R10, <#[R8]> */
		/* 820CD098h case    0:*/		cpu::mem::stwcx( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820CD098h case    0:*/		return 0x820CD09C;
		  /* 820CD09Ch */ case    1:  		/* mtmsrd MSR, R9 */
		/* 820CD09Ch case    1:*/		regs.MSR = regs.R9;
		/* 820CD09Ch case    1:*/		return 0x820CD0A0;
	}
	return 0x820CD0A0;
} // Block from 820CD098h-820CD0A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD0A0);
		  /* 820CD0A0h */ case    0:  		/* mr R11, R10 */
		/* 820CD0A0h case    0:*/		regs.R11 = regs.R10;
		/* 820CD0A0h case    0:*/		return 0x820CD0A4;
		  /* 820CD0A4h */ case    1:  		/* b 64 */
		/* 820CD0A4h case    1:*/		return 0x820CD0E4;
		/* 820CD0A4h case    1:*/		return 0x820CD0A8;
		  /* 820CD0A8h */ case    2:  		/* li R3, 1 */
		/* 820CD0A8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CD0A8h case    2:*/		return 0x820CD0AC;
		  /* 820CD0ACh */ case    3:  		/* bl -281716 */
		/* 820CD0ACh case    3:*/		regs.LR = 0x820CD0B0; return 0x82088438;
		/* 820CD0ACh case    3:*/		return 0x820CD0B0;
		  /* 820CD0B0h */ case    4:  		/* addi R10, R30, 4 */
		/* 820CD0B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x4);
		/* 820CD0B0h case    4:*/		return 0x820CD0B4;
		  /* 820CD0B4h */ case    5:  		/* mfmsr R9, MSR */
		/* 820CD0B4h case    5:*/		regs.R9 = regs.MSR;
		/* 820CD0B4h case    5:*/		return 0x820CD0B8;
		  /* 820CD0B8h */ case    6:  		/* mtmsrd MSR, R13 */
		/* 820CD0B8h case    6:*/		regs.MSR = regs.R13;
		/* 820CD0B8h case    6:*/		return 0x820CD0BC;
		  /* 820CD0BCh */ case    7:  		/* lwarx R11, <#[R10]> */
		/* 820CD0BCh case    7:*/		cpu::mem::lwarx( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD0BCh case    7:*/		return 0x820CD0C0;
		  /* 820CD0C0h */ case    8:  		/* cmpw CR6, R11, R28 */
		/* 820CD0C0h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R28);
		/* 820CD0C0h case    8:*/		return 0x820CD0C4;
		  /* 820CD0C4h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 820CD0C4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820CD0D8;  }
		/* 820CD0C4h case    9:*/		return 0x820CD0C8;
		  /* 820CD0C8h */ case   10:  		/* stwcx. R31, <#[R10]> */
		/* 820CD0C8h case   10:*/		cpu::mem::stwcx( regs, regs.R31, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD0C8h case   10:*/		return 0x820CD0CC;
		  /* 820CD0CCh */ case   11:  		/* mtmsrd MSR, R9 */
		/* 820CD0CCh case   11:*/		regs.MSR = regs.R9;
		/* 820CD0CCh case   11:*/		return 0x820CD0D0;
	}
	return 0x820CD0D0;
} // Block from 820CD0A0h-820CD0D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CD0D0h
// Function '??0CNodeState@D3DXShader@@QAA@PAVCNode@1@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD0D0);
		  /* 820CD0D0h */ case    0:  		/* bc 4, CR0_EQ, -28 */
		/* 820CD0D0h case    0:*/		if ( !regs.CR[0].eq ) { return 0x820CD0B4;  }
		/* 820CD0D0h case    0:*/		return 0x820CD0D4;
		  /* 820CD0D4h */ case    1:  		/* b 12 */
		/* 820CD0D4h case    1:*/		return 0x820CD0E0;
		/* 820CD0D4h case    1:*/		return 0x820CD0D8;
	}
	return 0x820CD0D8;
} // Block from 820CD0D0h-820CD0D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD0D8);
		  /* 820CD0D8h */ case    0:  		/* stwcx. R11, <#[R10]> */
		/* 820CD0D8h case    0:*/		cpu::mem::stwcx( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD0D8h case    0:*/		return 0x820CD0DC;
		  /* 820CD0DCh */ case    1:  		/* mtmsrd MSR, R9 */
		/* 820CD0DCh case    1:*/		regs.MSR = regs.R9;
		/* 820CD0DCh case    1:*/		return 0x820CD0E0;
	}
	return 0x820CD0E0;
} // Block from 820CD0D8h-820CD0E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD0E0);
		  /* 820CD0E0h */ case    0:  		/* nop */
		/* 820CD0E0h case    0:*/		cpu::op::nop();
		/* 820CD0E0h case    0:*/		return 0x820CD0E4;
	}
	return 0x820CD0E4;
} // Block from 820CD0E0h-820CD0E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD0E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD0E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD0E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD0E4);
		  /* 820CD0E4h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820CD0E4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820CD0E4h case    0:*/		return 0x820CD0E8;
		  /* 820CD0E8h */ case    1:  		/* bc 12, CR6_EQ, -64 */
		/* 820CD0E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CD0A8;  }
		/* 820CD0E8h case    1:*/		return 0x820CD0EC;
		  /* 820CD0ECh */ case    2:  		/* lwz R11, <#[R30]> */
		/* 820CD0ECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD0ECh case    2:*/		return 0x820CD0F0;
		  /* 820CD0F0h */ case    3:  		/* lis R29, -32217 */
		/* 820CD0F0h case    3:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8227);
		/* 820CD0F0h case    3:*/		return 0x820CD0F4;
		  /* 820CD0F4h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820CD0F4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CD0F4h case    4:*/		return 0x820CD0F8;
		  /* 820CD0F8h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 820CD0F8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820CD108;  }
		/* 820CD0F8h case    5:*/		return 0x820CD0FC;
		  /* 820CD0FCh */ case    6:  		/* bl 1704972 */
		/* 820CD0FCh case    6:*/		regs.LR = 0x820CD100; return 0x8226D508;
		/* 820CD0FCh case    6:*/		return 0x820CD100;
	}
	return 0x820CD100;
} // Block from 820CD0E4h-820CD100h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CD100h
// Function '?IsEqual@CNodeState@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD100);
		  /* 820CD100h */ case    0:  		/* stw R3, <#[R29 + 11036]> */
		/* 820CD100h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00002B1C) );
		/* 820CD100h case    0:*/		return 0x820CD104;
		  /* 820CD104h */ case    1:  		/* b 8 */
		/* 820CD104h case    1:*/		return 0x820CD10C;
		/* 820CD104h case    1:*/		return 0x820CD108;
	}
	return 0x820CD108;
} // Block from 820CD100h-820CD108h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD108);
		  /* 820CD108h */ case    0:  		/* lwz R3, <#[R29 + 11036]> */
		/* 820CD108h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00002B1C) );
		/* 820CD108h case    0:*/		return 0x820CD10C;
	}
	return 0x820CD10C;
} // Block from 820CD108h-820CD10Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD10C);
		  /* 820CD10Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820CD10Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD10Ch case    0:*/		return 0x820CD110;
		  /* 820CD110h */ case    1:  		/* cmpwi CR6, R3, -1 */
		/* 820CD110h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820CD110h case    1:*/		return 0x820CD114;
		  /* 820CD114h */ case    2:  		/* addi R11, R11, 1 */
		/* 820CD114h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD114h case    2:*/		return 0x820CD118;
		  /* 820CD118h */ case    3:  		/* stw R11, <#[R30]> */
		/* 820CD118h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD118h case    3:*/		return 0x820CD11C;
		  /* 820CD11Ch */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 820CD11Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CD12C;  }
		/* 820CD11Ch case    4:*/		return 0x820CD120;
		  /* 820CD120h */ case    5:  		/* lis R27, -32768 */
		/* 820CD120h case    5:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8000);
		/* 820CD120h case    5:*/		return 0x820CD124;
		  /* 820CD124h */ case    6:  		/* ori R27, R27, 16389 */
		/* 820CD124h case    6:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x4005);
		/* 820CD124h case    6:*/		return 0x820CD128;
		  /* 820CD128h */ case    7:  		/* b 88 */
		/* 820CD128h case    7:*/		return 0x820CD180;
		/* 820CD128h case    7:*/		return 0x820CD12C;
	}
	return 0x820CD12C;
} // Block from 820CD10Ch-820CD12Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CD12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD12C);
		  /* 820CD12Ch */ case    0:  		/* bl 1704876 */
		/* 820CD12Ch case    0:*/		regs.LR = 0x820CD130; return 0x8226D4D8;
		/* 820CD12Ch case    0:*/		return 0x820CD130;
		  /* 820CD130h */ case    1:  		/* or. R31, R3, R3 */
		/* 820CD130h case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820CD130h case    1:*/		return 0x820CD134;
		  /* 820CD134h */ case    2:  		/* bc 4, CR0_EQ, 64 */
		/* 820CD134h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820CD174;  }
		/* 820CD134h case    2:*/		return 0x820CD138;
		  /* 820CD138h */ case    3:  		/* lis R4, 9345 */
		/* 820CD138h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CD138h case    3:*/		return 0x820CD13C;
		  /* 820CD13Ch */ case    4:  		/* li R3, 24 */
		/* 820CD13Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x18);
		/* 820CD13Ch case    4:*/		return 0x820CD140;
		  /* 820CD140h */ case    5:  		/* bl -282432 */
		/* 820CD140h case    5:*/		regs.LR = 0x820CD144; return 0x82088200;
		/* 820CD140h case    5:*/		return 0x820CD144;
		  /* 820CD144h */ case    6:  		/* or. R31, R3, R3 */
		/* 820CD144h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820CD144h case    6:*/		return 0x820CD148;
		  /* 820CD148h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 820CD148h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820CD158;  }
		/* 820CD148h case    7:*/		return 0x820CD14C;
		  /* 820CD14Ch */ case    8:  		/* lis R27, -32761 */
		/* 820CD14Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8007);
		/* 820CD14Ch case    8:*/		return 0x820CD150;
		  /* 820CD150h */ case    9:  		/* ori R27, R27, 14 */
		/* 820CD150h case    9:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0xE);
		/* 820CD150h case    9:*/		return 0x820CD154;
		  /* 820CD154h */ case   10:  		/* b 44 */
		/* 820CD154h case   10:*/		return 0x820CD180;
		/* 820CD154h case   10:*/		return 0x820CD158;
	}
	return 0x820CD158;
} // Block from 820CD12Ch-820CD158h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CD158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD158);
		  /* 820CD158h */ case    0:  		/* li R5, 24 */
		/* 820CD158h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x18);
		/* 820CD158h case    0:*/		return 0x820CD15C;
		  /* 820CD15Ch */ case    1:  		/* li R4, 0 */
		/* 820CD15Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CD15Ch case    1:*/		return 0x820CD160;
		  /* 820CD160h */ case    2:  		/* mr R3, R31 */
		/* 820CD160h case    2:*/		regs.R3 = regs.R31;
		/* 820CD160h case    2:*/		return 0x820CD164;
		  /* 820CD164h */ case    3:  		/* bl -245284 */
		/* 820CD164h case    3:*/		regs.LR = 0x820CD168; return 0x82091340;
		/* 820CD164h case    3:*/		return 0x820CD168;
		  /* 820CD168h */ case    4:  		/* mr R4, R31 */
		/* 820CD168h case    4:*/		regs.R4 = regs.R31;
		/* 820CD168h case    4:*/		return 0x820CD16C;
		  /* 820CD16Ch */ case    5:  		/* lwz R3, <#[R29 + 11036]> */
		/* 820CD16Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00002B1C) );
		/* 820CD16Ch case    5:*/		return 0x820CD170;
		  /* 820CD170h */ case    6:  		/* bl 1704824 */
		/* 820CD170h case    6:*/		regs.LR = 0x820CD174; return 0x8226D4E8;
		/* 820CD170h case    6:*/		return 0x820CD174;
	}
	return 0x820CD174;
} // Block from 820CD158h-820CD174h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CD174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD174);
		  /* 820CD174h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820CD174h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CD174h case    0:*/		return 0x820CD178;
		  /* 820CD178h */ case    1:  		/* addi R11, R11, 1 */
		/* 820CD178h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD178h case    1:*/		return 0x820CD17C;
		  /* 820CD17Ch */ case    2:  		/* stw R11, <#[R31 + 20]> */
		/* 820CD17Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CD17Ch case    2:*/		return 0x820CD180;
	}
	return 0x820CD180;
} // Block from 820CD174h-820CD180h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CD180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD180);
		  /* 820CD180h */ case    0:  		/* addi R11, R30, 4 */
		/* 820CD180h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 820CD180h case    0:*/		return 0x820CD184;
		  /* 820CD184h */ case    1:  		/* mfmsr R9, MSR */
		/* 820CD184h case    1:*/		regs.R9 = regs.MSR;
		/* 820CD184h case    1:*/		return 0x820CD188;
		  /* 820CD188h */ case    2:  		/* mtmsrd MSR, R13 */
		/* 820CD188h case    2:*/		regs.MSR = regs.R13;
		/* 820CD188h case    2:*/		return 0x820CD18C;
		  /* 820CD18Ch */ case    3:  		/* lwarx R10, <#[R11]> */
		/* 820CD18Ch case    3:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD18Ch case    3:*/		return 0x820CD190;
		  /* 820CD190h */ case    4:  		/* stwcx. R28, <#[R11]> */
		/* 820CD190h case    4:*/		cpu::mem::stwcx( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD190h case    4:*/		return 0x820CD194;
		  /* 820CD194h */ case    5:  		/* mtmsrd MSR, R9 */
		/* 820CD194h case    5:*/		regs.MSR = regs.R9;
		/* 820CD194h case    5:*/		return 0x820CD198;
		  /* 820CD198h */ case    6:  		/* bc 4, CR0_EQ, -20 */
		/* 820CD198h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820CD184;  }
		/* 820CD198h case    6:*/		return 0x820CD19C;
		  /* 820CD19Ch */ case    7:  		/* mr R3, R27 */
		/* 820CD19Ch case    7:*/		regs.R3 = regs.R27;
		/* 820CD19Ch case    7:*/		return 0x820CD1A0;
		  /* 820CD1A0h */ case    8:  		/* addi R1, R1, 128 */
		/* 820CD1A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CD1A0h case    8:*/		return 0x820CD1A4;
		  /* 820CD1A4h */ case    9:  		/* b -245504 */
		/* 820CD1A4h case    9:*/		return 0x820912A4;
		/* 820CD1A4h case    9:*/		return 0x820CD1A8;
	}
	return 0x820CD1A8;
} // Block from 820CD180h-820CD1A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CD1A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD1A8);
		  /* 820CD1A8h */ case    0:  		/* mfspr R12, LR */
		/* 820CD1A8h case    0:*/		regs.R12 = regs.LR;
		/* 820CD1A8h case    0:*/		return 0x820CD1AC;
		  /* 820CD1ACh */ case    1:  		/* bl -245584 */
		/* 820CD1ACh case    1:*/		regs.LR = 0x820CD1B0; return 0x8209125C;
		/* 820CD1ACh case    1:*/		return 0x820CD1B0;
		  /* 820CD1B0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CD1B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CD1B0h case    2:*/		return 0x820CD1B4;
		  /* 820CD1B4h */ case    3:  		/* lis R11, -32215 */
		/* 820CD1B4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 820CD1B4h case    3:*/		return 0x820CD1B8;
		  /* 820CD1B8h */ case    4:  		/* li R29, 0 */
		/* 820CD1B8h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820CD1B8h case    4:*/		return 0x820CD1BC;
		  /* 820CD1BCh */ case    5:  		/* addi R30, R11, -30116 */
		/* 820CD1BCh case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFF8A5C);
		/* 820CD1BCh case    5:*/		return 0x820CD1C0;
		  /* 820CD1C0h */ case    6:  		/* li R31, 1 */
		/* 820CD1C0h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820CD1C0h case    6:*/		return 0x820CD1C4;
		  /* 820CD1C4h */ case    7:  		/* addi R8, R30, 4 */
		/* 820CD1C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x4);
		/* 820CD1C4h case    7:*/		return 0x820CD1C8;
		  /* 820CD1C8h */ case    8:  		/* mfmsr R9, MSR */
		/* 820CD1C8h case    8:*/		regs.R9 = regs.MSR;
		/* 820CD1C8h case    8:*/		return 0x820CD1CC;
		  /* 820CD1CCh */ case    9:  		/* mtmsrd MSR, R13 */
		/* 820CD1CCh case    9:*/		regs.MSR = regs.R13;
		/* 820CD1CCh case    9:*/		return 0x820CD1D0;
		  /* 820CD1D0h */ case   10:  		/* lwarx R10, <#[R8]> */
		/* 820CD1D0h case   10:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820CD1D0h case   10:*/		return 0x820CD1D4;
		  /* 820CD1D4h */ case   11:  		/* cmpw CR6, R10, R29 */
		/* 820CD1D4h case   11:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R29);
		/* 820CD1D4h case   11:*/		return 0x820CD1D8;
		  /* 820CD1D8h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 820CD1D8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CD1EC;  }
		/* 820CD1D8h case   12:*/		return 0x820CD1DC;
		  /* 820CD1DCh */ case   13:  		/* stwcx. R31, <#[R8]> */
		/* 820CD1DCh case   13:*/		cpu::mem::stwcx( regs, regs.R31, (uint32)(regs.R8 + 0x00000000) );
		/* 820CD1DCh case   13:*/		return 0x820CD1E0;
		  /* 820CD1E0h */ case   14:  		/* mtmsrd MSR, R9 */
		/* 820CD1E0h case   14:*/		regs.MSR = regs.R9;
		/* 820CD1E0h case   14:*/		return 0x820CD1E4;
		  /* 820CD1E4h */ case   15:  		/* bc 4, CR0_EQ, -28 */
		/* 820CD1E4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820CD1C8;  }
		/* 820CD1E4h case   15:*/		return 0x820CD1E8;
		  /* 820CD1E8h */ case   16:  		/* b 12 */
		/* 820CD1E8h case   16:*/		return 0x820CD1F4;
		/* 820CD1E8h case   16:*/		return 0x820CD1EC;
	}
	return 0x820CD1EC;
} // Block from 820CD1A8h-820CD1ECh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820CD1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD1EC);
		  /* 820CD1ECh */ case    0:  		/* stwcx. R10, <#[R8]> */
		/* 820CD1ECh case    0:*/		cpu::mem::stwcx( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820CD1ECh case    0:*/		return 0x820CD1F0;
		  /* 820CD1F0h */ case    1:  		/* mtmsrd MSR, R9 */
		/* 820CD1F0h case    1:*/		regs.MSR = regs.R9;
		/* 820CD1F0h case    1:*/		return 0x820CD1F4;
	}
	return 0x820CD1F4;
} // Block from 820CD1ECh-820CD1F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD1F4);
		  /* 820CD1F4h */ case    0:  		/* mr R11, R10 */
		/* 820CD1F4h case    0:*/		regs.R11 = regs.R10;
		/* 820CD1F4h case    0:*/		return 0x820CD1F8;
		  /* 820CD1F8h */ case    1:  		/* b 64 */
		/* 820CD1F8h case    1:*/		return 0x820CD238;
		/* 820CD1F8h case    1:*/		return 0x820CD1FC;
		  /* 820CD1FCh */ case    2:  		/* li R3, 1 */
		/* 820CD1FCh case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CD1FCh case    2:*/		return 0x820CD200;
	}
	return 0x820CD200;
} // Block from 820CD1F4h-820CD200h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CD200h
// Function '?Copy@CNodeState@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD200);
		  /* 820CD200h */ case    0:  		/* bl -282056 */
		/* 820CD200h case    0:*/		regs.LR = 0x820CD204; return 0x82088438;
		/* 820CD200h case    0:*/		return 0x820CD204;
		  /* 820CD204h */ case    1:  		/* addi R10, R30, 4 */
		/* 820CD204h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x4);
		/* 820CD204h case    1:*/		return 0x820CD208;
		  /* 820CD208h */ case    2:  		/* mfmsr R9, MSR */
		/* 820CD208h case    2:*/		regs.R9 = regs.MSR;
		/* 820CD208h case    2:*/		return 0x820CD20C;
		  /* 820CD20Ch */ case    3:  		/* mtmsrd MSR, R13 */
		/* 820CD20Ch case    3:*/		regs.MSR = regs.R13;
		/* 820CD20Ch case    3:*/		return 0x820CD210;
		  /* 820CD210h */ case    4:  		/* lwarx R11, <#[R10]> */
		/* 820CD210h case    4:*/		cpu::mem::lwarx( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD210h case    4:*/		return 0x820CD214;
		  /* 820CD214h */ case    5:  		/* cmpw CR6, R11, R29 */
		/* 820CD214h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 820CD214h case    5:*/		return 0x820CD218;
		  /* 820CD218h */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 820CD218h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CD22C;  }
		/* 820CD218h case    6:*/		return 0x820CD21C;
		  /* 820CD21Ch */ case    7:  		/* stwcx. R31, <#[R10]> */
		/* 820CD21Ch case    7:*/		cpu::mem::stwcx( regs, regs.R31, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD21Ch case    7:*/		return 0x820CD220;
		  /* 820CD220h */ case    8:  		/* mtmsrd MSR, R9 */
		/* 820CD220h case    8:*/		regs.MSR = regs.R9;
		/* 820CD220h case    8:*/		return 0x820CD224;
		  /* 820CD224h */ case    9:  		/* bc 4, CR0_EQ, -28 */
		/* 820CD224h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820CD208;  }
		/* 820CD224h case    9:*/		return 0x820CD228;
		  /* 820CD228h */ case   10:  		/* b 12 */
		/* 820CD228h case   10:*/		return 0x820CD234;
		/* 820CD228h case   10:*/		return 0x820CD22C;
	}
	return 0x820CD22C;
} // Block from 820CD200h-820CD22Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CD22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD22C);
		  /* 820CD22Ch */ case    0:  		/* stwcx. R11, <#[R10]> */
		/* 820CD22Ch case    0:*/		cpu::mem::stwcx( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD22Ch case    0:*/		return 0x820CD230;
		  /* 820CD230h */ case    1:  		/* mtmsrd MSR, R9 */
		/* 820CD230h case    1:*/		regs.MSR = regs.R9;
		/* 820CD230h case    1:*/		return 0x820CD234;
	}
	return 0x820CD234;
} // Block from 820CD22Ch-820CD234h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD234);
		  /* 820CD234h */ case    0:  		/* nop */
		/* 820CD234h case    0:*/		cpu::op::nop();
		/* 820CD234h case    0:*/		return 0x820CD238;
	}
	return 0x820CD238;
} // Block from 820CD234h-820CD238h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD238);
		  /* 820CD238h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820CD238h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820CD238h case    0:*/		return 0x820CD23C;
		  /* 820CD23Ch */ case    1:  		/* bc 12, CR6_EQ, -64 */
		/* 820CD23Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820CD1FC;  }
		/* 820CD23Ch case    1:*/		return 0x820CD240;
		  /* 820CD240h */ case    2:  		/* lis R31, -32217 */
		/* 820CD240h case    2:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8227);
		/* 820CD240h case    2:*/		return 0x820CD244;
		  /* 820CD244h */ case    3:  		/* lwz R3, <#[R31 + 11036]> */
		/* 820CD244h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00002B1C) );
		/* 820CD244h case    3:*/		return 0x820CD248;
		  /* 820CD248h */ case    4:  		/* cmpwi CR6, R3, -1 */
		/* 820CD248h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820CD248h case    4:*/		return 0x820CD24C;
		  /* 820CD24Ch */ case    5:  		/* bc 12, CR6_EQ, 56 */
		/* 820CD24Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820CD284;  }
		/* 820CD24Ch case    5:*/		return 0x820CD250;
		  /* 820CD250h */ case    6:  		/* bl 1704584 */
		/* 820CD250h case    6:*/		regs.LR = 0x820CD254; return 0x8226D4D8;
		/* 820CD250h case    6:*/		return 0x820CD254;
		  /* 820CD254h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820CD254h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CD254h case    7:*/		return 0x820CD258;
		  /* 820CD258h */ case    8:  		/* bc 12, CR0_EQ, 40 */
		/* 820CD258h case    8:*/		if ( regs.CR[0].eq ) { return 0x820CD280;  }
		/* 820CD258h case    8:*/		return 0x820CD25C;
		  /* 820CD25Ch */ case    9:  		/* lwz R11, <#[R3 + 20]> */
		/* 820CD25Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CD25Ch case    9:*/		return 0x820CD260;
		  /* 820CD260h */ case   10:  		/* addic. R11, R11, -1 */
		/* 820CD260h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820CD260h case   10:*/		return 0x820CD264;
		  /* 820CD264h */ case   11:  		/* stw R11, <#[R3 + 20]> */
		/* 820CD264h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CD264h case   11:*/		return 0x820CD268;
		  /* 820CD268h */ case   12:  		/* bc 4, CR0_EQ, 24 */
		/* 820CD268h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820CD280;  }
		/* 820CD268h case   12:*/		return 0x820CD26C;
		  /* 820CD26Ch */ case   13:  		/* lis R4, 9345 */
		/* 820CD26Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CD26Ch case   13:*/		return 0x820CD270;
		  /* 820CD270h */ case   14:  		/* bl -282424 */
		/* 820CD270h case   14:*/		regs.LR = 0x820CD274; return 0x82088338;
		/* 820CD270h case   14:*/		return 0x820CD274;
		  /* 820CD274h */ case   15:  		/* li R4, 0 */
		/* 820CD274h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CD274h case   15:*/		return 0x820CD278;
		  /* 820CD278h */ case   16:  		/* lwz R3, <#[R31 + 11036]> */
		/* 820CD278h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00002B1C) );
		/* 820CD278h case   16:*/		return 0x820CD27C;
		  /* 820CD27Ch */ case   17:  		/* bl 1704556 */
		/* 820CD27Ch case   17:*/		regs.LR = 0x820CD280; return 0x8226D4E8;
		/* 820CD27Ch case   17:*/		return 0x820CD280;
	}
	return 0x820CD280;
} // Block from 820CD238h-820CD280h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CD280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD280);
		  /* 820CD280h */ case    0:  		/* lwz R3, <#[R31 + 11036]> */
		/* 820CD280h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00002B1C) );
		/* 820CD280h case    0:*/		return 0x820CD284;
	}
	return 0x820CD284;
} // Block from 820CD280h-820CD284h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD284);
		  /* 820CD284h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820CD284h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD284h case    0:*/		return 0x820CD288;
		  /* 820CD288h */ case    1:  		/* addi R11, R11, -1 */
		/* 820CD288h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820CD288h case    1:*/		return 0x820CD28C;
		  /* 820CD28Ch */ case    2:  		/* stw R11, <#[R30]> */
		/* 820CD28Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD28Ch case    2:*/		return 0x820CD290;
		  /* 820CD290h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 820CD290h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD290h case    3:*/		return 0x820CD294;
		  /* 820CD294h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820CD294h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CD294h case    4:*/		return 0x820CD298;
		  /* 820CD298h */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 820CD298h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820CD2B0;  }
		/* 820CD298h case    5:*/		return 0x820CD29C;
		  /* 820CD29Ch */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 820CD29Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820CD29Ch case    6:*/		return 0x820CD2A0;
		  /* 820CD2A0h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 820CD2A0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820CD2B0;  }
		/* 820CD2A0h case    7:*/		return 0x820CD2A4;
		  /* 820CD2A4h */ case    8:  		/* bl 1704532 */
		/* 820CD2A4h case    8:*/		regs.LR = 0x820CD2A8; return 0x8226D4F8;
		/* 820CD2A4h case    8:*/		return 0x820CD2A8;
		  /* 820CD2A8h */ case    9:  		/* li R11, -1 */
		/* 820CD2A8h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820CD2A8h case    9:*/		return 0x820CD2AC;
		  /* 820CD2ACh */ case   10:  		/* stw R11, <#[R31 + 11036]> */
		/* 820CD2ACh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 820CD2ACh case   10:*/		return 0x820CD2B0;
	}
	return 0x820CD2B0;
} // Block from 820CD284h-820CD2B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CD2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD2B0);
		  /* 820CD2B0h */ case    0:  		/* addi R11, R30, 4 */
		/* 820CD2B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 820CD2B0h case    0:*/		return 0x820CD2B4;
		  /* 820CD2B4h */ case    1:  		/* mfmsr R9, MSR */
		/* 820CD2B4h case    1:*/		regs.R9 = regs.MSR;
		/* 820CD2B4h case    1:*/		return 0x820CD2B8;
		  /* 820CD2B8h */ case    2:  		/* mtmsrd MSR, R13 */
		/* 820CD2B8h case    2:*/		regs.MSR = regs.R13;
		/* 820CD2B8h case    2:*/		return 0x820CD2BC;
		  /* 820CD2BCh */ case    3:  		/* lwarx R10, <#[R11]> */
		/* 820CD2BCh case    3:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD2BCh case    3:*/		return 0x820CD2C0;
		  /* 820CD2C0h */ case    4:  		/* stwcx. R29, <#[R11]> */
		/* 820CD2C0h case    4:*/		cpu::mem::stwcx( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD2C0h case    4:*/		return 0x820CD2C4;
		  /* 820CD2C4h */ case    5:  		/* mtmsrd MSR, R9 */
		/* 820CD2C4h case    5:*/		regs.MSR = regs.R9;
		/* 820CD2C4h case    5:*/		return 0x820CD2C8;
		  /* 820CD2C8h */ case    6:  		/* bc 4, CR0_EQ, -20 */
		/* 820CD2C8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820CD2B4;  }
		/* 820CD2C8h case    6:*/		return 0x820CD2CC;
		  /* 820CD2CCh */ case    7:  		/* addi R1, R1, 112 */
		/* 820CD2CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CD2CCh case    7:*/		return 0x820CD2D0;
		  /* 820CD2D0h */ case    8:  		/* b -245796 */
		/* 820CD2D0h case    8:*/		return 0x820912AC;
		/* 820CD2D0h case    8:*/		return 0x820CD2D4;
		  /* 820CD2D4h */ case    9:  		/* nop */
		/* 820CD2D4h case    9:*/		cpu::op::nop();
		/* 820CD2D4h case    9:*/		return 0x820CD2D8;
	}
	return 0x820CD2D8;
} // Block from 820CD2B0h-820CD2D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CD2D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD2D8);
		  /* 820CD2D8h */ case    0:  		/* mfspr R12, LR */
		/* 820CD2D8h case    0:*/		regs.R12 = regs.LR;
		/* 820CD2D8h case    0:*/		return 0x820CD2DC;
		  /* 820CD2DCh */ case    1:  		/* bl -245888 */
		/* 820CD2DCh case    1:*/		regs.LR = 0x820CD2E0; return 0x8209125C;
		/* 820CD2DCh case    1:*/		return 0x820CD2E0;
		  /* 820CD2E0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CD2E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CD2E0h case    2:*/		return 0x820CD2E4;
		  /* 820CD2E4h */ case    3:  		/* lis R10, -32215 */
		/* 820CD2E4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 820CD2E4h case    3:*/		return 0x820CD2E8;
		  /* 820CD2E8h */ case    4:  		/* lwz R11, <#[R10 - 30108]> */
		/* 820CD2E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFF8A64) );
		/* 820CD2E8h case    4:*/		return 0x820CD2EC;
		  /* 820CD2ECh */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820CD2ECh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CD2ECh case    5:*/		return 0x820CD2F0;
		  /* 820CD2F0h */ case    6:  		/* bc 4, CR6_EQ, 192 */
		/* 820CD2F0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CD3B0;  }
		/* 820CD2F0h case    6:*/		return 0x820CD2F4;
		  /* 820CD2F4h */ case    7:  		/* li R11, 1 */
		/* 820CD2F4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820CD2F4h case    7:*/		return 0x820CD2F8;
		  /* 820CD2F8h */ case    8:  		/* lis R4, 9345 */
		/* 820CD2F8h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CD2F8h case    8:*/		return 0x820CD2FC;
		  /* 820CD2FCh */ case    9:  		/* stw R11, <#[R10 - 30108]> */
		/* 820CD2FCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0xFFFF8A64) );
		/* 820CD2FCh case    9:*/		return 0x820CD300;
		  /* 820CD300h */ case   10:  		/* li R3, 0 */
		/* 820CD300h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD300h case   10:*/		return 0x820CD304;
		  /* 820CD304h */ case   11:  		/* li R29, 0 */
		/* 820CD304h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820CD304h case   11:*/		return 0x820CD308;
		  /* 820CD308h */ case   12:  		/* bl -282888 */
		/* 820CD308h case   12:*/		regs.LR = 0x820CD30C; return 0x82088200;
		/* 820CD308h case   12:*/		return 0x820CD30C;
		  /* 820CD30Ch */ case   13:  		/* mr R31, R3 */
		/* 820CD30Ch case   13:*/		regs.R31 = regs.R3;
		/* 820CD30Ch case   13:*/		return 0x820CD310;
		  /* 820CD310h */ case   14:  		/* lis R4, 9345 */
		/* 820CD310h case   14:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CD310h case   14:*/		return 0x820CD314;
		  /* 820CD314h */ case   15:  		/* li R3, 0 */
		/* 820CD314h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD314h case   15:*/		return 0x820CD318;
		  /* 820CD318h */ case   16:  		/* bl -282904 */
		/* 820CD318h case   16:*/		regs.LR = 0x820CD31C; return 0x82088200;
		/* 820CD318h case   16:*/		return 0x820CD31C;
		  /* 820CD31Ch */ case   17:  		/* mr R30, R3 */
		/* 820CD31Ch case   17:*/		regs.R30 = regs.R3;
		/* 820CD31Ch case   17:*/		return 0x820CD320;
	}
	return 0x820CD320;
} // Block from 820CD2D8h-820CD320h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CD320h
// Function '??0CNodeBuffer@D3DXShader@@QAA@PBUD3DXTOKEN@1@PAEI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD320);
		  /* 820CD320h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CD320h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CD320h case    0:*/		return 0x820CD324;
		  /* 820CD324h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820CD324h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CD338;  }
		/* 820CD324h case    1:*/		return 0x820CD328;
		  /* 820CD328h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820CD328h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CD328h case    2:*/		return 0x820CD32C;
		  /* 820CD32Ch */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820CD32Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820CD338;  }
		/* 820CD32Ch case    3:*/		return 0x820CD330;
		  /* 820CD330h */ case    4:  		/* cmplw CR6, R31, R3 */
		/* 820CD330h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R3);
		/* 820CD330h case    4:*/		return 0x820CD334;
		  /* 820CD334h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820CD334h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820CD33C;  }
		/* 820CD334h case    5:*/		return 0x820CD338;
	}
	return 0x820CD338;
} // Block from 820CD320h-820CD338h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CD338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD338);
		  /* 820CD338h */ case    0:  		/* li R29, 1 */
		/* 820CD338h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820CD338h case    0:*/		return 0x820CD33C;
	}
	return 0x820CD33C;
} // Block from 820CD338h-820CD33Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD33Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD33C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD33C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD33C);
		  /* 820CD33Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CD33Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CD33Ch case    0:*/		return 0x820CD340;
		  /* 820CD340h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820CD340h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CD350;  }
		/* 820CD340h case    1:*/		return 0x820CD344;
		  /* 820CD344h */ case    2:  		/* lis R4, 9345 */
		/* 820CD344h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CD344h case    2:*/		return 0x820CD348;
		  /* 820CD348h */ case    3:  		/* mr R3, R31 */
		/* 820CD348h case    3:*/		regs.R3 = regs.R31;
		/* 820CD348h case    3:*/		return 0x820CD34C;
		  /* 820CD34Ch */ case    4:  		/* bl -282644 */
		/* 820CD34Ch case    4:*/		regs.LR = 0x820CD350; return 0x82088338;
		/* 820CD34Ch case    4:*/		return 0x820CD350;
	}
	return 0x820CD350;
} // Block from 820CD33Ch-820CD350h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CD350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD350);
		  /* 820CD350h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820CD350h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CD350h case    0:*/		return 0x820CD354;
		  /* 820CD354h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820CD354h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CD36C;  }
		/* 820CD354h case    1:*/		return 0x820CD358;
		  /* 820CD358h */ case    2:  		/* cmplw CR6, R30, R31 */
		/* 820CD358h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 820CD358h case    2:*/		return 0x820CD35C;
		  /* 820CD35Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820CD35Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820CD36C;  }
		/* 820CD35Ch case    3:*/		return 0x820CD360;
		  /* 820CD360h */ case    4:  		/* lis R4, 9345 */
		/* 820CD360h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CD360h case    4:*/		return 0x820CD364;
		  /* 820CD364h */ case    5:  		/* mr R3, R30 */
		/* 820CD364h case    5:*/		regs.R3 = regs.R30;
		/* 820CD364h case    5:*/		return 0x820CD368;
	}
	return 0x820CD368;
} // Block from 820CD350h-820CD368h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CD368h
// Function '?IsEqual@CNodeBuffer@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD368);
		  /* 820CD368h */ case    0:  		/* bl -282672 */
		/* 820CD368h case    0:*/		regs.LR = 0x820CD36C; return 0x82088338;
		/* 820CD368h case    0:*/		return 0x820CD36C;
	}
	return 0x820CD36C;
} // Block from 820CD368h-820CD36Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD36C);
		  /* 820CD36Ch */ case    0:  		/* lis R4, 9345 */
		/* 820CD36Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CD36Ch case    0:*/		return 0x820CD370;
		  /* 820CD370h */ case    1:  		/* li R3, 0 */
		/* 820CD370h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD370h case    1:*/		return 0x820CD374;
		  /* 820CD374h */ case    2:  		/* bl -282684 */
		/* 820CD374h case    2:*/		regs.LR = 0x820CD378; return 0x82088338;
		/* 820CD374h case    2:*/		return 0x820CD378;
		  /* 820CD378h */ case    3:  		/* cmpwi CR6, R29, 0 */
		/* 820CD378h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820CD378h case    3:*/		return 0x820CD37C;
		  /* 820CD37Ch */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 820CD37Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820CD3B0;  }
		/* 820CD37Ch case    4:*/		return 0x820CD380;
		  /* 820CD380h */ case    5:  		/* lis R11, -32255 */
		/* 820CD380h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CD380h case    5:*/		return 0x820CD384;
		  /* 820CD384h */ case    6:  		/* addi R3, R11, 10992 */
		/* 820CD384h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2AF0);
		/* 820CD384h case    6:*/		return 0x820CD388;
		  /* 820CD388h */ case    7:  		/* bl -282672 */
		/* 820CD388h case    7:*/		regs.LR = 0x820CD38C; return 0x82088358;
		/* 820CD388h case    7:*/		return 0x820CD38C;
		  /* 820CD38Ch */ case    8:  		/* lis R11, -32255 */
		/* 820CD38Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CD38Ch case    8:*/		return 0x820CD390;
		  /* 820CD390h */ case    9:  		/* addi R3, R11, 10896 */
		/* 820CD390h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2A90);
		/* 820CD390h case    9:*/		return 0x820CD394;
		  /* 820CD394h */ case   10:  		/* bl -282684 */
		/* 820CD394h case   10:*/		regs.LR = 0x820CD398; return 0x82088358;
		/* 820CD394h case   10:*/		return 0x820CD398;
		  /* 820CD398h */ case   11:  		/* lis R11, -32255 */
		/* 820CD398h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CD398h case   11:*/		return 0x820CD39C;
		  /* 820CD39Ch */ case   12:  		/* addi R3, R11, 10808 */
		/* 820CD39Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2A38);
		/* 820CD39Ch case   12:*/		return 0x820CD3A0;
		  /* 820CD3A0h */ case   13:  		/* bl -282696 */
		/* 820CD3A0h case   13:*/		regs.LR = 0x820CD3A4; return 0x82088358;
		/* 820CD3A0h case   13:*/		return 0x820CD3A4;
		  /* 820CD3A4h */ case   14:  		/* lis R11, -32255 */
		/* 820CD3A4h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CD3A4h case   14:*/		return 0x820CD3A8;
		  /* 820CD3A8h */ case   15:  		/* addi R3, R11, 10760 */
		/* 820CD3A8h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2A08);
		/* 820CD3A8h case   15:*/		return 0x820CD3AC;
		  /* 820CD3ACh */ case   16:  		/* bl -282708 */
		/* 820CD3ACh case   16:*/		regs.LR = 0x820CD3B0; return 0x82088358;
		/* 820CD3ACh case   16:*/		return 0x820CD3B0;
	}
	return 0x820CD3B0;
} // Block from 820CD36Ch-820CD3B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820CD3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD3B0);
		  /* 820CD3B0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CD3B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CD3B0h case    0:*/		return 0x820CD3B4;
		  /* 820CD3B4h */ case    1:  		/* b -246024 */
		/* 820CD3B4h case    1:*/		return 0x820912AC;
		/* 820CD3B4h case    1:*/		return 0x820CD3B8;
	}
	return 0x820CD3B8;
} // Block from 820CD3B0h-820CD3B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD3B8);
		  /* 820CD3B8h */ case    0:  		/* mfspr R12, LR */
		/* 820CD3B8h case    0:*/		regs.R12 = regs.LR;
		/* 820CD3B8h case    0:*/		return 0x820CD3BC;
		  /* 820CD3BCh */ case    1:  		/* bl -246112 */
		/* 820CD3BCh case    1:*/		regs.LR = 0x820CD3C0; return 0x8209125C;
		/* 820CD3BCh case    1:*/		return 0x820CD3C0;
		  /* 820CD3C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CD3C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CD3C0h case    2:*/		return 0x820CD3C4;
		  /* 820CD3C4h */ case    3:  		/* mr R29, R3 */
		/* 820CD3C4h case    3:*/		regs.R29 = regs.R3;
		/* 820CD3C4h case    3:*/		return 0x820CD3C8;
		  /* 820CD3C8h */ case    4:  		/* mr R30, R4 */
		/* 820CD3C8h case    4:*/		regs.R30 = regs.R4;
		/* 820CD3C8h case    4:*/		return 0x820CD3CC;
		  /* 820CD3CCh */ case    5:  		/* mr R31, R5 */
		/* 820CD3CCh case    5:*/		regs.R31 = regs.R5;
		/* 820CD3CCh case    5:*/		return 0x820CD3D0;
		  /* 820CD3D0h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 820CD3D0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820CD3D0h case    6:*/		return 0x820CD3D4;
		  /* 820CD3D4h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 820CD3D4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820CD3DC;  }
		/* 820CD3D4h case    7:*/		return 0x820CD3D8;
		  /* 820CD3D8h */ case    8:  		/* addi R31, R1, 88 */
		/* 820CD3D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x58);
		/* 820CD3D8h case    8:*/		return 0x820CD3DC;
	}
	return 0x820CD3DC;
} // Block from 820CD3B8h-820CD3DCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CD3DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD3DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD3DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD3DC);
		  /* 820CD3DCh */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 820CD3DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820CD3DCh case    0:*/		return 0x820CD3E0;
		  /* 820CD3E0h */ case    1:  		/* cmpwi CR6, R11, 9 */
		/* 820CD3E0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 820CD3E0h case    1:*/		return 0x820CD3E4;
		  /* 820CD3E4h */ case    2:  		/* bc 4, CR6_EQ, 88 */
		/* 820CD3E4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CD43C;  }
		/* 820CD3E4h case    2:*/		return 0x820CD3E8;
	}
	return 0x820CD3E8;
} // Block from 820CD3DCh-820CD3E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CD3E8h
// Function '?Copy@CNodeBuffer@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD3E8);
		  /* 820CD3E8h */ case    0:  		/* lwz R11, <#[R29 + 16]> */
		/* 820CD3E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 820CD3E8h case    0:*/		return 0x820CD3EC;
		  /* 820CD3ECh */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 820CD3ECh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820CD3ECh case    1:*/		return 0x820CD3F0;
		  /* 820CD3F0h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 820CD3F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CD428;  }
		/* 820CD3F0h case    2:*/		return 0x820CD3F4;
		  /* 820CD3F4h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820CD3F4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CD3F4h case    3:*/		return 0x820CD3F8;
		  /* 820CD3F8h */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 820CD3F8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CD428;  }
		/* 820CD3F8h case    4:*/		return 0x820CD3FC;
		  /* 820CD3FCh */ case    5:  		/* cmpwi CR6, R11, 2 */
		/* 820CD3FCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820CD3FCh case    5:*/		return 0x820CD400;
		  /* 820CD400h */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 820CD400h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CD414;  }
		/* 820CD400h case    6:*/		return 0x820CD404;
		  /* 820CD404h */ case    7:  		/* lwz R11, <#[R29 + 32]> */
		/* 820CD404h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 820CD404h case    7:*/		return 0x820CD408;
		  /* 820CD408h */ case    8:  		/* stw R11, <#[R30]> */
		/* 820CD408h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD408h case    8:*/		return 0x820CD40C;
		  /* 820CD40Ch */ case    9:  		/* lwz R11, <#[R29 + 28]> */
		/* 820CD40Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 820CD40Ch case    9:*/		return 0x820CD410;
		  /* 820CD410h */ case   10:  		/* b 36 */
		/* 820CD410h case   10:*/		return 0x820CD434;
		/* 820CD410h case   10:*/		return 0x820CD414;
	}
	return 0x820CD414;
} // Block from 820CD3E8h-820CD414h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CD414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD414);
		  /* 820CD414h */ case    0:  		/* cmpwi CR6, R11, 3 */
		/* 820CD414h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820CD414h case    0:*/		return 0x820CD418;
		  /* 820CD418h */ case    1:  		/* bc 4, CR6_EQ, 200 */
		/* 820CD418h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CD4E0;  }
		/* 820CD418h case    1:*/		return 0x820CD41C;
		  /* 820CD41Ch */ case    2:  		/* li R11, 1 */
		/* 820CD41Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820CD41Ch case    2:*/		return 0x820CD420;
		  /* 820CD420h */ case    3:  		/* stw R11, <#[R30]> */
		/* 820CD420h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD420h case    3:*/		return 0x820CD424;
		  /* 820CD424h */ case    4:  		/* b 16 */
		/* 820CD424h case    4:*/		return 0x820CD434;
		/* 820CD424h case    4:*/		return 0x820CD428;
	}
	return 0x820CD428;
} // Block from 820CD414h-820CD428h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CD428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD428);
		  /* 820CD428h */ case    0:  		/* li R11, 1 */
		/* 820CD428h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820CD428h case    0:*/		return 0x820CD42C;
		  /* 820CD42Ch */ case    1:  		/* stw R11, <#[R30]> */
		/* 820CD42Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD42Ch case    1:*/		return 0x820CD430;
		  /* 820CD430h */ case    2:  		/* lwz R11, <#[R29 + 32]> */
		/* 820CD430h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 820CD430h case    2:*/		return 0x820CD434;
	}
	return 0x820CD434;
} // Block from 820CD428h-820CD434h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CD434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD434);
		  /* 820CD434h */ case    0:  		/* stw R11, <#[R31]> */
		/* 820CD434h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CD434h case    0:*/		return 0x820CD438;
		  /* 820CD438h */ case    1:  		/* b 160 */
		/* 820CD438h case    1:*/		return 0x820CD4D8;
		/* 820CD438h case    1:*/		return 0x820CD43C;
	}
	return 0x820CD43C;
} // Block from 820CD434h-820CD43Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD43C);
		  /* 820CD43Ch */ case    0:  		/* cmpwi CR6, R11, 8 */
		/* 820CD43Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 820CD43Ch case    0:*/		return 0x820CD440;
		  /* 820CD440h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 820CD440h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CD470;  }
		/* 820CD440h case    1:*/		return 0x820CD444;
		  /* 820CD444h */ case    2:  		/* mr R5, R31 */
		/* 820CD444h case    2:*/		regs.R5 = regs.R31;
		/* 820CD444h case    2:*/		return 0x820CD448;
		  /* 820CD448h */ case    3:  		/* lwz R3, <#[R29 + 16]> */
		/* 820CD448h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000010) );
		/* 820CD448h case    3:*/		return 0x820CD44C;
		  /* 820CD44Ch */ case    4:  		/* mr R4, R30 */
		/* 820CD44Ch case    4:*/		regs.R4 = regs.R30;
		/* 820CD44Ch case    4:*/		return 0x820CD450;
		  /* 820CD450h */ case    5:  		/* bl -152 */
		/* 820CD450h case    5:*/		regs.LR = 0x820CD454; return 0x820CD3B8;
		/* 820CD450h case    5:*/		return 0x820CD454;
		  /* 820CD454h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820CD454h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CD454h case    6:*/		return 0x820CD458;
		  /* 820CD458h */ case    7:  		/* bc 12, CR0_LT, 144 */
		/* 820CD458h case    7:*/		if ( regs.CR[0].lt ) { return 0x820CD4E8;  }
		/* 820CD458h case    7:*/		return 0x820CD45C;
		  /* 820CD45Ch */ case    8:  		/* lwz R11, <#[R29 + 20]> */
		/* 820CD45Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 820CD45Ch case    8:*/		return 0x820CD460;
		  /* 820CD460h */ case    9:  		/* lwz R10, <#[R30]> */
		/* 820CD460h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD460h case    9:*/		return 0x820CD464;
		  /* 820CD464h */ case   10:  		/* mullw R11, R11, R10 */
		/* 820CD464h case   10:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820CD464h case   10:*/		return 0x820CD468;
		  /* 820CD468h */ case   11:  		/* stw R11, <#[R30]> */
		/* 820CD468h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD468h case   11:*/		return 0x820CD46C;
		  /* 820CD46Ch */ case   12:  		/* b 108 */
		/* 820CD46Ch case   12:*/		return 0x820CD4D8;
		/* 820CD46Ch case   12:*/		return 0x820CD470;
	}
	return 0x820CD470;
} // Block from 820CD43Ch-820CD470h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CD470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD470);
		  /* 820CD470h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820CD470h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820CD470h case    0:*/		return 0x820CD474;
		  /* 820CD474h */ case    1:  		/* bc 4, CR6_EQ, 108 */
		/* 820CD474h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CD4E0;  }
		/* 820CD474h case    1:*/		return 0x820CD478;
		  /* 820CD478h */ case    2:  		/* li R11, 0 */
		/* 820CD478h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CD478h case    2:*/		return 0x820CD47C;
		  /* 820CD47Ch */ case    3:  		/* stw R11, <#[R30]> */
		/* 820CD47Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD47Ch case    3:*/		return 0x820CD480;
		  /* 820CD480h */ case    4:  		/* stw R11, <#[R31]> */
		/* 820CD480h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CD480h case    4:*/		return 0x820CD484;
		  /* 820CD484h */ case    5:  		/* lwz R11, <#[R29 + 8]> */
		/* 820CD484h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820CD484h case    5:*/		return 0x820CD488;
		  /* 820CD488h */ case    6:  		/* addi R5, R1, 84 */
		/* 820CD488h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 820CD488h case    6:*/		return 0x820CD48C;
		  /* 820CD48Ch */ case    7:  		/* addi R4, R1, 80 */
		/* 820CD48Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820CD48Ch case    7:*/		return 0x820CD490;
	}
	return 0x820CD490;
} // Block from 820CD470h-820CD490h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CD490h
// Function '??0CNodeRegister@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD490);
		  /* 820CD490h */ case    0:  		/* lwz R11, <#[R11 + 24]> */
		/* 820CD490h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820CD490h case    0:*/		return 0x820CD494;
		  /* 820CD494h */ case    1:  		/* lwz R3, <#[R11 + 48]> */
		/* 820CD494h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 820CD494h case    1:*/		return 0x820CD498;
		  /* 820CD498h */ case    2:  		/* bl -224 */
		/* 820CD498h case    2:*/		regs.LR = 0x820CD49C; return 0x820CD3B8;
		/* 820CD498h case    2:*/		return 0x820CD49C;
		  /* 820CD49Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820CD49Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CD49Ch case    3:*/		return 0x820CD4A0;
		  /* 820CD4A0h */ case    4:  		/* bc 12, CR0_LT, 72 */
		/* 820CD4A0h case    4:*/		if ( regs.CR[0].lt ) { return 0x820CD4E8;  }
		/* 820CD4A0h case    4:*/		return 0x820CD4A4;
		  /* 820CD4A4h */ case    5:  		/* lwz R11, <#[R30]> */
		/* 820CD4A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD4A4h case    5:*/		return 0x820CD4A8;
		  /* 820CD4A8h */ case    6:  		/* lwz R10, <#[R1 + 80]> */
		/* 820CD4A8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820CD4A8h case    6:*/		return 0x820CD4AC;
		  /* 820CD4ACh */ case    7:  		/* lwz R9, <#[R1 + 84]> */
		/* 820CD4ACh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 820CD4ACh case    7:*/		return 0x820CD4B0;
		  /* 820CD4B0h */ case    8:  		/* add R11, R11, R10 */
		/* 820CD4B0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820CD4B0h case    8:*/		return 0x820CD4B4;
		  /* 820CD4B4h */ case    9:  		/* stw R11, <#[R30]> */
		/* 820CD4B4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CD4B4h case    9:*/		return 0x820CD4B8;
		  /* 820CD4B8h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 820CD4B8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CD4B8h case   10:*/		return 0x820CD4BC;
		  /* 820CD4BCh */ case   11:  		/* cmplw CR6, R9, R11 */
		/* 820CD4BCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820CD4BCh case   11:*/		return 0x820CD4C0;
		  /* 820CD4C0h */ case   12:  		/* bc 4, CR6_GT, 8 */
		/* 820CD4C0h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820CD4C8;  }
		/* 820CD4C0h case   12:*/		return 0x820CD4C4;
		  /* 820CD4C4h */ case   13:  		/* mr R11, R9 */
		/* 820CD4C4h case   13:*/		regs.R11 = regs.R9;
		/* 820CD4C4h case   13:*/		return 0x820CD4C8;
	}
	return 0x820CD4C8;
} // Block from 820CD490h-820CD4C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CD4C8h
// Function '??0CNodeRegister@D3DXShader@@QAA@W4_D3DRREGISTERBINDTYPE@1@PAVCNode@1@11@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD4C8);
		  /* 820CD4C8h */ case    0:  		/* stw R11, <#[R31]> */
		/* 820CD4C8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CD4C8h case    0:*/		return 0x820CD4CC;
		  /* 820CD4CCh */ case    1:  		/* lwz R29, <#[R29 + 12]> */
		/* 820CD4CCh case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000000C) );
		/* 820CD4CCh case    1:*/		return 0x820CD4D0;
		  /* 820CD4D0h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 820CD4D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820CD4D0h case    2:*/		return 0x820CD4D4;
		  /* 820CD4D4h */ case    3:  		/* bc 4, CR6_EQ, -80 */
		/* 820CD4D4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820CD484;  }
		/* 820CD4D4h case    3:*/		return 0x820CD4D8;
	}
	return 0x820CD4D8;
} // Block from 820CD4C8h-820CD4D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CD4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD4D8);
		  /* 820CD4D8h */ case    0:  		/* li R3, 0 */
		/* 820CD4D8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD4D8h case    0:*/		return 0x820CD4DC;
		  /* 820CD4DCh */ case    1:  		/* b 12 */
		/* 820CD4DCh case    1:*/		return 0x820CD4E8;
		/* 820CD4DCh case    1:*/		return 0x820CD4E0;
	}
	return 0x820CD4E0;
} // Block from 820CD4D8h-820CD4E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD4E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD4E0);
		  /* 820CD4E0h */ case    0:  		/* lis R3, -32768 */
		/* 820CD4E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CD4E0h case    0:*/		return 0x820CD4E4;
		  /* 820CD4E4h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820CD4E4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CD4E4h case    1:*/		return 0x820CD4E8;
	}
	return 0x820CD4E8;
} // Block from 820CD4E0h-820CD4E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD4E8);
		  /* 820CD4E8h */ case    0:  		/* addi R1, R1, 128 */
		/* 820CD4E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CD4E8h case    0:*/		return 0x820CD4EC;
		  /* 820CD4ECh */ case    1:  		/* b -246336 */
		/* 820CD4ECh case    1:*/		return 0x820912AC;
		/* 820CD4ECh case    1:*/		return 0x820CD4F0;
	}
	return 0x820CD4F0;
} // Block from 820CD4E8h-820CD4F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD4F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD4F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD4F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD4F0);
		  /* 820CD4F0h */ case    0:  		/* mfspr R12, LR */
		/* 820CD4F0h case    0:*/		regs.R12 = regs.LR;
		/* 820CD4F0h case    0:*/		return 0x820CD4F4;
		  /* 820CD4F4h */ case    1:  		/* bl -246432 */
		/* 820CD4F4h case    1:*/		regs.LR = 0x820CD4F8; return 0x82091254;
		/* 820CD4F4h case    1:*/		return 0x820CD4F8;
		  /* 820CD4F8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820CD4F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820CD4F8h case    2:*/		return 0x820CD4FC;
		  /* 820CD4FCh */ case    3:  		/* li R11, 5 */
		/* 820CD4FCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CD4FCh case    3:*/		return 0x820CD500;
	}
	return 0x820CD500;
} // Block from 820CD4F0h-820CD500h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CD500h
// Function '?IsEqual@CNodeRegister@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD500);
		  /* 820CD500h */ case    0:  		/* addi R10, R1, 104 */
		/* 820CD500h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 820CD500h case    0:*/		return 0x820CD504;
		  /* 820CD504h */ case    1:  		/* mr R29, R3 */
		/* 820CD504h case    1:*/		regs.R29 = regs.R3;
		/* 820CD504h case    1:*/		return 0x820CD508;
		  /* 820CD508h */ case    2:  		/* mr R27, R4 */
		/* 820CD508h case    2:*/		regs.R27 = regs.R4;
		/* 820CD508h case    2:*/		return 0x820CD50C;
		  /* 820CD50Ch */ case    3:  		/* mr R31, R5 */
		/* 820CD50Ch case    3:*/		regs.R31 = regs.R5;
		/* 820CD50Ch case    3:*/		return 0x820CD510;
		  /* 820CD510h */ case    4:  		/* mr R28, R6 */
		/* 820CD510h case    4:*/		regs.R28 = regs.R6;
		/* 820CD510h case    4:*/		return 0x820CD514;
		  /* 820CD514h */ case    5:  		/* mtspr CTR, R11 */
		/* 820CD514h case    5:*/		regs.CTR = regs.R11;
		/* 820CD514h case    5:*/		return 0x820CD518;
		  /* 820CD518h */ case    6:  		/* addi R9, R4, -8 */
		/* 820CD518h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0xFFFFFFF8);
		/* 820CD518h case    6:*/		return 0x820CD51C;
		  /* 820CD51Ch */ case    7:  		/* ldu R11, <#[R9 + 8]> */
		/* 820CD51Ch case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CD51Ch case    7:*/		return 0x820CD520;
		  /* 820CD520h */ case    8:  		/* stdu R11, <#[R10 + 8]> */
		/* 820CD520h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CD520h case    8:*/		return 0x820CD524;
		  /* 820CD524h */ case    9:  		/* bc 16, CR0_LT, -8 */
		/* 820CD524h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CD51C;  }
		/* 820CD524h case    9:*/		return 0x820CD528;
		  /* 820CD528h */ case   10:  		/* addi R7, R31, 2 */
		/* 820CD528h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x2);
		/* 820CD528h case   10:*/		return 0x820CD52C;
		  /* 820CD52Ch */ case   11:  		/* lwz R8, <#[R29 + 4]> */
		/* 820CD52Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000004) );
		/* 820CD52Ch case   11:*/		return 0x820CD530;
		  /* 820CD530h */ case   12:  		/* li R11, 12 */
		/* 820CD530h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820CD530h case   12:*/		return 0x820CD534;
		  /* 820CD534h */ case   13:  		/* lwz R3, <#[R29]> */
		/* 820CD534h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820CD534h case   13:*/		return 0x820CD538;
		  /* 820CD538h */ case   14:  		/* stw R7, <#[R1 + 120]> */
		/* 820CD538h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000078) );
		/* 820CD538h case   14:*/		return 0x820CD53C;
		  /* 820CD53Ch */ case   15:  		/* li R30, 0 */
		/* 820CD53Ch case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CD53Ch case   15:*/		return 0x820CD540;
		  /* 820CD540h */ case   16:  		/* addi R10, R1, 96 */
		/* 820CD540h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 820CD540h case   16:*/		return 0x820CD544;
		  /* 820CD544h */ case   17:  		/* stw R11, <#[R1 + 112]> */
		/* 820CD544h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820CD544h case   17:*/		return 0x820CD548;
		  /* 820CD548h */ case   18:  		/* li R9, 2 */
		/* 820CD548h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 820CD548h case   18:*/		return 0x820CD54C;
		  /* 820CD54Ch */ case   19:  		/* stw R30, <#[R1 + 84]> */
		/* 820CD54Ch case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820CD54Ch case   19:*/		return 0x820CD550;
		  /* 820CD550h */ case   20:  		/* li R7, 0 */
		/* 820CD550h case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820CD550h case   20:*/		return 0x820CD554;
		  /* 820CD554h */ case   21:  		/* li R6, 0 */
		/* 820CD554h case   21:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820CD554h case   21:*/		return 0x820CD558;
		  /* 820CD558h */ case   22:  		/* addi R5, R1, 112 */
		/* 820CD558h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820CD558h case   22:*/		return 0x820CD55C;
		  /* 820CD55Ch */ case   23:  		/* li R4, 1 */
		/* 820CD55Ch case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820CD55Ch case   23:*/		return 0x820CD560;
		  /* 820CD560h */ case   24:  		/* bl 338680 */
		/* 820CD560h case   24:*/		regs.LR = 0x820CD564; return 0x82120058;
		/* 820CD560h case   24:*/		return 0x820CD564;
		  /* 820CD564h */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 820CD564h case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CD564h case   25:*/		return 0x820CD568;
		  /* 820CD568h */ case   26:  		/* bc 12, CR0_EQ, 20 */
		/* 820CD568h case   26:*/		if ( regs.CR[0].eq ) { return 0x820CD57C;  }
		/* 820CD568h case   26:*/		return 0x820CD56C;
		  /* 820CD56Ch */ case   27:  		/* stw R30, <#[R28]> */
		/* 820CD56Ch case   27:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 820CD56Ch case   27:*/		return 0x820CD570;
		  /* 820CD570h */ case   28:  		/* li R3, 0 */
		/* 820CD570h case   28:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD570h case   28:*/		return 0x820CD574;
		  /* 820CD574h */ case   29:  		/* addi R1, R1, 208 */
		/* 820CD574h case   29:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820CD574h case   29:*/		return 0x820CD578;
		  /* 820CD578h */ case   30:  		/* b -246484 */
		/* 820CD578h case   30:*/		return 0x820912A4;
		/* 820CD578h case   30:*/		return 0x820CD57C;
	}
	return 0x820CD57C;
} // Block from 820CD500h-820CD57Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 820CD57Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD57C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD57C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD57C);
		  /* 820CD57Ch */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CD57Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CD57Ch case    0:*/		return 0x820CD580;
		  /* 820CD580h */ case    1:  		/* li R5, 0 */
		/* 820CD580h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820CD580h case    1:*/		return 0x820CD584;
		  /* 820CD584h */ case    2:  		/* mr R4, R28 */
		/* 820CD584h case    2:*/		regs.R4 = regs.R28;
		/* 820CD584h case    2:*/		return 0x820CD588;
		  /* 820CD588h */ case    3:  		/* lwz R3, <#[R11 + 48]> */
		/* 820CD588h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 820CD588h case    3:*/		return 0x820CD58C;
		  /* 820CD58Ch */ case    4:  		/* bl -468 */
		/* 820CD58Ch case    4:*/		regs.LR = 0x820CD590; return 0x820CD3B8;
		/* 820CD58Ch case    4:*/		return 0x820CD590;
		  /* 820CD590h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820CD590h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CD590h case    5:*/		return 0x820CD594;
		  /* 820CD594h */ case    6:  		/* bc 12, CR0_LT, -32 */
		/* 820CD594h case    6:*/		if ( regs.CR[0].lt ) { return 0x820CD574;  }
		/* 820CD594h case    6:*/		return 0x820CD598;
		  /* 820CD598h */ case    7:  		/* lis R10, -32255 */
		/* 820CD598h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CD598h case    7:*/		return 0x820CD59C;
		  /* 820CD59Ch */ case    8:  		/* mr R11, R31 */
		/* 820CD59Ch case    8:*/		regs.R11 = regs.R31;
		/* 820CD59Ch case    8:*/		return 0x820CD5A0;
		  /* 820CD5A0h */ case    9:  		/* addi R10, R10, 2908 */
		/* 820CD5A0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xB5C);
		/* 820CD5A0h case    9:*/		return 0x820CD5A4;
		  /* 820CD5A4h */ case   10:  		/* addi R8, R31, 2 */
		/* 820CD5A4h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x2);
		/* 820CD5A4h case   10:*/		return 0x820CD5A8;
		  /* 820CD5A8h */ case   11:  		/* lbz R9, <#[R11]> */
		/* 820CD5A8h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD5A8h case   11:*/		return 0x820CD5AC;
		  /* 820CD5ACh */ case   12:  		/* lbz R7, <#[R10]> */
		/* 820CD5ACh case   12:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD5ACh case   12:*/		return 0x820CD5B0;
		  /* 820CD5B0h */ case   13:  		/* subf. R9, R7, R9 */
		/* 820CD5B0h case   13:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CD5B0h case   13:*/		return 0x820CD5B4;
		  /* 820CD5B4h */ case   14:  		/* bc 4, CR0_EQ, 20 */
		/* 820CD5B4h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820CD5C8;  }
		/* 820CD5B4h case   14:*/		return 0x820CD5B8;
		  /* 820CD5B8h */ case   15:  		/* addi R11, R11, 1 */
		/* 820CD5B8h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD5B8h case   15:*/		return 0x820CD5BC;
		  /* 820CD5BCh */ case   16:  		/* addi R10, R10, 1 */
		/* 820CD5BCh case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CD5BCh case   16:*/		return 0x820CD5C0;
		  /* 820CD5C0h */ case   17:  		/* cmpw CR6, R11, R8 */
		/* 820CD5C0h case   17:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CD5C0h case   17:*/		return 0x820CD5C4;
		  /* 820CD5C4h */ case   18:  		/* bc 4, CR6_EQ, -28 */
		/* 820CD5C4h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820CD5A8;  }
		/* 820CD5C4h case   18:*/		return 0x820CD5C8;
	}
	return 0x820CD5C8;
} // Block from 820CD57Ch-820CD5C8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CD5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD5C8);
		  /* 820CD5C8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CD5C8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CD5C8h case    0:*/		return 0x820CD5CC;
		  /* 820CD5CCh */ case    1:  		/* bc 4, CR0_EQ, 108 */
		/* 820CD5CCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CD638;  }
		/* 820CD5CCh case    1:*/		return 0x820CD5D0;
		  /* 820CD5D0h */ case    2:  		/* lwz R11, <#[R28]> */
		/* 820CD5D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820CD5D0h case    2:*/		return 0x820CD5D4;
		  /* 820CD5D4h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 820CD5D4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820CD5D4h case    3:*/		return 0x820CD5D8;
		  /* 820CD5D8h */ case    4:  		/* bc 4, CR6_EQ, 48 */
		/* 820CD5D8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CD608;  }
		/* 820CD5D8h case    4:*/		return 0x820CD5DC;
		  /* 820CD5DCh */ case    5:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CD5DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CD5DCh case    5:*/		return 0x820CD5E0;
		  /* 820CD5E0h */ case    6:  		/* lwz R11, <#[R11 + 48]> */
		/* 820CD5E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 820CD5E0h case    6:*/		return 0x820CD5E4;
		  /* 820CD5E4h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 820CD5E4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820CD5E4h case    7:*/		return 0x820CD5E8;
		  /* 820CD5E8h */ case    8:  		/* cmpwi CR6, R10, 9 */
		/* 820CD5E8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 820CD5E8h case    8:*/		return 0x820CD5EC;
		  /* 820CD5ECh */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 820CD5ECh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820CD608;  }
		/* 820CD5ECh case    9:*/		return 0x820CD5F0;
		  /* 820CD5F0h */ case   10:  		/* lwz R10, <#[R11 + 16]> */
		/* 820CD5F0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820CD5F0h case   10:*/		return 0x820CD5F4;
		  /* 820CD5F4h */ case   11:  		/* cmpwi CR6, R10, 0 */
		/* 820CD5F4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820CD5F4h case   11:*/		return 0x820CD5F8;
		  /* 820CD5F8h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 820CD5F8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CD608;  }
		/* 820CD5F8h case   12:*/		return 0x820CD5FC;
		  /* 820CD5FCh */ case   13:  		/* lwz R11, <#[R11 + 20]> */
		/* 820CD5FCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820CD5FCh case   13:*/		return 0x820CD600;
		  /* 820CD600h */ case   14:  		/* cmpwi CR6, R11, 0 */
		/* 820CD600h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CD600h case   14:*/		return 0x820CD604;
		  /* 820CD604h */ case   15:  		/* bc 12, CR6_EQ, -148 */
		/* 820CD604h case   15:*/		if ( regs.CR[6].eq ) { return 0x820CD570;  }
		/* 820CD604h case   15:*/		return 0x820CD608;
	}
	return 0x820CD608;
} // Block from 820CD5C8h-820CD608h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CD608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD608);
		  /* 820CD608h */ case    0:  		/* lis R10, -32255 */
		/* 820CD608h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CD608h case    0:*/		return 0x820CD60C;
		  /* 820CD60Ch */ case    1:  		/* li R5, 2900 */
		/* 820CD60Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xB54);
		/* 820CD60Ch case    1:*/		return 0x820CD610;
	}
	return 0x820CD610;
} // Block from 820CD608h-820CD610h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD610h
// Function '?Copy@CNodeRegister@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD610);
		  /* 820CD610h */ case    0:  		/* addi R6, R10, 11288 */
		/* 820CD610h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x2C18);
		/* 820CD610h case    0:*/		return 0x820CD614;
		  /* 820CD614h */ case    1:  		/* lwz R11, <#[R29]> */
		/* 820CD614h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820CD614h case    1:*/		return 0x820CD618;
		  /* 820CD618h */ case    2:  		/* mr R7, R31 */
		/* 820CD618h case    2:*/		regs.R7 = regs.R31;
		/* 820CD618h case    2:*/		return 0x820CD61C;
		  /* 820CD61Ch */ case    3:  		/* mr R4, R27 */
		/* 820CD61Ch case    3:*/		regs.R4 = regs.R27;
		/* 820CD61Ch case    3:*/		return 0x820CD620;
		  /* 820CD620h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CD620h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CD620h case    4:*/		return 0x820CD624;
		  /* 820CD624h */ case    5:  		/* addi R3, R11, 24 */
		/* 820CD624h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820CD624h case    5:*/		return 0x820CD628;
		  /* 820CD628h */ case    6:  		/* bl -156824 */
		/* 820CD628h case    6:*/		regs.LR = 0x820CD62C; return 0x820A7190;
		/* 820CD628h case    6:*/		return 0x820CD62C;
		  /* 820CD62Ch */ case    7:  		/* lis R3, -32768 */
		/* 820CD62Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CD62Ch case    7:*/		return 0x820CD630;
		  /* 820CD630h */ case    8:  		/* ori R3, R3, 16389 */
		/* 820CD630h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CD630h case    8:*/		return 0x820CD634;
		  /* 820CD634h */ case    9:  		/* b -192 */
		/* 820CD634h case    9:*/		return 0x820CD574;
		/* 820CD634h case    9:*/		return 0x820CD638;
	}
	return 0x820CD638;
} // Block from 820CD610h-820CD638h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CD638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD638);
		  /* 820CD638h */ case    0:  		/* lis R10, -32255 */
		/* 820CD638h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CD638h case    0:*/		return 0x820CD63C;
		  /* 820CD63Ch */ case    1:  		/* mr R11, R31 */
		/* 820CD63Ch case    1:*/		regs.R11 = regs.R31;
		/* 820CD63Ch case    1:*/		return 0x820CD640;
		  /* 820CD640h */ case    2:  		/* addi R10, R10, 2912 */
		/* 820CD640h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xB60);
		/* 820CD640h case    2:*/		return 0x820CD644;
		  /* 820CD644h */ case    3:  		/* addi R8, R31, 2 */
		/* 820CD644h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x2);
		/* 820CD644h case    3:*/		return 0x820CD648;
		  /* 820CD648h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820CD648h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD648h case    4:*/		return 0x820CD64C;
		  /* 820CD64Ch */ case    5:  		/* lbz R7, <#[R10]> */
		/* 820CD64Ch case    5:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD64Ch case    5:*/		return 0x820CD650;
		  /* 820CD650h */ case    6:  		/* subf. R9, R7, R9 */
		/* 820CD650h case    6:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CD650h case    6:*/		return 0x820CD654;
		  /* 820CD654h */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 820CD654h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820CD668;  }
		/* 820CD654h case    7:*/		return 0x820CD658;
		  /* 820CD658h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CD658h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD658h case    8:*/		return 0x820CD65C;
		  /* 820CD65Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820CD65Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CD65Ch case    9:*/		return 0x820CD660;
		  /* 820CD660h */ case   10:  		/* cmpw CR6, R11, R8 */
		/* 820CD660h case   10:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CD660h case   10:*/		return 0x820CD664;
		  /* 820CD664h */ case   11:  		/* bc 4, CR6_EQ, -28 */
		/* 820CD664h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820CD648;  }
		/* 820CD664h case   11:*/		return 0x820CD668;
	}
	return 0x820CD668;
} // Block from 820CD638h-820CD668h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CD668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD668);
		  /* 820CD668h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CD668h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CD668h case    0:*/		return 0x820CD66C;
		  /* 820CD66Ch */ case    1:  		/* bc 4, CR0_EQ, -252 */
		/* 820CD66Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CD570;  }
		/* 820CD66Ch case    1:*/		return 0x820CD670;
		  /* 820CD670h */ case    2:  		/* lwz R11, <#[R28]> */
		/* 820CD670h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820CD670h case    2:*/		return 0x820CD674;
		  /* 820CD674h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 820CD674h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820CD674h case    3:*/		return 0x820CD678;
		  /* 820CD678h */ case    4:  		/* bc 4, CR6_EQ, 60 */
		/* 820CD678h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CD6B4;  }
		/* 820CD678h case    4:*/		return 0x820CD67C;
		  /* 820CD67Ch */ case    5:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CD67Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CD67Ch case    5:*/		return 0x820CD680;
		  /* 820CD680h */ case    6:  		/* lwz R11, <#[R11 + 48]> */
		/* 820CD680h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 820CD680h case    6:*/		return 0x820CD684;
		  /* 820CD684h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 820CD684h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820CD684h case    7:*/		return 0x820CD688;
		  /* 820CD688h */ case    8:  		/* cmpwi CR6, R10, 9 */
		/* 820CD688h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 820CD688h case    8:*/		return 0x820CD68C;
		  /* 820CD68Ch */ case    9:  		/* bc 4, CR6_EQ, 40 */
		/* 820CD68Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820CD6B4;  }
		/* 820CD68Ch case    9:*/		return 0x820CD690;
		  /* 820CD690h */ case   10:  		/* lwz R10, <#[R11 + 16]> */
		/* 820CD690h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820CD690h case   10:*/		return 0x820CD694;
		  /* 820CD694h */ case   11:  		/* cmpwi CR6, R10, 1 */
		/* 820CD694h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820CD694h case   11:*/		return 0x820CD698;
		  /* 820CD698h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 820CD698h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CD6B4;  }
		/* 820CD698h case   12:*/		return 0x820CD69C;
		  /* 820CD69Ch */ case   13:  		/* lwz R10, <#[R11 + 20]> */
		/* 820CD69Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820CD69Ch case   13:*/		return 0x820CD6A0;
		  /* 820CD6A0h */ case   14:  		/* cmpwi CR6, R10, 5 */
		/* 820CD6A0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000005);
		/* 820CD6A0h case   14:*/		return 0x820CD6A4;
		  /* 820CD6A4h */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 820CD6A4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820CD6B4;  }
		/* 820CD6A4h case   15:*/		return 0x820CD6A8;
		  /* 820CD6A8h */ case   16:  		/* lwz R11, <#[R11 + 32]> */
		/* 820CD6A8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820CD6A8h case   16:*/		return 0x820CD6AC;
		  /* 820CD6ACh */ case   17:  		/* cmplwi CR6, R11, 3 */
		/* 820CD6ACh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820CD6ACh case   17:*/		return 0x820CD6B0;
		  /* 820CD6B0h */ case   18:  		/* bc 4, CR6_LT, -320 */
		/* 820CD6B0h case   18:*/		if ( !regs.CR[6].lt ) { return 0x820CD570;  }
		/* 820CD6B0h case   18:*/		return 0x820CD6B4;
	}
	return 0x820CD6B4;
} // Block from 820CD668h-820CD6B4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CD6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD6B4);
		  /* 820CD6B4h */ case    0:  		/* lis R10, -32255 */
		/* 820CD6B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CD6B4h case    0:*/		return 0x820CD6B8;
		  /* 820CD6B8h */ case    1:  		/* li R5, 2901 */
		/* 820CD6B8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xB55);
		/* 820CD6B8h case    1:*/		return 0x820CD6BC;
		  /* 820CD6BCh */ case    2:  		/* addi R6, R10, 11200 */
		/* 820CD6BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x2BC0);
		/* 820CD6BCh case    2:*/		return 0x820CD6C0;
		  /* 820CD6C0h */ case    3:  		/* b -172 */
		/* 820CD6C0h case    3:*/		return 0x820CD614;
		/* 820CD6C0h case    3:*/		return 0x820CD6C4;
		  /* 820CD6C4h */ case    4:  		/* nop */
		/* 820CD6C4h case    4:*/		cpu::op::nop();
		/* 820CD6C4h case    4:*/		return 0x820CD6C8;
	}
	return 0x820CD6C8;
} // Block from 820CD6B4h-820CD6C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CD6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD6C8);
		  /* 820CD6C8h */ case    0:  		/* mfspr R12, LR */
		/* 820CD6C8h case    0:*/		regs.R12 = regs.LR;
		/* 820CD6C8h case    0:*/		return 0x820CD6CC;
		  /* 820CD6CCh */ case    1:  		/* bl -246912 */
		/* 820CD6CCh case    1:*/		regs.LR = 0x820CD6D0; return 0x8209124C;
		/* 820CD6CCh case    1:*/		return 0x820CD6D0;
		  /* 820CD6D0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820CD6D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820CD6D0h case    2:*/		return 0x820CD6D4;
		  /* 820CD6D4h */ case    3:  		/* lwz R11, <#[R6 + 4]> */
		/* 820CD6D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 820CD6D4h case    3:*/		return 0x820CD6D8;
		  /* 820CD6D8h */ case    4:  		/* mr R26, R3 */
		/* 820CD6D8h case    4:*/		regs.R26 = regs.R3;
		/* 820CD6D8h case    4:*/		return 0x820CD6DC;
		  /* 820CD6DCh */ case    5:  		/* mr R29, R4 */
		/* 820CD6DCh case    5:*/		regs.R29 = regs.R4;
		/* 820CD6DCh case    5:*/		return 0x820CD6E0;
		  /* 820CD6E0h */ case    6:  		/* mr R28, R5 */
		/* 820CD6E0h case    6:*/		regs.R28 = regs.R5;
		/* 820CD6E0h case    6:*/		return 0x820CD6E4;
		  /* 820CD6E4h */ case    7:  		/* mr R25, R7 */
		/* 820CD6E4h case    7:*/		regs.R25 = regs.R7;
		/* 820CD6E4h case    7:*/		return 0x820CD6E8;
		  /* 820CD6E8h */ case    8:  		/* li R30, 0 */
		/* 820CD6E8h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CD6E8h case    8:*/		return 0x820CD6EC;
		  /* 820CD6ECh */ case    9:  		/* li R31, 0 */
		/* 820CD6ECh case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CD6ECh case    9:*/		return 0x820CD6F0;
		  /* 820CD6F0h */ case   10:  		/* cmpwi CR6, R11, 14 */
		/* 820CD6F0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 820CD6F0h case   10:*/		return 0x820CD6F4;
		  /* 820CD6F4h */ case   11:  		/* bc 4, CR6_EQ, 256 */
		/* 820CD6F4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820CD7F4;  }
		/* 820CD6F4h case   11:*/		return 0x820CD6F8;
		  /* 820CD6F8h */ case   12:  		/* lwz R27, <#[R6 + 32]> */
		/* 820CD6F8h case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R6 + 0x00000020) );
		/* 820CD6F8h case   12:*/		return 0x820CD6FC;
		  /* 820CD6FCh */ case   13:  		/* lwz R11, <#[R27 + 4]> */
		/* 820CD6FCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 820CD6FCh case   13:*/		return 0x820CD700;
		  /* 820CD700h */ case   14:  		/* cmpwi CR6, R11, 1 */
		/* 820CD700h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820CD700h case   14:*/		return 0x820CD704;
		  /* 820CD704h */ case   15:  		/* bc 4, CR6_EQ, 224 */
		/* 820CD704h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820CD7E4;  }
		/* 820CD704h case   15:*/		return 0x820CD708;
		  /* 820CD708h */ case   16:  		/* lis R10, 16383 */
		/* 820CD708h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0x3FFF);
		/* 820CD708h case   16:*/		return 0x820CD70C;
		  /* 820CD70Ch */ case   17:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820CD70Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820CD70Ch case   17:*/		return 0x820CD710;
		  /* 820CD710h */ case   18:  		/* ori R10, R10, 65535 */
		/* 820CD710h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 820CD710h case   18:*/		return 0x820CD714;
		  /* 820CD714h */ case   19:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820CD714h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820CD714h case   19:*/		return 0x820CD718;
		  /* 820CD718h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 820CD718h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CD718h case   20:*/		return 0x820CD71C;
		  /* 820CD71Ch */ case   21:  		/* bc 4, CR6_GT, 8 */
		/* 820CD71Ch case   21:*/		if ( !regs.CR[6].gt ) { return 0x820CD724;  }
		/* 820CD71Ch case   21:*/		return 0x820CD720;
		  /* 820CD720h */ case   22:  		/* li R3, -1 */
		/* 820CD720h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820CD720h case   22:*/		return 0x820CD724;
	}
	return 0x820CD724;
} // Block from 820CD6C8h-820CD724h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820CD724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD724);
		  /* 820CD724h */ case    0:  		/* bl -237532 */
		/* 820CD724h case    0:*/		regs.LR = 0x820CD728; return 0x82093748;
		/* 820CD724h case    0:*/		return 0x820CD728;
		  /* 820CD728h */ case    1:  		/* or. R31, R3, R3 */
		/* 820CD728h case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820CD728h case    1:*/		return 0x820CD72C;
		  /* 820CD72Ch */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820CD72Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820CD73C;  }
		/* 820CD72Ch case    2:*/		return 0x820CD730;
		  /* 820CD730h */ case    3:  		/* lis R30, -32761 */
		/* 820CD730h case    3:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820CD730h case    3:*/		return 0x820CD734;
		  /* 820CD734h */ case    4:  		/* ori R30, R30, 14 */
		/* 820CD734h case    4:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820CD734h case    4:*/		return 0x820CD738;
		  /* 820CD738h */ case    5:  		/* b 172 */
		/* 820CD738h case    5:*/		return 0x820CD7E4;
		/* 820CD738h case    5:*/		return 0x820CD73C;
	}
	return 0x820CD73C;
} // Block from 820CD724h-820CD73Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CD73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD73C);
		  /* 820CD73Ch */ case    0:  		/* rlwinm R30, R29, 4, 0, 27 */
		/* 820CD73Ch case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R30,regs.R29);
		/* 820CD73Ch case    0:*/		return 0x820CD740;
	}
	return 0x820CD740;
} // Block from 820CD73Ch-820CD740h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD740h
// Function '??0CNodeFormat@D3DXShader@@QAA@PAVCNode@1@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD740);
		  /* 820CD740h */ case    0:  		/* li R4, 0 */
		/* 820CD740h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CD740h case    0:*/		return 0x820CD744;
		  /* 820CD744h */ case    1:  		/* mr R5, R30 */
		/* 820CD744h case    1:*/		regs.R5 = regs.R30;
		/* 820CD744h case    1:*/		return 0x820CD748;
		  /* 820CD748h */ case    2:  		/* mr R3, R31 */
		/* 820CD748h case    2:*/		regs.R3 = regs.R31;
		/* 820CD748h case    2:*/		return 0x820CD74C;
		  /* 820CD74Ch */ case    3:  		/* bl -246796 */
		/* 820CD74Ch case    3:*/		regs.LR = 0x820CD750; return 0x82091340;
		/* 820CD74Ch case    3:*/		return 0x820CD750;
		  /* 820CD750h */ case    4:  		/* li R7, 0 */
		/* 820CD750h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820CD750h case    4:*/		return 0x820CD754;
		  /* 820CD754h */ case    5:  		/* cmplwi CR6, R29, 0 */
		/* 820CD754h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820CD754h case    5:*/		return 0x820CD758;
		  /* 820CD758h */ case    6:  		/* bc 12, CR6_EQ, 108 */
		/* 820CD758h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CD7C4;  }
		/* 820CD758h case    6:*/		return 0x820CD75C;
		  /* 820CD75Ch */ case    7:  		/* li R10, 0 */
		/* 820CD75Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CD75Ch case    7:*/		return 0x820CD760;
		  /* 820CD760h */ case    8:  		/* cmplwi CR6, R28, 0 */
		/* 820CD760h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820CD760h case    8:*/		return 0x820CD764;
		  /* 820CD764h */ case    9:  		/* bc 12, CR6_EQ, 84 */
		/* 820CD764h case    9:*/		if ( regs.CR[6].eq ) { return 0x820CD7B8;  }
		/* 820CD764h case    9:*/		return 0x820CD768;
		  /* 820CD768h */ case   10:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 820CD768h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 820CD768h case   10:*/		return 0x820CD76C;
		  /* 820CD76Ch */ case   11:  		/* mtspr CTR, R28 */
		/* 820CD76Ch case   11:*/		regs.CTR = regs.R28;
		/* 820CD76Ch case   11:*/		return 0x820CD770;
	}
	return 0x820CD770;
} // Block from 820CD740h-820CD770h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CD770h
// Function '?Copy@CNodeFormat@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD770);
		  /* 820CD770h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 820CD770h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820CD770h case    0:*/		return 0x820CD774;
		  /* 820CD774h */ case    1:  		/* lwz R8, <#[R11 + 16]> */
		/* 820CD774h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 820CD774h case    1:*/		return 0x820CD778;
		  /* 820CD778h */ case    2:  		/* cmpwi CR6, R8, 3 */
		/* 820CD778h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000003);
		/* 820CD778h case    2:*/		return 0x820CD77C;
		  /* 820CD77Ch */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 820CD77Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820CD798;  }
		/* 820CD77Ch case    3:*/		return 0x820CD780;
		  /* 820CD780h */ case    4:  		/* add R8, R9, R10 */
		/* 820CD780h case    4:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R10);
		/* 820CD780h case    4:*/		return 0x820CD784;
		  /* 820CD784h */ case    5:  		/* lfd FR0, <#[R11 + 24]> */
		/* 820CD784h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000018) );
		/* 820CD784h case    5:*/		return 0x820CD788;
		  /* 820CD788h */ case    6:  		/* frsp FR0, FR0 */
		/* 820CD788h case    6:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820CD788h case    6:*/		return 0x820CD78C;
		  /* 820CD78Ch */ case    7:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820CD78Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820CD78Ch case    7:*/		return 0x820CD790;
		  /* 820CD790h */ case    8:  		/* stfsx FR0, <#[R11 + R31]> */
		/* 820CD790h case    8:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820CD790h case    8:*/		return 0x820CD794;
		  /* 820CD794h */ case    9:  		/* b 24 */
		/* 820CD794h case    9:*/		return 0x820CD7AC;
		/* 820CD794h case    9:*/		return 0x820CD798;
	}
	return 0x820CD798;
} // Block from 820CD770h-820CD798h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CD798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD798);
		  /* 820CD798h */ case    0:  		/* cmpwi CR6, R8, 1 */
		/* 820CD798h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820CD798h case    0:*/		return 0x820CD79C;
		  /* 820CD79Ch */ case    1:  		/* lwz R11, <#[R11 + 24]> */
		/* 820CD79Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820CD79Ch case    1:*/		return 0x820CD7A0;
		  /* 820CD7A0h */ case    2:  		/* add R8, R9, R10 */
		/* 820CD7A0h case    2:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R10);
		/* 820CD7A0h case    2:*/		return 0x820CD7A4;
		  /* 820CD7A4h */ case    3:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820CD7A4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820CD7A4h case    3:*/		return 0x820CD7A8;
		  /* 820CD7A8h */ case    4:  		/* stwx R11, <#[R8 + R31]> */
		/* 820CD7A8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R31 + 0x00000000) );
		/* 820CD7A8h case    4:*/		return 0x820CD7AC;
	}
	return 0x820CD7AC;
} // Block from 820CD798h-820CD7ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CD7ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD7AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD7AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD7AC);
		  /* 820CD7ACh */ case    0:  		/* lwz R27, <#[R27 + 12]> */
		/* 820CD7ACh case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x0000000C) );
		/* 820CD7ACh case    0:*/		return 0x820CD7B0;
		  /* 820CD7B0h */ case    1:  		/* addi R10, R10, 1 */
		/* 820CD7B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CD7B0h case    1:*/		return 0x820CD7B4;
		  /* 820CD7B4h */ case    2:  		/* bc 16, CR0_LT, -68 */
		/* 820CD7B4h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CD770;  }
		/* 820CD7B4h case    2:*/		return 0x820CD7B8;
	}
	return 0x820CD7B8;
} // Block from 820CD7ACh-820CD7B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CD7B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD7B8);
		  /* 820CD7B8h */ case    0:  		/* addi R7, R7, 1 */
		/* 820CD7B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820CD7B8h case    0:*/		return 0x820CD7BC;
		  /* 820CD7BCh */ case    1:  		/* cmplw CR6, R7, R29 */
		/* 820CD7BCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R29);
		/* 820CD7BCh case    1:*/		return 0x820CD7C0;
		  /* 820CD7C0h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820CD7C0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820CD75C;  }
		/* 820CD7C0h case    2:*/		return 0x820CD7C4;
	}
	return 0x820CD7C4;
} // Block from 820CD7B8h-820CD7C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CD7C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD7C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD7C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD7C4);
		  /* 820CD7C4h */ case    0:  		/* li R8, 0 */
		/* 820CD7C4h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820CD7C4h case    0:*/		return 0x820CD7C8;
		  /* 820CD7C8h */ case    1:  		/* mr R7, R25 */
		/* 820CD7C8h case    1:*/		regs.R7 = regs.R25;
		/* 820CD7C8h case    1:*/		return 0x820CD7CC;
		  /* 820CD7CCh */ case    2:  		/* li R6, 6 */
		/* 820CD7CCh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 820CD7CCh case    2:*/		return 0x820CD7D0;
		  /* 820CD7D0h */ case    3:  		/* mr R5, R30 */
		/* 820CD7D0h case    3:*/		regs.R5 = regs.R30;
		/* 820CD7D0h case    3:*/		return 0x820CD7D4;
		  /* 820CD7D4h */ case    4:  		/* mr R4, R31 */
		/* 820CD7D4h case    4:*/		regs.R4 = regs.R31;
		/* 820CD7D4h case    4:*/		return 0x820CD7D8;
		  /* 820CD7D8h */ case    5:  		/* mr R3, R26 */
		/* 820CD7D8h case    5:*/		regs.R3 = regs.R26;
		/* 820CD7D8h case    5:*/		return 0x820CD7DC;
		  /* 820CD7DCh */ case    6:  		/* bl 2708 */
		/* 820CD7DCh case    6:*/		regs.LR = 0x820CD7E0; return 0x820CE270;
		/* 820CD7DCh case    6:*/		return 0x820CD7E0;
		  /* 820CD7E0h */ case    7:  		/* mr R30, R3 */
		/* 820CD7E0h case    7:*/		regs.R30 = regs.R3;
		/* 820CD7E0h case    7:*/		return 0x820CD7E4;
	}
	return 0x820CD7E4;
} // Block from 820CD7C4h-820CD7E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CD7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD7E4);
		  /* 820CD7E4h */ case    0:  		/* mr R3, R31 */
		/* 820CD7E4h case    0:*/		regs.R3 = regs.R31;
		/* 820CD7E4h case    0:*/		return 0x820CD7E8;
		  /* 820CD7E8h */ case    1:  		/* bl -242816 */
		/* 820CD7E8h case    1:*/		regs.LR = 0x820CD7EC; return 0x82092368;
		/* 820CD7E8h case    1:*/		return 0x820CD7EC;
		  /* 820CD7ECh */ case    2:  		/* mr R3, R30 */
		/* 820CD7ECh case    2:*/		regs.R3 = regs.R30;
		/* 820CD7ECh case    2:*/		return 0x820CD7F0;
		  /* 820CD7F0h */ case    3:  		/* b 8 */
		/* 820CD7F0h case    3:*/		return 0x820CD7F8;
		/* 820CD7F0h case    3:*/		return 0x820CD7F4;
	}
	return 0x820CD7F4;
} // Block from 820CD7E4h-820CD7F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CD7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD7F4);
		  /* 820CD7F4h */ case    0:  		/* li R3, 0 */
		/* 820CD7F4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CD7F4h case    0:*/		return 0x820CD7F8;
	}
	return 0x820CD7F8;
} // Block from 820CD7F4h-820CD7F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CD7F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD7F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD7F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD7F8);
		  /* 820CD7F8h */ case    0:  		/* addi R1, R1, 144 */
		/* 820CD7F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820CD7F8h case    0:*/		return 0x820CD7FC;
		  /* 820CD7FCh */ case    1:  		/* b -247136 */
		/* 820CD7FCh case    1:*/		return 0x8209129C;
		/* 820CD7FCh case    1:*/		return 0x820CD800;
	}
	return 0x820CD800;
} // Block from 820CD7F8h-820CD800h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD800);
		  /* 820CD800h */ case    0:  		/* mfspr R12, LR */
		/* 820CD800h case    0:*/		regs.R12 = regs.LR;
		/* 820CD800h case    0:*/		return 0x820CD804;
		  /* 820CD804h */ case    1:  		/* bl -247212 */
		/* 820CD804h case    1:*/		regs.LR = 0x820CD808; return 0x82091258;
		/* 820CD804h case    1:*/		return 0x820CD808;
		  /* 820CD808h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CD808h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CD808h case    2:*/		return 0x820CD80C;
		  /* 820CD80Ch */ case    3:  		/* lis R10, 16383 */
		/* 820CD80Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x3FFF);
		/* 820CD80Ch case    3:*/		return 0x820CD810;
		  /* 820CD810h */ case    4:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 820CD810h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 820CD810h case    4:*/		return 0x820CD814;
		  /* 820CD814h */ case    5:  		/* ori R10, R10, 65535 */
		/* 820CD814h case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 820CD814h case    5:*/		return 0x820CD818;
		  /* 820CD818h */ case    6:  		/* mr R29, R3 */
		/* 820CD818h case    6:*/		regs.R29 = regs.R3;
		/* 820CD818h case    6:*/		return 0x820CD81C;
		  /* 820CD81Ch */ case    7:  		/* mr R30, R4 */
		/* 820CD81Ch case    7:*/		regs.R30 = regs.R4;
		/* 820CD81Ch case    7:*/		return 0x820CD820;
		  /* 820CD820h */ case    8:  		/* mr R28, R5 */
		/* 820CD820h case    8:*/		regs.R28 = regs.R5;
		/* 820CD820h case    8:*/		return 0x820CD824;
		  /* 820CD824h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820CD824h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CD824h case    9:*/		return 0x820CD828;
		  /* 820CD828h */ case   10:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820CD828h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820CD828h case   10:*/		return 0x820CD82C;
		  /* 820CD82Ch */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 820CD82Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x820CD834;  }
		/* 820CD82Ch case   11:*/		return 0x820CD830;
		  /* 820CD830h */ case   12:  		/* li R3, -1 */
		/* 820CD830h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820CD830h case   12:*/		return 0x820CD834;
	}
	return 0x820CD834;
} // Block from 820CD800h-820CD834h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CD834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD834);
		  /* 820CD834h */ case    0:  		/* bl -237804 */
		/* 820CD834h case    0:*/		regs.LR = 0x820CD838; return 0x82093748;
		/* 820CD834h case    0:*/		return 0x820CD838;
		  /* 820CD838h */ case    1:  		/* or. R31, R3, R3 */
		/* 820CD838h case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820CD838h case    1:*/		return 0x820CD83C;
		  /* 820CD83Ch */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820CD83Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820CD84C;  }
		/* 820CD83Ch case    2:*/		return 0x820CD840;
		  /* 820CD840h */ case    3:  		/* lis R30, -32761 */
		/* 820CD840h case    3:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820CD840h case    3:*/		return 0x820CD844;
		  /* 820CD844h */ case    4:  		/* ori R30, R30, 14 */
		/* 820CD844h case    4:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820CD844h case    4:*/		return 0x820CD848;
		  /* 820CD848h */ case    5:  		/* b 56 */
		/* 820CD848h case    5:*/		return 0x820CD880;
		/* 820CD848h case    5:*/		return 0x820CD84C;
	}
	return 0x820CD84C;
} // Block from 820CD834h-820CD84Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CD84Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD84C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD84C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD84C);
		  /* 820CD84Ch */ case    0:  		/* rlwinm R30, R30, 4, 0, 27 */
		/* 820CD84Ch case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R30,regs.R30);
		/* 820CD84Ch case    0:*/		return 0x820CD850;
		  /* 820CD850h */ case    1:  		/* li R4, 0 */
		/* 820CD850h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CD850h case    1:*/		return 0x820CD854;
		  /* 820CD854h */ case    2:  		/* mr R5, R30 */
		/* 820CD854h case    2:*/		regs.R5 = regs.R30;
		/* 820CD854h case    2:*/		return 0x820CD858;
		  /* 820CD858h */ case    3:  		/* mr R3, R31 */
		/* 820CD858h case    3:*/		regs.R3 = regs.R31;
		/* 820CD858h case    3:*/		return 0x820CD85C;
		  /* 820CD85Ch */ case    4:  		/* bl -247068 */
		/* 820CD85Ch case    4:*/		regs.LR = 0x820CD860; return 0x82091340;
		/* 820CD85Ch case    4:*/		return 0x820CD860;
		  /* 820CD860h */ case    5:  		/* li R8, 0 */
		/* 820CD860h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820CD860h case    5:*/		return 0x820CD864;
		  /* 820CD864h */ case    6:  		/* mr R7, R28 */
		/* 820CD864h case    6:*/		regs.R7 = regs.R28;
		/* 820CD864h case    6:*/		return 0x820CD868;
		  /* 820CD868h */ case    7:  		/* li R6, 6 */
		/* 820CD868h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 820CD868h case    7:*/		return 0x820CD86C;
		  /* 820CD86Ch */ case    8:  		/* mr R5, R30 */
		/* 820CD86Ch case    8:*/		regs.R5 = regs.R30;
		/* 820CD86Ch case    8:*/		return 0x820CD870;
		  /* 820CD870h */ case    9:  		/* mr R4, R31 */
		/* 820CD870h case    9:*/		regs.R4 = regs.R31;
		/* 820CD870h case    9:*/		return 0x820CD874;
		  /* 820CD874h */ case   10:  		/* mr R3, R29 */
		/* 820CD874h case   10:*/		regs.R3 = regs.R29;
		/* 820CD874h case   10:*/		return 0x820CD878;
		  /* 820CD878h */ case   11:  		/* bl 2552 */
		/* 820CD878h case   11:*/		regs.LR = 0x820CD87C; return 0x820CE270;
		/* 820CD878h case   11:*/		return 0x820CD87C;
		  /* 820CD87Ch */ case   12:  		/* mr R30, R3 */
		/* 820CD87Ch case   12:*/		regs.R30 = regs.R3;
		/* 820CD87Ch case   12:*/		return 0x820CD880;
	}
	return 0x820CD880;
} // Block from 820CD84Ch-820CD880h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CD880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD880);
		  /* 820CD880h */ case    0:  		/* mr R3, R31 */
		/* 820CD880h case    0:*/		regs.R3 = regs.R31;
		/* 820CD880h case    0:*/		return 0x820CD884;
		  /* 820CD884h */ case    1:  		/* bl -242972 */
		/* 820CD884h case    1:*/		regs.LR = 0x820CD888; return 0x82092368;
		/* 820CD884h case    1:*/		return 0x820CD888;
		  /* 820CD888h */ case    2:  		/* mr R3, R30 */
		/* 820CD888h case    2:*/		regs.R3 = regs.R30;
		/* 820CD888h case    2:*/		return 0x820CD88C;
		  /* 820CD88Ch */ case    3:  		/* addi R1, R1, 128 */
		/* 820CD88Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CD88Ch case    3:*/		return 0x820CD890;
	}
	return 0x820CD890;
} // Block from 820CD880h-820CD890h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CD890h
// Function '?Copy@CNodeTree@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD890);
		  /* 820CD890h */ case    0:  		/* b -247272 */
		/* 820CD890h case    0:*/		return 0x820912A8;
		/* 820CD890h case    0:*/		return 0x820CD894;
		  /* 820CD894h */ case    1:  		/* nop */
		/* 820CD894h case    1:*/		cpu::op::nop();
		/* 820CD894h case    1:*/		return 0x820CD898;
	}
	return 0x820CD898;
} // Block from 820CD890h-820CD898h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CD898h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD898);
		  /* 820CD898h */ case    0:  		/* mfspr R12, LR */
		/* 820CD898h case    0:*/		regs.R12 = regs.LR;
		/* 820CD898h case    0:*/		return 0x820CD89C;
		  /* 820CD89Ch */ case    1:  		/* bl -247412 */
		/* 820CD89Ch case    1:*/		regs.LR = 0x820CD8A0; return 0x82091228;
		/* 820CD89Ch case    1:*/		return 0x820CD8A0;
		  /* 820CD8A0h */ case    2:  		/* stwu R1, <#[R1 - 320]> */
		/* 820CD8A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 820CD8A0h case    2:*/		return 0x820CD8A4;
		  /* 820CD8A4h */ case    3:  		/* lis R11, -32255 */
		/* 820CD8A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CD8A4h case    3:*/		return 0x820CD8A8;
		  /* 820CD8A8h */ case    4:  		/* li R20, 0 */
		/* 820CD8A8h case    4:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 820CD8A8h case    4:*/		return 0x820CD8AC;
		  /* 820CD8ACh */ case    5:  		/* addi R11, R11, 2920 */
		/* 820CD8ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB68);
		/* 820CD8ACh case    5:*/		return 0x820CD8B0;
		  /* 820CD8B0h */ case    6:  		/* oris R24, R8, 32768 */
		/* 820CD8B0h case    6:*/		cpu::op::oris<0>(regs,&regs.R24,regs.R8,0x8000);
		/* 820CD8B0h case    6:*/		return 0x820CD8B4;
		  /* 820CD8B4h */ case    7:  		/* stw R20, <#[R1 + 96]> */
		/* 820CD8B4h case    7:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000060) );
		/* 820CD8B4h case    7:*/		return 0x820CD8B8;
		  /* 820CD8B8h */ case    8:  		/* mr R21, R3 */
		/* 820CD8B8h case    8:*/		regs.R21 = regs.R3;
		/* 820CD8B8h case    8:*/		return 0x820CD8BC;
		  /* 820CD8BCh */ case    9:  		/* mr R23, R4 */
		/* 820CD8BCh case    9:*/		regs.R23 = regs.R4;
		/* 820CD8BCh case    9:*/		return 0x820CD8C0;
		  /* 820CD8C0h */ case   10:  		/* mr R22, R5 */
		/* 820CD8C0h case   10:*/		regs.R22 = regs.R5;
		/* 820CD8C0h case   10:*/		return 0x820CD8C4;
		  /* 820CD8C4h */ case   11:  		/* mr R25, R6 */
		/* 820CD8C4h case   11:*/		regs.R25 = regs.R6;
		/* 820CD8C4h case   11:*/		return 0x820CD8C8;
		  /* 820CD8C8h */ case   12:  		/* mr R16, R7 */
		/* 820CD8C8h case   12:*/		regs.R16 = regs.R7;
		/* 820CD8C8h case   12:*/		return 0x820CD8CC;
		  /* 820CD8CCh */ case   13:  		/* mr R10, R6 */
		/* 820CD8CCh case   13:*/		regs.R10 = regs.R6;
		/* 820CD8CCh case   13:*/		return 0x820CD8D0;
		  /* 820CD8D0h */ case   14:  		/* addi R8, R11, 2 */
		/* 820CD8D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x2);
		/* 820CD8D0h case   14:*/		return 0x820CD8D4;
		  /* 820CD8D4h */ case   15:  		/* lbz R9, <#[R11]> */
		/* 820CD8D4h case   15:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD8D4h case   15:*/		return 0x820CD8D8;
		  /* 820CD8D8h */ case   16:  		/* lbz R7, <#[R10]> */
		/* 820CD8D8h case   16:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD8D8h case   16:*/		return 0x820CD8DC;
		  /* 820CD8DCh */ case   17:  		/* subf. R9, R7, R9 */
		/* 820CD8DCh case   17:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CD8DCh case   17:*/		return 0x820CD8E0;
		  /* 820CD8E0h */ case   18:  		/* bc 4, CR0_EQ, 20 */
		/* 820CD8E0h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820CD8F4;  }
		/* 820CD8E0h case   18:*/		return 0x820CD8E4;
		  /* 820CD8E4h */ case   19:  		/* addi R11, R11, 1 */
		/* 820CD8E4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD8E4h case   19:*/		return 0x820CD8E8;
		  /* 820CD8E8h */ case   20:  		/* addi R10, R10, 1 */
		/* 820CD8E8h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CD8E8h case   20:*/		return 0x820CD8EC;
		  /* 820CD8ECh */ case   21:  		/* cmpw CR6, R11, R8 */
		/* 820CD8ECh case   21:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CD8ECh case   21:*/		return 0x820CD8F0;
		  /* 820CD8F0h */ case   22:  		/* bc 4, CR6_EQ, -28 */
		/* 820CD8F0h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820CD8D4;  }
		/* 820CD8F0h case   22:*/		return 0x820CD8F4;
	}
	return 0x820CD8F4;
} // Block from 820CD898h-820CD8F4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820CD8F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD8F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD8F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD8F4);
		  /* 820CD8F4h */ case    0:  		/* lis R11, -32255 */
		/* 820CD8F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CD8F4h case    0:*/		return 0x820CD8F8;
		  /* 820CD8F8h */ case    1:  		/* lis R10, -32255 */
		/* 820CD8F8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CD8F8h case    1:*/		return 0x820CD8FC;
		  /* 820CD8FCh */ case    2:  		/* li R17, 1 */
		/* 820CD8FCh case    2:*/		cpu::op::li<0>(regs,&regs.R17,0x1);
		/* 820CD8FCh case    2:*/		return 0x820CD900;
		  /* 820CD900h */ case    3:  		/* cmpwi CR0, R9, 0 */
		/* 820CD900h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CD900h case    3:*/		return 0x820CD904;
		  /* 820CD904h */ case    4:  		/* addi R18, R11, 2912 */
		/* 820CD904h case    4:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R11,0xB60);
		/* 820CD904h case    4:*/		return 0x820CD908;
		  /* 820CD908h */ case    5:  		/* addi R19, R10, 2908 */
		/* 820CD908h case    5:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R10,0xB5C);
		/* 820CD908h case    5:*/		return 0x820CD90C;
		  /* 820CD90Ch */ case    6:  		/* bc 12, CR0_EQ, 244 */
		/* 820CD90Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820CDA00;  }
		/* 820CD90Ch case    6:*/		return 0x820CD910;
		  /* 820CD910h */ case    7:  		/* mr R11, R19 */
		/* 820CD910h case    7:*/		regs.R11 = regs.R19;
		/* 820CD910h case    7:*/		return 0x820CD914;
		  /* 820CD914h */ case    8:  		/* mr R10, R25 */
		/* 820CD914h case    8:*/		regs.R10 = regs.R25;
		/* 820CD914h case    8:*/		return 0x820CD918;
		  /* 820CD918h */ case    9:  		/* addi R8, R19, 2 */
		/* 820CD918h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R19,0x2);
		/* 820CD918h case    9:*/		return 0x820CD91C;
		  /* 820CD91Ch */ case   10:  		/* lbz R9, <#[R11]> */
		/* 820CD91Ch case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD91Ch case   10:*/		return 0x820CD920;
		  /* 820CD920h */ case   11:  		/* lbz R7, <#[R10]> */
		/* 820CD920h case   11:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD920h case   11:*/		return 0x820CD924;
		  /* 820CD924h */ case   12:  		/* subf. R9, R7, R9 */
		/* 820CD924h case   12:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CD924h case   12:*/		return 0x820CD928;
		  /* 820CD928h */ case   13:  		/* bc 4, CR0_EQ, 20 */
		/* 820CD928h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820CD93C;  }
		/* 820CD928h case   13:*/		return 0x820CD92C;
		  /* 820CD92Ch */ case   14:  		/* addi R11, R11, 1 */
		/* 820CD92Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD92Ch case   14:*/		return 0x820CD930;
		  /* 820CD930h */ case   15:  		/* addi R10, R10, 1 */
		/* 820CD930h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CD930h case   15:*/		return 0x820CD934;
		  /* 820CD934h */ case   16:  		/* cmpw CR6, R11, R8 */
		/* 820CD934h case   16:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CD934h case   16:*/		return 0x820CD938;
		  /* 820CD938h */ case   17:  		/* bc 4, CR6_EQ, -28 */
		/* 820CD938h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820CD91C;  }
		/* 820CD938h case   17:*/		return 0x820CD93C;
	}
	return 0x820CD93C;
} // Block from 820CD8F4h-820CD93Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CD93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD93C);
		  /* 820CD93Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CD93Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CD93Ch case    0:*/		return 0x820CD940;
		  /* 820CD940h */ case    1:  		/* bc 12, CR0_EQ, 192 */
		/* 820CD940h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CDA00;  }
		/* 820CD940h case    1:*/		return 0x820CD944;
		  /* 820CD944h */ case    2:  		/* mr R11, R18 */
		/* 820CD944h case    2:*/		regs.R11 = regs.R18;
		/* 820CD944h case    2:*/		return 0x820CD948;
		  /* 820CD948h */ case    3:  		/* mr R10, R25 */
		/* 820CD948h case    3:*/		regs.R10 = regs.R25;
		/* 820CD948h case    3:*/		return 0x820CD94C;
		  /* 820CD94Ch */ case    4:  		/* addi R8, R18, 2 */
		/* 820CD94Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R18,0x2);
		/* 820CD94Ch case    4:*/		return 0x820CD950;
		  /* 820CD950h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820CD950h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD950h case    5:*/		return 0x820CD954;
		  /* 820CD954h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820CD954h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD954h case    6:*/		return 0x820CD958;
		  /* 820CD958h */ case    7:  		/* subf. R9, R7, R9 */
		/* 820CD958h case    7:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CD958h case    7:*/		return 0x820CD95C;
		  /* 820CD95Ch */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 820CD95Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x820CD970;  }
		/* 820CD95Ch case    8:*/		return 0x820CD960;
		  /* 820CD960h */ case    9:  		/* addi R11, R11, 1 */
		/* 820CD960h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD960h case    9:*/		return 0x820CD964;
		  /* 820CD964h */ case   10:  		/* addi R10, R10, 1 */
		/* 820CD964h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CD964h case   10:*/		return 0x820CD968;
		  /* 820CD968h */ case   11:  		/* cmpw CR6, R11, R8 */
		/* 820CD968h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CD968h case   11:*/		return 0x820CD96C;
		  /* 820CD96Ch */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 820CD96Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CD950;  }
		/* 820CD96Ch case   12:*/		return 0x820CD970;
	}
	return 0x820CD970;
} // Block from 820CD93Ch-820CD970h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CD970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD970);
		  /* 820CD970h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CD970h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CD970h case    0:*/		return 0x820CD974;
		  /* 820CD974h */ case    1:  		/* bc 12, CR0_EQ, 140 */
		/* 820CD974h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CDA00;  }
		/* 820CD974h case    1:*/		return 0x820CD978;
		  /* 820CD978h */ case    2:  		/* lis R11, -32255 */
		/* 820CD978h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CD978h case    2:*/		return 0x820CD97C;
		  /* 820CD97Ch */ case    3:  		/* mr R10, R25 */
		/* 820CD97Ch case    3:*/		regs.R10 = regs.R25;
		/* 820CD97Ch case    3:*/		return 0x820CD980;
		  /* 820CD980h */ case    4:  		/* addi R11, R11, 2916 */
		/* 820CD980h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB64);
		/* 820CD980h case    4:*/		return 0x820CD984;
		  /* 820CD984h */ case    5:  		/* addi R8, R11, 2 */
		/* 820CD984h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x2);
		/* 820CD984h case    5:*/		return 0x820CD988;
	}
	return 0x820CD988;
} // Block from 820CD970h-820CD988h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CD988h
// Function '?Copy@CNodeStateBlockFunctionCall@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD988);
		  /* 820CD988h */ case    0:  		/* lbz R9, <#[R11]> */
		/* 820CD988h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CD988h case    0:*/		return 0x820CD98C;
		  /* 820CD98Ch */ case    1:  		/* lbz R7, <#[R10]> */
		/* 820CD98Ch case    1:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CD98Ch case    1:*/		return 0x820CD990;
		  /* 820CD990h */ case    2:  		/* subf. R9, R7, R9 */
		/* 820CD990h case    2:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CD990h case    2:*/		return 0x820CD994;
		  /* 820CD994h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 820CD994h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820CD9A8;  }
		/* 820CD994h case    3:*/		return 0x820CD998;
		  /* 820CD998h */ case    4:  		/* addi R11, R11, 1 */
		/* 820CD998h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CD998h case    4:*/		return 0x820CD99C;
		  /* 820CD99Ch */ case    5:  		/* addi R10, R10, 1 */
		/* 820CD99Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CD99Ch case    5:*/		return 0x820CD9A0;
		  /* 820CD9A0h */ case    6:  		/* cmpw CR6, R11, R8 */
		/* 820CD9A0h case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CD9A0h case    6:*/		return 0x820CD9A4;
		  /* 820CD9A4h */ case    7:  		/* bc 4, CR6_EQ, -28 */
		/* 820CD9A4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820CD988;  }
		/* 820CD9A4h case    7:*/		return 0x820CD9A8;
	}
	return 0x820CD9A8;
} // Block from 820CD988h-820CD9A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CD9A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CD9A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CD9A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CD9A8);
		  /* 820CD9A8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CD9A8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CD9A8h case    0:*/		return 0x820CD9AC;
		  /* 820CD9ACh */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 820CD9ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x820CDA00;  }
		/* 820CD9ACh case    1:*/		return 0x820CD9B0;
		  /* 820CD9B0h */ case    2:  		/* li R11, 3 */
		/* 820CD9B0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820CD9B0h case    2:*/		return 0x820CD9B4;
		  /* 820CD9B4h */ case    3:  		/* sth R17, <#[R1 + 128]> */
		/* 820CD9B4h case    3:*/		cpu::mem::store16( regs, regs.R17, (uint32)(regs.R1 + 0x00000080) );
		/* 820CD9B4h case    3:*/		return 0x820CD9B8;
		  /* 820CD9B8h */ case    4:  		/* li R10, 4 */
		/* 820CD9B8h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820CD9B8h case    4:*/		return 0x820CD9BC;
		  /* 820CD9BCh */ case    5:  		/* sth R17, <#[R1 + 132]> */
		/* 820CD9BCh case    5:*/		cpu::mem::store16( regs, regs.R17, (uint32)(regs.R1 + 0x00000084) );
		/* 820CD9BCh case    5:*/		return 0x820CD9C0;
		  /* 820CD9C0h */ case    6:  		/* sth R11, <#[R1 + 130]> */
		/* 820CD9C0h case    6:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000082) );
		/* 820CD9C0h case    6:*/		return 0x820CD9C4;
		  /* 820CD9C4h */ case    7:  		/* li R8, 4 */
		/* 820CD9C4h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 820CD9C4h case    7:*/		return 0x820CD9C8;
		  /* 820CD9C8h */ case    8:  		/* sth R10, <#[R1 + 134]> */
		/* 820CD9C8h case    8:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000086) );
		/* 820CD9C8h case    8:*/		return 0x820CD9CC;
		  /* 820CD9CCh */ case    9:  		/* addi R7, R22, 12 */
		/* 820CD9CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R22,0xC);
		/* 820CD9CCh case    9:*/		return 0x820CD9D0;
		  /* 820CD9D0h */ case   10:  		/* sth R17, <#[R1 + 136]> */
		/* 820CD9D0h case   10:*/		cpu::mem::store16( regs, regs.R17, (uint32)(regs.R1 + 0x00000088) );
		/* 820CD9D0h case   10:*/		return 0x820CD9D4;
		  /* 820CD9D4h */ case   11:  		/* li R6, 6 */
		/* 820CD9D4h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 820CD9D4h case   11:*/		return 0x820CD9D8;
		  /* 820CD9D8h */ case   12:  		/* sth R20, <#[R1 + 138]> */
		/* 820CD9D8h case   12:*/		cpu::mem::store16( regs, regs.R20, (uint32)(regs.R1 + 0x0000008A) );
		/* 820CD9D8h case   12:*/		return 0x820CD9DC;
		  /* 820CD9DCh */ case   13:  		/* li R5, 16 */
		/* 820CD9DCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CD9DCh case   13:*/		return 0x820CD9E0;
		  /* 820CD9E0h */ case   14:  		/* stw R20, <#[R1 + 140]> */
		/* 820CD9E0h case   14:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x0000008C) );
		/* 820CD9E0h case   14:*/		return 0x820CD9E4;
		  /* 820CD9E4h */ case   15:  		/* addi R4, R1, 128 */
		/* 820CD9E4h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820CD9E4h case   15:*/		return 0x820CD9E8;
		  /* 820CD9E8h */ case   16:  		/* mr R3, R23 */
		/* 820CD9E8h case   16:*/		regs.R3 = regs.R23;
		/* 820CD9E8h case   16:*/		return 0x820CD9EC;
		  /* 820CD9ECh */ case   17:  		/* bl 2180 */
		/* 820CD9ECh case   17:*/		regs.LR = 0x820CD9F0; return 0x820CE270;
		/* 820CD9ECh case   17:*/		return 0x820CD9F0;
		  /* 820CD9F0h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820CD9F0h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CD9F0h case   18:*/		return 0x820CD9F4;
		  /* 820CD9F4h */ case   19:  		/* bc 12, CR0_LT, 996 */
		/* 820CD9F4h case   19:*/		if ( regs.CR[0].lt ) { return 0x820CDDD8;  }
		/* 820CD9F4h case   19:*/		return 0x820CD9F8;
		  /* 820CD9F8h */ case   20:  		/* stw R17, <#[R1 + 100]> */
		/* 820CD9F8h case   20:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000064) );
		/* 820CD9F8h case   20:*/		return 0x820CD9FC;
		  /* 820CD9FCh */ case   21:  		/* b 812 */
		/* 820CD9FCh case   21:*/		return 0x820CDD28;
		/* 820CD9FCh case   21:*/		return 0x820CDA00;
	}
	return 0x820CDA00;
} // Block from 820CD9A8h-820CDA00h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CDA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDA00);
		  /* 820CDA00h */ case    0:  		/* li R11, 12 */
		/* 820CDA00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820CDA00h case    0:*/		return 0x820CDA04;
		  /* 820CDA04h */ case    1:  		/* lwz R8, <#[R21 + 4]> */
		/* 820CDA04h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R21 + 0x00000004) );
		/* 820CDA04h case    1:*/		return 0x820CDA08;
		  /* 820CDA08h */ case    2:  		/* addi R26, R25, 2 */
		/* 820CDA08h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R25,0x2);
		/* 820CDA08h case    2:*/		return 0x820CDA0C;
		  /* 820CDA0Ch */ case    3:  		/* lwz R3, <#[R21]> */
		/* 820CDA0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000000) );
		/* 820CDA0Ch case    3:*/		return 0x820CDA10;
		  /* 820CDA10h */ case    4:  		/* addi R10, R1, 96 */
		/* 820CDA10h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 820CDA10h case    4:*/		return 0x820CDA14;
		  /* 820CDA14h */ case    5:  		/* stw R11, <#[R1 + 144]> */
		/* 820CDA14h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 820CDA14h case    5:*/		return 0x820CDA18;
		  /* 820CDA18h */ case    6:  		/* li R9, 2 */
		/* 820CDA18h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 820CDA18h case    6:*/		return 0x820CDA1C;
		  /* 820CDA1Ch */ case    7:  		/* stw R26, <#[R1 + 152]> */
		/* 820CDA1Ch case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000098) );
		/* 820CDA1Ch case    7:*/		return 0x820CDA20;
		  /* 820CDA20h */ case    8:  		/* li R7, 0 */
		/* 820CDA20h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820CDA20h case    8:*/		return 0x820CDA24;
		  /* 820CDA24h */ case    9:  		/* stw R20, <#[R1 + 160]> */
		/* 820CDA24h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x000000A0) );
		/* 820CDA24h case    9:*/		return 0x820CDA28;
		  /* 820CDA28h */ case   10:  		/* li R6, 0 */
		/* 820CDA28h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820CDA28h case   10:*/		return 0x820CDA2C;
		  /* 820CDA2Ch */ case   11:  		/* stw R20, <#[R1 + 168]> */
		/* 820CDA2Ch case   11:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x000000A8) );
		/* 820CDA2Ch case   11:*/		return 0x820CDA30;
		  /* 820CDA30h */ case   12:  		/* addi R5, R1, 144 */
		/* 820CDA30h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x90);
		/* 820CDA30h case   12:*/		return 0x820CDA34;
		  /* 820CDA34h */ case   13:  		/* stw R20, <#[R1 + 84]> */
		/* 820CDA34h case   13:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000054) );
		/* 820CDA34h case   13:*/		return 0x820CDA38;
		  /* 820CDA38h */ case   14:  		/* li R4, 1 */
		/* 820CDA38h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820CDA38h case   14:*/		return 0x820CDA3C;
		  /* 820CDA3Ch */ case   15:  		/* bl 337436 */
		/* 820CDA3Ch case   15:*/		regs.LR = 0x820CDA40; return 0x82120058;
		/* 820CDA3Ch case   15:*/		return 0x820CDA40;
		  /* 820CDA40h */ case   16:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CDA40h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CDA40h case   16:*/		return 0x820CDA44;
		  /* 820CDA44h */ case   17:  		/* addi R5, R1, 104 */
		/* 820CDA44h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 820CDA44h case   17:*/		return 0x820CDA48;
		  /* 820CDA48h */ case   18:  		/* addi R4, R1, 100 */
		/* 820CDA48h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x64);
		/* 820CDA48h case   18:*/		return 0x820CDA4C;
		  /* 820CDA4Ch */ case   19:  		/* lwz R3, <#[R11 + 48]> */
		/* 820CDA4Ch case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 820CDA4Ch case   19:*/		return 0x820CDA50;
		  /* 820CDA50h */ case   20:  		/* bl -1688 */
		/* 820CDA50h case   20:*/		regs.LR = 0x820CDA54; return 0x820CD3B8;
		/* 820CDA50h case   20:*/		return 0x820CDA54;
		  /* 820CDA54h */ case   21:  		/* cmpwi CR0, R3, 0 */
		/* 820CDA54h case   21:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CDA54h case   21:*/		return 0x820CDA58;
	}
	return 0x820CDA58;
} // Block from 820CDA00h-820CDA58h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CDA58h
// Function '?GetThreadLocalData@D3DXShader@@YAPAVThreadLocalData@1@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDA58);
		  /* 820CDA58h */ case    0:  		/* bc 12, CR0_LT, 896 */
		/* 820CDA58h case    0:*/		if ( regs.CR[0].lt ) { return 0x820CDDD8;  }
		/* 820CDA58h case    0:*/		return 0x820CDA5C;
		  /* 820CDA5Ch */ case    1:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CDA5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CDA5Ch case    1:*/		return 0x820CDA60;
		  /* 820CDA60h */ case    2:  		/* lwz R10, <#[R11 + 64]> */
		/* 820CDA60h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000040) );
		/* 820CDA60h case    2:*/		return 0x820CDA64;
		  /* 820CDA64h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820CDA64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CDA64h case    3:*/		return 0x820CDA68;
		  /* 820CDA68h */ case    4:  		/* bc 12, CR6_EQ, 464 */
		/* 820CDA68h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CDC38;  }
		/* 820CDA68h case    4:*/		return 0x820CDA6C;
		  /* 820CDA6Ch */ case    5:  		/* rlwinm R30, R10, 0, 0, 31 */
		/* 820CDA6Ch case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R30,regs.R10);
		/* 820CDA6Ch case    5:*/		return 0x820CDA70;
		  /* 820CDA70h */ case    6:  		/* mr R29, R20 */
		/* 820CDA70h case    6:*/		regs.R29 = regs.R20;
		/* 820CDA70h case    6:*/		return 0x820CDA74;
		  /* 820CDA74h */ case    7:  		/* mr R28, R20 */
		/* 820CDA74h case    7:*/		regs.R28 = regs.R20;
		/* 820CDA74h case    7:*/		return 0x820CDA78;
	}
	return 0x820CDA78;
} // Block from 820CDA58h-820CDA78h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CDA78h
// Function '?ThreadLocalDataBegin@D3DXShader@@YAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDA78);
		  /* 820CDA78h */ case    0:  		/* mr R27, R20 */
		/* 820CDA78h case    0:*/		regs.R27 = regs.R20;
		/* 820CDA78h case    0:*/		return 0x820CDA7C;
		  /* 820CDA7Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820CDA7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CDA7Ch case    1:*/		return 0x820CDA80;
		  /* 820CDA80h */ case    2:  		/* bc 12, CR6_EQ, 236 */
		/* 820CDA80h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CDB6C;  }
		/* 820CDA80h case    2:*/		return 0x820CDA84;
		  /* 820CDA84h */ case    3:  		/* lwz R10, <#[R30 + 8]> */
		/* 820CDA84h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820CDA84h case    3:*/		return 0x820CDA88;
		  /* 820CDA88h */ case    4:  		/* lwz R11, <#[R10 + 4]> */
		/* 820CDA88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820CDA88h case    4:*/		return 0x820CDA8C;
		  /* 820CDA8Ch */ case    5:  		/* cmpwi CR6, R11, 18 */
		/* 820CDA8Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 820CDA8Ch case    5:*/		return 0x820CDA90;
		  /* 820CDA90h */ case    6:  		/* bc 4, CR6_EQ, 196 */
		/* 820CDA90h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CDB54;  }
		/* 820CDA90h case    6:*/		return 0x820CDA94;
		  /* 820CDA94h */ case    7:  		/* lwz R11, <#[R10 + 16]> */
		/* 820CDA94h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820CDA94h case    7:*/		return 0x820CDA98;
		  /* 820CDA98h */ case    8:  		/* mr R3, R20 */
		/* 820CDA98h case    8:*/		regs.R3 = regs.R20;
		/* 820CDA98h case    8:*/		return 0x820CDA9C;
		  /* 820CDA9Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820CDA9Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CDA9Ch case    9:*/		return 0x820CDAA0;
		  /* 820CDAA0h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 820CDAA0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820CDAA8;  }
		/* 820CDAA0h case   10:*/		return 0x820CDAA4;
		  /* 820CDAA4h */ case   11:  		/* lwz R3, <#[R11 + 24]> */
		/* 820CDAA4h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000018) );
		/* 820CDAA4h case   11:*/		return 0x820CDAA8;
	}
	return 0x820CDAA8;
} // Block from 820CDA78h-820CDAA8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CDAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDAA8);
		  /* 820CDAA8h */ case    0:  		/* lwz R11, <#[R10 + 20]> */
		/* 820CDAA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820CDAA8h case    0:*/		return 0x820CDAAC;
		  /* 820CDAACh */ case    1:  		/* mr R31, R20 */
		/* 820CDAACh case    1:*/		regs.R31 = regs.R20;
		/* 820CDAACh case    1:*/		return 0x820CDAB0;
		  /* 820CDAB0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820CDAB0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CDAB0h case    2:*/		return 0x820CDAB4;
		  /* 820CDAB4h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 820CDAB4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820CDABC;  }
		/* 820CDAB4h case    3:*/		return 0x820CDAB8;
		  /* 820CDAB8h */ case    4:  		/* lwz R31, <#[R11 + 24]> */
		/* 820CDAB8h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000018) );
		/* 820CDAB8h case    4:*/		return 0x820CDABC;
	}
	return 0x820CDABC;
} // Block from 820CDAA8h-820CDABCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CDABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDABC);
		  /* 820CDABCh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820CDABCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CDABCh case    0:*/		return 0x820CDAC0;
		  /* 820CDAC0h */ case    1:  		/* bc 12, CR6_EQ, 108 */
		/* 820CDAC0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CDB2C;  }
		/* 820CDAC0h case    1:*/		return 0x820CDAC4;
		  /* 820CDAC4h */ case    2:  		/* addi R5, R1, 112 */
		/* 820CDAC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820CDAC4h case    2:*/		return 0x820CDAC8;
		  /* 820CDAC8h */ case    3:  		/* li R4, 0 */
		/* 820CDAC8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CDAC8h case    3:*/		return 0x820CDACC;
		  /* 820CDACCh */ case    4:  		/* bl -191804 */
		/* 820CDACCh case    4:*/		regs.LR = 0x820CDAD0; return 0x8209ED90;
		/* 820CDACCh case    4:*/		return 0x820CDAD0;
		  /* 820CDAD0h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820CDAD0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CDAD0h case    5:*/		return 0x820CDAD4;
		  /* 820CDAD4h */ case    6:  		/* bc 12, CR0_LT, 128 */
		/* 820CDAD4h case    6:*/		if ( regs.CR[0].lt ) { return 0x820CDB54;  }
		/* 820CDAD4h case    6:*/		return 0x820CDAD8;
		  /* 820CDAD8h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 820CDAD8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CDAD8h case    7:*/		return 0x820CDADC;
		  /* 820CDADCh */ case    8:  		/* bc 12, CR6_EQ, 120 */
		/* 820CDADCh case    8:*/		if ( regs.CR[6].eq ) { return 0x820CDB54;  }
		/* 820CDADCh case    8:*/		return 0x820CDAE0;
		  /* 820CDAE0h */ case    9:  		/* lbz R11, <#[R31]> */
		/* 820CDAE0h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CDAE0h case    9:*/		return 0x820CDAE4;
		  /* 820CDAE4h */ case   10:  		/* extsb R3, R11 */
		/* 820CDAE4h case   10:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820CDAE4h case   10:*/		return 0x820CDAE8;
		  /* 820CDAE8h */ case   11:  		/* bl -213848 */
		/* 820CDAE8h case   11:*/		regs.LR = 0x820CDAEC; return 0x82099790;
		/* 820CDAE8h case   11:*/		return 0x820CDAEC;
		  /* 820CDAECh */ case   12:  		/* lbz R11, <#[R25]> */
		/* 820CDAECh case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820CDAECh case   12:*/		return 0x820CDAF0;
		  /* 820CDAF0h */ case   13:  		/* extsb R11, R11 */
		/* 820CDAF0h case   13:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820CDAF0h case   13:*/		return 0x820CDAF4;
		  /* 820CDAF4h */ case   14:  		/* cmpw CR6, R3, R11 */
		/* 820CDAF4h case   14:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 820CDAF4h case   14:*/		return 0x820CDAF8;
		  /* 820CDAF8h */ case   15:  		/* bc 4, CR6_EQ, 92 */
		/* 820CDAF8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820CDB54;  }
		/* 820CDAF8h case   15:*/		return 0x820CDAFC;
		  /* 820CDAFCh */ case   16:  		/* lwz R11, <#[R1 + 116]> */
		/* 820CDAFCh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820CDAFCh case   16:*/		return 0x820CDB00;
		  /* 820CDB00h */ case   17:  		/* cmplw CR6, R24, R11 */
		/* 820CDB00h case   17:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 820CDB00h case   17:*/		return 0x820CDB04;
		  /* 820CDB04h */ case   18:  		/* bc 4, CR6_EQ, 12 */
		/* 820CDB04h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820CDB10;  }
		/* 820CDB04h case   18:*/		return 0x820CDB08;
		  /* 820CDB08h */ case   19:  		/* mr R29, R31 */
		/* 820CDB08h case   19:*/		regs.R29 = regs.R31;
		/* 820CDB08h case   19:*/		return 0x820CDB0C;
		  /* 820CDB0Ch */ case   20:  		/* b 72 */
		/* 820CDB0Ch case   20:*/		return 0x820CDB54;
		/* 820CDB0Ch case   20:*/		return 0x820CDB10;
	}
	return 0x820CDB10;
} // Block from 820CDABCh-820CDB10h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820CDB10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDB10);
		  /* 820CDB10h */ case    0:  		/* xor R10, R11, R24 */
		/* 820CDB10h case    0:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R11,regs.R24);
		/* 820CDB10h case    0:*/		return 0x820CDB14;
		  /* 820CDB14h */ case    1:  		/* rlwinm. R10, R10, 0, 0, 15 */
		/* 820CDB14h case    1:*/		cpu::op::rlwinm<1,0,0,15>(regs,&regs.R10,regs.R10);
		/* 820CDB14h case    1:*/		return 0x820CDB18;
		  /* 820CDB18h */ case    2:  		/* bc 4, CR0_EQ, 60 */
		/* 820CDB18h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820CDB54;  }
		/* 820CDB18h case    2:*/		return 0x820CDB1C;
		  /* 820CDB1Ch */ case    3:  		/* rlwinm. R11, R11, 0, 16, 31 */
		/* 820CDB1Ch case    3:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820CDB1Ch case    3:*/		return 0x820CDB20;
		  /* 820CDB20h */ case    4:  		/* bc 4, CR0_EQ, 52 */
		/* 820CDB20h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820CDB54;  }
		/* 820CDB20h case    4:*/		return 0x820CDB24;
		  /* 820CDB24h */ case    5:  		/* mr R28, R31 */
		/* 820CDB24h case    5:*/		regs.R28 = regs.R31;
		/* 820CDB24h case    5:*/		return 0x820CDB28;
		  /* 820CDB28h */ case    6:  		/* b 44 */
		/* 820CDB28h case    6:*/		return 0x820CDB54;
		/* 820CDB28h case    6:*/		return 0x820CDB2C;
	}
	return 0x820CDB2C;
} // Block from 820CDB10h-820CDB2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CDB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDB2C);
		  /* 820CDB2Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CDB2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CDB2Ch case    0:*/		return 0x820CDB30;
		  /* 820CDB30h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820CDB30h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CDB54;  }
		/* 820CDB30h case    1:*/		return 0x820CDB34;
		  /* 820CDB34h */ case    2:  		/* lbz R11, <#[R31]> */
		/* 820CDB34h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CDB34h case    2:*/		return 0x820CDB38;
		  /* 820CDB38h */ case    3:  		/* extsb R3, R11 */
		/* 820CDB38h case    3:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820CDB38h case    3:*/		return 0x820CDB3C;
		  /* 820CDB3Ch */ case    4:  		/* bl -213932 */
		/* 820CDB3Ch case    4:*/		regs.LR = 0x820CDB40; return 0x82099790;
		/* 820CDB3Ch case    4:*/		return 0x820CDB40;
		  /* 820CDB40h */ case    5:  		/* lbz R11, <#[R25]> */
		/* 820CDB40h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820CDB40h case    5:*/		return 0x820CDB44;
		  /* 820CDB44h */ case    6:  		/* extsb R11, R11 */
		/* 820CDB44h case    6:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820CDB44h case    6:*/		return 0x820CDB48;
		  /* 820CDB48h */ case    7:  		/* cmpw CR6, R3, R11 */
		/* 820CDB48h case    7:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 820CDB48h case    7:*/		return 0x820CDB4C;
		  /* 820CDB4Ch */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 820CDB4Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CDB54;  }
		/* 820CDB4Ch case    8:*/		return 0x820CDB50;
		  /* 820CDB50h */ case    9:  		/* mr R27, R31 */
		/* 820CDB50h case    9:*/		regs.R27 = regs.R31;
		/* 820CDB50h case    9:*/		return 0x820CDB54;
	}
	return 0x820CDB54;
} // Block from 820CDB2Ch-820CDB54h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CDB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDB54);
		  /* 820CDB54h */ case    0:  		/* lwz R30, <#[R30 + 12]> */
		/* 820CDB54h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x0000000C) );
		/* 820CDB54h case    0:*/		return 0x820CDB58;
		  /* 820CDB58h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820CDB58h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CDB58h case    1:*/		return 0x820CDB5C;
		  /* 820CDB5Ch */ case    2:  		/* bc 4, CR6_EQ, -216 */
		/* 820CDB5Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CDA84;  }
		/* 820CDB5Ch case    2:*/		return 0x820CDB60;
		  /* 820CDB60h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 820CDB60h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820CDB60h case    3:*/		return 0x820CDB64;
		  /* 820CDB64h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 820CDB64h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CDB84;  }
		/* 820CDB64h case    4:*/		return 0x820CDB68;
		  /* 820CDB68h */ case    5:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CDB68h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CDB68h case    5:*/		return 0x820CDB6C;
	}
	return 0x820CDB6C;
} // Block from 820CDB54h-820CDB6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CDB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDB6C);
		  /* 820CDB6Ch */ case    0:  		/* mr R29, R28 */
		/* 820CDB6Ch case    0:*/		regs.R29 = regs.R28;
		/* 820CDB6Ch case    0:*/		return 0x820CDB70;
		  /* 820CDB70h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820CDB70h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820CDB70h case    1:*/		return 0x820CDB74;
		  /* 820CDB74h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820CDB74h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CDB84;  }
		/* 820CDB74h case    2:*/		return 0x820CDB78;
		  /* 820CDB78h */ case    3:  		/* mr R29, R27 */
		/* 820CDB78h case    3:*/		regs.R29 = regs.R27;
		/* 820CDB78h case    3:*/		return 0x820CDB7C;
		  /* 820CDB7Ch */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 820CDB7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820CDB7Ch case    4:*/		return 0x820CDB80;
		  /* 820CDB80h */ case    5:  		/* bc 12, CR6_EQ, 184 */
		/* 820CDB80h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CDC38;  }
		/* 820CDB80h case    5:*/		return 0x820CDB84;
	}
	return 0x820CDB84;
} // Block from 820CDB6Ch-820CDB84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CDB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDB84);
		  /* 820CDB84h */ case    0:  		/* lbz R11, <#[R29]> */
		/* 820CDB84h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820CDB84h case    0:*/		return 0x820CDB88;
		  /* 820CDB88h */ case    1:  		/* extsb R3, R11 */
		/* 820CDB88h case    1:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820CDB88h case    1:*/		return 0x820CDB8C;
		  /* 820CDB8Ch */ case    2:  		/* bl -214012 */
		/* 820CDB8Ch case    2:*/		regs.LR = 0x820CDB90; return 0x82099790;
		/* 820CDB8Ch case    2:*/		return 0x820CDB90;
		  /* 820CDB90h */ case    3:  		/* lbz R11, <#[R25]> */
		/* 820CDB90h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820CDB90h case    3:*/		return 0x820CDB94;
		  /* 820CDB94h */ case    4:  		/* extsb R11, R11 */
		/* 820CDB94h case    4:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820CDB94h case    4:*/		return 0x820CDB98;
		  /* 820CDB98h */ case    5:  		/* cmpw CR6, R11, R3 */
		/* 820CDB98h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 820CDB98h case    5:*/		return 0x820CDB9C;
		  /* 820CDB9Ch */ case    6:  		/* bc 4, CR6_EQ, 152 */
		/* 820CDB9Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CDC34;  }
		/* 820CDB9Ch case    6:*/		return 0x820CDBA0;
		  /* 820CDBA0h */ case    7:  		/* lbz R11, <#[R29 + 1]> */
		/* 820CDBA0h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000001) );
		/* 820CDBA0h case    7:*/		return 0x820CDBA4;
		  /* 820CDBA4h */ case    8:  		/* addi R30, R29, 1 */
		/* 820CDBA4h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x1);
		/* 820CDBA4h case    8:*/		return 0x820CDBA8;
		  /* 820CDBA8h */ case    9:  		/* extsb R3, R11 */
		/* 820CDBA8h case    9:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820CDBA8h case    9:*/		return 0x820CDBAC;
		  /* 820CDBACh */ case   10:  		/* bl -214172 */
		/* 820CDBACh case   10:*/		regs.LR = 0x820CDBB0; return 0x82099710;
		/* 820CDBACh case   10:*/		return 0x820CDBB0;
		  /* 820CDBB0h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820CDBB0h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CDBB0h case   11:*/		return 0x820CDBB4;
		  /* 820CDBB4h */ case   12:  		/* bc 12, CR0_EQ, 128 */
		/* 820CDBB4h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CDC34;  }
		/* 820CDBB4h case   12:*/		return 0x820CDBB8;
		  /* 820CDBB8h */ case   13:  		/* lbz R11, <#[R29 + 2]> */
		/* 820CDBB8h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000002) );
		/* 820CDBB8h case   13:*/		return 0x820CDBBC;
		  /* 820CDBBCh */ case   14:  		/* addi R31, R29, 2 */
		/* 820CDBBCh case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R29,0x2);
		/* 820CDBBCh case   14:*/		return 0x820CDBC0;
		  /* 820CDBC0h */ case   15:  		/* b 8 */
		/* 820CDBC0h case   15:*/		return 0x820CDBC8;
		/* 820CDBC0h case   15:*/		return 0x820CDBC4;
		  /* 820CDBC4h */ case   16:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820CDBC4h case   16:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820CDBC4h case   16:*/		return 0x820CDBC8;
	}
	return 0x820CDBC8;
} // Block from 820CDB84h-820CDBC8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820CDBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDBC8);
		  /* 820CDBC8h */ case    0:  		/* extsb R3, R11 */
		/* 820CDBC8h case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820CDBC8h case    0:*/		return 0x820CDBCC;
		  /* 820CDBCCh */ case    1:  		/* bl -214204 */
		/* 820CDBCCh case    1:*/		regs.LR = 0x820CDBD0; return 0x82099710;
		/* 820CDBCCh case    1:*/		return 0x820CDBD0;
	}
	return 0x820CDBD0;
} // Block from 820CDBC8h-820CDBD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CDBD0h
// Function '?ThreadLocalDataEnd@D3DXShader@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDBD0);
		  /* 820CDBD0h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820CDBD0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CDBD0h case    0:*/		return 0x820CDBD4;
		  /* 820CDBD4h */ case    1:  		/* bc 4, CR0_EQ, -16 */
		/* 820CDBD4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CDBC4;  }
		/* 820CDBD4h case    1:*/		return 0x820CDBD8;
		  /* 820CDBD8h */ case    2:  		/* lbz R11, <#[R31]> */
		/* 820CDBD8h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CDBD8h case    2:*/		return 0x820CDBDC;
		  /* 820CDBDCh */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820CDBDCh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CDBDCh case    3:*/		return 0x820CDBE0;
		  /* 820CDBE0h */ case    4:  		/* bc 4, CR0_EQ, 84 */
		/* 820CDBE0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820CDC34;  }
		/* 820CDBE0h case    4:*/		return 0x820CDBE4;
		  /* 820CDBE4h */ case    5:  		/* mr R3, R30 */
		/* 820CDBE4h case    5:*/		regs.R3 = regs.R30;
		/* 820CDBE4h case    5:*/		return 0x820CDBE8;
		  /* 820CDBE8h */ case    6:  		/* bl -241792 */
		/* 820CDBE8h case    6:*/		regs.LR = 0x820CDBEC; return 0x82092B68;
		/* 820CDBE8h case    6:*/		return 0x820CDBEC;
		  /* 820CDBECh */ case    7:  		/* mr R8, R3 */
		/* 820CDBECh case    7:*/		regs.R8 = regs.R3;
		/* 820CDBECh case    7:*/		return 0x820CDBF0;
		  /* 820CDBF0h */ case    8:  		/* cmplwi CR6, R3, 8191 */
		/* 820CDBF0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00001FFF);
		/* 820CDBF0h case    8:*/		return 0x820CDBF4;
		  /* 820CDBF4h */ case    9:  		/* bc 4, CR6_GT, 44 */
		/* 820CDBF4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820CDC20;  }
		/* 820CDBF4h case    9:*/		return 0x820CDBF8;
		  /* 820CDBF8h */ case   10:  		/* lwz R11, <#[R21]> */
		/* 820CDBF8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820CDBF8h case   10:*/		return 0x820CDBFC;
		  /* 820CDBFCh */ case   11:  		/* lis R10, -32255 */
		/* 820CDBFCh case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CDBFCh case   11:*/		return 0x820CDC00;
		  /* 820CDC00h */ case   12:  		/* mr R7, R26 */
		/* 820CDC00h case   12:*/		regs.R7 = regs.R26;
		/* 820CDC00h case   12:*/		return 0x820CDC04;
		  /* 820CDC04h */ case   13:  		/* addi R6, R10, 11480 */
		/* 820CDC04h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x2CD8);
		/* 820CDC04h case   13:*/		return 0x820CDC08;
		  /* 820CDC08h */ case   14:  		/* li R5, 2902 */
		/* 820CDC08h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0xB56);
		/* 820CDC08h case   14:*/		return 0x820CDC0C;
		  /* 820CDC0Ch */ case   15:  		/* li R4, 0 */
		/* 820CDC0Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CDC0Ch case   15:*/		return 0x820CDC10;
		  /* 820CDC10h */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CDC10h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CDC10h case   16:*/		return 0x820CDC14;
		  /* 820CDC14h */ case   17:  		/* addi R3, R11, 24 */
		/* 820CDC14h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820CDC14h case   17:*/		return 0x820CDC18;
		  /* 820CDC18h */ case   18:  		/* bl -158344 */
		/* 820CDC18h case   18:*/		regs.LR = 0x820CDC1C; return 0x820A7190;
		/* 820CDC18h case   18:*/		return 0x820CDC1C;
		  /* 820CDC1Ch */ case   19:  		/* b 180 */
		/* 820CDC1Ch case   19:*/		return 0x820CDCD0;
		/* 820CDC1Ch case   19:*/		return 0x820CDC20;
	}
	return 0x820CDC20;
} // Block from 820CDBD0h-820CDC20h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820CDC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDC20);
		  /* 820CDC20h */ case    0:  		/* lhz R10, <#[R22 + 10]> */
		/* 820CDC20h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R22 + 0x0000000A) );
		/* 820CDC20h case    0:*/		return 0x820CDC24;
		  /* 820CDC24h */ case    1:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 820CDC24h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 820CDC24h case    1:*/		return 0x820CDC28;
		  /* 820CDC28h */ case    2:  		/* or R10, R9, R10 */
		/* 820CDC28h case    2:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820CDC28h case    2:*/		return 0x820CDC2C;
		  /* 820CDC2Ch */ case    3:  		/* ori R10, R10, 2 */
		/* 820CDC2Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820CDC2Ch case    3:*/		return 0x820CDC30;
		  /* 820CDC30h */ case    4:  		/* sth R10, <#[R22 + 10]> */
		/* 820CDC30h case    4:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R22 + 0x0000000A) );
		/* 820CDC30h case    4:*/		return 0x820CDC34;
	}
	return 0x820CDC34;
} // Block from 820CDC20h-820CDC34h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CDC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDC34);
		  /* 820CDC34h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CDC34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CDC34h case    0:*/		return 0x820CDC38;
	}
	return 0x820CDC38;
} // Block from 820CDC34h-820CDC38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CDC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDC38);
		  /* 820CDC38h */ case    0:  		/* lwz R10, <#[R11 + 44]> */
		/* 820CDC38h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 820CDC38h case    0:*/		return 0x820CDC3C;
		  /* 820CDC3Ch */ case    1:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820CDC3Ch case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820CDC3Ch case    1:*/		return 0x820CDC40;
		  /* 820CDC40h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 820CDC40h case    2:*/		if ( regs.CR[0].eq ) { return 0x820CDC50;  }
		/* 820CDC40h case    2:*/		return 0x820CDC44;
		  /* 820CDC44h */ case    3:  		/* lhz R10, <#[R22 + 10]> */
		/* 820CDC44h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R22 + 0x0000000A) );
		/* 820CDC44h case    3:*/		return 0x820CDC48;
		  /* 820CDC48h */ case    4:  		/* ori R10, R10, 1 */
		/* 820CDC48h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CDC48h case    4:*/		return 0x820CDC4C;
		  /* 820CDC4Ch */ case    5:  		/* sth R10, <#[R22 + 10]> */
		/* 820CDC4Ch case    5:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R22 + 0x0000000A) );
		/* 820CDC4Ch case    5:*/		return 0x820CDC50;
	}
	return 0x820CDC50;
} // Block from 820CDC38h-820CDC50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CDC50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDC50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDC50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDC50);
		  /* 820CDC50h */ case    0:  		/* lwz R10, <#[R11 + 56]> */
		/* 820CDC50h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 820CDC50h case    0:*/		return 0x820CDC54;
		  /* 820CDC54h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820CDC54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CDC54h case    1:*/		return 0x820CDC58;
		  /* 820CDC58h */ case    2:  		/* bc 4, CR6_EQ, 140 */
		/* 820CDC58h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CDCE4;  }
		/* 820CDC58h case    2:*/		return 0x820CDC5C;
		  /* 820CDC5Ch */ case    3:  		/* lwz R9, <#[R11 + 52]> */
		/* 820CDC5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000034) );
		/* 820CDC5Ch case    3:*/		return 0x820CDC60;
		  /* 820CDC60h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 820CDC60h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820CDC60h case    4:*/		return 0x820CDC64;
		  /* 820CDC64h */ case    5:  		/* bc 4, CR6_EQ, 120 */
		/* 820CDC64h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820CDCDC;  }
		/* 820CDC64h case    5:*/		return 0x820CDC68;
		  /* 820CDC68h */ case    6:  		/* lhz R10, <#[R22 + 10]> */
		/* 820CDC68h case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R22 + 0x0000000A) );
		/* 820CDC68h case    6:*/		return 0x820CDC6C;
		  /* 820CDC6Ch */ case    7:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 820CDC6Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 820CDC6Ch case    7:*/		return 0x820CDC70;
		  /* 820CDC70h */ case    8:  		/* bc 12, CR0_EQ, 32 */
		/* 820CDC70h case    8:*/		if ( regs.CR[0].eq ) { return 0x820CDC90;  }
		/* 820CDC70h case    8:*/		return 0x820CDC74;
		  /* 820CDC74h */ case    9:  		/* addi R5, R22, 16 */
		/* 820CDC74h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R22,0x10);
		/* 820CDC74h case    9:*/		return 0x820CDC78;
		  /* 820CDC78h */ case   10:  		/* lwz R4, <#[R1 + 100]> */
		/* 820CDC78h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 820CDC78h case   10:*/		return 0x820CDC7C;
		  /* 820CDC7Ch */ case   11:  		/* mr R3, R23 */
		/* 820CDC7Ch case   11:*/		regs.R3 = regs.R23;
		/* 820CDC7Ch case   11:*/		return 0x820CDC80;
		  /* 820CDC80h */ case   12:  		/* bl -1152 */
		/* 820CDC80h case   12:*/		regs.LR = 0x820CDC84; return 0x820CD800;
		/* 820CDC80h case   12:*/		return 0x820CDC84;
		  /* 820CDC84h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820CDC84h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CDC84h case   13:*/		return 0x820CDC88;
		  /* 820CDC88h */ case   14:  		/* bc 12, CR0_LT, 336 */
		/* 820CDC88h case   14:*/		if ( regs.CR[0].lt ) { return 0x820CDDD8;  }
		/* 820CDC88h case   14:*/		return 0x820CDC8C;
		  /* 820CDC8Ch */ case   15:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CDC8Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CDC8Ch case   15:*/		return 0x820CDC90;
	}
	return 0x820CDC90;
} // Block from 820CDC50h-820CDC90h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CDC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDC90);
		  /* 820CDC90h */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 820CDC90h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 820CDC90h case    0:*/		return 0x820CDC94;
		  /* 820CDC94h */ case    1:  		/* lwz R9, <#[R10 + 4]> */
		/* 820CDC94h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820CDC94h case    1:*/		return 0x820CDC98;
		  /* 820CDC98h */ case    2:  		/* cmpwi CR6, R9, 9 */
		/* 820CDC98h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000009);
		/* 820CDC98h case    2:*/		return 0x820CDC9C;
		  /* 820CDC9Ch */ case    3:  		/* bc 4, CR6_EQ, 108 */
		/* 820CDC9Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820CDD08;  }
		/* 820CDC9Ch case    3:*/		return 0x820CDCA0;
		  /* 820CDCA0h */ case    4:  		/* lwz R10, <#[R10 + 20]> */
		/* 820CDCA0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820CDCA0h case    4:*/		return 0x820CDCA4;
		  /* 820CDCA4h */ case    5:  		/* cmpwi CR6, R10, 33 */
		/* 820CDCA4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000021);
		/* 820CDCA4h case    5:*/		return 0x820CDCA8;
		  /* 820CDCA8h */ case    6:  		/* bc 4, CR6_EQ, 96 */
		/* 820CDCA8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CDD08;  }
		/* 820CDCA8h case    6:*/		return 0x820CDCAC;
		  /* 820CDCACh */ case    7:  		/* lwz R11, <#[R21]> */
		/* 820CDCACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820CDCACh case    7:*/		return 0x820CDCB0;
		  /* 820CDCB0h */ case    8:  		/* lis R10, -32255 */
		/* 820CDCB0h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CDCB0h case    8:*/		return 0x820CDCB4;
		  /* 820CDCB4h */ case    9:  		/* mr R7, R26 */
		/* 820CDCB4h case    9:*/		regs.R7 = regs.R26;
		/* 820CDCB4h case    9:*/		return 0x820CDCB8;
		  /* 820CDCB8h */ case   10:  		/* addi R6, R10, 11368 */
		/* 820CDCB8h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x2C68);
		/* 820CDCB8h case   10:*/		return 0x820CDCBC;
		  /* 820CDCBCh */ case   11:  		/* li R5, 2905 */
		/* 820CDCBCh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xB59);
		/* 820CDCBCh case   11:*/		return 0x820CDCC0;
		  /* 820CDCC0h */ case   12:  		/* li R4, 0 */
		/* 820CDCC0h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CDCC0h case   12:*/		return 0x820CDCC4;
		  /* 820CDCC4h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CDCC4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CDCC4h case   13:*/		return 0x820CDCC8;
		  /* 820CDCC8h */ case   14:  		/* addi R3, R11, 24 */
		/* 820CDCC8h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820CDCC8h case   14:*/		return 0x820CDCCC;
		  /* 820CDCCCh */ case   15:  		/* bl -158524 */
		/* 820CDCCCh case   15:*/		regs.LR = 0x820CDCD0; return 0x820A7190;
		/* 820CDCCCh case   15:*/		return 0x820CDCD0;
	}
	return 0x820CDCD0;
} // Block from 820CDC90h-820CDCD0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CDCD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDCD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDCD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDCD0);
		  /* 820CDCD0h */ case    0:  		/* lis R3, -32768 */
		/* 820CDCD0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CDCD0h case    0:*/		return 0x820CDCD4;
		  /* 820CDCD4h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820CDCD4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CDCD4h case    1:*/		return 0x820CDCD8;
		  /* 820CDCD8h */ case    2:  		/* b 256 */
		/* 820CDCD8h case    2:*/		return 0x820CDDD8;
		/* 820CDCD8h case    2:*/		return 0x820CDCDC;
	}
	return 0x820CDCDC;
} // Block from 820CDCD0h-820CDCDCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CDCDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDCDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDCDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDCDC);
		  /* 820CDCDCh */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820CDCDCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CDCDCh case    0:*/		return 0x820CDCE0;
		  /* 820CDCE0h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820CDCE0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CDCEC;  }
		/* 820CDCE0h case    1:*/		return 0x820CDCE4;
	}
	return 0x820CDCE4;
} // Block from 820CDCDCh-820CDCE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CDCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDCE4);
		  /* 820CDCE4h */ case    0:  		/* lwz R6, <#[R11 + 56]> */
		/* 820CDCE4h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000038) );
		/* 820CDCE4h case    0:*/		return 0x820CDCE8;
		  /* 820CDCE8h */ case    1:  		/* b 8 */
		/* 820CDCE8h case    1:*/		return 0x820CDCF0;
		/* 820CDCE8h case    1:*/		return 0x820CDCEC;
	}
	return 0x820CDCEC;
} // Block from 820CDCE4h-820CDCECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CDCECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDCEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDCEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDCEC);
		  /* 820CDCECh */ case    0:  		/* lwz R6, <#[R11 + 52]> */
		/* 820CDCECh case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000034) );
		/* 820CDCECh case    0:*/		return 0x820CDCF0;
	}
	return 0x820CDCF0;
} // Block from 820CDCECh-820CDCF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CDCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDCF0);
		  /* 820CDCF0h */ case    0:  		/* addi R7, R22, 16 */
		/* 820CDCF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R22,0x10);
		/* 820CDCF0h case    0:*/		return 0x820CDCF4;
		  /* 820CDCF4h */ case    1:  		/* lwz R5, <#[R1 + 104]> */
		/* 820CDCF4h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 820CDCF4h case    1:*/		return 0x820CDCF8;
		  /* 820CDCF8h */ case    2:  		/* mr R3, R23 */
		/* 820CDCF8h case    2:*/		regs.R3 = regs.R23;
		/* 820CDCF8h case    2:*/		return 0x820CDCFC;
		  /* 820CDCFCh */ case    3:  		/* lwz R4, <#[R1 + 100]> */
		/* 820CDCFCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 820CDCFCh case    3:*/		return 0x820CDD00;
	}
	return 0x820CDD00;
} // Block from 820CDCF0h-820CDD00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CDD00h
// Function '?D3DXCheckNewDelete@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDD00);
		  /* 820CDD00h */ case    0:  		/* bl -1592 */
		/* 820CDD00h case    0:*/		regs.LR = 0x820CDD04; return 0x820CD6C8;
		/* 820CDD00h case    0:*/		return 0x820CDD04;
		  /* 820CDD04h */ case    1:  		/* b -128 */
		/* 820CDD04h case    1:*/		return 0x820CDC84;
		/* 820CDD04h case    1:*/		return 0x820CDD08;
	}
	return 0x820CDD08;
} // Block from 820CDD00h-820CDD08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CDD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDD08);
		  /* 820CDD08h */ case    0:  		/* addi R7, R22, 12 */
		/* 820CDD08h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R22,0xC);
		/* 820CDD08h case    0:*/		return 0x820CDD0C;
		  /* 820CDD0Ch */ case    1:  		/* lwz R4, <#[R11 + 48]> */
		/* 820CDD0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000030) );
		/* 820CDD0Ch case    1:*/		return 0x820CDD10;
		  /* 820CDD10h */ case    2:  		/* li R6, 0 */
		/* 820CDD10h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820CDD10h case    2:*/		return 0x820CDD14;
		  /* 820CDD14h */ case    3:  		/* li R5, 1 */
		/* 820CDD14h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820CDD14h case    3:*/		return 0x820CDD18;
		  /* 820CDD18h */ case    4:  		/* mr R3, R23 */
		/* 820CDD18h case    4:*/		regs.R3 = regs.R23;
		/* 820CDD18h case    4:*/		return 0x820CDD1C;
		  /* 820CDD1Ch */ case    5:  		/* bl 145756 */
		/* 820CDD1Ch case    5:*/		regs.LR = 0x820CDD20; return 0x820F1678;
		/* 820CDD1Ch case    5:*/		return 0x820CDD20;
		  /* 820CDD20h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820CDD20h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CDD20h case    6:*/		return 0x820CDD24;
		  /* 820CDD24h */ case    7:  		/* bc 12, CR0_LT, 180 */
		/* 820CDD24h case    7:*/		if ( regs.CR[0].lt ) { return 0x820CDDD8;  }
		/* 820CDD24h case    7:*/		return 0x820CDD28;
	}
	return 0x820CDD28;
} // Block from 820CDD08h-820CDD28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CDD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDD28);
		  /* 820CDD28h */ case    0:  		/* li R8, 1 */
		/* 820CDD28h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820CDD28h case    0:*/		return 0x820CDD2C;
		  /* 820CDD2Ch */ case    1:  		/* mr R7, R22 */
		/* 820CDD2Ch case    1:*/		regs.R7 = regs.R22;
		/* 820CDD2Ch case    1:*/		return 0x820CDD30;
		  /* 820CDD30h */ case    2:  		/* li R6, 7 */
		/* 820CDD30h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820CDD30h case    2:*/		return 0x820CDD34;
		  /* 820CDD34h */ case    3:  		/* li R5, -1 */
		/* 820CDD34h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 820CDD34h case    3:*/		return 0x820CDD38;
		  /* 820CDD38h */ case    4:  		/* mr R4, R25 */
		/* 820CDD38h case    4:*/		regs.R4 = regs.R25;
		/* 820CDD38h case    4:*/		return 0x820CDD3C;
		  /* 820CDD3Ch */ case    5:  		/* mr R3, R23 */
		/* 820CDD3Ch case    5:*/		regs.R3 = regs.R23;
		/* 820CDD3Ch case    5:*/		return 0x820CDD40;
		  /* 820CDD40h */ case    6:  		/* bl 1328 */
		/* 820CDD40h case    6:*/		regs.LR = 0x820CDD44; return 0x820CE270;
		/* 820CDD40h case    6:*/		return 0x820CDD44;
		  /* 820CDD44h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820CDD44h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CDD44h case    7:*/		return 0x820CDD48;
		  /* 820CDD48h */ case    8:  		/* bc 12, CR0_LT, 144 */
		/* 820CDD48h case    8:*/		if ( regs.CR[0].lt ) { return 0x820CDDD8;  }
		/* 820CDD48h case    8:*/		return 0x820CDD4C;
		  /* 820CDD4Ch */ case    9:  		/* mr R11, R19 */
		/* 820CDD4Ch case    9:*/		regs.R11 = regs.R19;
		/* 820CDD4Ch case    9:*/		return 0x820CDD50;
		  /* 820CDD50h */ case   10:  		/* mr R10, R25 */
		/* 820CDD50h case   10:*/		regs.R10 = regs.R25;
		/* 820CDD50h case   10:*/		return 0x820CDD54;
		  /* 820CDD54h */ case   11:  		/* addi R8, R19, 2 */
		/* 820CDD54h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R19,0x2);
		/* 820CDD54h case   11:*/		return 0x820CDD58;
		  /* 820CDD58h */ case   12:  		/* lbz R9, <#[R11]> */
		/* 820CDD58h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CDD58h case   12:*/		return 0x820CDD5C;
		  /* 820CDD5Ch */ case   13:  		/* lbz R7, <#[R10]> */
		/* 820CDD5Ch case   13:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CDD5Ch case   13:*/		return 0x820CDD60;
		  /* 820CDD60h */ case   14:  		/* subf. R9, R7, R9 */
		/* 820CDD60h case   14:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CDD60h case   14:*/		return 0x820CDD64;
		  /* 820CDD64h */ case   15:  		/* bc 4, CR0_EQ, 20 */
		/* 820CDD64h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820CDD78;  }
		/* 820CDD64h case   15:*/		return 0x820CDD68;
		  /* 820CDD68h */ case   16:  		/* addi R11, R11, 1 */
		/* 820CDD68h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CDD68h case   16:*/		return 0x820CDD6C;
		  /* 820CDD6Ch */ case   17:  		/* addi R10, R10, 1 */
		/* 820CDD6Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CDD6Ch case   17:*/		return 0x820CDD70;
		  /* 820CDD70h */ case   18:  		/* cmpw CR6, R11, R8 */
		/* 820CDD70h case   18:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CDD70h case   18:*/		return 0x820CDD74;
		  /* 820CDD74h */ case   19:  		/* bc 4, CR6_EQ, -28 */
		/* 820CDD74h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820CDD58;  }
		/* 820CDD74h case   19:*/		return 0x820CDD78;
	}
	return 0x820CDD78;
} // Block from 820CDD28h-820CDD78h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820CDD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDD78);
		  /* 820CDD78h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CDD78h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CDD78h case    0:*/		return 0x820CDD7C;
		  /* 820CDD7Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CDD7Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CDD88;  }
		/* 820CDD7Ch case    1:*/		return 0x820CDD80;
		  /* 820CDD80h */ case    2:  		/* sth R20, <#[R22 + 4]> */
		/* 820CDD80h case    2:*/		cpu::mem::store16( regs, regs.R20, (uint32)(regs.R22 + 0x00000004) );
		/* 820CDD80h case    2:*/		return 0x820CDD84;
		  /* 820CDD84h */ case    3:  		/* b 72 */
		/* 820CDD84h case    3:*/		return 0x820CDDCC;
		/* 820CDD84h case    3:*/		return 0x820CDD88;
	}
	return 0x820CDD88;
} // Block from 820CDD78h-820CDD88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CDD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDD88);
		  /* 820CDD88h */ case    0:  		/* mr R11, R18 */
		/* 820CDD88h case    0:*/		regs.R11 = regs.R18;
		/* 820CDD88h case    0:*/		return 0x820CDD8C;
		  /* 820CDD8Ch */ case    1:  		/* mr R10, R25 */
		/* 820CDD8Ch case    1:*/		regs.R10 = regs.R25;
		/* 820CDD8Ch case    1:*/		return 0x820CDD90;
		  /* 820CDD90h */ case    2:  		/* addi R8, R18, 2 */
		/* 820CDD90h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R18,0x2);
		/* 820CDD90h case    2:*/		return 0x820CDD94;
		  /* 820CDD94h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CDD94h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CDD94h case    3:*/		return 0x820CDD98;
		  /* 820CDD98h */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820CDD98h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CDD98h case    4:*/		return 0x820CDD9C;
		  /* 820CDD9Ch */ case    5:  		/* subf. R9, R7, R9 */
		/* 820CDD9Ch case    5:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CDD9Ch case    5:*/		return 0x820CDDA0;
		  /* 820CDDA0h */ case    6:  		/* bc 4, CR0_EQ, 20 */
		/* 820CDDA0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820CDDB4;  }
		/* 820CDDA0h case    6:*/		return 0x820CDDA4;
		  /* 820CDDA4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820CDDA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CDDA4h case    7:*/		return 0x820CDDA8;
		  /* 820CDDA8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820CDDA8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CDDA8h case    8:*/		return 0x820CDDAC;
		  /* 820CDDACh */ case    9:  		/* cmpw CR6, R11, R8 */
		/* 820CDDACh case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820CDDACh case    9:*/		return 0x820CDDB0;
		  /* 820CDDB0h */ case   10:  		/* bc 4, CR6_EQ, -28 */
		/* 820CDDB0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820CDD94;  }
		/* 820CDDB0h case   10:*/		return 0x820CDDB4;
	}
	return 0x820CDDB4;
} // Block from 820CDD88h-820CDDB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CDDB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDDB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDDB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDDB4);
		  /* 820CDDB4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CDDB4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CDDB4h case    0:*/		return 0x820CDDB8;
		  /* 820CDDB8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CDDB8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CDDC4;  }
		/* 820CDDB8h case    1:*/		return 0x820CDDBC;
		  /* 820CDDBCh */ case    2:  		/* sth R17, <#[R22 + 4]> */
		/* 820CDDBCh case    2:*/		cpu::mem::store16( regs, regs.R17, (uint32)(regs.R22 + 0x00000004) );
		/* 820CDDBCh case    2:*/		return 0x820CDDC0;
		  /* 820CDDC0h */ case    3:  		/* b 12 */
		/* 820CDDC0h case    3:*/		return 0x820CDDCC;
		/* 820CDDC0h case    3:*/		return 0x820CDDC4;
	}
	return 0x820CDDC4;
} // Block from 820CDDB4h-820CDDC4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CDDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDDC4);
		  /* 820CDDC4h */ case    0:  		/* li R11, 2 */
		/* 820CDDC4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820CDDC4h case    0:*/		return 0x820CDDC8;
		  /* 820CDDC8h */ case    1:  		/* sth R11, <#[R22 + 4]> */
		/* 820CDDC8h case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 820CDDC8h case    1:*/		return 0x820CDDCC;
	}
	return 0x820CDDCC;
} // Block from 820CDDC4h-820CDDCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CDDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDDCC);
		  /* 820CDDCCh */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 820CDDCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820CDDCCh case    0:*/		return 0x820CDDD0;
		  /* 820CDDD0h */ case    1:  		/* sth R16, <#[R22 + 6]> */
		/* 820CDDD0h case    1:*/		cpu::mem::store16( regs, regs.R16, (uint32)(regs.R22 + 0x00000006) );
		/* 820CDDD0h case    1:*/		return 0x820CDDD4;
		  /* 820CDDD4h */ case    2:  		/* sth R11, <#[R22 + 8]> */
		/* 820CDDD4h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 820CDDD4h case    2:*/		return 0x820CDDD8;
	}
	return 0x820CDDD8;
} // Block from 820CDDCCh-820CDDD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CDDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDDD8);
		  /* 820CDDD8h */ case    0:  		/* addi R1, R1, 320 */
		/* 820CDDD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 820CDDD8h case    0:*/		return 0x820CDDDC;
		  /* 820CDDDCh */ case    1:  		/* b -248676 */
		/* 820CDDDCh case    1:*/		return 0x82091278;
		/* 820CDDDCh case    1:*/		return 0x820CDDE0;
	}
	return 0x820CDDE0;
} // Block from 820CDDD8h-820CDDE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CDDE0h
// Function '?CalcNumRegisters@D3DXShader@@YAJPAVCNode@1@PAI1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDDE0);
		  /* 820CDDE0h */ case    0:  		/* mfspr R12, LR */
		/* 820CDDE0h case    0:*/		regs.R12 = regs.LR;
		/* 820CDDE0h case    0:*/		return 0x820CDDE4;
		  /* 820CDDE4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CDDE4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CDDE4h case    1:*/		return 0x820CDDE8;
		  /* 820CDDE8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820CDDE8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CDDE8h case    2:*/		return 0x820CDDEC;
		  /* 820CDDECh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CDDECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CDDECh case    3:*/		return 0x820CDDF0;
		  /* 820CDDF0h */ case    4:  		/* li R4, 24 */
		/* 820CDDF0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820CDDF0h case    4:*/		return 0x820CDDF4;
		  /* 820CDDF4h */ case    5:  		/* mr R31, R3 */
		/* 820CDDF4h case    5:*/		regs.R31 = regs.R3;
		/* 820CDDF4h case    5:*/		return 0x820CDDF8;
		  /* 820CDDF8h */ case    6:  		/* bl -19312 */
		/* 820CDDF8h case    6:*/		regs.LR = 0x820CDDFC; return 0x820C9288;
		/* 820CDDF8h case    6:*/		return 0x820CDDFC;
		  /* 820CDDFCh */ case    7:  		/* lis R10, -32255 */
		/* 820CDDFCh case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CDDFCh case    7:*/		return 0x820CDE00;
		  /* 820CDE00h */ case    8:  		/* li R11, 0 */
		/* 820CDE00h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CDE00h case    8:*/		return 0x820CDE04;
		  /* 820CDE04h */ case    9:  		/* addi R10, R10, 11556 */
		/* 820CDE04h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2D24);
		/* 820CDE04h case    9:*/		return 0x820CDE08;
		  /* 820CDE08h */ case   10:  		/* stw R11, <#[R31 + 56]> */
		/* 820CDE08h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820CDE08h case   10:*/		return 0x820CDE0C;
		  /* 820CDE0Ch */ case   11:  		/* mr R3, R31 */
		/* 820CDE0Ch case   11:*/		regs.R3 = regs.R31;
		/* 820CDE0Ch case   11:*/		return 0x820CDE10;
		  /* 820CDE10h */ case   12:  		/* stw R10, <#[R31]> */
		/* 820CDE10h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820CDE10h case   12:*/		return 0x820CDE14;
		  /* 820CDE14h */ case   13:  		/* stw R11, <#[R31 + 60]> */
		/* 820CDE14h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CDE14h case   13:*/		return 0x820CDE18;
		  /* 820CDE18h */ case   14:  		/* stw R11, <#[R31 + 64]> */
		/* 820CDE18h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820CDE18h case   14:*/		return 0x820CDE1C;
		  /* 820CDE1Ch */ case   15:  		/* stw R11, <#[R31 + 68]> */
		/* 820CDE1Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820CDE1Ch case   15:*/		return 0x820CDE20;
		  /* 820CDE20h */ case   16:  		/* stw R11, <#[R31 + 72]> */
		/* 820CDE20h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820CDE20h case   16:*/		return 0x820CDE24;
		  /* 820CDE24h */ case   17:  		/* stw R11, <#[R31 + 92]> */
		/* 820CDE24h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 820CDE24h case   17:*/		return 0x820CDE28;
		  /* 820CDE28h */ case   18:  		/* stw R11, <#[R31 + 96]> */
		/* 820CDE28h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820CDE28h case   18:*/		return 0x820CDE2C;
		  /* 820CDE2Ch */ case   19:  		/* std R11, <#[R31 + 16]> */
		/* 820CDE2Ch case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CDE2Ch case   19:*/		return 0x820CDE30;
		  /* 820CDE30h */ case   20:  		/* std R11, <#[R31 + 24]> */
		/* 820CDE30h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CDE30h case   20:*/		return 0x820CDE34;
		  /* 820CDE34h */ case   21:  		/* std R11, <#[R31 + 32]> */
		/* 820CDE34h case   21:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820CDE34h case   21:*/		return 0x820CDE38;
		  /* 820CDE38h */ case   22:  		/* std R11, <#[R31 + 40]> */
		/* 820CDE38h case   22:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820CDE38h case   22:*/		return 0x820CDE3C;
		  /* 820CDE3Ch */ case   23:  		/* std R11, <#[R31 + 48]> */
		/* 820CDE3Ch case   23:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820CDE3Ch case   23:*/		return 0x820CDE40;
		  /* 820CDE40h */ case   24:  		/* stw R11, <#[R31 + 76]> */
		/* 820CDE40h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820CDE40h case   24:*/		return 0x820CDE44;
		  /* 820CDE44h */ case   25:  		/* stw R11, <#[R31 + 80]> */
		/* 820CDE44h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 820CDE44h case   25:*/		return 0x820CDE48;
		  /* 820CDE48h */ case   26:  		/* stw R11, <#[R31 + 84]> */
		/* 820CDE48h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820CDE48h case   26:*/		return 0x820CDE4C;
		  /* 820CDE4Ch */ case   27:  		/* stw R11, <#[R31 + 88]> */
		/* 820CDE4Ch case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 820CDE4Ch case   27:*/		return 0x820CDE50;
		  /* 820CDE50h */ case   28:  		/* addi R1, R1, 96 */
		/* 820CDE50h case   28:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CDE50h case   28:*/		return 0x820CDE54;
		  /* 820CDE54h */ case   29:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CDE54h case   29:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CDE54h case   29:*/		return 0x820CDE58;
		  /* 820CDE58h */ case   30:  		/* mtspr LR, R12 */
		/* 820CDE58h case   30:*/		regs.LR = regs.R12;
		/* 820CDE58h case   30:*/		return 0x820CDE5C;
		  /* 820CDE5Ch */ case   31:  		/* ld R31, <#[R1 - 16]> */
		/* 820CDE5Ch case   31:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CDE5Ch case   31:*/		return 0x820CDE60;
		  /* 820CDE60h */ case   32:  		/* bclr 20, CR0_LT */
		/* 820CDE60h case   32:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CDE60h case   32:*/		return 0x820CDE64;
	}
	return 0x820CDE64;
} // Block from 820CDDE0h-820CDE64h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820CDE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDE64);
		  /* 820CDE64h */ case    0:  		/* nop */
		/* 820CDE64h case    0:*/		cpu::op::nop();
		/* 820CDE64h case    0:*/		return 0x820CDE68;
	}
	return 0x820CDE68;
} // Block from 820CDE64h-820CDE68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CDE68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDE68);
		  /* 820CDE68h */ case    0:  		/* mfspr R12, LR */
		/* 820CDE68h case    0:*/		regs.R12 = regs.LR;
		/* 820CDE68h case    0:*/		return 0x820CDE6C;
		  /* 820CDE6Ch */ case    1:  		/* bl -248856 */
		/* 820CDE6Ch case    1:*/		regs.LR = 0x820CDE70; return 0x82091254;
		/* 820CDE6Ch case    1:*/		return 0x820CDE70;
		  /* 820CDE70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CDE70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CDE70h case    2:*/		return 0x820CDE74;
		  /* 820CDE74h */ case    3:  		/* mr R30, R4 */
		/* 820CDE74h case    3:*/		regs.R30 = regs.R4;
		/* 820CDE74h case    3:*/		return 0x820CDE78;
		  /* 820CDE78h */ case    4:  		/* li R4, 24 */
		/* 820CDE78h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820CDE78h case    4:*/		return 0x820CDE7C;
		  /* 820CDE7Ch */ case    5:  		/* mr R31, R3 */
		/* 820CDE7Ch case    5:*/		regs.R31 = regs.R3;
		/* 820CDE7Ch case    5:*/		return 0x820CDE80;
		  /* 820CDE80h */ case    6:  		/* mr R29, R5 */
		/* 820CDE80h case    6:*/		regs.R29 = regs.R5;
		/* 820CDE80h case    6:*/		return 0x820CDE84;
		  /* 820CDE84h */ case    7:  		/* mr R28, R6 */
		/* 820CDE84h case    7:*/		regs.R28 = regs.R6;
		/* 820CDE84h case    7:*/		return 0x820CDE88;
		  /* 820CDE88h */ case    8:  		/* mr R27, R7 */
		/* 820CDE88h case    8:*/		regs.R27 = regs.R7;
		/* 820CDE88h case    8:*/		return 0x820CDE8C;
		  /* 820CDE8Ch */ case    9:  		/* bl -19460 */
		/* 820CDE8Ch case    9:*/		regs.LR = 0x820CDE90; return 0x820C9288;
		/* 820CDE8Ch case    9:*/		return 0x820CDE90;
		  /* 820CDE90h */ case   10:  		/* lis R10, -32255 */
		/* 820CDE90h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CDE90h case   10:*/		return 0x820CDE94;
		  /* 820CDE94h */ case   11:  		/* li R11, 5 */
		/* 820CDE94h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CDE94h case   11:*/		return 0x820CDE98;
		  /* 820CDE98h */ case   12:  		/* addi R10, R10, 11556 */
		/* 820CDE98h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2D24);
		/* 820CDE98h case   12:*/		return 0x820CDE9C;
		  /* 820CDE9Ch */ case   13:  		/* addi R9, R31, 8 */
		/* 820CDE9Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x8);
		/* 820CDE9Ch case   13:*/		return 0x820CDEA0;
		  /* 820CDEA0h */ case   14:  		/* stw R10, <#[R31]> */
		/* 820CDEA0h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820CDEA0h case   14:*/		return 0x820CDEA4;
		  /* 820CDEA4h */ case   15:  		/* addi R10, R30, -8 */
		/* 820CDEA4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFF8);
		/* 820CDEA4h case   15:*/		return 0x820CDEA8;
		  /* 820CDEA8h */ case   16:  		/* mtspr CTR, R11 */
		/* 820CDEA8h case   16:*/		regs.CTR = regs.R11;
		/* 820CDEA8h case   16:*/		return 0x820CDEAC;
		  /* 820CDEACh */ case   17:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CDEACh case   17:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CDEACh case   17:*/		return 0x820CDEB0;
		  /* 820CDEB0h */ case   18:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CDEB0h case   18:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CDEB0h case   18:*/		return 0x820CDEB4;
		  /* 820CDEB4h */ case   19:  		/* bc 16, CR0_LT, -8 */
		/* 820CDEB4h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CDEAC;  }
		/* 820CDEB4h case   19:*/		return 0x820CDEB8;
		  /* 820CDEB8h */ case   20:  		/* li R11, 0 */
		/* 820CDEB8h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CDEB8h case   20:*/		return 0x820CDEBC;
		  /* 820CDEBCh */ case   21:  		/* stw R29, <#[R31 + 56]> */
		/* 820CDEBCh case   21:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000038) );
		/* 820CDEBCh case   21:*/		return 0x820CDEC0;
		  /* 820CDEC0h */ case   22:  		/* stw R28, <#[R31 + 60]> */
		/* 820CDEC0h case   22:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CDEC0h case   22:*/		return 0x820CDEC4;
		  /* 820CDEC4h */ case   23:  		/* mr R3, R31 */
		/* 820CDEC4h case   23:*/		regs.R3 = regs.R31;
		/* 820CDEC4h case   23:*/		return 0x820CDEC8;
		  /* 820CDEC8h */ case   24:  		/* stw R27, <#[R31 + 64]> */
		/* 820CDEC8h case   24:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000040) );
		/* 820CDEC8h case   24:*/		return 0x820CDECC;
		  /* 820CDECCh */ case   25:  		/* stw R11, <#[R31 + 68]> */
		/* 820CDECCh case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820CDECCh case   25:*/		return 0x820CDED0;
		  /* 820CDED0h */ case   26:  		/* stw R11, <#[R31 + 72]> */
		/* 820CDED0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820CDED0h case   26:*/		return 0x820CDED4;
		  /* 820CDED4h */ case   27:  		/* stw R11, <#[R31 + 92]> */
		/* 820CDED4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 820CDED4h case   27:*/		return 0x820CDED8;
		  /* 820CDED8h */ case   28:  		/* stw R11, <#[R31 + 96]> */
		/* 820CDED8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820CDED8h case   28:*/		return 0x820CDEDC;
		  /* 820CDEDCh */ case   29:  		/* stw R11, <#[R31 + 76]> */
		/* 820CDEDCh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820CDEDCh case   29:*/		return 0x820CDEE0;
		  /* 820CDEE0h */ case   30:  		/* stw R11, <#[R31 + 80]> */
		/* 820CDEE0h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 820CDEE0h case   30:*/		return 0x820CDEE4;
		  /* 820CDEE4h */ case   31:  		/* stw R11, <#[R31 + 84]> */
		/* 820CDEE4h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820CDEE4h case   31:*/		return 0x820CDEE8;
		  /* 820CDEE8h */ case   32:  		/* stw R11, <#[R31 + 88]> */
		/* 820CDEE8h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 820CDEE8h case   32:*/		return 0x820CDEEC;
		  /* 820CDEECh */ case   33:  		/* addi R1, R1, 128 */
		/* 820CDEECh case   33:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CDEECh case   33:*/		return 0x820CDEF0;
		  /* 820CDEF0h */ case   34:  		/* b -248908 */
		/* 820CDEF0h case   34:*/		return 0x820912A4;
		/* 820CDEF0h case   34:*/		return 0x820CDEF4;
		  /* 820CDEF4h */ case   35:  		/* nop */
		/* 820CDEF4h case   35:*/		cpu::op::nop();
		/* 820CDEF4h case   35:*/		return 0x820CDEF8;
	}
	return 0x820CDEF8;
} // Block from 820CDE68h-820CDEF8h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820CDEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDEF8);
		  /* 820CDEF8h */ case    0:  		/* mfspr R12, LR */
		/* 820CDEF8h case    0:*/		regs.R12 = regs.LR;
		/* 820CDEF8h case    0:*/		return 0x820CDEFC;
		  /* 820CDEFCh */ case    1:  		/* bl -248996 */
		/* 820CDEFCh case    1:*/		regs.LR = 0x820CDF00; return 0x82091258;
		/* 820CDEFCh case    1:*/		return 0x820CDF00;
		  /* 820CDF00h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CDF00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CDF00h case    2:*/		return 0x820CDF04;
		  /* 820CDF04h */ case    3:  		/* mr R31, R3 */
		/* 820CDF04h case    3:*/		regs.R31 = regs.R3;
		/* 820CDF04h case    3:*/		return 0x820CDF08;
		  /* 820CDF08h */ case    4:  		/* li R3, 104 */
		/* 820CDF08h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x68);
		/* 820CDF08h case    4:*/		return 0x820CDF0C;
		  /* 820CDF0Ch */ case    5:  		/* bl -19684 */
		/* 820CDF0Ch case    5:*/		regs.LR = 0x820CDF10; return 0x820C9228;
		/* 820CDF0Ch case    5:*/		return 0x820CDF10;
		  /* 820CDF10h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820CDF10h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CDF10h case    6:*/		return 0x820CDF14;
		  /* 820CDF14h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820CDF14h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CDF24;  }
		/* 820CDF14h case    7:*/		return 0x820CDF18;
	}
	return 0x820CDF18;
} // Block from 820CDEF8h-820CDF18h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CDF18h
// Function '?GetConstantSize@CFragmentConstants@D3DXShader@@QAAJPAUD3DXTOKEN@2@PBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDF18);
		  /* 820CDF18h */ case    0:  		/* bl -312 */
		/* 820CDF18h case    0:*/		regs.LR = 0x820CDF1C; return 0x820CDDE0;
		/* 820CDF18h case    0:*/		return 0x820CDF1C;
		  /* 820CDF1Ch */ case    1:  		/* mr R30, R3 */
		/* 820CDF1Ch case    1:*/		regs.R30 = regs.R3;
		/* 820CDF1Ch case    1:*/		return 0x820CDF20;
		  /* 820CDF20h */ case    2:  		/* b 8 */
		/* 820CDF20h case    2:*/		return 0x820CDF28;
		/* 820CDF20h case    2:*/		return 0x820CDF24;
	}
	return 0x820CDF24;
} // Block from 820CDF18h-820CDF24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CDF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDF24);
		  /* 820CDF24h */ case    0:  		/* li R30, 0 */
		/* 820CDF24h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CDF24h case    0:*/		return 0x820CDF28;
	}
	return 0x820CDF28;
} // Block from 820CDF24h-820CDF28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CDF28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDF28);
		  /* 820CDF28h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820CDF28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CDF28h case    0:*/		return 0x820CDF2C;
		  /* 820CDF2Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CDF2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CDF38;  }
		/* 820CDF2Ch case    1:*/		return 0x820CDF30;
		  /* 820CDF30h */ case    2:  		/* li R3, 0 */
		/* 820CDF30h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CDF30h case    2:*/		return 0x820CDF34;
		  /* 820CDF34h */ case    3:  		/* b 236 */
		/* 820CDF34h case    3:*/		return 0x820CE020;
		/* 820CDF34h case    3:*/		return 0x820CDF38;
	}
	return 0x820CDF38;
} // Block from 820CDF28h-820CDF38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CDF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDF38);
		  /* 820CDF38h */ case    0:  		/* li R11, 5 */
		/* 820CDF38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CDF38h case    0:*/		return 0x820CDF3C;
		  /* 820CDF3Ch */ case    1:  		/* addi R10, R31, 8 */
		/* 820CDF3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x8);
		/* 820CDF3Ch case    1:*/		return 0x820CDF40;
		  /* 820CDF40h */ case    2:  		/* addi R9, R30, 8 */
		/* 820CDF40h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x8);
		/* 820CDF40h case    2:*/		return 0x820CDF44;
		  /* 820CDF44h */ case    3:  		/* mtspr CTR, R11 */
		/* 820CDF44h case    3:*/		regs.CTR = regs.R11;
		/* 820CDF44h case    3:*/		return 0x820CDF48;
		  /* 820CDF48h */ case    4:  		/* ldu R11, <#[R10 + 8]> */
		/* 820CDF48h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820CDF48h case    4:*/		return 0x820CDF4C;
		  /* 820CDF4Ch */ case    5:  		/* stdu R11, <#[R9 + 8]> */
		/* 820CDF4Ch case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820CDF4Ch case    5:*/		return 0x820CDF50;
		  /* 820CDF50h */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 820CDF50h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820CDF48;  }
		/* 820CDF50h case    6:*/		return 0x820CDF54;
		  /* 820CDF54h */ case    7:  		/* lwz R11, <#[R31 + 56]> */
		/* 820CDF54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820CDF54h case    7:*/		return 0x820CDF58;
		  /* 820CDF58h */ case    8:  		/* stw R11, <#[R30 + 56]> */
		/* 820CDF58h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 820CDF58h case    8:*/		return 0x820CDF5C;
		  /* 820CDF5Ch */ case    9:  		/* lwz R11, <#[R31 + 60]> */
		/* 820CDF5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CDF5Ch case    9:*/		return 0x820CDF60;
		  /* 820CDF60h */ case   10:  		/* stw R11, <#[R30 + 60]> */
		/* 820CDF60h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 820CDF60h case   10:*/		return 0x820CDF64;
		  /* 820CDF64h */ case   11:  		/* lwz R11, <#[R31 + 64]> */
		/* 820CDF64h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820CDF64h case   11:*/		return 0x820CDF68;
		  /* 820CDF68h */ case   12:  		/* stw R11, <#[R30 + 64]> */
		/* 820CDF68h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000040) );
		/* 820CDF68h case   12:*/		return 0x820CDF6C;
		  /* 820CDF6Ch */ case   13:  		/* lwz R11, <#[R31 + 92]> */
		/* 820CDF6Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 820CDF6Ch case   13:*/		return 0x820CDF70;
		  /* 820CDF70h */ case   14:  		/* stw R11, <#[R30 + 92]> */
		/* 820CDF70h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000005C) );
		/* 820CDF70h case   14:*/		return 0x820CDF74;
		  /* 820CDF74h */ case   15:  		/* lwz R11, <#[R31 + 96]> */
		/* 820CDF74h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820CDF74h case   15:*/		return 0x820CDF78;
		  /* 820CDF78h */ case   16:  		/* stw R11, <#[R30 + 96]> */
		/* 820CDF78h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000060) );
		/* 820CDF78h case   16:*/		return 0x820CDF7C;
		  /* 820CDF7Ch */ case   17:  		/* lwz R11, <#[R31 + 68]> */
		/* 820CDF7Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820CDF7Ch case   17:*/		return 0x820CDF80;
		  /* 820CDF80h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820CDF80h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CDF80h case   18:*/		return 0x820CDF84;
		  /* 820CDF84h */ case   19:  		/* bc 12, CR6_EQ, 36 */
		/* 820CDF84h case   19:*/		if ( regs.CR[6].eq ) { return 0x820CDFA8;  }
		/* 820CDF84h case   19:*/		return 0x820CDF88;
		  /* 820CDF88h */ case   20:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CDF88h case   20:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CDF88h case   20:*/		return 0x820CDF8C;
		  /* 820CDF8Ch */ case   21:  		/* lwz R11, <#[R3]> */
		/* 820CDF8Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CDF8Ch case   21:*/		return 0x820CDF90;
		  /* 820CDF90h */ case   22:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CDF90h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CDF90h case   22:*/		return 0x820CDF94;
		  /* 820CDF94h */ case   23:  		/* mtspr CTR, R11 */
		/* 820CDF94h case   23:*/		regs.CTR = regs.R11;
		/* 820CDF94h case   23:*/		return 0x820CDF98;
		  /* 820CDF98h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 820CDF98h case   24:*/		if ( 1 ) { regs.LR = 0x820CDF9C; return (uint32)regs.CTR; }
		/* 820CDF98h case   24:*/		return 0x820CDF9C;
		  /* 820CDF9Ch */ case   25:  		/* stw R3, <#[R30 + 68]> */
		/* 820CDF9Ch case   25:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000044) );
		/* 820CDF9Ch case   25:*/		return 0x820CDFA0;
		  /* 820CDFA0h */ case   26:  		/* cmplwi CR0, R3, 0 */
		/* 820CDFA0h case   26:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CDFA0h case   26:*/		return 0x820CDFA4;
		  /* 820CDFA4h */ case   27:  		/* bc 12, CR0_EQ, -116 */
		/* 820CDFA4h case   27:*/		if ( regs.CR[0].eq ) { return 0x820CDF30;  }
		/* 820CDFA4h case   27:*/		return 0x820CDFA8;
	}
	return 0x820CDFA8;
} // Block from 820CDF38h-820CDFA8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820CDFA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDFA8);
		  /* 820CDFA8h */ case    0:  		/* lwz R11, <#[R31 + 72]> */
		/* 820CDFA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820CDFA8h case    0:*/		return 0x820CDFAC;
		  /* 820CDFACh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CDFACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CDFACh case    1:*/		return 0x820CDFB0;
		  /* 820CDFB0h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CDFB0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CDFD4;  }
		/* 820CDFB0h case    2:*/		return 0x820CDFB4;
		  /* 820CDFB4h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CDFB4h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CDFB4h case    3:*/		return 0x820CDFB8;
		  /* 820CDFB8h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CDFB8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CDFB8h case    4:*/		return 0x820CDFBC;
		  /* 820CDFBCh */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CDFBCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CDFBCh case    5:*/		return 0x820CDFC0;
		  /* 820CDFC0h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CDFC0h case    6:*/		regs.CTR = regs.R11;
		/* 820CDFC0h case    6:*/		return 0x820CDFC4;
		  /* 820CDFC4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CDFC4h case    7:*/		if ( 1 ) { regs.LR = 0x820CDFC8; return (uint32)regs.CTR; }
		/* 820CDFC4h case    7:*/		return 0x820CDFC8;
		  /* 820CDFC8h */ case    8:  		/* stw R3, <#[R30 + 72]> */
		/* 820CDFC8h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000048) );
		/* 820CDFC8h case    8:*/		return 0x820CDFCC;
		  /* 820CDFCCh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CDFCCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CDFCCh case    9:*/		return 0x820CDFD0;
		  /* 820CDFD0h */ case   10:  		/* bc 12, CR0_EQ, -160 */
		/* 820CDFD0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CDF30;  }
		/* 820CDFD0h case   10:*/		return 0x820CDFD4;
	}
	return 0x820CDFD4;
} // Block from 820CDFA8h-820CDFD4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CDFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CDFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CDFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CDFD4);
		  /* 820CDFD4h */ case    0:  		/* addi R29, R31, 76 */
		/* 820CDFD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x4C);
		/* 820CDFD4h case    0:*/		return 0x820CDFD8;
		  /* 820CDFD8h */ case    1:  		/* li R28, 0 */
		/* 820CDFD8h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820CDFD8h case    1:*/		return 0x820CDFDC;
		  /* 820CDFDCh */ case    2:  		/* subf R31, R31, R30 */
		/* 820CDFDCh case    2:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R31,regs.R30);
		/* 820CDFDCh case    2:*/		return 0x820CDFE0;
		  /* 820CDFE0h */ case    3:  		/* lwz R11, <#[R29]> */
		/* 820CDFE0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820CDFE0h case    3:*/		return 0x820CDFE4;
		  /* 820CDFE4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820CDFE4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CDFE4h case    4:*/		return 0x820CDFE8;
		  /* 820CDFE8h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 820CDFE8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CE00C;  }
		/* 820CDFE8h case    5:*/		return 0x820CDFEC;
		  /* 820CDFECh */ case    6:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CDFECh case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CDFECh case    6:*/		return 0x820CDFF0;
		  /* 820CDFF0h */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820CDFF0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CDFF0h case    7:*/		return 0x820CDFF4;
		  /* 820CDFF4h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CDFF4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CDFF4h case    8:*/		return 0x820CDFF8;
		  /* 820CDFF8h */ case    9:  		/* mtspr CTR, R11 */
		/* 820CDFF8h case    9:*/		regs.CTR = regs.R11;
		/* 820CDFF8h case    9:*/		return 0x820CDFFC;
		  /* 820CDFFCh */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820CDFFCh case   10:*/		if ( 1 ) { regs.LR = 0x820CE000; return (uint32)regs.CTR; }
		/* 820CDFFCh case   10:*/		return 0x820CE000;
		  /* 820CE000h */ case   11:  		/* stwx R3, <#[R31 + R29]> */
		/* 820CE000h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R29 + 0x00000000) );
		/* 820CE000h case   11:*/		return 0x820CE004;
		  /* 820CE004h */ case   12:  		/* cmplwi CR0, R3, 0 */
		/* 820CE004h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CE004h case   12:*/		return 0x820CE008;
		  /* 820CE008h */ case   13:  		/* bc 12, CR0_EQ, -216 */
		/* 820CE008h case   13:*/		if ( regs.CR[0].eq ) { return 0x820CDF30;  }
		/* 820CE008h case   13:*/		return 0x820CE00C;
	}
	return 0x820CE00C;
} // Block from 820CDFD4h-820CE00Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CE00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE00C);
		  /* 820CE00Ch */ case    0:  		/* addi R28, R28, 1 */
		/* 820CE00Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820CE00Ch case    0:*/		return 0x820CE010;
		  /* 820CE010h */ case    1:  		/* addi R29, R29, 4 */
		/* 820CE010h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820CE010h case    1:*/		return 0x820CE014;
		  /* 820CE014h */ case    2:  		/* cmplwi CR6, R28, 4 */
		/* 820CE014h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000004);
		/* 820CE014h case    2:*/		return 0x820CE018;
		  /* 820CE018h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 820CE018h case    3:*/		if ( regs.CR[6].lt ) { return 0x820CDFE0;  }
		/* 820CE018h case    3:*/		return 0x820CE01C;
		  /* 820CE01Ch */ case    4:  		/* mr R3, R30 */
		/* 820CE01Ch case    4:*/		regs.R3 = regs.R30;
		/* 820CE01Ch case    4:*/		return 0x820CE020;
	}
	return 0x820CE020;
} // Block from 820CE00Ch-820CE020h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CE020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE020);
		  /* 820CE020h */ case    0:  		/* addi R1, R1, 128 */
		/* 820CE020h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CE020h case    0:*/		return 0x820CE024;
		  /* 820CE024h */ case    1:  		/* b -249212 */
		/* 820CE024h case    1:*/		return 0x820912A8;
		/* 820CE024h case    1:*/		return 0x820CE028;
	}
	return 0x820CE028;
} // Block from 820CE020h-820CE028h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE028);
		  /* 820CE028h */ case    0:  		/* mfspr R12, LR */
		/* 820CE028h case    0:*/		regs.R12 = regs.LR;
		/* 820CE028h case    0:*/		return 0x820CE02C;
		  /* 820CE02Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CE02Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE02Ch case    1:*/		return 0x820CE030;
		  /* 820CE030h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820CE030h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE030h case    2:*/		return 0x820CE034;
		  /* 820CE034h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CE034h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CE034h case    3:*/		return 0x820CE038;
		  /* 820CE038h */ case    4:  		/* li R4, 25 */
		/* 820CE038h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x19);
		/* 820CE038h case    4:*/		return 0x820CE03C;
		  /* 820CE03Ch */ case    5:  		/* mr R31, R3 */
		/* 820CE03Ch case    5:*/		regs.R31 = regs.R3;
		/* 820CE03Ch case    5:*/		return 0x820CE040;
		  /* 820CE040h */ case    6:  		/* bl -19896 */
		/* 820CE040h case    6:*/		regs.LR = 0x820CE044; return 0x820C9288;
		/* 820CE040h case    6:*/		return 0x820CE044;
		  /* 820CE044h */ case    7:  		/* lis R10, -32255 */
		/* 820CE044h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE044h case    7:*/		return 0x820CE048;
		  /* 820CE048h */ case    8:  		/* li R11, 0 */
		/* 820CE048h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CE048h case    8:*/		return 0x820CE04C;
		  /* 820CE04Ch */ case    9:  		/* addi R10, R10, 11568 */
		/* 820CE04Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2D30);
		/* 820CE04Ch case    9:*/		return 0x820CE050;
		  /* 820CE050h */ case   10:  		/* lis R9, 15 */
		/* 820CE050h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xF);
		/* 820CE050h case   10:*/		return 0x820CE054;
		  /* 820CE054h */ case   11:  		/* stw R11, <#[R31 + 16]> */
		/* 820CE054h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CE054h case   11:*/		return 0x820CE058;
		  /* 820CE058h */ case   12:  		/* lis R8, 228 */
		/* 820CE058h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0xE4);
		/* 820CE058h case   12:*/		return 0x820CE05C;
		  /* 820CE05Ch */ case   13:  		/* stw R10, <#[R31]> */
		/* 820CE05Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE05Ch case   13:*/		return 0x820CE060;
		  /* 820CE060h */ case   14:  		/* stw R11, <#[R31 + 20]> */
		/* 820CE060h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CE060h case   14:*/		return 0x820CE064;
		  /* 820CE064h */ case   15:  		/* mr R3, R31 */
		/* 820CE064h case   15:*/		regs.R3 = regs.R31;
		/* 820CE064h case   15:*/		return 0x820CE068;
		  /* 820CE068h */ case   16:  		/* stw R11, <#[R31 + 24]> */
		/* 820CE068h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CE068h case   16:*/		return 0x820CE06C;
		  /* 820CE06Ch */ case   17:  		/* stw R11, <#[R31 + 28]> */
		/* 820CE06Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CE06Ch case   17:*/		return 0x820CE070;
		  /* 820CE070h */ case   18:  		/* stw R9, <#[R31 + 32]> */
		/* 820CE070h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 820CE070h case   18:*/		return 0x820CE074;
		  /* 820CE074h */ case   19:  		/* stw R8, <#[R31 + 36]> */
		/* 820CE074h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000024) );
		/* 820CE074h case   19:*/		return 0x820CE078;
		  /* 820CE078h */ case   20:  		/* stw R11, <#[R31 + 40]> */
		/* 820CE078h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820CE078h case   20:*/		return 0x820CE07C;
		  /* 820CE07Ch */ case   21:  		/* addi R1, R1, 96 */
		/* 820CE07Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CE07Ch case   21:*/		return 0x820CE080;
		  /* 820CE080h */ case   22:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CE080h case   22:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE080h case   22:*/		return 0x820CE084;
		  /* 820CE084h */ case   23:  		/* mtspr LR, R12 */
		/* 820CE084h case   23:*/		regs.LR = regs.R12;
		/* 820CE084h case   23:*/		return 0x820CE088;
		  /* 820CE088h */ case   24:  		/* ld R31, <#[R1 - 16]> */
		/* 820CE088h case   24:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE088h case   24:*/		return 0x820CE08C;
		  /* 820CE08Ch */ case   25:  		/* bclr 20, CR0_LT */
		/* 820CE08Ch case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE08Ch case   25:*/		return 0x820CE090;
	}
	return 0x820CE090;
} // Block from 820CE028h-820CE090h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820CE090h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE090);
		  /* 820CE090h */ case    0:  		/* mfspr R12, LR */
		/* 820CE090h case    0:*/		regs.R12 = regs.LR;
		/* 820CE090h case    0:*/		return 0x820CE094;
		  /* 820CE094h */ case    1:  		/* bl -249412 */
		/* 820CE094h case    1:*/		regs.LR = 0x820CE098; return 0x82091250;
		/* 820CE094h case    1:*/		return 0x820CE098;
		  /* 820CE098h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820CE098h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820CE098h case    2:*/		return 0x820CE09C;
		  /* 820CE09Ch */ case    3:  		/* mr R30, R4 */
		/* 820CE09Ch case    3:*/		regs.R30 = regs.R4;
		/* 820CE09Ch case    3:*/		return 0x820CE0A0;
		  /* 820CE0A0h */ case    4:  		/* li R4, 25 */
		/* 820CE0A0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x19);
		/* 820CE0A0h case    4:*/		return 0x820CE0A4;
		  /* 820CE0A4h */ case    5:  		/* mr R31, R3 */
		/* 820CE0A4h case    5:*/		regs.R31 = regs.R3;
		/* 820CE0A4h case    5:*/		return 0x820CE0A8;
		  /* 820CE0A8h */ case    6:  		/* mr R29, R5 */
		/* 820CE0A8h case    6:*/		regs.R29 = regs.R5;
		/* 820CE0A8h case    6:*/		return 0x820CE0AC;
		  /* 820CE0ACh */ case    7:  		/* mr R28, R6 */
		/* 820CE0ACh case    7:*/		regs.R28 = regs.R6;
		/* 820CE0ACh case    7:*/		return 0x820CE0B0;
		  /* 820CE0B0h */ case    8:  		/* mr R27, R7 */
		/* 820CE0B0h case    8:*/		regs.R27 = regs.R7;
		/* 820CE0B0h case    8:*/		return 0x820CE0B4;
		  /* 820CE0B4h */ case    9:  		/* mr R26, R8 */
		/* 820CE0B4h case    9:*/		regs.R26 = regs.R8;
		/* 820CE0B4h case    9:*/		return 0x820CE0B8;
		  /* 820CE0B8h */ case   10:  		/* bl -20016 */
		/* 820CE0B8h case   10:*/		regs.LR = 0x820CE0BC; return 0x820C9288;
		/* 820CE0B8h case   10:*/		return 0x820CE0BC;
		  /* 820CE0BCh */ case   11:  		/* lis R11, -32255 */
		/* 820CE0BCh case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CE0BCh case   11:*/		return 0x820CE0C0;
		  /* 820CE0C0h */ case   12:  		/* stw R30, <#[R31 + 16]> */
		/* 820CE0C0h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 820CE0C0h case   12:*/		return 0x820CE0C4;
		  /* 820CE0C4h */ case   13:  		/* lis R10, 15 */
		/* 820CE0C4h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xF);
		/* 820CE0C4h case   13:*/		return 0x820CE0C8;
		  /* 820CE0C8h */ case   14:  		/* stw R29, <#[R31 + 20]> */
		/* 820CE0C8h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000014) );
		/* 820CE0C8h case   14:*/		return 0x820CE0CC;
		  /* 820CE0CCh */ case   15:  		/* addi R11, R11, 11568 */
		/* 820CE0CCh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2D30);
		/* 820CE0CCh case   15:*/		return 0x820CE0D0;
		  /* 820CE0D0h */ case   16:  		/* stw R28, <#[R31 + 24]> */
		/* 820CE0D0h case   16:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000018) );
		/* 820CE0D0h case   16:*/		return 0x820CE0D4;
		  /* 820CE0D4h */ case   17:  		/* lis R9, 228 */
		/* 820CE0D4h case   17:*/		cpu::op::lis<0>(regs,&regs.R9,0xE4);
		/* 820CE0D4h case   17:*/		return 0x820CE0D8;
		  /* 820CE0D8h */ case   18:  		/* stw R27, <#[R31 + 28]> */
		/* 820CE0D8h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CE0D8h case   18:*/		return 0x820CE0DC;
		  /* 820CE0DCh */ case   19:  		/* stw R11, <#[R31]> */
		/* 820CE0DCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE0DCh case   19:*/		return 0x820CE0E0;
		  /* 820CE0E0h */ case   20:  		/* mr R3, R31 */
		/* 820CE0E0h case   20:*/		regs.R3 = regs.R31;
		/* 820CE0E0h case   20:*/		return 0x820CE0E4;
		  /* 820CE0E4h */ case   21:  		/* stw R10, <#[R31 + 32]> */
		/* 820CE0E4h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 820CE0E4h case   21:*/		return 0x820CE0E8;
		  /* 820CE0E8h */ case   22:  		/* stw R9, <#[R31 + 36]> */
		/* 820CE0E8h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 820CE0E8h case   22:*/		return 0x820CE0EC;
		  /* 820CE0ECh */ case   23:  		/* stw R26, <#[R31 + 40]> */
		/* 820CE0ECh case   23:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000028) );
		/* 820CE0ECh case   23:*/		return 0x820CE0F0;
	}
	return 0x820CE0F0;
} // Block from 820CE090h-820CE0F0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820CE0F0h
// Function '?EmitDefaultValue@D3DXShader@@YAJPAVCCommentBlock@1@IIPAVCNode@1@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE0F0);
		  /* 820CE0F0h */ case    0:  		/* addi R1, R1, 144 */
		/* 820CE0F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820CE0F0h case    0:*/		return 0x820CE0F4;
		  /* 820CE0F4h */ case    1:  		/* b -249428 */
		/* 820CE0F4h case    1:*/		return 0x820912A0;
		/* 820CE0F4h case    1:*/		return 0x820CE0F8;
	}
	return 0x820CE0F8;
} // Block from 820CE0F0h-820CE0F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE0F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE0F8);
		  /* 820CE0F8h */ case    0:  		/* mfspr R12, LR */
		/* 820CE0F8h case    0:*/		regs.R12 = regs.LR;
		/* 820CE0F8h case    0:*/		return 0x820CE0FC;
		  /* 820CE0FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CE0FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE0FCh case    1:*/		return 0x820CE100;
		  /* 820CE100h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CE100h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CE100h case    2:*/		return 0x820CE104;
		  /* 820CE104h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CE104h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE104h case    3:*/		return 0x820CE108;
		  /* 820CE108h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CE108h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CE108h case    4:*/		return 0x820CE10C;
		  /* 820CE10Ch */ case    5:  		/* mr R30, R3 */
		/* 820CE10Ch case    5:*/		regs.R30 = regs.R3;
		/* 820CE10Ch case    5:*/		return 0x820CE110;
		  /* 820CE110h */ case    6:  		/* li R3, 44 */
		/* 820CE110h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x2C);
		/* 820CE110h case    6:*/		return 0x820CE114;
		  /* 820CE114h */ case    7:  		/* bl -20204 */
		/* 820CE114h case    7:*/		regs.LR = 0x820CE118; return 0x820C9228;
		/* 820CE114h case    7:*/		return 0x820CE118;
		  /* 820CE118h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820CE118h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CE118h case    8:*/		return 0x820CE11C;
		  /* 820CE11Ch */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 820CE11Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820CE12C;  }
		/* 820CE11Ch case    9:*/		return 0x820CE120;
		  /* 820CE120h */ case   10:  		/* bl -248 */
		/* 820CE120h case   10:*/		regs.LR = 0x820CE124; return 0x820CE028;
		/* 820CE120h case   10:*/		return 0x820CE124;
		  /* 820CE124h */ case   11:  		/* mr R31, R3 */
		/* 820CE124h case   11:*/		regs.R31 = regs.R3;
		/* 820CE124h case   11:*/		return 0x820CE128;
		  /* 820CE128h */ case   12:  		/* b 8 */
		/* 820CE128h case   12:*/		return 0x820CE130;
		/* 820CE128h case   12:*/		return 0x820CE12C;
	}
	return 0x820CE12C;
} // Block from 820CE0F8h-820CE12Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CE12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE12C);
		  /* 820CE12Ch */ case    0:  		/* li R31, 0 */
		/* 820CE12Ch case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CE12Ch case    0:*/		return 0x820CE130;
	}
	return 0x820CE130;
} // Block from 820CE12Ch-820CE130h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE130);
		  /* 820CE130h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CE130h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CE130h case    0:*/		return 0x820CE134;
		  /* 820CE134h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CE134h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CE140;  }
		/* 820CE134h case    1:*/		return 0x820CE138;
		  /* 820CE138h */ case    2:  		/* li R3, 0 */
		/* 820CE138h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CE138h case    2:*/		return 0x820CE13C;
		  /* 820CE13Ch */ case    3:  		/* b 104 */
		/* 820CE13Ch case    3:*/		return 0x820CE1A4;
		/* 820CE13Ch case    3:*/		return 0x820CE140;
	}
	return 0x820CE140;
} // Block from 820CE130h-820CE140h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE140);
		  /* 820CE140h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CE140h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CE140h case    0:*/		return 0x820CE144;
		  /* 820CE144h */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820CE144h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CE144h case    1:*/		return 0x820CE148;
		  /* 820CE148h */ case    2:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CE148h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CE148h case    2:*/		return 0x820CE14C;
		  /* 820CE14Ch */ case    3:  		/* stw R11, <#[R31 + 20]> */
		/* 820CE14Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CE14Ch case    3:*/		return 0x820CE150;
		  /* 820CE150h */ case    4:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CE150h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CE150h case    4:*/		return 0x820CE154;
		  /* 820CE154h */ case    5:  		/* stw R11, <#[R31 + 24]> */
		/* 820CE154h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CE154h case    5:*/		return 0x820CE158;
		  /* 820CE158h */ case    6:  		/* lwz R11, <#[R30 + 28]> */
		/* 820CE158h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CE158h case    6:*/		return 0x820CE15C;
		  /* 820CE15Ch */ case    7:  		/* stw R11, <#[R31 + 28]> */
		/* 820CE15Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CE15Ch case    7:*/		return 0x820CE160;
		  /* 820CE160h */ case    8:  		/* lwz R11, <#[R30 + 32]> */
		/* 820CE160h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820CE160h case    8:*/		return 0x820CE164;
		  /* 820CE164h */ case    9:  		/* stw R11, <#[R31 + 32]> */
		/* 820CE164h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820CE164h case    9:*/		return 0x820CE168;
		  /* 820CE168h */ case   10:  		/* lwz R11, <#[R30 + 36]> */
		/* 820CE168h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820CE168h case   10:*/		return 0x820CE16C;
		  /* 820CE16Ch */ case   11:  		/* stw R11, <#[R31 + 36]> */
		/* 820CE16Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820CE16Ch case   11:*/		return 0x820CE170;
		  /* 820CE170h */ case   12:  		/* lwz R11, <#[R30 + 40]> */
		/* 820CE170h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820CE170h case   12:*/		return 0x820CE174;
		  /* 820CE174h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 820CE174h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CE174h case   13:*/		return 0x820CE178;
		  /* 820CE178h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 820CE178h case   14:*/		if ( regs.CR[6].eq ) { return 0x820CE1A0;  }
		/* 820CE178h case   14:*/		return 0x820CE17C;
		  /* 820CE17Ch */ case   15:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CE17Ch case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CE17Ch case   15:*/		return 0x820CE180;
		  /* 820CE180h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 820CE180h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CE180h case   16:*/		return 0x820CE184;
		  /* 820CE184h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CE184h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CE184h case   17:*/		return 0x820CE188;
		  /* 820CE188h */ case   18:  		/* mtspr CTR, R11 */
		/* 820CE188h case   18:*/		regs.CTR = regs.R11;
		/* 820CE188h case   18:*/		return 0x820CE18C;
		  /* 820CE18Ch */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820CE18Ch case   19:*/		if ( 1 ) { regs.LR = 0x820CE190; return (uint32)regs.CTR; }
		/* 820CE18Ch case   19:*/		return 0x820CE190;
		  /* 820CE190h */ case   20:  		/* stw R3, <#[R31 + 40]> */
		/* 820CE190h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 820CE190h case   20:*/		return 0x820CE194;
		  /* 820CE194h */ case   21:  		/* cmplwi CR0, R3, 0 */
		/* 820CE194h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CE194h case   21:*/		return 0x820CE198;
		  /* 820CE198h */ case   22:  		/* li R3, 0 */
		/* 820CE198h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CE198h case   22:*/		return 0x820CE19C;
		  /* 820CE19Ch */ case   23:  		/* bc 12, CR0_EQ, 8 */
		/* 820CE19Ch case   23:*/		if ( regs.CR[0].eq ) { return 0x820CE1A4;  }
		/* 820CE19Ch case   23:*/		return 0x820CE1A0;
	}
	return 0x820CE1A0;
} // Block from 820CE140h-820CE1A0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1A0);
		  /* 820CE1A0h */ case    0:  		/* mr R3, R31 */
		/* 820CE1A0h case    0:*/		regs.R3 = regs.R31;
		/* 820CE1A0h case    0:*/		return 0x820CE1A4;
	}
	return 0x820CE1A4;
} // Block from 820CE1A0h-820CE1A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1A4);
		  /* 820CE1A4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CE1A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CE1A4h case    0:*/		return 0x820CE1A8;
		  /* 820CE1A8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CE1A8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE1A8h case    1:*/		return 0x820CE1AC;
		  /* 820CE1ACh */ case    2:  		/* mtspr LR, R12 */
		/* 820CE1ACh case    2:*/		regs.LR = regs.R12;
		/* 820CE1ACh case    2:*/		return 0x820CE1B0;
		  /* 820CE1B0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CE1B0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CE1B0h case    3:*/		return 0x820CE1B4;
		  /* 820CE1B4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CE1B4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE1B4h case    4:*/		return 0x820CE1B8;
		  /* 820CE1B8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CE1B8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE1B8h case    5:*/		return 0x820CE1BC;
	}
	return 0x820CE1BC;
} // Block from 820CE1A4h-820CE1BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1BC);
		  /* 820CE1BCh */ case    0:  		/* nop */
		/* 820CE1BCh case    0:*/		cpu::op::nop();
		/* 820CE1BCh case    0:*/		return 0x820CE1C0;
	}
	return 0x820CE1C0;
} // Block from 820CE1BCh-820CE1C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1C0);
		  /* 820CE1C0h */ case    0:  		/* li R10, 0 */
		/* 820CE1C0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CE1C0h case    0:*/		return 0x820CE1C4;
		  /* 820CE1C4h */ case    1:  		/* stw R4, <#[R3]> */
		/* 820CE1C4h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 820CE1C4h case    1:*/		return 0x820CE1C8;
		  /* 820CE1C8h */ case    2:  		/* addi R11, R3, 8 */
		/* 820CE1C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x8);
		/* 820CE1C8h case    2:*/		return 0x820CE1CC;
		  /* 820CE1CCh */ case    3:  		/* stw R10, <#[R3 + 4]> */
		/* 820CE1CCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CE1CCh case    3:*/		return 0x820CE1D0;
		  /* 820CE1D0h */ case    4:  		/* stw R11, <#[R3 + 12]> */
		/* 820CE1D0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CE1D0h case    4:*/		return 0x820CE1D4;
		  /* 820CE1D4h */ case    5:  		/* stw R10, <#[R3 + 8]> */
		/* 820CE1D4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820CE1D4h case    5:*/		return 0x820CE1D8;
		  /* 820CE1D8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820CE1D8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE1D8h case    6:*/		return 0x820CE1DC;
	}
	return 0x820CE1DC;
} // Block from 820CE1C0h-820CE1DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1DC);
		  /* 820CE1DCh */ case    0:  		/* nop */
		/* 820CE1DCh case    0:*/		cpu::op::nop();
		/* 820CE1DCh case    0:*/		return 0x820CE1E0;
	}
	return 0x820CE1E0;
} // Block from 820CE1DCh-820CE1E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1E0);
		  /* 820CE1E0h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 820CE1E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820CE1E0h case    0:*/		return 0x820CE1E4;
		  /* 820CE1E4h */ case    1:  		/* addi R11, R11, 3 */
		/* 820CE1E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820CE1E4h case    1:*/		return 0x820CE1E8;
		  /* 820CE1E8h */ case    2:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820CE1E8h case    2:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820CE1E8h case    2:*/		return 0x820CE1EC;
		  /* 820CE1ECh */ case    3:  		/* addi R3, R11, 2 */
		/* 820CE1ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2);
		/* 820CE1ECh case    3:*/		return 0x820CE1F0;
		  /* 820CE1F0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820CE1F0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE1F0h case    4:*/		return 0x820CE1F4;
	}
	return 0x820CE1F4;
} // Block from 820CE1E0h-820CE1F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1F4);
		  /* 820CE1F4h */ case    0:  		/* nop */
		/* 820CE1F4h case    0:*/		cpu::op::nop();
		/* 820CE1F4h case    0:*/		return 0x820CE1F8;
	}
	return 0x820CE1F8;
} // Block from 820CE1F4h-820CE1F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE1F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE1F8);
		  /* 820CE1F8h */ case    0:  		/* mfspr R12, LR */
		/* 820CE1F8h case    0:*/		regs.R12 = regs.LR;
		/* 820CE1F8h case    0:*/		return 0x820CE1FC;
		  /* 820CE1FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CE1FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE1FCh case    1:*/		return 0x820CE200;
		  /* 820CE200h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CE200h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CE200h case    2:*/		return 0x820CE204;
		  /* 820CE204h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CE204h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE204h case    3:*/		return 0x820CE208;
		  /* 820CE208h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CE208h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CE208h case    4:*/		return 0x820CE20C;
		  /* 820CE20Ch */ case    5:  		/* mr R30, R3 */
		/* 820CE20Ch case    5:*/		regs.R30 = regs.R3;
		/* 820CE20Ch case    5:*/		return 0x820CE210;
		  /* 820CE210h */ case    6:  		/* b 60 */
		/* 820CE210h case    6:*/		return 0x820CE24C;
		/* 820CE210h case    6:*/		return 0x820CE214;
		  /* 820CE214h */ case    7:  		/* lwz R31, <#[R30 + 8]> */
		/* 820CE214h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000008) );
		/* 820CE214h case    7:*/		return 0x820CE218;
		  /* 820CE218h */ case    8:  		/* lwz R11, <#[R31 + 16]> */
		/* 820CE218h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CE218h case    8:*/		return 0x820CE21C;
		  /* 820CE21Ch */ case    9:  		/* stw R11, <#[R30 + 8]> */
		/* 820CE21Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820CE21Ch case    9:*/		return 0x820CE220;
		  /* 820CE220h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 820CE220h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820CE220h case   10:*/		return 0x820CE224;
		  /* 820CE224h */ case   11:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 820CE224h case   11:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 820CE224h case   11:*/		return 0x820CE228;
	}
	return 0x820CE228;
} // Block from 820CE1F8h-820CE228h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE228h
// Function '?EmitZeroDefaultValue@D3DXShader@@YAJPAVCCommentBlock@1@IPAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE228);
		  /* 820CE228h */ case    0:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE228h case    0:*/		if ( !regs.CR[0].eq ) { return 0x820CE234;  }
		/* 820CE228h case    0:*/		return 0x820CE22C;
		  /* 820CE22Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820CE22Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820CE22Ch case    1:*/		return 0x820CE230;
		  /* 820CE230h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820CE230h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820CE240;  }
		/* 820CE230h case    2:*/		return 0x820CE234;
	}
	return 0x820CE234;
} // Block from 820CE228h-820CE234h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE234);
		  /* 820CE234h */ case    0:  		/* lis R4, 9345 */
		/* 820CE234h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CE234h case    0:*/		return 0x820CE238;
		  /* 820CE238h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820CE238h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE238h case    1:*/		return 0x820CE23C;
		  /* 820CE23Ch */ case    2:  		/* bl -286468 */
		/* 820CE23Ch case    2:*/		regs.LR = 0x820CE240; return 0x82088338;
		/* 820CE23Ch case    2:*/		return 0x820CE240;
	}
	return 0x820CE240;
} // Block from 820CE234h-820CE240h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE240);
		  /* 820CE240h */ case    0:  		/* lis R4, 9345 */
		/* 820CE240h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CE240h case    0:*/		return 0x820CE244;
		  /* 820CE244h */ case    1:  		/* mr R3, R31 */
		/* 820CE244h case    1:*/		regs.R3 = regs.R31;
		/* 820CE244h case    1:*/		return 0x820CE248;
		  /* 820CE248h */ case    2:  		/* bl -286480 */
		/* 820CE248h case    2:*/		regs.LR = 0x820CE24C; return 0x82088338;
		/* 820CE248h case    2:*/		return 0x820CE24C;
	}
	return 0x820CE24C;
} // Block from 820CE240h-820CE24Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE24C);
		  /* 820CE24Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820CE24Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820CE24Ch case    0:*/		return 0x820CE250;
		  /* 820CE250h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CE250h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CE250h case    1:*/		return 0x820CE254;
		  /* 820CE254h */ case    2:  		/* bc 4, CR6_EQ, -64 */
		/* 820CE254h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CE214;  }
		/* 820CE254h case    2:*/		return 0x820CE258;
		  /* 820CE258h */ case    3:  		/* addi R1, R1, 112 */
		/* 820CE258h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CE258h case    3:*/		return 0x820CE25C;
		  /* 820CE25Ch */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CE25Ch case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE25Ch case    4:*/		return 0x820CE260;
		  /* 820CE260h */ case    5:  		/* mtspr LR, R12 */
		/* 820CE260h case    5:*/		regs.LR = regs.R12;
		/* 820CE260h case    5:*/		return 0x820CE264;
		  /* 820CE264h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 820CE264h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CE264h case    6:*/		return 0x820CE268;
		  /* 820CE268h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 820CE268h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE268h case    7:*/		return 0x820CE26C;
		  /* 820CE26Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 820CE26Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE26Ch case    8:*/		return 0x820CE270;
	}
	return 0x820CE270;
} // Block from 820CE24Ch-820CE270h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CE270h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE270);
		  /* 820CE270h */ case    0:  		/* mfspr R12, LR */
		/* 820CE270h case    0:*/		regs.R12 = regs.LR;
		/* 820CE270h case    0:*/		return 0x820CE274;
		  /* 820CE274h */ case    1:  		/* bl -249896 */
		/* 820CE274h case    1:*/		regs.LR = 0x820CE278; return 0x8209124C;
		/* 820CE274h case    1:*/		return 0x820CE278;
		  /* 820CE278h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820CE278h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820CE278h case    2:*/		return 0x820CE27C;
		  /* 820CE27Ch */ case    3:  		/* mr R29, R3 */
		/* 820CE27Ch case    3:*/		regs.R29 = regs.R3;
		/* 820CE27Ch case    3:*/		return 0x820CE280;
		  /* 820CE280h */ case    4:  		/* mr R28, R4 */
		/* 820CE280h case    4:*/		regs.R28 = regs.R4;
		/* 820CE280h case    4:*/		return 0x820CE284;
		  /* 820CE284h */ case    5:  		/* mr R30, R5 */
		/* 820CE284h case    5:*/		regs.R30 = regs.R5;
		/* 820CE284h case    5:*/		return 0x820CE288;
		  /* 820CE288h */ case    6:  		/* mr R27, R6 */
		/* 820CE288h case    6:*/		regs.R27 = regs.R6;
		/* 820CE288h case    6:*/		return 0x820CE28C;
		  /* 820CE28Ch */ case    7:  		/* mr R26, R7 */
		/* 820CE28Ch case    7:*/		regs.R26 = regs.R7;
		/* 820CE28Ch case    7:*/		return 0x820CE290;
		  /* 820CE290h */ case    8:  		/* mr R25, R8 */
		/* 820CE290h case    8:*/		regs.R25 = regs.R8;
		/* 820CE290h case    8:*/		return 0x820CE294;
		  /* 820CE294h */ case    9:  		/* cmplwi CR6, R5, 0 */
		/* 820CE294h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820CE294h case    9:*/		return 0x820CE298;
		  /* 820CE298h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 820CE298h case   10:*/		if ( regs.CR[6].eq ) { return 0x820CE2B0;  }
		/* 820CE298h case   10:*/		return 0x820CE29C;
		  /* 820CE29Ch */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 820CE29Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CE29Ch case   11:*/		return 0x820CE2A0;
		  /* 820CE2A0h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 820CE2A0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CE2B0;  }
		/* 820CE2A0h case   12:*/		return 0x820CE2A4;
		  /* 820CE2A4h */ case   13:  		/* lis R3, -32768 */
		/* 820CE2A4h case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CE2A4h case   13:*/		return 0x820CE2A8;
		  /* 820CE2A8h */ case   14:  		/* ori R3, R3, 16389 */
		/* 820CE2A8h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CE2A8h case   14:*/		return 0x820CE2AC;
		  /* 820CE2ACh */ case   15:  		/* b 424 */
		/* 820CE2ACh case   15:*/		return 0x820CE454;
		/* 820CE2ACh case   15:*/		return 0x820CE2B0;
	}
	return 0x820CE2B0;
} // Block from 820CE270h-820CE2B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CE2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE2B0);
		  /* 820CE2B0h */ case    0:  		/* cmpwi CR6, R30, -1 */
		/* 820CE2B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 820CE2B0h case    0:*/		return 0x820CE2B4;
		  /* 820CE2B4h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 820CE2B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CE2DC;  }
		/* 820CE2B4h case    1:*/		return 0x820CE2B8;
		  /* 820CE2B8h */ case    2:  		/* mr R11, R28 */
		/* 820CE2B8h case    2:*/		regs.R11 = regs.R28;
		/* 820CE2B8h case    2:*/		return 0x820CE2BC;
		  /* 820CE2BCh */ case    3:  		/* lbz R10, <#[R11]> */
		/* 820CE2BCh case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE2BCh case    3:*/		return 0x820CE2C0;
	}
	return 0x820CE2C0;
} // Block from 820CE2B0h-820CE2C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE2C0h
// Function '?AddRegister@CFragmentConstants@D3DXShader@@QAAJPAVCCommentBlock@2@PAU_D3DXSHADER_CONSTANTINFO@@PBDIK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE2C0);
		  /* 820CE2C0h */ case    0:  		/* addi R11, R11, 1 */
		/* 820CE2C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE2C0h case    0:*/		return 0x820CE2C4;
		  /* 820CE2C4h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820CE2C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CE2C4h case    1:*/		return 0x820CE2C8;
		  /* 820CE2C8h */ case    2:  		/* bc 4, CR6_EQ, -12 */
		/* 820CE2C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CE2BC;  }
		/* 820CE2C8h case    2:*/		return 0x820CE2CC;
		  /* 820CE2CCh */ case    3:  		/* subf R11, R28, R11 */
		/* 820CE2CCh case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 820CE2CCh case    3:*/		return 0x820CE2D0;
		  /* 820CE2D0h */ case    4:  		/* addi R11, R11, -1 */
		/* 820CE2D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820CE2D0h case    4:*/		return 0x820CE2D4;
		  /* 820CE2D4h */ case    5:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820CE2D4h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820CE2D4h case    5:*/		return 0x820CE2D8;
		  /* 820CE2D8h */ case    6:  		/* addi R30, R11, 1 */
		/* 820CE2D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 820CE2D8h case    6:*/		return 0x820CE2DC;
	}
	return 0x820CE2DC;
} // Block from 820CE2C0h-820CE2DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CE2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE2DC);
		  /* 820CE2DCh */ case    0:  		/* rlwinm. R11, R27, 0, 31, 31 */
		/* 820CE2DCh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R27);
		/* 820CE2DCh case    0:*/		return 0x820CE2E0;
		  /* 820CE2E0h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 820CE2E0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE2E8;  }
		/* 820CE2E0h case    1:*/		return 0x820CE2E4;
		  /* 820CE2E4h */ case    2:  		/* ori R27, R27, 2 */
		/* 820CE2E4h case    2:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x2);
		/* 820CE2E4h case    2:*/		return 0x820CE2E8;
	}
	return 0x820CE2E8;
} // Block from 820CE2DCh-820CE2E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE2E8);
		  /* 820CE2E8h */ case    0:  		/* rlwinm. R11, R27, 0, 30, 30 */
		/* 820CE2E8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R27);
		/* 820CE2E8h case    0:*/		return 0x820CE2EC;
		  /* 820CE2ECh */ case    1:  		/* bc 12, CR0_EQ, 112 */
		/* 820CE2ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x820CE35C;  }
		/* 820CE2ECh case    1:*/		return 0x820CE2F0;
		  /* 820CE2F0h */ case    2:  		/* lwz R8, <#[R29 + 8]> */
		/* 820CE2F0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000008) );
		/* 820CE2F0h case    2:*/		return 0x820CE2F4;
		  /* 820CE2F4h */ case    3:  		/* b 96 */
		/* 820CE2F4h case    3:*/		return 0x820CE354;
		/* 820CE2F4h case    3:*/		return 0x820CE2F8;
		  /* 820CE2F8h */ case    4:  		/* lwz R11, <#[R8 + 8]> */
		/* 820CE2F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 820CE2F8h case    4:*/		return 0x820CE2FC;
		  /* 820CE2FCh */ case    5:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820CE2FCh case    5:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820CE2FCh case    5:*/		return 0x820CE300;
		  /* 820CE300h */ case    6:  		/* bc 12, CR0_EQ, 80 */
		/* 820CE300h case    6:*/		if ( regs.CR[0].eq ) { return 0x820CE350;  }
		/* 820CE300h case    6:*/		return 0x820CE304;
		  /* 820CE304h */ case    7:  		/* lwz R11, <#[R8 + 4]> */
		/* 820CE304h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820CE304h case    7:*/		return 0x820CE308;
		  /* 820CE308h */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 820CE308h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820CE308h case    8:*/		return 0x820CE30C;
		  /* 820CE30Ch */ case    9:  		/* bc 4, CR6_EQ, 68 */
		/* 820CE30Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820CE350;  }
		/* 820CE30Ch case    9:*/		return 0x820CE310;
		  /* 820CE310h */ case   10:  		/* lwz R10, <#[R8]> */
		/* 820CE310h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820CE310h case   10:*/		return 0x820CE314;
		  /* 820CE314h */ case   11:  		/* mr R11, R28 */
		/* 820CE314h case   11:*/		regs.R11 = regs.R28;
		/* 820CE314h case   11:*/		return 0x820CE318;
		  /* 820CE318h */ case   12:  		/* li R9, 0 */
		/* 820CE318h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CE318h case   12:*/		return 0x820CE31C;
		  /* 820CE31Ch */ case   13:  		/* cmplwi CR0, R30, 0 */
		/* 820CE31Ch case   13:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820CE31Ch case   13:*/		return 0x820CE320;
		  /* 820CE320h */ case   14:  		/* bc 12, CR0_EQ, 40 */
		/* 820CE320h case   14:*/		if ( regs.CR[0].eq ) { return 0x820CE348;  }
		/* 820CE320h case   14:*/		return 0x820CE324;
		  /* 820CE324h */ case   15:  		/* add R7, R28, R30 */
		/* 820CE324h case   15:*/		cpu::op::add<0>(regs,&regs.R7,regs.R28,regs.R30);
		/* 820CE324h case   15:*/		return 0x820CE328;
		  /* 820CE328h */ case   16:  		/* lbz R9, <#[R11]> */
		/* 820CE328h case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE328h case   16:*/		return 0x820CE32C;
		  /* 820CE32Ch */ case   17:  		/* lbz R6, <#[R10]> */
		/* 820CE32Ch case   17:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE32Ch case   17:*/		return 0x820CE330;
		  /* 820CE330h */ case   18:  		/* subf. R9, R6, R9 */
		/* 820CE330h case   18:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820CE330h case   18:*/		return 0x820CE334;
		  /* 820CE334h */ case   19:  		/* bc 4, CR0_EQ, 20 */
		/* 820CE334h case   19:*/		if ( !regs.CR[0].eq ) { return 0x820CE348;  }
		/* 820CE334h case   19:*/		return 0x820CE338;
		  /* 820CE338h */ case   20:  		/* addi R11, R11, 1 */
		/* 820CE338h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE338h case   20:*/		return 0x820CE33C;
		  /* 820CE33Ch */ case   21:  		/* addi R10, R10, 1 */
		/* 820CE33Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE33Ch case   21:*/		return 0x820CE340;
		  /* 820CE340h */ case   22:  		/* cmpw CR6, R11, R7 */
		/* 820CE340h case   22:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R7);
		/* 820CE340h case   22:*/		return 0x820CE344;
		  /* 820CE344h */ case   23:  		/* bc 4, CR6_EQ, -28 */
		/* 820CE344h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820CE328;  }
		/* 820CE344h case   23:*/		return 0x820CE348;
	}
	return 0x820CE348;
} // Block from 820CE2E8h-820CE348h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820CE348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE348);
		  /* 820CE348h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE348h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE348h case    0:*/		return 0x820CE34C;
		  /* 820CE34Ch */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 820CE34Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820CE37C;  }
		/* 820CE34Ch case    1:*/		return 0x820CE350;
	}
	return 0x820CE350;
} // Block from 820CE348h-820CE350h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE350);
		  /* 820CE350h */ case    0:  		/* lwz R8, <#[R8 + 16]> */
		/* 820CE350h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000010) );
		/* 820CE350h case    0:*/		return 0x820CE354;
	}
	return 0x820CE354;
} // Block from 820CE350h-820CE354h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE354);
		  /* 820CE354h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820CE354h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820CE354h case    0:*/		return 0x820CE358;
		  /* 820CE358h */ case    1:  		/* bc 4, CR6_EQ, -96 */
		/* 820CE358h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CE2F8;  }
		/* 820CE358h case    1:*/		return 0x820CE35C;
	}
	return 0x820CE35C;
} // Block from 820CE354h-820CE35Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE35Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE35C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE35C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE35C);
		  /* 820CE35Ch */ case    0:  		/* lis R4, 9345 */
		/* 820CE35Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CE35Ch case    0:*/		return 0x820CE360;
		  /* 820CE360h */ case    1:  		/* li R3, 24 */
		/* 820CE360h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x18);
		/* 820CE360h case    1:*/		return 0x820CE364;
		  /* 820CE364h */ case    2:  		/* bl -287076 */
		/* 820CE364h case    2:*/		regs.LR = 0x820CE368; return 0x82088200;
		/* 820CE364h case    2:*/		return 0x820CE368;
		  /* 820CE368h */ case    3:  		/* or. R31, R3, R3 */
		/* 820CE368h case    3:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820CE368h case    3:*/		return 0x820CE36C;
		  /* 820CE36Ch */ case    4:  		/* bc 4, CR0_EQ, 64 */
		/* 820CE36Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x820CE3AC;  }
		/* 820CE36Ch case    4:*/		return 0x820CE370;
		  /* 820CE370h */ case    5:  		/* lis R3, -32761 */
		/* 820CE370h case    5:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820CE370h case    5:*/		return 0x820CE374;
		  /* 820CE374h */ case    6:  		/* ori R3, R3, 14 */
		/* 820CE374h case    6:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820CE374h case    6:*/		return 0x820CE378;
		  /* 820CE378h */ case    7:  		/* b 220 */
		/* 820CE378h case    7:*/		return 0x820CE454;
		/* 820CE378h case    7:*/		return 0x820CE37C;
	}
	return 0x820CE37C;
} // Block from 820CE35Ch-820CE37Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CE37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE37C);
		  /* 820CE37Ch */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820CE37Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820CE37Ch case    0:*/		return 0x820CE380;
		  /* 820CE380h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820CE380h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CE38C;  }
		/* 820CE380h case    1:*/		return 0x820CE384;
		  /* 820CE384h */ case    2:  		/* lwz R11, <#[R8 + 12]> */
		/* 820CE384h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 820CE384h case    2:*/		return 0x820CE388;
		  /* 820CE388h */ case    3:  		/* stw R11, <#[R26]> */
		/* 820CE388h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820CE388h case    3:*/		return 0x820CE38C;
	}
	return 0x820CE38C;
} // Block from 820CE37Ch-820CE38Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE38C);
		  /* 820CE38Ch */ case    0:  		/* rlwinm. R11, R27, 0, 31, 31 */
		/* 820CE38Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R27);
		/* 820CE38Ch case    0:*/		return 0x820CE390;
		  /* 820CE390h */ case    1:  		/* bc 12, CR0_EQ, 192 */
		/* 820CE390h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CE450;  }
		/* 820CE390h case    1:*/		return 0x820CE394;
		  /* 820CE394h */ case    2:  		/* rlwinm. R11, R27, 0, 28, 28 */
		/* 820CE394h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R27);
		/* 820CE394h case    2:*/		return 0x820CE398;
		  /* 820CE398h */ case    3:  		/* bc 12, CR0_EQ, 184 */
		/* 820CE398h case    3:*/		if ( regs.CR[0].eq ) { return 0x820CE450;  }
		/* 820CE398h case    3:*/		return 0x820CE39C;
		  /* 820CE39Ch */ case    4:  		/* lis R4, 9345 */
		/* 820CE39Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CE39Ch case    4:*/		return 0x820CE3A0;
		  /* 820CE3A0h */ case    5:  		/* mr R3, R28 */
		/* 820CE3A0h case    5:*/		regs.R3 = regs.R28;
		/* 820CE3A0h case    5:*/		return 0x820CE3A4;
		  /* 820CE3A4h */ case    6:  		/* bl -286828 */
		/* 820CE3A4h case    6:*/		regs.LR = 0x820CE3A8; return 0x82088338;
		/* 820CE3A4h case    6:*/		return 0x820CE3A8;
		  /* 820CE3A8h */ case    7:  		/* b 168 */
		/* 820CE3A8h case    7:*/		return 0x820CE450;
		/* 820CE3A8h case    7:*/		return 0x820CE3AC;
	}
	return 0x820CE3AC;
} // Block from 820CE38Ch-820CE3ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CE3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE3AC);
		  /* 820CE3ACh */ case    0:  		/* rlwinm. R11, R27, 0, 31, 31 */
		/* 820CE3ACh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R27);
		/* 820CE3ACh case    0:*/		return 0x820CE3B0;
		  /* 820CE3B0h */ case    1:  		/* bc 4, CR0_EQ, 60 */
		/* 820CE3B0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE3EC;  }
		/* 820CE3B0h case    1:*/		return 0x820CE3B4;
		  /* 820CE3B4h */ case    2:  		/* lis R4, 9345 */
		/* 820CE3B4h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CE3B4h case    2:*/		return 0x820CE3B8;
		  /* 820CE3B8h */ case    3:  		/* mr R3, R30 */
		/* 820CE3B8h case    3:*/		regs.R3 = regs.R30;
		/* 820CE3B8h case    3:*/		return 0x820CE3BC;
		  /* 820CE3BCh */ case    4:  		/* bl -287164 */
		/* 820CE3BCh case    4:*/		regs.LR = 0x820CE3C0; return 0x82088200;
		/* 820CE3BCh case    4:*/		return 0x820CE3C0;
		  /* 820CE3C0h */ case    5:  		/* stw R3, <#[R31]> */
		/* 820CE3C0h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE3C0h case    5:*/		return 0x820CE3C4;
		  /* 820CE3C4h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820CE3C4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CE3C4h case    6:*/		return 0x820CE3C8;
		  /* 820CE3C8h */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 820CE3C8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820CE3DC;  }
		/* 820CE3C8h case    7:*/		return 0x820CE3CC;
		  /* 820CE3CCh */ case    8:  		/* lis R4, 9345 */
		/* 820CE3CCh case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820CE3CCh case    8:*/		return 0x820CE3D0;
		  /* 820CE3D0h */ case    9:  		/* mr R3, R31 */
		/* 820CE3D0h case    9:*/		regs.R3 = regs.R31;
		/* 820CE3D0h case    9:*/		return 0x820CE3D4;
		  /* 820CE3D4h */ case   10:  		/* bl -286876 */
		/* 820CE3D4h case   10:*/		regs.LR = 0x820CE3D8; return 0x82088338;
		/* 820CE3D4h case   10:*/		return 0x820CE3D8;
		  /* 820CE3D8h */ case   11:  		/* b -104 */
		/* 820CE3D8h case   11:*/		return 0x820CE370;
		/* 820CE3D8h case   11:*/		return 0x820CE3DC;
	}
	return 0x820CE3DC;
} // Block from 820CE3ACh-820CE3DCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE3DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE3DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE3DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE3DC);
		  /* 820CE3DCh */ case    0:  		/* mr R5, R30 */
		/* 820CE3DCh case    0:*/		regs.R5 = regs.R30;
		/* 820CE3DCh case    0:*/		return 0x820CE3E0;
		  /* 820CE3E0h */ case    1:  		/* mr R4, R28 */
		/* 820CE3E0h case    1:*/		regs.R4 = regs.R28;
		/* 820CE3E0h case    1:*/		return 0x820CE3E4;
		  /* 820CE3E4h */ case    2:  		/* bl -248372 */
		/* 820CE3E4h case    2:*/		regs.LR = 0x820CE3E8; return 0x820919B0;
		/* 820CE3E4h case    2:*/		return 0x820CE3E8;
		  /* 820CE3E8h */ case    3:  		/* b 8 */
		/* 820CE3E8h case    3:*/		return 0x820CE3F0;
		/* 820CE3E8h case    3:*/		return 0x820CE3EC;
	}
	return 0x820CE3EC;
} // Block from 820CE3DCh-820CE3ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE3EC);
		  /* 820CE3ECh */ case    0:  		/* stw R28, <#[R31]> */
		/* 820CE3ECh case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE3ECh case    0:*/		return 0x820CE3F0;
	}
	return 0x820CE3F0;
} // Block from 820CE3ECh-820CE3F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE3F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE3F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE3F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE3F0);
		  /* 820CE3F0h */ case    0:  		/* rlwinm. R11, R27, 0, 29, 29 */
		/* 820CE3F0h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R27);
		/* 820CE3F0h case    0:*/		return 0x820CE3F4;
		  /* 820CE3F4h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 820CE3F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE408;  }
		/* 820CE3F4h case    1:*/		return 0x820CE3F8;
		  /* 820CE3F8h */ case    2:  		/* lwz R11, <#[R29 + 4]> */
		/* 820CE3F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820CE3F8h case    2:*/		return 0x820CE3FC;
		  /* 820CE3FCh */ case    3:  		/* addi R11, R11, 3 */
		/* 820CE3FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820CE3FCh case    3:*/		return 0x820CE400;
		  /* 820CE400h */ case    4:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 820CE400h case    4:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 820CE400h case    4:*/		return 0x820CE404;
		  /* 820CE404h */ case    5:  		/* stw R11, <#[R29 + 4]> */
		/* 820CE404h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820CE404h case    5:*/		return 0x820CE408;
	}
	return 0x820CE408;
} // Block from 820CE3F0h-820CE408h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CE408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE408);
		  /* 820CE408h */ case    0:  		/* lwz R10, <#[R29 + 4]> */
		/* 820CE408h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 820CE408h case    0:*/		return 0x820CE40C;
		  /* 820CE40Ch */ case    1:  		/* li R9, 0 */
		/* 820CE40Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CE40Ch case    1:*/		return 0x820CE410;
		  /* 820CE410h */ case    2:  		/* stw R30, <#[R31 + 4]> */
		/* 820CE410h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 820CE410h case    2:*/		return 0x820CE414;
		  /* 820CE414h */ case    3:  		/* addi R11, R31, 16 */
		/* 820CE414h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x10);
		/* 820CE414h case    3:*/		return 0x820CE418;
		  /* 820CE418h */ case    4:  		/* stw R27, <#[R31 + 8]> */
		/* 820CE418h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000008) );
		/* 820CE418h case    4:*/		return 0x820CE41C;
		  /* 820CE41Ch */ case    5:  		/* cmplwi CR6, R26, 0 */
		/* 820CE41Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820CE41Ch case    5:*/		return 0x820CE420;
		  /* 820CE420h */ case    6:  		/* stw R9, <#[R31 + 16]> */
		/* 820CE420h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820CE420h case    6:*/		return 0x820CE424;
		  /* 820CE424h */ case    7:  		/* stw R25, <#[R31 + 20]> */
		/* 820CE424h case    7:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000014) );
		/* 820CE424h case    7:*/		return 0x820CE428;
		  /* 820CE428h */ case    8:  		/* stw R10, <#[R31 + 12]> */
		/* 820CE428h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820CE428h case    8:*/		return 0x820CE42C;
		  /* 820CE42Ch */ case    9:  		/* lwz R9, <#[R29 + 12]> */
		/* 820CE42Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x0000000C) );
		/* 820CE42Ch case    9:*/		return 0x820CE430;
		  /* 820CE430h */ case   10:  		/* lwz R10, <#[R29 + 4]> */
		/* 820CE430h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 820CE430h case   10:*/		return 0x820CE434;
		  /* 820CE434h */ case   11:  		/* add R10, R10, R30 */
		/* 820CE434h case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 820CE434h case   11:*/		return 0x820CE438;
		  /* 820CE438h */ case   12:  		/* stw R10, <#[R29 + 4]> */
		/* 820CE438h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 820CE438h case   12:*/		return 0x820CE43C;
		  /* 820CE43Ch */ case   13:  		/* stw R31, <#[R9]> */
		/* 820CE43Ch case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + 0x00000000) );
		/* 820CE43Ch case   13:*/		return 0x820CE440;
		  /* 820CE440h */ case   14:  		/* stw R11, <#[R29 + 12]> */
		/* 820CE440h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 820CE440h case   14:*/		return 0x820CE444;
		  /* 820CE444h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 820CE444h case   15:*/		if ( regs.CR[6].eq ) { return 0x820CE450;  }
		/* 820CE444h case   15:*/		return 0x820CE448;
		  /* 820CE448h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 820CE448h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820CE448h case   16:*/		return 0x820CE44C;
		  /* 820CE44Ch */ case   17:  		/* stw R11, <#[R26]> */
		/* 820CE44Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820CE44Ch case   17:*/		return 0x820CE450;
	}
	return 0x820CE450;
} // Block from 820CE408h-820CE450h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CE450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE450);
		  /* 820CE450h */ case    0:  		/* li R3, 0 */
		/* 820CE450h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CE450h case    0:*/		return 0x820CE454;
	}
	return 0x820CE454;
} // Block from 820CE450h-820CE454h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE454);
		  /* 820CE454h */ case    0:  		/* addi R1, R1, 144 */
		/* 820CE454h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820CE454h case    0:*/		return 0x820CE458;
		  /* 820CE458h */ case    1:  		/* b -250300 */
		/* 820CE458h case    1:*/		return 0x8209129C;
		/* 820CE458h case    1:*/		return 0x820CE45C;
		  /* 820CE45Ch */ case    2:  		/* nop */
		/* 820CE45Ch case    2:*/		cpu::op::nop();
		/* 820CE45Ch case    2:*/		return 0x820CE460;
	}
	return 0x820CE460;
} // Block from 820CE454h-820CE460h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE460);
		  /* 820CE460h */ case    0:  		/* mfspr R12, LR */
		/* 820CE460h case    0:*/		regs.R12 = regs.LR;
		/* 820CE460h case    0:*/		return 0x820CE464;
		  /* 820CE464h */ case    1:  		/* bl -250384 */
		/* 820CE464h case    1:*/		regs.LR = 0x820CE468; return 0x82091254;
		/* 820CE464h case    1:*/		return 0x820CE468;
		  /* 820CE468h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CE468h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CE468h case    2:*/		return 0x820CE46C;
		  /* 820CE46Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 820CE46Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820CE46Ch case    3:*/		return 0x820CE470;
		  /* 820CE470h */ case    4:  		/* mr R28, R5 */
		/* 820CE470h case    4:*/		regs.R28 = regs.R5;
		/* 820CE470h case    4:*/		return 0x820CE474;
		  /* 820CE474h */ case    5:  		/* cmpwi CR6, R5, -1 */
		/* 820CE474h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 820CE474h case    5:*/		return 0x820CE478;
		  /* 820CE478h */ case    6:  		/* addi R11, R11, 3 */
		/* 820CE478h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820CE478h case    6:*/		return 0x820CE47C;
		  /* 820CE47Ch */ case    7:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820CE47Ch case    7:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820CE47Ch case    7:*/		return 0x820CE480;
		  /* 820CE480h */ case    8:  		/* bc 4, CR6_EQ, 56 */
		/* 820CE480h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CE4B8;  }
		/* 820CE480h case    8:*/		return 0x820CE484;
		  /* 820CE484h */ case    9:  		/* addi R28, R11, 2 */
		/* 820CE484h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x2);
		/* 820CE484h case    9:*/		return 0x820CE488;
		  /* 820CE488h */ case   10:  		/* cmplwi CR6, R28, 32768 */
		/* 820CE488h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00008000);
		/* 820CE488h case   10:*/		return 0x820CE48C;
		  /* 820CE48Ch */ case   11:  		/* bc 12, CR6_GT, 56 */
		/* 820CE48Ch case   11:*/		if ( regs.CR[6].gt ) { return 0x820CE4C4;  }
		/* 820CE48Ch case   11:*/		return 0x820CE490;
		  /* 820CE490h */ case   12:  		/* addi R11, R28, -1 */
		/* 820CE490h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFF);
		/* 820CE490h case   12:*/		return 0x820CE494;
		  /* 820CE494h */ case   13:  		/* addi R30, R4, 8 */
		/* 820CE494h case   13:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0x8);
		/* 820CE494h case   13:*/		return 0x820CE498;
		  /* 820CE498h */ case   14:  		/* rlwinm R11, R11, 16, 1, 15 */
		/* 820CE498h case   14:*/		cpu::op::rlwinm<0,16,1,15>(regs,&regs.R11,regs.R11);
		/* 820CE498h case   14:*/		return 0x820CE49C;
		  /* 820CE49Ch */ case   15:  		/* li R29, 0 */
		/* 820CE49Ch case   15:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820CE49Ch case   15:*/		return 0x820CE4A0;
		  /* 820CE4A0h */ case   16:  		/* ori R11, R11, 65534 */
		/* 820CE4A0h case   16:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFE);
		/* 820CE4A0h case   16:*/		return 0x820CE4A4;
		  /* 820CE4A4h */ case   17:  		/* stw R11, <#[R4]> */
		/* 820CE4A4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820CE4A4h case   17:*/		return 0x820CE4A8;
		  /* 820CE4A8h */ case   18:  		/* lwz R11, <#[R3]> */
		/* 820CE4A8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CE4A8h case   18:*/		return 0x820CE4AC;
		  /* 820CE4ACh */ case   19:  		/* stw R11, <#[R4 + 4]> */
		/* 820CE4ACh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CE4ACh case   19:*/		return 0x820CE4B0;
		  /* 820CE4B0h */ case   20:  		/* lwz R31, <#[R3 + 8]> */
		/* 820CE4B0h case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000008) );
		/* 820CE4B0h case   20:*/		return 0x820CE4B4;
		  /* 820CE4B4h */ case   21:  		/* b 108 */
		/* 820CE4B4h case   21:*/		return 0x820CE520;
		/* 820CE4B4h case   21:*/		return 0x820CE4B8;
	}
	return 0x820CE4B8;
} // Block from 820CE460h-820CE4B8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CE4B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE4B8);
		  /* 820CE4B8h */ case    0:  		/* addi R11, R11, 2 */
		/* 820CE4B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820CE4B8h case    0:*/		return 0x820CE4BC;
		  /* 820CE4BCh */ case    1:  		/* cmplw CR6, R28, R11 */
		/* 820CE4BCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820CE4BCh case    1:*/		return 0x820CE4C0;
		  /* 820CE4C0h */ case    2:  		/* bc 4, CR6_LT, -56 */
		/* 820CE4C0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820CE488;  }
		/* 820CE4C0h case    2:*/		return 0x820CE4C4;
	}
	return 0x820CE4C4;
} // Block from 820CE4B8h-820CE4C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE4C4);
		  /* 820CE4C4h */ case    0:  		/* lis R3, -32768 */
		/* 820CE4C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CE4C4h case    0:*/		return 0x820CE4C8;
		  /* 820CE4C8h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820CE4C8h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CE4C8h case    1:*/		return 0x820CE4CC;
		  /* 820CE4CCh */ case    2:  		/* b 120 */
		/* 820CE4CCh case    2:*/		return 0x820CE544;
		/* 820CE4CCh case    2:*/		return 0x820CE4D0;
		  /* 820CE4D0h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 820CE4D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820CE4D0h case    3:*/		return 0x820CE4D4;
		  /* 820CE4D4h */ case    4:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820CE4D4h case    4:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820CE4D4h case    4:*/		return 0x820CE4D8;
		  /* 820CE4D8h */ case    5:  		/* bc 4, CR0_EQ, 40 */
		/* 820CE4D8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820CE500;  }
		/* 820CE4D8h case    5:*/		return 0x820CE4DC;
		  /* 820CE4DCh */ case    6:  		/* addi R11, R29, 3 */
		/* 820CE4DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x3);
		/* 820CE4DCh case    6:*/		return 0x820CE4E0;
		  /* 820CE4E0h */ case    7:  		/* li R4, 171 */
		/* 820CE4E0h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xAB);
		/* 820CE4E0h case    7:*/		return 0x820CE4E4;
		  /* 820CE4E4h */ case    8:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 820CE4E4h case    8:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 820CE4E4h case    8:*/		return 0x820CE4E8;
		  /* 820CE4E8h */ case    9:  		/* mr R3, R30 */
		/* 820CE4E8h case    9:*/		regs.R3 = regs.R30;
		/* 820CE4E8h case    9:*/		return 0x820CE4EC;
		  /* 820CE4ECh */ case   10:  		/* subf R27, R29, R11 */
		/* 820CE4ECh case   10:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R29,regs.R11);
		/* 820CE4ECh case   10:*/		return 0x820CE4F0;
		  /* 820CE4F0h */ case   11:  		/* mr R5, R27 */
		/* 820CE4F0h case   11:*/		regs.R5 = regs.R27;
		/* 820CE4F0h case   11:*/		return 0x820CE4F4;
		  /* 820CE4F4h */ case   12:  		/* bl -250292 */
		/* 820CE4F4h case   12:*/		regs.LR = 0x820CE4F8; return 0x82091340;
		/* 820CE4F4h case   12:*/		return 0x820CE4F8;
		  /* 820CE4F8h */ case   13:  		/* add R30, R27, R30 */
		/* 820CE4F8h case   13:*/		cpu::op::add<0>(regs,&regs.R30,regs.R27,regs.R30);
		/* 820CE4F8h case   13:*/		return 0x820CE4FC;
		  /* 820CE4FCh */ case   14:  		/* add R29, R27, R29 */
		/* 820CE4FCh case   14:*/		cpu::op::add<0>(regs,&regs.R29,regs.R27,regs.R29);
		/* 820CE4FCh case   14:*/		return 0x820CE500;
	}
	return 0x820CE500;
} // Block from 820CE4C4h-820CE500h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820CE500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE500);
		  /* 820CE500h */ case    0:  		/* mr R3, R30 */
		/* 820CE500h case    0:*/		regs.R3 = regs.R30;
		/* 820CE500h case    0:*/		return 0x820CE504;
		  /* 820CE504h */ case    1:  		/* lwz R5, <#[R31 + 4]> */
		/* 820CE504h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000004) );
		/* 820CE504h case    1:*/		return 0x820CE508;
		  /* 820CE508h */ case    2:  		/* lwz R4, <#[R31]> */
		/* 820CE508h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE508h case    2:*/		return 0x820CE50C;
		  /* 820CE50Ch */ case    3:  		/* bl -248668 */
		/* 820CE50Ch case    3:*/		regs.LR = 0x820CE510; return 0x820919B0;
		/* 820CE50Ch case    3:*/		return 0x820CE510;
		  /* 820CE510h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 820CE510h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820CE510h case    4:*/		return 0x820CE514;
		  /* 820CE514h */ case    5:  		/* add R30, R11, R30 */
		/* 820CE514h case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820CE514h case    5:*/		return 0x820CE518;
		  /* 820CE518h */ case    6:  		/* add R29, R11, R29 */
		/* 820CE518h case    6:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820CE518h case    6:*/		return 0x820CE51C;
		  /* 820CE51Ch */ case    7:  		/* lwz R31, <#[R31 + 16]> */
		/* 820CE51Ch case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000010) );
		/* 820CE51Ch case    7:*/		return 0x820CE520;
	}
	return 0x820CE520;
} // Block from 820CE500h-820CE520h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CE520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE520);
		  /* 820CE520h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CE520h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CE520h case    0:*/		return 0x820CE524;
		  /* 820CE524h */ case    1:  		/* bc 4, CR6_EQ, -84 */
		/* 820CE524h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CE4D0;  }
		/* 820CE524h case    1:*/		return 0x820CE528;
		  /* 820CE528h */ case    2:  		/* addi R11, R28, -2 */
		/* 820CE528h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFE);
		/* 820CE528h case    2:*/		return 0x820CE52C;
		  /* 820CE52Ch */ case    3:  		/* li R4, 171 */
		/* 820CE52Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0xAB);
		/* 820CE52Ch case    3:*/		return 0x820CE530;
		  /* 820CE530h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820CE530h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820CE530h case    4:*/		return 0x820CE534;
		  /* 820CE534h */ case    5:  		/* mr R3, R30 */
		/* 820CE534h case    5:*/		regs.R3 = regs.R30;
		/* 820CE534h case    5:*/		return 0x820CE538;
		  /* 820CE538h */ case    6:  		/* subf R5, R29, R11 */
		/* 820CE538h case    6:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R29,regs.R11);
		/* 820CE538h case    6:*/		return 0x820CE53C;
		  /* 820CE53Ch */ case    7:  		/* bl -250364 */
		/* 820CE53Ch case    7:*/		regs.LR = 0x820CE540; return 0x82091340;
		/* 820CE53Ch case    7:*/		return 0x820CE540;
		  /* 820CE540h */ case    8:  		/* li R3, 0 */
		/* 820CE540h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CE540h case    8:*/		return 0x820CE544;
	}
	return 0x820CE544;
} // Block from 820CE520h-820CE544h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CE544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE544);
		  /* 820CE544h */ case    0:  		/* addi R1, R1, 128 */
		/* 820CE544h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CE544h case    0:*/		return 0x820CE548;
		  /* 820CE548h */ case    1:  		/* b -250532 */
		/* 820CE548h case    1:*/		return 0x820912A4;
		/* 820CE548h case    1:*/		return 0x820CE54C;
		  /* 820CE54Ch */ case    2:  		/* nop */
		/* 820CE54Ch case    2:*/		cpu::op::nop();
		/* 820CE54Ch case    2:*/		return 0x820CE550;
	}
	return 0x820CE550;
} // Block from 820CE544h-820CE550h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE550h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE550);
		  /* 820CE550h */ case    0:  		/* b -240 */
		/* 820CE550h case    0:*/		return 0x820CE460;
		/* 820CE550h case    0:*/		return 0x820CE554;
		  /* 820CE554h */ case    1:  		/* nop */
		/* 820CE554h case    1:*/		cpu::op::nop();
		/* 820CE554h case    1:*/		return 0x820CE558;
		  /* 820CE558h */ case    2:  		/* li R6, 1 */
		/* 820CE558h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820CE558h case    2:*/		return 0x820CE55C;
		  /* 820CE55Ch */ case    3:  		/* b -252 */
		/* 820CE55Ch case    3:*/		return 0x820CE460;
		/* 820CE55Ch case    3:*/		return 0x820CE560;
		  /* 820CE560h */ case    4:  		/* lbz R11, <#[R3]> */
		/* 820CE560h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CE560h case    4:*/		return 0x820CE564;
		  /* 820CE564h */ case    5:  		/* addi R9, R3, 1 */
		/* 820CE564h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x1);
		/* 820CE564h case    5:*/		return 0x820CE568;
		  /* 820CE568h */ case    6:  		/* extsb R11, R11 */
		/* 820CE568h case    6:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820CE568h case    6:*/		return 0x820CE56C;
		  /* 820CE56Ch */ case    7:  		/* cmpwi CR6, R11, 111 */
		/* 820CE56Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006F);
		/* 820CE56Ch case    7:*/		return 0x820CE570;
		  /* 820CE570h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 820CE570h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CE58C;  }
		/* 820CE570h case    8:*/		return 0x820CE574;
		  /* 820CE574h */ case    9:  		/* cmpwi CR6, R11, 114 */
		/* 820CE574h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000072);
		/* 820CE574h case    9:*/		return 0x820CE578;
		  /* 820CE578h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820CE578h case   10:*/		if ( regs.CR[6].eq ) { return 0x820CE584;  }
		/* 820CE578h case   10:*/		return 0x820CE57C;
		  /* 820CE57Ch */ case   11:  		/* cmpwi CR6, R11, 101 */
		/* 820CE57Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000065);
		/* 820CE57Ch case   11:*/		return 0x820CE580;
		  /* 820CE580h */ case   12:  		/* bc 4, CR6_EQ, 196 */
		/* 820CE580h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CE644;  }
		/* 820CE580h case   12:*/		return 0x820CE584;
	}
	return 0x820CE584;
} // Block from 820CE550h-820CE584h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CE584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE584);
		  /* 820CE584h */ case    0:  		/* cmpwi CR6, R11, 111 */
		/* 820CE584h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006F);
		/* 820CE584h case    0:*/		return 0x820CE588;
		  /* 820CE588h */ case    1:  		/* bc 4, CR6_EQ, 136 */
		/* 820CE588h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CE610;  }
		/* 820CE588h case    1:*/		return 0x820CE58C;
	}
	return 0x820CE58C;
} // Block from 820CE584h-820CE58Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE58Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE58C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE58C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE58C);
		  /* 820CE58Ch */ case    0:  		/* lis R10, -32255 */
		/* 820CE58Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE58Ch case    0:*/		return 0x820CE590;
		  /* 820CE590h */ case    1:  		/* mr R11, R9 */
		/* 820CE590h case    1:*/		regs.R11 = regs.R9;
		/* 820CE590h case    1:*/		return 0x820CE594;
		  /* 820CE594h */ case    2:  		/* addi R10, R10, 22344 */
		/* 820CE594h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x5748);
		/* 820CE594h case    2:*/		return 0x820CE598;
		  /* 820CE598h */ case    3:  		/* lbz R8, <#[R11]> */
		/* 820CE598h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE598h case    3:*/		return 0x820CE59C;
		  /* 820CE59Ch */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820CE59Ch case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE59Ch case    4:*/		return 0x820CE5A0;
		  /* 820CE5A0h */ case    5:  		/* cmpwi CR0, R8, 0 */
		/* 820CE5A0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820CE5A0h case    5:*/		return 0x820CE5A4;
		  /* 820CE5A4h */ case    6:  		/* subf R8, R7, R8 */
		/* 820CE5A4h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820CE5A4h case    6:*/		return 0x820CE5A8;
		  /* 820CE5A8h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE5A8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CE5BC;  }
		/* 820CE5A8h case    7:*/		return 0x820CE5AC;
		  /* 820CE5ACh */ case    8:  		/* addi R11, R11, 1 */
		/* 820CE5ACh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE5ACh case    8:*/		return 0x820CE5B0;
		  /* 820CE5B0h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CE5B0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE5B0h case    9:*/		return 0x820CE5B4;
		  /* 820CE5B4h */ case   10:  		/* cmpwi CR6, R8, 0 */
		/* 820CE5B4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820CE5B4h case   10:*/		return 0x820CE5B8;
		  /* 820CE5B8h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE5B8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CE598;  }
		/* 820CE5B8h case   11:*/		return 0x820CE5BC;
	}
	return 0x820CE5BC;
} // Block from 820CE58Ch-820CE5BCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE5BC);
		  /* 820CE5BCh */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820CE5BCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820CE5BCh case    0:*/		return 0x820CE5C0;
		  /* 820CE5C0h */ case    1:  		/* bc 12, CR0_EQ, 172 */
		/* 820CE5C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CE66C;  }
		/* 820CE5C0h case    1:*/		return 0x820CE5C4;
		  /* 820CE5C4h */ case    2:  		/* lis R10, -32255 */
		/* 820CE5C4h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE5C4h case    2:*/		return 0x820CE5C8;
		  /* 820CE5C8h */ case    3:  		/* mr R11, R9 */
		/* 820CE5C8h case    3:*/		regs.R11 = regs.R9;
		/* 820CE5C8h case    3:*/		return 0x820CE5CC;
		  /* 820CE5CCh */ case    4:  		/* addi R10, R10, 22340 */
		/* 820CE5CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x5744);
		/* 820CE5CCh case    4:*/		return 0x820CE5D0;
		  /* 820CE5D0h */ case    5:  		/* lbz R8, <#[R11]> */
		/* 820CE5D0h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE5D0h case    5:*/		return 0x820CE5D4;
		  /* 820CE5D4h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820CE5D4h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE5D4h case    6:*/		return 0x820CE5D8;
		  /* 820CE5D8h */ case    7:  		/* cmpwi CR0, R8, 0 */
		/* 820CE5D8h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820CE5D8h case    7:*/		return 0x820CE5DC;
		  /* 820CE5DCh */ case    8:  		/* subf R8, R7, R8 */
		/* 820CE5DCh case    8:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820CE5DCh case    8:*/		return 0x820CE5E0;
		  /* 820CE5E0h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE5E0h case    9:*/		if ( regs.CR[0].eq ) { return 0x820CE5F4;  }
		/* 820CE5E0h case    9:*/		return 0x820CE5E4;
		  /* 820CE5E4h */ case   10:  		/* addi R11, R11, 1 */
		/* 820CE5E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE5E4h case   10:*/		return 0x820CE5E8;
		  /* 820CE5E8h */ case   11:  		/* addi R10, R10, 1 */
		/* 820CE5E8h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE5E8h case   11:*/		return 0x820CE5EC;
		  /* 820CE5ECh */ case   12:  		/* cmpwi CR6, R8, 0 */
		/* 820CE5ECh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820CE5ECh case   12:*/		return 0x820CE5F0;
		  /* 820CE5F0h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE5F0h case   13:*/		if ( regs.CR[6].eq ) { return 0x820CE5D0;  }
		/* 820CE5F0h case   13:*/		return 0x820CE5F4;
	}
	return 0x820CE5F4;
} // Block from 820CE5BCh-820CE5F4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CE5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE5F4);
		  /* 820CE5F4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820CE5F4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820CE5F4h case    0:*/		return 0x820CE5F8;
		  /* 820CE5F8h */ case    1:  		/* bc 12, CR0_EQ, 116 */
		/* 820CE5F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CE66C;  }
		/* 820CE5F8h case    1:*/		return 0x820CE5FC;
		  /* 820CE5FCh */ case    2:  		/* lbz R11, <#[R9]> */
		/* 820CE5FCh case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820CE5FCh case    2:*/		return 0x820CE600;
		  /* 820CE600h */ case    3:  		/* cmplwi CR6, R11, 67 */
		/* 820CE600h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000043);
		/* 820CE600h case    3:*/		return 0x820CE604;
		  /* 820CE604h */ case    4:  		/* bc 4, CR6_EQ, 92 */
		/* 820CE604h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CE660;  }
		/* 820CE604h case    4:*/		return 0x820CE608;
		  /* 820CE608h */ case    5:  		/* addi R9, R9, 1 */
		/* 820CE608h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820CE608h case    5:*/		return 0x820CE60C;
		  /* 820CE60Ch */ case    6:  		/* b 84 */
		/* 820CE60Ch case    6:*/		return 0x820CE660;
		/* 820CE60Ch case    6:*/		return 0x820CE610;
	}
	return 0x820CE610;
} // Block from 820CE5F4h-820CE610h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CE610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE610);
		  /* 820CE610h */ case    0:  		/* cmpwi CR6, R11, 101 */
		/* 820CE610h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000065);
		/* 820CE610h case    0:*/		return 0x820CE614;
		  /* 820CE614h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 820CE614h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CE660;  }
		/* 820CE614h case    1:*/		return 0x820CE618;
		  /* 820CE618h */ case    2:  		/* lbz R11, <#[R9]> */
		/* 820CE618h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820CE618h case    2:*/		return 0x820CE61C;
		  /* 820CE61Ch */ case    3:  		/* addi R9, R9, 1 */
		/* 820CE61Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820CE61Ch case    3:*/		return 0x820CE620;
		  /* 820CE620h */ case    4:  		/* extsb R11, R11 */
		/* 820CE620h case    4:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820CE620h case    4:*/		return 0x820CE624;
		  /* 820CE624h */ case    5:  		/* cmpwi CR6, R11, 65 */
		/* 820CE624h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000041);
		/* 820CE624h case    5:*/		return 0x820CE628;
		  /* 820CE628h */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 820CE628h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CE63C;  }
		/* 820CE628h case    6:*/		return 0x820CE62C;
		  /* 820CE62Ch */ case    7:  		/* lbz R11, <#[R9]> */
		/* 820CE62Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820CE62Ch case    7:*/		return 0x820CE630;
		  /* 820CE630h */ case    8:  		/* cntlzw R11, R11 */
		/* 820CE630h case    8:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CE630h case    8:*/		return 0x820CE634;
		  /* 820CE634h */ case    9:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CE634h case    9:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CE634h case    9:*/		return 0x820CE638;
		  /* 820CE638h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820CE638h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE638h case   10:*/		return 0x820CE63C;
	}
	return 0x820CE63C;
} // Block from 820CE610h-820CE63Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CE63Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE63C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE63C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE63C);
		  /* 820CE63Ch */ case    0:  		/* cmpwi CR6, R11, 77 */
		/* 820CE63Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000004D);
		/* 820CE63Ch case    0:*/		return 0x820CE640;
		  /* 820CE640h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820CE640h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CE660;  }
		/* 820CE640h case    1:*/		return 0x820CE644;
	}
	return 0x820CE644;
} // Block from 820CE63Ch-820CE644h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE644);
		  /* 820CE644h */ case    0:  		/* li R3, 0 */
		/* 820CE644h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CE644h case    0:*/		return 0x820CE648;
		  /* 820CE648h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820CE648h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE648h case    1:*/		return 0x820CE64C;
	}
	return 0x820CE64C;
} // Block from 820CE644h-820CE64Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE64C);
		  /* 820CE64Ch */ case    0:  		/* addi R9, R9, 1 */
		/* 820CE64Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820CE64Ch case    0:*/		return 0x820CE650;
		  /* 820CE650h */ case    1:  		/* cmpwi CR6, R11, 48 */
		/* 820CE650h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 820CE650h case    1:*/		return 0x820CE654;
		  /* 820CE654h */ case    2:  		/* bc 12, CR6_LT, -16 */
		/* 820CE654h case    2:*/		if ( regs.CR[6].lt ) { return 0x820CE644;  }
		/* 820CE654h case    2:*/		return 0x820CE658;
		  /* 820CE658h */ case    3:  		/* cmpwi CR6, R11, 57 */
		/* 820CE658h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 820CE658h case    3:*/		return 0x820CE65C;
		  /* 820CE65Ch */ case    4:  		/* bc 12, CR6_GT, -24 */
		/* 820CE65Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x820CE644;  }
		/* 820CE65Ch case    4:*/		return 0x820CE660;
	}
	return 0x820CE660;
} // Block from 820CE64Ch-820CE660h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CE660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE660);
		  /* 820CE660h */ case    0:  		/* lbz R11, <#[R9]> */
		/* 820CE660h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820CE660h case    0:*/		return 0x820CE664;
		  /* 820CE664h */ case    1:  		/* extsb. R11, R11 */
		/* 820CE664h case    1:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 820CE664h case    1:*/		return 0x820CE668;
		  /* 820CE668h */ case    2:  		/* bc 4, CR0_EQ, -28 */
		/* 820CE668h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820CE64C;  }
		/* 820CE668h case    2:*/		return 0x820CE66C;
	}
	return 0x820CE66C;
} // Block from 820CE660h-820CE66Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CE66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE66C);
		  /* 820CE66Ch */ case    0:  		/* li R3, 1 */
		/* 820CE66Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CE66Ch case    0:*/		return 0x820CE670;
		  /* 820CE670h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820CE670h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE670h case    1:*/		return 0x820CE674;
	}
	return 0x820CE674;
} // Block from 820CE66Ch-820CE674h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE674);
		  /* 820CE674h */ case    0:  		/* nop */
		/* 820CE674h case    0:*/		cpu::op::nop();
		/* 820CE674h case    0:*/		return 0x820CE678;
	}
	return 0x820CE678;
} // Block from 820CE674h-820CE678h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE678);
		  /* 820CE678h */ case    0:  		/* mfspr R12, LR */
		/* 820CE678h case    0:*/		regs.R12 = regs.LR;
		/* 820CE678h case    0:*/		return 0x820CE67C;
		  /* 820CE67Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CE67Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE67Ch case    1:*/		return 0x820CE680;
		  /* 820CE680h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820CE680h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE680h case    2:*/		return 0x820CE684;
		  /* 820CE684h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CE684h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CE684h case    3:*/		return 0x820CE688;
		  /* 820CE688h */ case    4:  		/* mr R31, R4 */
		/* 820CE688h case    4:*/		regs.R31 = regs.R4;
		/* 820CE688h case    4:*/		return 0x820CE68C;
		  /* 820CE68Ch */ case    5:  		/* bl -171492 */
		/* 820CE68Ch case    5:*/		regs.LR = 0x820CE690; return 0x820A48A8;
		/* 820CE68Ch case    5:*/		return 0x820CE690;
		  /* 820CE690h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820CE690h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CE690h case    6:*/		return 0x820CE694;
		  /* 820CE694h */ case    7:  		/* bc 12, CR0_LT, 24 */
		/* 820CE694h case    7:*/		if ( regs.CR[0].lt ) { return 0x820CE6AC;  }
		/* 820CE694h case    7:*/		return 0x820CE698;
		  /* 820CE698h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820CE698h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE698h case    8:*/		return 0x820CE69C;
		  /* 820CE69Ch */ case    9:  		/* cmpwi CR6, R11, 3 */
		/* 820CE69Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820CE69Ch case    9:*/		return 0x820CE6A0;
		  /* 820CE6A0h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 820CE6A0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820CE6AC;  }
		/* 820CE6A0h case   10:*/		return 0x820CE6A4;
		  /* 820CE6A4h */ case   11:  		/* li R11, 2 */
		/* 820CE6A4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820CE6A4h case   11:*/		return 0x820CE6A8;
		  /* 820CE6A8h */ case   12:  		/* stw R11, <#[R31]> */
		/* 820CE6A8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE6A8h case   12:*/		return 0x820CE6AC;
	}
	return 0x820CE6AC;
} // Block from 820CE678h-820CE6ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CE6ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE6AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE6AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE6AC);
		  /* 820CE6ACh */ case    0:  		/* addi R1, R1, 96 */
		/* 820CE6ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CE6ACh case    0:*/		return 0x820CE6B0;
		  /* 820CE6B0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CE6B0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CE6B0h case    1:*/		return 0x820CE6B4;
		  /* 820CE6B4h */ case    2:  		/* mtspr LR, R12 */
		/* 820CE6B4h case    2:*/		regs.LR = regs.R12;
		/* 820CE6B4h case    2:*/		return 0x820CE6B8;
		  /* 820CE6B8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820CE6B8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CE6B8h case    3:*/		return 0x820CE6BC;
		  /* 820CE6BCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 820CE6BCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CE6BCh case    4:*/		return 0x820CE6C0;
	}
	return 0x820CE6C0;
} // Block from 820CE6ACh-820CE6C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CE6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE6C0);
		  /* 820CE6C0h */ case    0:  		/* mfspr R12, LR */
		/* 820CE6C0h case    0:*/		regs.R12 = regs.LR;
		/* 820CE6C0h case    0:*/		return 0x820CE6C4;
		  /* 820CE6C4h */ case    1:  		/* bl -250988 */
		/* 820CE6C4h case    1:*/		regs.LR = 0x820CE6C8; return 0x82091258;
		/* 820CE6C4h case    1:*/		return 0x820CE6C8;
		  /* 820CE6C8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820CE6C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820CE6C8h case    2:*/		return 0x820CE6CC;
		  /* 820CE6CCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820CE6CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CE6CCh case    3:*/		return 0x820CE6D0;
		  /* 820CE6D0h */ case    4:  		/* mr R28, R4 */
		/* 820CE6D0h case    4:*/		regs.R28 = regs.R4;
		/* 820CE6D0h case    4:*/		return 0x820CE6D4;
		  /* 820CE6D4h */ case    5:  		/* mr R29, R5 */
		/* 820CE6D4h case    5:*/		regs.R29 = regs.R5;
		/* 820CE6D4h case    5:*/		return 0x820CE6D8;
		  /* 820CE6D8h */ case    6:  		/* cmpwi CR6, R11, 11 */
		/* 820CE6D8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820CE6D8h case    6:*/		return 0x820CE6DC;
		  /* 820CE6DCh */ case    7:  		/* bc 4, CR6_EQ, 1112 */
		/* 820CE6DCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820CEB34;  }
		/* 820CE6DCh case    7:*/		return 0x820CE6E0;
		  /* 820CE6E0h */ case    8:  		/* lwz R4, <#[R3 + 8]> */
		/* 820CE6E0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000008) );
		/* 820CE6E0h case    8:*/		return 0x820CE6E4;
		  /* 820CE6E4h */ case    9:  		/* mr R11, R4 */
		/* 820CE6E4h case    9:*/		regs.R11 = regs.R4;
		/* 820CE6E4h case    9:*/		return 0x820CE6E8;
		  /* 820CE6E8h */ case   10:  		/* lbz R10, <#[R11]> */
		/* 820CE6E8h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE6E8h case   10:*/		return 0x820CE6EC;
		  /* 820CE6ECh */ case   11:  		/* addi R11, R11, 1 */
		/* 820CE6ECh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE6ECh case   11:*/		return 0x820CE6F0;
		  /* 820CE6F0h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 820CE6F0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CE6F0h case   12:*/		return 0x820CE6F4;
		  /* 820CE6F4h */ case   13:  		/* bc 4, CR6_EQ, -12 */
		/* 820CE6F4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820CE6E8;  }
		/* 820CE6F4h case   13:*/		return 0x820CE6F8;
		  /* 820CE6F8h */ case   14:  		/* subf R11, R4, R11 */
		/* 820CE6F8h case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820CE6F8h case   14:*/		return 0x820CE6FC;
		  /* 820CE6FCh */ case   15:  		/* addi R11, R11, -1 */
		/* 820CE6FCh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820CE6FCh case   15:*/		return 0x820CE700;
		  /* 820CE700h */ case   16:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820CE700h case   16:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820CE700h case   16:*/		return 0x820CE704;
		  /* 820CE704h */ case   17:  		/* cmplwi CR6, R11, 20 */
		/* 820CE704h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000014);
		/* 820CE704h case   17:*/		return 0x820CE708;
		  /* 820CE708h */ case   18:  		/* bc 4, CR6_LT, 1068 */
		/* 820CE708h case   18:*/		if ( !regs.CR[6].lt ) { return 0x820CEB34;  }
		/* 820CE708h case   18:*/		return 0x820CE70C;
		  /* 820CE70Ch */ case   19:  		/* addi R5, R11, 1 */
		/* 820CE70Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 820CE70Ch case   19:*/		return 0x820CE710;
		  /* 820CE710h */ case   20:  		/* addi R3, R1, 80 */
		/* 820CE710h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820CE710h case   20:*/		return 0x820CE714;
		  /* 820CE714h */ case   21:  		/* bl -249188 */
		/* 820CE714h case   21:*/		regs.LR = 0x820CE718; return 0x820919B0;
		/* 820CE714h case   21:*/		return 0x820CE718;
		  /* 820CE718h */ case   22:  		/* lbz R11, <#[R1 + 80]> */
		/* 820CE718h case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820CE718h case   22:*/		return 0x820CE71C;
		  /* 820CE71Ch */ case   23:  		/* addi R31, R1, 80 */
		/* 820CE71Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x50);
		/* 820CE71Ch case   23:*/		return 0x820CE720;
		  /* 820CE720h */ case   24:  		/* b 28 */
		/* 820CE720h case   24:*/		return 0x820CE73C;
		/* 820CE720h case   24:*/		return 0x820CE724;
		  /* 820CE724h */ case   25:  		/* lbz R11, <#[R31]> */
		/* 820CE724h case   25:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE724h case   25:*/		return 0x820CE728;
		  /* 820CE728h */ case   26:  		/* extsb R3, R11 */
		/* 820CE728h case   26:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820CE728h case   26:*/		return 0x820CE72C;
		  /* 820CE72Ch */ case   27:  		/* bl -217148 */
		/* 820CE72Ch case   27:*/		regs.LR = 0x820CE730; return 0x820996F0;
		/* 820CE72Ch case   27:*/		return 0x820CE730;
		  /* 820CE730h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 820CE730h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CE730h case   28:*/		return 0x820CE734;
		  /* 820CE734h */ case   29:  		/* bc 12, CR0_EQ, 16 */
		/* 820CE734h case   29:*/		if ( regs.CR[0].eq ) { return 0x820CE744;  }
		/* 820CE734h case   29:*/		return 0x820CE738;
		  /* 820CE738h */ case   30:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820CE738h case   30:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820CE738h case   30:*/		return 0x820CE73C;
	}
	return 0x820CE73C;
} // Block from 820CE6C0h-820CE73Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 820CE73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE73C);
		  /* 820CE73Ch */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820CE73Ch case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CE73Ch case    0:*/		return 0x820CE740;
		  /* 820CE740h */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820CE740h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE724;  }
		/* 820CE740h case    1:*/		return 0x820CE744;
	}
	return 0x820CE744;
} // Block from 820CE73Ch-820CE744h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE744);
		  /* 820CE744h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820CE744h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE744h case    0:*/		return 0x820CE748;
		  /* 820CE748h */ case    1:  		/* li R30, 0 */
		/* 820CE748h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CE748h case    1:*/		return 0x820CE74C;
		  /* 820CE74Ch */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 820CE74Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CE74Ch case    2:*/		return 0x820CE750;
		  /* 820CE750h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820CE750h case    3:*/		if ( regs.CR[0].eq ) { return 0x820CE760;  }
		/* 820CE750h case    3:*/		return 0x820CE754;
		  /* 820CE754h */ case    4:  		/* mr R3, R31 */
		/* 820CE754h case    4:*/		regs.R3 = regs.R31;
		/* 820CE754h case    4:*/		return 0x820CE758;
		  /* 820CE758h */ case    5:  		/* bl -244720 */
		/* 820CE758h case    5:*/		regs.LR = 0x820CE75C; return 0x82092B68;
		/* 820CE758h case    5:*/		return 0x820CE75C;
		  /* 820CE75Ch */ case    6:  		/* b 8 */
		/* 820CE75Ch case    6:*/		return 0x820CE764;
		/* 820CE75Ch case    6:*/		return 0x820CE760;
	}
	return 0x820CE760;
} // Block from 820CE744h-820CE760h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CE760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE760);
		  /* 820CE760h */ case    0:  		/* mr R3, R30 */
		/* 820CE760h case    0:*/		regs.R3 = regs.R30;
		/* 820CE760h case    0:*/		return 0x820CE764;
	}
	return 0x820CE764;
} // Block from 820CE760h-820CE764h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE764);
		  /* 820CE764h */ case    0:  		/* stw R3, <#[R29]> */
		/* 820CE764h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820CE764h case    0:*/		return 0x820CE768;
		  /* 820CE768h */ case    1:  		/* cmplwi CR6, R3, 15 */
		/* 820CE768h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000000F);
		/* 820CE768h case    1:*/		return 0x820CE76C;
		  /* 820CE76Ch */ case    2:  		/* bc 12, CR6_GT, 968 */
		/* 820CE76Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x820CEB34;  }
		/* 820CE76Ch case    2:*/		return 0x820CE770;
		  /* 820CE770h */ case    3:  		/* lbz R11, <#[R31]> */
		/* 820CE770h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE770h case    3:*/		return 0x820CE774;
		  /* 820CE774h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 820CE774h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CE774h case    4:*/		return 0x820CE778;
		  /* 820CE778h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 820CE778h case    5:*/		if ( regs.CR[0].eq ) { return 0x820CE784;  }
		/* 820CE778h case    5:*/		return 0x820CE77C;
		  /* 820CE77Ch */ case    6:  		/* stb R30, <#[R31]> */
		/* 820CE77Ch case    6:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE77Ch case    6:*/		return 0x820CE780;
		  /* 820CE780h */ case    7:  		/* addi R31, R31, 1 */
		/* 820CE780h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820CE780h case    7:*/		return 0x820CE784;
	}
	return 0x820CE784;
} // Block from 820CE764h-820CE784h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CE784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE784);
		  /* 820CE784h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820CE784h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE784h case    0:*/		return 0x820CE788;
		  /* 820CE788h */ case    1:  		/* b 20 */
		/* 820CE788h case    1:*/		return 0x820CE79C;
		/* 820CE788h case    1:*/		return 0x820CE78C;
		  /* 820CE78Ch */ case    2:  		/* bl -217212 */
		/* 820CE78Ch case    2:*/		regs.LR = 0x820CE790; return 0x82099710;
		/* 820CE78Ch case    2:*/		return 0x820CE790;
		  /* 820CE790h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820CE790h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CE790h case    3:*/		return 0x820CE794;
		  /* 820CE794h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820CE794h case    4:*/		if ( regs.CR[0].eq ) { return 0x820CE7A4;  }
		/* 820CE794h case    4:*/		return 0x820CE798;
		  /* 820CE798h */ case    5:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820CE798h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820CE798h case    5:*/		return 0x820CE79C;
	}
	return 0x820CE79C;
} // Block from 820CE784h-820CE79Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CE79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE79C);
		  /* 820CE79Ch */ case    0:  		/* extsb. R3, R11 */
		/* 820CE79Ch case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820CE79Ch case    0:*/		return 0x820CE7A0;
		  /* 820CE7A0h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820CE7A0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE78C;  }
		/* 820CE7A0h case    1:*/		return 0x820CE7A4;
	}
	return 0x820CE7A4;
} // Block from 820CE79Ch-820CE7A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CE7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE7A4);
		  /* 820CE7A4h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820CE7A4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CE7A4h case    0:*/		return 0x820CE7A8;
		  /* 820CE7A8h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820CE7A8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CE7A8h case    1:*/		return 0x820CE7AC;
		  /* 820CE7ACh */ case    2:  		/* bc 4, CR0_EQ, 904 */
		/* 820CE7ACh case    2:*/		if ( !regs.CR[0].eq ) { return 0x820CEB34;  }
		/* 820CE7ACh case    2:*/		return 0x820CE7B0;
		  /* 820CE7B0h */ case    3:  		/* lis R10, -32255 */
		/* 820CE7B0h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE7B0h case    3:*/		return 0x820CE7B4;
		  /* 820CE7B4h */ case    4:  		/* stw R30, <#[R28]> */
		/* 820CE7B4h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 820CE7B4h case    4:*/		return 0x820CE7B8;
		  /* 820CE7B8h */ case    5:  		/* addi R11, R1, 80 */
		/* 820CE7B8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE7B8h case    5:*/		return 0x820CE7BC;
		  /* 820CE7BCh */ case    6:  		/* addi R10, R10, 4972 */
		/* 820CE7BCh case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x136C);
		/* 820CE7BCh case    6:*/		return 0x820CE7C0;
		  /* 820CE7C0h */ case    7:  		/* lbz R9, <#[R11]> */
		/* 820CE7C0h case    7:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE7C0h case    7:*/		return 0x820CE7C4;
		  /* 820CE7C4h */ case    8:  		/* lbz R8, <#[R10]> */
		/* 820CE7C4h case    8:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE7C4h case    8:*/		return 0x820CE7C8;
		  /* 820CE7C8h */ case    9:  		/* cmpwi CR0, R9, 0 */
		/* 820CE7C8h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE7C8h case    9:*/		return 0x820CE7CC;
		  /* 820CE7CCh */ case   10:  		/* subf R9, R8, R9 */
		/* 820CE7CCh case   10:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE7CCh case   10:*/		return 0x820CE7D0;
		  /* 820CE7D0h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE7D0h case   11:*/		if ( regs.CR[0].eq ) { return 0x820CE7E4;  }
		/* 820CE7D0h case   11:*/		return 0x820CE7D4;
		  /* 820CE7D4h */ case   12:  		/* addi R11, R11, 1 */
		/* 820CE7D4h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE7D4h case   12:*/		return 0x820CE7D8;
		  /* 820CE7D8h */ case   13:  		/* addi R10, R10, 1 */
		/* 820CE7D8h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE7D8h case   13:*/		return 0x820CE7DC;
		  /* 820CE7DCh */ case   14:  		/* cmpwi CR6, R9, 0 */
		/* 820CE7DCh case   14:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE7DCh case   14:*/		return 0x820CE7E0;
		  /* 820CE7E0h */ case   15:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE7E0h case   15:*/		if ( regs.CR[6].eq ) { return 0x820CE7C0;  }
		/* 820CE7E0h case   15:*/		return 0x820CE7E4;
	}
	return 0x820CE7E4;
} // Block from 820CE7A4h-820CE7E4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CE7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE7E4);
		  /* 820CE7E4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE7E4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE7E4h case    0:*/		return 0x820CE7E8;
		  /* 820CE7E8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE7E8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE7F4;  }
		/* 820CE7E8h case    1:*/		return 0x820CE7EC;
		  /* 820CE7ECh */ case    2:  		/* stw R30, <#[R28]> */
		/* 820CE7ECh case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 820CE7ECh case    2:*/		return 0x820CE7F0;
		  /* 820CE7F0h */ case    3:  		/* b 828 */
		/* 820CE7F0h case    3:*/		return 0x820CEB2C;
		/* 820CE7F0h case    3:*/		return 0x820CE7F4;
	}
	return 0x820CE7F4;
} // Block from 820CE7E4h-820CE7F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE7F4);
		  /* 820CE7F4h */ case    0:  		/* lis R10, -32255 */
		/* 820CE7F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE7F4h case    0:*/		return 0x820CE7F8;
		  /* 820CE7F8h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE7F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE7F8h case    1:*/		return 0x820CE7FC;
		  /* 820CE7FCh */ case    2:  		/* addi R10, R10, 4984 */
		/* 820CE7FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1378);
		/* 820CE7FCh case    2:*/		return 0x820CE800;
		  /* 820CE800h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE800h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE800h case    3:*/		return 0x820CE804;
		  /* 820CE804h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE804h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE804h case    4:*/		return 0x820CE808;
	}
	return 0x820CE808;
} // Block from 820CE7F4h-820CE808h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CE808h
// Function '??0CNodeAsmInstruction@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE808);
		  /* 820CE808h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE808h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE808h case    0:*/		return 0x820CE80C;
		  /* 820CE80Ch */ case    1:  		/* subf R9, R8, R9 */
		/* 820CE80Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE80Ch case    1:*/		return 0x820CE810;
		  /* 820CE810h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE810h case    2:*/		if ( regs.CR[0].eq ) { return 0x820CE824;  }
		/* 820CE810h case    2:*/		return 0x820CE814;
		  /* 820CE814h */ case    3:  		/* addi R11, R11, 1 */
		/* 820CE814h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE814h case    3:*/		return 0x820CE818;
		  /* 820CE818h */ case    4:  		/* addi R10, R10, 1 */
		/* 820CE818h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE818h case    4:*/		return 0x820CE81C;
		  /* 820CE81Ch */ case    5:  		/* cmpwi CR6, R9, 0 */
		/* 820CE81Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE81Ch case    5:*/		return 0x820CE820;
		  /* 820CE820h */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE820h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CE800;  }
		/* 820CE820h case    6:*/		return 0x820CE824;
	}
	return 0x820CE824;
} // Block from 820CE808h-820CE824h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CE824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE824);
		  /* 820CE824h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE824h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE824h case    0:*/		return 0x820CE828;
		  /* 820CE828h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE828h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE834;  }
		/* 820CE828h case    1:*/		return 0x820CE82C;
		  /* 820CE82Ch */ case    2:  		/* li R11, 1 */
		/* 820CE82Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820CE82Ch case    2:*/		return 0x820CE830;
		  /* 820CE830h */ case    3:  		/* b 760 */
		/* 820CE830h case    3:*/		return 0x820CEB28;
		/* 820CE830h case    3:*/		return 0x820CE834;
	}
	return 0x820CE834;
} // Block from 820CE824h-820CE834h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE834);
		  /* 820CE834h */ case    0:  		/* lis R10, -32255 */
		/* 820CE834h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE834h case    0:*/		return 0x820CE838;
		  /* 820CE838h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE838h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE838h case    1:*/		return 0x820CE83C;
		  /* 820CE83Ch */ case    2:  		/* addi R10, R10, 5004 */
		/* 820CE83Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x138C);
		/* 820CE83Ch case    2:*/		return 0x820CE840;
		  /* 820CE840h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE840h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE840h case    3:*/		return 0x820CE844;
		  /* 820CE844h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE844h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE844h case    4:*/		return 0x820CE848;
		  /* 820CE848h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CE848h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE848h case    5:*/		return 0x820CE84C;
		  /* 820CE84Ch */ case    6:  		/* subf R9, R8, R9 */
		/* 820CE84Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE84Ch case    6:*/		return 0x820CE850;
		  /* 820CE850h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE850h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CE864;  }
		/* 820CE850h case    7:*/		return 0x820CE854;
		  /* 820CE854h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CE854h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE854h case    8:*/		return 0x820CE858;
		  /* 820CE858h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CE858h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE858h case    9:*/		return 0x820CE85C;
		  /* 820CE85Ch */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CE85Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE85Ch case   10:*/		return 0x820CE860;
		  /* 820CE860h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE860h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CE840;  }
		/* 820CE860h case   11:*/		return 0x820CE864;
	}
	return 0x820CE864;
} // Block from 820CE834h-820CE864h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE864);
		  /* 820CE864h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE864h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE864h case    0:*/		return 0x820CE868;
		  /* 820CE868h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE868h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE874;  }
		/* 820CE868h case    1:*/		return 0x820CE86C;
		  /* 820CE86Ch */ case    2:  		/* li R11, 2 */
		/* 820CE86Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820CE86Ch case    2:*/		return 0x820CE870;
		  /* 820CE870h */ case    3:  		/* b 696 */
		/* 820CE870h case    3:*/		return 0x820CEB28;
		/* 820CE870h case    3:*/		return 0x820CE874;
	}
	return 0x820CE874;
} // Block from 820CE864h-820CE874h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE874);
		  /* 820CE874h */ case    0:  		/* lis R10, -32255 */
		/* 820CE874h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE874h case    0:*/		return 0x820CE878;
		  /* 820CE878h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE878h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE878h case    1:*/		return 0x820CE87C;
		  /* 820CE87Ch */ case    2:  		/* addi R10, R10, 5020 */
		/* 820CE87Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x139C);
		/* 820CE87Ch case    2:*/		return 0x820CE880;
		  /* 820CE880h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE880h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE880h case    3:*/		return 0x820CE884;
		  /* 820CE884h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE884h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE884h case    4:*/		return 0x820CE888;
		  /* 820CE888h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CE888h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE888h case    5:*/		return 0x820CE88C;
		  /* 820CE88Ch */ case    6:  		/* subf R9, R8, R9 */
		/* 820CE88Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE88Ch case    6:*/		return 0x820CE890;
	}
	return 0x820CE890;
} // Block from 820CE874h-820CE890h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CE890h
// Function '??0CNodeAsmInstruction@D3DXShader@@QAA@PBUD3DXTOKEN@1@KKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE890);
		  /* 820CE890h */ case    0:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE890h case    0:*/		if ( regs.CR[0].eq ) { return 0x820CE8A4;  }
		/* 820CE890h case    0:*/		return 0x820CE894;
		  /* 820CE894h */ case    1:  		/* addi R11, R11, 1 */
		/* 820CE894h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE894h case    1:*/		return 0x820CE898;
		  /* 820CE898h */ case    2:  		/* addi R10, R10, 1 */
		/* 820CE898h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE898h case    2:*/		return 0x820CE89C;
		  /* 820CE89Ch */ case    3:  		/* cmpwi CR6, R9, 0 */
		/* 820CE89Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE89Ch case    3:*/		return 0x820CE8A0;
		  /* 820CE8A0h */ case    4:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE8A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CE880;  }
		/* 820CE8A0h case    4:*/		return 0x820CE8A4;
	}
	return 0x820CE8A4;
} // Block from 820CE890h-820CE8A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CE8A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE8A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE8A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE8A4);
		  /* 820CE8A4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE8A4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE8A4h case    0:*/		return 0x820CE8A8;
		  /* 820CE8A8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE8A8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE8B4;  }
		/* 820CE8A8h case    1:*/		return 0x820CE8AC;
		  /* 820CE8ACh */ case    2:  		/* li R11, 3 */
		/* 820CE8ACh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820CE8ACh case    2:*/		return 0x820CE8B0;
		  /* 820CE8B0h */ case    3:  		/* b 632 */
		/* 820CE8B0h case    3:*/		return 0x820CEB28;
		/* 820CE8B0h case    3:*/		return 0x820CE8B4;
	}
	return 0x820CE8B4;
} // Block from 820CE8A4h-820CE8B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE8B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE8B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE8B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE8B4);
		  /* 820CE8B4h */ case    0:  		/* lis R10, -32255 */
		/* 820CE8B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE8B4h case    0:*/		return 0x820CE8B8;
		  /* 820CE8B8h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE8B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE8B8h case    1:*/		return 0x820CE8BC;
		  /* 820CE8BCh */ case    2:  		/* addi R10, R10, 5028 */
		/* 820CE8BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x13A4);
		/* 820CE8BCh case    2:*/		return 0x820CE8C0;
		  /* 820CE8C0h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE8C0h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE8C0h case    3:*/		return 0x820CE8C4;
		  /* 820CE8C4h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE8C4h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE8C4h case    4:*/		return 0x820CE8C8;
		  /* 820CE8C8h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CE8C8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE8C8h case    5:*/		return 0x820CE8CC;
		  /* 820CE8CCh */ case    6:  		/* subf R9, R8, R9 */
		/* 820CE8CCh case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE8CCh case    6:*/		return 0x820CE8D0;
		  /* 820CE8D0h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE8D0h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CE8E4;  }
		/* 820CE8D0h case    7:*/		return 0x820CE8D4;
		  /* 820CE8D4h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CE8D4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE8D4h case    8:*/		return 0x820CE8D8;
		  /* 820CE8D8h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CE8D8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE8D8h case    9:*/		return 0x820CE8DC;
		  /* 820CE8DCh */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CE8DCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE8DCh case   10:*/		return 0x820CE8E0;
		  /* 820CE8E0h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE8E0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CE8C0;  }
		/* 820CE8E0h case   11:*/		return 0x820CE8E4;
	}
	return 0x820CE8E4;
} // Block from 820CE8B4h-820CE8E4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE8E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE8E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE8E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE8E4);
		  /* 820CE8E4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE8E4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE8E4h case    0:*/		return 0x820CE8E8;
		  /* 820CE8E8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE8E8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE8F4;  }
		/* 820CE8E8h case    1:*/		return 0x820CE8EC;
		  /* 820CE8ECh */ case    2:  		/* li R11, 4 */
		/* 820CE8ECh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820CE8ECh case    2:*/		return 0x820CE8F0;
		  /* 820CE8F0h */ case    3:  		/* b 568 */
		/* 820CE8F0h case    3:*/		return 0x820CEB28;
		/* 820CE8F0h case    3:*/		return 0x820CE8F4;
	}
	return 0x820CE8F4;
} // Block from 820CE8E4h-820CE8F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE8F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE8F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE8F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE8F4);
		  /* 820CE8F4h */ case    0:  		/* lis R10, -32255 */
		/* 820CE8F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE8F4h case    0:*/		return 0x820CE8F8;
		  /* 820CE8F8h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE8F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE8F8h case    1:*/		return 0x820CE8FC;
		  /* 820CE8FCh */ case    2:  		/* addi R10, R10, -8388 */
		/* 820CE8FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFDF3C);
		/* 820CE8FCh case    2:*/		return 0x820CE900;
		  /* 820CE900h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE900h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE900h case    3:*/		return 0x820CE904;
		  /* 820CE904h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE904h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE904h case    4:*/		return 0x820CE908;
		  /* 820CE908h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CE908h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE908h case    5:*/		return 0x820CE90C;
		  /* 820CE90Ch */ case    6:  		/* subf R9, R8, R9 */
		/* 820CE90Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE90Ch case    6:*/		return 0x820CE910;
		  /* 820CE910h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE910h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CE924;  }
		/* 820CE910h case    7:*/		return 0x820CE914;
		  /* 820CE914h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CE914h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE914h case    8:*/		return 0x820CE918;
		  /* 820CE918h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CE918h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE918h case    9:*/		return 0x820CE91C;
		  /* 820CE91Ch */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CE91Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE91Ch case   10:*/		return 0x820CE920;
	}
	return 0x820CE920;
} // Block from 820CE8F4h-820CE920h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CE920h
// Function '?Copy@CNodeAsmInstruction@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE920);
		  /* 820CE920h */ case    0:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE920h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CE900;  }
		/* 820CE920h case    0:*/		return 0x820CE924;
	}
	return 0x820CE924;
} // Block from 820CE920h-820CE924h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CE924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE924);
		  /* 820CE924h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE924h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE924h case    0:*/		return 0x820CE928;
		  /* 820CE928h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE928h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE934;  }
		/* 820CE928h case    1:*/		return 0x820CE92C;
		  /* 820CE92Ch */ case    2:  		/* li R11, 5 */
		/* 820CE92Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CE92Ch case    2:*/		return 0x820CE930;
		  /* 820CE930h */ case    3:  		/* b 504 */
		/* 820CE930h case    3:*/		return 0x820CEB28;
		/* 820CE930h case    3:*/		return 0x820CE934;
	}
	return 0x820CE934;
} // Block from 820CE924h-820CE934h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE934);
		  /* 820CE934h */ case    0:  		/* lis R10, -32255 */
		/* 820CE934h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE934h case    0:*/		return 0x820CE938;
		  /* 820CE938h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE938h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE938h case    1:*/		return 0x820CE93C;
		  /* 820CE93Ch */ case    2:  		/* addi R10, R10, 5036 */
		/* 820CE93Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x13AC);
		/* 820CE93Ch case    2:*/		return 0x820CE940;
		  /* 820CE940h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE940h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE940h case    3:*/		return 0x820CE944;
		  /* 820CE944h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE944h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE944h case    4:*/		return 0x820CE948;
		  /* 820CE948h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CE948h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE948h case    5:*/		return 0x820CE94C;
		  /* 820CE94Ch */ case    6:  		/* subf R9, R8, R9 */
		/* 820CE94Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE94Ch case    6:*/		return 0x820CE950;
		  /* 820CE950h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE950h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CE964;  }
		/* 820CE950h case    7:*/		return 0x820CE954;
		  /* 820CE954h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CE954h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE954h case    8:*/		return 0x820CE958;
		  /* 820CE958h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CE958h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE958h case    9:*/		return 0x820CE95C;
		  /* 820CE95Ch */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CE95Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE95Ch case   10:*/		return 0x820CE960;
		  /* 820CE960h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE960h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CE940;  }
		/* 820CE960h case   11:*/		return 0x820CE964;
	}
	return 0x820CE964;
} // Block from 820CE934h-820CE964h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE964);
		  /* 820CE964h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE964h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE964h case    0:*/		return 0x820CE968;
		  /* 820CE968h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE968h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE974;  }
		/* 820CE968h case    1:*/		return 0x820CE96C;
		  /* 820CE96Ch */ case    2:  		/* li R11, 6 */
		/* 820CE96Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820CE96Ch case    2:*/		return 0x820CE970;
		  /* 820CE970h */ case    3:  		/* b 440 */
		/* 820CE970h case    3:*/		return 0x820CEB28;
		/* 820CE970h case    3:*/		return 0x820CE974;
	}
	return 0x820CE974;
} // Block from 820CE964h-820CE974h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE974);
		  /* 820CE974h */ case    0:  		/* lis R10, -32255 */
		/* 820CE974h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE974h case    0:*/		return 0x820CE978;
		  /* 820CE978h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE978h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE978h case    1:*/		return 0x820CE97C;
		  /* 820CE97Ch */ case    2:  		/* addi R10, R10, 5056 */
		/* 820CE97Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x13C0);
		/* 820CE97Ch case    2:*/		return 0x820CE980;
		  /* 820CE980h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE980h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE980h case    3:*/		return 0x820CE984;
		  /* 820CE984h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE984h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE984h case    4:*/		return 0x820CE988;
		  /* 820CE988h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CE988h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE988h case    5:*/		return 0x820CE98C;
		  /* 820CE98Ch */ case    6:  		/* subf R9, R8, R9 */
		/* 820CE98Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE98Ch case    6:*/		return 0x820CE990;
		  /* 820CE990h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE990h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CE9A4;  }
		/* 820CE990h case    7:*/		return 0x820CE994;
		  /* 820CE994h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CE994h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE994h case    8:*/		return 0x820CE998;
		  /* 820CE998h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CE998h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE998h case    9:*/		return 0x820CE99C;
		  /* 820CE99Ch */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CE99Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE99Ch case   10:*/		return 0x820CE9A0;
		  /* 820CE9A0h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE9A0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CE980;  }
		/* 820CE9A0h case   11:*/		return 0x820CE9A4;
	}
	return 0x820CE9A4;
} // Block from 820CE974h-820CE9A4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE9A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE9A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE9A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE9A4);
		  /* 820CE9A4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE9A4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE9A4h case    0:*/		return 0x820CE9A8;
		  /* 820CE9A8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE9A8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE9B4;  }
		/* 820CE9A8h case    1:*/		return 0x820CE9AC;
		  /* 820CE9ACh */ case    2:  		/* li R11, 7 */
		/* 820CE9ACh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820CE9ACh case    2:*/		return 0x820CE9B0;
		  /* 820CE9B0h */ case    3:  		/* b 376 */
		/* 820CE9B0h case    3:*/		return 0x820CEB28;
		/* 820CE9B0h case    3:*/		return 0x820CE9B4;
	}
	return 0x820CE9B4;
} // Block from 820CE9A4h-820CE9B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE9B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE9B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE9B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE9B4);
		  /* 820CE9B4h */ case    0:  		/* lis R10, -32255 */
		/* 820CE9B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE9B4h case    0:*/		return 0x820CE9B8;
		  /* 820CE9B8h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE9B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE9B8h case    1:*/		return 0x820CE9BC;
		  /* 820CE9BCh */ case    2:  		/* addi R10, R10, 5044 */
		/* 820CE9BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x13B4);
		/* 820CE9BCh case    2:*/		return 0x820CE9C0;
		  /* 820CE9C0h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CE9C0h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CE9C0h case    3:*/		return 0x820CE9C4;
		  /* 820CE9C4h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CE9C4h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CE9C4h case    4:*/		return 0x820CE9C8;
		  /* 820CE9C8h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CE9C8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE9C8h case    5:*/		return 0x820CE9CC;
		  /* 820CE9CCh */ case    6:  		/* subf R9, R8, R9 */
		/* 820CE9CCh case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CE9CCh case    6:*/		return 0x820CE9D0;
		  /* 820CE9D0h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CE9D0h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CE9E4;  }
		/* 820CE9D0h case    7:*/		return 0x820CE9D4;
		  /* 820CE9D4h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CE9D4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CE9D4h case    8:*/		return 0x820CE9D8;
		  /* 820CE9D8h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CE9D8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CE9D8h case    9:*/		return 0x820CE9DC;
		  /* 820CE9DCh */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CE9DCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CE9DCh case   10:*/		return 0x820CE9E0;
		  /* 820CE9E0h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CE9E0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CE9C0;  }
		/* 820CE9E0h case   11:*/		return 0x820CE9E4;
	}
	return 0x820CE9E4;
} // Block from 820CE9B4h-820CE9E4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CE9E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE9E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE9E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE9E4);
		  /* 820CE9E4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CE9E4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CE9E4h case    0:*/		return 0x820CE9E8;
		  /* 820CE9E8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CE9E8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CE9F4;  }
		/* 820CE9E8h case    1:*/		return 0x820CE9EC;
		  /* 820CE9ECh */ case    2:  		/* li R11, 8 */
		/* 820CE9ECh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820CE9ECh case    2:*/		return 0x820CE9F0;
		  /* 820CE9F0h */ case    3:  		/* b 312 */
		/* 820CE9F0h case    3:*/		return 0x820CEB28;
		/* 820CE9F0h case    3:*/		return 0x820CE9F4;
	}
	return 0x820CE9F4;
} // Block from 820CE9E4h-820CE9F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CE9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CE9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CE9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CE9F4);
		  /* 820CE9F4h */ case    0:  		/* lis R10, -32255 */
		/* 820CE9F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CE9F4h case    0:*/		return 0x820CE9F8;
		  /* 820CE9F8h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CE9F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CE9F8h case    1:*/		return 0x820CE9FC;
		  /* 820CE9FCh */ case    2:  		/* addi R10, R10, 5068 */
		/* 820CE9FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x13CC);
		/* 820CE9FCh case    2:*/		return 0x820CEA00;
		  /* 820CEA00h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CEA00h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEA00h case    3:*/		return 0x820CEA04;
		  /* 820CEA04h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CEA04h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CEA04h case    4:*/		return 0x820CEA08;
		  /* 820CEA08h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CEA08h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEA08h case    5:*/		return 0x820CEA0C;
		  /* 820CEA0Ch */ case    6:  		/* subf R9, R8, R9 */
		/* 820CEA0Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CEA0Ch case    6:*/		return 0x820CEA10;
		  /* 820CEA10h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CEA10h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CEA24;  }
		/* 820CEA10h case    7:*/		return 0x820CEA14;
		  /* 820CEA14h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CEA14h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEA14h case    8:*/		return 0x820CEA18;
		  /* 820CEA18h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CEA18h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CEA18h case    9:*/		return 0x820CEA1C;
		  /* 820CEA1Ch */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CEA1Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CEA1Ch case   10:*/		return 0x820CEA20;
		  /* 820CEA20h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CEA20h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CEA00;  }
		/* 820CEA20h case   11:*/		return 0x820CEA24;
	}
	return 0x820CEA24;
} // Block from 820CE9F4h-820CEA24h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CEA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEA24);
		  /* 820CEA24h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CEA24h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEA24h case    0:*/		return 0x820CEA28;
		  /* 820CEA28h */ case    1:  		/* bc 12, CR0_EQ, 268 */
		/* 820CEA28h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CEB34;  }
		/* 820CEA28h case    1:*/		return 0x820CEA2C;
		  /* 820CEA2Ch */ case    2:  		/* lis R10, -32255 */
		/* 820CEA2Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CEA2Ch case    2:*/		return 0x820CEA30;
		  /* 820CEA30h */ case    3:  		/* addi R11, R1, 80 */
		/* 820CEA30h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CEA30h case    3:*/		return 0x820CEA34;
		  /* 820CEA34h */ case    4:  		/* addi R10, R10, 5080 */
		/* 820CEA34h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x13D8);
		/* 820CEA34h case    4:*/		return 0x820CEA38;
		  /* 820CEA38h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820CEA38h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEA38h case    5:*/		return 0x820CEA3C;
		  /* 820CEA3Ch */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820CEA3Ch case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CEA3Ch case    6:*/		return 0x820CEA40;
		  /* 820CEA40h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820CEA40h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEA40h case    7:*/		return 0x820CEA44;
		  /* 820CEA44h */ case    8:  		/* subf R9, R8, R9 */
		/* 820CEA44h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CEA44h case    8:*/		return 0x820CEA48;
		  /* 820CEA48h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820CEA48h case    9:*/		if ( regs.CR[0].eq ) { return 0x820CEA5C;  }
		/* 820CEA48h case    9:*/		return 0x820CEA4C;
		  /* 820CEA4Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 820CEA4Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEA4Ch case   10:*/		return 0x820CEA50;
	}
	return 0x820CEA50;
} // Block from 820CEA24h-820CEA50h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CEA50h
// Function '??0CNodeAsmRegister@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEA50);
		  /* 820CEA50h */ case    0:  		/* addi R10, R10, 1 */
		/* 820CEA50h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CEA50h case    0:*/		return 0x820CEA54;
		  /* 820CEA54h */ case    1:  		/* cmpwi CR6, R9, 0 */
		/* 820CEA54h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CEA54h case    1:*/		return 0x820CEA58;
		  /* 820CEA58h */ case    2:  		/* bc 12, CR6_EQ, -32 */
		/* 820CEA58h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CEA38;  }
		/* 820CEA58h case    2:*/		return 0x820CEA5C;
	}
	return 0x820CEA5C;
} // Block from 820CEA50h-820CEA5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CEA5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEA5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEA5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEA5C);
		  /* 820CEA5Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CEA5Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEA5Ch case    0:*/		return 0x820CEA60;
		  /* 820CEA60h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CEA60h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CEA6C;  }
		/* 820CEA60h case    1:*/		return 0x820CEA64;
		  /* 820CEA64h */ case    2:  		/* li R11, 10 */
		/* 820CEA64h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820CEA64h case    2:*/		return 0x820CEA68;
		  /* 820CEA68h */ case    3:  		/* b 192 */
		/* 820CEA68h case    3:*/		return 0x820CEB28;
		/* 820CEA68h case    3:*/		return 0x820CEA6C;
	}
	return 0x820CEA6C;
} // Block from 820CEA5Ch-820CEA6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CEA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEA6C);
		  /* 820CEA6Ch */ case    0:  		/* lis R10, -32255 */
		/* 820CEA6Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CEA6Ch case    0:*/		return 0x820CEA70;
		  /* 820CEA70h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CEA70h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CEA70h case    1:*/		return 0x820CEA74;
		  /* 820CEA74h */ case    2:  		/* addi R10, R10, 4996 */
		/* 820CEA74h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1384);
		/* 820CEA74h case    2:*/		return 0x820CEA78;
		  /* 820CEA78h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CEA78h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEA78h case    3:*/		return 0x820CEA7C;
		  /* 820CEA7Ch */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CEA7Ch case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CEA7Ch case    4:*/		return 0x820CEA80;
		  /* 820CEA80h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CEA80h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEA80h case    5:*/		return 0x820CEA84;
		  /* 820CEA84h */ case    6:  		/* subf R9, R8, R9 */
		/* 820CEA84h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CEA84h case    6:*/		return 0x820CEA88;
		  /* 820CEA88h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CEA88h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CEA9C;  }
		/* 820CEA88h case    7:*/		return 0x820CEA8C;
		  /* 820CEA8Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 820CEA8Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEA8Ch case    8:*/		return 0x820CEA90;
		  /* 820CEA90h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CEA90h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CEA90h case    9:*/		return 0x820CEA94;
		  /* 820CEA94h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CEA94h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CEA94h case   10:*/		return 0x820CEA98;
		  /* 820CEA98h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CEA98h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CEA78;  }
		/* 820CEA98h case   11:*/		return 0x820CEA9C;
	}
	return 0x820CEA9C;
} // Block from 820CEA6Ch-820CEA9Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CEA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEA9C);
		  /* 820CEA9Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CEA9Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEA9Ch case    0:*/		return 0x820CEAA0;
		  /* 820CEAA0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CEAA0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CEAAC;  }
		/* 820CEAA0h case    1:*/		return 0x820CEAA4;
		  /* 820CEAA4h */ case    2:  		/* li R11, 11 */
		/* 820CEAA4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820CEAA4h case    2:*/		return 0x820CEAA8;
		  /* 820CEAA8h */ case    3:  		/* b 128 */
		/* 820CEAA8h case    3:*/		return 0x820CEB28;
		/* 820CEAA8h case    3:*/		return 0x820CEAAC;
	}
	return 0x820CEAAC;
} // Block from 820CEA9Ch-820CEAACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CEAACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEAAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEAAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEAAC);
		  /* 820CEAACh */ case    0:  		/* lis R10, -32255 */
		/* 820CEAACh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CEAACh case    0:*/		return 0x820CEAB0;
		  /* 820CEAB0h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CEAB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CEAB0h case    1:*/		return 0x820CEAB4;
		  /* 820CEAB4h */ case    2:  		/* addi R10, R10, 5156 */
		/* 820CEAB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1424);
		/* 820CEAB4h case    2:*/		return 0x820CEAB8;
	}
	return 0x820CEAB8;
} // Block from 820CEAACh-820CEAB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CEAB8h
// Function '??0CNodeAsmRegister@D3DXShader@@QAA@KKKHPAVCNode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEAB8);
		  /* 820CEAB8h */ case    0:  		/* lbz R9, <#[R11]> */
		/* 820CEAB8h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEAB8h case    0:*/		return 0x820CEABC;
		  /* 820CEABCh */ case    1:  		/* lbz R8, <#[R10]> */
		/* 820CEABCh case    1:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CEABCh case    1:*/		return 0x820CEAC0;
		  /* 820CEAC0h */ case    2:  		/* cmpwi CR0, R9, 0 */
		/* 820CEAC0h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEAC0h case    2:*/		return 0x820CEAC4;
		  /* 820CEAC4h */ case    3:  		/* subf R9, R8, R9 */
		/* 820CEAC4h case    3:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CEAC4h case    3:*/		return 0x820CEAC8;
		  /* 820CEAC8h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 820CEAC8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820CEADC;  }
		/* 820CEAC8h case    4:*/		return 0x820CEACC;
		  /* 820CEACCh */ case    5:  		/* addi R11, R11, 1 */
		/* 820CEACCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEACCh case    5:*/		return 0x820CEAD0;
		  /* 820CEAD0h */ case    6:  		/* addi R10, R10, 1 */
		/* 820CEAD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CEAD0h case    6:*/		return 0x820CEAD4;
		  /* 820CEAD4h */ case    7:  		/* cmpwi CR6, R9, 0 */
		/* 820CEAD4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CEAD4h case    7:*/		return 0x820CEAD8;
		  /* 820CEAD8h */ case    8:  		/* bc 12, CR6_EQ, -32 */
		/* 820CEAD8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CEAB8;  }
		/* 820CEAD8h case    8:*/		return 0x820CEADC;
	}
	return 0x820CEADC;
} // Block from 820CEAB8h-820CEADCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CEADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEADC);
		  /* 820CEADCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CEADCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEADCh case    0:*/		return 0x820CEAE0;
		  /* 820CEAE0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CEAE0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CEAEC;  }
		/* 820CEAE0h case    1:*/		return 0x820CEAE4;
		  /* 820CEAE4h */ case    2:  		/* li R11, 12 */
		/* 820CEAE4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820CEAE4h case    2:*/		return 0x820CEAE8;
		  /* 820CEAE8h */ case    3:  		/* b 64 */
		/* 820CEAE8h case    3:*/		return 0x820CEB28;
		/* 820CEAE8h case    3:*/		return 0x820CEAEC;
	}
	return 0x820CEAEC;
} // Block from 820CEADCh-820CEAECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CEAECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEAEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEAEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEAEC);
		  /* 820CEAECh */ case    0:  		/* lis R10, -32255 */
		/* 820CEAECh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CEAECh case    0:*/		return 0x820CEAF0;
		  /* 820CEAF0h */ case    1:  		/* addi R11, R1, 80 */
		/* 820CEAF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820CEAF0h case    1:*/		return 0x820CEAF4;
		  /* 820CEAF4h */ case    2:  		/* addi R10, R10, 5168 */
		/* 820CEAF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1430);
		/* 820CEAF4h case    2:*/		return 0x820CEAF8;
		  /* 820CEAF8h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CEAF8h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEAF8h case    3:*/		return 0x820CEAFC;
		  /* 820CEAFCh */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CEAFCh case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CEAFCh case    4:*/		return 0x820CEB00;
		  /* 820CEB00h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CEB00h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEB00h case    5:*/		return 0x820CEB04;
		  /* 820CEB04h */ case    6:  		/* subf R9, R8, R9 */
		/* 820CEB04h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CEB04h case    6:*/		return 0x820CEB08;
		  /* 820CEB08h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CEB08h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CEB1C;  }
		/* 820CEB08h case    7:*/		return 0x820CEB0C;
		  /* 820CEB0Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 820CEB0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEB0Ch case    8:*/		return 0x820CEB10;
		  /* 820CEB10h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CEB10h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CEB10h case    9:*/		return 0x820CEB14;
		  /* 820CEB14h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CEB14h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CEB14h case   10:*/		return 0x820CEB18;
		  /* 820CEB18h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CEB18h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CEAF8;  }
		/* 820CEB18h case   11:*/		return 0x820CEB1C;
	}
	return 0x820CEB1C;
} // Block from 820CEAECh-820CEB1Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB1C);
		  /* 820CEB1Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CEB1Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEB1Ch case    0:*/		return 0x820CEB20;
	}
	return 0x820CEB20;
} // Block from 820CEB1Ch-820CEB20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB20h
// Function '?Copy@CNodeAsmRegister@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB20);
		  /* 820CEB20h */ case    0:  		/* bc 4, CR0_EQ, 20 */
		/* 820CEB20h case    0:*/		if ( !regs.CR[0].eq ) { return 0x820CEB34;  }
		/* 820CEB20h case    0:*/		return 0x820CEB24;
		  /* 820CEB24h */ case    1:  		/* li R11, 13 */
		/* 820CEB24h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820CEB24h case    1:*/		return 0x820CEB28;
	}
	return 0x820CEB28;
} // Block from 820CEB20h-820CEB28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB28);
		  /* 820CEB28h */ case    0:  		/* stw R11, <#[R28]> */
		/* 820CEB28h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820CEB28h case    0:*/		return 0x820CEB2C;
	}
	return 0x820CEB2C;
} // Block from 820CEB28h-820CEB2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB2C);
		  /* 820CEB2Ch */ case    0:  		/* li R3, 1 */
		/* 820CEB2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CEB2Ch case    0:*/		return 0x820CEB30;
		  /* 820CEB30h */ case    1:  		/* b 8 */
		/* 820CEB30h case    1:*/		return 0x820CEB38;
		/* 820CEB30h case    1:*/		return 0x820CEB34;
	}
	return 0x820CEB34;
} // Block from 820CEB2Ch-820CEB34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB34);
		  /* 820CEB34h */ case    0:  		/* li R3, 0 */
		/* 820CEB34h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CEB34h case    0:*/		return 0x820CEB38;
	}
	return 0x820CEB38;
} // Block from 820CEB34h-820CEB38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB38);
		  /* 820CEB38h */ case    0:  		/* addi R1, R1, 144 */
		/* 820CEB38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820CEB38h case    0:*/		return 0x820CEB3C;
		  /* 820CEB3Ch */ case    1:  		/* b -252052 */
		/* 820CEB3Ch case    1:*/		return 0x820912A8;
		/* 820CEB3Ch case    1:*/		return 0x820CEB40;
	}
	return 0x820CEB40;
} // Block from 820CEB38h-820CEB40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB40);
		  /* 820CEB40h */ case    0:  		/* mfspr R12, LR */
		/* 820CEB40h case    0:*/		regs.R12 = regs.LR;
		/* 820CEB40h case    0:*/		return 0x820CEB44;
		  /* 820CEB44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CEB44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CEB44h case    1:*/		return 0x820CEB48;
		  /* 820CEB48h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CEB48h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CEB48h case    2:*/		return 0x820CEB4C;
		  /* 820CEB4Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CEB4Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CEB4Ch case    3:*/		return 0x820CEB50;
		  /* 820CEB50h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CEB50h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CEB50h case    4:*/		return 0x820CEB54;
		  /* 820CEB54h */ case    5:  		/* mr R31, R3 */
		/* 820CEB54h case    5:*/		regs.R31 = regs.R3;
		/* 820CEB54h case    5:*/		return 0x820CEB58;
		  /* 820CEB58h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 820CEB58h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CEB58h case    6:*/		return 0x820CEB5C;
		  /* 820CEB5Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820CEB5Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820CEB68;  }
		/* 820CEB5Ch case    7:*/		return 0x820CEB60;
		  /* 820CEB60h */ case    8:  		/* mr R3, R4 */
		/* 820CEB60h case    8:*/		regs.R3 = regs.R4;
		/* 820CEB60h case    8:*/		return 0x820CEB64;
		  /* 820CEB64h */ case    9:  		/* b 56 */
		/* 820CEB64h case    9:*/		return 0x820CEB9C;
		/* 820CEB64h case    9:*/		return 0x820CEB68;
	}
	return 0x820CEB68;
} // Block from 820CEB40h-820CEB68h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB68);
		  /* 820CEB68h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820CEB68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CEB68h case    0:*/		return 0x820CEB6C;
		  /* 820CEB6Ch */ case    1:  		/* li R30, 1 */
		/* 820CEB6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820CEB6Ch case    1:*/		return 0x820CEB70;
		  /* 820CEB70h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820CEB70h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CEB70h case    2:*/		return 0x820CEB74;
		  /* 820CEB74h */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 820CEB74h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820CEB94;  }
		/* 820CEB74h case    3:*/		return 0x820CEB78;
		  /* 820CEB78h */ case    4:  		/* lis R11, -32255 */
		/* 820CEB78h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CEB78h case    4:*/		return 0x820CEB7C;
		  /* 820CEB7Ch */ case    5:  		/* lwz R3, <#[R31]> */
		/* 820CEB7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820CEB7Ch case    5:*/		return 0x820CEB80;
		  /* 820CEB80h */ case    6:  		/* li R5, 0 */
		/* 820CEB80h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820CEB80h case    6:*/		return 0x820CEB84;
		  /* 820CEB84h */ case    7:  		/* addi R6, R11, -10784 */
		/* 820CEB84h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD5E0);
		/* 820CEB84h case    7:*/		return 0x820CEB88;
		  /* 820CEB88h */ case    8:  		/* addi R4, R31, 16 */
		/* 820CEB88h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820CEB88h case    8:*/		return 0x820CEB8C;
		  /* 820CEB8Ch */ case    9:  		/* bl -162300 */
		/* 820CEB8Ch case    9:*/		regs.LR = 0x820CEB90; return 0x820A7190;
		/* 820CEB8Ch case    9:*/		return 0x820CEB90;
		  /* 820CEB90h */ case   10:  		/* stw R30, <#[R31 + 60]> */
		/* 820CEB90h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CEB90h case   10:*/		return 0x820CEB94;
	}
	return 0x820CEB94;
} // Block from 820CEB68h-820CEB94h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB94);
		  /* 820CEB94h */ case    0:  		/* li R3, 0 */
		/* 820CEB94h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CEB94h case    0:*/		return 0x820CEB98;
		  /* 820CEB98h */ case    1:  		/* stw R30, <#[R31 + 64]> */
		/* 820CEB98h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000040) );
		/* 820CEB98h case    1:*/		return 0x820CEB9C;
	}
	return 0x820CEB9C;
} // Block from 820CEB94h-820CEB9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEB9C);
		  /* 820CEB9Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820CEB9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CEB9Ch case    0:*/		return 0x820CEBA0;
		  /* 820CEBA0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CEBA0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CEBA0h case    1:*/		return 0x820CEBA4;
		  /* 820CEBA4h */ case    2:  		/* mtspr LR, R12 */
		/* 820CEBA4h case    2:*/		regs.LR = regs.R12;
		/* 820CEBA4h case    2:*/		return 0x820CEBA8;
		  /* 820CEBA8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CEBA8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CEBA8h case    3:*/		return 0x820CEBAC;
		  /* 820CEBACh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CEBACh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CEBACh case    4:*/		return 0x820CEBB0;
		  /* 820CEBB0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CEBB0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CEBB0h case    5:*/		return 0x820CEBB4;
	}
	return 0x820CEBB4;
} // Block from 820CEB9Ch-820CEBB4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CEBB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEBB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEBB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEBB4);
		  /* 820CEBB4h */ case    0:  		/* nop */
		/* 820CEBB4h case    0:*/		cpu::op::nop();
		/* 820CEBB4h case    0:*/		return 0x820CEBB8;
	}
	return 0x820CEBB8;
} // Block from 820CEBB4h-820CEBB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEBB8);
		  /* 820CEBB8h */ case    0:  		/* mfspr R12, LR */
		/* 820CEBB8h case    0:*/		regs.R12 = regs.LR;
		/* 820CEBB8h case    0:*/		return 0x820CEBBC;
		  /* 820CEBBCh */ case    1:  		/* bl -252260 */
		/* 820CEBBCh case    1:*/		regs.LR = 0x820CEBC0; return 0x82091258;
		/* 820CEBBCh case    1:*/		return 0x820CEBC0;
		  /* 820CEBC0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CEBC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CEBC0h case    2:*/		return 0x820CEBC4;
		  /* 820CEBC4h */ case    3:  		/* mr R31, R3 */
		/* 820CEBC4h case    3:*/		regs.R31 = regs.R3;
		/* 820CEBC4h case    3:*/		return 0x820CEBC8;
		  /* 820CEBC8h */ case    4:  		/* mr R30, R4 */
		/* 820CEBC8h case    4:*/		regs.R30 = regs.R4;
		/* 820CEBC8h case    4:*/		return 0x820CEBCC;
		  /* 820CEBCCh */ case    5:  		/* mr R28, R5 */
		/* 820CEBCCh case    5:*/		regs.R28 = regs.R5;
		/* 820CEBCCh case    5:*/		return 0x820CEBD0;
		  /* 820CEBD0h */ case    6:  		/* mr R11, R4 */
		/* 820CEBD0h case    6:*/		regs.R11 = regs.R4;
		/* 820CEBD0h case    6:*/		return 0x820CEBD4;
		  /* 820CEBD4h */ case    7:  		/* lbz R10, <#[R11]> */
		/* 820CEBD4h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEBD4h case    7:*/		return 0x820CEBD8;
		  /* 820CEBD8h */ case    8:  		/* addi R11, R11, 1 */
		/* 820CEBD8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEBD8h case    8:*/		return 0x820CEBDC;
		  /* 820CEBDCh */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820CEBDCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CEBDCh case    9:*/		return 0x820CEBE0;
		  /* 820CEBE0h */ case   10:  		/* bc 4, CR6_EQ, -12 */
		/* 820CEBE0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820CEBD4;  }
		/* 820CEBE0h case   10:*/		return 0x820CEBE4;
		  /* 820CEBE4h */ case   11:  		/* subf R11, R30, R11 */
		/* 820CEBE4h case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820CEBE4h case   11:*/		return 0x820CEBE8;
	}
	return 0x820CEBE8;
} // Block from 820CEBB8h-820CEBE8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CEBE8h
// Function '??0CCommentBlock@D3DXShader@@QAA@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEBE8);
		  /* 820CEBE8h */ case    0:  		/* addi R11, R11, -1 */
		/* 820CEBE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820CEBE8h case    0:*/		return 0x820CEBEC;
		  /* 820CEBECh */ case    1:  		/* rlwinm R29, R11, 0, 0, 31 */
		/* 820CEBECh case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R29,regs.R11);
		/* 820CEBECh case    1:*/		return 0x820CEBF0;
		  /* 820CEBF0h */ case    2:  		/* b 64 */
		/* 820CEBF0h case    2:*/		return 0x820CEC30;
		/* 820CEBF0h case    2:*/		return 0x820CEBF4;
		  /* 820CEBF4h */ case    3:  		/* mr R11, R4 */
		/* 820CEBF4h case    3:*/		regs.R11 = regs.R4;
		/* 820CEBF4h case    3:*/		return 0x820CEBF8;
		  /* 820CEBF8h */ case    4:  		/* lbz R10, <#[R11]> */
		/* 820CEBF8h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEBF8h case    4:*/		return 0x820CEBFC;
		  /* 820CEBFCh */ case    5:  		/* addi R11, R11, 1 */
		/* 820CEBFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEBFCh case    5:*/		return 0x820CEC00;
		  /* 820CEC00h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820CEC00h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CEC00h case    6:*/		return 0x820CEC04;
		  /* 820CEC04h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 820CEC04h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820CEBF8;  }
		/* 820CEC04h case    7:*/		return 0x820CEC08;
	}
	return 0x820CEC08;
} // Block from 820CEBE8h-820CEC08h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CEC08h
// Function '?SizeInDwords@CCommentBlock@D3DXShader@@QAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEC08);
		  /* 820CEC08h */ case    0:  		/* subf R11, R4, R11 */
		/* 820CEC08h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 820CEC08h case    0:*/		return 0x820CEC0C;
		  /* 820CEC0Ch */ case    1:  		/* addi R11, R11, -1 */
		/* 820CEC0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820CEC0Ch case    1:*/		return 0x820CEC10;
		  /* 820CEC10h */ case    2:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820CEC10h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820CEC10h case    2:*/		return 0x820CEC14;
		  /* 820CEC14h */ case    3:  		/* cmplw CR6, R11, R29 */
		/* 820CEC14h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820CEC14h case    3:*/		return 0x820CEC18;
		  /* 820CEC18h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 820CEC18h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CEC2C;  }
		/* 820CEC18h case    4:*/		return 0x820CEC1C;
		  /* 820CEC1Ch */ case    5:  		/* mr R3, R30 */
		/* 820CEC1Ch case    5:*/		regs.R3 = regs.R30;
		/* 820CEC1Ch case    5:*/		return 0x820CEC20;
	}
	return 0x820CEC20;
} // Block from 820CEC08h-820CEC20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CEC20h
// Function '??1CCommentBlock@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEC20);
		  /* 820CEC20h */ case    0:  		/* bl -243696 */
		/* 820CEC20h case    0:*/		regs.LR = 0x820CEC24; return 0x82093430;
		/* 820CEC20h case    0:*/		return 0x820CEC24;
		  /* 820CEC24h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820CEC24h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CEC24h case    1:*/		return 0x820CEC28;
		  /* 820CEC28h */ case    2:  		/* bc 12, CR0_EQ, 44 */
		/* 820CEC28h case    2:*/		if ( regs.CR[0].eq ) { return 0x820CEC54;  }
		/* 820CEC28h case    2:*/		return 0x820CEC2C;
	}
	return 0x820CEC2C;
} // Block from 820CEC20h-820CEC2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CEC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEC2C);
		  /* 820CEC2Ch */ case    0:  		/* addi R31, R31, 8 */
		/* 820CEC2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 820CEC2Ch case    0:*/		return 0x820CEC30;
	}
	return 0x820CEC30;
} // Block from 820CEC2Ch-820CEC30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEC30);
		  /* 820CEC30h */ case    0:  		/* lwz R4, <#[R31 + 4]> */
		/* 820CEC30h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 820CEC30h case    0:*/		return 0x820CEC34;
		  /* 820CEC34h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820CEC34h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CEC34h case    1:*/		return 0x820CEC38;
		  /* 820CEC38h */ case    2:  		/* bc 4, CR6_EQ, -68 */
		/* 820CEC38h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CEBF4;  }
		/* 820CEC38h case    2:*/		return 0x820CEC3C;
		  /* 820CEC3Ch */ case    3:  		/* lis R3, -32768 */
		/* 820CEC3Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CEC3Ch case    3:*/		return 0x820CEC40;
		  /* 820CEC40h */ case    4:  		/* li R11, -1 */
		/* 820CEC40h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820CEC40h case    4:*/		return 0x820CEC44;
		  /* 820CEC44h */ case    5:  		/* ori R3, R3, 16389 */
		/* 820CEC44h case    5:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CEC44h case    5:*/		return 0x820CEC48;
		  /* 820CEC48h */ case    6:  		/* stw R11, <#[R28]> */
		/* 820CEC48h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820CEC48h case    6:*/		return 0x820CEC4C;
		  /* 820CEC4Ch */ case    7:  		/* addi R1, R1, 128 */
		/* 820CEC4Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CEC4Ch case    7:*/		return 0x820CEC50;
		  /* 820CEC50h */ case    8:  		/* b -252328 */
		/* 820CEC50h case    8:*/		return 0x820912A8;
		/* 820CEC50h case    8:*/		return 0x820CEC54;
	}
	return 0x820CEC54;
} // Block from 820CEC30h-820CEC54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CEC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEC54);
		  /* 820CEC54h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820CEC54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820CEC54h case    0:*/		return 0x820CEC58;
		  /* 820CEC58h */ case    1:  		/* li R3, 0 */
		/* 820CEC58h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CEC58h case    1:*/		return 0x820CEC5C;
		  /* 820CEC5Ch */ case    2:  		/* b -20 */
		/* 820CEC5Ch case    2:*/		return 0x820CEC48;
		/* 820CEC5Ch case    2:*/		return 0x820CEC60;
	}
	return 0x820CEC60;
} // Block from 820CEC54h-820CEC60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CEC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEC60);
		  /* 820CEC60h */ case    0:  		/* mfspr R12, LR */
		/* 820CEC60h case    0:*/		regs.R12 = regs.LR;
		/* 820CEC60h case    0:*/		return 0x820CEC64;
		  /* 820CEC64h */ case    1:  		/* bl -252428 */
		/* 820CEC64h case    1:*/		regs.LR = 0x820CEC68; return 0x82091258;
		/* 820CEC64h case    1:*/		return 0x820CEC68;
		  /* 820CEC68h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820CEC68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820CEC68h case    2:*/		return 0x820CEC6C;
		  /* 820CEC6Ch */ case    3:  		/* lwz R30, <#[R6]> */
		/* 820CEC6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R6 + 0x00000000) );
		/* 820CEC6Ch case    3:*/		return 0x820CEC70;
		  /* 820CEC70h */ case    4:  		/* mr R8, R3 */
		/* 820CEC70h case    4:*/		regs.R8 = regs.R3;
		/* 820CEC70h case    4:*/		return 0x820CEC74;
		  /* 820CEC74h */ case    5:  		/* mr R3, R5 */
		/* 820CEC74h case    5:*/		regs.R3 = regs.R5;
		/* 820CEC74h case    5:*/		return 0x820CEC78;
		  /* 820CEC78h */ case    6:  		/* mr R28, R6 */
		/* 820CEC78h case    6:*/		regs.R28 = regs.R6;
		/* 820CEC78h case    6:*/		return 0x820CEC7C;
		  /* 820CEC7Ch */ case    7:  		/* mr R29, R4 */
		/* 820CEC7Ch case    7:*/		regs.R29 = regs.R4;
		/* 820CEC7Ch case    7:*/		return 0x820CEC80;
		  /* 820CEC80h */ case    8:  		/* rlwinm R5, R4, 3, 0, 28 */
		/* 820CEC80h case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R4);
		/* 820CEC80h case    8:*/		return 0x820CEC84;
		  /* 820CEC84h */ case    9:  		/* li R6, 0 */
		/* 820CEC84h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820CEC84h case    9:*/		return 0x820CEC88;
		  /* 820CEC88h */ case   10:  		/* cmplwi CR6, R30, 0 */
		/* 820CEC88h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CEC88h case   10:*/		return 0x820CEC8C;
		  /* 820CEC8Ch */ case   11:  		/* bc 12, CR6_EQ, 100 */
		/* 820CEC8Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820CECF0;  }
		/* 820CEC8Ch case   11:*/		return 0x820CEC90;
		  /* 820CEC90h */ case   12:  		/* mr R4, R3 */
		/* 820CEC90h case   12:*/		regs.R4 = regs.R3;
		/* 820CEC90h case   12:*/		return 0x820CEC94;
		  /* 820CEC94h */ case   13:  		/* subf R11, R6, R30 */
		/* 820CEC94h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R30);
		/* 820CEC94h case   13:*/		return 0x820CEC98;
	}
	return 0x820CEC98;
} // Block from 820CEC60h-820CEC98h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CEC98h
// Function '?Add@CCommentBlock@D3DXShader@@QAAJPBXIKPAKW4SegmentType@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEC98);
		  /* 820CEC98h */ case    0:  		/* cmplw CR6, R11, R29 */
		/* 820CEC98h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820CEC98h case    0:*/		return 0x820CEC9C;
		  /* 820CEC9Ch */ case    1:  		/* bc 12, CR6_LT, 84 */
		/* 820CEC9Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x820CECF0;  }
		/* 820CEC9Ch case    1:*/		return 0x820CECA0;
		  /* 820CECA0h */ case    2:  		/* mr R10, R4 */
		/* 820CECA0h case    2:*/		regs.R10 = regs.R4;
		/* 820CECA0h case    2:*/		return 0x820CECA4;
		  /* 820CECA4h */ case    3:  		/* mr R11, R8 */
		/* 820CECA4h case    3:*/		regs.R11 = regs.R8;
		/* 820CECA4h case    3:*/		return 0x820CECA8;
		  /* 820CECA8h */ case    4:  		/* li R9, 0 */
		/* 820CECA8h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CECA8h case    4:*/		return 0x820CECAC;
		  /* 820CECACh */ case    5:  		/* cmplwi CR0, R5, 0 */
		/* 820CECACh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R5,0x00000000);
		/* 820CECACh case    5:*/		return 0x820CECB0;
		  /* 820CECB0h */ case    6:  		/* bc 12, CR0_EQ, 40 */
		/* 820CECB0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820CECD8;  }
		/* 820CECB0h case    6:*/		return 0x820CECB4;
		  /* 820CECB4h */ case    7:  		/* add R7, R8, R5 */
		/* 820CECB4h case    7:*/		cpu::op::add<0>(regs,&regs.R7,regs.R8,regs.R5);
		/* 820CECB4h case    7:*/		return 0x820CECB8;
		  /* 820CECB8h */ case    8:  		/* lbz R9, <#[R11]> */
		/* 820CECB8h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CECB8h case    8:*/		return 0x820CECBC;
		  /* 820CECBCh */ case    9:  		/* lbz R31, <#[R10]> */
		/* 820CECBCh case    9:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000000) );
		/* 820CECBCh case    9:*/		return 0x820CECC0;
		  /* 820CECC0h */ case   10:  		/* subf. R9, R31, R9 */
		/* 820CECC0h case   10:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R31,regs.R9);
		/* 820CECC0h case   10:*/		return 0x820CECC4;
		  /* 820CECC4h */ case   11:  		/* bc 4, CR0_EQ, 20 */
		/* 820CECC4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820CECD8;  }
		/* 820CECC4h case   11:*/		return 0x820CECC8;
		  /* 820CECC8h */ case   12:  		/* addi R11, R11, 1 */
		/* 820CECC8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CECC8h case   12:*/		return 0x820CECCC;
		  /* 820CECCCh */ case   13:  		/* addi R10, R10, 1 */
		/* 820CECCCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CECCCh case   13:*/		return 0x820CECD0;
		  /* 820CECD0h */ case   14:  		/* cmpw CR6, R11, R7 */
		/* 820CECD0h case   14:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R7);
		/* 820CECD0h case   14:*/		return 0x820CECD4;
		  /* 820CECD4h */ case   15:  		/* bc 4, CR6_EQ, -28 */
		/* 820CECD4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820CECB8;  }
		/* 820CECD4h case   15:*/		return 0x820CECD8;
	}
	return 0x820CECD8;
} // Block from 820CEC98h-820CECD8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CECD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CECD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CECD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CECD8);
		  /* 820CECD8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CECD8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CECD8h case    0:*/		return 0x820CECDC;
		  /* 820CECDCh */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 820CECDCh case    1:*/		if ( regs.CR[0].eq ) { return 0x820CED14;  }
		/* 820CECDCh case    1:*/		return 0x820CECE0;
		  /* 820CECE0h */ case    2:  		/* addi R6, R6, 1 */
		/* 820CECE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820CECE0h case    2:*/		return 0x820CECE4;
		  /* 820CECE4h */ case    3:  		/* addi R4, R4, 8 */
		/* 820CECE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x8);
		/* 820CECE4h case    3:*/		return 0x820CECE8;
		  /* 820CECE8h */ case    4:  		/* cmplw CR6, R6, R30 */
		/* 820CECE8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R30);
		/* 820CECE8h case    4:*/		return 0x820CECEC;
		  /* 820CECECh */ case    5:  		/* bc 12, CR6_LT, -88 */
		/* 820CECECh case    5:*/		if ( regs.CR[6].lt ) { return 0x820CEC94;  }
		/* 820CECECh case    5:*/		return 0x820CECF0;
	}
	return 0x820CECF0;
} // Block from 820CECD8h-820CECF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CECF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CECF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CECF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CECF0);
		  /* 820CECF0h */ case    0:  		/* rlwinm R31, R30, 3, 0, 28 */
		/* 820CECF0h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R31,regs.R30);
		/* 820CECF0h case    0:*/		return 0x820CECF4;
		  /* 820CECF4h */ case    1:  		/* mr R4, R8 */
		/* 820CECF4h case    1:*/		regs.R4 = regs.R8;
		/* 820CECF4h case    1:*/		return 0x820CECF8;
		  /* 820CECF8h */ case    2:  		/* add R3, R31, R3 */
		/* 820CECF8h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R31,regs.R3);
		/* 820CECF8h case    2:*/		return 0x820CECFC;
		  /* 820CECFCh */ case    3:  		/* bl -250700 */
		/* 820CECFCh case    3:*/		regs.LR = 0x820CED00; return 0x820919B0;
		/* 820CECFCh case    3:*/		return 0x820CED00;
		  /* 820CED00h */ case    4:  		/* add R11, R30, R29 */
		/* 820CED00h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R29);
		/* 820CED00h case    4:*/		return 0x820CED04;
		  /* 820CED04h */ case    5:  		/* mr R3, R31 */
		/* 820CED04h case    5:*/		regs.R3 = regs.R31;
		/* 820CED04h case    5:*/		return 0x820CED08;
		  /* 820CED08h */ case    6:  		/* stw R11, <#[R28]> */
		/* 820CED08h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820CED08h case    6:*/		return 0x820CED0C;
		  /* 820CED0Ch */ case    7:  		/* addi R1, R1, 128 */
		/* 820CED0Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820CED0Ch case    7:*/		return 0x820CED10;
		  /* 820CED10h */ case    8:  		/* b -252520 */
		/* 820CED10h case    8:*/		return 0x820912A8;
		/* 820CED10h case    8:*/		return 0x820CED14;
	}
	return 0x820CED14;
} // Block from 820CECF0h-820CED14h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CED14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CED14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CED14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CED14);
		  /* 820CED14h */ case    0:  		/* rlwinm R3, R6, 3, 0, 28 */
		/* 820CED14h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R6);
		/* 820CED14h case    0:*/		return 0x820CED18;
		  /* 820CED18h */ case    1:  		/* b -12 */
		/* 820CED18h case    1:*/		return 0x820CED0C;
		/* 820CED18h case    1:*/		return 0x820CED1C;
		  /* 820CED1Ch */ case    2:  		/* nop */
		/* 820CED1Ch case    2:*/		cpu::op::nop();
		/* 820CED1Ch case    2:*/		return 0x820CED20;
	}
	return 0x820CED20;
} // Block from 820CED14h-820CED20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CED20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CED20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CED20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CED20);
		  /* 820CED20h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 820CED20h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CED20h case    0:*/		return 0x820CED24;
		  /* 820CED24h */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 820CED24h case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CED24h case    1:*/		return 0x820CED28;
		  /* 820CED28h */ case    2:  		/* lwz R8, <#[R5]> */
		/* 820CED28h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 820CED28h case    2:*/		return 0x820CED2C;
		  /* 820CED2Ch */ case    3:  		/* mr R10, R3 */
		/* 820CED2Ch case    3:*/		regs.R10 = regs.R3;
		/* 820CED2Ch case    3:*/		return 0x820CED30;
		  /* 820CED30h */ case    4:  		/* li R31, 0 */
		/* 820CED30h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CED30h case    4:*/		return 0x820CED34;
		  /* 820CED34h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 820CED34h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820CED34h case    5:*/		return 0x820CED38;
		  /* 820CED38h */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 820CED38h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CED84;  }
		/* 820CED38h case    6:*/		return 0x820CED3C;
		  /* 820CED3Ch */ case    7:  		/* mr R7, R4 */
		/* 820CED3Ch case    7:*/		regs.R7 = regs.R4;
		/* 820CED3Ch case    7:*/		return 0x820CED40;
		  /* 820CED40h */ case    8:  		/* mr R9, R7 */
		/* 820CED40h case    8:*/		regs.R9 = regs.R7;
		/* 820CED40h case    8:*/		return 0x820CED44;
		  /* 820CED44h */ case    9:  		/* mr R11, R10 */
		/* 820CED44h case    9:*/		regs.R11 = regs.R10;
		/* 820CED44h case    9:*/		return 0x820CED48;
		  /* 820CED48h */ case   10:  		/* addi R3, R10, 16 */
		/* 820CED48h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x10);
		/* 820CED48h case   10:*/		return 0x820CED4C;
		  /* 820CED4Ch */ case   11:  		/* lbz R6, <#[R11]> */
		/* 820CED4Ch case   11:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820CED4Ch case   11:*/		return 0x820CED50;
		  /* 820CED50h */ case   12:  		/* lbz R30, <#[R9]> */
		/* 820CED50h case   12:*/		cpu::mem::load8z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000000) );
		/* 820CED50h case   12:*/		return 0x820CED54;
		  /* 820CED54h */ case   13:  		/* subf. R6, R30, R6 */
		/* 820CED54h case   13:*/		cpu::op::subf<1>(regs,&regs.R6,regs.R30,regs.R6);
		/* 820CED54h case   13:*/		return 0x820CED58;
		  /* 820CED58h */ case   14:  		/* bc 4, CR0_EQ, 20 */
		/* 820CED58h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820CED6C;  }
		/* 820CED58h case   14:*/		return 0x820CED5C;
		  /* 820CED5Ch */ case   15:  		/* addi R11, R11, 1 */
		/* 820CED5Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CED5Ch case   15:*/		return 0x820CED60;
		  /* 820CED60h */ case   16:  		/* addi R9, R9, 1 */
		/* 820CED60h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820CED60h case   16:*/		return 0x820CED64;
		  /* 820CED64h */ case   17:  		/* cmpw CR6, R11, R3 */
		/* 820CED64h case   17:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R3);
		/* 820CED64h case   17:*/		return 0x820CED68;
		  /* 820CED68h */ case   18:  		/* bc 4, CR6_EQ, -28 */
		/* 820CED68h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820CED4C;  }
		/* 820CED68h case   18:*/		return 0x820CED6C;
	}
	return 0x820CED6C;
} // Block from 820CED20h-820CED6Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CED6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CED6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CED6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CED6C);
		  /* 820CED6Ch */ case    0:  		/* cmpwi CR0, R6, 0 */
		/* 820CED6Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R6,0x00000000);
		/* 820CED6Ch case    0:*/		return 0x820CED70;
		  /* 820CED70h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 820CED70h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CEDC0;  }
		/* 820CED70h case    1:*/		return 0x820CED74;
		  /* 820CED74h */ case    2:  		/* addi R31, R31, 1 */
		/* 820CED74h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820CED74h case    2:*/		return 0x820CED78;
		  /* 820CED78h */ case    3:  		/* addi R7, R7, 16 */
		/* 820CED78h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x10);
		/* 820CED78h case    3:*/		return 0x820CED7C;
		  /* 820CED7Ch */ case    4:  		/* cmplw CR6, R31, R8 */
		/* 820CED7Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R8);
		/* 820CED7Ch case    4:*/		return 0x820CED80;
		  /* 820CED80h */ case    5:  		/* bc 12, CR6_LT, -64 */
		/* 820CED80h case    5:*/		if ( regs.CR[6].lt ) { return 0x820CED40;  }
		/* 820CED80h case    5:*/		return 0x820CED84;
	}
	return 0x820CED84;
} // Block from 820CED6Ch-820CED84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CED84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CED84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CED84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CED84);
		  /* 820CED84h */ case    0:  		/* rlwinm R3, R8, 4, 0, 27 */
		/* 820CED84h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R8);
		/* 820CED84h case    0:*/		return 0x820CED88;
		  /* 820CED88h */ case    1:  		/* lwz R9, <#[R10]> */
		/* 820CED88h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820CED88h case    1:*/		return 0x820CED8C;
		  /* 820CED8Ch */ case    2:  		/* addi R8, R8, 1 */
		/* 820CED8Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820CED8Ch case    2:*/		return 0x820CED90;
		  /* 820CED90h */ case    3:  		/* add R11, R3, R4 */
		/* 820CED90h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 820CED90h case    3:*/		return 0x820CED94;
		  /* 820CED94h */ case    4:  		/* stwx R9, <#[R3 + R4]> */
		/* 820CED94h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + regs.R4 + 0x00000000) );
		/* 820CED94h case    4:*/		return 0x820CED98;
		  /* 820CED98h */ case    5:  		/* lwz R9, <#[R10 + 4]> */
		/* 820CED98h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820CED98h case    5:*/		return 0x820CED9C;
		  /* 820CED9Ch */ case    6:  		/* stw R9, <#[R11 + 4]> */
		/* 820CED9Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820CED9Ch case    6:*/		return 0x820CEDA0;
		  /* 820CEDA0h */ case    7:  		/* lwz R9, <#[R10 + 8]> */
		/* 820CEDA0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820CEDA0h case    7:*/		return 0x820CEDA4;
		  /* 820CEDA4h */ case    8:  		/* stw R9, <#[R11 + 8]> */
		/* 820CEDA4h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820CEDA4h case    8:*/		return 0x820CEDA8;
		  /* 820CEDA8h */ case    9:  		/* lwz R10, <#[R10 + 12]> */
		/* 820CEDA8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820CEDA8h case    9:*/		return 0x820CEDAC;
		  /* 820CEDACh */ case   10:  		/* stw R10, <#[R11 + 12]> */
		/* 820CEDACh case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820CEDACh case   10:*/		return 0x820CEDB0;
		  /* 820CEDB0h */ case   11:  		/* stw R8, <#[R5]> */
		/* 820CEDB0h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 820CEDB0h case   11:*/		return 0x820CEDB4;
		  /* 820CEDB4h */ case   12:  		/* ld R30, <#[R1 - 16]> */
		/* 820CEDB4h case   12:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CEDB4h case   12:*/		return 0x820CEDB8;
		  /* 820CEDB8h */ case   13:  		/* ld R31, <#[R1 - 8]> */
		/* 820CEDB8h case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CEDB8h case   13:*/		return 0x820CEDBC;
		  /* 820CEDBCh */ case   14:  		/* bclr 20, CR0_LT */
		/* 820CEDBCh case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CEDBCh case   14:*/		return 0x820CEDC0;
	}
	return 0x820CEDC0;
} // Block from 820CED84h-820CEDC0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820CEDC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEDC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEDC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEDC0);
		  /* 820CEDC0h */ case    0:  		/* rlwinm R3, R31, 4, 0, 27 */
		/* 820CEDC0h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R31);
		/* 820CEDC0h case    0:*/		return 0x820CEDC4;
		  /* 820CEDC4h */ case    1:  		/* b -16 */
		/* 820CEDC4h case    1:*/		return 0x820CEDB4;
		/* 820CEDC4h case    1:*/		return 0x820CEDC8;
	}
	return 0x820CEDC8;
} // Block from 820CEDC0h-820CEDC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEDC8);
		  /* 820CEDC8h */ case    0:  		/* mfspr R12, LR */
		/* 820CEDC8h case    0:*/		regs.R12 = regs.LR;
		/* 820CEDC8h case    0:*/		return 0x820CEDCC;
		  /* 820CEDCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CEDCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CEDCCh case    1:*/		return 0x820CEDD0;
		  /* 820CEDD0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CEDD0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CEDD0h case    2:*/		return 0x820CEDD4;
		  /* 820CEDD4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CEDD4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CEDD4h case    3:*/		return 0x820CEDD8;
		  /* 820CEDD8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CEDD8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CEDD8h case    4:*/		return 0x820CEDDC;
		  /* 820CEDDCh */ case    5:  		/* lwz R7, <#[R4 + 8]> */
		/* 820CEDDCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 820CEDDCh case    5:*/		return 0x820CEDE0;
		  /* 820CEDE0h */ case    6:  		/* mr R30, R3 */
		/* 820CEDE0h case    6:*/		regs.R30 = regs.R3;
		/* 820CEDE0h case    6:*/		return 0x820CEDE4;
		  /* 820CEDE4h */ case    7:  		/* cmplwi CR6, R7, 0 */
		/* 820CEDE4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820CEDE4h case    7:*/		return 0x820CEDE8;
		  /* 820CEDE8h */ case    8:  		/* bc 12, CR6_EQ, 312 */
		/* 820CEDE8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CEF20;  }
		/* 820CEDE8h case    8:*/		return 0x820CEDEC;
		  /* 820CEDECh */ case    9:  		/* lbz R11, <#[R7]> */
		/* 820CEDECh case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820CEDECh case    9:*/		return 0x820CEDF0;
		  /* 820CEDF0h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 820CEDF0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CEDF0h case   10:*/		return 0x820CEDF4;
		  /* 820CEDF4h */ case   11:  		/* bc 12, CR0_EQ, 300 */
		/* 820CEDF4h case   11:*/		if ( regs.CR[0].eq ) { return 0x820CEF20;  }
		/* 820CEDF4h case   11:*/		return 0x820CEDF8;
		  /* 820CEDF8h */ case   12:  		/* lis R10, -32255 */
		/* 820CEDF8h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CEDF8h case   12:*/		return 0x820CEDFC;
		  /* 820CEDFCh */ case   13:  		/* mr R11, R7 */
		/* 820CEDFCh case   13:*/		regs.R11 = regs.R7;
		/* 820CEDFCh case   13:*/		return 0x820CEE00;
		  /* 820CEE00h */ case   14:  		/* addi R10, R10, 22348 */
		/* 820CEE00h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x574C);
		/* 820CEE00h case   14:*/		return 0x820CEE04;
		  /* 820CEE04h */ case   15:  		/* lbz R9, <#[R11]> */
		/* 820CEE04h case   15:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CEE04h case   15:*/		return 0x820CEE08;
		  /* 820CEE08h */ case   16:  		/* lbz R8, <#[R10]> */
		/* 820CEE08h case   16:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CEE08h case   16:*/		return 0x820CEE0C;
		  /* 820CEE0Ch */ case   17:  		/* cmpwi CR0, R9, 0 */
		/* 820CEE0Ch case   17:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEE0Ch case   17:*/		return 0x820CEE10;
		  /* 820CEE10h */ case   18:  		/* subf R9, R8, R9 */
		/* 820CEE10h case   18:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CEE10h case   18:*/		return 0x820CEE14;
		  /* 820CEE14h */ case   19:  		/* bc 12, CR0_EQ, 20 */
		/* 820CEE14h case   19:*/		if ( regs.CR[0].eq ) { return 0x820CEE28;  }
		/* 820CEE14h case   19:*/		return 0x820CEE18;
		  /* 820CEE18h */ case   20:  		/* addi R11, R11, 1 */
		/* 820CEE18h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CEE18h case   20:*/		return 0x820CEE1C;
		  /* 820CEE1Ch */ case   21:  		/* addi R10, R10, 1 */
		/* 820CEE1Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CEE1Ch case   21:*/		return 0x820CEE20;
		  /* 820CEE20h */ case   22:  		/* cmpwi CR6, R9, 0 */
		/* 820CEE20h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CEE20h case   22:*/		return 0x820CEE24;
		  /* 820CEE24h */ case   23:  		/* bc 12, CR6_EQ, -32 */
		/* 820CEE24h case   23:*/		if ( regs.CR[6].eq ) { return 0x820CEE04;  }
		/* 820CEE24h case   23:*/		return 0x820CEE28;
	}
	return 0x820CEE28;
} // Block from 820CEDC8h-820CEE28h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820CEE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEE28);
		  /* 820CEE28h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CEE28h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CEE28h case    0:*/		return 0x820CEE2C;
		  /* 820CEE2Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CEE2Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CEE38;  }
		/* 820CEE2Ch case    1:*/		return 0x820CEE30;
		  /* 820CEE30h */ case    2:  		/* li R3, 4095 */
		/* 820CEE30h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFF);
		/* 820CEE30h case    2:*/		return 0x820CEE34;
		  /* 820CEE34h */ case    3:  		/* b 240 */
		/* 820CEE34h case    3:*/		return 0x820CEF24;
		/* 820CEE34h case    3:*/		return 0x820CEE38;
	}
	return 0x820CEE38;
} // Block from 820CEE28h-820CEE38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CEE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEE38);
		  /* 820CEE38h */ case    0:  		/* li R3, 0 */
		/* 820CEE38h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CEE38h case    0:*/		return 0x820CEE3C;
		  /* 820CEE3Ch */ case    1:  		/* li R10, 0 */
		/* 820CEE3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CEE3Ch case    1:*/		return 0x820CEE40;
		  /* 820CEE40h */ case    2:  		/* mr R9, R7 */
		/* 820CEE40h case    2:*/		regs.R9 = regs.R7;
		/* 820CEE40h case    2:*/		return 0x820CEE44;
		  /* 820CEE44h */ case    3:  		/* li R31, 1 */
		/* 820CEE44h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820CEE44h case    3:*/		return 0x820CEE48;
		  /* 820CEE48h */ case    4:  		/* cmplwi CR6, R10, 12 */
		/* 820CEE48h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000C);
		/* 820CEE48h case    4:*/		return 0x820CEE4C;
		  /* 820CEE4Ch */ case    5:  		/* bc 4, CR6_LT, 180 */
		/* 820CEE4Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x820CEF00;  }
		/* 820CEE4Ch case    5:*/		return 0x820CEE50;
		  /* 820CEE50h */ case    6:  		/* lbz R11, <#[R9]> */
		/* 820CEE50h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820CEE50h case    6:*/		return 0x820CEE54;
		  /* 820CEE54h */ case    7:  		/* cmplwi CR6, R11, 103 */
		/* 820CEE54h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 820CEE54h case    7:*/		return 0x820CEE58;
		  /* 820CEE58h */ case    8:  		/* bc 12, CR6_GT, 76 */
		/* 820CEE58h case    8:*/		if ( regs.CR[6].gt ) { return 0x820CEEA4;  }
		/* 820CEE58h case    8:*/		return 0x820CEE5C;
		  /* 820CEE5Ch */ case    9:  		/* bc 12, CR6_EQ, 120 */
		/* 820CEE5Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820CEED4;  }
		/* 820CEE5Ch case    9:*/		return 0x820CEE60;
		  /* 820CEE60h */ case   10:  		/* cmplwi CR6, R11, 48 */
		/* 820CEE60h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 820CEE60h case   10:*/		return 0x820CEE64;
		  /* 820CEE64h */ case   11:  		/* bc 12, CR6_EQ, 56 */
		/* 820CEE64h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CEE9C;  }
		/* 820CEE64h case   11:*/		return 0x820CEE68;
		  /* 820CEE68h */ case   12:  		/* cmplwi CR6, R11, 49 */
		/* 820CEE68h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000031);
		/* 820CEE68h case   12:*/		return 0x820CEE6C;
		  /* 820CEE6Ch */ case   13:  		/* bc 12, CR6_EQ, 40 */
		/* 820CEE6Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820CEE94;  }
		/* 820CEE6Ch case   13:*/		return 0x820CEE70;
		  /* 820CEE70h */ case   14:  		/* cmplwi CR6, R11, 95 */
		/* 820CEE70h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820CEE70h case   14:*/		return 0x820CEE74;
		  /* 820CEE74h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 820CEE74h case   15:*/		if ( regs.CR[6].eq ) { return 0x820CEE88;  }
		/* 820CEE74h case   15:*/		return 0x820CEE78;
		  /* 820CEE78h */ case   16:  		/* cmplwi CR6, R11, 97 */
		/* 820CEE78h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 820CEE78h case   16:*/		return 0x820CEE7C;
		  /* 820CEE7Ch */ case   17:  		/* bc 12, CR6_EQ, 96 */
		/* 820CEE7Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820CEEDC;  }
		/* 820CEE7Ch case   17:*/		return 0x820CEE80;
		  /* 820CEE80h */ case   18:  		/* cmplwi CR6, R11, 98 */
		/* 820CEE80h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000062);
		/* 820CEE80h case   18:*/		return 0x820CEE84;
		  /* 820CEE84h */ case   19:  		/* b 68 */
		/* 820CEE84h case   19:*/		return 0x820CEEC8;
		/* 820CEE84h case   19:*/		return 0x820CEE88;
	}
	return 0x820CEE88;
} // Block from 820CEE38h-820CEE88h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820CEE88h
// Function '?WriteOrderedComment@CCommentBlock@D3DXShader@@IAAJPAKIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEE88);
		  /* 820CEE88h */ case    0:  		/* li R11, 7 */
		/* 820CEE88h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820CEE88h case    0:*/		return 0x820CEE8C;
		  /* 820CEE8Ch */ case    1:  		/* slw R11, R11, R10 */
		/* 820CEE8Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820CEE8Ch case    1:*/		return 0x820CEE90;
		  /* 820CEE90h */ case    2:  		/* b 88 */
		/* 820CEE90h case    2:*/		return 0x820CEEE8;
		/* 820CEE90h case    2:*/		return 0x820CEE94;
	}
	return 0x820CEE94;
} // Block from 820CEE88h-820CEE94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CEE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEE94);
		  /* 820CEE94h */ case    0:  		/* li R11, 6 */
		/* 820CEE94h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820CEE94h case    0:*/		return 0x820CEE98;
		  /* 820CEE98h */ case    1:  		/* b -12 */
		/* 820CEE98h case    1:*/		return 0x820CEE8C;
		/* 820CEE98h case    1:*/		return 0x820CEE9C;
	}
	return 0x820CEE9C;
} // Block from 820CEE94h-820CEE9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEE9C);
		  /* 820CEE9Ch */ case    0:  		/* li R11, 5 */
		/* 820CEE9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820CEE9Ch case    0:*/		return 0x820CEEA0;
		  /* 820CEEA0h */ case    1:  		/* b -20 */
		/* 820CEEA0h case    1:*/		return 0x820CEE8C;
		/* 820CEEA0h case    1:*/		return 0x820CEEA4;
	}
	return 0x820CEEA4;
} // Block from 820CEE9Ch-820CEEA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEEA4);
		  /* 820CEEA4h */ case    0:  		/* cmplwi CR6, R11, 114 */
		/* 820CEEA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000072);
		/* 820CEEA4h case    0:*/		return 0x820CEEA8;
		  /* 820CEEA8h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 820CEEA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CEEE4;  }
		/* 820CEEA8h case    1:*/		return 0x820CEEAC;
		  /* 820CEEACh */ case    2:  		/* cmplwi CR6, R11, 119 */
		/* 820CEEACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000077);
		/* 820CEEACh case    2:*/		return 0x820CEEB0;
		  /* 820CEEB0h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820CEEB0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820CEEDC;  }
		/* 820CEEB0h case    3:*/		return 0x820CEEB4;
		  /* 820CEEB4h */ case    4:  		/* cmplwi CR6, R11, 120 */
		/* 820CEEB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 820CEEB4h case    4:*/		return 0x820CEEB8;
		  /* 820CEEB8h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 820CEEB8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CEEE4;  }
		/* 820CEEB8h case    5:*/		return 0x820CEEBC;
		  /* 820CEEBCh */ case    6:  		/* cmplwi CR6, R11, 121 */
		/* 820CEEBCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000079);
		/* 820CEEBCh case    6:*/		return 0x820CEEC0;
		  /* 820CEEC0h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820CEEC0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820CEED4;  }
		/* 820CEEC0h case    7:*/		return 0x820CEEC4;
		  /* 820CEEC4h */ case    8:  		/* cmplwi CR6, R11, 122 */
		/* 820CEEC4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007A);
		/* 820CEEC4h case    8:*/		return 0x820CEEC8;
	}
	return 0x820CEEC8;
} // Block from 820CEEA4h-820CEEC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CEEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEEC8);
		  /* 820CEEC8h */ case    0:  		/* bc 4, CR6_EQ, 56 */
		/* 820CEEC8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820CEF00;  }
		/* 820CEEC8h case    0:*/		return 0x820CEECC;
		  /* 820CEECCh */ case    1:  		/* li R11, 3 */
		/* 820CEECCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820CEECCh case    1:*/		return 0x820CEED0;
		  /* 820CEED0h */ case    2:  		/* b -68 */
		/* 820CEED0h case    2:*/		return 0x820CEE8C;
		/* 820CEED0h case    2:*/		return 0x820CEED4;
	}
	return 0x820CEED4;
} // Block from 820CEEC8h-820CEED4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CEED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEED4);
		  /* 820CEED4h */ case    0:  		/* li R11, 2 */
		/* 820CEED4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820CEED4h case    0:*/		return 0x820CEED8;
		  /* 820CEED8h */ case    1:  		/* b -76 */
		/* 820CEED8h case    1:*/		return 0x820CEE8C;
		/* 820CEED8h case    1:*/		return 0x820CEEDC;
	}
	return 0x820CEEDC;
} // Block from 820CEED4h-820CEEDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEEDC);
		  /* 820CEEDCh */ case    0:  		/* li R11, 4 */
		/* 820CEEDCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820CEEDCh case    0:*/		return 0x820CEEE0;
		  /* 820CEEE0h */ case    1:  		/* b -84 */
		/* 820CEEE0h case    1:*/		return 0x820CEE8C;
		/* 820CEEE0h case    1:*/		return 0x820CEEE4;
	}
	return 0x820CEEE4;
} // Block from 820CEEDCh-820CEEE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEEE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEEE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEEE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEEE4);
		  /* 820CEEE4h */ case    0:  		/* slw R11, R31, R10 */
		/* 820CEEE4h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R31,regs.R10);
		/* 820CEEE4h case    0:*/		return 0x820CEEE8;
	}
	return 0x820CEEE8;
} // Block from 820CEEE4h-820CEEE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEEE8);
		  /* 820CEEE8h */ case    0:  		/* or R3, R11, R3 */
		/* 820CEEE8h case    0:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820CEEE8h case    0:*/		return 0x820CEEEC;
		  /* 820CEEECh */ case    1:  		/* lbzu R11, <#[R9 + 1]> */
		/* 820CEEECh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 820CEEECh case    1:*/		return 0x820CEEF0;
		  /* 820CEEF0h */ case    2:  		/* addi R10, R10, 3 */
		/* 820CEEF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3);
		/* 820CEEF0h case    2:*/		return 0x820CEEF4;
		  /* 820CEEF4h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820CEEF4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CEEF4h case    3:*/		return 0x820CEEF8;
		  /* 820CEEF8h */ case    4:  		/* bc 4, CR0_EQ, -176 */
		/* 820CEEF8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820CEE48;  }
		/* 820CEEF8h case    4:*/		return 0x820CEEFC;
		  /* 820CEEFCh */ case    5:  		/* b 40 */
		/* 820CEEFCh case    5:*/		return 0x820CEF24;
		/* 820CEEFCh case    5:*/		return 0x820CEF00;
	}
	return 0x820CEF00;
} // Block from 820CEEE8h-820CEF00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF00);
		  /* 820CEF00h */ case    0:  		/* lis R11, -32255 */
		/* 820CEF00h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CEF00h case    0:*/		return 0x820CEF04;
		  /* 820CEF04h */ case    1:  		/* lwz R3, <#[R30]> */
		/* 820CEF04h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820CEF04h case    1:*/		return 0x820CEF08;
		  /* 820CEF08h */ case    2:  		/* li R5, 2003 */
		/* 820CEF08h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D3);
		/* 820CEF08h case    2:*/		return 0x820CEF0C;
		  /* 820CEF0Ch */ case    3:  		/* addi R6, R11, 2436 */
		/* 820CEF0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x984);
		/* 820CEF0Ch case    3:*/		return 0x820CEF10;
		  /* 820CEF10h */ case    4:  		/* bl -163200 */
		/* 820CEF10h case    4:*/		regs.LR = 0x820CEF14; return 0x820A7190;
		/* 820CEF10h case    4:*/		return 0x820CEF14;
		  /* 820CEF14h */ case    5:  		/* li R3, 0 */
		/* 820CEF14h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CEF14h case    5:*/		return 0x820CEF18;
		  /* 820CEF18h */ case    6:  		/* stw R31, <#[R30 + 60]> */
		/* 820CEF18h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000003C) );
		/* 820CEF18h case    6:*/		return 0x820CEF1C;
		  /* 820CEF1Ch */ case    7:  		/* b 8 */
		/* 820CEF1Ch case    7:*/		return 0x820CEF24;
		/* 820CEF1Ch case    7:*/		return 0x820CEF20;
	}
	return 0x820CEF20;
} // Block from 820CEF00h-820CEF20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF20);
		  /* 820CEF20h */ case    0:  		/* li R3, 2257 */
		/* 820CEF20h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x8D1);
		/* 820CEF20h case    0:*/		return 0x820CEF24;
	}
	return 0x820CEF24;
} // Block from 820CEF20h-820CEF24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF24);
		  /* 820CEF24h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CEF24h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CEF24h case    0:*/		return 0x820CEF28;
		  /* 820CEF28h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CEF28h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CEF28h case    1:*/		return 0x820CEF2C;
		  /* 820CEF2Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CEF2Ch case    2:*/		regs.LR = regs.R12;
		/* 820CEF2Ch case    2:*/		return 0x820CEF30;
		  /* 820CEF30h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CEF30h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CEF30h case    3:*/		return 0x820CEF34;
		  /* 820CEF34h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CEF34h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CEF34h case    4:*/		return 0x820CEF38;
		  /* 820CEF38h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CEF38h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CEF38h case    5:*/		return 0x820CEF3C;
	}
	return 0x820CEF3C;
} // Block from 820CEF24h-820CEF3Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF3C);
		  /* 820CEF3Ch */ case    0:  		/* nop */
		/* 820CEF3Ch case    0:*/		cpu::op::nop();
		/* 820CEF3Ch case    0:*/		return 0x820CEF40;
		  /* 820CEF40h */ case    1:  		/* li R3, 0 */
		/* 820CEF40h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CEF40h case    1:*/		return 0x820CEF44;
		  /* 820CEF44h */ case    2:  		/* li R10, 0 */
		/* 820CEF44h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CEF44h case    2:*/		return 0x820CEF48;
		  /* 820CEF48h */ case    3:  		/* li R8, 0 */
		/* 820CEF48h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820CEF48h case    3:*/		return 0x820CEF4C;
		  /* 820CEF4Ch */ case    4:  		/* li R9, 0 */
		/* 820CEF4Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CEF4Ch case    4:*/		return 0x820CEF50;
		  /* 820CEF50h */ case    5:  		/* srw R11, R4, R9 */
		/* 820CEF50h case    5:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R4,regs.R9);
		/* 820CEF50h case    5:*/		return 0x820CEF54;
		  /* 820CEF54h */ case    6:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 820CEF54h case    6:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 820CEF54h case    6:*/		return 0x820CEF58;
		  /* 820CEF58h */ case    7:  		/* cmpwi CR6, R11, 1 */
		/* 820CEF58h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820CEF58h case    7:*/		return 0x820CEF5C;
		  /* 820CEF5Ch */ case    8:  		/* bc 12, CR6_LT, 40 */
		/* 820CEF5Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x820CEF84;  }
		/* 820CEF5Ch case    8:*/		return 0x820CEF60;
		  /* 820CEF60h */ case    9:  		/* cmpwi CR6, R11, 4 */
		/* 820CEF60h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820CEF60h case    9:*/		return 0x820CEF64;
		  /* 820CEF64h */ case   10:  		/* bc 12, CR6_GT, 32 */
		/* 820CEF64h case   10:*/		if ( regs.CR[6].gt ) { return 0x820CEF84;  }
		/* 820CEF64h case   10:*/		return 0x820CEF68;
		  /* 820CEF68h */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CEF68h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CEF68h case   11:*/		return 0x820CEF6C;
		  /* 820CEF6Ch */ case   12:  		/* bc 4, CR6_GT, 72 */
		/* 820CEF6Ch case   12:*/		if ( !regs.CR[6].gt ) { return 0x820CEFB4;  }
		/* 820CEF6Ch case   12:*/		return 0x820CEF70;
		  /* 820CEF70h */ case   13:  		/* mulli R10, R11, 3 */
		/* 820CEF70h case   13:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0x3);
		/* 820CEF70h case   13:*/		return 0x820CEF74;
		  /* 820CEF74h */ case   14:  		/* addi R7, R10, -3 */
		/* 820CEF74h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFFD);
		/* 820CEF74h case   14:*/		return 0x820CEF78;
	}
	return 0x820CEF78;
} // Block from 820CEF3Ch-820CEF78h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF78h
// Function '?WriteComment@CCommentBlock@D3DXShader@@QAAJPAKIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF78);
		  /* 820CEF78h */ case    0:  		/* mr R10, R11 */
		/* 820CEF78h case    0:*/		regs.R10 = regs.R11;
		/* 820CEF78h case    0:*/		return 0x820CEF7C;
		  /* 820CEF7Ch */ case    1:  		/* slw R11, R11, R7 */
		/* 820CEF7Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820CEF7Ch case    1:*/		return 0x820CEF80;
	}
	return 0x820CEF80;
} // Block from 820CEF78h-820CEF80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF80h
// Function '?WriteSwappedComment@CCommentBlock@D3DXShader@@QAAJPAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF80);
		  /* 820CEF80h */ case    0:  		/* b 28 */
		/* 820CEF80h case    0:*/		return 0x820CEF9C;
		/* 820CEF80h case    0:*/		return 0x820CEF84;
	}
	return 0x820CEF84;
} // Block from 820CEF80h-820CEF84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF84);
		  /* 820CEF84h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 820CEF84h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CEF84h case    0:*/		return 0x820CEF88;
	}
	return 0x820CEF88;
} // Block from 820CEF84h-820CEF88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF88h
// Function '?ValidatorOutputCallback_QuickCheck@XGRAPHICS@@YAJPAXPBDK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF88);
		  /* 820CEF88h */ case    0:  		/* bc 12, CR6_EQ, 16 */
		/* 820CEF88h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CEF98;  }
		/* 820CEF88h case    0:*/		return 0x820CEF8C;
		  /* 820CEF8Ch */ case    1:  		/* cmpw CR6, R8, R10 */
		/* 820CEF8Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R10);
		/* 820CEF8Ch case    1:*/		return 0x820CEF90;
		  /* 820CEF90h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 820CEF90h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CEFB4;  }
		/* 820CEF90h case    2:*/		return 0x820CEF94;
		  /* 820CEF94h */ case    3:  		/* addi R10, R10, 1 */
		/* 820CEF94h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CEF94h case    3:*/		return 0x820CEF98;
	}
	return 0x820CEF98;
} // Block from 820CEF88h-820CEF98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF98);
		  /* 820CEF98h */ case    0:  		/* slw R11, R11, R9 */
		/* 820CEF98h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820CEF98h case    0:*/		return 0x820CEF9C;
	}
	return 0x820CEF9C;
} // Block from 820CEF98h-820CEF9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEF9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEF9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEF9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEF9C);
		  /* 820CEF9Ch */ case    0:  		/* addi R9, R9, 3 */
		/* 820CEF9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x3);
		/* 820CEF9Ch case    0:*/		return 0x820CEFA0;
	}
	return 0x820CEFA0;
} // Block from 820CEF9Ch-820CEFA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEFA0h
// Function '?IsFancyMaskRegister@D3DXShader@@YA_NPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEFA0);
		  /* 820CEFA0h */ case    0:  		/* or R3, R11, R3 */
		/* 820CEFA0h case    0:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820CEFA0h case    0:*/		return 0x820CEFA4;
		  /* 820CEFA4h */ case    1:  		/* addi R8, R8, 1 */
		/* 820CEFA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820CEFA4h case    1:*/		return 0x820CEFA8;
		  /* 820CEFA8h */ case    2:  		/* cmpwi CR6, R9, 12 */
		/* 820CEFA8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000C);
		/* 820CEFA8h case    2:*/		return 0x820CEFAC;
		  /* 820CEFACh */ case    3:  		/* bc 12, CR6_LT, -92 */
		/* 820CEFACh case    3:*/		if ( regs.CR[6].lt ) { return 0x820CEF50;  }
		/* 820CEFACh case    3:*/		return 0x820CEFB0;
		  /* 820CEFB0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820CEFB0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CEFB0h case    4:*/		return 0x820CEFB4;
	}
	return 0x820CEFB4;
} // Block from 820CEFA0h-820CEFB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CEFB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEFB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEFB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEFB4);
		  /* 820CEFB4h */ case    0:  		/* li R3, -1 */
		/* 820CEFB4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820CEFB4h case    0:*/		return 0x820CEFB8;
		  /* 820CEFB8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820CEFB8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CEFB8h case    1:*/		return 0x820CEFBC;
	}
	return 0x820CEFBC;
} // Block from 820CEFB4h-820CEFBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CEFBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEFBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEFBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEFBC);
		  /* 820CEFBCh */ case    0:  		/* nop */
		/* 820CEFBCh case    0:*/		cpu::op::nop();
		/* 820CEFBCh case    0:*/		return 0x820CEFC0;
	}
	return 0x820CEFC0;
} // Block from 820CEFBCh-820CEFC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CEFC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CEFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CEFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CEFC0);
		  /* 820CEFC0h */ case    0:  		/* mfspr R12, LR */
		/* 820CEFC0h case    0:*/		regs.R12 = regs.LR;
		/* 820CEFC0h case    0:*/		return 0x820CEFC4;
		  /* 820CEFC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CEFC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CEFC4h case    1:*/		return 0x820CEFC8;
		  /* 820CEFC8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820CEFC8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CEFC8h case    2:*/		return 0x820CEFCC;
		  /* 820CEFCCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CEFCCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CEFCCh case    3:*/		return 0x820CEFD0;
		  /* 820CEFD0h */ case    4:  		/* lwz R7, <#[R4 + 8]> */
		/* 820CEFD0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 820CEFD0h case    4:*/		return 0x820CEFD4;
		  /* 820CEFD4h */ case    5:  		/* mr R31, R3 */
		/* 820CEFD4h case    5:*/		regs.R31 = regs.R3;
		/* 820CEFD4h case    5:*/		return 0x820CEFD8;
		  /* 820CEFD8h */ case    6:  		/* li R11, 0 */
		/* 820CEFD8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CEFD8h case    6:*/		return 0x820CEFDC;
		  /* 820CEFDCh */ case    7:  		/* li R3, 0 */
		/* 820CEFDCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CEFDCh case    7:*/		return 0x820CEFE0;
		  /* 820CEFE0h */ case    8:  		/* mr R8, R7 */
		/* 820CEFE0h case    8:*/		regs.R8 = regs.R7;
		/* 820CEFE0h case    8:*/		return 0x820CEFE4;
		  /* 820CEFE4h */ case    9:  		/* cmplwi CR6, R7, 0 */
		/* 820CEFE4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820CEFE4h case    9:*/		return 0x820CEFE8;
		  /* 820CEFE8h */ case   10:  		/* bc 12, CR6_EQ, 204 */
		/* 820CEFE8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820CF0B4;  }
		/* 820CEFE8h case   10:*/		return 0x820CEFEC;
		  /* 820CEFECh */ case   11:  		/* lbz R10, <#[R7]> */
		/* 820CEFECh case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820CEFECh case   11:*/		return 0x820CEFF0;
		  /* 820CEFF0h */ case   12:  		/* cmplwi CR0, R10, 0 */
		/* 820CEFF0h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820CEFF0h case   12:*/		return 0x820CEFF4;
		  /* 820CEFF4h */ case   13:  		/* bc 12, CR0_EQ, 192 */
		/* 820CEFF4h case   13:*/		if ( regs.CR[0].eq ) { return 0x820CF0B4;  }
		/* 820CEFF4h case   13:*/		return 0x820CEFF8;
		  /* 820CEFF8h */ case   14:  		/* li R9, 0 */
		/* 820CEFF8h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CEFF8h case   14:*/		return 0x820CEFFC;
		  /* 820CEFFCh */ case   15:  		/* lbz R10, <#[R8]> */
		/* 820CEFFCh case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820CEFFCh case   15:*/		return 0x820CF000;
		  /* 820CF000h */ case   16:  		/* cmplwi CR0, R10, 0 */
		/* 820CF000h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820CF000h case   16:*/		return 0x820CF004;
		  /* 820CF004h */ case   17:  		/* bc 12, CR0_EQ, 60 */
		/* 820CF004h case   17:*/		if ( regs.CR[0].eq ) { return 0x820CF040;  }
		/* 820CF004h case   17:*/		return 0x820CF008;
		  /* 820CF008h */ case   18:  		/* rlwinm R11, R10, 0, 24, 31 */
		/* 820CF008h case   18:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R10);
		/* 820CF008h case   18:*/		return 0x820CF00C;
		  /* 820CF00Ch */ case   19:  		/* cmplwi CR6, R11, 119 */
		/* 820CF00Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000077);
		/* 820CF00Ch case   19:*/		return 0x820CF010;
		  /* 820CF010h */ case   20:  		/* bc 12, CR6_GT, 124 */
		/* 820CF010h case   20:*/		if ( regs.CR[6].gt ) { return 0x820CF08C;  }
		/* 820CF010h case   20:*/		return 0x820CF014;
		  /* 820CF014h */ case   21:  		/* bc 12, CR6_EQ, 112 */
		/* 820CF014h case   21:*/		if ( regs.CR[6].eq ) { return 0x820CF084;  }
		/* 820CF014h case   21:*/		return 0x820CF018;
		  /* 820CF018h */ case   22:  		/* cmplwi CR6, R11, 97 */
		/* 820CF018h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 820CF018h case   22:*/		return 0x820CF01C;
		  /* 820CF01Ch */ case   23:  		/* bc 12, CR6_EQ, 104 */
		/* 820CF01Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x820CF084;  }
		/* 820CF01Ch case   23:*/		return 0x820CF020;
		  /* 820CF020h */ case   24:  		/* cmplwi CR6, R11, 98 */
		/* 820CF020h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000062);
		/* 820CF020h case   24:*/		return 0x820CF024;
		  /* 820CF024h */ case   25:  		/* bc 12, CR6_EQ, 128 */
		/* 820CF024h case   25:*/		if ( regs.CR[6].eq ) { return 0x820CF0A4;  }
		/* 820CF024h case   25:*/		return 0x820CF028;
		  /* 820CF028h */ case   26:  		/* cmplwi CR6, R11, 103 */
		/* 820CF028h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 820CF028h case   26:*/		return 0x820CF02C;
		  /* 820CF02Ch */ case   27:  		/* bc 12, CR6_EQ, 128 */
		/* 820CF02Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x820CF0AC;  }
		/* 820CF02Ch case   27:*/		return 0x820CF030;
		  /* 820CF030h */ case   28:  		/* cmplwi CR6, R11, 114 */
		/* 820CF030h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000072);
		/* 820CF030h case   28:*/		return 0x820CF034;
		  /* 820CF034h */ case   29:  		/* bc 4, CR6_EQ, 44 */
		/* 820CF034h case   29:*/		if ( !regs.CR[6].eq ) { return 0x820CF060;  }
		/* 820CF034h case   29:*/		return 0x820CF038;
		  /* 820CF038h */ case   30:  		/* li R11, 0 */
		/* 820CF038h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CF038h case   30:*/		return 0x820CF03C;
		  /* 820CF03Ch */ case   31:  		/* addi R8, R8, 1 */
		/* 820CF03Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820CF03Ch case   31:*/		return 0x820CF040;
	}
	return 0x820CF040;
} // Block from 820CEFC0h-820CF040h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820CF040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF040);
		  /* 820CF040h */ case    0:  		/* slw R10, R11, R9 */
		/* 820CF040h case    0:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 820CF040h case    0:*/		return 0x820CF044;
		  /* 820CF044h */ case    1:  		/* addi R9, R9, 2 */
		/* 820CF044h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 820CF044h case    1:*/		return 0x820CF048;
		  /* 820CF048h */ case    2:  		/* or R3, R10, R3 */
		/* 820CF048h case    2:*/		cpu::op::or<0>(regs,&regs.R3,regs.R10,regs.R3);
		/* 820CF048h case    2:*/		return 0x820CF04C;
		  /* 820CF04Ch */ case    3:  		/* cmplwi CR6, R9, 8 */
		/* 820CF04Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000008);
		/* 820CF04Ch case    3:*/		return 0x820CF050;
		  /* 820CF050h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 820CF050h case    4:*/		if ( regs.CR[6].lt ) { return 0x820CEFFC;  }
		/* 820CF050h case    4:*/		return 0x820CF054;
		  /* 820CF054h */ case    5:  		/* lbz R11, <#[R8]> */
		/* 820CF054h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820CF054h case    5:*/		return 0x820CF058;
		  /* 820CF058h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820CF058h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CF058h case    6:*/		return 0x820CF05C;
		  /* 820CF05Ch */ case    7:  		/* bc 12, CR0_EQ, 92 */
		/* 820CF05Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820CF0B8;  }
		/* 820CF05Ch case    7:*/		return 0x820CF060;
	}
	return 0x820CF060;
} // Block from 820CF040h-820CF060h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CF060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF060);
		  /* 820CF060h */ case    0:  		/* lis R11, -32255 */
		/* 820CF060h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CF060h case    0:*/		return 0x820CF064;
		  /* 820CF064h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820CF064h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820CF064h case    1:*/		return 0x820CF068;
		  /* 820CF068h */ case    2:  		/* li R5, 2004 */
		/* 820CF068h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D4);
		/* 820CF068h case    2:*/		return 0x820CF06C;
		  /* 820CF06Ch */ case    3:  		/* addi R6, R11, 2456 */
		/* 820CF06Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x998);
		/* 820CF06Ch case    3:*/		return 0x820CF070;
		  /* 820CF070h */ case    4:  		/* bl -163552 */
		/* 820CF070h case    4:*/		regs.LR = 0x820CF074; return 0x820A7190;
		/* 820CF070h case    4:*/		return 0x820CF074;
		  /* 820CF074h */ case    5:  		/* li R11, 1 */
		/* 820CF074h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820CF074h case    5:*/		return 0x820CF078;
		  /* 820CF078h */ case    6:  		/* li R3, 0 */
		/* 820CF078h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CF078h case    6:*/		return 0x820CF07C;
		  /* 820CF07Ch */ case    7:  		/* stw R11, <#[R31 + 60]> */
		/* 820CF07Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820CF07Ch case    7:*/		return 0x820CF080;
		  /* 820CF080h */ case    8:  		/* b 56 */
		/* 820CF080h case    8:*/		return 0x820CF0B8;
		/* 820CF080h case    8:*/		return 0x820CF084;
	}
	return 0x820CF084;
} // Block from 820CF060h-820CF084h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CF084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF084);
		  /* 820CF084h */ case    0:  		/* li R11, 3 */
		/* 820CF084h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820CF084h case    0:*/		return 0x820CF088;
		  /* 820CF088h */ case    1:  		/* b -76 */
		/* 820CF088h case    1:*/		return 0x820CF03C;
		/* 820CF088h case    1:*/		return 0x820CF08C;
	}
	return 0x820CF08C;
} // Block from 820CF084h-820CF08Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF08C);
		  /* 820CF08Ch */ case    0:  		/* cmplwi CR6, R11, 120 */
		/* 820CF08Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000078);
		/* 820CF08Ch case    0:*/		return 0x820CF090;
		  /* 820CF090h */ case    1:  		/* bc 12, CR6_EQ, -88 */
		/* 820CF090h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CF038;  }
		/* 820CF090h case    1:*/		return 0x820CF094;
		  /* 820CF094h */ case    2:  		/* cmplwi CR6, R11, 121 */
		/* 820CF094h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000079);
		/* 820CF094h case    2:*/		return 0x820CF098;
		  /* 820CF098h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820CF098h case    3:*/		if ( regs.CR[6].eq ) { return 0x820CF0AC;  }
		/* 820CF098h case    3:*/		return 0x820CF09C;
		  /* 820CF09Ch */ case    4:  		/* cmplwi CR6, R11, 122 */
		/* 820CF09Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007A);
		/* 820CF09Ch case    4:*/		return 0x820CF0A0;
		  /* 820CF0A0h */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 820CF0A0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820CF060;  }
		/* 820CF0A0h case    5:*/		return 0x820CF0A4;
	}
	return 0x820CF0A4;
} // Block from 820CF08Ch-820CF0A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CF0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF0A4);
		  /* 820CF0A4h */ case    0:  		/* li R11, 2 */
		/* 820CF0A4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820CF0A4h case    0:*/		return 0x820CF0A8;
		  /* 820CF0A8h */ case    1:  		/* b -108 */
		/* 820CF0A8h case    1:*/		return 0x820CF03C;
		/* 820CF0A8h case    1:*/		return 0x820CF0AC;
	}
	return 0x820CF0AC;
} // Block from 820CF0A4h-820CF0ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF0AC);
		  /* 820CF0ACh */ case    0:  		/* li R11, 1 */
		/* 820CF0ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820CF0ACh case    0:*/		return 0x820CF0B0;
		  /* 820CF0B0h */ case    1:  		/* b -116 */
		/* 820CF0B0h case    1:*/		return 0x820CF03C;
		/* 820CF0B0h case    1:*/		return 0x820CF0B4;
	}
	return 0x820CF0B4;
} // Block from 820CF0ACh-820CF0B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF0B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF0B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF0B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF0B4);
		  /* 820CF0B4h */ case    0:  		/* li R3, 228 */
		/* 820CF0B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xE4);
		/* 820CF0B4h case    0:*/		return 0x820CF0B8;
	}
	return 0x820CF0B8;
} // Block from 820CF0B4h-820CF0B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CF0B8h
// Function '?D3DX9GetToken@D3DXShader@@YAJPAVCPreProcessor@1@PAUD3DXTOKEN@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF0B8);
		  /* 820CF0B8h */ case    0:  		/* addi R1, R1, 96 */
		/* 820CF0B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CF0B8h case    0:*/		return 0x820CF0BC;
		  /* 820CF0BCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CF0BCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CF0BCh case    1:*/		return 0x820CF0C0;
		  /* 820CF0C0h */ case    2:  		/* mtspr LR, R12 */
		/* 820CF0C0h case    2:*/		regs.LR = regs.R12;
		/* 820CF0C0h case    2:*/		return 0x820CF0C4;
		  /* 820CF0C4h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820CF0C4h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF0C4h case    3:*/		return 0x820CF0C8;
		  /* 820CF0C8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820CF0C8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF0C8h case    4:*/		return 0x820CF0CC;
	}
	return 0x820CF0CC;
} // Block from 820CF0B8h-820CF0CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CF0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF0CC);
		  /* 820CF0CCh */ case    0:  		/* nop */
		/* 820CF0CCh case    0:*/		cpu::op::nop();
		/* 820CF0CCh case    0:*/		return 0x820CF0D0;
		  /* 820CF0D0h */ case    1:  		/* addi R10, R4, 26 */
		/* 820CF0D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x1A);
		/* 820CF0D0h case    1:*/		return 0x820CF0D4;
		  /* 820CF0D4h */ case    2:  		/* lwz R8, <#[R3 + 64]> */
		/* 820CF0D4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000040) );
		/* 820CF0D4h case    2:*/		return 0x820CF0D8;
		  /* 820CF0D8h */ case    3:  		/* lis R9, -32217 */
		/* 820CF0D8h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8227);
		/* 820CF0D8h case    3:*/		return 0x820CF0DC;
		  /* 820CF0DCh */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820CF0DCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820CF0DCh case    4:*/		return 0x820CF0E0;
		  /* 820CF0E0h */ case    5:  		/* addi R9, R9, 11384 */
		/* 820CF0E0h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2C78);
		/* 820CF0E0h case    5:*/		return 0x820CF0E4;
		  /* 820CF0E4h */ case    6:  		/* mr R11, R3 */
		/* 820CF0E4h case    6:*/		regs.R11 = regs.R3;
		/* 820CF0E4h case    6:*/		return 0x820CF0E8;
		  /* 820CF0E8h */ case    7:  		/* lwzx R7, <#[R10 + R3]> */
		/* 820CF0E8h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 820CF0E8h case    7:*/		return 0x820CF0EC;
		  /* 820CF0ECh */ case    8:  		/* lbzx R10, <#[R8 + R9]> */
		/* 820CF0ECh case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820CF0ECh case    8:*/		return 0x820CF0F0;
		  /* 820CF0F0h */ case    9:  		/* cmplwi CR6, R10, 1 */
		/* 820CF0F0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820CF0F0h case    9:*/		return 0x820CF0F4;
		  /* 820CF0F4h */ case   10:  		/* lwz R3, <#[R7 + 36]> */
		/* 820CF0F4h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000024) );
		/* 820CF0F4h case   10:*/		return 0x820CF0F8;
		  /* 820CF0F8h */ case   11:  		/* bc 12, CR6_EQ, 132 */
		/* 820CF0F8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CF17C;  }
		/* 820CF0F8h case   11:*/		return 0x820CF0FC;
		  /* 820CF0FCh */ case   12:  		/* cmplwi CR6, R10, 2 */
		/* 820CF0FCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820CF0FCh case   12:*/		return 0x820CF100;
	}
	return 0x820CF100;
} // Block from 820CF0CCh-820CF100h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CF100h
// Function '?ParseSemantic@D3DXShader@@YAHPAUD3DXTOKEN@1@AAKAAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF100);
		  /* 820CF100h */ case    0:  		/* bc 12, CR6_EQ, 104 */
		/* 820CF100h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CF168;  }
		/* 820CF100h case    0:*/		return 0x820CF104;
		  /* 820CF104h */ case    1:  		/* cmplwi CR6, R10, 4 */
		/* 820CF104h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820CF104h case    1:*/		return 0x820CF108;
		  /* 820CF108h */ case    2:  		/* bclr 4, CR6_EQ */
		/* 820CF108h case    2:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820CF108h case    2:*/		return 0x820CF10C;
	}
	return 0x820CF10C;
} // Block from 820CF100h-820CF10Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF10C);
		  /* 820CF10Ch */ case    0:  		/* addi R10, R4, 27 */
		/* 820CF10Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x1B);
		/* 820CF10Ch case    0:*/		return 0x820CF110;
		  /* 820CF110h */ case    1:  		/* rlwinm R7, R3, 0, 30, 31 */
		/* 820CF110h case    1:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R3);
		/* 820CF110h case    1:*/		return 0x820CF114;
		  /* 820CF114h */ case    2:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 820CF114h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 820CF114h case    2:*/		return 0x820CF118;
		  /* 820CF118h */ case    3:  		/* li R9, 0 */
		/* 820CF118h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CF118h case    3:*/		return 0x820CF11C;
		  /* 820CF11Ch */ case    4:  		/* li R10, 0 */
		/* 820CF11Ch case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CF11Ch case    4:*/		return 0x820CF120;
		  /* 820CF120h */ case    5:  		/* lwzx R11, <#[R8 + R11]> */
		/* 820CF120h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820CF120h case    5:*/		return 0x820CF124;
		  /* 820CF124h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820CF124h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CF124h case    6:*/		return 0x820CF128;
		  /* 820CF128h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 820CF128h case    7:*/		if ( regs.CR[6].eq ) { return 0x820CF144;  }
		/* 820CF128h case    7:*/		return 0x820CF12C;
		  /* 820CF12Ch */ case    8:  		/* lwz R9, <#[R11 + 16]> */
		/* 820CF12Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820CF12Ch case    8:*/		return 0x820CF130;
		  /* 820CF130h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 820CF130h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820CF130h case    9:*/		return 0x820CF134;
		  /* 820CF134h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820CF134h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820CF13C;  }
		/* 820CF134h case   10:*/		return 0x820CF138;
		  /* 820CF138h */ case   11:  		/* lwz R10, <#[R11 + 24]> */
		/* 820CF138h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820CF138h case   11:*/		return 0x820CF13C;
	}
	return 0x820CF13C;
} // Block from 820CF10Ch-820CF13Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CF13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF13C);
		  /* 820CF13Ch */ case    0:  		/* lwz R11, <#[R11 + 36]> */
		/* 820CF13Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820CF13Ch case    0:*/		return 0x820CF140;
		  /* 820CF140h */ case    1:  		/* rlwinm R9, R11, 0, 30, 31 */
		/* 820CF140h case    1:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R11);
		/* 820CF140h case    1:*/		return 0x820CF144;
	}
	return 0x820CF144;
} // Block from 820CF13Ch-820CF144h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF144);
		  /* 820CF144h */ case    0:  		/* rlwinm R8, R10, 28, 4, 31 */
		/* 820CF144h case    0:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R8,regs.R10);
		/* 820CF144h case    0:*/		return 0x820CF148;
		  /* 820CF148h */ case    1:  		/* rlwinm R11, R10, 0, 0, 29 */
		/* 820CF148h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R10);
		/* 820CF148h case    1:*/		return 0x820CF14C;
		  /* 820CF14Ch */ case    2:  		/* addi R10, R8, -2 */
		/* 820CF14Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFFFFE);
		/* 820CF14Ch case    2:*/		return 0x820CF150;
		  /* 820CF150h */ case    3:  		/* addi R11, R11, 4 */
		/* 820CF150h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820CF150h case    3:*/		return 0x820CF154;
		  /* 820CF154h */ case    4:  		/* rlwimi R10, R7, 2, 0, 29 */
		/* 820CF154h case    4:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 820CF154h case    4:*/		return 0x820CF158;
		  /* 820CF158h */ case    5:  		/* rlwimi R11, R10, 4, 0, 27 */
		/* 820CF158h case    5:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R11,regs.R10);
		/* 820CF158h case    5:*/		return 0x820CF15C;
		  /* 820CF15Ch */ case    6:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 820CF15Ch case    6:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 820CF15Ch case    6:*/		return 0x820CF160;
		  /* 820CF160h */ case    7:  		/* or R3, R11, R9 */
		/* 820CF160h case    7:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 820CF160h case    7:*/		return 0x820CF164;
		  /* 820CF164h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820CF164h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF164h case    8:*/		return 0x820CF168;
	}
	return 0x820CF168;
} // Block from 820CF144h-820CF168h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CF168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF168);
		  /* 820CF168h */ case    0:  		/* rlwinm R11, R3, 30, 30, 31 */
		/* 820CF168h case    0:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R11,regs.R3);
		/* 820CF168h case    0:*/		return 0x820CF16C;
		  /* 820CF16Ch */ case    1:  		/* rlwinm R10, R3, 6, 24, 25 */
		/* 820CF16Ch case    1:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R10,regs.R3);
		/* 820CF16Ch case    1:*/		return 0x820CF170;
		  /* 820CF170h */ case    2:  		/* mulli R11, R11, 21 */
		/* 820CF170h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x15);
		/* 820CF170h case    2:*/		return 0x820CF174;
		  /* 820CF174h */ case    3:  		/* or R3, R11, R10 */
		/* 820CF174h case    3:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820CF174h case    3:*/		return 0x820CF178;
		  /* 820CF178h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820CF178h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF178h case    4:*/		return 0x820CF17C;
	}
	return 0x820CF17C;
} // Block from 820CF168h-820CF17Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CF17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF17C);
		  /* 820CF17Ch */ case    0:  		/* rlwinm R11, R3, 0, 30, 31 */
		/* 820CF17Ch case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R3);
		/* 820CF17Ch case    0:*/		return 0x820CF180;
		  /* 820CF180h */ case    1:  		/* mulli R3, R11, 85 */
		/* 820CF180h case    1:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R11,0x55);
		/* 820CF180h case    1:*/		return 0x820CF184;
		  /* 820CF184h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820CF184h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF184h case    2:*/		return 0x820CF188;
	}
	return 0x820CF188;
} // Block from 820CF17Ch-820CF188h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF188);
		  /* 820CF188h */ case    0:  		/* mr R11, R3 */
		/* 820CF188h case    0:*/		regs.R11 = regs.R3;
		/* 820CF188h case    0:*/		return 0x820CF18C;
		  /* 820CF18Ch */ case    1:  		/* lwz R3, <#[R3]> */
		/* 820CF18Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CF18Ch case    1:*/		return 0x820CF190;
		  /* 820CF190h */ case    2:  		/* cmpwi CR6, R4, 0 */
		/* 820CF190h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820CF190h case    2:*/		return 0x820CF194;
		  /* 820CF194h */ case    3:  		/* mr R7, R6 */
		/* 820CF194h case    3:*/		regs.R7 = regs.R6;
		/* 820CF194h case    3:*/		return 0x820CF198;
		  /* 820CF198h */ case    4:  		/* addi R4, R11, 16 */
		/* 820CF198h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 820CF198h case    4:*/		return 0x820CF19C;
		  /* 820CF19Ch */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CF19Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820CF1B4;  }
		/* 820CF19Ch case    5:*/		return 0x820CF1A0;
		  /* 820CF1A0h */ case    6:  		/* li R10, 1 */
		/* 820CF1A0h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820CF1A0h case    6:*/		return 0x820CF1A4;
		  /* 820CF1A4h */ case    7:  		/* lis R9, -32255 */
		/* 820CF1A4h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CF1A4h case    7:*/		return 0x820CF1A8;
		  /* 820CF1A8h */ case    8:  		/* stw R10, <#[R11 + 60]> */
		/* 820CF1A8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 820CF1A8h case    8:*/		return 0x820CF1AC;
		  /* 820CF1ACh */ case    9:  		/* addi R6, R9, -10432 */
		/* 820CF1ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0xFFFFD740);
		/* 820CF1ACh case    9:*/		return 0x820CF1B0;
		  /* 820CF1B0h */ case   10:  		/* b -163872 */
		/* 820CF1B0h case   10:*/		return 0x820A7190;
		/* 820CF1B0h case   10:*/		return 0x820CF1B4;
	}
	return 0x820CF1B4;
} // Block from 820CF188h-820CF1B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CF1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF1B4);
		  /* 820CF1B4h */ case    0:  		/* lis R10, -32255 */
		/* 820CF1B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CF1B4h case    0:*/		return 0x820CF1B8;
		  /* 820CF1B8h */ case    1:  		/* addi R6, R10, -10432 */
		/* 820CF1B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFD740);
		/* 820CF1B8h case    1:*/		return 0x820CF1BC;
		  /* 820CF1BCh */ case    2:  		/* b -163428 */
		/* 820CF1BCh case    2:*/		return 0x820A7358;
		/* 820CF1BCh case    2:*/		return 0x820CF1C0;
	}
	return 0x820CF1C0;
} // Block from 820CF1B4h-820CF1C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF1C0);
		  /* 820CF1C0h */ case    0:  		/* mfspr R12, LR */
		/* 820CF1C0h case    0:*/		regs.R12 = regs.LR;
		/* 820CF1C0h case    0:*/		return 0x820CF1C4;
		  /* 820CF1C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CF1C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CF1C4h case    1:*/		return 0x820CF1C8;
		  /* 820CF1C8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CF1C8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CF1C8h case    2:*/		return 0x820CF1CC;
		  /* 820CF1CCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CF1CCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF1CCh case    3:*/		return 0x820CF1D0;
		  /* 820CF1D0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CF1D0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CF1D0h case    4:*/		return 0x820CF1D4;
		  /* 820CF1D4h */ case    5:  		/* mr R31, R3 */
		/* 820CF1D4h case    5:*/		regs.R31 = regs.R3;
		/* 820CF1D4h case    5:*/		return 0x820CF1D8;
		  /* 820CF1D8h */ case    6:  		/* li R3, 20 */
		/* 820CF1D8h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820CF1D8h case    6:*/		return 0x820CF1DC;
		  /* 820CF1DCh */ case    7:  		/* mr R30, R4 */
		/* 820CF1DCh case    7:*/		regs.R30 = regs.R4;
		/* 820CF1DCh case    7:*/		return 0x820CF1E0;
		  /* 820CF1E0h */ case    8:  		/* bl -24504 */
		/* 820CF1E0h case    8:*/		regs.LR = 0x820CF1E4; return 0x820C9228;
		/* 820CF1E0h case    8:*/		return 0x820CF1E4;
		  /* 820CF1E4h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CF1E4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CF1E4h case    9:*/		return 0x820CF1E8;
		  /* 820CF1E8h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820CF1E8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CF1F8;  }
		/* 820CF1E8h case   10:*/		return 0x820CF1EC;
		  /* 820CF1ECh */ case   11:  		/* lwz R4, <#[R31 + 56]> */
		/* 820CF1ECh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 820CF1ECh case   11:*/		return 0x820CF1F0;
		  /* 820CF1F0h */ case   12:  		/* bl 479840 */
		/* 820CF1F0h case   12:*/		regs.LR = 0x820CF1F4; return 0x82144450;
		/* 820CF1F0h case   12:*/		return 0x820CF1F4;
		  /* 820CF1F4h */ case   13:  		/* b 8 */
		/* 820CF1F4h case   13:*/		return 0x820CF1FC;
		/* 820CF1F4h case   13:*/		return 0x820CF1F8;
	}
	return 0x820CF1F8;
} // Block from 820CF1C0h-820CF1F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CF1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF1F8);
		  /* 820CF1F8h */ case    0:  		/* li R3, 0 */
		/* 820CF1F8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CF1F8h case    0:*/		return 0x820CF1FC;
	}
	return 0x820CF1FC;
} // Block from 820CF1F8h-820CF1FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CF1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF1FC);
		  /* 820CF1FCh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820CF1FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CF1FCh case    0:*/		return 0x820CF200;
		  /* 820CF200h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820CF200h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF210;  }
		/* 820CF200h case    1:*/		return 0x820CF204;
		  /* 820CF204h */ case    2:  		/* lis R3, -32761 */
		/* 820CF204h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820CF204h case    2:*/		return 0x820CF208;
		  /* 820CF208h */ case    3:  		/* ori R3, R3, 14 */
		/* 820CF208h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820CF208h case    3:*/		return 0x820CF20C;
		  /* 820CF20Ch */ case    4:  		/* b 12 */
		/* 820CF20Ch case    4:*/		return 0x820CF218;
		/* 820CF20Ch case    4:*/		return 0x820CF210;
	}
	return 0x820CF210;
} // Block from 820CF1FCh-820CF210h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CF210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF210);
		  /* 820CF210h */ case    0:  		/* stw R3, <#[R30]> */
		/* 820CF210h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820CF210h case    0:*/		return 0x820CF214;
		  /* 820CF214h */ case    1:  		/* li R3, 0 */
		/* 820CF214h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CF214h case    1:*/		return 0x820CF218;
	}
	return 0x820CF218;
} // Block from 820CF210h-820CF218h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF218);
		  /* 820CF218h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CF218h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CF218h case    0:*/		return 0x820CF21C;
		  /* 820CF21Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CF21Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CF21Ch case    1:*/		return 0x820CF220;
		  /* 820CF220h */ case    2:  		/* mtspr LR, R12 */
		/* 820CF220h case    2:*/		regs.LR = regs.R12;
		/* 820CF220h case    2:*/		return 0x820CF224;
		  /* 820CF224h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CF224h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CF224h case    3:*/		return 0x820CF228;
		  /* 820CF228h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CF228h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF228h case    4:*/		return 0x820CF22C;
		  /* 820CF22Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CF22Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF22Ch case    5:*/		return 0x820CF230;
	}
	return 0x820CF230;
} // Block from 820CF218h-820CF230h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CF230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF230);
		  /* 820CF230h */ case    0:  		/* lis R11, -32255 */
		/* 820CF230h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CF230h case    0:*/		return 0x820CF234;
		  /* 820CF234h */ case    1:  		/* addi R11, R11, 22380 */
		/* 820CF234h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x576C);
		/* 820CF234h case    1:*/		return 0x820CF238;
		  /* 820CF238h */ case    2:  		/* stw R11, <#[R3]> */
		/* 820CF238h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CF238h case    2:*/		return 0x820CF23C;
		  /* 820CF23Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CF23Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF23Ch case    3:*/		return 0x820CF240;
	}
	return 0x820CF240;
} // Block from 820CF230h-820CF240h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CF240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF240);
		  /* 820CF240h */ case    0:  		/* mfspr R12, LR */
		/* 820CF240h case    0:*/		regs.R12 = regs.LR;
		/* 820CF240h case    0:*/		return 0x820CF244;
		  /* 820CF244h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CF244h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CF244h case    1:*/		return 0x820CF248;
		  /* 820CF248h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CF248h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CF248h case    2:*/		return 0x820CF24C;
		  /* 820CF24Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CF24Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF24Ch case    3:*/		return 0x820CF250;
		  /* 820CF250h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CF250h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CF250h case    4:*/		return 0x820CF254;
		  /* 820CF254h */ case    5:  		/* lhz R11, <#[R3 + 8]> */
		/* 820CF254h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CF254h case    5:*/		return 0x820CF258;
		  /* 820CF258h */ case    6:  		/* li R30, 0 */
		/* 820CF258h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CF258h case    6:*/		return 0x820CF25C;
		  /* 820CF25Ch */ case    7:  		/* mr R31, R3 */
		/* 820CF25Ch case    7:*/		regs.R31 = regs.R3;
		/* 820CF25Ch case    7:*/		return 0x820CF260;
		  /* 820CF260h */ case    8:  		/* add R11, R11, R3 */
		/* 820CF260h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820CF260h case    8:*/		return 0x820CF264;
		  /* 820CF264h */ case    9:  		/* addi R7, R3, 16 */
		/* 820CF264h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R3,0x10);
		/* 820CF264h case    9:*/		return 0x820CF268;
		  /* 820CF268h */ case   10:  		/* stb R30, <#[R11 + 16]> */
		/* 820CF268h case   10:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 820CF268h case   10:*/		return 0x820CF26C;
		  /* 820CF26Ch */ case   11:  		/* lwz R11, <#[R3 + 12]> */
		/* 820CF26Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CF26Ch case   11:*/		return 0x820CF270;
		  /* 820CF270h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 820CF270h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CF270h case   12:*/		return 0x820CF274;
		  /* 820CF274h */ case   13:  		/* lis R11, -32255 */
		/* 820CF274h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CF274h case   13:*/		return 0x820CF278;
		  /* 820CF278h */ case   14:  		/* lwz R4, <#[R3 + 4]> */
		/* 820CF278h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 820CF278h case   14:*/		return 0x820CF27C;
		  /* 820CF27Ch */ case   15:  		/* lwz R3, <#[R3]> */
		/* 820CF27Ch case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CF27Ch case   15:*/		return 0x820CF280;
		  /* 820CF280h */ case   16:  		/* addi R6, R11, -10432 */
		/* 820CF280h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD740);
		/* 820CF280h case   16:*/		return 0x820CF284;
		  /* 820CF284h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 820CF284h case   17:*/		if ( regs.CR[6].eq ) { return 0x820CF294;  }
		/* 820CF284h case   17:*/		return 0x820CF288;
		  /* 820CF288h */ case   18:  		/* li R5, 7101 */
		/* 820CF288h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x1BBD);
		/* 820CF288h case   18:*/		return 0x820CF28C;
		  /* 820CF28Ch */ case   19:  		/* bl -164092 */
		/* 820CF28Ch case   19:*/		regs.LR = 0x820CF290; return 0x820A7190;
		/* 820CF28Ch case   19:*/		return 0x820CF290;
		  /* 820CF290h */ case   20:  		/* b 12 */
		/* 820CF290h case   20:*/		return 0x820CF29C;
		/* 820CF290h case   20:*/		return 0x820CF294;
	}
	return 0x820CF294;
} // Block from 820CF240h-820CF294h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820CF294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF294);
		  /* 820CF294h */ case    0:  		/* li R5, 7102 */
		/* 820CF294h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1BBE);
		/* 820CF294h case    0:*/		return 0x820CF298;
		  /* 820CF298h */ case    1:  		/* bl -163648 */
		/* 820CF298h case    1:*/		regs.LR = 0x820CF29C; return 0x820A7358;
		/* 820CF298h case    1:*/		return 0x820CF29C;
	}
	return 0x820CF29C;
} // Block from 820CF294h-820CF29Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF29Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF29C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF29C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF29C);
		  /* 820CF29Ch */ case    0:  		/* sth R30, <#[R31 + 8]> */
		/* 820CF29Ch case    0:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 820CF29Ch case    0:*/		return 0x820CF2A0;
		  /* 820CF2A0h */ case    1:  		/* addi R1, R1, 112 */
		/* 820CF2A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CF2A0h case    1:*/		return 0x820CF2A4;
		  /* 820CF2A4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CF2A4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CF2A4h case    2:*/		return 0x820CF2A8;
		  /* 820CF2A8h */ case    3:  		/* mtspr LR, R12 */
		/* 820CF2A8h case    3:*/		regs.LR = regs.R12;
		/* 820CF2A8h case    3:*/		return 0x820CF2AC;
		  /* 820CF2ACh */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820CF2ACh case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CF2ACh case    4:*/		return 0x820CF2B0;
		  /* 820CF2B0h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820CF2B0h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF2B0h case    5:*/		return 0x820CF2B4;
		  /* 820CF2B4h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820CF2B4h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF2B4h case    6:*/		return 0x820CF2B8;
	}
	return 0x820CF2B8;
} // Block from 820CF29Ch-820CF2B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CF2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF2B8);
		  /* 820CF2B8h */ case    0:  		/* mfspr R12, LR */
		/* 820CF2B8h case    0:*/		regs.R12 = regs.LR;
		/* 820CF2B8h case    0:*/		return 0x820CF2BC;
		  /* 820CF2BCh */ case    1:  		/* bl -254048 */
		/* 820CF2BCh case    1:*/		regs.LR = 0x820CF2C0; return 0x8209125C;
		/* 820CF2BCh case    1:*/		return 0x820CF2C0;
		  /* 820CF2C0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CF2C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CF2C0h case    2:*/		return 0x820CF2C4;
		  /* 820CF2C4h */ case    3:  		/* mr R31, R3 */
		/* 820CF2C4h case    3:*/		regs.R31 = regs.R3;
		/* 820CF2C4h case    3:*/		return 0x820CF2C8;
		  /* 820CF2C8h */ case    4:  		/* mr R30, R5 */
		/* 820CF2C8h case    4:*/		regs.R30 = regs.R5;
		/* 820CF2C8h case    4:*/		return 0x820CF2CC;
		  /* 820CF2CCh */ case    5:  		/* li R3, 0 */
		/* 820CF2CCh case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CF2CCh case    5:*/		return 0x820CF2D0;
		  /* 820CF2D0h */ case    6:  		/* addi R29, R4, -1 */
		/* 820CF2D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R4,0xFFFFFFFF);
		/* 820CF2D0h case    6:*/		return 0x820CF2D4;
		  /* 820CF2D4h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 820CF2D4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820CF2D4h case    7:*/		return 0x820CF2D8;
		  /* 820CF2D8h */ case    8:  		/* bc 12, CR6_EQ, 72 */
		/* 820CF2D8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CF320;  }
		/* 820CF2D8h case    8:*/		return 0x820CF2DC;
		  /* 820CF2DCh */ case    9:  		/* lbzu R11, <#[R29 + 1]> */
		/* 820CF2DCh case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000001) );
		regs.R29 = (uint32)(regs.R29 + 0x00000001);
		/* 820CF2DCh case    9:*/		return 0x820CF2E0;
		  /* 820CF2E0h */ case   10:  		/* addi R30, R30, -1 */
		/* 820CF2E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 820CF2E0h case   10:*/		return 0x820CF2E4;
		  /* 820CF2E4h */ case   11:  		/* cmplwi CR6, R11, 10 */
		/* 820CF2E4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820CF2E4h case   11:*/		return 0x820CF2E8;
		  /* 820CF2E8h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 820CF2E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820CF310;  }
		/* 820CF2E8h case   12:*/		return 0x820CF2EC;
		  /* 820CF2ECh */ case   13:  		/* lhz R10, <#[R31 + 8]> */
		/* 820CF2ECh case   13:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820CF2ECh case   13:*/		return 0x820CF2F0;
		  /* 820CF2F0h */ case   14:  		/* add R10, R10, R31 */
		/* 820CF2F0h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 820CF2F0h case   14:*/		return 0x820CF2F4;
		  /* 820CF2F4h */ case   15:  		/* stb R11, <#[R10 + 16]> */
		/* 820CF2F4h case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820CF2F4h case   15:*/		return 0x820CF2F8;
		  /* 820CF2F8h */ case   16:  		/* lhz R11, <#[R31 + 8]> */
		/* 820CF2F8h case   16:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820CF2F8h case   16:*/		return 0x820CF2FC;
		  /* 820CF2FCh */ case   17:  		/* addi R11, R11, 1 */
		/* 820CF2FCh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CF2FCh case   17:*/		return 0x820CF300;
		  /* 820CF300h */ case   18:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 820CF300h case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820CF300h case   18:*/		return 0x820CF304;
		  /* 820CF304h */ case   19:  		/* sth R11, <#[R31 + 8]> */
		/* 820CF304h case   19:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820CF304h case   19:*/		return 0x820CF308;
		  /* 820CF308h */ case   20:  		/* cmplwi CR6, R11, 511 */
		/* 820CF308h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000001FF);
		/* 820CF308h case   20:*/		return 0x820CF30C;
		  /* 820CF30Ch */ case   21:  		/* bc 12, CR6_LT, 12 */
		/* 820CF30Ch case   21:*/		if ( regs.CR[6].lt ) { return 0x820CF318;  }
		/* 820CF30Ch case   21:*/		return 0x820CF310;
	}
	return 0x820CF310;
} // Block from 820CF2B8h-820CF310h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CF310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF310);
		  /* 820CF310h */ case    0:  		/* mr R3, R31 */
		/* 820CF310h case    0:*/		regs.R3 = regs.R31;
		/* 820CF310h case    0:*/		return 0x820CF314;
		  /* 820CF314h */ case    1:  		/* bl -212 */
		/* 820CF314h case    1:*/		regs.LR = 0x820CF318; return 0x820CF240;
		/* 820CF314h case    1:*/		return 0x820CF318;
	}
	return 0x820CF318;
} // Block from 820CF310h-820CF318h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF318);
		  /* 820CF318h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CF318h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CF318h case    0:*/		return 0x820CF31C;
		  /* 820CF31Ch */ case    1:  		/* bc 4, CR6_LT, -72 */
		/* 820CF31Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x820CF2D4;  }
		/* 820CF31Ch case    1:*/		return 0x820CF320;
	}
	return 0x820CF320;
} // Block from 820CF318h-820CF320h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF320);
		  /* 820CF320h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CF320h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CF320h case    0:*/		return 0x820CF324;
		  /* 820CF324h */ case    1:  		/* b -254072 */
		/* 820CF324h case    1:*/		return 0x820912AC;
		/* 820CF324h case    1:*/		return 0x820CF328;
		  /* 820CF328h */ case    2:  		/* b -112 */
		/* 820CF328h case    2:*/		return 0x820CF2B8;
		/* 820CF328h case    2:*/		return 0x820CF32C;
		  /* 820CF32Ch */ case    3:  		/* nop */
		/* 820CF32Ch case    3:*/		cpu::op::nop();
		/* 820CF32Ch case    3:*/		return 0x820CF330;
		  /* 820CF330h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CF330h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CF330h case    4:*/		return 0x820CF334;
		  /* 820CF334h */ case    5:  		/* bc 12, CR6_EQ, 144 */
		/* 820CF334h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CF3C4;  }
		/* 820CF334h case    5:*/		return 0x820CF338;
		  /* 820CF338h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CF338h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CF338h case    6:*/		return 0x820CF33C;
		  /* 820CF33Ch */ case    7:  		/* cmpwi CR6, R11, 2 */
		/* 820CF33Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820CF33Ch case    7:*/		return 0x820CF340;
		  /* 820CF340h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820CF340h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CF360;  }
		/* 820CF340h case    8:*/		return 0x820CF344;
		  /* 820CF344h */ case    9:  		/* cmpwi CR6, R11, 4 */
		/* 820CF344h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820CF344h case    9:*/		return 0x820CF348;
		  /* 820CF348h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 820CF348h case   10:*/		if ( regs.CR[6].eq ) { return 0x820CF360;  }
		/* 820CF348h case   10:*/		return 0x820CF34C;
		  /* 820CF34Ch */ case   11:  		/* cmpwi CR6, R11, 6 */
		/* 820CF34Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820CF34Ch case   11:*/		return 0x820CF350;
		  /* 820CF350h */ case   12:  		/* bc 4, CR6_GT, 20 */
		/* 820CF350h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820CF364;  }
		/* 820CF350h case   12:*/		return 0x820CF354;
		  /* 820CF354h */ case   13:  		/* cmpwi CR6, R11, 10 */
		/* 820CF354h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820CF354h case   13:*/		return 0x820CF358;
		  /* 820CF358h */ case   14:  		/* bc 4, CR6_GT, 20 */
		/* 820CF358h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820CF36C;  }
		/* 820CF358h case   14:*/		return 0x820CF35C;
		  /* 820CF35Ch */ case   15:  		/* b 8 */
		/* 820CF35Ch case   15:*/		return 0x820CF364;
		/* 820CF35Ch case   15:*/		return 0x820CF360;
	}
	return 0x820CF360;
} // Block from 820CF320h-820CF360h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CF360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF360);
		  /* 820CF360h */ case    0:  		/* li R11, 2 */
		/* 820CF360h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820CF360h case    0:*/		return 0x820CF364;
	}
	return 0x820CF364;
} // Block from 820CF360h-820CF364h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CF364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF364);
		  /* 820CF364h */ case    0:  		/* cmplwi CR6, R11, 7 */
		/* 820CF364h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 820CF364h case    0:*/		return 0x820CF368;
		  /* 820CF368h */ case    1:  		/* bc 4, CR6_EQ, 104 */
		/* 820CF368h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF3D0;  }
		/* 820CF368h case    1:*/		return 0x820CF36C;
	}
	return 0x820CF36C;
} // Block from 820CF364h-820CF36Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF36C);
		  /* 820CF36Ch */ case    0:  		/* extsw R11, R5 */
		/* 820CF36Ch case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R5);
		/* 820CF36Ch case    0:*/		return 0x820CF370;
		  /* 820CF370h */ case    1:  		/* lfd FR0, <#[R3 + 8]> */
		/* 820CF370h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000008) );
		/* 820CF370h case    1:*/		return 0x820CF374;
		  /* 820CF374h */ case    2:  		/* std R11, <#[R1 - 16]> */
		/* 820CF374h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF374h case    2:*/		return 0x820CF378;
		  /* 820CF378h */ case    3:  		/* lfd FR13, <#[R1 - 16]> */
		/* 820CF378h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF378h case    3:*/		return 0x820CF37C;
		  /* 820CF37Ch */ case    4:  		/* fcfid FR13, FR13 */
		/* 820CF37Ch case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820CF37Ch case    4:*/		return 0x820CF380;
		  /* 820CF380h */ case    5:  		/* fcmpu CR6, FR0, FR13 */
		/* 820CF380h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820CF380h case    5:*/		return 0x820CF384;
		  /* 820CF384h */ case    6:  		/* bc 12, CR6_LT, 64 */
		/* 820CF384h case    6:*/		if ( regs.CR[6].lt ) { return 0x820CF3C4;  }
		/* 820CF384h case    6:*/		return 0x820CF388;
		  /* 820CF388h */ case    7:  		/* extsw R11, R6 */
		/* 820CF388h case    7:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R6);
		/* 820CF388h case    7:*/		return 0x820CF38C;
		  /* 820CF38Ch */ case    8:  		/* std R11, <#[R1 - 16]> */
		/* 820CF38Ch case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF38Ch case    8:*/		return 0x820CF390;
		  /* 820CF390h */ case    9:  		/* lfd FR13, <#[R1 - 16]> */
		/* 820CF390h case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF390h case    9:*/		return 0x820CF394;
		  /* 820CF394h */ case   10:  		/* fcfid FR13, FR13 */
		/* 820CF394h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820CF394h case   10:*/		return 0x820CF398;
		  /* 820CF398h */ case   11:  		/* fcmpu CR6, FR0, FR13 */
		/* 820CF398h case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820CF398h case   11:*/		return 0x820CF39C;
		  /* 820CF39Ch */ case   12:  		/* bc 12, CR6_GT, 40 */
		/* 820CF39Ch case   12:*/		if ( regs.CR[6].gt ) { return 0x820CF3C4;  }
		/* 820CF39Ch case   12:*/		return 0x820CF3A0;
		  /* 820CF3A0h */ case   13:  		/* fctiwz FR13, FR0 */
		/* 820CF3A0h case   13:*/		cpu::op::fctiwz<0>(regs,&regs.FR13,regs.FR0);
		/* 820CF3A0h case   13:*/		return 0x820CF3A4;
		  /* 820CF3A4h */ case   14:  		/* stfd FR13, <#[R1 - 16]> */
		/* 820CF3A4h case   14:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF3A4h case   14:*/		return 0x820CF3A8;
		  /* 820CF3A8h */ case   15:  		/* lwz R11, <#[R1 - 12]> */
		/* 820CF3A8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820CF3A8h case   15:*/		return 0x820CF3AC;
		  /* 820CF3ACh */ case   16:  		/* extsw R10, R11 */
		/* 820CF3ACh case   16:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R11);
		/* 820CF3ACh case   16:*/		return 0x820CF3B0;
		  /* 820CF3B0h */ case   17:  		/* std R10, <#[R1 - 16]> */
		/* 820CF3B0h case   17:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF3B0h case   17:*/		return 0x820CF3B4;
		  /* 820CF3B4h */ case   18:  		/* lfd FR13, <#[R1 - 16]> */
		/* 820CF3B4h case   18:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CF3B4h case   18:*/		return 0x820CF3B8;
		  /* 820CF3B8h */ case   19:  		/* fcfid FR13, FR13 */
		/* 820CF3B8h case   19:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820CF3B8h case   19:*/		return 0x820CF3BC;
		  /* 820CF3BCh */ case   20:  		/* fcmpu CR6, FR0, FR13 */
		/* 820CF3BCh case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820CF3BCh case   20:*/		return 0x820CF3C0;
		  /* 820CF3C0h */ case   21:  		/* bc 12, CR6_EQ, 76 */
		/* 820CF3C0h case   21:*/		if ( regs.CR[6].eq ) { return 0x820CF40C;  }
		/* 820CF3C0h case   21:*/		return 0x820CF3C4;
	}
	return 0x820CF3C4;
} // Block from 820CF36Ch-820CF3C4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CF3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF3C4);
		  /* 820CF3C4h */ case    0:  		/* lis R3, -32768 */
		/* 820CF3C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CF3C4h case    0:*/		return 0x820CF3C8;
		  /* 820CF3C8h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820CF3C8h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CF3C8h case    1:*/		return 0x820CF3CC;
		  /* 820CF3CCh */ case    2:  		/* bclr 20, CR0_LT */
		/* 820CF3CCh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF3CCh case    2:*/		return 0x820CF3D0;
	}
	return 0x820CF3D0;
} // Block from 820CF3C4h-820CF3D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF3D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF3D0);
		  /* 820CF3D0h */ case    0:  		/* cmplwi CR6, R11, 2 */
		/* 820CF3D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820CF3D0h case    0:*/		return 0x820CF3D4;
		  /* 820CF3D4h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820CF3D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF3F0;  }
		/* 820CF3D4h case    1:*/		return 0x820CF3D8;
		  /* 820CF3D8h */ case    2:  		/* lis R10, 32767 */
		/* 820CF3D8h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FFF);
		/* 820CF3D8h case    2:*/		return 0x820CF3DC;
		  /* 820CF3DCh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820CF3DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CF3DCh case    3:*/		return 0x820CF3E0;
		  /* 820CF3E0h */ case    4:  		/* ori R10, R10, 65535 */
		/* 820CF3E0h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 820CF3E0h case    4:*/		return 0x820CF3E4;
		  /* 820CF3E4h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820CF3E4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CF3E4h case    5:*/		return 0x820CF3E8;
		  /* 820CF3E8h */ case    6:  		/* bc 12, CR6_GT, -36 */
		/* 820CF3E8h case    6:*/		if ( regs.CR[6].gt ) { return 0x820CF3C4;  }
		/* 820CF3E8h case    6:*/		return 0x820CF3EC;
		  /* 820CF3ECh */ case    7:  		/* b 16 */
		/* 820CF3ECh case    7:*/		return 0x820CF3FC;
		/* 820CF3ECh case    7:*/		return 0x820CF3F0;
	}
	return 0x820CF3F0;
} // Block from 820CF3D0h-820CF3F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CF3F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF3F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF3F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF3F0);
		  /* 820CF3F0h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820CF3F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820CF3F0h case    0:*/		return 0x820CF3F4;
		  /* 820CF3F4h */ case    1:  		/* bc 4, CR6_EQ, -48 */
		/* 820CF3F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF3C4;  }
		/* 820CF3F4h case    1:*/		return 0x820CF3F8;
		  /* 820CF3F8h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 820CF3F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CF3F8h case    2:*/		return 0x820CF3FC;
	}
	return 0x820CF3FC;
} // Block from 820CF3F0h-820CF3FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF3FC);
		  /* 820CF3FCh */ case    0:  		/* cmpw CR6, R11, R5 */
		/* 820CF3FCh case    0:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 820CF3FCh case    0:*/		return 0x820CF400;
		  /* 820CF400h */ case    1:  		/* bc 12, CR6_LT, -60 */
		/* 820CF400h case    1:*/		if ( regs.CR[6].lt ) { return 0x820CF3C4;  }
		/* 820CF400h case    1:*/		return 0x820CF404;
		  /* 820CF404h */ case    2:  		/* cmpw CR6, R11, R6 */
		/* 820CF404h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R6);
		/* 820CF404h case    2:*/		return 0x820CF408;
		  /* 820CF408h */ case    3:  		/* bc 12, CR6_GT, -68 */
		/* 820CF408h case    3:*/		if ( regs.CR[6].gt ) { return 0x820CF3C4;  }
		/* 820CF408h case    3:*/		return 0x820CF40C;
	}
	return 0x820CF40C;
} // Block from 820CF3FCh-820CF40Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CF40Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF40C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF40C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF40C);
		  /* 820CF40Ch */ case    0:  		/* stw R11, <#[R4]> */
		/* 820CF40Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820CF40Ch case    0:*/		return 0x820CF410;
		  /* 820CF410h */ case    1:  		/* li R3, 0 */
		/* 820CF410h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CF410h case    1:*/		return 0x820CF414;
		  /* 820CF414h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820CF414h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF414h case    2:*/		return 0x820CF418;
	}
	return 0x820CF418;
} // Block from 820CF40Ch-820CF418h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF418);
		  /* 820CF418h */ case    0:  		/* mfspr R12, LR */
		/* 820CF418h case    0:*/		regs.R12 = regs.LR;
		/* 820CF418h case    0:*/		return 0x820CF41C;
		  /* 820CF41Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CF41Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CF41Ch case    1:*/		return 0x820CF420;
		  /* 820CF420h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CF420h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CF420h case    2:*/		return 0x820CF424;
		  /* 820CF424h */ case    3:  		/* mr R9, R3 */
		/* 820CF424h case    3:*/		regs.R9 = regs.R3;
		/* 820CF424h case    3:*/		return 0x820CF428;
		  /* 820CF428h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CF428h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CF428h case    4:*/		return 0x820CF42C;
		  /* 820CF42Ch */ case    5:  		/* bc 12, CR6_EQ, 180 */
		/* 820CF42Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820CF4E0;  }
		/* 820CF42Ch case    5:*/		return 0x820CF430;
		  /* 820CF430h */ case    6:  		/* li R6, 1 */
		/* 820CF430h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820CF430h case    6:*/		return 0x820CF434;
		  /* 820CF434h */ case    7:  		/* li R5, 0 */
		/* 820CF434h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820CF434h case    7:*/		return 0x820CF438;
		  /* 820CF438h */ case    8:  		/* bl -264 */
		/* 820CF438h case    8:*/		regs.LR = 0x820CF43C; return 0x820CF330;
		/* 820CF438h case    8:*/		return 0x820CF43C;
		  /* 820CF43Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820CF43Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CF43Ch case    9:*/		return 0x820CF440;
		  /* 820CF440h */ case   10:  		/* bc 12, CR0_LT, 12 */
		/* 820CF440h case   10:*/		if ( regs.CR[0].lt ) { return 0x820CF44C;  }
		/* 820CF440h case   10:*/		return 0x820CF444;
		  /* 820CF444h */ case   11:  		/* li R3, 0 */
		/* 820CF444h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CF444h case   11:*/		return 0x820CF448;
		  /* 820CF448h */ case   12:  		/* b 160 */
		/* 820CF448h case   12:*/		return 0x820CF4E8;
		/* 820CF448h case   12:*/		return 0x820CF44C;
	}
	return 0x820CF44C;
} // Block from 820CF418h-820CF44Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CF44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF44C);
		  /* 820CF44Ch */ case    0:  		/* lwz R11, <#[R9]> */
		/* 820CF44Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820CF44Ch case    0:*/		return 0x820CF450;
		  /* 820CF450h */ case    1:  		/* cmplwi CR6, R11, 11 */
		/* 820CF450h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 820CF450h case    1:*/		return 0x820CF454;
		  /* 820CF454h */ case    2:  		/* bc 4, CR6_EQ, 140 */
		/* 820CF454h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CF4E0;  }
		/* 820CF454h case    2:*/		return 0x820CF458;
		  /* 820CF458h */ case    3:  		/* lis R11, -32255 */
		/* 820CF458h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CF458h case    3:*/		return 0x820CF45C;
		  /* 820CF45Ch */ case    4:  		/* lwz R8, <#[R9 + 8]> */
		/* 820CF45Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000008) );
		/* 820CF45Ch case    4:*/		return 0x820CF460;
		  /* 820CF460h */ case    5:  		/* addi R10, R11, 5224 */
		/* 820CF460h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1468);
		/* 820CF460h case    5:*/		return 0x820CF464;
		  /* 820CF464h */ case    6:  		/* mr R11, R8 */
		/* 820CF464h case    6:*/		regs.R11 = regs.R8;
		/* 820CF464h case    6:*/		return 0x820CF468;
		  /* 820CF468h */ case    7:  		/* lbz R9, <#[R11]> */
		/* 820CF468h case    7:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CF468h case    7:*/		return 0x820CF46C;
		  /* 820CF46Ch */ case    8:  		/* lbz R7, <#[R10]> */
		/* 820CF46Ch case    8:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CF46Ch case    8:*/		return 0x820CF470;
		  /* 820CF470h */ case    9:  		/* cmpwi CR0, R9, 0 */
		/* 820CF470h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CF470h case    9:*/		return 0x820CF474;
		  /* 820CF474h */ case   10:  		/* subf R9, R7, R9 */
		/* 820CF474h case   10:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CF474h case   10:*/		return 0x820CF478;
		  /* 820CF478h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 820CF478h case   11:*/		if ( regs.CR[0].eq ) { return 0x820CF48C;  }
		/* 820CF478h case   11:*/		return 0x820CF47C;
		  /* 820CF47Ch */ case   12:  		/* addi R11, R11, 1 */
		/* 820CF47Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CF47Ch case   12:*/		return 0x820CF480;
		  /* 820CF480h */ case   13:  		/* addi R10, R10, 1 */
		/* 820CF480h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CF480h case   13:*/		return 0x820CF484;
		  /* 820CF484h */ case   14:  		/* cmpwi CR6, R9, 0 */
		/* 820CF484h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CF484h case   14:*/		return 0x820CF488;
		  /* 820CF488h */ case   15:  		/* bc 12, CR6_EQ, -32 */
		/* 820CF488h case   15:*/		if ( regs.CR[6].eq ) { return 0x820CF468;  }
		/* 820CF488h case   15:*/		return 0x820CF48C;
	}
	return 0x820CF48C;
} // Block from 820CF44Ch-820CF48Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CF48Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF48C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF48C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF48C);
		  /* 820CF48Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CF48Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CF48Ch case    0:*/		return 0x820CF490;
		  /* 820CF490h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820CF490h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CF49C;  }
		/* 820CF490h case    1:*/		return 0x820CF494;
		  /* 820CF494h */ case    2:  		/* li R11, 1 */
		/* 820CF494h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820CF494h case    2:*/		return 0x820CF498;
		  /* 820CF498h */ case    3:  		/* b 64 */
		/* 820CF498h case    3:*/		return 0x820CF4D8;
		/* 820CF498h case    3:*/		return 0x820CF49C;
	}
	return 0x820CF49C;
} // Block from 820CF48Ch-820CF49Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CF49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF49C);
		  /* 820CF49Ch */ case    0:  		/* lis R10, -32255 */
		/* 820CF49Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CF49Ch case    0:*/		return 0x820CF4A0;
		  /* 820CF4A0h */ case    1:  		/* mr R11, R8 */
		/* 820CF4A0h case    1:*/		regs.R11 = regs.R8;
		/* 820CF4A0h case    1:*/		return 0x820CF4A4;
		  /* 820CF4A4h */ case    2:  		/* addi R10, R10, 5216 */
		/* 820CF4A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1460);
		/* 820CF4A4h case    2:*/		return 0x820CF4A8;
		  /* 820CF4A8h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820CF4A8h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CF4A8h case    3:*/		return 0x820CF4AC;
		  /* 820CF4ACh */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820CF4ACh case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CF4ACh case    4:*/		return 0x820CF4B0;
		  /* 820CF4B0h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820CF4B0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CF4B0h case    5:*/		return 0x820CF4B4;
		  /* 820CF4B4h */ case    6:  		/* subf R9, R8, R9 */
		/* 820CF4B4h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820CF4B4h case    6:*/		return 0x820CF4B8;
		  /* 820CF4B8h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820CF4B8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820CF4CC;  }
		/* 820CF4B8h case    7:*/		return 0x820CF4BC;
		  /* 820CF4BCh */ case    8:  		/* addi R11, R11, 1 */
		/* 820CF4BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CF4BCh case    8:*/		return 0x820CF4C0;
		  /* 820CF4C0h */ case    9:  		/* addi R10, R10, 1 */
		/* 820CF4C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CF4C0h case    9:*/		return 0x820CF4C4;
		  /* 820CF4C4h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820CF4C4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CF4C4h case   10:*/		return 0x820CF4C8;
		  /* 820CF4C8h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820CF4C8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820CF4A8;  }
		/* 820CF4C8h case   11:*/		return 0x820CF4CC;
	}
	return 0x820CF4CC;
} // Block from 820CF49Ch-820CF4CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CF4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF4CC);
		  /* 820CF4CCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CF4CCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CF4CCh case    0:*/		return 0x820CF4D0;
		  /* 820CF4D0h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820CF4D0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CF4E0;  }
		/* 820CF4D0h case    1:*/		return 0x820CF4D4;
		  /* 820CF4D4h */ case    2:  		/* li R11, 0 */
		/* 820CF4D4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CF4D4h case    2:*/		return 0x820CF4D8;
	}
	return 0x820CF4D8;
} // Block from 820CF4CCh-820CF4D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF4D8);
		  /* 820CF4D8h */ case    0:  		/* stw R11, <#[R4]> */
		/* 820CF4D8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820CF4D8h case    0:*/		return 0x820CF4DC;
		  /* 820CF4DCh */ case    1:  		/* b -152 */
		/* 820CF4DCh case    1:*/		return 0x820CF444;
		/* 820CF4DCh case    1:*/		return 0x820CF4E0;
	}
	return 0x820CF4E0;
} // Block from 820CF4D8h-820CF4E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF4E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF4E0);
		  /* 820CF4E0h */ case    0:  		/* lis R3, -32768 */
		/* 820CF4E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820CF4E0h case    0:*/		return 0x820CF4E4;
		  /* 820CF4E4h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820CF4E4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820CF4E4h case    1:*/		return 0x820CF4E8;
	}
	return 0x820CF4E8;
} // Block from 820CF4E0h-820CF4E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF4E8);
		  /* 820CF4E8h */ case    0:  		/* addi R1, R1, 96 */
		/* 820CF4E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CF4E8h case    0:*/		return 0x820CF4EC;
		  /* 820CF4ECh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CF4ECh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CF4ECh case    1:*/		return 0x820CF4F0;
		  /* 820CF4F0h */ case    2:  		/* mtspr LR, R12 */
		/* 820CF4F0h case    2:*/		regs.LR = regs.R12;
		/* 820CF4F0h case    2:*/		return 0x820CF4F4;
		  /* 820CF4F4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CF4F4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CF4F4h case    3:*/		return 0x820CF4F8;
	}
	return 0x820CF4F8;
} // Block from 820CF4E8h-820CF4F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CF4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF4F8);
		  /* 820CF4F8h */ case    0:  		/* mfspr R12, LR */
		/* 820CF4F8h case    0:*/		regs.R12 = regs.LR;
		/* 820CF4F8h case    0:*/		return 0x820CF4FC;
		  /* 820CF4FCh */ case    1:  		/* bl -254684 */
		/* 820CF4FCh case    1:*/		regs.LR = 0x820CF500; return 0x82091220;
		/* 820CF4FCh case    1:*/		return 0x820CF500;
		  /* 820CF500h */ case    2:  		/* stwu R1, <#[R1 - 304]> */
		/* 820CF500h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 820CF500h case    2:*/		return 0x820CF504;
		  /* 820CF504h */ case    3:  		/* mr R28, R8 */
		/* 820CF504h case    3:*/		regs.R28 = regs.R8;
		/* 820CF504h case    3:*/		return 0x820CF508;
		  /* 820CF508h */ case    4:  		/* lwz R11, <#[R3 + 60]> */
		/* 820CF508h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CF508h case    4:*/		return 0x820CF50C;
		  /* 820CF50Ch */ case    5:  		/* addi R8, R1, 128 */
		/* 820CF50Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x80);
		/* 820CF50Ch case    5:*/		return 0x820CF510;
		  /* 820CF510h */ case    6:  		/* lwz R10, <#[R3 + 120]> */
		/* 820CF510h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000078) );
		/* 820CF510h case    6:*/		return 0x820CF514;
		  /* 820CF514h */ case    7:  		/* mr R27, R9 */
		/* 820CF514h case    7:*/		regs.R27 = regs.R9;
		/* 820CF514h case    7:*/		return 0x820CF518;
		  /* 820CF518h */ case    8:  		/* stw R7, <#[R1 + 356]> */
		/* 820CF518h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000164) );
		/* 820CF518h case    8:*/		return 0x820CF51C;
		  /* 820CF51Ch */ case    9:  		/* li R9, 0 */
		/* 820CF51Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CF51Ch case    9:*/		return 0x820CF520;
		  /* 820CF520h */ case   10:  		/* stw R4, <#[R1 + 332]> */
		/* 820CF520h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000014C) );
		/* 820CF520h case   10:*/		return 0x820CF524;
		  /* 820CF524h */ case   11:  		/* addi R7, R11, -1 */
		/* 820CF524h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 820CF524h case   11:*/		return 0x820CF528;
		  /* 820CF528h */ case   12:  		/* stw R6, <#[R1 + 348]> */
		/* 820CF528h case   12:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000015C) );
		/* 820CF528h case   12:*/		return 0x820CF52C;
		  /* 820CF52Ch */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 820CF52Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CF52Ch case   13:*/		return 0x820CF530;
		  /* 820CF530h */ case   14:  		/* stw R5, <#[R1 + 340]> */
		/* 820CF530h case   14:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000154) );
		/* 820CF530h case   14:*/		return 0x820CF534;
		  /* 820CF534h */ case   15:  		/* std R9, <#[R8]> */
		/* 820CF534h case   15:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 820CF534h case   15:*/		return 0x820CF538;
		  /* 820CF538h */ case   16:  		/* stw R9, <#[R8 + 8]> */
		/* 820CF538h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 820CF538h case   16:*/		return 0x820CF53C;
		  /* 820CF53Ch */ case   17:  		/* cntlzw R7, R7 */
		/* 820CF53Ch case   17:*/		cpu::op::cntlzw<0>(regs,&regs.R7,regs.R7);
		/* 820CF53Ch case   17:*/		return 0x820CF540;
		  /* 820CF540h */ case   18:  		/* stw R10, <#[R1 + 92]> */
		/* 820CF540h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CF540h case   18:*/		return 0x820CF544;
		  /* 820CF544h */ case   19:  		/* mr R24, R6 */
		/* 820CF544h case   19:*/		regs.R24 = regs.R6;
		/* 820CF544h case   19:*/		return 0x820CF548;
		  /* 820CF548h */ case   20:  		/* li R6, -1 */
		/* 820CF548h case   20:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820CF548h case   20:*/		return 0x820CF54C;
		  /* 820CF54Ch */ case   21:  		/* stb R9, <#[R1 + 80]> */
		/* 820CF54Ch case   21:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820CF54Ch case   21:*/		return 0x820CF550;
		  /* 820CF550h */ case   22:  		/* rlwinm R8, R7, 27, 31, 31 */
		/* 820CF550h case   22:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R8,regs.R7);
		/* 820CF550h case   22:*/		return 0x820CF554;
		  /* 820CF554h */ case   23:  		/* stw R9, <#[R1 + 88]> */
		/* 820CF554h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 820CF554h case   23:*/		return 0x820CF558;
		  /* 820CF558h */ case   24:  		/* mr R31, R4 */
		/* 820CF558h case   24:*/		regs.R31 = regs.R4;
		/* 820CF558h case   24:*/		return 0x820CF55C;
		  /* 820CF55Ch */ case   25:  		/* stw R11, <#[R1 + 104]> */
		/* 820CF55Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820CF55Ch case   25:*/		return 0x820CF560;
		  /* 820CF560h */ case   26:  		/* mr R25, R5 */
		/* 820CF560h case   26:*/		regs.R25 = regs.R5;
		/* 820CF560h case   26:*/		return 0x820CF564;
		  /* 820CF564h */ case   27:  		/* stw R6, <#[R1 + 96]> */
		/* 820CF564h case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 820CF564h case   27:*/		return 0x820CF568;
		  /* 820CF568h */ case   28:  		/* mr R30, R9 */
		/* 820CF568h case   28:*/		regs.R30 = regs.R9;
		/* 820CF568h case   28:*/		return 0x820CF56C;
		  /* 820CF56Ch */ case   29:  		/* stw R9, <#[R1 + 108]> */
		/* 820CF56Ch case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 820CF56Ch case   29:*/		return 0x820CF570;
		  /* 820CF570h */ case   30:  		/* lwz R26, <#[R1 + 132]> */
		/* 820CF570h case   30:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000084) );
		/* 820CF570h case   30:*/		return 0x820CF574;
		  /* 820CF574h */ case   31:  		/* lwz R10, <#[R1 + 128]> */
		/* 820CF574h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820CF574h case   31:*/		return 0x820CF578;
		  /* 820CF578h */ case   32:  		/* oris R29, R10, 8 */
		/* 820CF578h case   32:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R10,0x8);
		/* 820CF578h case   32:*/		return 0x820CF57C;
		  /* 820CF57Ch */ case   33:  		/* rlwimi R26, R8, 30, 1, 1 */
		/* 820CF57Ch case   33:*/		cpu::op::rlwimi<0,30,1,1>(regs,&regs.R26,regs.R8);
		/* 820CF57Ch case   33:*/		return 0x820CF580;
	}
	return 0x820CF580;
} // Block from 820CF4F8h-820CF580h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820CF580h
// Function '?NonNull@CUAssembler@D3DXShader@@IAAPAVCNode@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF580);
		  /* 820CF580h */ case    0:  		/* stw R29, <#[R1 + 128]> */
		/* 820CF580h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000080) );
		/* 820CF580h case    0:*/		return 0x820CF584;
		  /* 820CF584h */ case    1:  		/* bc 12, CR6_EQ, 464 */
		/* 820CF584h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CF754;  }
		/* 820CF584h case    1:*/		return 0x820CF588;
		  /* 820CF588h */ case    2:  		/* lis R9, -32255 */
		/* 820CF588h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CF588h case    2:*/		return 0x820CF58C;
		  /* 820CF58Ch */ case    3:  		/* lis R7, -32255 */
		/* 820CF58Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820CF58Ch case    3:*/		return 0x820CF590;
		  /* 820CF590h */ case    4:  		/* lis R6, -32255 */
		/* 820CF590h case    4:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820CF590h case    4:*/		return 0x820CF594;
		  /* 820CF594h */ case    5:  		/* lis R5, -32255 */
		/* 820CF594h case    5:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820CF594h case    5:*/		return 0x820CF598;
		  /* 820CF598h */ case    6:  		/* lis R4, -32255 */
		/* 820CF598h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 820CF598h case    6:*/		return 0x820CF59C;
		  /* 820CF59Ch */ case    7:  		/* lis R3, -32255 */
		/* 820CF59Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8201);
		/* 820CF59Ch case    7:*/		return 0x820CF5A0;
		  /* 820CF5A0h */ case    8:  		/* lis R31, -32255 */
		/* 820CF5A0h case    8:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820CF5A0h case    8:*/		return 0x820CF5A4;
		  /* 820CF5A4h */ case    9:  		/* lis R30, -32255 */
		/* 820CF5A4h case    9:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8201);
		/* 820CF5A4h case    9:*/		return 0x820CF5A8;
		  /* 820CF5A8h */ case   10:  		/* lis R29, -32255 */
		/* 820CF5A8h case   10:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8201);
		/* 820CF5A8h case   10:*/		return 0x820CF5AC;
		  /* 820CF5ACh */ case   11:  		/* lis R8, -32217 */
		/* 820CF5ACh case   11:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8227);
		/* 820CF5ACh case   11:*/		return 0x820CF5B0;
		  /* 820CF5B0h */ case   12:  		/* lis R10, -32255 */
		/* 820CF5B0h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CF5B0h case   12:*/		return 0x820CF5B4;
		  /* 820CF5B4h */ case   13:  		/* lis R11, -32255 */
		/* 820CF5B4h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CF5B4h case   13:*/		return 0x820CF5B8;
		  /* 820CF5B8h */ case   14:  		/* addi R9, R9, 22976 */
		/* 820CF5B8h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x59C0);
		/* 820CF5B8h case   14:*/		return 0x820CF5BC;
		  /* 820CF5BCh */ case   15:  		/* li R24, 1 */
		/* 820CF5BCh case   15:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 820CF5BCh case   15:*/		return 0x820CF5C0;
		  /* 820CF5C0h */ case   16:  		/* addi R19, R7, 22952 */
		/* 820CF5C0h case   16:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R7,0x59A8);
		/* 820CF5C0h case   16:*/		return 0x820CF5C4;
		  /* 820CF5C4h */ case   17:  		/* stw R9, <#[R1 + 120]> */
		/* 820CF5C4h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000078) );
		/* 820CF5C4h case   17:*/		return 0x820CF5C8;
		  /* 820CF5C8h */ case   18:  		/* addi R25, R6, 22900 */
		/* 820CF5C8h case   18:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R6,0x5974);
		/* 820CF5C8h case   18:*/		return 0x820CF5CC;
		  /* 820CF5CCh */ case   19:  		/* addi R18, R5, 22864 */
		/* 820CF5CCh case   19:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R5,0x5950);
		/* 820CF5CCh case   19:*/		return 0x820CF5D0;
		  /* 820CF5D0h */ case   20:  		/* addi R21, R4, 22828 */
		/* 820CF5D0h case   20:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R4,0x592C);
		/* 820CF5D0h case   20:*/		return 0x820CF5D4;
		  /* 820CF5D4h */ case   21:  		/* addi R17, R3, 22788 */
		/* 820CF5D4h case   21:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R3,0x5904);
		/* 820CF5D4h case   21:*/		return 0x820CF5D8;
		  /* 820CF5D8h */ case   22:  		/* addi R16, R31, 22752 */
		/* 820CF5D8h case   22:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R31,0x58E0);
		/* 820CF5D8h case   22:*/		return 0x820CF5DC;
		  /* 820CF5DCh */ case   23:  		/* addi R15, R30, 22696 */
		/* 820CF5DCh case   23:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R30,0x58A8);
		/* 820CF5DCh case   23:*/		return 0x820CF5E0;
		  /* 820CF5E0h */ case   24:  		/* addi R14, R29, 22636 */
		/* 820CF5E0h case   24:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R29,0x586C);
		/* 820CF5E0h case   24:*/		return 0x820CF5E4;
		  /* 820CF5E4h */ case   25:  		/* addi R23, R8, 11944 */
		/* 820CF5E4h case   25:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R8,0x2EA8);
		/* 820CF5E4h case   25:*/		return 0x820CF5E8;
		  /* 820CF5E8h */ case   26:  		/* addi R22, R10, 22604 */
		/* 820CF5E8h case   26:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R10,0x584C);
		/* 820CF5E8h case   26:*/		return 0x820CF5EC;
		  /* 820CF5ECh */ case   27:  		/* addi R20, R11, 22536 */
		/* 820CF5ECh case   27:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R11,0x5808);
		/* 820CF5ECh case   27:*/		return 0x820CF5F0;
		  /* 820CF5F0h */ case   28:  		/* lwz R10, <#[R1 + 92]> */
		/* 820CF5F0h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CF5F0h case   28:*/		return 0x820CF5F4;
		  /* 820CF5F4h */ case   29:  		/* lwz R11, <#[R10 + 8]> */
		/* 820CF5F4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820CF5F4h case   29:*/		return 0x820CF5F8;
	}
	return 0x820CF5F8;
} // Block from 820CF580h-820CF5F8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820CF5F8h
// Function '?GetEnumValue@D3DXShader@@YAJPBUEnumStringTableEntry@1@PBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF5F8);
		  /* 820CF5F8h */ case    0:  		/* lwz R10, <#[R10 + 12]> */
		/* 820CF5F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820CF5F8h case    0:*/		return 0x820CF5FC;
		  /* 820CF5FCh */ case    1:  		/* lwz R9, <#[R11 + 8]> */
		/* 820CF5FCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820CF5FCh case    1:*/		return 0x820CF600;
		  /* 820CF600h */ case    2:  		/* stw R10, <#[R1 + 92]> */
		/* 820CF600h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CF600h case    2:*/		return 0x820CF604;
		  /* 820CF604h */ case    3:  		/* lwz R10, <#[R9 + 4]> */
		/* 820CF604h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 820CF604h case    3:*/		return 0x820CF608;
		  /* 820CF608h */ case    4:  		/* cmpwi CR6, R10, 3 */
		/* 820CF608h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 820CF608h case    4:*/		return 0x820CF60C;
		  /* 820CF60Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820CF60Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820CF61C;  }
		/* 820CF60Ch case    5:*/		return 0x820CF610;
		  /* 820CF610h */ case    6:  		/* lwz R11, <#[R1 + 356]> */
		/* 820CF610h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000164) );
		/* 820CF610h case    6:*/		return 0x820CF614;
		  /* 820CF614h */ case    7:  		/* stb R24, <#[R11]> */
		/* 820CF614h case    7:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 820CF614h case    7:*/		return 0x820CF618;
		  /* 820CF618h */ case    8:  		/* b 280 */
		/* 820CF618h case    8:*/		return 0x820CF730;
		/* 820CF618h case    8:*/		return 0x820CF61C;
	}
	return 0x820CF61C;
} // Block from 820CF5F8h-820CF61Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CF61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF61C);
		  /* 820CF61Ch */ case    0:  		/* lwz R6, <#[R1 + 104]> */
		/* 820CF61Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000068) );
		/* 820CF61Ch case    0:*/		return 0x820CF620;
		  /* 820CF620h */ case    1:  		/* lwz R31, <#[R9 + 24]> */
		/* 820CF620h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000018) );
		/* 820CF620h case    1:*/		return 0x820CF624;
		  /* 820CF624h */ case    2:  		/* lwz R10, <#[R11 + 12]> */
		/* 820CF624h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820CF624h case    2:*/		return 0x820CF628;
		  /* 820CF628h */ case    3:  		/* cmplwi CR6, R6, 0 */
		/* 820CF628h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820CF628h case    3:*/		return 0x820CF62C;
		  /* 820CF62Ch */ case    4:  		/* bc 4, CR6_EQ, 132 */
		/* 820CF62Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CF6B0;  }
		/* 820CF62Ch case    4:*/		return 0x820CF630;
		  /* 820CF630h */ case    5:  		/* lwz R11, <#[R1 + 96]> */
		/* 820CF630h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CF630h case    5:*/		return 0x820CF634;
		  /* 820CF634h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 820CF634h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820CF634h case    6:*/		return 0x820CF638;
		  /* 820CF638h */ case    7:  		/* bc 4, CR6_EQ, 120 */
		/* 820CF638h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820CF6B0;  }
		/* 820CF638h case    7:*/		return 0x820CF63C;
		  /* 820CF63Ch */ case    8:  		/* lbz R11, <#[R1 + 80]> */
		/* 820CF63Ch case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820CF63Ch case    8:*/		return 0x820CF640;
		  /* 820CF640h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 820CF640h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820CF640h case    9:*/		return 0x820CF644;
		  /* 820CF644h */ case   10:  		/* bc 4, CR0_EQ, 108 */
		/* 820CF644h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820CF6B0;  }
		/* 820CF644h case   10:*/		return 0x820CF648;
		  /* 820CF648h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820CF648h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CF648h case   11:*/		return 0x820CF64C;
		  /* 820CF64Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 820CF64Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820CF664;  }
		/* 820CF64Ch case   12:*/		return 0x820CF650;
		  /* 820CF650h */ case   13:  		/* mr R4, R20 */
		/* 820CF650h case   13:*/		regs.R4 = regs.R20;
		/* 820CF650h case   13:*/		return 0x820CF654;
		  /* 820CF654h */ case   14:  		/* mtspr CTR, R28 */
		/* 820CF654h case   14:*/		regs.CTR = regs.R28;
		/* 820CF654h case   14:*/		return 0x820CF658;
		  /* 820CF658h */ case   15:  		/* mr R3, R27 */
		/* 820CF658h case   15:*/		regs.R3 = regs.R27;
		/* 820CF658h case   15:*/		return 0x820CF65C;
		  /* 820CF65Ch */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 820CF65Ch case   16:*/		if ( 1 ) { regs.LR = 0x820CF660; return (uint32)regs.CTR; }
		/* 820CF65Ch case   16:*/		return 0x820CF660;
		  /* 820CF660h */ case   17:  		/* b 48 */
		/* 820CF660h case   17:*/		return 0x820CF690;
		/* 820CF660h case   17:*/		return 0x820CF664;
	}
	return 0x820CF664;
} // Block from 820CF61Ch-820CF664h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820CF664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF664);
		  /* 820CF664h */ case    0:  		/* addi R5, R1, 116 */
		/* 820CF664h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x74);
		/* 820CF664h case    0:*/		return 0x820CF668;
		  /* 820CF668h */ case    1:  		/* addi R4, R1, 112 */
		/* 820CF668h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820CF668h case    1:*/		return 0x820CF66C;
		  /* 820CF66Ch */ case    2:  		/* addi R3, R9, 16 */
		/* 820CF66Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x10);
		/* 820CF66Ch case    2:*/		return 0x820CF670;
		  /* 820CF670h */ case    3:  		/* bl -4016 */
		/* 820CF670h case    3:*/		regs.LR = 0x820CF674; return 0x820CE6C0;
		/* 820CF670h case    3:*/		return 0x820CF674;
		  /* 820CF674h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820CF674h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CF674h case    4:*/		return 0x820CF678;
		  /* 820CF678h */ case    5:  		/* bc 4, CR0_EQ, 32 */
		/* 820CF678h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820CF698;  }
		/* 820CF678h case    5:*/		return 0x820CF67C;
		  /* 820CF67Ch */ case    6:  		/* mr R4, R22 */
		/* 820CF67Ch case    6:*/		regs.R4 = regs.R22;
		/* 820CF67Ch case    6:*/		return 0x820CF680;
		  /* 820CF680h */ case    7:  		/* mtspr CTR, R28 */
		/* 820CF680h case    7:*/		regs.CTR = regs.R28;
		/* 820CF680h case    7:*/		return 0x820CF684;
		  /* 820CF684h */ case    8:  		/* mr R5, R31 */
		/* 820CF684h case    8:*/		regs.R5 = regs.R31;
		/* 820CF684h case    8:*/		return 0x820CF688;
		  /* 820CF688h */ case    9:  		/* mr R3, R27 */
		/* 820CF688h case    9:*/		regs.R3 = regs.R27;
		/* 820CF688h case    9:*/		return 0x820CF68C;
		  /* 820CF68Ch */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820CF68Ch case   10:*/		if ( 1 ) { regs.LR = 0x820CF690; return (uint32)regs.CTR; }
		/* 820CF68Ch case   10:*/		return 0x820CF690;
	}
	return 0x820CF690;
} // Block from 820CF664h-820CF690h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CF690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF690);
		  /* 820CF690h */ case    0:  		/* stb R24, <#[R1 + 80]> */
		/* 820CF690h case    0:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 820CF690h case    0:*/		return 0x820CF694;
		  /* 820CF694h */ case    1:  		/* b 156 */
		/* 820CF694h case    1:*/		return 0x820CF730;
		/* 820CF694h case    1:*/		return 0x820CF698;
	}
	return 0x820CF698;
} // Block from 820CF690h-820CF698h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF698);
		  /* 820CF698h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820CF698h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820CF698h case    0:*/		return 0x820CF69C;
		  /* 820CF69Ch */ case    1:  		/* lwz R10, <#[R1 + 116]> */
		/* 820CF69Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820CF69Ch case    1:*/		return 0x820CF6A0;
	}
	return 0x820CF6A0;
} // Block from 820CF698h-820CF6A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF6A0h
// Function '?AddStructMemberInfoNoDuplicates@D3DXShader@@YAIPBU_D3DXSHADER_STRUCTMEMBERINFO@@IPAU2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF6A0);
		  /* 820CF6A0h */ case    0:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 820CF6A0h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 820CF6A0h case    0:*/		return 0x820CF6A4;
		  /* 820CF6A4h */ case    1:  		/* or R11, R11, R10 */
		/* 820CF6A4h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820CF6A4h case    1:*/		return 0x820CF6A8;
		  /* 820CF6A8h */ case    2:  		/* stw R11, <#[R1 + 96]> */
		/* 820CF6A8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CF6A8h case    2:*/		return 0x820CF6AC;
		  /* 820CF6ACh */ case    3:  		/* b 132 */
		/* 820CF6ACh case    3:*/		return 0x820CF730;
		/* 820CF6ACh case    3:*/		return 0x820CF6B0;
	}
	return 0x820CF6B0;
} // Block from 820CF6A0h-820CF6B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CF6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF6B0);
		  /* 820CF6B0h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820CF6B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CF6B0h case    0:*/		return 0x820CF6B4;
		  /* 820CF6B4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CF6B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF6C0;  }
		/* 820CF6B4h case    1:*/		return 0x820CF6B8;
		  /* 820CF6B8h */ case    2:  		/* lwz R4, <#[R1 + 120]> */
		/* 820CF6B8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000078) );
		/* 820CF6B8h case    2:*/		return 0x820CF6BC;
		  /* 820CF6BCh */ case    3:  		/* b 100 */
		/* 820CF6BCh case    3:*/		return 0x820CF720;
		/* 820CF6BCh case    3:*/		return 0x820CF6C0;
	}
	return 0x820CF6C0;
} // Block from 820CF6B0h-820CF6C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CF6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF6C0);
		  /* 820CF6C0h */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 820CF6C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820CF6C0h case    0:*/		return 0x820CF6C4;
		  /* 820CF6C4h */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 820CF6C4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820CF6C4h case    1:*/		return 0x820CF6C8;
		  /* 820CF6C8h */ case    2:  		/* bc 4, CR6_EQ, -184 */
		/* 820CF6C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CF610;  }
		/* 820CF6C8h case    2:*/		return 0x820CF6CC;
		  /* 820CF6CCh */ case    3:  		/* mr R11, R23 */
		/* 820CF6CCh case    3:*/		regs.R11 = regs.R23;
		/* 820CF6CCh case    3:*/		return 0x820CF6D0;
		  /* 820CF6D0h */ case    4:  		/* addi R3, R10, 16 */
		/* 820CF6D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x10);
		/* 820CF6D0h case    4:*/		return 0x820CF6D4;
		  /* 820CF6D4h */ case    5:  		/* li R7, 0 */
		/* 820CF6D4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820CF6D4h case    5:*/		return 0x820CF6D8;
		  /* 820CF6D8h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 820CF6D8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CF6D8h case    6:*/		return 0x820CF6DC;
		  /* 820CF6DCh */ case    7:  		/* mr R9, R31 */
		/* 820CF6DCh case    7:*/		regs.R9 = regs.R31;
		/* 820CF6DCh case    7:*/		return 0x820CF6E0;
		  /* 820CF6E0h */ case    8:  		/* lbz R8, <#[R10]> */
		/* 820CF6E0h case    8:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820CF6E0h case    8:*/		return 0x820CF6E4;
		  /* 820CF6E4h */ case    9:  		/* lbz R5, <#[R9]> */
		/* 820CF6E4h case    9:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 820CF6E4h case    9:*/		return 0x820CF6E8;
		  /* 820CF6E8h */ case   10:  		/* cmpwi CR0, R8, 0 */
		/* 820CF6E8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820CF6E8h case   10:*/		return 0x820CF6EC;
		  /* 820CF6ECh */ case   11:  		/* subf R8, R5, R8 */
		/* 820CF6ECh case   11:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820CF6ECh case   11:*/		return 0x820CF6F0;
		  /* 820CF6F0h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 820CF6F0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CF704;  }
		/* 820CF6F0h case   12:*/		return 0x820CF6F4;
		  /* 820CF6F4h */ case   13:  		/* addi R10, R10, 1 */
		/* 820CF6F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CF6F4h case   13:*/		return 0x820CF6F8;
		  /* 820CF6F8h */ case   14:  		/* addi R9, R9, 1 */
		/* 820CF6F8h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820CF6F8h case   14:*/		return 0x820CF6FC;
		  /* 820CF6FCh */ case   15:  		/* cmpwi CR6, R8, 0 */
		/* 820CF6FCh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820CF6FCh case   15:*/		return 0x820CF700;
		  /* 820CF700h */ case   16:  		/* bc 12, CR6_EQ, -32 */
		/* 820CF700h case   16:*/		if ( regs.CR[6].eq ) { return 0x820CF6E0;  }
		/* 820CF700h case   16:*/		return 0x820CF704;
	}
	return 0x820CF704;
} // Block from 820CF6C0h-820CF704h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820CF704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF704);
		  /* 820CF704h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820CF704h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820CF704h case    0:*/		return 0x820CF708;
		  /* 820CF708h */ case    1:  		/* bc 12, CR0_EQ, 136 */
		/* 820CF708h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CF790;  }
		/* 820CF708h case    1:*/		return 0x820CF70C;
		  /* 820CF70Ch */ case    2:  		/* addi R7, R7, 24 */
		/* 820CF70Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x18);
		/* 820CF70Ch case    2:*/		return 0x820CF710;
		  /* 820CF710h */ case    3:  		/* addi R11, R11, 24 */
		/* 820CF710h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820CF710h case    3:*/		return 0x820CF714;
		  /* 820CF714h */ case    4:  		/* cmplwi CR6, R7, 216 */
		/* 820CF714h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x000000D8);
		/* 820CF714h case    4:*/		return 0x820CF718;
		  /* 820CF718h */ case    5:  		/* bc 12, CR6_LT, -64 */
		/* 820CF718h case    5:*/		if ( regs.CR[6].lt ) { return 0x820CF6D8;  }
		/* 820CF718h case    5:*/		return 0x820CF71C;
		  /* 820CF71Ch */ case    6:  		/* mr R4, R19 */
		/* 820CF71Ch case    6:*/		regs.R4 = regs.R19;
		/* 820CF71Ch case    6:*/		return 0x820CF720;
	}
	return 0x820CF720;
} // Block from 820CF704h-820CF720h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CF720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF720);
		  /* 820CF720h */ case    0:  		/* mr R5, R31 */
		/* 820CF720h case    0:*/		regs.R5 = regs.R31;
		/* 820CF720h case    0:*/		return 0x820CF724;
		  /* 820CF724h */ case    1:  		/* mtspr CTR, R28 */
		/* 820CF724h case    1:*/		regs.CTR = regs.R28;
		/* 820CF724h case    1:*/		return 0x820CF728;
		  /* 820CF728h */ case    2:  		/* mr R3, R27 */
		/* 820CF728h case    2:*/		regs.R3 = regs.R27;
		/* 820CF728h case    2:*/		return 0x820CF72C;
		  /* 820CF72Ch */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820CF72Ch case    3:*/		if ( 1 ) { regs.LR = 0x820CF730; return (uint32)regs.CTR; }
		/* 820CF72Ch case    3:*/		return 0x820CF730;
	}
	return 0x820CF730;
} // Block from 820CF720h-820CF730h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CF730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF730);
		  /* 820CF730h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 820CF730h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CF730h case    0:*/		return 0x820CF734;
		  /* 820CF734h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CF734h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CF734h case    1:*/		return 0x820CF738;
		  /* 820CF738h */ case    2:  		/* bc 4, CR6_EQ, -328 */
		/* 820CF738h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CF5F0;  }
		/* 820CF738h case    2:*/		return 0x820CF73C;
		  /* 820CF73Ch */ case    3:  		/* lwz R24, <#[R1 + 348]> */
		/* 820CF73Ch case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x0000015C) );
		/* 820CF73Ch case    3:*/		return 0x820CF740;
		  /* 820CF740h */ case    4:  		/* lwz R25, <#[R1 + 340]> */
		/* 820CF740h case    4:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000154) );
		/* 820CF740h case    4:*/		return 0x820CF744;
		  /* 820CF744h */ case    5:  		/* lwz R31, <#[R1 + 332]> */
		/* 820CF744h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x0000014C) );
		/* 820CF744h case    5:*/		return 0x820CF748;
		  /* 820CF748h */ case    6:  		/* lwz R29, <#[R1 + 128]> */
		/* 820CF748h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000080) );
		/* 820CF748h case    6:*/		return 0x820CF74C;
		  /* 820CF74Ch */ case    7:  		/* lwz R11, <#[R1 + 104]> */
		/* 820CF74Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820CF74Ch case    7:*/		return 0x820CF750;
		  /* 820CF750h */ case    8:  		/* lwz R30, <#[R1 + 108]> */
		/* 820CF750h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 820CF750h case    8:*/		return 0x820CF754;
	}
	return 0x820CF754;
} // Block from 820CF730h-820CF754h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CF754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF754);
		  /* 820CF754h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820CF754h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CF754h case    0:*/		return 0x820CF758;
		  /* 820CF758h */ case    1:  		/* bc 12, CR6_EQ, 596 */
		/* 820CF758h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CF9AC;  }
		/* 820CF758h case    1:*/		return 0x820CF75C;
		  /* 820CF75Ch */ case    2:  		/* lwz R10, <#[R1 + 88]> */
		/* 820CF75Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820CF75Ch case    2:*/		return 0x820CF760;
	}
	return 0x820CF760;
} // Block from 820CF754h-820CF760h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF760h
// Function '?AddTypeInfoNoDuplicates@D3DXShader@@YAIPBU_D3DXSHADER_TYPEINFO@@PAU2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF760);
		  /* 820CF760h */ case    0:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 820CF760h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 820CF760h case    0:*/		return 0x820CF764;
		  /* 820CF764h */ case    1:  		/* bc 4, CR0_EQ, 584 */
		/* 820CF764h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820CF9AC;  }
		/* 820CF764h case    1:*/		return 0x820CF768;
		  /* 820CF768h */ case    2:  		/* lis R10, -32217 */
		/* 820CF768h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 820CF768h case    2:*/		return 0x820CF76C;
		  /* 820CF76Ch */ case    3:  		/* mtspr CTR, R28 */
		/* 820CF76Ch case    3:*/		regs.CTR = regs.R28;
		/* 820CF76Ch case    3:*/		return 0x820CF770;
		  /* 820CF770h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820CF770h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820CF770h case    4:*/		return 0x820CF774;
		  /* 820CF774h */ case    5:  		/* addi R10, R10, 12476 */
		/* 820CF774h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x30BC);
		/* 820CF774h case    5:*/		return 0x820CF778;
		  /* 820CF778h */ case    6:  		/* lis R9, -32255 */
		/* 820CF778h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CF778h case    6:*/		return 0x820CF77C;
		  /* 820CF77Ch */ case    7:  		/* mr R3, R27 */
		/* 820CF77Ch case    7:*/		regs.R3 = regs.R27;
		/* 820CF77Ch case    7:*/		return 0x820CF780;
		  /* 820CF780h */ case    8:  		/* addi R4, R9, 22480 */
		/* 820CF780h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x57D0);
		/* 820CF780h case    8:*/		return 0x820CF784;
		  /* 820CF784h */ case    9:  		/* lwzx R5, <#[R11 + R10]> */
		/* 820CF784h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820CF784h case    9:*/		return 0x820CF788;
		  /* 820CF788h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820CF788h case   10:*/		if ( 1 ) { regs.LR = 0x820CF78C; return (uint32)regs.CTR; }
		/* 820CF788h case   10:*/		return 0x820CF78C;
		  /* 820CF78Ch */ case   11:  		/* b 580 */
		/* 820CF78Ch case   11:*/		return 0x820CF9D0;
		/* 820CF78Ch case   11:*/		return 0x820CF790;
	}
	return 0x820CF790;
} // Block from 820CF760h-820CF790h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CF790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF790);
		  /* 820CF790h */ case    0:  		/* cmplwi CR6, R6, 1 */
		/* 820CF790h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 820CF790h case    0:*/		return 0x820CF794;
		  /* 820CF794h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820CF794h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF7AC;  }
		/* 820CF794h case    1:*/		return 0x820CF798;
		  /* 820CF798h */ case    2:  		/* lwz R10, <#[R11 + 8]> */
		/* 820CF798h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820CF798h case    2:*/		return 0x820CF79C;
		  /* 820CF79Ch */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 820CF79Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820CF79Ch case    3:*/		return 0x820CF7A0;
		  /* 820CF7A0h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 820CF7A0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CF7C8;  }
		/* 820CF7A0h case    4:*/		return 0x820CF7A4;
		  /* 820CF7A4h */ case    5:  		/* mr R4, R14 */
		/* 820CF7A4h case    5:*/		regs.R4 = regs.R14;
		/* 820CF7A4h case    5:*/		return 0x820CF7A8;
		  /* 820CF7A8h */ case    6:  		/* b -136 */
		/* 820CF7A8h case    6:*/		return 0x820CF720;
		/* 820CF7A8h case    6:*/		return 0x820CF7AC;
	}
	return 0x820CF7AC;
} // Block from 820CF790h-820CF7ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CF7ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF7AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF7AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF7AC);
		  /* 820CF7ACh */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820CF7ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820CF7ACh case    0:*/		return 0x820CF7B0;
		  /* 820CF7B0h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820CF7B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF7C8;  }
		/* 820CF7B0h case    1:*/		return 0x820CF7B4;
		  /* 820CF7B4h */ case    2:  		/* lwz R10, <#[R11 + 12]> */
		/* 820CF7B4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820CF7B4h case    2:*/		return 0x820CF7B8;
		  /* 820CF7B8h */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 820CF7B8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820CF7B8h case    3:*/		return 0x820CF7BC;
		  /* 820CF7BCh */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 820CF7BCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CF7C8;  }
		/* 820CF7BCh case    4:*/		return 0x820CF7C0;
		  /* 820CF7C0h */ case    5:  		/* mr R4, R15 */
		/* 820CF7C0h case    5:*/		regs.R4 = regs.R15;
		/* 820CF7C0h case    5:*/		return 0x820CF7C4;
		  /* 820CF7C4h */ case    6:  		/* b -164 */
		/* 820CF7C4h case    6:*/		return 0x820CF720;
		/* 820CF7C4h case    6:*/		return 0x820CF7C8;
	}
	return 0x820CF7C8;
} // Block from 820CF7ACh-820CF7C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CF7C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF7C8);
		  /* 820CF7C8h */ case    0:  		/* lbz R29, <#[R11 + 4]> */
		/* 820CF7C8h case    0:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 820CF7C8h case    0:*/		return 0x820CF7CC;
		  /* 820CF7CCh */ case    1:  		/* lwz R10, <#[R1 + 88]> */
		/* 820CF7CCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820CF7CCh case    1:*/		return 0x820CF7D0;
		  /* 820CF7D0h */ case    2:  		/* slw R9, R24, R29 */
		/* 820CF7D0h case    2:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R24,regs.R29);
		/* 820CF7D0h case    2:*/		return 0x820CF7D4;
		  /* 820CF7D4h */ case    3:  		/* and. R10, R9, R10 */
		/* 820CF7D4h case    3:*/		cpu::op::and<1>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820CF7D4h case    3:*/		return 0x820CF7D8;
		  /* 820CF7D8h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 820CF7D8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820CF7E4;  }
		/* 820CF7D8h case    4:*/		return 0x820CF7DC;
		  /* 820CF7DCh */ case    5:  		/* mr R4, R16 */
		/* 820CF7DCh case    5:*/		regs.R4 = regs.R16;
		/* 820CF7DCh case    5:*/		return 0x820CF7E0;
		  /* 820CF7E0h */ case    6:  		/* b -192 */
		/* 820CF7E0h case    6:*/		return 0x820CF720;
		/* 820CF7E0h case    6:*/		return 0x820CF7E4;
	}
	return 0x820CF7E4;
} // Block from 820CF7C8h-820CF7E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CF7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF7E4);
		  /* 820CF7E4h */ case    0:  		/* lwz R7, <#[R1 + 88]> */
		/* 820CF7E4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 820CF7E4h case    0:*/		return 0x820CF7E8;
		  /* 820CF7E8h */ case    1:  		/* li R8, 0 */
		/* 820CF7E8h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820CF7E8h case    1:*/		return 0x820CF7EC;
		  /* 820CF7ECh */ case    2:  		/* lbz R10, <#[R11 + 5]> */
		/* 820CF7ECh case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000005) );
		/* 820CF7ECh case    2:*/		return 0x820CF7F0;
		  /* 820CF7F0h */ case    3:  		/* li R30, 0 */
		/* 820CF7F0h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CF7F0h case    3:*/		return 0x820CF7F4;
		  /* 820CF7F4h */ case    4:  		/* or R9, R9, R7 */
		/* 820CF7F4h case    4:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820CF7F4h case    4:*/		return 0x820CF7F8;
		  /* 820CF7F8h */ case    5:  		/* stw R8, <#[R1 + 84]> */
		/* 820CF7F8h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820CF7F8h case    5:*/		return 0x820CF7FC;
		  /* 820CF7FCh */ case    6:  		/* stw R30, <#[R1 + 100]> */
		/* 820CF7FCh case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 820CF7FCh case    6:*/		return 0x820CF800;
		  /* 820CF800h */ case    7:  		/* cmplwi CR6, R10, 1 */
		/* 820CF800h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820CF800h case    7:*/		return 0x820CF804;
		  /* 820CF804h */ case    8:  		/* stw R9, <#[R1 + 88]> */
		/* 820CF804h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 820CF804h case    8:*/		return 0x820CF808;
	}
	return 0x820CF808;
} // Block from 820CF7E4h-820CF808h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CF808h
// Function '?DecodeMask@CUAssembler@D3DXShader@@IAAKPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF808);
		  /* 820CF808h */ case    0:  		/* bc 12, CR6_LT, 180 */
		/* 820CF808h case    0:*/		if ( regs.CR[6].lt ) { return 0x820CF8BC;  }
		/* 820CF808h case    0:*/		return 0x820CF80C;
		  /* 820CF80Ch */ case    1:  		/* bc 12, CR6_EQ, 152 */
		/* 820CF80Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820CF8A4;  }
		/* 820CF80Ch case    1:*/		return 0x820CF810;
		  /* 820CF810h */ case    2:  		/* cmplwi CR6, R10, 3 */
		/* 820CF810h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820CF810h case    2:*/		return 0x820CF814;
		  /* 820CF814h */ case    3:  		/* bc 12, CR6_LT, 68 */
		/* 820CF814h case    3:*/		if ( regs.CR[6].lt ) { return 0x820CF858;  }
		/* 820CF814h case    3:*/		return 0x820CF818;
		  /* 820CF818h */ case    4:  		/* bc 4, CR6_EQ, 92 */
		/* 820CF818h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CF874;  }
		/* 820CF818h case    4:*/		return 0x820CF81C;
		  /* 820CF81Ch */ case    5:  		/* lwz R11, <#[R11 + 16]> */
		/* 820CF81Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820CF81Ch case    5:*/		return 0x820CF820;
		  /* 820CF820h */ case    6:  		/* addi R4, R1, 100 */
		/* 820CF820h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x64);
		/* 820CF820h case    6:*/		return 0x820CF824;
		  /* 820CF824h */ case    7:  		/* addi R11, R11, -1 */
		/* 820CF824h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820CF824h case    7:*/		return 0x820CF828;
		  /* 820CF828h */ case    8:  		/* slw R11, R24, R11 */
		/* 820CF828h case    8:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 820CF828h case    8:*/		return 0x820CF82C;
		  /* 820CF82Ch */ case    9:  		/* addi R6, R11, -1 */
		/* 820CF82Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 820CF82Ch case    9:*/		return 0x820CF830;
		  /* 820CF830h */ case   10:  		/* subfic R5, R6, -1 */
		/* 820CF830h case   10:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R6,0xFFFFFFFF);
		/* 820CF830h case   10:*/		return 0x820CF834;
		  /* 820CF834h */ case   11:  		/* bl -1284 */
		/* 820CF834h case   11:*/		regs.LR = 0x820CF838; return 0x820CF330;
		/* 820CF834h case   11:*/		return 0x820CF838;
		  /* 820CF838h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820CF838h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CF838h case   12:*/		return 0x820CF83C;
		  /* 820CF83Ch */ case   13:  		/* bc 4, CR0_LT, 256 */
		/* 820CF83Ch case   13:*/		if ( !regs.CR[0].lt ) { return 0x820CF93C;  }
		/* 820CF83Ch case   13:*/		return 0x820CF840;
		  /* 820CF840h */ case   14:  		/* mr R4, R25 */
		/* 820CF840h case   14:*/		regs.R4 = regs.R25;
		/* 820CF840h case   14:*/		return 0x820CF844;
		  /* 820CF844h */ case   15:  		/* mtspr CTR, R28 */
		/* 820CF844h case   15:*/		regs.CTR = regs.R28;
		/* 820CF844h case   15:*/		return 0x820CF848;
		  /* 820CF848h */ case   16:  		/* mr R7, R31 */
		/* 820CF848h case   16:*/		regs.R7 = regs.R31;
		/* 820CF848h case   16:*/		return 0x820CF84C;
		  /* 820CF84Ch */ case   17:  		/* mr R3, R27 */
		/* 820CF84Ch case   17:*/		regs.R3 = regs.R27;
		/* 820CF84Ch case   17:*/		return 0x820CF850;
		  /* 820CF850h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820CF850h case   18:*/		if ( 1 ) { regs.LR = 0x820CF854; return (uint32)regs.CTR; }
		/* 820CF850h case   18:*/		return 0x820CF854;
		  /* 820CF854h */ case   19:  		/* b -292 */
		/* 820CF854h case   19:*/		return 0x820CF730;
		/* 820CF854h case   19:*/		return 0x820CF858;
	}
	return 0x820CF858;
} // Block from 820CF808h-820CF858h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820CF858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF858);
		  /* 820CF858h */ case    0:  		/* addi R4, R1, 84 */
		/* 820CF858h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 820CF858h case    0:*/		return 0x820CF85C;
		  /* 820CF85Ch */ case    1:  		/* lwz R6, <#[R11 + 16]> */
		/* 820CF85Ch case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000010) );
		/* 820CF85Ch case    1:*/		return 0x820CF860;
		  /* 820CF860h */ case    2:  		/* lwz R5, <#[R11 + 20]> */
		/* 820CF860h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000014) );
		/* 820CF860h case    2:*/		return 0x820CF864;
		  /* 820CF864h */ case    3:  		/* bl -1332 */
		/* 820CF864h case    3:*/		regs.LR = 0x820CF868; return 0x820CF330;
		/* 820CF864h case    3:*/		return 0x820CF868;
		  /* 820CF868h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820CF868h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CF868h case    4:*/		return 0x820CF86C;
		  /* 820CF86Ch */ case    5:  		/* bc 12, CR0_LT, -44 */
		/* 820CF86Ch case    5:*/		if ( regs.CR[0].lt ) { return 0x820CF840;  }
		/* 820CF86Ch case    5:*/		return 0x820CF870;
		  /* 820CF870h */ case    6:  		/* lwz R8, <#[R1 + 84]> */
		/* 820CF870h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820CF870h case    6:*/		return 0x820CF874;
	}
	return 0x820CF874;
} // Block from 820CF858h-820CF874h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CF874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF874);
		  /* 820CF874h */ case    0:  		/* cmplwi CR6, R29, 10 */
		/* 820CF874h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000A);
		/* 820CF874h case    0:*/		return 0x820CF878;
		  /* 820CF878h */ case    1:  		/* bc 12, CR6_GT, -328 */
		/* 820CF878h case    1:*/		if ( regs.CR[6].gt ) { return 0x820CF730;  }
		/* 820CF878h case    1:*/		return 0x820CF87C;
		  /* 820CF87Ch */ case    2:  		/* lis R12, -32255 */
		/* 820CF87Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820CF87Ch case    2:*/		return 0x820CF880;
		  /* 820CF880h */ case    3:  		/* addi R12, R12, 21800 */
		/* 820CF880h case    3:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5528);
		/* 820CF880h case    3:*/		return 0x820CF884;
		  /* 820CF884h */ case    4:  		/* lbzx R0, <#[R12 + R29]> */
		/* 820CF884h case    4:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R29 + 0x00000000) );
		/* 820CF884h case    4:*/		return 0x820CF888;
		  /* 820CF888h */ case    5:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820CF888h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820CF888h case    5:*/		return 0x820CF88C;
		  /* 820CF88Ch */ case    6:  		/* lis R12, -32243 */
		/* 820CF88Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820D);
		/* 820CF88Ch case    6:*/		return 0x820CF890;
		  /* 820CF890h */ case    7:  		/* ori R0, R0, 0 */
		/* 820CF890h case    7:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820CF890h case    7:*/		return 0x820CF894;
		  /* 820CF894h */ case    8:  		/* addi R12, R12, -2256 */
		/* 820CF894h case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFF730);
		/* 820CF894h case    8:*/		return 0x820CF898;
		  /* 820CF898h */ case    9:  		/* add R12, R12, R0 */
		/* 820CF898h case    9:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820CF898h case    9:*/		return 0x820CF89C;
		  /* 820CF89Ch */ case   10:  		/* mtspr CTR, R12 */
		/* 820CF89Ch case   10:*/		regs.CTR = regs.R12;
		/* 820CF89Ch case   10:*/		return 0x820CF8A0;
		  /* 820CF8A0h */ case   11:  		/* bcctr 20, CR0_LT */
		/* 820CF8A0h case   11:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820CF8A0h case   11:*/		return 0x820CF8A4;
	}
	return 0x820CF8A4;
} // Block from 820CF874h-820CF8A4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CF8A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF8A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF8A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF8A4);
		  /* 820CF8A4h */ case    0:  		/* addi R4, R1, 84 */
		/* 820CF8A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 820CF8A4h case    0:*/		return 0x820CF8A8;
		  /* 820CF8A8h */ case    1:  		/* bl -1168 */
		/* 820CF8A8h case    1:*/		regs.LR = 0x820CF8AC; return 0x820CF418;
		/* 820CF8A8h case    1:*/		return 0x820CF8AC;
		  /* 820CF8ACh */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820CF8ACh case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CF8ACh case    2:*/		return 0x820CF8B0;
		  /* 820CF8B0h */ case    3:  		/* bc 4, CR0_LT, -64 */
		/* 820CF8B0h case    3:*/		if ( !regs.CR[0].lt ) { return 0x820CF870;  }
		/* 820CF8B0h case    3:*/		return 0x820CF8B4;
		  /* 820CF8B4h */ case    4:  		/* mr R4, R18 */
		/* 820CF8B4h case    4:*/		regs.R4 = regs.R18;
		/* 820CF8B4h case    4:*/		return 0x820CF8B8;
		  /* 820CF8B8h */ case    5:  		/* b -408 */
		/* 820CF8B8h case    5:*/		return 0x820CF720;
		/* 820CF8B8h case    5:*/		return 0x820CF8BC;
	}
	return 0x820CF8BC;
} // Block from 820CF8A4h-820CF8BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CF8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF8BC);
		  /* 820CF8BCh */ case    0:  		/* lwz R10, <#[R3]> */
		/* 820CF8BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CF8BCh case    0:*/		return 0x820CF8C0;
		  /* 820CF8C0h */ case    1:  		/* cmpwi CR6, R10, 11 */
		/* 820CF8C0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000B);
		/* 820CF8C0h case    1:*/		return 0x820CF8C4;
		  /* 820CF8C4h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820CF8C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CF8D0;  }
		/* 820CF8C4h case    2:*/		return 0x820CF8C8;
		  /* 820CF8C8h */ case    3:  		/* mr R4, R17 */
		/* 820CF8C8h case    3:*/		regs.R4 = regs.R17;
		/* 820CF8C8h case    3:*/		return 0x820CF8CC;
		  /* 820CF8CCh */ case    4:  		/* b -428 */
		/* 820CF8CCh case    4:*/		return 0x820CF720;
		/* 820CF8CCh case    4:*/		return 0x820CF8D0;
	}
	return 0x820CF8D0;
} // Block from 820CF8BCh-820CF8D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CF8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF8D0);
		  /* 820CF8D0h */ case    0:  		/* lwz R8, <#[R11 + 16]> */
		/* 820CF8D0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 820CF8D0h case    0:*/		return 0x820CF8D4;
		  /* 820CF8D4h */ case    1:  		/* lwz R5, <#[R3 + 8]> */
		/* 820CF8D4h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000008) );
		/* 820CF8D4h case    1:*/		return 0x820CF8D8;
		  /* 820CF8D8h */ case    2:  		/* lwz R11, <#[R8]> */
		/* 820CF8D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820CF8D8h case    2:*/		return 0x820CF8DC;
		  /* 820CF8DCh */ case    3:  		/* b 56 */
		/* 820CF8DCh case    3:*/		return 0x820CF914;
		/* 820CF8DCh case    3:*/		return 0x820CF8E0;
		  /* 820CF8E0h */ case    4:  		/* mr R10, R5 */
		/* 820CF8E0h case    4:*/		regs.R10 = regs.R5;
		/* 820CF8E0h case    4:*/		return 0x820CF8E4;
		  /* 820CF8E4h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820CF8E4h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CF8E4h case    5:*/		return 0x820CF8E8;
		  /* 820CF8E8h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820CF8E8h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CF8E8h case    6:*/		return 0x820CF8EC;
		  /* 820CF8ECh */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820CF8ECh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CF8ECh case    7:*/		return 0x820CF8F0;
		  /* 820CF8F0h */ case    8:  		/* subf R9, R7, R9 */
		/* 820CF8F0h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CF8F0h case    8:*/		return 0x820CF8F4;
		  /* 820CF8F4h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820CF8F4h case    9:*/		if ( regs.CR[0].eq ) { return 0x820CF908;  }
		/* 820CF8F4h case    9:*/		return 0x820CF8F8;
		  /* 820CF8F8h */ case   10:  		/* addi R11, R11, 1 */
		/* 820CF8F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CF8F8h case   10:*/		return 0x820CF8FC;
		  /* 820CF8FCh */ case   11:  		/* addi R10, R10, 1 */
		/* 820CF8FCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CF8FCh case   11:*/		return 0x820CF900;
		  /* 820CF900h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820CF900h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CF900h case   12:*/		return 0x820CF904;
		  /* 820CF904h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820CF904h case   13:*/		if ( regs.CR[6].eq ) { return 0x820CF8E4;  }
		/* 820CF904h case   13:*/		return 0x820CF908;
	}
	return 0x820CF908;
} // Block from 820CF8D0h-820CF908h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CF908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF908);
		  /* 820CF908h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CF908h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CF908h case    0:*/		return 0x820CF90C;
		  /* 820CF90Ch */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 820CF90Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820CF934;  }
		/* 820CF90Ch case    1:*/		return 0x820CF910;
		  /* 820CF910h */ case    2:  		/* lwzu R11, <#[R8 + 8]> */
		/* 820CF910h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820CF910h case    2:*/		return 0x820CF914;
	}
	return 0x820CF914;
} // Block from 820CF908h-820CF914h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CF914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF914);
		  /* 820CF914h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820CF914h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CF914h case    0:*/		return 0x820CF918;
		  /* 820CF918h */ case    1:  		/* bc 4, CR6_EQ, -56 */
		/* 820CF918h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CF8E0;  }
		/* 820CF918h case    1:*/		return 0x820CF91C;
		  /* 820CF91Ch */ case    2:  		/* mr R4, R21 */
		/* 820CF91Ch case    2:*/		regs.R4 = regs.R21;
		/* 820CF91Ch case    2:*/		return 0x820CF920;
		  /* 820CF920h */ case    3:  		/* mtspr CTR, R28 */
		/* 820CF920h case    3:*/		regs.CTR = regs.R28;
		/* 820CF920h case    3:*/		return 0x820CF924;
		  /* 820CF924h */ case    4:  		/* mr R6, R31 */
		/* 820CF924h case    4:*/		regs.R6 = regs.R31;
		/* 820CF924h case    4:*/		return 0x820CF928;
		  /* 820CF928h */ case    5:  		/* mr R3, R27 */
		/* 820CF928h case    5:*/		regs.R3 = regs.R27;
		/* 820CF928h case    5:*/		return 0x820CF92C;
		  /* 820CF92Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820CF92Ch case    6:*/		if ( 1 ) { regs.LR = 0x820CF930; return (uint32)regs.CTR; }
		/* 820CF92Ch case    6:*/		return 0x820CF930;
		  /* 820CF930h */ case    7:  		/* b -512 */
		/* 820CF930h case    7:*/		return 0x820CF730;
		/* 820CF930h case    7:*/		return 0x820CF934;
	}
	return 0x820CF934;
} // Block from 820CF914h-820CF934h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820CF934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF934);
		  /* 820CF934h */ case    0:  		/* lbz R8, <#[R8 + 4]> */
		/* 820CF934h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820CF934h case    0:*/		return 0x820CF938;
		  /* 820CF938h */ case    1:  		/* b -196 */
		/* 820CF938h case    1:*/		return 0x820CF874;
		/* 820CF938h case    1:*/		return 0x820CF93C;
	}
	return 0x820CF93C;
} // Block from 820CF934h-820CF93Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CF93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF93C);
		  /* 820CF93Ch */ case    0:  		/* lwz R30, <#[R1 + 100]> */
		/* 820CF93Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 820CF93Ch case    0:*/		return 0x820CF940;
		  /* 820CF940h */ case    1:  		/* b -204 */
		/* 820CF940h case    1:*/		return 0x820CF874;
		/* 820CF940h case    1:*/		return 0x820CF944;
		  /* 820CF944h */ case    2:  		/* lwz R11, <#[R1 + 128]> */
		/* 820CF944h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820CF944h case    2:*/		return 0x820CF948;
		  /* 820CF948h */ case    3:  		/* addi R10, R8, -1 */
		/* 820CF948h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFFFFF);
		/* 820CF948h case    3:*/		return 0x820CF94C;
		  /* 820CF94Ch */ case    4:  		/* rlwimi R11, R10, 27, 2, 4 */
		/* 820CF94Ch case    4:*/		cpu::op::rlwimi<0,27,2,4>(regs,&regs.R11,regs.R10);
		/* 820CF94Ch case    4:*/		return 0x820CF950;
		  /* 820CF950h */ case    5:  		/* stw R11, <#[R1 + 128]> */
		/* 820CF950h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820CF950h case    5:*/		return 0x820CF954;
		  /* 820CF954h */ case    6:  		/* b -548 */
		/* 820CF954h case    6:*/		return 0x820CF730;
		/* 820CF954h case    6:*/		return 0x820CF958;
		  /* 820CF958h */ case    7:  		/* rlwimi R26, R8, 12, 19, 19 */
		/* 820CF958h case    7:*/		cpu::op::rlwimi<0,12,19,19>(regs,&regs.R26,regs.R8);
		/* 820CF958h case    7:*/		return 0x820CF95C;
		  /* 820CF95Ch */ case    8:  		/* b -556 */
		/* 820CF95Ch case    8:*/		return 0x820CF730;
		/* 820CF95Ch case    8:*/		return 0x820CF960;
		  /* 820CF960h */ case    9:  		/* rlwimi R26, R8, 13, 18, 18 */
		/* 820CF960h case    9:*/		cpu::op::rlwimi<0,13,18,18>(regs,&regs.R26,regs.R8);
		/* 820CF960h case    9:*/		return 0x820CF964;
		  /* 820CF964h */ case   10:  		/* b -564 */
		/* 820CF964h case   10:*/		return 0x820CF730;
		/* 820CF964h case   10:*/		return 0x820CF968;
		  /* 820CF968h */ case   11:  		/* rlwimi R26, R8, 15, 16, 16 */
		/* 820CF968h case   11:*/		cpu::op::rlwimi<0,15,16,16>(regs,&regs.R26,regs.R8);
		/* 820CF968h case   11:*/		return 0x820CF96C;
		  /* 820CF96Ch */ case   12:  		/* b -572 */
		/* 820CF96Ch case   12:*/		return 0x820CF730;
		/* 820CF96Ch case   12:*/		return 0x820CF970;
		  /* 820CF970h */ case   13:  		/* rlwimi R26, R8, 16, 10, 15 */
		/* 820CF970h case   13:*/		cpu::op::rlwimi<0,16,10,15>(regs,&regs.R26,regs.R8);
		/* 820CF970h case   13:*/		return 0x820CF974;
		  /* 820CF974h */ case   14:  		/* b -580 */
		/* 820CF974h case   14:*/		return 0x820CF730;
		/* 820CF974h case   14:*/		return 0x820CF978;
		  /* 820CF978h */ case   15:  		/* rlwimi R26, R30, 24, 2, 7 */
		/* 820CF978h case   15:*/		cpu::op::rlwimi<0,24,2,7>(regs,&regs.R26,regs.R30);
		/* 820CF978h case   15:*/		return 0x820CF97C;
		  /* 820CF97Ch */ case   16:  		/* b -588 */
		/* 820CF97Ch case   16:*/		return 0x820CF730;
		/* 820CF97Ch case   16:*/		return 0x820CF980;
	}
	return 0x820CF980;
} // Block from 820CF93Ch-820CF980h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820CF980h
// Function '?InterpretAsALUMask@CUAssembler@D3DXShader@@IAAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF980);
		  /* 820CF980h */ case    0:  		/* rlwimi R26, R8, 30, 1, 1 */
		/* 820CF980h case    0:*/		cpu::op::rlwimi<0,30,1,1>(regs,&regs.R26,regs.R8);
		/* 820CF980h case    0:*/		return 0x820CF984;
		  /* 820CF984h */ case    1:  		/* b -596 */
		/* 820CF984h case    1:*/		return 0x820CF730;
		/* 820CF984h case    1:*/		return 0x820CF988;
		  /* 820CF988h */ case    2:  		/* lwz R11, <#[R1 + 136]> */
		/* 820CF988h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 820CF988h case    2:*/		return 0x820CF98C;
		  /* 820CF98Ch */ case    3:  		/* rlwimi R11, R8, 0, 24, 31 */
		/* 820CF98Ch case    3:*/		cpu::op::rlwimi<0,0,24,31>(regs,&regs.R11,regs.R8);
		/* 820CF98Ch case    3:*/		return 0x820CF990;
		  /* 820CF990h */ case    4:  		/* stw R11, <#[R1 + 136]> */
		/* 820CF990h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 820CF990h case    4:*/		return 0x820CF994;
		  /* 820CF994h */ case    5:  		/* b -612 */
		/* 820CF994h case    5:*/		return 0x820CF730;
		/* 820CF994h case    5:*/		return 0x820CF998;
		  /* 820CF998h */ case    6:  		/* lwz R11, <#[R1 + 136]> */
		/* 820CF998h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 820CF998h case    6:*/		return 0x820CF99C;
		  /* 820CF99Ch */ case    7:  		/* rlwimi R11, R30, 8, 1, 23 */
		/* 820CF99Ch case    7:*/		cpu::op::rlwimi<0,8,1,23>(regs,&regs.R11,regs.R30);
		/* 820CF99Ch case    7:*/		return 0x820CF9A0;
		  /* 820CF9A0h */ case    8:  		/* b -16 */
		/* 820CF9A0h case    8:*/		return 0x820CF990;
		/* 820CF9A0h case    8:*/		return 0x820CF9A4;
		  /* 820CF9A4h */ case    9:  		/* stw R8, <#[R1 + 108]> */
		/* 820CF9A4h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000006C) );
		/* 820CF9A4h case    9:*/		return 0x820CF9A8;
		  /* 820CF9A8h */ case   10:  		/* b -632 */
		/* 820CF9A8h case   10:*/		return 0x820CF730;
		/* 820CF9A8h case   10:*/		return 0x820CF9AC;
	}
	return 0x820CF9AC;
} // Block from 820CF980h-820CF9ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CF9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF9AC);
		  /* 820CF9ACh */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 820CF9ACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820CF9ACh case    0:*/		return 0x820CF9B0;
		  /* 820CF9B0h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820CF9B0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CF9D0;  }
		/* 820CF9B0h case    1:*/		return 0x820CF9B4;
		  /* 820CF9B4h */ case    2:  		/* rlwinm. R11, R29, 0, 2, 4 */
		/* 820CF9B4h case    2:*/		cpu::op::rlwinm<1,0,2,4>(regs,&regs.R11,regs.R29);
		/* 820CF9B4h case    2:*/		return 0x820CF9B8;
		  /* 820CF9B8h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 820CF9B8h case    3:*/		if ( regs.CR[0].eq ) { return 0x820CF9D0;  }
		/* 820CF9B8h case    3:*/		return 0x820CF9BC;
		  /* 820CF9BCh */ case    4:  		/* lis R11, -32255 */
		/* 820CF9BCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CF9BCh case    4:*/		return 0x820CF9C0;
		  /* 820CF9C0h */ case    5:  		/* mtspr CTR, R28 */
		/* 820CF9C0h case    5:*/		regs.CTR = regs.R28;
		/* 820CF9C0h case    5:*/		return 0x820CF9C4;
		  /* 820CF9C4h */ case    6:  		/* mr R3, R27 */
		/* 820CF9C4h case    6:*/		regs.R3 = regs.R27;
		/* 820CF9C4h case    6:*/		return 0x820CF9C8;
		  /* 820CF9C8h */ case    7:  		/* addi R4, R11, 22400 */
		/* 820CF9C8h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x5780);
		/* 820CF9C8h case    7:*/		return 0x820CF9CC;
		  /* 820CF9CCh */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820CF9CCh case    8:*/		if ( 1 ) { regs.LR = 0x820CF9D0; return (uint32)regs.CTR; }
		/* 820CF9CCh case    8:*/		return 0x820CF9D0;
	}
	return 0x820CF9D0;
} // Block from 820CF9ACh-820CF9D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CF9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF9D0);
		  /* 820CF9D0h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 820CF9D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 820CF9D0h case    0:*/		return 0x820CF9D4;
		  /* 820CF9D4h */ case    1:  		/* lwz R10, <#[R1 + 96]> */
		/* 820CF9D4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820CF9D4h case    1:*/		return 0x820CF9D8;
		  /* 820CF9D8h */ case    2:  		/* stw R29, <#[R31]> */
		/* 820CF9D8h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 820CF9D8h case    2:*/		return 0x820CF9DC;
		  /* 820CF9DCh */ case    3:  		/* stw R26, <#[R31 + 4]> */
		/* 820CF9DCh case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000004) );
		/* 820CF9DCh case    3:*/		return 0x820CF9E0;
		  /* 820CF9E0h */ case    4:  		/* lbz R3, <#[R1 + 80]> */
		/* 820CF9E0h case    4:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820CF9E0h case    4:*/		return 0x820CF9E4;
		  /* 820CF9E4h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 820CF9E4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820CF9E4h case    5:*/		return 0x820CF9E8;
		  /* 820CF9E8h */ case    6:  		/* stw R10, <#[R25]> */
		/* 820CF9E8h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820CF9E8h case    6:*/		return 0x820CF9EC;
		  /* 820CF9ECh */ case    7:  		/* stw R30, <#[R24]> */
		/* 820CF9ECh case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R24 + 0x00000000) );
		/* 820CF9ECh case    7:*/		return 0x820CF9F0;
		  /* 820CF9F0h */ case    8:  		/* addi R1, R1, 304 */
		/* 820CF9F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 820CF9F0h case    8:*/		return 0x820CF9F4;
		  /* 820CF9F4h */ case    9:  		/* b -255876 */
		/* 820CF9F4h case    9:*/		return 0x82091270;
		/* 820CF9F4h case    9:*/		return 0x820CF9F8;
	}
	return 0x820CF9F8;
} // Block from 820CF9D0h-820CF9F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CF9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CF9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CF9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CF9F8);
		  /* 820CF9F8h */ case    0:  		/* mfspr R12, LR */
		/* 820CF9F8h case    0:*/		regs.R12 = regs.LR;
		/* 820CF9F8h case    0:*/		return 0x820CF9FC;
		  /* 820CF9FCh */ case    1:  		/* bl -255964 */
		/* 820CF9FCh case    1:*/		regs.LR = 0x820CFA00; return 0x82091220;
		/* 820CF9FCh case    1:*/		return 0x820CFA00;
	}
	return 0x820CFA00;
} // Block from 820CF9F8h-820CFA00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CFA00h
// Function '?DecodeSwizzle@CUAssembler@D3DXShader@@IAAKPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFA00);
		  /* 820CFA00h */ case    0:  		/* stfd FR31, <#[R1 - 160]> */
		/* 820CFA00h case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820CFA00h case    0:*/		return 0x820CFA04;
		  /* 820CFA04h */ case    1:  		/* stwu R1, <#[R1 - 336]> */
		/* 820CFA04h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEB0);
		/* 820CFA04h case    1:*/		return 0x820CFA08;
		  /* 820CFA08h */ case    2:  		/* addi R9, R1, 152 */
		/* 820CFA08h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x98);
		/* 820CFA08h case    2:*/		return 0x820CFA0C;
		  /* 820CFA0Ch */ case    3:  		/* lwz R10, <#[R3 + 120]> */
		/* 820CFA0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000078) );
		/* 820CFA0Ch case    3:*/		return 0x820CFA10;
		  /* 820CFA10h */ case    4:  		/* li R11, 0 */
		/* 820CFA10h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CFA10h case    4:*/		return 0x820CFA14;
		  /* 820CFA14h */ case    5:  		/* stw R4, <#[R1 + 364]> */
		/* 820CFA14h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000016C) );
		/* 820CFA14h case    5:*/		return 0x820CFA18;
		  /* 820CFA18h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820CFA18h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820CFA18h case    6:*/		return 0x820CFA1C;
		  /* 820CFA1Ch */ case    7:  		/* lwz R23, <#[R3 + 60]> */
		/* 820CFA1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R3 + 0x0000003C) );
		/* 820CFA1Ch case    7:*/		return 0x820CFA20;
		  /* 820CFA20h */ case    8:  		/* stw R11, <#[R1 + 88]> */
		/* 820CFA20h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820CFA20h case    8:*/		return 0x820CFA24;
		  /* 820CFA24h */ case    9:  		/* mr R27, R6 */
		/* 820CFA24h case    9:*/		regs.R27 = regs.R6;
		/* 820CFA24h case    9:*/		return 0x820CFA28;
		  /* 820CFA28h */ case   10:  		/* lwz R8, <#[R3 + 68]> */
		/* 820CFA28h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000044) );
		/* 820CFA28h case   10:*/		return 0x820CFA2C;
		  /* 820CFA2Ch */ case   11:  		/* mr R26, R7 */
		/* 820CFA2Ch case   11:*/		regs.R26 = regs.R7;
		/* 820CFA2Ch case   11:*/		return 0x820CFA30;
		  /* 820CFA30h */ case   12:  		/* std R11, <#[R9]> */
		/* 820CFA30h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820CFA30h case   12:*/		return 0x820CFA34;
		  /* 820CFA34h */ case   13:  		/* stw R11, <#[R9 + 8]> */
		/* 820CFA34h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 820CFA34h case   13:*/		return 0x820CFA38;
		  /* 820CFA38h */ case   14:  		/* stw R10, <#[R1 + 92]> */
		/* 820CFA38h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CFA38h case   14:*/		return 0x820CFA3C;
		  /* 820CFA3Ch */ case   15:  		/* stw R5, <#[R1 + 372]> */
		/* 820CFA3Ch case   15:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000174) );
		/* 820CFA3Ch case   15:*/		return 0x820CFA40;
		  /* 820CFA40h */ case   16:  		/* lwz R10, <#[R1 + 152]> */
		/* 820CFA40h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 820CFA40h case   16:*/		return 0x820CFA44;
		  /* 820CFA44h */ case   17:  		/* lwz R25, <#[R1 + 160]> */
		/* 820CFA44h case   17:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000A0) );
		/* 820CFA44h case   17:*/		return 0x820CFA48;
		  /* 820CFA48h */ case   18:  		/* lwz R11, <#[R1 + 156]> */
		/* 820CFA48h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 820CFA48h case   18:*/		return 0x820CFA4C;
		  /* 820CFA4Ch */ case   19:  		/* oris R21, R11, 7967 */
		/* 820CFA4Ch case   19:*/		cpu::op::oris<0>(regs,&regs.R21,regs.R11,0x1F1F);
		/* 820CFA4Ch case   19:*/		return 0x820CFA50;
		  /* 820CFA50h */ case   20:  		/* oris R10, R10, 8 */
		/* 820CFA50h case   20:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8);
		/* 820CFA50h case   20:*/		return 0x820CFA54;
		  /* 820CFA54h */ case   21:  		/* rlwimi R25, R8, 14, 16, 17 */
		/* 820CFA54h case   21:*/		cpu::op::rlwimi<0,14,16,17>(regs,&regs.R25,regs.R8);
		/* 820CFA54h case   21:*/		return 0x820CFA58;
		  /* 820CFA58h */ case   22:  		/* ori R21, R21, 61440 */
		/* 820CFA58h case   22:*/		cpu::op::ori<0>(regs,&regs.R21,regs.R21,0xF000);
		/* 820CFA58h case   22:*/		return 0x820CFA5C;
		  /* 820CFA5Ch */ case   23:  		/* rlwimi R23, R10, 0, 0, 26 */
		/* 820CFA5Ch case   23:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R23,regs.R10);
		/* 820CFA5Ch case   23:*/		return 0x820CFA60;
		  /* 820CFA60h */ case   24:  		/* bc 12, CR6_EQ, 316 */
		/* 820CFA60h case   24:*/		if ( regs.CR[6].eq ) { return 0x820CFB9C;  }
		/* 820CFA60h case   24:*/		return 0x820CFA64;
		  /* 820CFA64h */ case   25:  		/* lis R9, -32256 */
		/* 820CFA64h case   25:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820CFA64h case   25:*/		return 0x820CFA68;
		  /* 820CFA68h */ case   26:  		/* lis R3, -32255 */
		/* 820CFA68h case   26:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8201);
		/* 820CFA68h case   26:*/		return 0x820CFA6C;
		  /* 820CFA6Ch */ case   27:  		/* lis R30, -32255 */
		/* 820CFA6Ch case   27:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8201);
		/* 820CFA6Ch case   27:*/		return 0x820CFA70;
		  /* 820CFA70h */ case   28:  		/* lis R29, -32255 */
		/* 820CFA70h case   28:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8201);
		/* 820CFA70h case   28:*/		return 0x820CFA74;
		  /* 820CFA74h */ case   29:  		/* lis R11, -32255 */
		/* 820CFA74h case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820CFA74h case   29:*/		return 0x820CFA78;
		  /* 820CFA78h */ case   30:  		/* lfd FR31, <#[R9 + 1848]> */
		/* 820CFA78h case   30:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000738) );
		/* 820CFA78h case   30:*/		return 0x820CFA7C;
		  /* 820CFA7Ch */ case   31:  		/* lis R10, -32255 */
		/* 820CFA7Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CFA7Ch case   31:*/		return 0x820CFA80;
		  /* 820CFA80h */ case   32:  		/* lis R9, -32255 */
		/* 820CFA80h case   32:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820CFA80h case   32:*/		return 0x820CFA84;
		  /* 820CFA84h */ case   33:  		/* lis R8, -32255 */
		/* 820CFA84h case   33:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820CFA84h case   33:*/		return 0x820CFA88;
		  /* 820CFA88h */ case   34:  		/* lis R7, -32255 */
		/* 820CFA88h case   34:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820CFA88h case   34:*/		return 0x820CFA8C;
		  /* 820CFA8Ch */ case   35:  		/* lis R6, -32255 */
		/* 820CFA8Ch case   35:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820CFA8Ch case   35:*/		return 0x820CFA90;
		  /* 820CFA90h */ case   36:  		/* lis R5, -32255 */
		/* 820CFA90h case   36:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820CFA90h case   36:*/		return 0x820CFA94;
		  /* 820CFA94h */ case   37:  		/* lis R4, -32255 */
		/* 820CFA94h case   37:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 820CFA94h case   37:*/		return 0x820CFA98;
		  /* 820CFA98h */ case   38:  		/* lis R31, -32255 */
		/* 820CFA98h case   38:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820CFA98h case   38:*/		return 0x820CFA9C;
		  /* 820CFA9Ch */ case   39:  		/* lis R28, -32217 */
		/* 820CFA9Ch case   39:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8227);
		/* 820CFA9Ch case   39:*/		return 0x820CFAA0;
		  /* 820CFAA0h */ case   40:  		/* addi R3, R3, 23300 */
		/* 820CFAA0h case   40:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x5B04);
		/* 820CFAA0h case   40:*/		return 0x820CFAA4;
		  /* 820CFAA4h */ case   41:  		/* addi R30, R30, 22788 */
		/* 820CFAA4h case   41:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x5904);
		/* 820CFAA4h case   41:*/		return 0x820CFAA8;
		  /* 820CFAA8h */ case   42:  		/* addi R29, R29, 22752 */
		/* 820CFAA8h case   42:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x58E0);
		/* 820CFAA8h case   42:*/		return 0x820CFAAC;
		  /* 820CFAACh */ case   43:  		/* stw R3, <#[R1 + 104]> */
		/* 820CFAACh case   43:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 820CFAACh case   43:*/		return 0x820CFAB0;
		  /* 820CFAB0h */ case   44:  		/* addi R11, R11, 22976 */
		/* 820CFAB0h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x59C0);
		/* 820CFAB0h case   44:*/		return 0x820CFAB4;
		  /* 820CFAB4h */ case   45:  		/* stw R30, <#[R1 + 108]> */
		/* 820CFAB4h case   45:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 820CFAB4h case   45:*/		return 0x820CFAB8;
		  /* 820CFAB8h */ case   46:  		/* addi R24, R10, 22352 */
		/* 820CFAB8h case   46:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x5750);
		/* 820CFAB8h case   46:*/		return 0x820CFABC;
		  /* 820CFABCh */ case   47:  		/* stw R29, <#[R1 + 100]> */
		/* 820CFABCh case   47:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820CFABCh case   47:*/		return 0x820CFAC0;
		  /* 820CFAC0h */ case   48:  		/* addi R18, R9, 22952 */
		/* 820CFAC0h case   48:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R9,0x59A8);
		/* 820CFAC0h case   48:*/		return 0x820CFAC4;
		  /* 820CFAC4h */ case   49:  		/* stw R11, <#[R1 + 96]> */
		/* 820CFAC4h case   49:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820CFAC4h case   49:*/		return 0x820CFAC8;
		  /* 820CFAC8h */ case   50:  		/* addi R17, R8, 23256 */
		/* 820CFAC8h case   50:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R8,0x5AD8);
		/* 820CFAC8h case   50:*/		return 0x820CFACC;
		  /* 820CFACCh */ case   51:  		/* addi R16, R7, 23152 */
		/* 820CFACCh case   51:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R7,0x5A70);
		/* 820CFACCh case   51:*/		return 0x820CFAD0;
		  /* 820CFAD0h */ case   52:  		/* addi R15, R6, 23096 */
		/* 820CFAD0h case   52:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R6,0x5A38);
		/* 820CFAD0h case   52:*/		return 0x820CFAD4;
		  /* 820CFAD4h */ case   53:  		/* addi R14, R5, 23064 */
		/* 820CFAD4h case   53:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R5,0x5A18);
		/* 820CFAD4h case   53:*/		return 0x820CFAD8;
		  /* 820CFAD8h */ case   54:  		/* addi R20, R4, 23012 */
		/* 820CFAD8h case   54:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R4,0x59E4);
		/* 820CFAD8h case   54:*/		return 0x820CFADC;
		  /* 820CFADCh */ case   55:  		/* addi R19, R31, 22828 */
		/* 820CFADCh case   55:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R31,0x592C);
		/* 820CFADCh case   55:*/		return 0x820CFAE0;
		  /* 820CFAE0h */ case   56:  		/* addi R22, R28, 12296 */
		/* 820CFAE0h case   56:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R28,0x3008);
		/* 820CFAE0h case   56:*/		return 0x820CFAE4;
		  /* 820CFAE4h */ case   57:  		/* lwz R11, <#[R1 + 92]> */
		/* 820CFAE4h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CFAE4h case   57:*/		return 0x820CFAE8;
		  /* 820CFAE8h */ case   58:  		/* lwz R10, <#[R11 + 8]> */
		/* 820CFAE8h case   58:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820CFAE8h case   58:*/		return 0x820CFAEC;
		  /* 820CFAECh */ case   59:  		/* lwz R9, <#[R11 + 12]> */
		/* 820CFAECh case   59:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 820CFAECh case   59:*/		return 0x820CFAF0;
		  /* 820CFAF0h */ case   60:  		/* lwz R8, <#[R10 + 8]> */
		/* 820CFAF0h case   60:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820CFAF0h case   60:*/		return 0x820CFAF4;
		  /* 820CFAF4h */ case   61:  		/* lwz R11, <#[R10 + 12]> */
		/* 820CFAF4h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820CFAF4h case   61:*/		return 0x820CFAF8;
		  /* 820CFAF8h */ case   62:  		/* stw R9, <#[R1 + 92]> */
		/* 820CFAF8h case   62:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CFAF8h case   62:*/		return 0x820CFAFC;
		  /* 820CFAFCh */ case   63:  		/* cmplwi CR6, R11, 0 */
		/* 820CFAFCh case   63:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CFAFCh case   63:*/		return 0x820CFB00;
		  /* 820CFB00h */ case   64:  		/* lwz R28, <#[R8 + 24]> */
		/* 820CFB00h case   64:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R8 + 0x00000018) );
		/* 820CFB00h case   64:*/		return 0x820CFB04;
		  /* 820CFB04h */ case   65:  		/* bc 4, CR6_EQ, 12 */
		/* 820CFB04h case   65:*/		if ( !regs.CR[6].eq ) { return 0x820CFB10;  }
		/* 820CFB04h case   65:*/		return 0x820CFB08;
		  /* 820CFB08h */ case   66:  		/* lwz R4, <#[R1 + 96]> */
		/* 820CFB08h case   66:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 820CFB08h case   66:*/		return 0x820CFB0C;
		  /* 820CFB0Ch */ case   67:  		/* b 116 */
		/* 820CFB0Ch case   67:*/		return 0x820CFB80;
		/* 820CFB0Ch case   67:*/		return 0x820CFB10;
	}
	return 0x820CFB10;
} // Block from 820CFA00h-820CFB10h (68 instructions)

//////////////////////////////////////////////////////
// Block at 820CFB10h
// Function '?ConvertSwizzleToScalarForm@D3DXShader@@YAKPAVCNodeUAsmInstruction@1@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFB10);
		  /* 820CFB10h */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 820CFB10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820CFB10h case    0:*/		return 0x820CFB14;
		  /* 820CFB14h */ case    1:  		/* cmpwi CR6, R10, 3 */
		/* 820CFB14h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 820CFB14h case    1:*/		return 0x820CFB18;
		  /* 820CFB18h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820CFB18h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CFB2C;  }
		/* 820CFB18h case    2:*/		return 0x820CFB1C;
		  /* 820CFB1Ch */ case    3:  		/* lwz R11, <#[R1 + 372]> */
		/* 820CFB1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000174) );
		/* 820CFB1Ch case    3:*/		return 0x820CFB20;
		  /* 820CFB20h */ case    4:  		/* li R10, 1 */
		/* 820CFB20h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820CFB20h case    4:*/		return 0x820CFB24;
		  /* 820CFB24h */ case    5:  		/* stb R10, <#[R11]> */
		/* 820CFB24h case    5:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820CFB24h case    5:*/		return 0x820CFB28;
		  /* 820CFB28h */ case    6:  		/* b 104 */
		/* 820CFB28h case    6:*/		return 0x820CFB90;
		/* 820CFB28h case    6:*/		return 0x820CFB2C;
	}
	return 0x820CFB2C;
} // Block from 820CFB10h-820CFB2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CFB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFB2C);
		  /* 820CFB2Ch */ case    0:  		/* mr R30, R22 */
		/* 820CFB2Ch case    0:*/		regs.R30 = regs.R22;
		/* 820CFB2Ch case    0:*/		return 0x820CFB30;
		  /* 820CFB30h */ case    1:  		/* addi R3, R11, 16 */
		/* 820CFB30h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 820CFB30h case    1:*/		return 0x820CFB34;
		  /* 820CFB34h */ case    2:  		/* li R8, 0 */
		/* 820CFB34h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820CFB34h case    2:*/		return 0x820CFB38;
		  /* 820CFB38h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 820CFB38h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820CFB38h case    3:*/		return 0x820CFB3C;
		  /* 820CFB3Ch */ case    4:  		/* mr R10, R28 */
		/* 820CFB3Ch case    4:*/		regs.R10 = regs.R28;
		/* 820CFB3Ch case    4:*/		return 0x820CFB40;
		  /* 820CFB40h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820CFB40h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CFB40h case    5:*/		return 0x820CFB44;
		  /* 820CFB44h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820CFB44h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CFB44h case    6:*/		return 0x820CFB48;
		  /* 820CFB48h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820CFB48h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CFB48h case    7:*/		return 0x820CFB4C;
		  /* 820CFB4Ch */ case    8:  		/* subf R9, R7, R9 */
		/* 820CFB4Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CFB4Ch case    8:*/		return 0x820CFB50;
		  /* 820CFB50h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820CFB50h case    9:*/		if ( regs.CR[0].eq ) { return 0x820CFB64;  }
		/* 820CFB50h case    9:*/		return 0x820CFB54;
		  /* 820CFB54h */ case   10:  		/* addi R11, R11, 1 */
		/* 820CFB54h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CFB54h case   10:*/		return 0x820CFB58;
		  /* 820CFB58h */ case   11:  		/* addi R10, R10, 1 */
		/* 820CFB58h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CFB58h case   11:*/		return 0x820CFB5C;
		  /* 820CFB5Ch */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820CFB5Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CFB5Ch case   12:*/		return 0x820CFB60;
		  /* 820CFB60h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820CFB60h case   13:*/		if ( regs.CR[6].eq ) { return 0x820CFB40;  }
		/* 820CFB60h case   13:*/		return 0x820CFB64;
	}
	return 0x820CFB64;
} // Block from 820CFB2Ch-820CFB64h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CFB64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFB64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFB64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFB64);
		  /* 820CFB64h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CFB64h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CFB64h case    0:*/		return 0x820CFB68;
		  /* 820CFB68h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 820CFB68h case    1:*/		if ( regs.CR[0].eq ) { return 0x820CFBB8;  }
		/* 820CFB68h case    1:*/		return 0x820CFB6C;
		  /* 820CFB6Ch */ case    2:  		/* addi R8, R8, 12 */
		/* 820CFB6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xC);
		/* 820CFB6Ch case    2:*/		return 0x820CFB70;
		  /* 820CFB70h */ case    3:  		/* addi R30, R30, 12 */
		/* 820CFB70h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xC);
		/* 820CFB70h case    3:*/		return 0x820CFB74;
		  /* 820CFB74h */ case    4:  		/* cmplwi CR6, R8, 180 */
		/* 820CFB74h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x000000B4);
		/* 820CFB74h case    4:*/		return 0x820CFB78;
		  /* 820CFB78h */ case    5:  		/* bc 12, CR6_LT, -64 */
		/* 820CFB78h case    5:*/		if ( regs.CR[6].lt ) { return 0x820CFB38;  }
		/* 820CFB78h case    5:*/		return 0x820CFB7C;
		  /* 820CFB7Ch */ case    6:  		/* mr R4, R18 */
		/* 820CFB7Ch case    6:*/		regs.R4 = regs.R18;
		/* 820CFB7Ch case    6:*/		return 0x820CFB80;
	}
	return 0x820CFB80;
} // Block from 820CFB64h-820CFB80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CFB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFB80);
		  /* 820CFB80h */ case    0:  		/* mr R5, R28 */
		/* 820CFB80h case    0:*/		regs.R5 = regs.R28;
		/* 820CFB80h case    0:*/		return 0x820CFB84;
		  /* 820CFB84h */ case    1:  		/* mtspr CTR, R27 */
		/* 820CFB84h case    1:*/		regs.CTR = regs.R27;
		/* 820CFB84h case    1:*/		return 0x820CFB88;
		  /* 820CFB88h */ case    2:  		/* mr R3, R26 */
		/* 820CFB88h case    2:*/		regs.R3 = regs.R26;
		/* 820CFB88h case    2:*/		return 0x820CFB8C;
		  /* 820CFB8Ch */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820CFB8Ch case    3:*/		if ( 1 ) { regs.LR = 0x820CFB90; return (uint32)regs.CTR; }
		/* 820CFB8Ch case    3:*/		return 0x820CFB90;
	}
	return 0x820CFB90;
} // Block from 820CFB80h-820CFB90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CFB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFB90);
		  /* 820CFB90h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 820CFB90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820CFB90h case    0:*/		return 0x820CFB94;
		  /* 820CFB94h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CFB94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CFB94h case    1:*/		return 0x820CFB98;
		  /* 820CFB98h */ case    2:  		/* bc 4, CR6_EQ, -180 */
		/* 820CFB98h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CFAE4;  }
		/* 820CFB98h case    2:*/		return 0x820CFB9C;
	}
	return 0x820CFB9C;
} // Block from 820CFB90h-820CFB9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CFB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFB9C);
		  /* 820CFB9Ch */ case    0:  		/* lwz R11, <#[R1 + 364]> */
		/* 820CFB9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000016C) );
		/* 820CFB9Ch case    0:*/		return 0x820CFBA0;
		  /* 820CFBA0h */ case    1:  		/* stw R23, <#[R11]> */
		/* 820CFBA0h case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 820CFBA0h case    1:*/		return 0x820CFBA4;
		  /* 820CFBA4h */ case    2:  		/* stw R21, <#[R11 + 4]> */
		/* 820CFBA4h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000004) );
		/* 820CFBA4h case    2:*/		return 0x820CFBA8;
		  /* 820CFBA8h */ case    3:  		/* stw R25, <#[R11 + 8]> */
		/* 820CFBA8h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000008) );
		/* 820CFBA8h case    3:*/		return 0x820CFBAC;
		  /* 820CFBACh */ case    4:  		/* addi R1, R1, 336 */
		/* 820CFBACh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x150);
		/* 820CFBACh case    4:*/		return 0x820CFBB0;
		  /* 820CFBB0h */ case    5:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820CFBB0h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820CFBB0h case    5:*/		return 0x820CFBB4;
		  /* 820CFBB4h */ case    6:  		/* b -256324 */
		/* 820CFBB4h case    6:*/		return 0x82091270;
		/* 820CFBB4h case    6:*/		return 0x820CFBB8;
	}
	return 0x820CFBB8;
} // Block from 820CFB9Ch-820CFBB8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CFBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFBB8);
		  /* 820CFBB8h */ case    0:  		/* lbz R11, <#[R30 + 4]> */
		/* 820CFBB8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820CFBB8h case    0:*/		return 0x820CFBBC;
		  /* 820CFBBCh */ case    1:  		/* li R10, 1 */
		/* 820CFBBCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820CFBBCh case    1:*/		return 0x820CFBC0;
		  /* 820CFBC0h */ case    2:  		/* lwz R9, <#[R1 + 88]> */
		/* 820CFBC0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 820CFBC0h case    2:*/		return 0x820CFBC4;
		  /* 820CFBC4h */ case    3:  		/* slw R10, R10, R11 */
		/* 820CFBC4h case    3:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820CFBC4h case    3:*/		return 0x820CFBC8;
	}
	return 0x820CFBC8;
} // Block from 820CFBB8h-820CFBC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CFBC8h
// Function '?MicrocodeReoptimizerErrorCallback@D3DXShader@@YAXPAXHKPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFBC8);
		  /* 820CFBC8h */ case    0:  		/* and. R11, R10, R9 */
		/* 820CFBC8h case    0:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R9);
		/* 820CFBC8h case    0:*/		return 0x820CFBCC;
		  /* 820CFBCCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820CFBCCh case    1:*/		if ( regs.CR[0].eq ) { return 0x820CFBD8;  }
		/* 820CFBCCh case    1:*/		return 0x820CFBD0;
		  /* 820CFBD0h */ case    2:  		/* lwz R4, <#[R1 + 100]> */
		/* 820CFBD0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 820CFBD0h case    2:*/		return 0x820CFBD4;
		  /* 820CFBD4h */ case    3:  		/* b -84 */
		/* 820CFBD4h case    3:*/		return 0x820CFB80;
		/* 820CFBD4h case    3:*/		return 0x820CFBD8;
	}
	return 0x820CFBD8;
} // Block from 820CFBC8h-820CFBD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CFBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFBD8);
		  /* 820CFBD8h */ case    0:  		/* lwz R9, <#[R1 + 88]> */
		/* 820CFBD8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 820CFBD8h case    0:*/		return 0x820CFBDC;
		  /* 820CFBDCh */ case    1:  		/* li R29, 0 */
		/* 820CFBDCh case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820CFBDCh case    1:*/		return 0x820CFBE0;
		  /* 820CFBE0h */ case    2:  		/* lbz R11, <#[R30 + 5]> */
		/* 820CFBE0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000005) );
		/* 820CFBE0h case    2:*/		return 0x820CFBE4;
		  /* 820CFBE4h */ case    3:  		/* li R31, 0 */
		/* 820CFBE4h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CFBE4h case    3:*/		return 0x820CFBE8;
		  /* 820CFBE8h */ case    4:  		/* or R10, R10, R9 */
		/* 820CFBE8h case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820CFBE8h case    4:*/		return 0x820CFBEC;
		  /* 820CFBECh */ case    5:  		/* stw R29, <#[R1 + 80]> */
		/* 820CFBECh case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820CFBECh case    5:*/		return 0x820CFBF0;
		  /* 820CFBF0h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 820CFBF0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820CFBF0h case    6:*/		return 0x820CFBF4;
		  /* 820CFBF4h */ case    7:  		/* stw R10, <#[R1 + 88]> */
		/* 820CFBF4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820CFBF4h case    7:*/		return 0x820CFBF8;
		  /* 820CFBF8h */ case    8:  		/* bc 12, CR6_LT, 500 */
		/* 820CFBF8h case    8:*/		if ( regs.CR[6].lt ) { return 0x820CFDEC;  }
		/* 820CFBF8h case    8:*/		return 0x820CFBFC;
		  /* 820CFBFCh */ case    9:  		/* bc 12, CR6_EQ, 472 */
		/* 820CFBFCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820CFDD4;  }
		/* 820CFBFCh case    9:*/		return 0x820CFC00;
	}
	return 0x820CFC00;
} // Block from 820CFBD8h-820CFC00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC00h
// Function '?GetParseTree@CUAssembler@D3DXShader@@QAAJPAPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC00);
		  /* 820CFC00h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820CFC00h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820CFC00h case    0:*/		return 0x820CFC04;
		  /* 820CFC04h */ case    1:  		/* bc 12, CR6_LT, 408 */
		/* 820CFC04h case    1:*/		if ( regs.CR[6].lt ) { return 0x820CFD9C;  }
		/* 820CFC04h case    1:*/		return 0x820CFC08;
		  /* 820CFC08h */ case    2:  		/* cmplwi CR6, R11, 4 */
		/* 820CFC08h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820CFC08h case    2:*/		return 0x820CFC0C;
		  /* 820CFC0Ch */ case    3:  		/* bc 4, CR6_EQ, 612 */
		/* 820CFC0Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820CFE70;  }
		/* 820CFC0Ch case    3:*/		return 0x820CFC10;
		  /* 820CFC10h */ case    4:  		/* lwz R11, <#[R30 + 8]> */
		/* 820CFC10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820CFC10h case    4:*/		return 0x820CFC14;
		  /* 820CFC14h */ case    5:  		/* li R10, 0 */
		/* 820CFC14h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820CFC14h case    5:*/		return 0x820CFC18;
		  /* 820CFC18h */ case    6:  		/* li R9, 0 */
		/* 820CFC18h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820CFC18h case    6:*/		return 0x820CFC1C;
		  /* 820CFC1Ch */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 820CFC1Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820CFC1Ch case    7:*/		return 0x820CFC20;
		  /* 820CFC20h */ case    8:  		/* bc 12, CR6_LT, 20 */
		/* 820CFC20h case    8:*/		if ( regs.CR[6].lt ) { return 0x820CFC34;  }
		/* 820CFC20h case    8:*/		return 0x820CFC24;
		  /* 820CFC24h */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 820CFC24h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820CFC3C;  }
		/* 820CFC24h case    9:*/		return 0x820CFC28;
		  /* 820CFC28h */ case   10:  		/* li R10, 15 */
		/* 820CFC28h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0xF);
		/* 820CFC28h case   10:*/		return 0x820CFC2C;
		  /* 820CFC2Ch */ case   11:  		/* li R9, 1 */
		/* 820CFC2Ch case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820CFC2Ch case   11:*/		return 0x820CFC30;
		  /* 820CFC30h */ case   12:  		/* b 12 */
		/* 820CFC30h case   12:*/		return 0x820CFC3C;
		/* 820CFC30h case   12:*/		return 0x820CFC34;
	}
	return 0x820CFC34;
} // Block from 820CFC00h-820CFC34h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC34);
		  /* 820CFC34h */ case    0:  		/* li R10, 63 */
		/* 820CFC34h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3F);
		/* 820CFC34h case    0:*/		return 0x820CFC38;
		  /* 820CFC38h */ case    1:  		/* li R9, 4 */
		/* 820CFC38h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820CFC38h case    1:*/		return 0x820CFC3C;
	}
	return 0x820CFC3C;
} // Block from 820CFC34h-820CFC3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC3C);
		  /* 820CFC3Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820CFC3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CFC3Ch case    0:*/		return 0x820CFC40;
		  /* 820CFC40h */ case    1:  		/* cmpwi CR6, R11, 2 */
		/* 820CFC40h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820CFC40h case    1:*/		return 0x820CFC44;
		  /* 820CFC44h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CFC44h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CFC68;  }
		/* 820CFC44h case    2:*/		return 0x820CFC48;
		  /* 820CFC48h */ case    3:  		/* cmpwi CR6, R11, 4 */
		/* 820CFC48h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820CFC48h case    3:*/		return 0x820CFC4C;
		  /* 820CFC4Ch */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820CFC4Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820CFC68;  }
		/* 820CFC4Ch case    4:*/		return 0x820CFC50;
		  /* 820CFC50h */ case    5:  		/* cmpwi CR6, R11, 6 */
		/* 820CFC50h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820CFC50h case    5:*/		return 0x820CFC54;
		  /* 820CFC54h */ case    6:  		/* bc 4, CR6_GT, 24 */
		/* 820CFC54h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820CFC6C;  }
		/* 820CFC54h case    6:*/		return 0x820CFC58;
		  /* 820CFC58h */ case    7:  		/* cmpwi CR6, R11, 10 */
		/* 820CFC58h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820CFC58h case    7:*/		return 0x820CFC5C;
		  /* 820CFC5Ch */ case    8:  		/* bc 12, CR6_GT, 16 */
		/* 820CFC5Ch case    8:*/		if ( regs.CR[6].gt ) { return 0x820CFC6C;  }
		/* 820CFC5Ch case    8:*/		return 0x820CFC60;
		  /* 820CFC60h */ case    9:  		/* lfd FR0, <#[R3 + 8]> */
		/* 820CFC60h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000008) );
		/* 820CFC60h case    9:*/		return 0x820CFC64;
		  /* 820CFC64h */ case   10:  		/* b 72 */
		/* 820CFC64h case   10:*/		return 0x820CFCAC;
		/* 820CFC64h case   10:*/		return 0x820CFC68;
	}
	return 0x820CFC68;
} // Block from 820CFC3Ch-820CFC68h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC68);
		  /* 820CFC68h */ case    0:  		/* li R11, 2 */
		/* 820CFC68h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820CFC68h case    0:*/		return 0x820CFC6C;
	}
	return 0x820CFC6C;
} // Block from 820CFC68h-820CFC6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC6C);
		  /* 820CFC6Ch */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820CFC6Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820CFC6Ch case    0:*/		return 0x820CFC70;
	}
	return 0x820CFC70;
} // Block from 820CFC6Ch-820CFC70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC70h
// Function '??_GCNodeUAsmLabel@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC70);
		  /* 820CFC70h */ case    0:  		/* bc 12, CR6_EQ, 44 */
		/* 820CFC70h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CFC9C;  }
		/* 820CFC70h case    0:*/		return 0x820CFC74;
		  /* 820CFC74h */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 820CFC74h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820CFC74h case    1:*/		return 0x820CFC78;
		  /* 820CFC78h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820CFC78h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CFC8C;  }
		/* 820CFC78h case    2:*/		return 0x820CFC7C;
		  /* 820CFC7Ch */ case    3:  		/* cmpwi CR6, R11, 7 */
		/* 820CFC7Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 820CFC7Ch case    3:*/		return 0x820CFC80;
	}
	return 0x820CFC80;
} // Block from 820CFC70h-820CFC80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC80h
// Function '?OutputLine@ValidatorOutputCallbackContext@D3DXShader@@QAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC80);
		  /* 820CFC80h */ case    0:  		/* bc 12, CR6_EQ, -32 */
		/* 820CFC80h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CFC60;  }
		/* 820CFC80h case    0:*/		return 0x820CFC84;
		  /* 820CFC84h */ case    1:  		/* mr R4, R14 */
		/* 820CFC84h case    1:*/		regs.R4 = regs.R14;
		/* 820CFC84h case    1:*/		return 0x820CFC88;
		  /* 820CFC88h */ case    2:  		/* b -264 */
		/* 820CFC88h case    2:*/		return 0x820CFB80;
		/* 820CFC88h case    2:*/		return 0x820CFC8C;
	}
	return 0x820CFC8C;
} // Block from 820CFC80h-820CFC8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC8C);
		  /* 820CFC8Ch */ case    0:  		/* lwa R11, <#[R3 + 8]> */
		/* 820CFC8Ch case    0:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CFC8Ch case    0:*/		return 0x820CFC90;
		  /* 820CFC90h */ case    1:  		/* std R11, <#[R1 + 112]> */
		/* 820CFC90h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820CFC90h case    1:*/		return 0x820CFC94;
		  /* 820CFC94h */ case    2:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820CFC94h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820CFC94h case    2:*/		return 0x820CFC98;
		  /* 820CFC98h */ case    3:  		/* b 16 */
		/* 820CFC98h case    3:*/		return 0x820CFCA8;
		/* 820CFC98h case    3:*/		return 0x820CFC9C;
	}
	return 0x820CFC9C;
} // Block from 820CFC8Ch-820CFC9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CFC9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFC9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFC9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFC9C);
		  /* 820CFC9Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 820CFC9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CFC9Ch case    0:*/		return 0x820CFCA0;
		  /* 820CFCA0h */ case    1:  		/* std R11, <#[R1 + 120]> */
		/* 820CFCA0h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820CFCA0h case    1:*/		return 0x820CFCA4;
		  /* 820CFCA4h */ case    2:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820CFCA4h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820CFCA4h case    2:*/		return 0x820CFCA8;
	}
	return 0x820CFCA8;
} // Block from 820CFC9Ch-820CFCA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CFCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFCA8);
		  /* 820CFCA8h */ case    0:  		/* fcfid FR0, FR0 */
		/* 820CFCA8h case    0:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820CFCA8h case    0:*/		return 0x820CFCAC;
	}
	return 0x820CFCAC;
} // Block from 820CFCA8h-820CFCACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CFCACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFCAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFCAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFCAC);
		  /* 820CFCACh */ case    0:  		/* addi R11, R10, 1 */
		/* 820CFCACh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 820CFCACh case    0:*/		return 0x820CFCB0;
		  /* 820CFCB0h */ case    1:  		/* frsp FR1, FR0 */
		/* 820CFCB0h case    1:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR0);
		/* 820CFCB0h case    1:*/		return 0x820CFCB4;
		  /* 820CFCB4h */ case    2:  		/* li R8, 1 */
		/* 820CFCB4h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820CFCB4h case    2:*/		return 0x820CFCB8;
		  /* 820CFCB8h */ case    3:  		/* extsw R11, R11 */
		/* 820CFCB8h case    3:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 820CFCB8h case    3:*/		return 0x820CFCBC;
		  /* 820CFCBCh */ case    4:  		/* extsw R10, R10 */
		/* 820CFCBCh case    4:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R10);
		/* 820CFCBCh case    4:*/		return 0x820CFCC0;
		  /* 820CFCC0h */ case    5:  		/* std R10, <#[R1 + 136]> */
		/* 820CFCC0h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 820CFCC0h case    5:*/		return 0x820CFCC4;
		  /* 820CFCC4h */ case    6:  		/* std R11, <#[R1 + 128]> */
		/* 820CFCC4h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820CFCC4h case    6:*/		return 0x820CFCC8;
		  /* 820CFCC8h */ case    7:  		/* slw R11, R8, R9 */
		/* 820CFCC8h case    7:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 820CFCC8h case    7:*/		return 0x820CFCCC;
		  /* 820CFCCCh */ case    8:  		/* extsw R11, R11 */
		/* 820CFCCCh case    8:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 820CFCCCh case    8:*/		return 0x820CFCD0;
		  /* 820CFCD0h */ case    9:  		/* std R11, <#[R1 + 144]> */
		/* 820CFCD0h case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 820CFCD0h case    9:*/		return 0x820CFCD4;
		  /* 820CFCD4h */ case   10:  		/* lfd FR0, <#[R1 + 144]> */
		/* 820CFCD4h case   10:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000090) );
		/* 820CFCD4h case   10:*/		return 0x820CFCD8;
		  /* 820CFCD8h */ case   11:  		/* fcfid FR13, FR0 */
		/* 820CFCD8h case   11:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR0);
		/* 820CFCD8h case   11:*/		return 0x820CFCDC;
		  /* 820CFCDCh */ case   12:  		/* lfd FR11, <#[R1 + 136]> */
		/* 820CFCDCh case   12:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000088) );
		/* 820CFCDCh case   12:*/		return 0x820CFCE0;
		  /* 820CFCE0h */ case   13:  		/* lfd FR12, <#[R1 + 128]> */
		/* 820CFCE0h case   13:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000080) );
		/* 820CFCE0h case   13:*/		return 0x820CFCE4;
		  /* 820CFCE4h */ case   14:  		/* fdiv FR0, FR31, FR13 */
		/* 820CFCE4h case   14:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR31,regs.FR13);
		/* 820CFCE4h case   14:*/		return 0x820CFCE8;
		  /* 820CFCE8h */ case   15:  		/* fcfid FR12, FR12 */
		/* 820CFCE8h case   15:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 820CFCE8h case   15:*/		return 0x820CFCEC;
		  /* 820CFCECh */ case   16:  		/* fcfid FR11, FR11 */
		/* 820CFCECh case   16:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 820CFCECh case   16:*/		return 0x820CFCF0;
		  /* 820CFCF0h */ case   17:  		/* fmul FR12, FR12, FR0 */
		/* 820CFCF0h case   17:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR12,regs.FR0);
		/* 820CFCF0h case   17:*/		return 0x820CFCF4;
		  /* 820CFCF4h */ case   18:  		/* fmul FR3, FR11, FR0 */
		/* 820CFCF4h case   18:*/		cpu::op::fmul<0>(regs,&regs.FR3,regs.FR11,regs.FR0);
		/* 820CFCF4h case   18:*/		return 0x820CFCF8;
	}
	return 0x820CFCF8;
} // Block from 820CFCACh-820CFCF8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820CFCF8h
// Function '?ValidatorOutput@ValidatorOutputCallbackContext@D3DXShader@@QAAJPBDK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFCF8);
		  /* 820CFCF8h */ case    0:  		/* fneg FR2, FR12 */
		/* 820CFCF8h case    0:*/		cpu::op::fneg<0>(regs,&regs.FR2,regs.FR12);
		/* 820CFCF8h case    0:*/		return 0x820CFCFC;
		  /* 820CFCFCh */ case    1:  		/* fcmpu CR6, FR1, FR2 */
		/* 820CFCFCh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR2);
		/* 820CFCFCh case    1:*/		return 0x820CFD00;
		  /* 820CFD00h */ case    2:  		/* bc 12, CR6_LT, 108 */
		/* 820CFD00h case    2:*/		if ( regs.CR[6].lt ) { return 0x820CFD6C;  }
		/* 820CFD00h case    2:*/		return 0x820CFD04;
		  /* 820CFD04h */ case    3:  		/* fcmpu CR6, FR1, FR3 */
		/* 820CFD04h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR3);
		/* 820CFD04h case    3:*/		return 0x820CFD08;
		  /* 820CFD08h */ case    4:  		/* bc 12, CR6_GT, 100 */
		/* 820CFD08h case    4:*/		if ( regs.CR[6].gt ) { return 0x820CFD6C;  }
		/* 820CFD08h case    4:*/		return 0x820CFD0C;
		  /* 820CFD0Ch */ case    5:  		/* fmul FR12, FR13, FR1 */
		/* 820CFD0Ch case    5:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR13,regs.FR1);
		/* 820CFD0Ch case    5:*/		return 0x820CFD10;
		  /* 820CFD10h */ case    6:  		/* fctiwz FR13, FR12 */
		/* 820CFD10h case    6:*/		cpu::op::fctiwz<0>(regs,&regs.FR13,regs.FR12);
		/* 820CFD10h case    6:*/		return 0x820CFD14;
		  /* 820CFD14h */ case    7:  		/* stfd FR13, <#[R1 + 80]> */
		/* 820CFD14h case    7:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820CFD14h case    7:*/		return 0x820CFD18;
		  /* 820CFD18h */ case    8:  		/* lwz R31, <#[R1 + 84]> */
		/* 820CFD18h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820CFD18h case    8:*/		return 0x820CFD1C;
		  /* 820CFD1Ch */ case    9:  		/* extsw R11, R31 */
		/* 820CFD1Ch case    9:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R31);
		/* 820CFD1Ch case    9:*/		return 0x820CFD20;
		  /* 820CFD20h */ case   10:  		/* std R11, <#[R1 + 152]> */
		/* 820CFD20h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 820CFD20h case   10:*/		return 0x820CFD24;
		  /* 820CFD24h */ case   11:  		/* lfd FR13, <#[R1 + 152]> */
		/* 820CFD24h case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000098) );
		/* 820CFD24h case   11:*/		return 0x820CFD28;
		  /* 820CFD28h */ case   12:  		/* fcfid FR13, FR13 */
		/* 820CFD28h case   12:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820CFD28h case   12:*/		return 0x820CFD2C;
		  /* 820CFD2Ch */ case   13:  		/* fcmpu CR6, FR13, FR12 */
		/* 820CFD2Ch case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR12);
		/* 820CFD2Ch case   13:*/		return 0x820CFD30;
		  /* 820CFD30h */ case   14:  		/* bc 12, CR6_EQ, 320 */
		/* 820CFD30h case   14:*/		if ( regs.CR[6].eq ) { return 0x820CFE70;  }
		/* 820CFD30h case   14:*/		return 0x820CFD34;
		  /* 820CFD34h */ case   15:  		/* fmul FR2, FR13, FR0 */
		/* 820CFD34h case   15:*/		cpu::op::fmul<0>(regs,&regs.FR2,regs.FR13,regs.FR0);
		/* 820CFD34h case   15:*/		return 0x820CFD38;
		  /* 820CFD38h */ case   16:  		/* stfd FR2, <#[R1 + 48]> */
		/* 820CFD38h case   16:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000030) );
		/* 820CFD38h case   16:*/		return 0x820CFD3C;
		  /* 820CFD3Ch */ case   17:  		/* ld R7, <#[R1 + 48]> */
		/* 820CFD3Ch case   17:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820CFD3Ch case   17:*/		return 0x820CFD40;
		  /* 820CFD40h */ case   18:  		/* stfd FR1, <#[R1 + 32]> */
		/* 820CFD40h case   18:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000020) );
		/* 820CFD40h case   18:*/		return 0x820CFD44;
		  /* 820CFD44h */ case   19:  		/* mr R4, R16 */
		/* 820CFD44h case   19:*/		regs.R4 = regs.R16;
		/* 820CFD44h case   19:*/		return 0x820CFD48;
		  /* 820CFD48h */ case   20:  		/* mtspr CTR, R27 */
		/* 820CFD48h case   20:*/		regs.CTR = regs.R27;
		/* 820CFD48h case   20:*/		return 0x820CFD4C;
		  /* 820CFD4Ch */ case   21:  		/* mr R6, R28 */
		/* 820CFD4Ch case   21:*/		regs.R6 = regs.R28;
		/* 820CFD4Ch case   21:*/		return 0x820CFD50;
		  /* 820CFD50h */ case   22:  		/* mr R3, R26 */
		/* 820CFD50h case   22:*/		regs.R3 = regs.R26;
		/* 820CFD50h case   22:*/		return 0x820CFD54;
		  /* 820CFD54h */ case   23:  		/* fadd FR3, FR2, FR0 */
		/* 820CFD54h case   23:*/		cpu::op::fadd<0>(regs,&regs.FR3,regs.FR2,regs.FR0);
		/* 820CFD54h case   23:*/		return 0x820CFD58;
		  /* 820CFD58h */ case   24:  		/* stfd FR3, <#[R1 + 56]> */
		/* 820CFD58h case   24:*/		cpu::mem::store64f( regs, regs.FR3, (uint32)(regs.R1 + 0x00000038) );
		/* 820CFD58h case   24:*/		return 0x820CFD5C;
		  /* 820CFD5Ch */ case   25:  		/* ld R8, <#[R1 + 56]> */
		/* 820CFD5Ch case   25:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820CFD5Ch case   25:*/		return 0x820CFD60;
		  /* 820CFD60h */ case   26:  		/* ld R5, <#[R1 + 32]> */
		/* 820CFD60h case   26:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820CFD60h case   26:*/		return 0x820CFD64;
		  /* 820CFD64h */ case   27:  		/* bcctrl 20, CR0_LT */
		/* 820CFD64h case   27:*/		if ( 1 ) { regs.LR = 0x820CFD68; return (uint32)regs.CTR; }
		/* 820CFD64h case   27:*/		return 0x820CFD68;
	}
	return 0x820CFD68;
} // Block from 820CFCF8h-820CFD68h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820CFD68h
// Function '?ValidatorOutputCallback@D3DXShader@@YAJPAXPBDK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFD68);
		  /* 820CFD68h */ case    0:  		/* b 264 */
		/* 820CFD68h case    0:*/		return 0x820CFE70;
		/* 820CFD68h case    0:*/		return 0x820CFD6C;
	}
	return 0x820CFD6C;
} // Block from 820CFD68h-820CFD6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CFD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFD6C);
		  /* 820CFD6Ch */ case    0:  		/* stfd FR3, <#[R1 + 56]> */
		/* 820CFD6Ch case    0:*/		cpu::mem::store64f( regs, regs.FR3, (uint32)(regs.R1 + 0x00000038) );
		/* 820CFD6Ch case    0:*/		return 0x820CFD70;
	}
	return 0x820CFD70;
} // Block from 820CFD6Ch-820CFD70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CFD70h
// Function '?GetValueAsInt@CUAssembler@D3DXShader@@KAJPAUD3DXTOKEN@2@PAHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFD70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFD70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFD70);
		  /* 820CFD70h */ case    0:  		/* ld R8, <#[R1 + 56]> */
		/* 820CFD70h case    0:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820CFD70h case    0:*/		return 0x820CFD74;
		  /* 820CFD74h */ case    1:  		/* stfd FR2, <#[R1 + 48]> */
		/* 820CFD74h case    1:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000030) );
		/* 820CFD74h case    1:*/		return 0x820CFD78;
		  /* 820CFD78h */ case    2:  		/* ld R7, <#[R1 + 48]> */
		/* 820CFD78h case    2:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820CFD78h case    2:*/		return 0x820CFD7C;
		  /* 820CFD7Ch */ case    3:  		/* stfd FR1, <#[R1 + 32]> */
		/* 820CFD7Ch case    3:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000020) );
		/* 820CFD7Ch case    3:*/		return 0x820CFD80;
		  /* 820CFD80h */ case    4:  		/* mr R4, R15 */
		/* 820CFD80h case    4:*/		regs.R4 = regs.R15;
		/* 820CFD80h case    4:*/		return 0x820CFD84;
		  /* 820CFD84h */ case    5:  		/* mr R6, R28 */
		/* 820CFD84h case    5:*/		regs.R6 = regs.R28;
		/* 820CFD84h case    5:*/		return 0x820CFD88;
		  /* 820CFD88h */ case    6:  		/* mtspr CTR, R27 */
		/* 820CFD88h case    6:*/		regs.CTR = regs.R27;
		/* 820CFD88h case    6:*/		return 0x820CFD8C;
		  /* 820CFD8Ch */ case    7:  		/* mr R3, R26 */
		/* 820CFD8Ch case    7:*/		regs.R3 = regs.R26;
		/* 820CFD8Ch case    7:*/		return 0x820CFD90;
		  /* 820CFD90h */ case    8:  		/* ld R5, <#[R1 + 32]> */
		/* 820CFD90h case    8:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820CFD90h case    8:*/		return 0x820CFD94;
		  /* 820CFD94h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CFD94h case    9:*/		if ( 1 ) { regs.LR = 0x820CFD98; return (uint32)regs.CTR; }
		/* 820CFD94h case    9:*/		return 0x820CFD98;
		  /* 820CFD98h */ case   10:  		/* b -520 */
		/* 820CFD98h case   10:*/		return 0x820CFB90;
		/* 820CFD98h case   10:*/		return 0x820CFD9C;
	}
	return 0x820CFD9C;
} // Block from 820CFD70h-820CFD9Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CFD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFD9C);
		  /* 820CFD9Ch */ case    0:  		/* lwz R7, <#[R30 + 8]> */
		/* 820CFD9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 820CFD9Ch case    0:*/		return 0x820CFDA0;
		  /* 820CFDA0h */ case    1:  		/* li R5, 0 */
		/* 820CFDA0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820CFDA0h case    1:*/		return 0x820CFDA4;
		  /* 820CFDA4h */ case    2:  		/* addi R4, R1, 80 */
		/* 820CFDA4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820CFDA4h case    2:*/		return 0x820CFDA8;
		  /* 820CFDA8h */ case    3:  		/* mr R6, R7 */
		/* 820CFDA8h case    3:*/		regs.R6 = regs.R7;
		/* 820CFDA8h case    3:*/		return 0x820CFDAC;
		  /* 820CFDACh */ case    4:  		/* bl -2684 */
		/* 820CFDACh case    4:*/		regs.LR = 0x820CFDB0; return 0x820CF330;
		/* 820CFDACh case    4:*/		return 0x820CFDB0;
		  /* 820CFDB0h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820CFDB0h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CFDB0h case    5:*/		return 0x820CFDB4;
		  /* 820CFDB4h */ case    6:  		/* bc 4, CR0_LT, 184 */
		/* 820CFDB4h case    6:*/		if ( !regs.CR[0].lt ) { return 0x820CFE6C;  }
		/* 820CFDB4h case    6:*/		return 0x820CFDB8;
		  /* 820CFDB8h */ case    7:  		/* mr R4, R20 */
		/* 820CFDB8h case    7:*/		regs.R4 = regs.R20;
		/* 820CFDB8h case    7:*/		return 0x820CFDBC;
		  /* 820CFDBCh */ case    8:  		/* lwz R5, <#[R1 + 80]> */
		/* 820CFDBCh case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820CFDBCh case    8:*/		return 0x820CFDC0;
		  /* 820CFDC0h */ case    9:  		/* mr R6, R28 */
		/* 820CFDC0h case    9:*/		regs.R6 = regs.R28;
		/* 820CFDC0h case    9:*/		return 0x820CFDC4;
		  /* 820CFDC4h */ case   10:  		/* mtspr CTR, R27 */
		/* 820CFDC4h case   10:*/		regs.CTR = regs.R27;
		/* 820CFDC4h case   10:*/		return 0x820CFDC8;
		  /* 820CFDC8h */ case   11:  		/* mr R3, R26 */
		/* 820CFDC8h case   11:*/		regs.R3 = regs.R26;
		/* 820CFDC8h case   11:*/		return 0x820CFDCC;
		  /* 820CFDCCh */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820CFDCCh case   12:*/		if ( 1 ) { regs.LR = 0x820CFDD0; return (uint32)regs.CTR; }
		/* 820CFDCCh case   12:*/		return 0x820CFDD0;
		  /* 820CFDD0h */ case   13:  		/* b -576 */
		/* 820CFDD0h case   13:*/		return 0x820CFB90;
		/* 820CFDD0h case   13:*/		return 0x820CFDD4;
	}
	return 0x820CFDD4;
} // Block from 820CFD9Ch-820CFDD4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CFDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFDD4);
		  /* 820CFDD4h */ case    0:  		/* addi R4, R1, 80 */
		/* 820CFDD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820CFDD4h case    0:*/		return 0x820CFDD8;
		  /* 820CFDD8h */ case    1:  		/* bl -2496 */
		/* 820CFDD8h case    1:*/		regs.LR = 0x820CFDDC; return 0x820CF418;
		/* 820CFDD8h case    1:*/		return 0x820CFDDC;
		  /* 820CFDDCh */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820CFDDCh case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820CFDDCh case    2:*/		return 0x820CFDE0;
		  /* 820CFDE0h */ case    3:  		/* bc 4, CR0_LT, 140 */
		/* 820CFDE0h case    3:*/		if ( !regs.CR[0].lt ) { return 0x820CFE6C;  }
		/* 820CFDE0h case    3:*/		return 0x820CFDE4;
		  /* 820CFDE4h */ case    4:  		/* lwz R4, <#[R1 + 104]> */
		/* 820CFDE4h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 820CFDE4h case    4:*/		return 0x820CFDE8;
		  /* 820CFDE8h */ case    5:  		/* b -616 */
		/* 820CFDE8h case    5:*/		return 0x820CFB80;
		/* 820CFDE8h case    5:*/		return 0x820CFDEC;
	}
	return 0x820CFDEC;
} // Block from 820CFDD4h-820CFDECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CFDECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFDEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFDEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFDEC);
		  /* 820CFDECh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820CFDECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CFDECh case    0:*/		return 0x820CFDF0;
		  /* 820CFDF0h */ case    1:  		/* cmpwi CR6, R11, 11 */
		/* 820CFDF0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820CFDF0h case    1:*/		return 0x820CFDF4;
		  /* 820CFDF4h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820CFDF4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CFE00;  }
		/* 820CFDF4h case    2:*/		return 0x820CFDF8;
		  /* 820CFDF8h */ case    3:  		/* lwz R4, <#[R1 + 108]> */
		/* 820CFDF8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000006C) );
		/* 820CFDF8h case    3:*/		return 0x820CFDFC;
		  /* 820CFDFCh */ case    4:  		/* b -636 */
		/* 820CFDFCh case    4:*/		return 0x820CFB80;
		/* 820CFDFCh case    4:*/		return 0x820CFE00;
	}
	return 0x820CFE00;
} // Block from 820CFDECh-820CFE00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CFE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFE00);
		  /* 820CFE00h */ case    0:  		/* lwz R8, <#[R30 + 8]> */
		/* 820CFE00h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 820CFE00h case    0:*/		return 0x820CFE04;
		  /* 820CFE04h */ case    1:  		/* lwz R5, <#[R3 + 8]> */
		/* 820CFE04h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000008) );
		/* 820CFE04h case    1:*/		return 0x820CFE08;
		  /* 820CFE08h */ case    2:  		/* lwz R11, <#[R8]> */
		/* 820CFE08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820CFE08h case    2:*/		return 0x820CFE0C;
		  /* 820CFE0Ch */ case    3:  		/* b 56 */
		/* 820CFE0Ch case    3:*/		return 0x820CFE44;
		/* 820CFE0Ch case    3:*/		return 0x820CFE10;
		  /* 820CFE10h */ case    4:  		/* mr R10, R5 */
		/* 820CFE10h case    4:*/		regs.R10 = regs.R5;
		/* 820CFE10h case    4:*/		return 0x820CFE14;
		  /* 820CFE14h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820CFE14h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820CFE14h case    5:*/		return 0x820CFE18;
		  /* 820CFE18h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820CFE18h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820CFE18h case    6:*/		return 0x820CFE1C;
		  /* 820CFE1Ch */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820CFE1Ch case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CFE1Ch case    7:*/		return 0x820CFE20;
		  /* 820CFE20h */ case    8:  		/* subf R9, R7, R9 */
		/* 820CFE20h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820CFE20h case    8:*/		return 0x820CFE24;
		  /* 820CFE24h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820CFE24h case    9:*/		if ( regs.CR[0].eq ) { return 0x820CFE38;  }
		/* 820CFE24h case    9:*/		return 0x820CFE28;
		  /* 820CFE28h */ case   10:  		/* addi R11, R11, 1 */
		/* 820CFE28h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820CFE28h case   10:*/		return 0x820CFE2C;
		  /* 820CFE2Ch */ case   11:  		/* addi R10, R10, 1 */
		/* 820CFE2Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820CFE2Ch case   11:*/		return 0x820CFE30;
		  /* 820CFE30h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820CFE30h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820CFE30h case   12:*/		return 0x820CFE34;
		  /* 820CFE34h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820CFE34h case   13:*/		if ( regs.CR[6].eq ) { return 0x820CFE14;  }
		/* 820CFE34h case   13:*/		return 0x820CFE38;
	}
	return 0x820CFE38;
} // Block from 820CFE00h-820CFE38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CFE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFE38);
		  /* 820CFE38h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820CFE38h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820CFE38h case    0:*/		return 0x820CFE3C;
		  /* 820CFE3Ch */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 820CFE3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820CFE64;  }
		/* 820CFE3Ch case    1:*/		return 0x820CFE40;
		  /* 820CFE40h */ case    2:  		/* lwzu R11, <#[R8 + 8]> */
		/* 820CFE40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		regs.R8 = (uint32)(regs.R8 + 0x00000008);
		/* 820CFE40h case    2:*/		return 0x820CFE44;
	}
	return 0x820CFE44;
} // Block from 820CFE38h-820CFE44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CFE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFE44);
		  /* 820CFE44h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820CFE44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CFE44h case    0:*/		return 0x820CFE48;
		  /* 820CFE48h */ case    1:  		/* bc 4, CR6_EQ, -56 */
		/* 820CFE48h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CFE10;  }
		/* 820CFE48h case    1:*/		return 0x820CFE4C;
		  /* 820CFE4Ch */ case    2:  		/* mr R4, R19 */
		/* 820CFE4Ch case    2:*/		regs.R4 = regs.R19;
		/* 820CFE4Ch case    2:*/		return 0x820CFE50;
		  /* 820CFE50h */ case    3:  		/* mtspr CTR, R27 */
		/* 820CFE50h case    3:*/		regs.CTR = regs.R27;
		/* 820CFE50h case    3:*/		return 0x820CFE54;
		  /* 820CFE54h */ case    4:  		/* mr R6, R28 */
		/* 820CFE54h case    4:*/		regs.R6 = regs.R28;
		/* 820CFE54h case    4:*/		return 0x820CFE58;
	}
	return 0x820CFE58;
} // Block from 820CFE44h-820CFE58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CFE58h
// Function '?GetValueAsBool@CUAssembler@D3DXShader@@KAJPAUD3DXTOKEN@2@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFE58);
		  /* 820CFE58h */ case    0:  		/* mr R3, R26 */
		/* 820CFE58h case    0:*/		regs.R3 = regs.R26;
		/* 820CFE58h case    0:*/		return 0x820CFE5C;
		  /* 820CFE5Ch */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 820CFE5Ch case    1:*/		if ( 1 ) { regs.LR = 0x820CFE60; return (uint32)regs.CTR; }
		/* 820CFE5Ch case    1:*/		return 0x820CFE60;
		  /* 820CFE60h */ case    2:  		/* b -720 */
		/* 820CFE60h case    2:*/		return 0x820CFB90;
		/* 820CFE60h case    2:*/		return 0x820CFE64;
	}
	return 0x820CFE64;
} // Block from 820CFE58h-820CFE64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CFE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFE64);
		  /* 820CFE64h */ case    0:  		/* lbz R29, <#[R8 + 4]> */
		/* 820CFE64h case    0:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R8 + 0x00000004) );
		/* 820CFE64h case    0:*/		return 0x820CFE68;
		  /* 820CFE68h */ case    1:  		/* b 8 */
		/* 820CFE68h case    1:*/		return 0x820CFE70;
		/* 820CFE68h case    1:*/		return 0x820CFE6C;
	}
	return 0x820CFE6C;
} // Block from 820CFE64h-820CFE6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CFE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFE6C);
		  /* 820CFE6Ch */ case    0:  		/* lwz R29, <#[R1 + 80]> */
		/* 820CFE6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820CFE6Ch case    0:*/		return 0x820CFE70;
	}
	return 0x820CFE70;
} // Block from 820CFE6Ch-820CFE70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CFE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFE70);
		  /* 820CFE70h */ case    0:  		/* rlwinm R11, R23, 0, 27, 31 */
		/* 820CFE70h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R23);
		/* 820CFE70h case    0:*/		return 0x820CFE74;
		  /* 820CFE74h */ case    1:  		/* lbz R9, <#[R30 + 4]> */
		/* 820CFE74h case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 820CFE74h case    1:*/		return 0x820CFE78;
		  /* 820CFE78h */ case    2:  		/* rlwinm R10, R25, 18, 30, 31 */
		/* 820CFE78h case    2:*/		cpu::op::rlwinm<0,18,30,31>(regs,&regs.R10,regs.R25);
		/* 820CFE78h case    2:*/		return 0x820CFE7C;
		  /* 820CFE7Ch */ case    3:  		/* cmplwi CR6, R9, 14 */
		/* 820CFE7Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000E);
		/* 820CFE7Ch case    3:*/		return 0x820CFE80;
		  /* 820CFE80h */ case    4:  		/* lbzx R11, <#[R11 + R24]> */
		/* 820CFE80h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 820CFE80h case    4:*/		return 0x820CFE84;
		  /* 820CFE84h */ case    5:  		/* bc 12, CR6_GT, 188 */
		/* 820CFE84h case    5:*/		if ( regs.CR[6].gt ) { return 0x820CFF40;  }
		/* 820CFE84h case    5:*/		return 0x820CFE88;
		  /* 820CFE88h */ case    6:  		/* lis R12, -32255 */
		/* 820CFE88h case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820CFE88h case    6:*/		return 0x820CFE8C;
		  /* 820CFE8Ch */ case    7:  		/* addi R12, R12, 21848 */
		/* 820CFE8Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5558);
		/* 820CFE8Ch case    7:*/		return 0x820CFE90;
		  /* 820CFE90h */ case    8:  		/* lbzx R0, <#[R12 + R9]> */
		/* 820CFE90h case    8:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R9 + 0x00000000) );
		/* 820CFE90h case    8:*/		return 0x820CFE94;
		  /* 820CFE94h */ case    9:  		/* lis R12, -32243 */
		/* 820CFE94h case    9:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820D);
		/* 820CFE94h case    9:*/		return 0x820CFE98;
		  /* 820CFE98h */ case   10:  		/* ori R0, R0, 0 */
		/* 820CFE98h case   10:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820CFE98h case   10:*/		return 0x820CFE9C;
		  /* 820CFE9Ch */ case   11:  		/* addi R12, R12, -336 */
		/* 820CFE9Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFFEB0);
		/* 820CFE9Ch case   11:*/		return 0x820CFEA0;
		  /* 820CFEA0h */ case   12:  		/* ori R0, R0, 0 */
		/* 820CFEA0h case   12:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820CFEA0h case   12:*/		return 0x820CFEA4;
		  /* 820CFEA4h */ case   13:  		/* add R12, R12, R0 */
		/* 820CFEA4h case   13:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820CFEA4h case   13:*/		return 0x820CFEA8;
		  /* 820CFEA8h */ case   14:  		/* mtspr CTR, R12 */
		/* 820CFEA8h case   14:*/		regs.CTR = regs.R12;
		/* 820CFEA8h case   14:*/		return 0x820CFEAC;
		  /* 820CFEACh */ case   15:  		/* bcctr 20, CR0_LT */
		/* 820CFEACh case   15:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820CFEACh case   15:*/		return 0x820CFEB0;
		  /* 820CFEB0h */ case   16:  		/* andi. R11, R11, 23 */
		/* 820CFEB0h case   16:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 820CFEB0h case   16:*/		return 0x820CFEB4;
		  /* 820CFEB4h */ case   17:  		/* addi R11, R11, 0 */
		/* 820CFEB4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820CFEB4h case   17:*/		return 0x820CFEB8;
		  /* 820CFEB8h */ case   18:  		/* addic R10, R11, -1 */
		/* 820CFEB8h case   18:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 820CFEB8h case   18:*/		return 0x820CFEBC;
		  /* 820CFEBCh */ case   19:  		/* subfe R11, R10, R11 */
		/* 820CFEBCh case   19:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820CFEBCh case   19:*/		return 0x820CFEC0;
		  /* 820CFEC0h */ case   20:  		/* b 120 */
		/* 820CFEC0h case   20:*/		return 0x820CFF38;
		/* 820CFEC0h case   20:*/		return 0x820CFEC4;
		  /* 820CFEC4h */ case   21:  		/* andi. R11, R11, 19 */
		/* 820CFEC4h case   21:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 820CFEC4h case   21:*/		return 0x820CFEC8;
		  /* 820CFEC8h */ case   22:  		/* b -20 */
		/* 820CFEC8h case   22:*/		return 0x820CFEB4;
		/* 820CFEC8h case   22:*/		return 0x820CFECC;
		  /* 820CFECCh */ case   23:  		/* cmplwi CR6, R10, 2 */
		/* 820CFECCh case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820CFECCh case   23:*/		return 0x820CFED0;
		  /* 820CFED0h */ case   24:  		/* bc 12, CR6_LT, 112 */
		/* 820CFED0h case   24:*/		if ( regs.CR[6].lt ) { return 0x820CFF40;  }
		/* 820CFED0h case   24:*/		return 0x820CFED4;
		  /* 820CFED4h */ case   25:  		/* andi. R11, R11, 23 */
		/* 820CFED4h case   25:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 820CFED4h case   25:*/		return 0x820CFED8;
		  /* 820CFED8h */ case   26:  		/* cmpwi CR0, R11, 0 */
		/* 820CFED8h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820CFED8h case   26:*/		return 0x820CFEDC;
		  /* 820CFEDCh */ case   27:  		/* bc 12, CR0_EQ, 100 */
		/* 820CFEDCh case   27:*/		if ( regs.CR[0].eq ) { return 0x820CFF40;  }
		/* 820CFEDCh case   27:*/		return 0x820CFEE0;
		  /* 820CFEE0h */ case   28:  		/* lis R12, -32255 */
		/* 820CFEE0h case   28:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820CFEE0h case   28:*/		return 0x820CFEE4;
		  /* 820CFEE4h */ case   29:  		/* rlwinm R0, R9, 1, 0, 30 */
		/* 820CFEE4h case   29:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R9);
		/* 820CFEE4h case   29:*/		return 0x820CFEE8;
		  /* 820CFEE8h */ case   30:  		/* addi R12, R12, 21816 */
		/* 820CFEE8h case   30:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5538);
		/* 820CFEE8h case   30:*/		return 0x820CFEEC;
		  /* 820CFEECh */ case   31:  		/* lhzx R0, <#[R12 + R0]> */
		/* 820CFEECh case   31:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 820CFEECh case   31:*/		return 0x820CFEF0;
		  /* 820CFEF0h */ case   32:  		/* lis R12, -32243 */
		/* 820CFEF0h case   32:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820D);
		/* 820CFEF0h case   32:*/		return 0x820CFEF4;
		  /* 820CFEF4h */ case   33:  		/* addi R12, R12, -1136 */
		/* 820CFEF4h case   33:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFFB90);
		/* 820CFEF4h case   33:*/		return 0x820CFEF8;
		  /* 820CFEF8h */ case   34:  		/* ori R0, R0, 0 */
		/* 820CFEF8h case   34:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820CFEF8h case   34:*/		return 0x820CFEFC;
		  /* 820CFEFCh */ case   35:  		/* add R12, R12, R0 */
		/* 820CFEFCh case   35:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820CFEFCh case   35:*/		return 0x820CFF00;
		  /* 820CFF00h */ case   36:  		/* mtspr CTR, R12 */
		/* 820CFF00h case   36:*/		regs.CTR = regs.R12;
		/* 820CFF00h case   36:*/		return 0x820CFF04;
		  /* 820CFF04h */ case   37:  		/* bcctr 20, CR0_LT */
		/* 820CFF04h case   37:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820CFF04h case   37:*/		return 0x820CFF08;
		  /* 820CFF08h */ case   38:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 820CFF08h case   38:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 820CFF08h case   38:*/		return 0x820CFF0C;
		  /* 820CFF0Ch */ case   39:  		/* b -88 */
		/* 820CFF0Ch case   39:*/		return 0x820CFEB4;
		/* 820CFF0Ch case   39:*/		return 0x820CFF10;
		  /* 820CFF10h */ case   40:  		/* cmplwi CR6, R10, 1 */
		/* 820CFF10h case   40:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820CFF10h case   40:*/		return 0x820CFF14;
		  /* 820CFF14h */ case   41:  		/* bc 12, CR6_LT, 44 */
		/* 820CFF14h case   41:*/		if ( regs.CR[6].lt ) { return 0x820CFF40;  }
		/* 820CFF14h case   41:*/		return 0x820CFF18;
		  /* 820CFF18h */ case   42:  		/* andi. R11, R11, 19 */
		/* 820CFF18h case   42:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 820CFF18h case   42:*/		return 0x820CFF1C;
		  /* 820CFF1Ch */ case   43:  		/* b -68 */
		/* 820CFF1Ch case   43:*/		return 0x820CFED8;
		/* 820CFF1Ch case   43:*/		return 0x820CFF20;
		  /* 820CFF20h */ case   44:  		/* cmplwi CR6, R10, 2 */
		/* 820CFF20h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820CFF20h case   44:*/		return 0x820CFF24;
		  /* 820CFF24h */ case   45:  		/* bc 12, CR6_LT, 16 */
		/* 820CFF24h case   45:*/		if ( regs.CR[6].lt ) { return 0x820CFF34;  }
		/* 820CFF24h case   45:*/		return 0x820CFF28;
		  /* 820CFF28h */ case   46:  		/* andi. R11, R11, 19 */
		/* 820CFF28h case   46:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 820CFF28h case   46:*/		return 0x820CFF2C;
		  /* 820CFF2Ch */ case   47:  		/* cmpwi CR0, R11, 0 */
		/* 820CFF2Ch case   47:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820CFF2Ch case   47:*/		return 0x820CFF30;
		  /* 820CFF30h */ case   48:  		/* bc 4, CR0_EQ, -80 */
		/* 820CFF30h case   48:*/		if ( !regs.CR[0].eq ) { return 0x820CFEE0;  }
		/* 820CFF30h case   48:*/		return 0x820CFF34;
	}
	return 0x820CFF34;
} // Block from 820CFE70h-820CFF34h (49 instructions)

//////////////////////////////////////////////////////
// Block at 820CFF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFF34);
		  /* 820CFF34h */ case    0:  		/* li R11, 0 */
		/* 820CFF34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CFF34h case    0:*/		return 0x820CFF38;
	}
	return 0x820CFF38;
} // Block from 820CFF34h-820CFF38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CFF38h
// Function '?HandleVFetchOptions@CUAssembler@D3DXShader@@SA_NPAVCNodeUAsmInstruction@2@PATGPUVERTEX_FETCH_INSTRUCTION@@PAKPAHPA_NP6AXPAXPBDZZ5@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFF38);
		  /* 820CFF38h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 820CFF38h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820CFF38h case    0:*/		return 0x820CFF3C;
		  /* 820CFF3Ch */ case    1:  		/* bc 4, CR6_EQ, -92 */
		/* 820CFF3Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CFEE0;  }
		/* 820CFF3Ch case    1:*/		return 0x820CFF40;
	}
	return 0x820CFF40;
} // Block from 820CFF38h-820CFF40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CFF40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFF40);
		  /* 820CFF40h */ case    0:  		/* mr R4, R17 */
		/* 820CFF40h case    0:*/		regs.R4 = regs.R17;
		/* 820CFF40h case    0:*/		return 0x820CFF44;
		  /* 820CFF44h */ case    1:  		/* b -964 */
		/* 820CFF44h case    1:*/		return 0x820CFB80;
		/* 820CFF44h case    1:*/		return 0x820CFF48;
		  /* 820CFF48h */ case    2:  		/* rlwimi R23, R29, 25, 6, 6 */
		/* 820CFF48h case    2:*/		cpu::op::rlwimi<0,25,6,6>(regs,&regs.R23,regs.R29);
		/* 820CFF48h case    2:*/		return 0x820CFF4C;
		  /* 820CFF4Ch */ case    3:  		/* b -956 */
		/* 820CFF4Ch case    3:*/		return 0x820CFB90;
		/* 820CFF4Ch case    3:*/		return 0x820CFF50;
		  /* 820CFF50h */ case    4:  		/* rlwimi R23, R29, 19, 12, 12 */
		/* 820CFF50h case    4:*/		cpu::op::rlwimi<0,19,12,12>(regs,&regs.R23,regs.R29);
		/* 820CFF50h case    4:*/		return 0x820CFF54;
		  /* 820CFF54h */ case    5:  		/* b -964 */
		/* 820CFF54h case    5:*/		return 0x820CFB90;
		/* 820CFF54h case    5:*/		return 0x820CFF58;
		  /* 820CFF58h */ case    6:  		/* rlwimi R21, R29, 12, 18, 19 */
		/* 820CFF58h case    6:*/		cpu::op::rlwimi<0,12,18,19>(regs,&regs.R21,regs.R29);
		/* 820CFF58h case    6:*/		return 0x820CFF5C;
		  /* 820CFF5Ch */ case    7:  		/* b -972 */
		/* 820CFF5Ch case    7:*/		return 0x820CFB90;
		/* 820CFF5Ch case    7:*/		return 0x820CFF60;
		  /* 820CFF60h */ case    8:  		/* rlwimi R21, R29, 14, 16, 17 */
		/* 820CFF60h case    8:*/		cpu::op::rlwimi<0,14,16,17>(regs,&regs.R21,regs.R29);
		/* 820CFF60h case    8:*/		return 0x820CFF64;
		  /* 820CFF64h */ case    9:  		/* b -980 */
		/* 820CFF64h case    9:*/		return 0x820CFB90;
		/* 820CFF64h case    9:*/		return 0x820CFF68;
		  /* 820CFF68h */ case   10:  		/* rlwimi R21, R29, 16, 14, 15 */
		/* 820CFF68h case   10:*/		cpu::op::rlwimi<0,16,14,15>(regs,&regs.R21,regs.R29);
		/* 820CFF68h case   10:*/		return 0x820CFF6C;
		  /* 820CFF6Ch */ case   11:  		/* b -988 */
		/* 820CFF6Ch case   11:*/		return 0x820CFB90;
		/* 820CFF6Ch case   11:*/		return 0x820CFF70;
		  /* 820CFF70h */ case   12:  		/* rlwimi R21, R29, 18, 11, 13 */
		/* 820CFF70h case   12:*/		cpu::op::rlwimi<0,18,11,13>(regs,&regs.R21,regs.R29);
		/* 820CFF70h case   12:*/		return 0x820CFF74;
		  /* 820CFF74h */ case   13:  		/* b -996 */
		/* 820CFF74h case   13:*/		return 0x820CFB90;
		/* 820CFF74h case   13:*/		return 0x820CFF78;
		  /* 820CFF78h */ case   14:  		/* rlwimi R21, R29, 24, 6, 7 */
		/* 820CFF78h case   14:*/		cpu::op::rlwimi<0,24,6,7>(regs,&regs.R21,regs.R29);
		/* 820CFF78h case   14:*/		return 0x820CFF7C;
		  /* 820CFF7Ch */ case   15:  		/* b -1004 */
		/* 820CFF7Ch case   15:*/		return 0x820CFB90;
		/* 820CFF7Ch case   15:*/		return 0x820CFF80;
		  /* 820CFF80h */ case   16:  		/* rlwimi R21, R29, 26, 4, 5 */
		/* 820CFF80h case   16:*/		cpu::op::rlwimi<0,26,4,5>(regs,&regs.R21,regs.R29);
		/* 820CFF80h case   16:*/		return 0x820CFF84;
		  /* 820CFF84h */ case   17:  		/* b -1012 */
		/* 820CFF84h case   17:*/		return 0x820CFB90;
		/* 820CFF84h case   17:*/		return 0x820CFF88;
		  /* 820CFF88h */ case   18:  		/* rlwimi R21, R29, 28, 3, 3 */
		/* 820CFF88h case   18:*/		cpu::op::rlwimi<0,28,3,3>(regs,&regs.R21,regs.R29);
		/* 820CFF88h case   18:*/		return 0x820CFF8C;
		  /* 820CFF8Ch */ case   19:  		/* b -1020 */
		/* 820CFF8Ch case   19:*/		return 0x820CFB90;
		/* 820CFF8Ch case   19:*/		return 0x820CFF90;
		  /* 820CFF90h */ case   20:  		/* rlwimi R21, R29, 29, 2, 2 */
		/* 820CFF90h case   20:*/		cpu::op::rlwimi<0,29,2,2>(regs,&regs.R21,regs.R29);
		/* 820CFF90h case   20:*/		return 0x820CFF94;
		  /* 820CFF94h */ case   21:  		/* b -1028 */
		/* 820CFF94h case   21:*/		return 0x820CFB90;
		/* 820CFF94h case   21:*/		return 0x820CFF98;
		  /* 820CFF98h */ case   22:  		/* rlwimi R29, R25, 0, 0, 30 */
		/* 820CFF98h case   22:*/		cpu::op::rlwimi<0,0,0,30>(regs,&regs.R29,regs.R25);
		/* 820CFF98h case   22:*/		return 0x820CFF9C;
		  /* 820CFF9Ch */ case   23:  		/* mr R25, R29 */
		/* 820CFF9Ch case   23:*/		regs.R25 = regs.R29;
		/* 820CFF9Ch case   23:*/		return 0x820CFFA0;
		  /* 820CFFA0h */ case   24:  		/* b -1040 */
		/* 820CFFA0h case   24:*/		return 0x820CFB90;
		/* 820CFFA0h case   24:*/		return 0x820CFFA4;
		  /* 820CFFA4h */ case   25:  		/* rlwimi R25, R31, 2, 23, 29 */
		/* 820CFFA4h case   25:*/		cpu::op::rlwimi<0,2,23,29>(regs,&regs.R25,regs.R31);
		/* 820CFFA4h case   25:*/		return 0x820CFFA8;
		  /* 820CFFA8h */ case   26:  		/* b -1048 */
		/* 820CFFA8h case   26:*/		return 0x820CFB90;
		/* 820CFFA8h case   26:*/		return 0x820CFFAC;
		  /* 820CFFACh */ case   27:  		/* rlwimi R25, R31, 16, 11, 15 */
		/* 820CFFACh case   27:*/		cpu::op::rlwimi<0,16,11,15>(regs,&regs.R25,regs.R31);
		/* 820CFFACh case   27:*/		return 0x820CFFB0;
		  /* 820CFFB0h */ case   28:  		/* b -1056 */
		/* 820CFFB0h case   28:*/		return 0x820CFB90;
		/* 820CFFB0h case   28:*/		return 0x820CFFB4;
		  /* 820CFFB4h */ case   29:  		/* rlwimi R25, R31, 21, 6, 10 */
		/* 820CFFB4h case   29:*/		cpu::op::rlwimi<0,21,6,10>(regs,&regs.R25,regs.R31);
		/* 820CFFB4h case   29:*/		return 0x820CFFB8;
		  /* 820CFFB8h */ case   30:  		/* b -1064 */
		/* 820CFFB8h case   30:*/		return 0x820CFB90;
		/* 820CFFB8h case   30:*/		return 0x820CFFBC;
		  /* 820CFFBCh */ case   31:  		/* rlwimi R25, R31, 26, 1, 5 */
		/* 820CFFBCh case   31:*/		cpu::op::rlwimi<0,26,1,5>(regs,&regs.R25,regs.R31);
		/* 820CFFBCh case   31:*/		return 0x820CFFC0;
		  /* 820CFFC0h */ case   32:  		/* b -1072 */
		/* 820CFFC0h case   32:*/		return 0x820CFB90;
		/* 820CFFC0h case   32:*/		return 0x820CFFC4;
		  /* 820CFFC4h */ case   33:  		/* nop */
		/* 820CFFC4h case   33:*/		cpu::op::nop();
		/* 820CFFC4h case   33:*/		return 0x820CFFC8;
	}
	return 0x820CFFC8;
} // Block from 820CFF40h-820CFFC8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820CFFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CFFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CFFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CFFC8);
		  /* 820CFFC8h */ case    0:  		/* mfspr R12, LR */
		/* 820CFFC8h case    0:*/		regs.R12 = regs.LR;
		/* 820CFFC8h case    0:*/		return 0x820CFFCC;
		  /* 820CFFCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CFFCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CFFCCh case    1:*/		return 0x820CFFD0;
		  /* 820CFFD0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CFFD0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CFFD0h case    2:*/		return 0x820CFFD4;
		  /* 820CFFD4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CFFD4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CFFD4h case    3:*/		return 0x820CFFD8;
		  /* 820CFFD8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CFFD8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CFFD8h case    4:*/		return 0x820CFFDC;
		  /* 820CFFDCh */ case    5:  		/* lwz R11, <#[R3 + 304]> */
		/* 820CFFDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000130) );
		/* 820CFFDCh case    5:*/		return 0x820CFFE0;
		  /* 820CFFE0h */ case    6:  		/* mr R31, R3 */
		/* 820CFFE0h case    6:*/		regs.R31 = regs.R3;
		/* 820CFFE0h case    6:*/		return 0x820CFFE4;
		  /* 820CFFE4h */ case    7:  		/* li R30, 0 */
		/* 820CFFE4h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820CFFE4h case    7:*/		return 0x820CFFE8;
		  /* 820CFFE8h */ case    8:  		/* rlwinm R11, R11, 0, 11, 11 */
		/* 820CFFE8h case    8:*/		cpu::op::rlwinm<0,0,11,11>(regs,&regs.R11,regs.R11);
		/* 820CFFE8h case    8:*/		return 0x820CFFEC;
		  /* 820CFFECh */ case    9:  		/* stw R30, <#[R3 + 296]> */
		/* 820CFFECh case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000128) );
		/* 820CFFECh case    9:*/		return 0x820CFFF0;
		  /* 820CFFF0h */ case   10:  		/* li R5, 32 */
		/* 820CFFF0h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820CFFF0h case   10:*/		return 0x820CFFF4;
		  /* 820CFFF4h */ case   11:  		/* stw R30, <#[R3 + 300]> */
		/* 820CFFF4h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000012C) );
		/* 820CFFF4h case   11:*/		return 0x820CFFF8;
		  /* 820CFFF8h */ case   12:  		/* li R4, 0 */
		/* 820CFFF8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820CFFF8h case   12:*/		return 0x820CFFFC;
		  /* 820CFFFCh */ case   13:  		/* addi R3, R3, 140 */
		/* 820CFFFCh case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x8C);
		/* 820CFFFCh case   13:*/		return 0x820D0000;
		  /* 820D0000h */ case   14:  		/* stw R11, <#[R31 + 304]> */
		/* 820D0000h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000130) );
		/* 820D0000h case   14:*/		return 0x820D0004;
		  /* 820D0004h */ case   15:  		/* stw R30, <#[R31 + 312]> */
		/* 820D0004h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000138) );
		/* 820D0004h case   15:*/		return 0x820D0008;
		  /* 820D0008h */ case   16:  		/* bl -257224 */
		/* 820D0008h case   16:*/		regs.LR = 0x820D000C; return 0x82091340;
		/* 820D0008h case   16:*/		return 0x820D000C;
		  /* 820D000Ch */ case   17:  		/* stw R30, <#[R31 + 172]> */
		/* 820D000Ch case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000000AC) );
		/* 820D000Ch case   17:*/		return 0x820D0010;
		  /* 820D0010h */ case   18:  		/* stw R30, <#[R31 + 176]> */
		/* 820D0010h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000000B0) );
		/* 820D0010h case   18:*/		return 0x820D0014;
		  /* 820D0014h */ case   19:  		/* li R5, 32 */
		/* 820D0014h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820D0014h case   19:*/		return 0x820D0018;
		  /* 820D0018h */ case   20:  		/* stw R30, <#[R31 + 180]> */
		/* 820D0018h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000000B4) );
		/* 820D0018h case   20:*/		return 0x820D001C;
		  /* 820D001Ch */ case   21:  		/* li R4, 0 */
		/* 820D001Ch case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D001Ch case   21:*/		return 0x820D0020;
		  /* 820D0020h */ case   22:  		/* addi R3, R31, 188 */
		/* 820D0020h case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xBC);
		/* 820D0020h case   22:*/		return 0x820D0024;
		  /* 820D0024h */ case   23:  		/* stw R30, <#[R31 + 184]> */
		/* 820D0024h case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x000000B8) );
		/* 820D0024h case   23:*/		return 0x820D0028;
		  /* 820D0028h */ case   24:  		/* bl -257256 */
		/* 820D0028h case   24:*/		regs.LR = 0x820D002C; return 0x82091340;
		/* 820D0028h case   24:*/		return 0x820D002C;
		  /* 820D002Ch */ case   25:  		/* li R5, 32 */
		/* 820D002Ch case   25:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820D002Ch case   25:*/		return 0x820D0030;
		  /* 820D0030h */ case   26:  		/* li R4, 0 */
		/* 820D0030h case   26:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D0030h case   26:*/		return 0x820D0034;
		  /* 820D0034h */ case   27:  		/* sth R30, <#[R31 + 220]> */
		/* 820D0034h case   27:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R31 + 0x000000DC) );
		/* 820D0034h case   27:*/		return 0x820D0038;
		  /* 820D0038h */ case   28:  		/* addi R3, R31, 224 */
		/* 820D0038h case   28:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xE0);
		/* 820D0038h case   28:*/		return 0x820D003C;
		  /* 820D003Ch */ case   29:  		/* bl -257276 */
		/* 820D003Ch case   29:*/		regs.LR = 0x820D0040; return 0x82091340;
		/* 820D003Ch case   29:*/		return 0x820D0040;
		  /* 820D0040h */ case   30:  		/* li R5, 32 */
		/* 820D0040h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820D0040h case   30:*/		return 0x820D0044;
		  /* 820D0044h */ case   31:  		/* li R4, 0 */
		/* 820D0044h case   31:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D0044h case   31:*/		return 0x820D0048;
		  /* 820D0048h */ case   32:  		/* stw R30, <#[R31 + 256]> */
		/* 820D0048h case   32:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000100) );
		/* 820D0048h case   32:*/		return 0x820D004C;
		  /* 820D004Ch */ case   33:  		/* addi R3, R31, 260 */
		/* 820D004Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x104);
		/* 820D004Ch case   33:*/		return 0x820D0050;
		  /* 820D0050h */ case   34:  		/* bl -257296 */
		/* 820D0050h case   34:*/		regs.LR = 0x820D0054; return 0x82091340;
		/* 820D0050h case   34:*/		return 0x820D0054;
		  /* 820D0054h */ case   35:  		/* li R11, 1 */
		/* 820D0054h case   35:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D0054h case   35:*/		return 0x820D0058;
		  /* 820D0058h */ case   36:  		/* stw R11, <#[R31 + 308]> */
		/* 820D0058h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000134) );
		/* 820D0058h case   36:*/		return 0x820D005C;
		  /* 820D005Ch */ case   37:  		/* addi R1, R1, 112 */
		/* 820D005Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820D005Ch case   37:*/		return 0x820D0060;
		  /* 820D0060h */ case   38:  		/* lwz R12, <#[R1 - 8]> */
		/* 820D0060h case   38:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D0060h case   38:*/		return 0x820D0064;
		  /* 820D0064h */ case   39:  		/* mtspr LR, R12 */
		/* 820D0064h case   39:*/		regs.LR = regs.R12;
		/* 820D0064h case   39:*/		return 0x820D0068;
		  /* 820D0068h */ case   40:  		/* ld R30, <#[R1 - 24]> */
		/* 820D0068h case   40:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820D0068h case   40:*/		return 0x820D006C;
		  /* 820D006Ch */ case   41:  		/* ld R31, <#[R1 - 16]> */
		/* 820D006Ch case   41:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820D006Ch case   41:*/		return 0x820D0070;
		  /* 820D0070h */ case   42:  		/* bclr 20, CR0_LT */
		/* 820D0070h case   42:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820D0070h case   42:*/		return 0x820D0074;
	}
	return 0x820D0074;
} // Block from 820CFFC8h-820D0074h (43 instructions)

//////////////////////////////////////////////////////
// Block at 820D0074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0074);
		  /* 820D0074h */ case    0:  		/* nop */
		/* 820D0074h case    0:*/		cpu::op::nop();
		/* 820D0074h case    0:*/		return 0x820D0078;
	}
	return 0x820D0078;
} // Block from 820D0074h-820D0078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D0078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0078);
		  /* 820D0078h */ case    0:  		/* mfspr R12, LR */
		/* 820D0078h case    0:*/		regs.R12 = regs.LR;
		/* 820D0078h case    0:*/		return 0x820D007C;
		  /* 820D007Ch */ case    1:  		/* bl -257572 */
		/* 820D007Ch case    1:*/		regs.LR = 0x820D0080; return 0x82091258;
		/* 820D007Ch case    1:*/		return 0x820D0080;
		  /* 820D0080h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820D0080h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820D0080h case    2:*/		return 0x820D0084;
		  /* 820D0084h */ case    3:  		/* mr R30, R3 */
		/* 820D0084h case    3:*/		regs.R30 = regs.R3;
		/* 820D0084h case    3:*/		return 0x820D0088;
		  /* 820D0088h */ case    4:  		/* li R3, 24 */
		/* 820D0088h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x18);
		/* 820D0088h case    4:*/		return 0x820D008C;
		  /* 820D008Ch */ case    5:  		/* mr R29, R4 */
		/* 820D008Ch case    5:*/		regs.R29 = regs.R4;
		/* 820D008Ch case    5:*/		return 0x820D0090;
		  /* 820D0090h */ case    6:  		/* mr R28, R5 */
		/* 820D0090h case    6:*/		regs.R28 = regs.R5;
		/* 820D0090h case    6:*/		return 0x820D0094;
		  /* 820D0094h */ case    7:  		/* bl -28268 */
		/* 820D0094h case    7:*/		regs.LR = 0x820D0098; return 0x820C9228;
		/* 820D0094h case    7:*/		return 0x820D0098;
		  /* 820D0098h */ case    8:  		/* or. R31, R3, R3 */
		/* 820D0098h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820D0098h case    8:*/		return 0x820D009C;
		  /* 820D009Ch */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 820D009Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820D00C8;  }
		/* 820D009Ch case    9:*/		return 0x820D00A0;
		  /* 820D00A0h */ case   10:  		/* mr R3, R31 */
		/* 820D00A0h case   10:*/		regs.R3 = regs.R31;
		/* 820D00A0h case   10:*/		return 0x820D00A4;
		  /* 820D00A4h */ case   11:  		/* bl -28220 */
		/* 820D00A4h case   11:*/		regs.LR = 0x820D00A8; return 0x820C9268;
		/* 820D00A4h case   11:*/		return 0x820D00A8;
		  /* 820D00A8h */ case   12:  		/* lis R10, -32255 */
		/* 820D00A8h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D00A8h case   12:*/		return 0x820D00AC;
		  /* 820D00ACh */ case   13:  		/* li R11, -1 */
		/* 820D00ACh case   13:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D00ACh case   13:*/		return 0x820D00B0;
		  /* 820D00B0h */ case   14:  		/* addi R10, R10, 22380 */
		/* 820D00B0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x576C);
		/* 820D00B0h case   14:*/		return 0x820D00B4;
		  /* 820D00B4h */ case   15:  		/* stw R11, <#[R31 + 16]> */
		/* 820D00B4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820D00B4h case   15:*/		return 0x820D00B8;
		  /* 820D00B8h */ case   16:  		/* mr R3, R31 */
		/* 820D00B8h case   16:*/		regs.R3 = regs.R31;
		/* 820D00B8h case   16:*/		return 0x820D00BC;
		  /* 820D00BCh */ case   17:  		/* stw R10, <#[R31]> */
		/* 820D00BCh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820D00BCh case   17:*/		return 0x820D00C0;
		  /* 820D00C0h */ case   18:  		/* stw R11, <#[R31 + 20]> */
		/* 820D00C0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820D00C0h case   18:*/		return 0x820D00C4;
		  /* 820D00C4h */ case   19:  		/* b 8 */
		/* 820D00C4h case   19:*/		return 0x820D00CC;
		/* 820D00C4h case   19:*/		return 0x820D00C8;
	}
	return 0x820D00C8;
} // Block from 820D0078h-820D00C8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820D00C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D00C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D00C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D00C8);
		  /* 820D00C8h */ case    0:  		/* li R3, 0 */
		/* 820D00C8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820D00C8h case    0:*/		return 0x820D00CC;
	}
	return 0x820D00CC;
} // Block from 820D00C8h-820D00CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D00CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D00CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D00CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D00CC);
		  /* 820D00CCh */ case    0:  		/* stw R28, <#[R3 + 16]> */
		/* 820D00CCh case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000010) );
		/* 820D00CCh case    0:*/		return 0x820D00D0;
		  /* 820D00D0h */ case    1:  		/* stw R29, <#[R3 + 20]> */
		/* 820D00D0h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 820D00D0h case    1:*/		return 0x820D00D4;
		  /* 820D00D4h */ case    2:  		/* lwz R11, <#[R30 + 336]> */
		/* 820D00D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000150) );
		/* 820D00D4h case    2:*/		return 0x820D00D8;
		  /* 820D00D8h */ case    3:  		/* stw R11, <#[R3 + 12]> */
		/* 820D00D8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820D00D8h case    3:*/		return 0x820D00DC;
		  /* 820D00DCh */ case    4:  		/* stw R3, <#[R30 + 336]> */
		/* 820D00DCh case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000150) );
		/* 820D00DCh case    4:*/		return 0x820D00E0;
		  /* 820D00E0h */ case    5:  		/* addi R1, R1, 128 */
		/* 820D00E0h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820D00E0h case    5:*/		return 0x820D00E4;
		  /* 820D00E4h */ case    6:  		/* b -257596 */
		/* 820D00E4h case    6:*/		return 0x820912A8;
		/* 820D00E4h case    6:*/		return 0x820D00E8;
	}
	return 0x820D00E8;
} // Block from 820D00CCh-820D00E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D00E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D00E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D00E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D00E8);
		  /* 820D00E8h */ case    0:  		/* mfspr R12, LR */
		/* 820D00E8h case    0:*/		regs.R12 = regs.LR;
		/* 820D00E8h case    0:*/		return 0x820D00EC;
		  /* 820D00ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820D00ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D00ECh case    1:*/		return 0x820D00F0;
		  /* 820D00F0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820D00F0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820D00F0h case    2:*/		return 0x820D00F4;
		  /* 820D00F4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820D00F4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820D00F4h case    3:*/		return 0x820D00F8;
		  /* 820D00F8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820D00F8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820D00F8h case    4:*/		return 0x820D00FC;
		  /* 820D00FCh */ case    5:  		/* mr R31, R3 */
		/* 820D00FCh case    5:*/		regs.R31 = regs.R3;
		/* 820D00FCh case    5:*/		return 0x820D0100;
		  /* 820D0100h */ case    6:  		/* lwz R3, <#[R3 + 324]> */
		/* 820D0100h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000144) );
		/* 820D0100h case    6:*/		return 0x820D0104;
		  /* 820D0104h */ case    7:  		/* li R30, 0 */
		/* 820D0104h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820D0104h case    7:*/		return 0x820D0108;
		  /* 820D0108h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820D0108h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820D0108h case    8:*/		return 0x820D010C;
		  /* 820D010Ch */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820D010Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820D0118;  }
		/* 820D010Ch case    9:*/		return 0x820D0110;
		  /* 820D0110h */ case   10:  		/* bl 484440 */
		/* 820D0110h case   10:*/		regs.LR = 0x820D0114; return 0x82146568;
		/* 820D0110h case   10:*/		return 0x820D0114;
		  /* 820D0114h */ case   11:  		/* stw R30, <#[R31 + 324]> */
		/* 820D0114h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000144) );
		/* 820D0114h case   11:*/		return 0x820D0118;
	}
	return 0x820D0118;
} // Block from 820D00E8h-820D0118h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D0118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0118);
		  /* 820D0118h */ case    0:  		/* lwz R3, <#[R31 + 320]> */
		/* 820D0118h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000140) );
		/* 820D0118h case    0:*/		return 0x820D011C;
		  /* 820D011Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820D011Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820D011Ch case    1:*/		return 0x820D0120;
		  /* 820D0120h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820D0120h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D012C;  }
		/* 820D0120h case    2:*/		return 0x820D0124;
		  /* 820D0124h */ case    3:  		/* bl -402724 */
		/* 820D0124h case    3:*/		regs.LR = 0x820D0128; return 0x8206DC00;
		/* 820D0124h case    3:*/		return 0x820D0128;
		  /* 820D0128h */ case    4:  		/* stw R30, <#[R31 + 320]> */
		/* 820D0128h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000140) );
		/* 820D0128h case    4:*/		return 0x820D012C;
	}
	return 0x820D012C;
} // Block from 820D0118h-820D012Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D012Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D012C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D012C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D012C);
		  /* 820D012Ch */ case    0:  		/* lwz R3, <#[R31 + 136]> */
		/* 820D012Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000088) );
		/* 820D012Ch case    0:*/		return 0x820D0130;
		  /* 820D0130h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820D0130h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820D0130h case    1:*/		return 0x820D0134;
		  /* 820D0134h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820D0134h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D014C;  }
		/* 820D0134h case    2:*/		return 0x820D0138;
		  /* 820D0138h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820D0138h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820D0138h case    3:*/		return 0x820D013C;
		  /* 820D013Ch */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820D013Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820D013Ch case    4:*/		return 0x820D0140;
		  /* 820D0140h */ case    5:  		/* mtspr CTR, R11 */
		/* 820D0140h case    5:*/		regs.CTR = regs.R11;
		/* 820D0140h case    5:*/		return 0x820D0144;
		  /* 820D0144h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820D0144h case    6:*/		if ( 1 ) { regs.LR = 0x820D0148; return (uint32)regs.CTR; }
		/* 820D0144h case    6:*/		return 0x820D0148;
		  /* 820D0148h */ case    7:  		/* stw R30, <#[R31 + 136]> */
		/* 820D0148h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 820D0148h case    7:*/		return 0x820D014C;
	}
	return 0x820D014C;
} // Block from 820D012Ch-820D014Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D014Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D014C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D014C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D014C);
		  /* 820D014Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820D014Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820D014Ch case    0:*/		return 0x820D0150;
		  /* 820D0150h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820D0150h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D0150h case    1:*/		return 0x820D0154;
		  /* 820D0154h */ case    2:  		/* mtspr LR, R12 */
		/* 820D0154h case    2:*/		regs.LR = regs.R12;
		/* 820D0154h case    2:*/		return 0x820D0158;
		  /* 820D0158h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820D0158h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820D0158h case    3:*/		return 0x820D015C;
		  /* 820D015Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820D015Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820D015Ch case    4:*/		return 0x820D0160;
		  /* 820D0160h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820D0160h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820D0160h case    5:*/		return 0x820D0164;
	}
	return 0x820D0164;
} // Block from 820D014Ch-820D0164h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D0164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0164);
		  /* 820D0164h */ case    0:  		/* nop */
		/* 820D0164h case    0:*/		cpu::op::nop();
		/* 820D0164h case    0:*/		return 0x820D0168;
	}
	return 0x820D0168;
} // Block from 820D0164h-820D0168h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D0168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0168);
		  /* 820D0168h */ case    0:  		/* mfspr R12, LR */
		/* 820D0168h case    0:*/		regs.R12 = regs.LR;
		/* 820D0168h case    0:*/		return 0x820D016C;
		  /* 820D016Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820D016Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D016Ch case    1:*/		return 0x820D0170;
		  /* 820D0170h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820D0170h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820D0170h case    2:*/		return 0x820D0174;
		  /* 820D0174h */ case    3:  		/* ld R12, <#[R1 - 4096]> */
		/* 820D0174h case    3:*/		cpu::mem::load64( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFF000) );
		/* 820D0174h case    3:*/		return 0x820D0178;
		  /* 820D0178h */ case    4:  		/* stwu R1, <#[R1 - 4192]> */
		/* 820D0178h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFEFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFEFA0);
		/* 820D0178h case    4:*/		return 0x820D017C;
		  /* 820D017Ch */ case    5:  		/* li R11, 1 */
		/* 820D017Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D017Ch case    5:*/		return 0x820D0180;
		  /* 820D0180h */ case    6:  		/* lis R10, -32255 */
		/* 820D0180h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D0180h case    6:*/		return 0x820D0184;
		  /* 820D0184h */ case    7:  		/* stw R11, <#[R3 + 60]> */
		/* 820D0184h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 820D0184h case    7:*/		return 0x820D0188;
		  /* 820D0188h */ case    8:  		/* mr R31, R3 */
		/* 820D0188h case    8:*/		regs.R31 = regs.R3;
		/* 820D0188h case    8:*/		return 0x820D018C;
		  /* 820D018Ch */ case    9:  		/* mr R6, R5 */
		/* 820D018Ch case    9:*/		regs.R6 = regs.R5;
		/* 820D018Ch case    9:*/		return 0x820D0190;
		  /* 820D0190h */ case   10:  		/* mr R11, R4 */
		/* 820D0190h case   10:*/		regs.R11 = regs.R4;
		/* 820D0190h case   10:*/		return 0x820D0194;
		  /* 820D0194h */ case   11:  		/* addi R10, R10, -10392 */
		/* 820D0194h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD768);
		/* 820D0194h case   11:*/		return 0x820D0198;
		  /* 820D0198h */ case   12:  		/* lbz R9, <#[R11]> */
		/* 820D0198h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0198h case   12:*/		return 0x820D019C;
		  /* 820D019Ch */ case   13:  		/* lbz R8, <#[R10]> */
		/* 820D019Ch case   13:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D019Ch case   13:*/		return 0x820D01A0;
		  /* 820D01A0h */ case   14:  		/* cmpwi CR0, R9, 0 */
		/* 820D01A0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D01A0h case   14:*/		return 0x820D01A4;
		  /* 820D01A4h */ case   15:  		/* subf R9, R8, R9 */
		/* 820D01A4h case   15:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D01A4h case   15:*/		return 0x820D01A8;
		  /* 820D01A8h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 820D01A8h case   16:*/		if ( regs.CR[0].eq ) { return 0x820D01BC;  }
		/* 820D01A8h case   16:*/		return 0x820D01AC;
		  /* 820D01ACh */ case   17:  		/* addi R11, R11, 1 */
		/* 820D01ACh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D01ACh case   17:*/		return 0x820D01B0;
		  /* 820D01B0h */ case   18:  		/* addi R10, R10, 1 */
		/* 820D01B0h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D01B0h case   18:*/		return 0x820D01B4;
		  /* 820D01B4h */ case   19:  		/* cmpwi CR6, R9, 0 */
		/* 820D01B4h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D01B4h case   19:*/		return 0x820D01B8;
		  /* 820D01B8h */ case   20:  		/* bc 12, CR6_EQ, -32 */
		/* 820D01B8h case   20:*/		if ( regs.CR[6].eq ) { return 0x820D0198;  }
		/* 820D01B8h case   20:*/		return 0x820D01BC;
	}
	return 0x820D01BC;
} // Block from 820D0168h-820D01BCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820D01BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D01BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D01BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D01BC);
		  /* 820D01BCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D01BCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D01BCh case    0:*/		return 0x820D01C0;
		  /* 820D01C0h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 820D01C0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D01D8;  }
		/* 820D01C0h case    1:*/		return 0x820D01C4;
		  /* 820D01C4h */ case    2:  		/* addi R5, R31, 16 */
		/* 820D01C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x10);
		/* 820D01C4h case    2:*/		return 0x820D01C8;
		  /* 820D01C8h */ case    3:  		/* lwz R3, <#[R31]> */
		/* 820D01C8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820D01C8h case    3:*/		return 0x820D01CC;
		  /* 820D01CCh */ case    4:  		/* li R4, 2000 */
		/* 820D01CCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x7D0);
		/* 820D01CCh case    4:*/		return 0x820D01D0;
		  /* 820D01D0h */ case    5:  		/* bl -167472 */
		/* 820D01D0h case    5:*/		regs.LR = 0x820D01D4; return 0x820A73A0;
		/* 820D01D0h case    5:*/		return 0x820D01D4;
		  /* 820D01D4h */ case    6:  		/* b 56 */
		/* 820D01D4h case    6:*/		return 0x820D020C;
		/* 820D01D4h case    6:*/		return 0x820D01D8;
	}
	return 0x820D01D8;
} // Block from 820D01BCh-820D01D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D01D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D01D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D01D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D01D8);
		  /* 820D01D8h */ case    0:  		/* mr R5, R4 */
		/* 820D01D8h case    0:*/		regs.R5 = regs.R4;
		/* 820D01D8h case    0:*/		return 0x820D01DC;
		  /* 820D01DCh */ case    1:  		/* li R4, 4096 */
		/* 820D01DCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1000);
		/* 820D01DCh case    1:*/		return 0x820D01E0;
		  /* 820D01E0h */ case    2:  		/* addi R3, R1, 80 */
		/* 820D01E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820D01E0h case    2:*/		return 0x820D01E4;
		  /* 820D01E4h */ case    3:  		/* bl -201468 */
		/* 820D01E4h case    3:*/		regs.LR = 0x820D01E8; return 0x8209EEE8;
		/* 820D01E4h case    3:*/		return 0x820D01E8;
		  /* 820D01E8h */ case    4:  		/* li R11, 0 */
		/* 820D01E8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D01E8h case    4:*/		return 0x820D01EC;
		  /* 820D01ECh */ case    5:  		/* lis R10, -32255 */
		/* 820D01ECh case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D01ECh case    5:*/		return 0x820D01F0;
		  /* 820D01F0h */ case    6:  		/* lwz R3, <#[R31]> */
		/* 820D01F0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820D01F0h case    6:*/		return 0x820D01F4;
		  /* 820D01F4h */ case    7:  		/* stb R11, <#[R1 + 4175]> */
		/* 820D01F4h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000104F) );
		/* 820D01F4h case    7:*/		return 0x820D01F8;
		  /* 820D01F8h */ case    8:  		/* addi R7, R1, 80 */
		/* 820D01F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820D01F8h case    8:*/		return 0x820D01FC;
		  /* 820D01FCh */ case    9:  		/* addi R6, R10, -10432 */
		/* 820D01FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFD740);
		/* 820D01FCh case    9:*/		return 0x820D0200;
		  /* 820D0200h */ case   10:  		/* li R5, 7100 */
		/* 820D0200h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1BBC);
		/* 820D0200h case   10:*/		return 0x820D0204;
		  /* 820D0204h */ case   11:  		/* addi R4, R31, 16 */
		/* 820D0204h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820D0204h case   11:*/		return 0x820D0208;
		  /* 820D0208h */ case   12:  		/* bl -168056 */
		/* 820D0208h case   12:*/		regs.LR = 0x820D020C; return 0x820A7190;
		/* 820D0208h case   12:*/		return 0x820D020C;
	}
	return 0x820D020C;
} // Block from 820D01D8h-820D020Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D020Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D020C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D020C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D020C);
		  /* 820D020Ch */ case    0:  		/* addi R1, R1, 4192 */
		/* 820D020Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1060);
		/* 820D020Ch case    0:*/		return 0x820D0210;
		  /* 820D0210h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820D0210h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D0210h case    1:*/		return 0x820D0214;
		  /* 820D0214h */ case    2:  		/* mtspr LR, R12 */
		/* 820D0214h case    2:*/		regs.LR = regs.R12;
		/* 820D0214h case    2:*/		return 0x820D0218;
		  /* 820D0218h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820D0218h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820D0218h case    3:*/		return 0x820D021C;
		  /* 820D021Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 820D021Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820D021Ch case    4:*/		return 0x820D0220;
	}
	return 0x820D0220;
} // Block from 820D020Ch-820D0220h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D0220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0220);
		  /* 820D0220h */ case    0:  		/* mfspr R12, LR */
		/* 820D0220h case    0:*/		regs.R12 = regs.LR;
		/* 820D0220h case    0:*/		return 0x820D0224;
		  /* 820D0224h */ case    1:  		/* bl -257996 */
		/* 820D0224h case    1:*/		regs.LR = 0x820D0228; return 0x82091258;
		/* 820D0224h case    1:*/		return 0x820D0228;
		  /* 820D0228h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820D0228h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820D0228h case    2:*/		return 0x820D022C;
		  /* 820D022Ch */ case    3:  		/* lwz R10, <#[R6]> */
		/* 820D022Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 820D022Ch case    3:*/		return 0x820D0230;
		  /* 820D0230h */ case    4:  		/* mr R31, R4 */
		/* 820D0230h case    4:*/		regs.R31 = regs.R4;
		/* 820D0230h case    4:*/		return 0x820D0234;
		  /* 820D0234h */ case    5:  		/* mr R30, R3 */
		/* 820D0234h case    5:*/		regs.R30 = regs.R3;
		/* 820D0234h case    5:*/		return 0x820D0238;
		  /* 820D0238h */ case    6:  		/* mr R4, R5 */
		/* 820D0238h case    6:*/		regs.R4 = regs.R5;
		/* 820D0238h case    6:*/		return 0x820D023C;
		  /* 820D023Ch */ case    7:  		/* mr R29, R6 */
		/* 820D023Ch case    7:*/		regs.R29 = regs.R6;
		/* 820D023Ch case    7:*/		return 0x820D0240;
		  /* 820D0240h */ case    8:  		/* mr R28, R31 */
		/* 820D0240h case    8:*/		regs.R28 = regs.R31;
		/* 820D0240h case    8:*/		return 0x820D0244;
		  /* 820D0244h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820D0244h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D0244h case    9:*/		return 0x820D0248;
		  /* 820D0248h */ case   10:  		/* bc 12, CR6_EQ, 108 */
		/* 820D0248h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D02B4;  }
		/* 820D0248h case   10:*/		return 0x820D024C;
		  /* 820D024Ch */ case   11:  		/* mr R9, R31 */
		/* 820D024Ch case   11:*/		regs.R9 = regs.R31;
		/* 820D024Ch case   11:*/		return 0x820D0250;
		  /* 820D0250h */ case   12:  		/* mr R11, R30 */
		/* 820D0250h case   12:*/		regs.R11 = regs.R30;
		/* 820D0250h case   12:*/		return 0x820D0254;
		  /* 820D0254h */ case   13:  		/* lbz R8, <#[R11]> */
		/* 820D0254h case   13:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0254h case   13:*/		return 0x820D0258;
		  /* 820D0258h */ case   14:  		/* lbz R7, <#[R9]> */
		/* 820D0258h case   14:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820D0258h case   14:*/		return 0x820D025C;
		  /* 820D025Ch */ case   15:  		/* cmpwi CR0, R8, 0 */
		/* 820D025Ch case   15:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820D025Ch case   15:*/		return 0x820D0260;
		  /* 820D0260h */ case   16:  		/* subf R8, R7, R8 */
		/* 820D0260h case   16:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820D0260h case   16:*/		return 0x820D0264;
		  /* 820D0264h */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0264h case   17:*/		if ( regs.CR[0].eq ) { return 0x820D0278;  }
		/* 820D0264h case   17:*/		return 0x820D0268;
		  /* 820D0268h */ case   18:  		/* addi R11, R11, 1 */
		/* 820D0268h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0268h case   18:*/		return 0x820D026C;
		  /* 820D026Ch */ case   19:  		/* addi R9, R9, 1 */
		/* 820D026Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820D026Ch case   19:*/		return 0x820D0270;
		  /* 820D0270h */ case   20:  		/* cmpwi CR6, R8, 0 */
		/* 820D0270h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820D0270h case   20:*/		return 0x820D0274;
		  /* 820D0274h */ case   21:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0274h case   21:*/		if ( regs.CR[6].eq ) { return 0x820D0254;  }
		/* 820D0274h case   21:*/		return 0x820D0278;
	}
	return 0x820D0278;
} // Block from 820D0220h-820D0278h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820D0278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0278);
		  /* 820D0278h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820D0278h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820D0278h case    0:*/		return 0x820D027C;
		  /* 820D027Ch */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 820D027Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820D0300;  }
		/* 820D027Ch case    1:*/		return 0x820D0280;
		  /* 820D0280h */ case    2:  		/* mr R11, R31 */
		/* 820D0280h case    2:*/		regs.R11 = regs.R31;
		/* 820D0280h case    2:*/		return 0x820D0284;
		  /* 820D0284h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820D0284h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0284h case    3:*/		return 0x820D0288;
		  /* 820D0288h */ case    4:  		/* addi R11, R11, 1 */
		/* 820D0288h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0288h case    4:*/		return 0x820D028C;
		  /* 820D028Ch */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 820D028Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D028Ch case    5:*/		return 0x820D0290;
		  /* 820D0290h */ case    6:  		/* bc 4, CR6_EQ, -12 */
		/* 820D0290h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820D0284;  }
		/* 820D0290h case    6:*/		return 0x820D0294;
		  /* 820D0294h */ case    7:  		/* subf R11, R31, R11 */
		/* 820D0294h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820D0294h case    7:*/		return 0x820D0298;
		  /* 820D0298h */ case    8:  		/* addi R11, R11, -1 */
		/* 820D0298h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D0298h case    8:*/		return 0x820D029C;
		  /* 820D029Ch */ case    9:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820D029Ch case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820D029Ch case    9:*/		return 0x820D02A0;
		  /* 820D02A0h */ case   10:  		/* subf R10, R11, R10 */
		/* 820D02A0h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820D02A0h case   10:*/		return 0x820D02A4;
		  /* 820D02A4h */ case   11:  		/* add R11, R11, R31 */
		/* 820D02A4h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820D02A4h case   11:*/		return 0x820D02A8;
		  /* 820D02A8h */ case   12:  		/* addic. R10, R10, -1 */
		/* 820D02A8h case   12:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820D02A8h case   12:*/		return 0x820D02AC;
		  /* 820D02ACh */ case   13:  		/* addi R31, R11, 1 */
		/* 820D02ACh case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 820D02ACh case   13:*/		return 0x820D02B0;
		  /* 820D02B0h */ case   14:  		/* bc 4, CR0_EQ, -100 */
		/* 820D02B0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820D024C;  }
		/* 820D02B0h case   14:*/		return 0x820D02B4;
	}
	return 0x820D02B4;
} // Block from 820D0278h-820D02B4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D02B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D02B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D02B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D02B4);
		  /* 820D02B4h */ case    0:  		/* lis R11, 32767 */
		/* 820D02B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820D02B4h case    0:*/		return 0x820D02B8;
		  /* 820D02B8h */ case    1:  		/* ori R11, R11, 65535 */
		/* 820D02B8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 820D02B8h case    1:*/		return 0x820D02BC;
		  /* 820D02BCh */ case    2:  		/* cmplw CR6, R4, R11 */
		/* 820D02BCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820D02BCh case    2:*/		return 0x820D02C0;
		  /* 820D02C0h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820D02C0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820D02D0;  }
		/* 820D02C0h case    3:*/		return 0x820D02C4;
		  /* 820D02C4h */ case    4:  		/* mr R5, R30 */
		/* 820D02C4h case    4:*/		regs.R5 = regs.R30;
		/* 820D02C4h case    4:*/		return 0x820D02C8;
		  /* 820D02C8h */ case    5:  		/* mr R3, R31 */
		/* 820D02C8h case    5:*/		regs.R3 = regs.R31;
		/* 820D02C8h case    5:*/		return 0x820D02CC;
		  /* 820D02CCh */ case    6:  		/* bl -170972 */
		/* 820D02CCh case    6:*/		regs.LR = 0x820D02D0; return 0x820A66F0;
		/* 820D02CCh case    6:*/		return 0x820D02D0;
	}
	return 0x820D02D0;
} // Block from 820D02B4h-820D02D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D02D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D02D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D02D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D02D0);
		  /* 820D02D0h */ case    0:  		/* mr R11, R30 */
		/* 820D02D0h case    0:*/		regs.R11 = regs.R30;
		/* 820D02D0h case    0:*/		return 0x820D02D4;
		  /* 820D02D4h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 820D02D4h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D02D4h case    1:*/		return 0x820D02D8;
		  /* 820D02D8h */ case    2:  		/* addi R11, R11, 1 */
		/* 820D02D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D02D8h case    2:*/		return 0x820D02DC;
		  /* 820D02DCh */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820D02DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D02DCh case    3:*/		return 0x820D02E0;
		  /* 820D02E0h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 820D02E0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D02D4;  }
		/* 820D02E0h case    4:*/		return 0x820D02E4;
		  /* 820D02E4h */ case    5:  		/* subf R10, R30, R11 */
		/* 820D02E4h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R11);
		/* 820D02E4h case    5:*/		return 0x820D02E8;
		  /* 820D02E8h */ case    6:  		/* lwz R11, <#[R29]> */
		/* 820D02E8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820D02E8h case    6:*/		return 0x820D02EC;
		  /* 820D02ECh */ case    7:  		/* addi R10, R10, -1 */
		/* 820D02ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820D02ECh case    7:*/		return 0x820D02F0;
		  /* 820D02F0h */ case    8:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 820D02F0h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 820D02F0h case    8:*/		return 0x820D02F4;
		  /* 820D02F4h */ case    9:  		/* add R11, R11, R10 */
		/* 820D02F4h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820D02F4h case    9:*/		return 0x820D02F8;
		  /* 820D02F8h */ case   10:  		/* addi R11, R11, 1 */
		/* 820D02F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D02F8h case   10:*/		return 0x820D02FC;
		  /* 820D02FCh */ case   11:  		/* stw R11, <#[R29]> */
		/* 820D02FCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820D02FCh case   11:*/		return 0x820D0300;
	}
	return 0x820D0300;
} // Block from 820D02D0h-820D0300h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D0300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0300);
		  /* 820D0300h */ case    0:  		/* subf R3, R28, R31 */
		/* 820D0300h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R28,regs.R31);
		/* 820D0300h case    0:*/		return 0x820D0304;
		  /* 820D0304h */ case    1:  		/* addi R1, R1, 128 */
		/* 820D0304h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820D0304h case    1:*/		return 0x820D0308;
		  /* 820D0308h */ case    2:  		/* b -258144 */
		/* 820D0308h case    2:*/		return 0x820912A8;
		/* 820D0308h case    2:*/		return 0x820D030C;
		  /* 820D030Ch */ case    3:  		/* nop */
		/* 820D030Ch case    3:*/		cpu::op::nop();
		/* 820D030Ch case    3:*/		return 0x820D0310;
	}
	return 0x820D0310;
} // Block from 820D0300h-820D0310h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D0310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0310);
		  /* 820D0310h */ case    0:  		/* mfspr R12, LR */
		/* 820D0310h case    0:*/		regs.R12 = regs.LR;
		/* 820D0310h case    0:*/		return 0x820D0314;
		  /* 820D0314h */ case    1:  		/* bl -258252 */
		/* 820D0314h case    1:*/		regs.LR = 0x820D0318; return 0x82091248;
		/* 820D0314h case    1:*/		return 0x820D0318;
		  /* 820D0318h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820D0318h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820D0318h case    2:*/		return 0x820D031C;
		  /* 820D031Ch */ case    3:  		/* li R28, 0 */
		/* 820D031Ch case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820D031Ch case    3:*/		return 0x820D0320;
		  /* 820D0320h */ case    4:  		/* mr R31, R3 */
		/* 820D0320h case    4:*/		regs.R31 = regs.R3;
		/* 820D0320h case    4:*/		return 0x820D0324;
		  /* 820D0324h */ case    5:  		/* stb R28, <#[R4]> */
		/* 820D0324h case    5:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R4 + 0x00000000) );
		/* 820D0324h case    5:*/		return 0x820D0328;
		  /* 820D0328h */ case    6:  		/* mr R27, R4 */
		/* 820D0328h case    6:*/		regs.R27 = regs.R4;
		/* 820D0328h case    6:*/		return 0x820D032C;
		  /* 820D032Ch */ case    7:  		/* stb R28, <#[R6]> */
		/* 820D032Ch case    7:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R6 + 0x00000000) );
		/* 820D032Ch case    7:*/		return 0x820D0330;
		  /* 820D0330h */ case    8:  		/* mr R26, R5 */
		/* 820D0330h case    8:*/		regs.R26 = regs.R5;
		/* 820D0330h case    8:*/		return 0x820D0334;
		  /* 820D0334h */ case    9:  		/* stw R28, <#[R8]> */
		/* 820D0334h case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R8 + 0x00000000) );
		/* 820D0334h case    9:*/		return 0x820D0338;
		  /* 820D0338h */ case   10:  		/* mr R24, R6 */
		/* 820D0338h case   10:*/		regs.R24 = regs.R6;
		/* 820D0338h case   10:*/		return 0x820D033C;
		  /* 820D033Ch */ case   11:  		/* stw R28, <#[R9]> */
		/* 820D033Ch case   11:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R9 + 0x00000000) );
		/* 820D033Ch case   11:*/		return 0x820D0340;
		  /* 820D0340h */ case   12:  		/* mr R25, R7 */
		/* 820D0340h case   12:*/		regs.R25 = regs.R7;
		/* 820D0340h case   12:*/		return 0x820D0344;
		  /* 820D0344h */ case   13:  		/* lbz R11, <#[R3]> */
		/* 820D0344h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820D0344h case   13:*/		return 0x820D0348;
		  /* 820D0348h */ case   14:  		/* extsb R11, R11 */
		/* 820D0348h case   14:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820D0348h case   14:*/		return 0x820D034C;
		  /* 820D034Ch */ case   15:  		/* mr R30, R9 */
		/* 820D034Ch case   15:*/		regs.R30 = regs.R9;
		/* 820D034Ch case   15:*/		return 0x820D0350;
		  /* 820D0350h */ case   16:  		/* mr R29, R3 */
		/* 820D0350h case   16:*/		regs.R29 = regs.R3;
		/* 820D0350h case   16:*/		return 0x820D0354;
		  /* 820D0354h */ case   17:  		/* cmpwi CR6, R11, 46 */
		/* 820D0354h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820D0354h case   17:*/		return 0x820D0358;
		  /* 820D0358h */ case   18:  		/* bc 4, CR6_EQ, 104 */
		/* 820D0358h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820D03C0;  }
		/* 820D0358h case   18:*/		return 0x820D035C;
		  /* 820D035Ch */ case   19:  		/* li R11, 1 */
		/* 820D035Ch case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D035Ch case   19:*/		return 0x820D0360;
		  /* 820D0360h */ case   20:  		/* addi R5, R3, 1 */
		/* 820D0360h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R3,0x1);
		/* 820D0360h case   20:*/		return 0x820D0364;
		  /* 820D0364h */ case   21:  		/* stw R11, <#[R8]> */
		/* 820D0364h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820D0364h case   21:*/		return 0x820D0368;
		  /* 820D0368h */ case   22:  		/* lbz R11, <#[R3 + 1]> */
		/* 820D0368h case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000001) );
		/* 820D0368h case   22:*/		return 0x820D036C;
		  /* 820D036Ch */ case   23:  		/* mr R29, R5 */
		/* 820D036Ch case   23:*/		regs.R29 = regs.R5;
		/* 820D036Ch case   23:*/		return 0x820D0370;
		  /* 820D0370h */ case   24:  		/* b 24 */
		/* 820D0370h case   24:*/		return 0x820D0388;
		/* 820D0370h case   24:*/		return 0x820D0374;
		  /* 820D0374h */ case   25:  		/* cmpwi CR6, R11, 91 */
		/* 820D0374h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005B);
		/* 820D0374h case   25:*/		return 0x820D0378;
		  /* 820D0378h */ case   26:  		/* bc 12, CR6_EQ, 28 */
		/* 820D0378h case   26:*/		if ( regs.CR[6].eq ) { return 0x820D0394;  }
		/* 820D0378h case   26:*/		return 0x820D037C;
		  /* 820D037Ch */ case   27:  		/* cmpwi CR6, R11, 0 */
		/* 820D037Ch case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D037Ch case   27:*/		return 0x820D0380;
		  /* 820D0380h */ case   28:  		/* bc 12, CR6_EQ, 20 */
		/* 820D0380h case   28:*/		if ( regs.CR[6].eq ) { return 0x820D0394;  }
		/* 820D0380h case   28:*/		return 0x820D0384;
		  /* 820D0384h */ case   29:  		/* lbzu R11, <#[R29 + 1]> */
		/* 820D0384h case   29:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000001) );
		regs.R29 = (uint32)(regs.R29 + 0x00000001);
		/* 820D0384h case   29:*/		return 0x820D0388;
	}
	return 0x820D0388;
} // Block from 820D0310h-820D0388h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820D0388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0388);
		  /* 820D0388h */ case    0:  		/* extsb R11, R11 */
		/* 820D0388h case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820D0388h case    0:*/		return 0x820D038C;
		  /* 820D038Ch */ case    1:  		/* cmpwi CR6, R11, 46 */
		/* 820D038Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820D038Ch case    1:*/		return 0x820D0390;
		  /* 820D0390h */ case    2:  		/* bc 4, CR6_EQ, -28 */
		/* 820D0390h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D0374;  }
		/* 820D0390h case    2:*/		return 0x820D0394;
	}
	return 0x820D0394;
} // Block from 820D0388h-820D0394h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D0394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0394);
		  /* 820D0394h */ case    0:  		/* lis R11, 32767 */
		/* 820D0394h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820D0394h case    0:*/		return 0x820D0398;
		  /* 820D0398h */ case    1:  		/* ori R30, R11, 65535 */
		/* 820D0398h case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R11,0xFFFF);
		/* 820D0398h case    1:*/		return 0x820D039C;
		  /* 820D039Ch */ case    2:  		/* cmplw CR6, R26, R30 */
		/* 820D039Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R30);
		/* 820D039Ch case    2:*/		return 0x820D03A0;
		  /* 820D03A0h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820D03A0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820D03B0;  }
		/* 820D03A0h case    3:*/		return 0x820D03A4;
		  /* 820D03A4h */ case    4:  		/* mr R4, R26 */
		/* 820D03A4h case    4:*/		regs.R4 = regs.R26;
		/* 820D03A4h case    4:*/		return 0x820D03A8;
		  /* 820D03A8h */ case    5:  		/* mr R3, R27 */
		/* 820D03A8h case    5:*/		regs.R3 = regs.R27;
		/* 820D03A8h case    5:*/		return 0x820D03AC;
		  /* 820D03ACh */ case    6:  		/* bl -171196 */
		/* 820D03ACh case    6:*/		regs.LR = 0x820D03B0; return 0x820A66F0;
		/* 820D03ACh case    6:*/		return 0x820D03B0;
	}
	return 0x820D03B0;
} // Block from 820D0394h-820D03B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D03B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D03B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D03B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D03B0);
		  /* 820D03B0h */ case    0:  		/* subf R11, R31, R29 */
		/* 820D03B0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 820D03B0h case    0:*/		return 0x820D03B4;
		  /* 820D03B4h */ case    1:  		/* add R11, R11, R27 */
		/* 820D03B4h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 820D03B4h case    1:*/		return 0x820D03B8;
		  /* 820D03B8h */ case    2:  		/* stb R28, <#[R11 - 1]> */
		/* 820D03B8h case    2:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 820D03B8h case    2:*/		return 0x820D03BC;
		  /* 820D03BCh */ case    3:  		/* b 168 */
		/* 820D03BCh case    3:*/		return 0x820D0464;
		/* 820D03BCh case    3:*/		return 0x820D03C0;
	}
	return 0x820D03C0;
} // Block from 820D03B0h-820D03C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D03C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D03C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D03C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D03C0);
		  /* 820D03C0h */ case    0:  		/* cmpwi CR6, R11, 91 */
		/* 820D03C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005B);
		/* 820D03C0h case    0:*/		return 0x820D03C4;
		  /* 820D03C4h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 820D03C4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D0410;  }
		/* 820D03C4h case    1:*/		return 0x820D03C8;
		  /* 820D03C8h */ case    2:  		/* li R11, 2 */
		/* 820D03C8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820D03C8h case    2:*/		return 0x820D03CC;
		  /* 820D03CCh */ case    3:  		/* addi R29, R31, 1 */
		/* 820D03CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x1);
		/* 820D03CCh case    3:*/		return 0x820D03D0;
		  /* 820D03D0h */ case    4:  		/* stw R11, <#[R8]> */
		/* 820D03D0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820D03D0h case    4:*/		return 0x820D03D4;
		  /* 820D03D4h */ case    5:  		/* mr R3, R29 */
		/* 820D03D4h case    5:*/		regs.R3 = regs.R29;
		/* 820D03D4h case    5:*/		return 0x820D03D8;
		  /* 820D03D8h */ case    6:  		/* bl -252016 */
		/* 820D03D8h case    6:*/		regs.LR = 0x820D03DC; return 0x82092B68;
		/* 820D03D8h case    6:*/		return 0x820D03DC;
		  /* 820D03DCh */ case    7:  		/* stw R3, <#[R30]> */
		/* 820D03DCh case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820D03DCh case    7:*/		return 0x820D03E0;
		  /* 820D03E0h */ case    8:  		/* lbz R11, <#[R31 + 1]> */
		/* 820D03E0h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		/* 820D03E0h case    8:*/		return 0x820D03E4;
		  /* 820D03E4h */ case    9:  		/* b 16 */
		/* 820D03E4h case    9:*/		return 0x820D03F4;
		/* 820D03E4h case    9:*/		return 0x820D03E8;
		  /* 820D03E8h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 820D03E8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D03E8h case   10:*/		return 0x820D03EC;
		  /* 820D03ECh */ case   11:  		/* bc 12, CR6_EQ, 80 */
		/* 820D03ECh case   11:*/		if ( regs.CR[6].eq ) { return 0x820D043C;  }
		/* 820D03ECh case   11:*/		return 0x820D03F0;
		  /* 820D03F0h */ case   12:  		/* lbzu R11, <#[R29 + 1]> */
		/* 820D03F0h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000001) );
		regs.R29 = (uint32)(regs.R29 + 0x00000001);
		/* 820D03F0h case   12:*/		return 0x820D03F4;
	}
	return 0x820D03F4;
} // Block from 820D03C0h-820D03F4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D03F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D03F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D03F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D03F4);
		  /* 820D03F4h */ case    0:  		/* extsb R11, R11 */
		/* 820D03F4h case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820D03F4h case    0:*/		return 0x820D03F8;
		  /* 820D03F8h */ case    1:  		/* cmpwi CR6, R11, 93 */
		/* 820D03F8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005D);
		/* 820D03F8h case    1:*/		return 0x820D03FC;
		  /* 820D03FCh */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 820D03FCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D03E8;  }
		/* 820D03FCh case    2:*/		return 0x820D0400;
		  /* 820D0400h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820D0400h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D0400h case    3:*/		return 0x820D0404;
		  /* 820D0404h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 820D0404h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D043C;  }
		/* 820D0404h case    4:*/		return 0x820D0408;
		  /* 820D0408h */ case    5:  		/* addi R29, R29, 1 */
		/* 820D0408h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820D0408h case    5:*/		return 0x820D040C;
		  /* 820D040Ch */ case    6:  		/* b 48 */
		/* 820D040Ch case    6:*/		return 0x820D043C;
		/* 820D040Ch case    6:*/		return 0x820D0410;
	}
	return 0x820D0410;
} // Block from 820D03F4h-820D0410h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D0410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0410);
		  /* 820D0410h */ case    0:  		/* stw R28, <#[R8]> */
		/* 820D0410h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R8 + 0x00000000) );
		/* 820D0410h case    0:*/		return 0x820D0414;
		  /* 820D0414h */ case    1:  		/* lbz R11, <#[R31]> */
		/* 820D0414h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D0414h case    1:*/		return 0x820D0418;
		  /* 820D0418h */ case    2:  		/* b 24 */
		/* 820D0418h case    2:*/		return 0x820D0430;
		/* 820D0418h case    2:*/		return 0x820D041C;
		  /* 820D041Ch */ case    3:  		/* cmpwi CR6, R11, 91 */
		/* 820D041Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005B);
		/* 820D041Ch case    3:*/		return 0x820D0420;
		  /* 820D0420h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820D0420h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D043C;  }
		/* 820D0420h case    4:*/		return 0x820D0424;
		  /* 820D0424h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820D0424h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D0424h case    5:*/		return 0x820D0428;
		  /* 820D0428h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820D0428h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D043C;  }
		/* 820D0428h case    6:*/		return 0x820D042C;
		  /* 820D042Ch */ case    7:  		/* lbzu R11, <#[R29 + 1]> */
		/* 820D042Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000001) );
		regs.R29 = (uint32)(regs.R29 + 0x00000001);
		/* 820D042Ch case    7:*/		return 0x820D0430;
	}
	return 0x820D0430;
} // Block from 820D0410h-820D0430h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D0430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0430);
		  /* 820D0430h */ case    0:  		/* extsb R11, R11 */
		/* 820D0430h case    0:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820D0430h case    0:*/		return 0x820D0434;
		  /* 820D0434h */ case    1:  		/* cmpwi CR6, R11, 46 */
		/* 820D0434h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820D0434h case    1:*/		return 0x820D0438;
	}
	return 0x820D0438;
} // Block from 820D0430h-820D0438h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0438h
// Function '?HandleTFetchOptions@CUAssembler@D3DXShader@@SAXPAVCNodeUAsmInstruction@2@PATGPUTEXTURE_FETCH_INSTRUCTION@@PA_NP6AXPAXPBDZZ3@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0438);
		  /* 820D0438h */ case    0:  		/* bc 4, CR6_EQ, -28 */
		/* 820D0438h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820D041C;  }
		/* 820D0438h case    0:*/		return 0x820D043C;
	}
	return 0x820D043C;
} // Block from 820D0438h-820D043Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D043Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D043C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D043C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D043C);
		  /* 820D043Ch */ case    0:  		/* lis R11, 32767 */
		/* 820D043Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820D043Ch case    0:*/		return 0x820D0440;
		  /* 820D0440h */ case    1:  		/* ori R30, R11, 65535 */
		/* 820D0440h case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R11,0xFFFF);
		/* 820D0440h case    1:*/		return 0x820D0444;
		  /* 820D0444h */ case    2:  		/* cmplw CR6, R26, R30 */
		/* 820D0444h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R30);
		/* 820D0444h case    2:*/		return 0x820D0448;
		  /* 820D0448h */ case    3:  		/* bc 12, CR6_GT, 20 */
		/* 820D0448h case    3:*/		if ( regs.CR[6].gt ) { return 0x820D045C;  }
		/* 820D0448h case    3:*/		return 0x820D044C;
		  /* 820D044Ch */ case    4:  		/* mr R5, R31 */
		/* 820D044Ch case    4:*/		regs.R5 = regs.R31;
		/* 820D044Ch case    4:*/		return 0x820D0450;
		  /* 820D0450h */ case    5:  		/* mr R4, R26 */
		/* 820D0450h case    5:*/		regs.R4 = regs.R26;
		/* 820D0450h case    5:*/		return 0x820D0454;
		  /* 820D0454h */ case    6:  		/* mr R3, R27 */
		/* 820D0454h case    6:*/		regs.R3 = regs.R27;
		/* 820D0454h case    6:*/		return 0x820D0458;
		  /* 820D0458h */ case    7:  		/* bl -171368 */
		/* 820D0458h case    7:*/		regs.LR = 0x820D045C; return 0x820A66F0;
		/* 820D0458h case    7:*/		return 0x820D045C;
	}
	return 0x820D045C;
} // Block from 820D043Ch-820D045Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D045Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D045C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D045C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D045C);
		  /* 820D045Ch */ case    0:  		/* subf R11, R31, R29 */
		/* 820D045Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 820D045Ch case    0:*/		return 0x820D0460;
		  /* 820D0460h */ case    1:  		/* stbx R28, <#[R11 + R27]> */
		/* 820D0460h case    1:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 820D0460h case    1:*/		return 0x820D0464;
	}
	return 0x820D0464;
} // Block from 820D045Ch-820D0464h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0464);
		  /* 820D0464h */ case    0:  		/* cmplw CR6, R25, R30 */
		/* 820D0464h case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R30);
		/* 820D0464h case    0:*/		return 0x820D0468;
		  /* 820D0468h */ case    1:  		/* bc 12, CR6_GT, 20 */
		/* 820D0468h case    1:*/		if ( regs.CR[6].gt ) { return 0x820D047C;  }
		/* 820D0468h case    1:*/		return 0x820D046C;
		  /* 820D046Ch */ case    2:  		/* mr R5, R29 */
		/* 820D046Ch case    2:*/		regs.R5 = regs.R29;
		/* 820D046Ch case    2:*/		return 0x820D0470;
		  /* 820D0470h */ case    3:  		/* mr R4, R25 */
		/* 820D0470h case    3:*/		regs.R4 = regs.R25;
		/* 820D0470h case    3:*/		return 0x820D0474;
		  /* 820D0474h */ case    4:  		/* mr R3, R24 */
		/* 820D0474h case    4:*/		regs.R3 = regs.R24;
		/* 820D0474h case    4:*/		return 0x820D0478;
		  /* 820D0478h */ case    5:  		/* bl -171400 */
		/* 820D0478h case    5:*/		regs.LR = 0x820D047C; return 0x820A66F0;
		/* 820D0478h case    5:*/		return 0x820D047C;
	}
	return 0x820D047C;
} // Block from 820D0464h-820D047Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D047Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D047C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D047C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D047C);
		  /* 820D047Ch */ case    0:  		/* addi R1, R1, 160 */
		/* 820D047Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820D047Ch case    0:*/		return 0x820D0480;
		  /* 820D0480h */ case    1:  		/* b -258536 */
		/* 820D0480h case    1:*/		return 0x82091298;
		/* 820D0480h case    1:*/		return 0x820D0484;
		  /* 820D0484h */ case    2:  		/* nop */
		/* 820D0484h case    2:*/		cpu::op::nop();
		/* 820D0484h case    2:*/		return 0x820D0488;
	}
	return 0x820D0488;
} // Block from 820D047Ch-820D0488h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D0488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0488);
		  /* 820D0488h */ case    0:  		/* mfspr R12, LR */
		/* 820D0488h case    0:*/		regs.R12 = regs.LR;
		/* 820D0488h case    0:*/		return 0x820D048C;
		  /* 820D048Ch */ case    1:  		/* bl -258632 */
		/* 820D048Ch case    1:*/		regs.LR = 0x820D0490; return 0x82091244;
		/* 820D048Ch case    1:*/		return 0x820D0490;
		  /* 820D0490h */ case    2:  		/* stwu R1, <#[R1 - 432]> */
		/* 820D0490h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE50);
		/* 820D0490h case    2:*/		return 0x820D0494;
		  /* 820D0494h */ case    3:  		/* mr R26, R3 */
		/* 820D0494h case    3:*/		regs.R26 = regs.R3;
		/* 820D0494h case    3:*/		return 0x820D0498;
		  /* 820D0498h */ case    4:  		/* mr R30, R4 */
		/* 820D0498h case    4:*/		regs.R30 = regs.R4;
		/* 820D0498h case    4:*/		return 0x820D049C;
		  /* 820D049Ch */ case    5:  		/* mr R3, R5 */
		/* 820D049Ch case    5:*/		regs.R3 = regs.R5;
		/* 820D049Ch case    5:*/		return 0x820D04A0;
		  /* 820D04A0h */ case    6:  		/* mr R25, R6 */
		/* 820D04A0h case    6:*/		regs.R25 = regs.R6;
		/* 820D04A0h case    6:*/		return 0x820D04A4;
		  /* 820D04A4h */ case    7:  		/* addi R9, R1, 80 */
		/* 820D04A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 820D04A4h case    7:*/		return 0x820D04A8;
		  /* 820D04A8h */ case    8:  		/* addi R8, R1, 84 */
		/* 820D04A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x54);
		/* 820D04A8h case    8:*/		return 0x820D04AC;
		  /* 820D04ACh */ case    9:  		/* li R7, 128 */
		/* 820D04ACh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x80);
		/* 820D04ACh case    9:*/		return 0x820D04B0;
		  /* 820D04B0h */ case   10:  		/* addi R6, R1, 224 */
		/* 820D04B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xE0);
		/* 820D04B0h case   10:*/		return 0x820D04B4;
		  /* 820D04B4h */ case   11:  		/* li R5, 128 */
		/* 820D04B4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 820D04B4h case   11:*/		return 0x820D04B8;
		  /* 820D04B8h */ case   12:  		/* addi R4, R1, 96 */
		/* 820D04B8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820D04B8h case   12:*/		return 0x820D04BC;
		  /* 820D04BCh */ case   13:  		/* bl -428 */
		/* 820D04BCh case   13:*/		regs.LR = 0x820D04C0; return 0x820D0310;
		/* 820D04BCh case   13:*/		return 0x820D04C0;
		  /* 820D04C0h */ case   14:  		/* lwz R23, <#[R1 + 84]> */
		/* 820D04C0h case   14:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000054) );
		/* 820D04C0h case   14:*/		return 0x820D04C4;
		  /* 820D04C4h */ case   15:  		/* cmpwi CR6, R23, 2 */
		/* 820D04C4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000002);
		/* 820D04C4h case   15:*/		return 0x820D04C8;
		  /* 820D04C8h */ case   16:  		/* bc 4, CR6_EQ, 20 */
		/* 820D04C8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820D04DC;  }
		/* 820D04C8h case   16:*/		return 0x820D04CC;
		  /* 820D04CCh */ case   17:  		/* li R4, 128 */
		/* 820D04CCh case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x80);
		/* 820D04CCh case   17:*/		return 0x820D04D0;
		  /* 820D04D0h */ case   18:  		/* lwz R5, <#[R25]> */
		/* 820D04D0h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x00000000) );
		/* 820D04D0h case   18:*/		return 0x820D04D4;
		  /* 820D04D4h */ case   19:  		/* addi R3, R1, 96 */
		/* 820D04D4h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820D04D4h case   19:*/		return 0x820D04D8;
		  /* 820D04D8h */ case   20:  		/* bl -171496 */
		/* 820D04D8h case   20:*/		regs.LR = 0x820D04DC; return 0x820A66F0;
		/* 820D04D8h case   20:*/		return 0x820D04DC;
	}
	return 0x820D04DC;
} // Block from 820D0488h-820D04DCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820D04DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D04DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D04DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D04DC);
		  /* 820D04DCh */ case    0:  		/* lbz R11, <#[R1 + 224]> */
		/* 820D04DCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000E0) );
		/* 820D04DCh case    0:*/		return 0x820D04E0;
		  /* 820D04E0h */ case    1:  		/* li R27, 0 */
		/* 820D04E0h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820D04E0h case    1:*/		return 0x820D04E4;
		  /* 820D04E4h */ case    2:  		/* lwz R24, <#[R1 + 80]> */
		/* 820D04E4h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 820D04E4h case    2:*/		return 0x820D04E8;
		  /* 820D04E8h */ case    3:  		/* extsb. R5, R11 */
		/* 820D04E8h case    3:*/		cpu::op::extsb<1>(regs,&regs.R5,regs.R11);
		/* 820D04E8h case    3:*/		return 0x820D04EC;
		  /* 820D04ECh */ case    4:  		/* bc 12, CR0_EQ, 128 */
		/* 820D04ECh case    4:*/		if ( regs.CR[0].eq ) { return 0x820D056C;  }
		/* 820D04ECh case    4:*/		return 0x820D04F0;
		  /* 820D04F0h */ case    5:  		/* lwz R11, <#[R25 + 56]> */
		/* 820D04F0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 820D04F0h case    5:*/		return 0x820D04F4;
		  /* 820D04F4h */ case    6:  		/* mr R6, R27 */
		/* 820D04F4h case    6:*/		regs.R6 = regs.R27;
		/* 820D04F4h case    6:*/		return 0x820D04F8;
		  /* 820D04F8h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820D04F8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D04F8h case    7:*/		return 0x820D04FC;
		  /* 820D04FCh */ case    8:  		/* bc 4, CR6_GT, 112 */
		/* 820D04FCh case    8:*/		if ( !regs.CR[6].gt ) { return 0x820D056C;  }
		/* 820D04FCh case    8:*/		return 0x820D0500;
		  /* 820D0500h */ case    9:  		/* addi R7, R25, 60 */
		/* 820D0500h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R25,0x3C);
		/* 820D0500h case    9:*/		return 0x820D0504;
		  /* 820D0504h */ case   10:  		/* lwz R8, <#[R7]> */
		/* 820D0504h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 820D0504h case   10:*/		return 0x820D0508;
		  /* 820D0508h */ case   11:  		/* addi R11, R1, 96 */
		/* 820D0508h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820D0508h case   11:*/		return 0x820D050C;
		  /* 820D050Ch */ case   12:  		/* lwz R10, <#[R8]> */
		/* 820D050Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820D050Ch case   12:*/		return 0x820D0510;
		  /* 820D0510h */ case   13:  		/* lbz R9, <#[R11]> */
		/* 820D0510h case   13:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0510h case   13:*/		return 0x820D0514;
		  /* 820D0514h */ case   14:  		/* lbz R4, <#[R10]> */
		/* 820D0514h case   14:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0514h case   14:*/		return 0x820D0518;
		  /* 820D0518h */ case   15:  		/* cmpwi CR0, R9, 0 */
		/* 820D0518h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0518h case   15:*/		return 0x820D051C;
		  /* 820D051Ch */ case   16:  		/* subf R9, R4, R9 */
		/* 820D051Ch case   16:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 820D051Ch case   16:*/		return 0x820D0520;
		  /* 820D0520h */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0520h case   17:*/		if ( regs.CR[0].eq ) { return 0x820D0534;  }
		/* 820D0520h case   17:*/		return 0x820D0524;
		  /* 820D0524h */ case   18:  		/* addi R11, R11, 1 */
		/* 820D0524h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0524h case   18:*/		return 0x820D0528;
		  /* 820D0528h */ case   19:  		/* addi R10, R10, 1 */
		/* 820D0528h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0528h case   19:*/		return 0x820D052C;
		  /* 820D052Ch */ case   20:  		/* cmpwi CR6, R9, 0 */
		/* 820D052Ch case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D052Ch case   20:*/		return 0x820D0530;
		  /* 820D0530h */ case   21:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0530h case   21:*/		if ( regs.CR[6].eq ) { return 0x820D0510;  }
		/* 820D0530h case   21:*/		return 0x820D0534;
	}
	return 0x820D0534;
} // Block from 820D04DCh-820D0534h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820D0534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0534);
		  /* 820D0534h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D0534h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0534h case    0:*/		return 0x820D0538;
		  /* 820D0538h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 820D0538h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0558;  }
		/* 820D0538h case    1:*/		return 0x820D053C;
		  /* 820D053Ch */ case    2:  		/* lwz R11, <#[R8 + 52]> */
		/* 820D053Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000034) );
		/* 820D053Ch case    2:*/		return 0x820D0540;
		  /* 820D0540h */ case    3:  		/* cmplw CR6, R11, R24 */
		/* 820D0540h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820D0540h case    3:*/		return 0x820D0544;
		  /* 820D0544h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 820D0544h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D0558;  }
		/* 820D0544h case    4:*/		return 0x820D0548;
		  /* 820D0548h */ case    5:  		/* lwz R11, <#[R8 + 4]> */
		/* 820D0548h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820D0548h case    5:*/		return 0x820D054C;
		  /* 820D054Ch */ case    6:  		/* lwz R10, <#[R30 + 4]> */
		/* 820D054Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 820D054Ch case    6:*/		return 0x820D0550;
		  /* 820D0550h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820D0550h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820D0550h case    7:*/		return 0x820D0554;
		  /* 820D0554h */ case    8:  		/* bc 12, CR6_EQ, 248 */
		/* 820D0554h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D064C;  }
		/* 820D0554h case    8:*/		return 0x820D0558;
	}
	return 0x820D0558;
} // Block from 820D0534h-820D0558h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D0558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0558);
		  /* 820D0558h */ case    0:  		/* lwz R11, <#[R25 + 56]> */
		/* 820D0558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 820D0558h case    0:*/		return 0x820D055C;
		  /* 820D055Ch */ case    1:  		/* addi R6, R6, 1 */
		/* 820D055Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820D055Ch case    1:*/		return 0x820D0560;
		  /* 820D0560h */ case    2:  		/* addi R7, R7, 4 */
		/* 820D0560h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820D0560h case    2:*/		return 0x820D0564;
		  /* 820D0564h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 820D0564h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820D0564h case    3:*/		return 0x820D0568;
		  /* 820D0568h */ case    4:  		/* bc 12, CR6_LT, -100 */
		/* 820D0568h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D0504;  }
		/* 820D0568h case    4:*/		return 0x820D056C;
	}
	return 0x820D056C;
} // Block from 820D0558h-820D056Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D056Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D056C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D056C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D056C);
		  /* 820D056Ch */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 820D056Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820D056Ch case    0:*/		return 0x820D0570;
		  /* 820D0570h */ case    1:  		/* lwz R3, <#[R26 + 4]> */
		/* 820D0570h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000004) );
		/* 820D0570h case    1:*/		return 0x820D0574;
		  /* 820D0574h */ case    2:  		/* li R5, 4 */
		/* 820D0574h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D0574h case    2:*/		return 0x820D0578;
		  /* 820D0578h */ case    3:  		/* li R4, 1084 */
		/* 820D0578h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x43C);
		/* 820D0578h case    3:*/		return 0x820D057C;
		  /* 820D057Ch */ case    4:  		/* bc 12, CR6_EQ, 240 */
		/* 820D057Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820D066C;  }
		/* 820D057Ch case    4:*/		return 0x820D0580;
		  /* 820D0580h */ case    5:  		/* bl -29856 */
		/* 820D0580h case    5:*/		regs.LR = 0x820D0584; return 0x820C90E0;
		/* 820D0580h case    5:*/		return 0x820D0584;
		  /* 820D0584h */ case    6:  		/* addi R11, R1, 96 */
		/* 820D0584h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820D0584h case    6:*/		return 0x820D0588;
		  /* 820D0588h */ case    7:  		/* mr R31, R3 */
		/* 820D0588h case    7:*/		regs.R31 = regs.R3;
		/* 820D0588h case    7:*/		return 0x820D058C;
		  /* 820D058Ch */ case    8:  		/* mr R10, R11 */
		/* 820D058Ch case    8:*/		regs.R10 = regs.R11;
		/* 820D058Ch case    8:*/		return 0x820D0590;
		  /* 820D0590h */ case    9:  		/* lbz R9, <#[R11]> */
		/* 820D0590h case    9:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0590h case    9:*/		return 0x820D0594;
		  /* 820D0594h */ case   10:  		/* addi R11, R11, 1 */
		/* 820D0594h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0594h case   10:*/		return 0x820D0598;
		  /* 820D0598h */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 820D0598h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D0598h case   11:*/		return 0x820D059C;
		  /* 820D059Ch */ case   12:  		/* bc 4, CR6_EQ, -12 */
		/* 820D059Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820D0590;  }
		/* 820D059Ch case   12:*/		return 0x820D05A0;
		  /* 820D05A0h */ case   13:  		/* subf R11, R10, R11 */
		/* 820D05A0h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D05A0h case   13:*/		return 0x820D05A4;
		  /* 820D05A4h */ case   14:  		/* lwz R3, <#[R26 + 4]> */
		/* 820D05A4h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000004) );
		/* 820D05A4h case   14:*/		return 0x820D05A8;
		  /* 820D05A8h */ case   15:  		/* li R5, 16 */
		/* 820D05A8h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820D05A8h case   15:*/		return 0x820D05AC;
		  /* 820D05ACh */ case   16:  		/* addi R11, R11, -1 */
		/* 820D05ACh case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D05ACh case   16:*/		return 0x820D05B0;
		  /* 820D05B0h */ case   17:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820D05B0h case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820D05B0h case   17:*/		return 0x820D05B4;
		  /* 820D05B4h */ case   18:  		/* addi R29, R11, 1 */
		/* 820D05B4h case   18:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 820D05B4h case   18:*/		return 0x820D05B8;
		  /* 820D05B8h */ case   19:  		/* mr R4, R29 */
		/* 820D05B8h case   19:*/		regs.R4 = regs.R29;
		/* 820D05B8h case   19:*/		return 0x820D05BC;
		  /* 820D05BCh */ case   20:  		/* bl -29916 */
		/* 820D05BCh case   20:*/		regs.LR = 0x820D05C0; return 0x820C90E0;
		/* 820D05BCh case   20:*/		return 0x820D05C0;
		  /* 820D05C0h */ case   21:  		/* lis R11, 32767 */
		/* 820D05C0h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820D05C0h case   21:*/		return 0x820D05C4;
		  /* 820D05C4h */ case   22:  		/* mr R28, R3 */
		/* 820D05C4h case   22:*/		regs.R28 = regs.R3;
		/* 820D05C4h case   22:*/		return 0x820D05C8;
		  /* 820D05C8h */ case   23:  		/* ori R11, R11, 65535 */
		/* 820D05C8h case   23:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 820D05C8h case   23:*/		return 0x820D05CC;
		  /* 820D05CCh */ case   24:  		/* cmplw CR6, R29, R11 */
		/* 820D05CCh case   24:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820D05CCh case   24:*/		return 0x820D05D0;
		  /* 820D05D0h */ case   25:  		/* bc 12, CR6_GT, 16 */
		/* 820D05D0h case   25:*/		if ( regs.CR[6].gt ) { return 0x820D05E0;  }
		/* 820D05D0h case   25:*/		return 0x820D05D4;
		  /* 820D05D4h */ case   26:  		/* addi R5, R1, 96 */
		/* 820D05D4h case   26:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 820D05D4h case   26:*/		return 0x820D05D8;
		  /* 820D05D8h */ case   27:  		/* mr R4, R29 */
		/* 820D05D8h case   27:*/		regs.R4 = regs.R29;
		/* 820D05D8h case   27:*/		return 0x820D05DC;
		  /* 820D05DCh */ case   28:  		/* bl -171756 */
		/* 820D05DCh case   28:*/		regs.LR = 0x820D05E0; return 0x820A66F0;
		/* 820D05DCh case   28:*/		return 0x820D05E0;
	}
	return 0x820D05E0;
} // Block from 820D056Ch-820D05E0h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820D05E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D05E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D05E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D05E0);
		  /* 820D05E0h */ case    0:  		/* li R11, -1 */
		/* 820D05E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D05E0h case    0:*/		return 0x820D05E4;
		  /* 820D05E4h */ case    1:  		/* stw R28, <#[R31]> */
		/* 820D05E4h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 820D05E4h case    1:*/		return 0x820D05E8;
		  /* 820D05E8h */ case    2:  		/* li R9, 1 */
		/* 820D05E8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820D05E8h case    2:*/		return 0x820D05EC;
		  /* 820D05ECh */ case    3:  		/* stw R24, <#[R31 + 52]> */
		/* 820D05ECh case    3:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000034) );
		/* 820D05ECh case    3:*/		return 0x820D05F0;
		  /* 820D05F0h */ case    4:  		/* li R10, -1 */
		/* 820D05F0h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820D05F0h case    4:*/		return 0x820D05F4;
		  /* 820D05F4h */ case    5:  		/* stw R23, <#[R31 + 48]> */
		/* 820D05F4h case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000030) );
		/* 820D05F4h case    5:*/		return 0x820D05F8;
		  /* 820D05F8h */ case    6:  		/* stw R27, <#[R31 + 56]> */
		/* 820D05F8h case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000038) );
		/* 820D05F8h case    6:*/		return 0x820D05FC;
		  /* 820D05FCh */ case    7:  		/* mr R6, R31 */
		/* 820D05FCh case    7:*/		regs.R6 = regs.R31;
		/* 820D05FCh case    7:*/		return 0x820D0600;
		  /* 820D0600h */ case    8:  		/* stw R27, <#[R31 + 40]> */
		/* 820D0600h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000028) );
		/* 820D0600h case    8:*/		return 0x820D0604;
		  /* 820D0604h */ case    9:  		/* addi R5, R1, 224 */
		/* 820D0604h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xE0);
		/* 820D0604h case    9:*/		return 0x820D0608;
		  /* 820D0608h */ case   10:  		/* stw R27, <#[R31 + 24]> */
		/* 820D0608h case   10:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000018) );
		/* 820D0608h case   10:*/		return 0x820D060C;
		  /* 820D060Ch */ case   11:  		/* mr R4, R30 */
		/* 820D060Ch case   11:*/		regs.R4 = regs.R30;
		/* 820D060Ch case   11:*/		return 0x820D0610;
		  /* 820D0610h */ case   12:  		/* stw R27, <#[R31 + 28]> */
		/* 820D0610h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000001C) );
		/* 820D0610h case   12:*/		return 0x820D0614;
		  /* 820D0614h */ case   13:  		/* mr R3, R26 */
		/* 820D0614h case   13:*/		regs.R3 = regs.R26;
		/* 820D0614h case   13:*/		return 0x820D0618;
		  /* 820D0618h */ case   14:  		/* stw R27, <#[R31 + 44]> */
		/* 820D0618h case   14:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D0618h case   14:*/		return 0x820D061C;
		  /* 820D061Ch */ case   15:  		/* stw R9, <#[R31 + 32]> */
		/* 820D061Ch case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 820D061Ch case   15:*/		return 0x820D0620;
		  /* 820D0620h */ case   16:  		/* stw R11, <#[R31 + 12]> */
		/* 820D0620h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D0620h case   16:*/		return 0x820D0624;
		  /* 820D0624h */ case   17:  		/* stw R11, <#[R31 + 8]> */
		/* 820D0624h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820D0624h case   17:*/		return 0x820D0628;
		  /* 820D0628h */ case   18:  		/* lwz R11, <#[R30 + 4]> */
		/* 820D0628h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820D0628h case   18:*/		return 0x820D062C;
		  /* 820D062Ch */ case   19:  		/* stw R11, <#[R31 + 4]> */
		/* 820D062Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820D062Ch case   19:*/		return 0x820D0630;
		  /* 820D0630h */ case   20:  		/* stw R10, <#[R31 + 16]> */
		/* 820D0630h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820D0630h case   20:*/		return 0x820D0634;
		  /* 820D0634h */ case   21:  		/* stw R10, <#[R31 + 20]> */
		/* 820D0634h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820D0634h case   21:*/		return 0x820D0638;
		  /* 820D0638h */ case   22:  		/* stw R27, <#[R31 + 36]> */
		/* 820D0638h case   22:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000024) );
		/* 820D0638h case   22:*/		return 0x820D063C;
		  /* 820D063Ch */ case   23:  		/* bl -436 */
		/* 820D063Ch case   23:*/		regs.LR = 0x820D0640; return 0x820D0488;
		/* 820D063Ch case   23:*/		return 0x820D0640;
		  /* 820D0640h */ case   24:  		/* cmpwi CR6, R3, -1 */
		/* 820D0640h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820D0640h case   24:*/		return 0x820D0644;
		  /* 820D0644h */ case   25:  		/* bc 4, CR6_EQ, 236 */
		/* 820D0644h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820D0730;  }
		/* 820D0644h case   25:*/		return 0x820D0648;
		  /* 820D0648h */ case   26:  		/* b 264 */
		/* 820D0648h case   26:*/		return 0x820D0750;
		/* 820D0648h case   26:*/		return 0x820D064C;
	}
	return 0x820D064C;
} // Block from 820D05E0h-820D064Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820D064Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D064C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D064C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D064C);
		  /* 820D064Ch */ case    0:  		/* addi R11, R6, 15 */
		/* 820D064Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xF);
		/* 820D064Ch case    0:*/		return 0x820D0650;
		  /* 820D0650h */ case    1:  		/* addi R5, R1, 224 */
		/* 820D0650h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xE0);
		/* 820D0650h case    1:*/		return 0x820D0654;
		  /* 820D0654h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820D0654h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820D0654h case    2:*/		return 0x820D0658;
		  /* 820D0658h */ case    3:  		/* mr R4, R30 */
		/* 820D0658h case    3:*/		regs.R4 = regs.R30;
		/* 820D0658h case    3:*/		return 0x820D065C;
		  /* 820D065Ch */ case    4:  		/* mr R3, R26 */
		/* 820D065Ch case    4:*/		regs.R3 = regs.R26;
		/* 820D065Ch case    4:*/		return 0x820D0660;
		  /* 820D0660h */ case    5:  		/* lwzx R6, <#[R11 + R25]> */
		/* 820D0660h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820D0660h case    5:*/		return 0x820D0664;
		  /* 820D0664h */ case    6:  		/* bl -476 */
		/* 820D0664h case    6:*/		regs.LR = 0x820D0668; return 0x820D0488;
		/* 820D0664h case    6:*/		return 0x820D0668;
		  /* 820D0668h */ case    7:  		/* b 232 */
		/* 820D0668h case    7:*/		return 0x820D0750;
		/* 820D0668h case    7:*/		return 0x820D066C;
	}
	return 0x820D066C;
} // Block from 820D064Ch-820D066Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D066Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D066C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D066C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D066C);
		  /* 820D066Ch */ case    0:  		/* bl -30092 */
		/* 820D066Ch case    0:*/		regs.LR = 0x820D0670; return 0x820C90E0;
		/* 820D066Ch case    0:*/		return 0x820D0670;
		  /* 820D0670h */ case    1:  		/* addi R11, R1, 96 */
		/* 820D0670h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820D0670h case    1:*/		return 0x820D0674;
		  /* 820D0674h */ case    2:  		/* mr R31, R3 */
		/* 820D0674h case    2:*/		regs.R31 = regs.R3;
		/* 820D0674h case    2:*/		return 0x820D0678;
		  /* 820D0678h */ case    3:  		/* mr R10, R11 */
		/* 820D0678h case    3:*/		regs.R10 = regs.R11;
		/* 820D0678h case    3:*/		return 0x820D067C;
		  /* 820D067Ch */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820D067Ch case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D067Ch case    4:*/		return 0x820D0680;
		  /* 820D0680h */ case    5:  		/* addi R11, R11, 1 */
		/* 820D0680h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0680h case    5:*/		return 0x820D0684;
		  /* 820D0684h */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 820D0684h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D0684h case    6:*/		return 0x820D0688;
		  /* 820D0688h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 820D0688h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D067C;  }
		/* 820D0688h case    7:*/		return 0x820D068C;
		  /* 820D068Ch */ case    8:  		/* subf R11, R10, R11 */
		/* 820D068Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D068Ch case    8:*/		return 0x820D0690;
		  /* 820D0690h */ case    9:  		/* lwz R3, <#[R26 + 4]> */
		/* 820D0690h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000004) );
		/* 820D0690h case    9:*/		return 0x820D0694;
		  /* 820D0694h */ case   10:  		/* li R5, 16 */
		/* 820D0694h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820D0694h case   10:*/		return 0x820D0698;
		  /* 820D0698h */ case   11:  		/* addi R11, R11, -1 */
		/* 820D0698h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D0698h case   11:*/		return 0x820D069C;
		  /* 820D069Ch */ case   12:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820D069Ch case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820D069Ch case   12:*/		return 0x820D06A0;
		  /* 820D06A0h */ case   13:  		/* addi R29, R11, 1 */
		/* 820D06A0h case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 820D06A0h case   13:*/		return 0x820D06A4;
		  /* 820D06A4h */ case   14:  		/* mr R4, R29 */
		/* 820D06A4h case   14:*/		regs.R4 = regs.R29;
		/* 820D06A4h case   14:*/		return 0x820D06A8;
		  /* 820D06A8h */ case   15:  		/* bl -30152 */
		/* 820D06A8h case   15:*/		regs.LR = 0x820D06AC; return 0x820C90E0;
		/* 820D06A8h case   15:*/		return 0x820D06AC;
		  /* 820D06ACh */ case   16:  		/* lis R11, 32767 */
		/* 820D06ACh case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 820D06ACh case   16:*/		return 0x820D06B0;
		  /* 820D06B0h */ case   17:  		/* mr R28, R3 */
		/* 820D06B0h case   17:*/		regs.R28 = regs.R3;
		/* 820D06B0h case   17:*/		return 0x820D06B4;
		  /* 820D06B4h */ case   18:  		/* ori R11, R11, 65535 */
		/* 820D06B4h case   18:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 820D06B4h case   18:*/		return 0x820D06B8;
		  /* 820D06B8h */ case   19:  		/* cmplw CR6, R29, R11 */
		/* 820D06B8h case   19:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820D06B8h case   19:*/		return 0x820D06BC;
		  /* 820D06BCh */ case   20:  		/* bc 12, CR6_GT, 16 */
		/* 820D06BCh case   20:*/		if ( regs.CR[6].gt ) { return 0x820D06CC;  }
		/* 820D06BCh case   20:*/		return 0x820D06C0;
		  /* 820D06C0h */ case   21:  		/* addi R5, R1, 96 */
		/* 820D06C0h case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 820D06C0h case   21:*/		return 0x820D06C4;
		  /* 820D06C4h */ case   22:  		/* mr R4, R29 */
		/* 820D06C4h case   22:*/		regs.R4 = regs.R29;
		/* 820D06C4h case   22:*/		return 0x820D06C8;
		  /* 820D06C8h */ case   23:  		/* bl -171992 */
		/* 820D06C8h case   23:*/		regs.LR = 0x820D06CC; return 0x820A66F0;
		/* 820D06C8h case   23:*/		return 0x820D06CC;
	}
	return 0x820D06CC;
} // Block from 820D066Ch-820D06CCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 820D06CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D06CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D06CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D06CC);
		  /* 820D06CCh */ case    0:  		/* stw R28, <#[R31]> */
		/* 820D06CCh case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 820D06CCh case    0:*/		return 0x820D06D0;
		  /* 820D06D0h */ case    1:  		/* li R11, 1 */
		/* 820D06D0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D06D0h case    1:*/		return 0x820D06D4;
		  /* 820D06D4h */ case    2:  		/* stw R24, <#[R31 + 52]> */
		/* 820D06D4h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000034) );
		/* 820D06D4h case    2:*/		return 0x820D06D8;
		  /* 820D06D8h */ case    3:  		/* stw R23, <#[R31 + 48]> */
		/* 820D06D8h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000030) );
		/* 820D06D8h case    3:*/		return 0x820D06DC;
		  /* 820D06DCh */ case    4:  		/* stw R27, <#[R31 + 56]> */
		/* 820D06DCh case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000038) );
		/* 820D06DCh case    4:*/		return 0x820D06E0;
		  /* 820D06E0h */ case    5:  		/* lwz R10, <#[R30 + 4]> */
		/* 820D06E0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 820D06E0h case    5:*/		return 0x820D06E4;
		  /* 820D06E4h */ case    6:  		/* stw R10, <#[R31 + 4]> */
		/* 820D06E4h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820D06E4h case    6:*/		return 0x820D06E8;
		  /* 820D06E8h */ case    7:  		/* lwz R10, <#[R30 + 40]> */
		/* 820D06E8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 820D06E8h case    7:*/		return 0x820D06EC;
		  /* 820D06ECh */ case    8:  		/* stw R10, <#[R31 + 40]> */
		/* 820D06ECh case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820D06ECh case    8:*/		return 0x820D06F0;
		  /* 820D06F0h */ case    9:  		/* lwz R10, <#[R30 + 24]> */
		/* 820D06F0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 820D06F0h case    9:*/		return 0x820D06F4;
		  /* 820D06F4h */ case   10:  		/* stw R10, <#[R31 + 24]> */
		/* 820D06F4h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820D06F4h case   10:*/		return 0x820D06F8;
		  /* 820D06F8h */ case   11:  		/* lwz R10, <#[R30 + 28]> */
		/* 820D06F8h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 820D06F8h case   11:*/		return 0x820D06FC;
		  /* 820D06FCh */ case   12:  		/* stw R10, <#[R31 + 28]> */
		/* 820D06FCh case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820D06FCh case   12:*/		return 0x820D0700;
		  /* 820D0700h */ case   13:  		/* lwz R10, <#[R30 + 44]> */
		/* 820D0700h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 820D0700h case   13:*/		return 0x820D0704;
		  /* 820D0704h */ case   14:  		/* stw R10, <#[R31 + 44]> */
		/* 820D0704h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D0704h case   14:*/		return 0x820D0708;
		  /* 820D0708h */ case   15:  		/* stw R11, <#[R31 + 32]> */
		/* 820D0708h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820D0708h case   15:*/		return 0x820D070C;
		  /* 820D070Ch */ case   16:  		/* lwz R11, <#[R30 + 12]> */
		/* 820D070Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820D070Ch case   16:*/		return 0x820D0710;
		  /* 820D0710h */ case   17:  		/* stw R11, <#[R31 + 12]> */
		/* 820D0710h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D0710h case   17:*/		return 0x820D0714;
		  /* 820D0714h */ case   18:  		/* lwz R11, <#[R30 + 8]> */
		/* 820D0714h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820D0714h case   18:*/		return 0x820D0718;
		  /* 820D0718h */ case   19:  		/* stw R11, <#[R31 + 8]> */
		/* 820D0718h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820D0718h case   19:*/		return 0x820D071C;
		  /* 820D071Ch */ case   20:  		/* stw R27, <#[R31 + 36]> */
		/* 820D071Ch case   20:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000024) );
		/* 820D071Ch case   20:*/		return 0x820D0720;
		  /* 820D0720h */ case   21:  		/* lwz R11, <#[R30 + 16]> */
		/* 820D0720h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820D0720h case   21:*/		return 0x820D0724;
		  /* 820D0724h */ case   22:  		/* stw R11, <#[R31 + 16]> */
		/* 820D0724h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820D0724h case   22:*/		return 0x820D0728;
		  /* 820D0728h */ case   23:  		/* lwz R11, <#[R30 + 20]> */
		/* 820D0728h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820D0728h case   23:*/		return 0x820D072C;
		  /* 820D072Ch */ case   24:  		/* stw R11, <#[R31 + 20]> */
		/* 820D072Ch case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820D072Ch case   24:*/		return 0x820D0730;
	}
	return 0x820D0730;
} // Block from 820D06CCh-820D0730h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820D0730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0730);
		  /* 820D0730h */ case    0:  		/* lwz R11, <#[R25 + 56]> */
		/* 820D0730h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 820D0730h case    0:*/		return 0x820D0734;
		  /* 820D0734h */ case    1:  		/* li R3, 1 */
		/* 820D0734h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820D0734h case    1:*/		return 0x820D0738;
		  /* 820D0738h */ case    2:  		/* addi R11, R11, 15 */
		/* 820D0738h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xF);
		/* 820D0738h case    2:*/		return 0x820D073C;
		  /* 820D073Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820D073Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820D073Ch case    3:*/		return 0x820D0740;
		  /* 820D0740h */ case    4:  		/* stwx R31, <#[R11 + R25]> */
		/* 820D0740h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820D0740h case    4:*/		return 0x820D0744;
		  /* 820D0744h */ case    5:  		/* lwz R11, <#[R25 + 56]> */
		/* 820D0744h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 820D0744h case    5:*/		return 0x820D0748;
		  /* 820D0748h */ case    6:  		/* addi R11, R11, 1 */
		/* 820D0748h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0748h case    6:*/		return 0x820D074C;
		  /* 820D074Ch */ case    7:  		/* stw R11, <#[R25 + 56]> */
		/* 820D074Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 820D074Ch case    7:*/		return 0x820D0750;
	}
	return 0x820D0750;
} // Block from 820D0730h-820D0750h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D0750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0750);
		  /* 820D0750h */ case    0:  		/* addi R1, R1, 432 */
		/* 820D0750h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1B0);
		/* 820D0750h case    0:*/		return 0x820D0754;
		  /* 820D0754h */ case    1:  		/* b -259264 */
		/* 820D0754h case    1:*/		return 0x82091294;
		/* 820D0754h case    1:*/		return 0x820D0758;
	}
	return 0x820D0758;
} // Block from 820D0750h-820D0758h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0758);
		  /* 820D0758h */ case    0:  		/* mfspr R12, LR */
		/* 820D0758h case    0:*/		regs.R12 = regs.LR;
		/* 820D0758h case    0:*/		return 0x820D075C;
		  /* 820D075Ch */ case    1:  		/* bl -259364 */
		/* 820D075Ch case    1:*/		regs.LR = 0x820D0760; return 0x82091238;
		/* 820D075Ch case    1:*/		return 0x820D0760;
		  /* 820D0760h */ case    2:  		/* stwu R1, <#[R1 - 2256]> */
		/* 820D0760h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF730) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF730);
		/* 820D0760h case    2:*/		return 0x820D0764;
		  /* 820D0764h */ case    3:  		/* mr R24, R6 */
		/* 820D0764h case    3:*/		regs.R24 = regs.R6;
		/* 820D0764h case    3:*/		return 0x820D0768;
		  /* 820D0768h */ case    4:  		/* lwz R11, <#[R3 + 32]> */
		/* 820D0768h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820D0768h case    4:*/		return 0x820D076C;
		  /* 820D076Ch */ case    5:  		/* mr R23, R7 */
		/* 820D076Ch case    5:*/		regs.R23 = regs.R7;
		/* 820D076Ch case    5:*/		return 0x820D0770;
		  /* 820D0770h */ case    6:  		/* lwz R7, <#[R3 + 24]> */
		/* 820D0770h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000018) );
		/* 820D0770h case    6:*/		return 0x820D0774;
		  /* 820D0774h */ case    7:  		/* mr R26, R9 */
		/* 820D0774h case    7:*/		regs.R26 = regs.R9;
		/* 820D0774h case    7:*/		return 0x820D0778;
		  /* 820D0778h */ case    8:  		/* lwz R9, <#[R3 + 20]> */
		/* 820D0778h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 820D0778h case    8:*/		return 0x820D077C;
		  /* 820D077Ch */ case    9:  		/* mr R25, R10 */
		/* 820D077Ch case    9:*/		regs.R25 = regs.R10;
		/* 820D077Ch case    9:*/		return 0x820D0780;
		  /* 820D0780h */ case   10:  		/* lwz R10, <#[R3 + 16]> */
		/* 820D0780h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820D0780h case   10:*/		return 0x820D0784;
		  /* 820D0784h */ case   11:  		/* lwz R6, <#[R3 + 28]> */
		/* 820D0784h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x0000001C) );
		/* 820D0784h case   11:*/		return 0x820D0788;
		  /* 820D0788h */ case   12:  		/* mr R31, R3 */
		/* 820D0788h case   12:*/		regs.R31 = regs.R3;
		/* 820D0788h case   12:*/		return 0x820D078C;
		  /* 820D078Ch */ case   13:  		/* mr R22, R4 */
		/* 820D078Ch case   13:*/		regs.R22 = regs.R4;
		/* 820D078Ch case   13:*/		return 0x820D0790;
		  /* 820D0790h */ case   14:  		/* sth R11, <#[R1 + 88]> */
		/* 820D0790h case   14:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820D0790h case   14:*/		return 0x820D0794;
		  /* 820D0794h */ case   15:  		/* mr R21, R5 */
		/* 820D0794h case   15:*/		regs.R21 = regs.R5;
		/* 820D0794h case   15:*/		return 0x820D0798;
		  /* 820D0798h */ case   16:  		/* sth R7, <#[R1 + 84]> */
		/* 820D0798h case   16:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 820D0798h case   16:*/		return 0x820D079C;
		  /* 820D079Ch */ case   17:  		/* mr R27, R8 */
		/* 820D079Ch case   17:*/		regs.R27 = regs.R8;
		/* 820D079Ch case   17:*/		return 0x820D07A0;
		  /* 820D07A0h */ case   18:  		/* sth R9, <#[R1 + 82]> */
		/* 820D07A0h case   18:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000052) );
		/* 820D07A0h case   18:*/		return 0x820D07A4;
		  /* 820D07A4h */ case   19:  		/* sth R10, <#[R1 + 80]> */
		/* 820D07A4h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820D07A4h case   19:*/		return 0x820D07A8;
		  /* 820D07A8h */ case   20:  		/* cmplwi CR6, R11, 1 */
		/* 820D07A8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D07A8h case   20:*/		return 0x820D07AC;
		  /* 820D07ACh */ case   21:  		/* sth R6, <#[R1 + 86]> */
		/* 820D07ACh case   21:*/		cpu::mem::store16( regs, regs.R6, (uint32)(regs.R1 + 0x00000056) );
		/* 820D07ACh case   21:*/		return 0x820D07B0;
		  /* 820D07B0h */ case   22:  		/* bc 4, CR6_EQ, 28 */
		/* 820D07B0h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820D07CC;  }
		/* 820D07B0h case   22:*/		return 0x820D07B4;
		  /* 820D07B4h */ case   23:  		/* lwz R11, <#[R3 + 36]> */
		/* 820D07B4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820D07B4h case   23:*/		return 0x820D07B8;
		  /* 820D07B8h */ case   24:  		/* cmplwi CR6, R11, 0 */
		/* 820D07B8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D07B8h case   24:*/		return 0x820D07BC;
		  /* 820D07BCh */ case   25:  		/* bc 4, CR6_EQ, 20 */
		/* 820D07BCh case   25:*/		if ( !regs.CR[6].eq ) { return 0x820D07D0;  }
		/* 820D07BCh case   25:*/		return 0x820D07C0;
		  /* 820D07C0h */ case   26:  		/* lwz R11, <#[R3 + 56]> */
		/* 820D07C0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820D07C0h case   26:*/		return 0x820D07C4;
		  /* 820D07C4h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 820D07C4h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D07C4h case   27:*/		return 0x820D07C8;
		  /* 820D07C8h */ case   28:  		/* bc 12, CR6_EQ, 8 */
		/* 820D07C8h case   28:*/		if ( regs.CR[6].eq ) { return 0x820D07D0;  }
		/* 820D07C8h case   28:*/		return 0x820D07CC;
	}
	return 0x820D07CC;
} // Block from 820D0758h-820D07CCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 820D07CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D07CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D07CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D07CC);
		  /* 820D07CCh */ case    0:  		/* lwz R31, <#[R31 + 60]> */
		/* 820D07CCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000003C) );
		/* 820D07CCh case    0:*/		return 0x820D07D0;
	}
	return 0x820D07D0;
} // Block from 820D07CCh-820D07D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D07D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D07D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D07D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D07D0);
		  /* 820D07D0h */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 820D07D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820D07D0h case    0:*/		return 0x820D07D4;
		  /* 820D07D4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D07D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D07D4h case    1:*/		return 0x820D07D8;
		  /* 820D07D8h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820D07D8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D07E8;  }
		/* 820D07D8h case    2:*/		return 0x820D07DC;
		  /* 820D07DCh */ case    3:  		/* sth R11, <#[R1 + 90]> */
		/* 820D07DCh case    3:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000005A) );
		/* 820D07DCh case    3:*/		return 0x820D07E0;
		  /* 820D07E0h */ case    4:  		/* stw R11, <#[R1 + 92]> */
		/* 820D07E0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820D07E0h case    4:*/		return 0x820D07E4;
		  /* 820D07E4h */ case    5:  		/* b 152 */
		/* 820D07E4h case    5:*/		return 0x820D087C;
		/* 820D07E4h case    5:*/		return 0x820D07E8;
	}
	return 0x820D07E8;
} // Block from 820D07D0h-820D07E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D07E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D07E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D07E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D07E8);
		  /* 820D07E8h */ case    0:  		/* lwz R10, <#[R31 + 56]> */
		/* 820D07E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 820D07E8h case    0:*/		return 0x820D07EC;
		  /* 820D07ECh */ case    1:  		/* rlwinm R20, R11, 0, 16, 31 */
		/* 820D07ECh case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R20,regs.R11);
		/* 820D07ECh case    1:*/		return 0x820D07F0;
		  /* 820D07F0h */ case    2:  		/* li R28, 0 */
		/* 820D07F0h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820D07F0h case    2:*/		return 0x820D07F4;
		  /* 820D07F4h */ case    3:  		/* sth R20, <#[R1 + 90]> */
		/* 820D07F4h case    3:*/		cpu::mem::store16( regs, regs.R20, (uint32)(regs.R1 + 0x0000005A) );
		/* 820D07F4h case    3:*/		return 0x820D07F8;
		  /* 820D07F8h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820D07F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D07F8h case    4:*/		return 0x820D07FC;
		  /* 820D07FCh */ case    5:  		/* bc 4, CR6_GT, 104 */
		/* 820D07FCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x820D0864;  }
		/* 820D07FCh case    5:*/		return 0x820D0800;
		  /* 820D0800h */ case    6:  		/* addi R11, R1, 100 */
		/* 820D0800h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x64);
		/* 820D0800h case    6:*/		return 0x820D0804;
		  /* 820D0804h */ case    7:  		/* addi R30, R31, 56 */
		/* 820D0804h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x38);
		/* 820D0804h case    7:*/		return 0x820D0808;
		  /* 820D0808h */ case    8:  		/* addi R29, R11, -8 */
		/* 820D0808h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFF8);
		/* 820D0808h case    8:*/		return 0x820D080C;
		  /* 820D080Ch */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 820D080Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820D080Ch case    9:*/		return 0x820D0810;
		  /* 820D0810h */ case   10:  		/* mr R6, R25 */
		/* 820D0810h case   10:*/		regs.R6 = regs.R25;
		/* 820D0810h case   10:*/		return 0x820D0814;
		  /* 820D0814h */ case   11:  		/* mr R5, R26 */
		/* 820D0814h case   11:*/		regs.R5 = regs.R26;
		/* 820D0814h case   11:*/		return 0x820D0818;
		  /* 820D0818h */ case   12:  		/* mr R4, R27 */
		/* 820D0818h case   12:*/		regs.R4 = regs.R27;
		/* 820D0818h case   12:*/		return 0x820D081C;
		  /* 820D081Ch */ case   13:  		/* lwz R3, <#[R11]> */
		/* 820D081Ch case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 820D081Ch case   13:*/		return 0x820D0820;
		  /* 820D0820h */ case   14:  		/* bl -1536 */
		/* 820D0820h case   14:*/		regs.LR = 0x820D0824; return 0x820D0220;
		/* 820D0820h case   14:*/		return 0x820D0824;
		  /* 820D0824h */ case   15:  		/* lwzu R11, <#[R30 + 4]> */
		/* 820D0824h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 820D0824h case   15:*/		return 0x820D0828;
		  /* 820D0828h */ case   16:  		/* mr R10, R25 */
		/* 820D0828h case   16:*/		regs.R10 = regs.R25;
		/* 820D0828h case   16:*/		return 0x820D082C;
		  /* 820D082Ch */ case   17:  		/* stw R3, <#[R29 + 4]> */
		/* 820D082Ch case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000004) );
		/* 820D082Ch case   17:*/		return 0x820D0830;
		  /* 820D0830h */ case   18:  		/* mr R9, R26 */
		/* 820D0830h case   18:*/		regs.R9 = regs.R26;
		/* 820D0830h case   18:*/		return 0x820D0834;
		  /* 820D0834h */ case   19:  		/* mr R8, R27 */
		/* 820D0834h case   19:*/		regs.R8 = regs.R27;
		/* 820D0834h case   19:*/		return 0x820D0838;
		  /* 820D0838h */ case   20:  		/* mr R7, R23 */
		/* 820D0838h case   20:*/		regs.R7 = regs.R23;
		/* 820D0838h case   20:*/		return 0x820D083C;
		  /* 820D083Ch */ case   21:  		/* mr R6, R24 */
		/* 820D083Ch case   21:*/		regs.R6 = regs.R24;
		/* 820D083Ch case   21:*/		return 0x820D0840;
		  /* 820D0840h */ case   22:  		/* mr R5, R21 */
		/* 820D0840h case   22:*/		regs.R5 = regs.R21;
		/* 820D0840h case   22:*/		return 0x820D0844;
		  /* 820D0844h */ case   23:  		/* mr R4, R22 */
		/* 820D0844h case   23:*/		regs.R4 = regs.R22;
		/* 820D0844h case   23:*/		return 0x820D0848;
		  /* 820D0848h */ case   24:  		/* mr R3, R11 */
		/* 820D0848h case   24:*/		regs.R3 = regs.R11;
		/* 820D0848h case   24:*/		return 0x820D084C;
		  /* 820D084Ch */ case   25:  		/* bl -244 */
		/* 820D084Ch case   25:*/		regs.LR = 0x820D0850; return 0x820D0758;
		/* 820D084Ch case   25:*/		return 0x820D0850;
		  /* 820D0850h */ case   26:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D0850h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D0850h case   26:*/		return 0x820D0854;
		  /* 820D0854h */ case   27:  		/* addi R28, R28, 1 */
		/* 820D0854h case   27:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820D0854h case   27:*/		return 0x820D0858;
		  /* 820D0858h */ case   28:  		/* stwu R3, <#[R29 + 8]> */
		/* 820D0858h case   28:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000008) );
		regs.R29 = (uint32)(regs.R29 + 0x00000008);
		/* 820D0858h case   28:*/		return 0x820D085C;
		  /* 820D085Ch */ case   29:  		/* cmplw CR6, R28, R11 */
		/* 820D085Ch case   29:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820D085Ch case   29:*/		return 0x820D0860;
		  /* 820D0860h */ case   30:  		/* bc 12, CR6_LT, -84 */
		/* 820D0860h case   30:*/		if ( regs.CR[6].lt ) { return 0x820D080C;  }
		/* 820D0860h case   30:*/		return 0x820D0864;
	}
	return 0x820D0864;
} // Block from 820D07E8h-820D0864h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820D0864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0864);
		  /* 820D0864h */ case    0:  		/* mr R6, R23 */
		/* 820D0864h case    0:*/		regs.R6 = regs.R23;
		/* 820D0864h case    0:*/		return 0x820D0868;
		  /* 820D0868h */ case    1:  		/* mr R5, R24 */
		/* 820D0868h case    1:*/		regs.R5 = regs.R24;
		/* 820D0868h case    1:*/		return 0x820D086C;
		  /* 820D086Ch */ case    2:  		/* rlwinm R4, R20, 0, 16, 31 */
		/* 820D086Ch case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R4,regs.R20);
		/* 820D086Ch case    2:*/		return 0x820D0870;
		  /* 820D0870h */ case    3:  		/* addi R3, R1, 96 */
		/* 820D0870h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820D0870h case    3:*/		return 0x820D0874;
		  /* 820D0874h */ case    4:  		/* bl -7188 */
		/* 820D0874h case    4:*/		regs.LR = 0x820D0878; return 0x820CEC60;
		/* 820D0874h case    4:*/		return 0x820D0878;
		  /* 820D0878h */ case    5:  		/* stw R3, <#[R1 + 92]> */
		/* 820D0878h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 820D0878h case    5:*/		return 0x820D087C;
	}
	return 0x820D087C;
} // Block from 820D0864h-820D087Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D087Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D087C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D087C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D087C);
		  /* 820D087Ch */ case    0:  		/* mr R5, R21 */
		/* 820D087Ch case    0:*/		regs.R5 = regs.R21;
		/* 820D087Ch case    0:*/		return 0x820D0880;
		  /* 820D0880h */ case    1:  		/* mr R4, R22 */
		/* 820D0880h case    1:*/		regs.R4 = regs.R22;
		/* 820D0880h case    1:*/		return 0x820D0884;
		  /* 820D0884h */ case    2:  		/* addi R3, R1, 80 */
		/* 820D0884h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820D0884h case    2:*/		return 0x820D0888;
		  /* 820D0888h */ case    3:  		/* bl -7016 */
		/* 820D0888h case    3:*/		regs.LR = 0x820D088C; return 0x820CED20;
		/* 820D0888h case    3:*/		return 0x820D088C;
		  /* 820D088Ch */ case    4:  		/* addi R1, R1, 2256 */
		/* 820D088Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x8D0);
		/* 820D088Ch case    4:*/		return 0x820D0890;
		  /* 820D0890h */ case    5:  		/* b -259592 */
		/* 820D0890h case    5:*/		return 0x82091288;
		/* 820D0890h case    5:*/		return 0x820D0894;
		  /* 820D0894h */ case    6:  		/* nop */
		/* 820D0894h case    6:*/		cpu::op::nop();
		/* 820D0894h case    6:*/		return 0x820D0898;
	}
	return 0x820D0898;
} // Block from 820D087Ch-820D0898h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D0898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0898);
		  /* 820D0898h */ case    0:  		/* mfspr R12, LR */
		/* 820D0898h case    0:*/		regs.R12 = regs.LR;
		/* 820D0898h case    0:*/		return 0x820D089C;
		  /* 820D089Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820D089Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D089Ch case    1:*/		return 0x820D08A0;
		  /* 820D08A0h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 820D08A0h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820D08A0h case    2:*/		return 0x820D08A4;
		  /* 820D08A4h */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 820D08A4h case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820D08A4h case    3:*/		return 0x820D08A8;
		  /* 820D08A8h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 820D08A8h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820D08A8h case    4:*/		return 0x820D08AC;
		  /* 820D08ACh */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 820D08ACh case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820D08ACh case    5:*/		return 0x820D08B0;
		  /* 820D08B0h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 820D08B0h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820D08B0h case    6:*/		return 0x820D08B4;
		  /* 820D08B4h */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 820D08B4h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820D08B4h case    7:*/		return 0x820D08B8;
		  /* 820D08B8h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 820D08B8h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820D08B8h case    8:*/		return 0x820D08BC;
		  /* 820D08BCh */ case    9:  		/* stw R4, <#[R1 + 124]> */
		/* 820D08BCh case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D08BCh case    9:*/		return 0x820D08C0;
		  /* 820D08C0h */ case   10:  		/* addi R11, R1, 80 */
		/* 820D08C0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820D08C0h case   10:*/		return 0x820D08C4;
		  /* 820D08C4h */ case   11:  		/* addi R10, R1, 128 */
		/* 820D08C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820D08C4h case   11:*/		return 0x820D08C8;
		  /* 820D08C8h */ case   12:  		/* lwz R3, <#[R3 + 3032]> */
		/* 820D08C8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000BD8) );
		/* 820D08C8h case   12:*/		return 0x820D08CC;
		  /* 820D08CCh */ case   13:  		/* stw R10, <#[R11]> */
		/* 820D08CCh case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D08CCh case   13:*/		return 0x820D08D0;
		  /* 820D08D0h */ case   14:  		/* lwz R5, <#[R1 + 80]> */
		/* 820D08D0h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820D08D0h case   14:*/		return 0x820D08D4;
		  /* 820D08D4h */ case   15:  		/* bl -1900 */
		/* 820D08D4h case   15:*/		regs.LR = 0x820D08D8; return 0x820D0168;
		/* 820D08D4h case   15:*/		return 0x820D08D8;
		  /* 820D08D8h */ case   16:  		/* addi R1, R1, 96 */
		/* 820D08D8h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820D08D8h case   16:*/		return 0x820D08DC;
		  /* 820D08DCh */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 820D08DCh case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D08DCh case   17:*/		return 0x820D08E0;
		  /* 820D08E0h */ case   18:  		/* mtspr LR, R12 */
		/* 820D08E0h case   18:*/		regs.LR = regs.R12;
		/* 820D08E0h case   18:*/		return 0x820D08E4;
		  /* 820D08E4h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820D08E4h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820D08E4h case   19:*/		return 0x820D08E8;
	}
	return 0x820D08E8;
} // Block from 820D0898h-820D08E8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820D08E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D08E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D08E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D08E8);
		  /* 820D08E8h */ case    0:  		/* mfspr R12, LR */
		/* 820D08E8h case    0:*/		regs.R12 = regs.LR;
		/* 820D08E8h case    0:*/		return 0x820D08EC;
		  /* 820D08ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820D08ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D08ECh case    1:*/		return 0x820D08F0;
		  /* 820D08F0h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 820D08F0h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820D08F0h case    2:*/		return 0x820D08F4;
		  /* 820D08F4h */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 820D08F4h case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820D08F4h case    3:*/		return 0x820D08F8;
		  /* 820D08F8h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 820D08F8h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820D08F8h case    4:*/		return 0x820D08FC;
		  /* 820D08FCh */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 820D08FCh case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820D08FCh case    5:*/		return 0x820D0900;
		  /* 820D0900h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 820D0900h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820D0900h case    6:*/		return 0x820D0904;
		  /* 820D0904h */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 820D0904h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820D0904h case    7:*/		return 0x820D0908;
		  /* 820D0908h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 820D0908h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820D0908h case    8:*/		return 0x820D090C;
		  /* 820D090Ch */ case    9:  		/* stw R4, <#[R1 + 124]> */
		/* 820D090Ch case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D090Ch case    9:*/		return 0x820D0910;
		  /* 820D0910h */ case   10:  		/* addi R11, R1, 80 */
		/* 820D0910h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820D0910h case   10:*/		return 0x820D0914;
		  /* 820D0914h */ case   11:  		/* addi R10, R1, 128 */
		/* 820D0914h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820D0914h case   11:*/		return 0x820D0918;
		  /* 820D0918h */ case   12:  		/* stw R10, <#[R11]> */
		/* 820D0918h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0918h case   12:*/		return 0x820D091C;
		  /* 820D091Ch */ case   13:  		/* lwz R5, <#[R1 + 80]> */
		/* 820D091Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820D091Ch case   13:*/		return 0x820D0920;
		  /* 820D0920h */ case   14:  		/* bl -1976 */
		/* 820D0920h case   14:*/		regs.LR = 0x820D0924; return 0x820D0168;
		/* 820D0920h case   14:*/		return 0x820D0924;
		  /* 820D0924h */ case   15:  		/* addi R1, R1, 96 */
		/* 820D0924h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820D0924h case   15:*/		return 0x820D0928;
		  /* 820D0928h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 820D0928h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D0928h case   16:*/		return 0x820D092C;
		  /* 820D092Ch */ case   17:  		/* mtspr LR, R12 */
		/* 820D092Ch case   17:*/		regs.LR = regs.R12;
		/* 820D092Ch case   17:*/		return 0x820D0930;
		  /* 820D0930h */ case   18:  		/* bclr 20, CR0_LT */
		/* 820D0930h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820D0930h case   18:*/		return 0x820D0934;
	}
	return 0x820D0934;
} // Block from 820D08E8h-820D0934h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D0934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0934);
		  /* 820D0934h */ case    0:  		/* nop */
		/* 820D0934h case    0:*/		cpu::op::nop();
		/* 820D0934h case    0:*/		return 0x820D0938;
	}
	return 0x820D0938;
} // Block from 820D0934h-820D0938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D0938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0938);
		  /* 820D0938h */ case    0:  		/* mfspr R12, LR */
		/* 820D0938h case    0:*/		regs.R12 = regs.LR;
		/* 820D0938h case    0:*/		return 0x820D093C;
		  /* 820D093Ch */ case    1:  		/* bl -259868 */
		/* 820D093Ch case    1:*/		regs.LR = 0x820D0940; return 0x82091220;
		/* 820D093Ch case    1:*/		return 0x820D0940;
		  /* 820D0940h */ case    2:  		/* stwu R1, <#[R1 - 384]> */
		/* 820D0940h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE80);
		/* 820D0940h case    2:*/		return 0x820D0944;
		  /* 820D0944h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 820D0944h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 820D0944h case    3:*/		return 0x820D0948;
		  /* 820D0948h */ case    4:  		/* lis R10, -32255 */
		/* 820D0948h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D0948h case    4:*/		return 0x820D094C;
		  /* 820D094Ch */ case    5:  		/* li R27, 0 */
		/* 820D094Ch case    5:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820D094Ch case    5:*/		return 0x820D0950;
		  /* 820D0950h */ case    6:  		/* stw R3, <#[R1 + 404]> */
		/* 820D0950h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000194) );
		/* 820D0950h case    6:*/		return 0x820D0954;
		  /* 820D0954h */ case    7:  		/* addi R31, R10, 19264 */
		/* 820D0954h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0x4B40);
		/* 820D0954h case    7:*/		return 0x820D0958;
		  /* 820D0958h */ case    8:  		/* li R28, 277 */
		/* 820D0958h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x115);
		/* 820D0958h case    8:*/		return 0x820D095C;
		  /* 820D095Ch */ case    9:  		/* stw R27, <#[R3 + 68]> */
		/* 820D095Ch case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000044) );
		/* 820D095Ch case    9:*/		return 0x820D0960;
		  /* 820D0960h */ case   10:  		/* mr R29, R3 */
		/* 820D0960h case   10:*/		regs.R29 = regs.R3;
		/* 820D0960h case   10:*/		return 0x820D0964;
		  /* 820D0964h */ case   11:  		/* stw R27, <#[R1 + 104]> */
		/* 820D0964h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 820D0964h case   11:*/		return 0x820D0968;
		  /* 820D0968h */ case   12:  		/* lbz R4, <#[R11]> */
		/* 820D0968h case   12:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0968h case   12:*/		return 0x820D096C;
		  /* 820D096Ch */ case   13:  		/* mr R26, R11 */
		/* 820D096Ch case   13:*/		regs.R26 = regs.R11;
		/* 820D096Ch case   13:*/		return 0x820D0970;
		  /* 820D0970h */ case   14:  		/* stw R27, <#[R1 + 116]> */
		/* 820D0970h case   14:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000074) );
		/* 820D0970h case   14:*/		return 0x820D0974;
		  /* 820D0974h */ case   15:  		/* mr R14, R27 */
		/* 820D0974h case   15:*/		regs.R14 = regs.R27;
		/* 820D0974h case   15:*/		return 0x820D0978;
		  /* 820D0978h */ case   16:  		/* stw R27, <#[R1 + 128]> */
		/* 820D0978h case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000080) );
		/* 820D0978h case   16:*/		return 0x820D097C;
		  /* 820D097Ch */ case   17:  		/* mr R6, R31 */
		/* 820D097Ch case   17:*/		regs.R6 = regs.R31;
		/* 820D097Ch case   17:*/		return 0x820D0980;
		  /* 820D0980h */ case   18:  		/* stw R27, <#[R1 + 120]> */
		/* 820D0980h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000078) );
		/* 820D0980h case   18:*/		return 0x820D0984;
		  /* 820D0984h */ case   19:  		/* addi R3, R11, 1 */
		/* 820D0984h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 820D0984h case   19:*/		return 0x820D0988;
		  /* 820D0988h */ case   20:  		/* stw R27, <#[R1 + 112]> */
		/* 820D0988h case   20:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000070) );
		/* 820D0988h case   20:*/		return 0x820D098C;
		  /* 820D098Ch */ case   21:  		/* mr R30, R27 */
		/* 820D098Ch case   21:*/		regs.R30 = regs.R27;
		/* 820D098Ch case   21:*/		return 0x820D0990;
		  /* 820D0990h */ case   22:  		/* stw R27, <#[R1 + 108]> */
		/* 820D0990h case   22:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000006C) );
		/* 820D0990h case   22:*/		return 0x820D0994;
		  /* 820D0994h */ case   23:  		/* li R25, 1 */
		/* 820D0994h case   23:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D0994h case   23:*/		return 0x820D0998;
		  /* 820D0998h */ case   24:  		/* stw R28, <#[R1 + 96]> */
		/* 820D0998h case   24:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820D0998h case   24:*/		return 0x820D099C;
		  /* 820D099Ch */ case   25:  		/* stw R11, <#[R1 + 124]> */
		/* 820D099Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D099Ch case   25:*/		return 0x820D09A0;
		  /* 820D09A0h */ case   26:  		/* stw R11, <#[R1 + 100]> */
		/* 820D09A0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820D09A0h case   26:*/		return 0x820D09A4;
		  /* 820D09A4h */ case   27:  		/* lwz R5, <#[R6]> */
		/* 820D09A4h case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + 0x00000000) );
		/* 820D09A4h case   27:*/		return 0x820D09A8;
		  /* 820D09A8h */ case   28:  		/* extsb. R10, R4 */
		/* 820D09A8h case   28:*/		cpu::op::extsb<1>(regs,&regs.R10,regs.R4);
		/* 820D09A8h case   28:*/		return 0x820D09AC;
		  /* 820D09ACh */ case   29:  		/* lbz R9, <#[R5]> */
		/* 820D09ACh case   29:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 820D09ACh case   29:*/		return 0x820D09B0;
		  /* 820D09B0h */ case   30:  		/* addi R8, R5, 1 */
		/* 820D09B0h case   30:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R5,0x1);
		/* 820D09B0h case   30:*/		return 0x820D09B4;
		  /* 820D09B4h */ case   31:  		/* bc 12, CR0_EQ, 56 */
		/* 820D09B4h case   31:*/		if ( regs.CR[0].eq ) { return 0x820D09EC;  }
		/* 820D09B4h case   31:*/		return 0x820D09B8;
		  /* 820D09B8h */ case   32:  		/* addi R7, R8, -1 */
		/* 820D09B8h case   32:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R8,0xFFFFFFFF);
		/* 820D09B8h case   32:*/		return 0x820D09BC;
		  /* 820D09BCh */ case   33:  		/* addi R8, R3, -1 */
		/* 820D09BCh case   33:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0xFFFFFFFF);
		/* 820D09BCh case   33:*/		return 0x820D09C0;
		  /* 820D09C0h */ case   34:  		/* cmpwi CR6, R10, 95 */
		/* 820D09C0h case   34:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005F);
		/* 820D09C0h case   34:*/		return 0x820D09C4;
		  /* 820D09C4h */ case   35:  		/* bc 4, CR6_EQ, 12 */
		/* 820D09C4h case   35:*/		if ( !regs.CR[6].eq ) { return 0x820D09D0;  }
		/* 820D09C4h case   35:*/		return 0x820D09C8;
		  /* 820D09C8h */ case   36:  		/* extsb. R24, R9 */
		/* 820D09C8h case   36:*/		cpu::op::extsb<1>(regs,&regs.R24,regs.R9);
		/* 820D09C8h case   36:*/		return 0x820D09CC;
		  /* 820D09CCh */ case   37:  		/* bc 12, CR0_EQ, 48 */
		/* 820D09CCh case   37:*/		if ( regs.CR[0].eq ) { return 0x820D09FC;  }
		/* 820D09CCh case   37:*/		return 0x820D09D0;
	}
	return 0x820D09D0;
} // Block from 820D0938h-820D09D0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820D09D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D09D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D09D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D09D0);
		  /* 820D09D0h */ case    0:  		/* extsb R9, R9 */
		/* 820D09D0h case    0:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R9);
		/* 820D09D0h case    0:*/		return 0x820D09D4;
		  /* 820D09D4h */ case    1:  		/* cmpw CR6, R10, R9 */
		/* 820D09D4h case    1:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 820D09D4h case    1:*/		return 0x820D09D8;
		  /* 820D09D8h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 820D09D8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D0A04;  }
		/* 820D09D8h case    2:*/		return 0x820D09DC;
		  /* 820D09DCh */ case    3:  		/* lbzu R10, <#[R8 + 1]> */
		/* 820D09DCh case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000001) );
		regs.R8 = (uint32)(regs.R8 + 0x00000001);
		/* 820D09DCh case    3:*/		return 0x820D09E0;
		  /* 820D09E0h */ case    4:  		/* lbzu R9, <#[R7 + 1]> */
		/* 820D09E0h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000001) );
		regs.R7 = (uint32)(regs.R7 + 0x00000001);
		/* 820D09E0h case    4:*/		return 0x820D09E4;
		  /* 820D09E4h */ case    5:  		/* extsb. R10, R10 */
		/* 820D09E4h case    5:*/		cpu::op::extsb<1>(regs,&regs.R10,regs.R10);
		/* 820D09E4h case    5:*/		return 0x820D09E8;
		  /* 820D09E8h */ case    6:  		/* bc 4, CR0_EQ, -40 */
		/* 820D09E8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820D09C0;  }
		/* 820D09E8h case    6:*/		return 0x820D09EC;
	}
	return 0x820D09EC;
} // Block from 820D09D0h-820D09ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D09ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D09EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D09EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D09EC);
		  /* 820D09ECh */ case    0:  		/* extsb R10, R9 */
		/* 820D09ECh case    0:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R9);
		/* 820D09ECh case    0:*/		return 0x820D09F0;
		  /* 820D09F0h */ case    1:  		/* cntlzw R10, R10 */
		/* 820D09F0h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 820D09F0h case    1:*/		return 0x820D09F4;
		  /* 820D09F4h */ case    2:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 820D09F4h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 820D09F4h case    2:*/		return 0x820D09F8;
		  /* 820D09F8h */ case    3:  		/* b 16 */
		/* 820D09F8h case    3:*/		return 0x820D0A08;
		/* 820D09F8h case    3:*/		return 0x820D09FC;
	}
	return 0x820D09FC;
} // Block from 820D09ECh-820D09FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D09FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D09FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D09FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D09FC);
		  /* 820D09FCh */ case    0:  		/* mr R10, R25 */
		/* 820D09FCh case    0:*/		regs.R10 = regs.R25;
		/* 820D09FCh case    0:*/		return 0x820D0A00;
		  /* 820D0A00h */ case    1:  		/* b 8 */
		/* 820D0A00h case    1:*/		return 0x820D0A08;
		/* 820D0A00h case    1:*/		return 0x820D0A04;
	}
	return 0x820D0A04;
} // Block from 820D09FCh-820D0A04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0A04);
		  /* 820D0A04h */ case    0:  		/* mr R10, R27 */
		/* 820D0A04h case    0:*/		regs.R10 = regs.R27;
		/* 820D0A04h case    0:*/		return 0x820D0A08;
	}
	return 0x820D0A08;
} // Block from 820D0A04h-820D0A08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D0A08h
// Function '?InitializePass@CUAssembler@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0A08);
		  /* 820D0A08h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 820D0A08h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 820D0A08h case    0:*/		return 0x820D0A0C;
		  /* 820D0A0Ch */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 820D0A0Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0A24;  }
		/* 820D0A0Ch case    1:*/		return 0x820D0A10;
		  /* 820D0A10h */ case    2:  		/* addi R30, R30, 1 */
		/* 820D0A10h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820D0A10h case    2:*/		return 0x820D0A14;
		  /* 820D0A14h */ case    3:  		/* addi R6, R6, 16 */
		/* 820D0A14h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x10);
		/* 820D0A14h case    3:*/		return 0x820D0A18;
		  /* 820D0A18h */ case    4:  		/* cmplwi CR6, R30, 128 */
		/* 820D0A18h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000080);
		/* 820D0A18h case    4:*/		return 0x820D0A1C;
		  /* 820D0A1Ch */ case    5:  		/* bc 12, CR6_LT, -120 */
		/* 820D0A1Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x820D09A4;  }
		/* 820D0A1Ch case    5:*/		return 0x820D0A20;
		  /* 820D0A20h */ case    6:  		/* b 68 */
		/* 820D0A20h case    6:*/		return 0x820D0A64;
		/* 820D0A20h case    6:*/		return 0x820D0A24;
	}
	return 0x820D0A24;
} // Block from 820D0A08h-820D0A24h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D0A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0A24);
		  /* 820D0A24h */ case    0:  		/* mr R10, R5 */
		/* 820D0A24h case    0:*/		regs.R10 = regs.R5;
		/* 820D0A24h case    0:*/		return 0x820D0A28;
		  /* 820D0A28h */ case    1:  		/* lbz R9, <#[R10]> */
		/* 820D0A28h case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0A28h case    1:*/		return 0x820D0A2C;
		  /* 820D0A2Ch */ case    2:  		/* addi R10, R10, 1 */
		/* 820D0A2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0A2Ch case    2:*/		return 0x820D0A30;
		  /* 820D0A30h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 820D0A30h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D0A30h case    3:*/		return 0x820D0A34;
		  /* 820D0A34h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 820D0A34h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D0A28;  }
		/* 820D0A34h case    4:*/		return 0x820D0A38;
		  /* 820D0A38h */ case    5:  		/* subf R10, R5, R10 */
		/* 820D0A38h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 820D0A38h case    5:*/		return 0x820D0A3C;
		  /* 820D0A3Ch */ case    6:  		/* addi R10, R10, -1 */
		/* 820D0A3Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820D0A3Ch case    6:*/		return 0x820D0A40;
		  /* 820D0A40h */ case    7:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 820D0A40h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 820D0A40h case    7:*/		return 0x820D0A44;
		  /* 820D0A44h */ case    8:  		/* add R26, R10, R11 */
		/* 820D0A44h case    8:*/		cpu::op::add<0>(regs,&regs.R26,regs.R10,regs.R11);
		/* 820D0A44h case    8:*/		return 0x820D0A48;
		  /* 820D0A48h */ case    9:  		/* stw R26, <#[R1 + 100]> */
		/* 820D0A48h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000064) );
		/* 820D0A48h case    9:*/		return 0x820D0A4C;
		  /* 820D0A4Ch */ case   10:  		/* lbz R11, <#[R26]> */
		/* 820D0A4Ch case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D0A4Ch case   10:*/		return 0x820D0A50;
		  /* 820D0A50h */ case   11:  		/* cmplwi CR6, R11, 95 */
		/* 820D0A50h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820D0A50h case   11:*/		return 0x820D0A54;
		  /* 820D0A54h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 820D0A54h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820D0A60;  }
		/* 820D0A54h case   12:*/		return 0x820D0A58;
		  /* 820D0A58h */ case   13:  		/* addi R26, R26, 1 */
		/* 820D0A58h case   13:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820D0A58h case   13:*/		return 0x820D0A5C;
		  /* 820D0A5Ch */ case   14:  		/* stw R26, <#[R1 + 100]> */
		/* 820D0A5Ch case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000064) );
		/* 820D0A5Ch case   14:*/		return 0x820D0A60;
	}
	return 0x820D0A60;
} // Block from 820D0A24h-820D0A60h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D0A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0A60);
		  /* 820D0A60h */ case    0:  		/* stw R26, <#[R1 + 124]> */
		/* 820D0A60h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D0A60h case    0:*/		return 0x820D0A64;
	}
	return 0x820D0A64;
} // Block from 820D0A60h-820D0A64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D0A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0A64);
		  /* 820D0A64h */ case    0:  		/* cmplwi CR6, R30, 128 */
		/* 820D0A64h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000080);
		/* 820D0A64h case    0:*/		return 0x820D0A68;
		  /* 820D0A68h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D0A68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D0A74;  }
		/* 820D0A68h case    1:*/		return 0x820D0A6C;
		  /* 820D0A6Ch */ case    2:  		/* li R3, 277 */
		/* 820D0A6Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x115);
		/* 820D0A6Ch case    2:*/		return 0x820D0A70;
		  /* 820D0A70h */ case    3:  		/* b 3680 */
		/* 820D0A70h case    3:*/		return 0x820D18D0;
		/* 820D0A70h case    3:*/		return 0x820D0A74;
	}
	return 0x820D0A74;
} // Block from 820D0A64h-820D0A74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D0A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0A74);
		  /* 820D0A74h */ case    0:  		/* lwz R10, <#[R29 + 72]> */
		/* 820D0A74h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000048) );
		/* 820D0A74h case    0:*/		return 0x820D0A78;
		  /* 820D0A78h */ case    1:  		/* rlwinm R11, R30, 3, 0, 28 */
		/* 820D0A78h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R30);
		/* 820D0A78h case    1:*/		return 0x820D0A7C;
		  /* 820D0A7Ch */ case    2:  		/* addi R9, R31, 8 */
		/* 820D0A7Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x8);
		/* 820D0A7Ch case    2:*/		return 0x820D0A80;
		  /* 820D0A80h */ case    3:  		/* add R11, R11, R10 */
		/* 820D0A80h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820D0A80h case    3:*/		return 0x820D0A84;
		  /* 820D0A84h */ case    4:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820D0A84h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820D0A84h case    4:*/		return 0x820D0A88;
		  /* 820D0A88h */ case    5:  		/* lhzx R11, <#[R11 + R9]> */
		/* 820D0A88h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820D0A88h case    5:*/		return 0x820D0A8C;
		  /* 820D0A8Ch */ case    6:  		/* cmplwi CR6, R11, 65535 */
		/* 820D0A8Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFFF);
		/* 820D0A8Ch case    6:*/		return 0x820D0A90;
		  /* 820D0A90h */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 820D0A90h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D0AAC;  }
		/* 820D0A90h case    7:*/		return 0x820D0A94;
		  /* 820D0A94h */ case    8:  		/* lwz R9, <#[R29 + 80]> */
		/* 820D0A94h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000050) );
		/* 820D0A94h case    8:*/		return 0x820D0A98;
		  /* 820D0A98h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D0A98h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D0A98h case    9:*/		return 0x820D0A9C;
		  /* 820D0A9Ch */ case   10:  		/* bc 12, CR6_EQ, 792 */
		/* 820D0A9Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820D0DB4;  }
		/* 820D0A9Ch case   10:*/		return 0x820D0AA0;
		  /* 820D0AA0h */ case   11:  		/* rlwinm R11, R30, 4, 0, 27 */
		/* 820D0AA0h case   11:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R30);
		/* 820D0AA0h case   11:*/		return 0x820D0AA4;
		  /* 820D0AA4h */ case   12:  		/* addi R9, R31, 10 */
		/* 820D0AA4h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0xA);
		/* 820D0AA4h case   12:*/		return 0x820D0AA8;
		  /* 820D0AA8h */ case   13:  		/* lhzx R11, <#[R11 + R9]> */
		/* 820D0AA8h case   13:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820D0AA8h case   13:*/		return 0x820D0AAC;
	}
	return 0x820D0AAC;
} // Block from 820D0A74h-820D0AACh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D0AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0AAC);
		  /* 820D0AACh */ case    0:  		/* cmplwi CR6, R11, 65526 */
		/* 820D0AACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFF6);
		/* 820D0AACh case    0:*/		return 0x820D0AB0;
		  /* 820D0AB0h */ case    1:  		/* bc 12, CR6_GT, 772 */
		/* 820D0AB0h case    1:*/		if ( regs.CR[6].gt ) { return 0x820D0DB4;  }
		/* 820D0AB0h case    1:*/		return 0x820D0AB4;
		  /* 820D0AB4h */ case    2:  		/* bc 12, CR6_EQ, 760 */
		/* 820D0AB4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D0DAC;  }
		/* 820D0AB4h case    2:*/		return 0x820D0AB8;
	}
	return 0x820D0AB8;
} // Block from 820D0AACh-820D0AB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D0AB8h
// Function '?CreateLabel@CUAssembler@D3DXShader@@IAAPAVCNodeUAsmLabel@2@KK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0AB8);
		  /* 820D0AB8h */ case    0:  		/* cmplwi CR6, R11, 5 */
		/* 820D0AB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 820D0AB8h case    0:*/		return 0x820D0ABC;
		  /* 820D0ABCh */ case    1:  		/* bc 12, CR6_GT, 688 */
		/* 820D0ABCh case    1:*/		if ( regs.CR[6].gt ) { return 0x820D0D6C;  }
		/* 820D0ABCh case    1:*/		return 0x820D0AC0;
		  /* 820D0AC0h */ case    2:  		/* bc 12, CR6_EQ, 676 */
		/* 820D0AC0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D0D64;  }
		/* 820D0AC0h case    2:*/		return 0x820D0AC4;
		  /* 820D0AC4h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 820D0AC4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D0AC4h case    3:*/		return 0x820D0AC8;
		  /* 820D0AC8h */ case    4:  		/* bc 12, CR6_LT, 60 */
		/* 820D0AC8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D0B04;  }
		/* 820D0AC8h case    4:*/		return 0x820D0ACC;
		  /* 820D0ACCh */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 820D0ACCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820D0AFC;  }
		/* 820D0ACCh case    5:*/		return 0x820D0AD0;
		  /* 820D0AD0h */ case    6:  		/* cmplwi CR6, R11, 3 */
		/* 820D0AD0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820D0AD0h case    6:*/		return 0x820D0AD4;
		  /* 820D0AD4h */ case    7:  		/* bc 12, CR6_LT, 32 */
		/* 820D0AD4h case    7:*/		if ( regs.CR[6].lt ) { return 0x820D0AF4;  }
		/* 820D0AD4h case    7:*/		return 0x820D0AD8;
		  /* 820D0AD8h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 820D0AD8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D0AEC;  }
		/* 820D0AD8h case    8:*/		return 0x820D0ADC;
		  /* 820D0ADCh */ case    9:  		/* cmplwi CR6, R11, 5 */
		/* 820D0ADCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 820D0ADCh case    9:*/		return 0x820D0AE0;
		  /* 820D0AE0h */ case   10:  		/* bc 4, CR6_LT, 44 */
		/* 820D0AE0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820D0B0C;  }
		/* 820D0AE0h case   10:*/		return 0x820D0AE4;
		  /* 820D0AE4h */ case   11:  		/* li R28, 262 */
		/* 820D0AE4h case   11:*/		cpu::op::li<0>(regs,&regs.R28,0x106);
		/* 820D0AE4h case   11:*/		return 0x820D0AE8;
		  /* 820D0AE8h */ case   12:  		/* b 32 */
		/* 820D0AE8h case   12:*/		return 0x820D0B08;
		/* 820D0AE8h case   12:*/		return 0x820D0AEC;
	}
	return 0x820D0AEC;
} // Block from 820D0AB8h-820D0AECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D0AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0AEC);
		  /* 820D0AECh */ case    0:  		/* li R28, 261 */
		/* 820D0AECh case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x105);
		/* 820D0AECh case    0:*/		return 0x820D0AF0;
		  /* 820D0AF0h */ case    1:  		/* b 24 */
		/* 820D0AF0h case    1:*/		return 0x820D0B08;
		/* 820D0AF0h case    1:*/		return 0x820D0AF4;
	}
	return 0x820D0AF4;
} // Block from 820D0AECh-820D0AF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0AF4);
		  /* 820D0AF4h */ case    0:  		/* li R28, 260 */
		/* 820D0AF4h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x104);
		/* 820D0AF4h case    0:*/		return 0x820D0AF8;
		  /* 820D0AF8h */ case    1:  		/* b 16 */
		/* 820D0AF8h case    1:*/		return 0x820D0B08;
		/* 820D0AF8h case    1:*/		return 0x820D0AFC;
	}
	return 0x820D0AFC;
} // Block from 820D0AF4h-820D0AFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0AFC);
		  /* 820D0AFCh */ case    0:  		/* li R28, 259 */
		/* 820D0AFCh case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x103);
		/* 820D0AFCh case    0:*/		return 0x820D0B00;
		  /* 820D0B00h */ case    1:  		/* b 8 */
		/* 820D0B00h case    1:*/		return 0x820D0B08;
		/* 820D0B00h case    1:*/		return 0x820D0B04;
	}
	return 0x820D0B04;
} // Block from 820D0AFCh-820D0B04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B04);
		  /* 820D0B04h */ case    0:  		/* li R28, 258 */
		/* 820D0B04h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x102);
		/* 820D0B04h case    0:*/		return 0x820D0B08;
	}
	return 0x820D0B08;
} // Block from 820D0B04h-820D0B08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B08);
		  /* 820D0B08h */ case    0:  		/* stw R28, <#[R1 + 96]> */
		/* 820D0B08h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820D0B08h case    0:*/		return 0x820D0B0C;
	}
	return 0x820D0B0C;
} // Block from 820D0B08h-820D0B0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B0C);
		  /* 820D0B0Ch */ case    0:  		/* rlwinm R11, R30, 4, 0, 27 */
		/* 820D0B0Ch case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R30);
		/* 820D0B0Ch case    0:*/		return 0x820D0B10;
		  /* 820D0B10h */ case    1:  		/* addi R9, R31, 4 */
		/* 820D0B10h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x4);
		/* 820D0B10h case    1:*/		return 0x820D0B14;
		  /* 820D0B14h */ case    2:  		/* cmpwi CR6, R28, 259 */
		/* 820D0B14h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000103);
		/* 820D0B14h case    2:*/		return 0x820D0B18;
		  /* 820D0B18h */ case    3:  		/* lwzx R9, <#[R11 + R9]> */
		/* 820D0B18h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820D0B18h case    3:*/		return 0x820D0B1C;
		  /* 820D0B1Ch */ case    4:  		/* rlwinm R8, R9, 4, 28, 31 */
		/* 820D0B1Ch case    4:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R8,regs.R9);
		/* 820D0B1Ch case    4:*/		return 0x820D0B20;
		  /* 820D0B20h */ case    5:  		/* rlwinm R11, R9, 13, 23, 31 */
		/* 820D0B20h case    5:*/		cpu::op::rlwinm<0,13,23,31>(regs,&regs.R11,regs.R9);
		/* 820D0B20h case    5:*/		return 0x820D0B24;
		  /* 820D0B24h */ case    6:  		/* rlwinm R9, R9, 15, 30, 31 */
		/* 820D0B24h case    6:*/		cpu::op::rlwinm<0,15,30,31>(regs,&regs.R9,regs.R9);
		/* 820D0B24h case    6:*/		return 0x820D0B28;
	}
	return 0x820D0B28;
} // Block from 820D0B0Ch-820D0B28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B28h
// Function '??1CUAssembler@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B28);
		  /* 820D0B28h */ case    0:  		/* stw R8, <#[R1 + 196]> */
		/* 820D0B28h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000C4) );
		/* 820D0B28h case    0:*/		return 0x820D0B2C;
		  /* 820D0B2Ch */ case    1:  		/* stw R11, <#[R1 + 192]> */
		/* 820D0B2Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 820D0B2Ch case    1:*/		return 0x820D0B30;
		  /* 820D0B30h */ case    2:  		/* stw R9, <#[R1 + 200]> */
		/* 820D0B30h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000C8) );
		/* 820D0B30h case    2:*/		return 0x820D0B34;
		  /* 820D0B34h */ case    3:  		/* bc 12, CR6_LT, 24 */
		/* 820D0B34h case    3:*/		if ( regs.CR[6].lt ) { return 0x820D0B4C;  }
		/* 820D0B34h case    3:*/		return 0x820D0B38;
		  /* 820D0B38h */ case    4:  		/* cmpwi CR6, R28, 263 */
		/* 820D0B38h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000107);
		/* 820D0B38h case    4:*/		return 0x820D0B3C;
		  /* 820D0B3Ch */ case    5:  		/* bc 12, CR6_GT, 16 */
		/* 820D0B3Ch case    5:*/		if ( regs.CR[6].gt ) { return 0x820D0B4C;  }
		/* 820D0B3Ch case    5:*/		return 0x820D0B40;
		  /* 820D0B40h */ case    6:  		/* cmplwi CR6, R11, 248 */
		/* 820D0B40h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F8);
		/* 820D0B40h case    6:*/		return 0x820D0B44;
		  /* 820D0B44h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 820D0B44h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D0B4C;  }
		/* 820D0B44h case    7:*/		return 0x820D0B48;
		  /* 820D0B48h */ case    8:  		/* stw R25, <#[R1 + 128]> */
		/* 820D0B48h case    8:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000080) );
		/* 820D0B48h case    8:*/		return 0x820D0B4C;
	}
	return 0x820D0B4C;
} // Block from 820D0B28h-820D0B4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B4C);
		  /* 820D0B4Ch */ case    0:  		/* cmpwi CR6, R10, 1 */
		/* 820D0B4Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820D0B4Ch case    0:*/		return 0x820D0B50;
		  /* 820D0B50h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D0B50h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D0B60;  }
		/* 820D0B50h case    1:*/		return 0x820D0B54;
		  /* 820D0B54h */ case    2:  		/* cmplwi CR6, R11, 248 */
		/* 820D0B54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F8);
		/* 820D0B54h case    2:*/		return 0x820D0B58;
		  /* 820D0B58h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 820D0B58h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D0B6C;  }
		/* 820D0B58h case    3:*/		return 0x820D0B5C;
		  /* 820D0B5Ch */ case    4:  		/* stw R25, <#[R1 + 120]> */
		/* 820D0B5Ch case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000078) );
		/* 820D0B5Ch case    4:*/		return 0x820D0B60;
	}
	return 0x820D0B60;
} // Block from 820D0B4Ch-820D0B60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B60);
		  /* 820D0B60h */ case    0:  		/* cmplwi CR6, R11, 248 */
		/* 820D0B60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F8);
		/* 820D0B60h case    0:*/		return 0x820D0B64;
		  /* 820D0B64h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 820D0B64h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D0B6C;  }
		/* 820D0B64h case    1:*/		return 0x820D0B68;
		  /* 820D0B68h */ case    2:  		/* mr R14, R25 */
		/* 820D0B68h case    2:*/		regs.R14 = regs.R25;
		/* 820D0B68h case    2:*/		return 0x820D0B6C;
	}
	return 0x820D0B6C;
} // Block from 820D0B60h-820D0B6Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B6C);
		  /* 820D0B6Ch */ case    0:  		/* cmpwi CR6, R10, 1 */
		/* 820D0B6Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820D0B6Ch case    0:*/		return 0x820D0B70;
		  /* 820D0B70h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D0B70h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D0B80;  }
		/* 820D0B70h case    1:*/		return 0x820D0B74;
		  /* 820D0B74h */ case    2:  		/* cmplwi CR6, R11, 248 */
		/* 820D0B74h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F8);
		/* 820D0B74h case    2:*/		return 0x820D0B78;
		  /* 820D0B78h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 820D0B78h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D0B80;  }
		/* 820D0B78h case    3:*/		return 0x820D0B7C;
		  /* 820D0B7Ch */ case    4:  		/* stw R25, <#[R1 + 112]> */
		/* 820D0B7Ch case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 820D0B7Ch case    4:*/		return 0x820D0B80;
	}
	return 0x820D0B80;
} // Block from 820D0B6Ch-820D0B80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B80);
		  /* 820D0B80h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 820D0B80h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820D0B80h case    0:*/		return 0x820D0B84;
		  /* 820D0B84h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D0B84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D0B94;  }
		/* 820D0B84h case    1:*/		return 0x820D0B88;
		  /* 820D0B88h */ case    2:  		/* cmplwi CR6, R11, 248 */
		/* 820D0B88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F8);
		/* 820D0B88h case    2:*/		return 0x820D0B8C;
		  /* 820D0B8Ch */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 820D0B8Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D0B94;  }
		/* 820D0B8Ch case    3:*/		return 0x820D0B90;
		  /* 820D0B90h */ case    4:  		/* stw R25, <#[R1 + 108]> */
		/* 820D0B90h case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000006C) );
		/* 820D0B90h case    4:*/		return 0x820D0B94;
	}
	return 0x820D0B94;
} // Block from 820D0B80h-820D0B94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D0B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0B94);
		  /* 820D0B94h */ case    0:  		/* li R10, 2024 */
		/* 820D0B94h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x7E8);
		/* 820D0B94h case    0:*/		return 0x820D0B98;
		  /* 820D0B98h */ case    1:  		/* stw R10, <#[R29 + 68]> */
		/* 820D0B98h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000044) );
		/* 820D0B98h case    1:*/		return 0x820D0B9C;
		  /* 820D0B9Ch */ case    2:  		/* lbz R10, <#[R26]> */
		/* 820D0B9Ch case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820D0B9Ch case    2:*/		return 0x820D0BA0;
		  /* 820D0BA0h */ case    3:  		/* extsb. R15, R10 */
		/* 820D0BA0h case    3:*/		cpu::op::extsb<1>(regs,&regs.R15,regs.R10);
		/* 820D0BA0h case    3:*/		return 0x820D0BA4;
		  /* 820D0BA4h */ case    4:  		/* bc 12, CR0_EQ, 3304 */
		/* 820D0BA4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D188C;  }
		/* 820D0BA4h case    4:*/		return 0x820D0BA8;
	}
	return 0x820D0BA8;
} // Block from 820D0B94h-820D0BA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D0BA8h
// Function '?VError@CUAssembler@D3DXShader@@IAAXPBDPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0BA8);
		  /* 820D0BA8h */ case    0:  		/* lis R11, -32255 */
		/* 820D0BA8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D0BA8h case    0:*/		return 0x820D0BAC;
		  /* 820D0BACh */ case    1:  		/* lis R10, -32255 */
		/* 820D0BACh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D0BACh case    1:*/		return 0x820D0BB0;
		  /* 820D0BB0h */ case    2:  		/* lis R9, -32255 */
		/* 820D0BB0h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820D0BB0h case    2:*/		return 0x820D0BB4;
		  /* 820D0BB4h */ case    3:  		/* addi R11, R11, 23500 */
		/* 820D0BB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5BCC);
		/* 820D0BB4h case    3:*/		return 0x820D0BB8;
		  /* 820D0BB8h */ case    4:  		/* addi R10, R10, 23488 */
		/* 820D0BB8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x5BC0);
		/* 820D0BB8h case    4:*/		return 0x820D0BBC;
		  /* 820D0BBCh */ case    5:  		/* addi R9, R9, 23480 */
		/* 820D0BBCh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x5BB8);
		/* 820D0BBCh case    5:*/		return 0x820D0BC0;
		  /* 820D0BC0h */ case    6:  		/* stw R11, <#[R1 + 188]> */
		/* 820D0BC0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000BC) );
		/* 820D0BC0h case    6:*/		return 0x820D0BC4;
		  /* 820D0BC4h */ case    7:  		/* lis R8, -32255 */
		/* 820D0BC4h case    7:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820D0BC4h case    7:*/		return 0x820D0BC8;
		  /* 820D0BC8h */ case    8:  		/* stw R10, <#[R1 + 184]> */
		/* 820D0BC8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 820D0BC8h case    8:*/		return 0x820D0BCC;
		  /* 820D0BCCh */ case    9:  		/* lis R7, -32255 */
		/* 820D0BCCh case    9:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820D0BCCh case    9:*/		return 0x820D0BD0;
		  /* 820D0BD0h */ case   10:  		/* stw R9, <#[R1 + 180]> */
		/* 820D0BD0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000B4) );
		/* 820D0BD0h case   10:*/		return 0x820D0BD4;
		  /* 820D0BD4h */ case   11:  		/* lis R6, -32255 */
		/* 820D0BD4h case   11:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820D0BD4h case   11:*/		return 0x820D0BD8;
		  /* 820D0BD8h */ case   12:  		/* addi R11, R8, 23416 */
		/* 820D0BD8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x5B78);
		/* 820D0BD8h case   12:*/		return 0x820D0BDC;
		  /* 820D0BDCh */ case   13:  		/* addi R10, R7, 5168 */
		/* 820D0BDCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0x1430);
		/* 820D0BDCh case   13:*/		return 0x820D0BE0;
		  /* 820D0BE0h */ case   14:  		/* addi R9, R6, 5156 */
		/* 820D0BE0h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x1424);
		/* 820D0BE0h case   14:*/		return 0x820D0BE4;
		  /* 820D0BE4h */ case   15:  		/* stw R11, <#[R1 + 176]> */
		/* 820D0BE4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 820D0BE4h case   15:*/		return 0x820D0BE8;
		  /* 820D0BE8h */ case   16:  		/* lis R20, -32255 */
		/* 820D0BE8h case   16:*/		cpu::op::lis<0>(regs,&regs.R20,0xFFFF8201);
		/* 820D0BE8h case   16:*/		return 0x820D0BEC;
		  /* 820D0BECh */ case   17:  		/* stw R10, <#[R1 + 164]> */
		/* 820D0BECh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000A4) );
		/* 820D0BECh case   17:*/		return 0x820D0BF0;
		  /* 820D0BF0h */ case   18:  		/* lis R29, -32255 */
		/* 820D0BF0h case   18:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8201);
		/* 820D0BF0h case   18:*/		return 0x820D0BF4;
		  /* 820D0BF4h */ case   19:  		/* stw R9, <#[R1 + 160]> */
		/* 820D0BF4h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000A0) );
		/* 820D0BF4h case   19:*/		return 0x820D0BF8;
		  /* 820D0BF8h */ case   20:  		/* lis R26, -32255 */
		/* 820D0BF8h case   20:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8201);
		/* 820D0BF8h case   20:*/		return 0x820D0BFC;
		  /* 820D0BFCh */ case   21:  		/* lis R5, -32255 */
		/* 820D0BFCh case   21:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820D0BFCh case   21:*/		return 0x820D0C00;
		  /* 820D0C00h */ case   22:  		/* lis R4, -32255 */
		/* 820D0C00h case   22:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 820D0C00h case   22:*/		return 0x820D0C04;
		  /* 820D0C04h */ case   23:  		/* lis R3, -32255 */
		/* 820D0C04h case   23:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8201);
		/* 820D0C04h case   23:*/		return 0x820D0C08;
		  /* 820D0C08h */ case   24:  		/* addi R27, R20, 4960 */
		/* 820D0C08h case   24:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R20,0x1360);
		/* 820D0C08h case   24:*/		return 0x820D0C0C;
		  /* 820D0C0Ch */ case   25:  		/* addi R25, R29, 5056 */
		/* 820D0C0Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R29,0x13C0);
		/* 820D0C0Ch case   25:*/		return 0x820D0C10;
		  /* 820D0C10h */ case   26:  		/* lwz R29, <#[R1 + 100]> */
		/* 820D0C10h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820D0C10h case   26:*/		return 0x820D0C14;
		  /* 820D0C14h */ case   27:  		/* addi R24, R26, 5028 */
		/* 820D0C14h case   27:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R26,0x13A4);
		/* 820D0C14h case   27:*/		return 0x820D0C18;
		  /* 820D0C18h */ case   28:  		/* stw R27, <#[R1 + 172]> */
		/* 820D0C18h case   28:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x000000AC) );
		/* 820D0C18h case   28:*/		return 0x820D0C1C;
		  /* 820D0C1Ch */ case   29:  		/* lis R19, -32255 */
		/* 820D0C1Ch case   29:*/		cpu::op::lis<0>(regs,&regs.R19,0xFFFF8201);
		/* 820D0C1Ch case   29:*/		return 0x820D0C20;
		  /* 820D0C20h */ case   30:  		/* stw R25, <#[R1 + 140]> */
		/* 820D0C20h case   30:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000008C) );
		/* 820D0C20h case   30:*/		return 0x820D0C24;
		  /* 820D0C24h */ case   31:  		/* addi R11, R5, 4996 */
		/* 820D0C24h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x1384);
		/* 820D0C24h case   31:*/		return 0x820D0C28;
		  /* 820D0C28h */ case   32:  		/* stw R24, <#[R1 + 132]> */
		/* 820D0C28h case   32:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000084) );
		/* 820D0C28h case   32:*/		return 0x820D0C2C;
		  /* 820D0C2Ch */ case   33:  		/* addi R10, R4, 5080 */
		/* 820D0C2Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x13D8);
		/* 820D0C2Ch case   33:*/		return 0x820D0C30;
		  /* 820D0C30h */ case   34:  		/* lwz R26, <#[R1 + 116]> */
		/* 820D0C30h case   34:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000074) );
		/* 820D0C30h case   34:*/		return 0x820D0C34;
		  /* 820D0C34h */ case   35:  		/* addi R9, R3, 23356 */
		/* 820D0C34h case   35:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x5B3C);
		/* 820D0C34h case   35:*/		return 0x820D0C38;
		  /* 820D0C38h */ case   36:  		/* stw R11, <#[R1 + 156]> */
		/* 820D0C38h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 820D0C38h case   36:*/		return 0x820D0C3C;
		  /* 820D0C3Ch */ case   37:  		/* lis R18, -32255 */
		/* 820D0C3Ch case   37:*/		cpu::op::lis<0>(regs,&regs.R18,0xFFFF8201);
		/* 820D0C3Ch case   37:*/		return 0x820D0C40;
		  /* 820D0C40h */ case   38:  		/* stw R10, <#[R1 + 152]> */
		/* 820D0C40h case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 820D0C40h case   38:*/		return 0x820D0C44;
		  /* 820D0C44h */ case   39:  		/* lis R31, -32255 */
		/* 820D0C44h case   39:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820D0C44h case   39:*/		return 0x820D0C48;
		  /* 820D0C48h */ case   40:  		/* stw R9, <#[R1 + 168]> */
		/* 820D0C48h case   40:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000A8) );
		/* 820D0C48h case   40:*/		return 0x820D0C4C;
		  /* 820D0C4Ch */ case   41:  		/* lis R30, -32255 */
		/* 820D0C4Ch case   41:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8201);
		/* 820D0C4Ch case   41:*/		return 0x820D0C50;
		  /* 820D0C50h */ case   42:  		/* lis R28, -32255 */
		/* 820D0C50h case   42:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8201);
		/* 820D0C50h case   42:*/		return 0x820D0C54;
		  /* 820D0C54h */ case   43:  		/* lis R17, -32255 */
		/* 820D0C54h case   43:*/		cpu::op::lis<0>(regs,&regs.R17,0xFFFF8201);
		/* 820D0C54h case   43:*/		return 0x820D0C58;
		  /* 820D0C58h */ case   44:  		/* lis R16, -32255 */
		/* 820D0C58h case   44:*/		cpu::op::lis<0>(regs,&regs.R16,0xFFFF8201);
		/* 820D0C58h case   44:*/		return 0x820D0C5C;
		  /* 820D0C5Ch */ case   45:  		/* addi R20, R19, 5204 */
		/* 820D0C5Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R19,0x1454);
		/* 820D0C5Ch case   45:*/		return 0x820D0C60;
	}
	return 0x820D0C60;
} // Block from 820D0BA8h-820D0C60h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820D0C60h
// Function '?AddStringNoDuplicates@D3DXShader@@YAIPBDPADIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0C60);
		  /* 820D0C60h */ case    0:  		/* lis R27, -32255 */
		/* 820D0C60h case    0:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8201);
		/* 820D0C60h case    0:*/		return 0x820D0C64;
		  /* 820D0C64h */ case    1:  		/* lis R25, -32255 */
		/* 820D0C64h case    1:*/		cpu::op::lis<0>(regs,&regs.R25,0xFFFF8201);
		/* 820D0C64h case    1:*/		return 0x820D0C68;
		  /* 820D0C68h */ case    2:  		/* lis R24, -32255 */
		/* 820D0C68h case    2:*/		cpu::op::lis<0>(regs,&regs.R24,0xFFFF8201);
		/* 820D0C68h case    2:*/		return 0x820D0C6C;
		  /* 820D0C6Ch */ case    3:  		/* lis R23, -32255 */
		/* 820D0C6Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R23,0xFFFF8201);
		/* 820D0C6Ch case    3:*/		return 0x820D0C70;
		  /* 820D0C70h */ case    4:  		/* lis R22, -32255 */
		/* 820D0C70h case    4:*/		cpu::op::lis<0>(regs,&regs.R22,0xFFFF8201);
		/* 820D0C70h case    4:*/		return 0x820D0C74;
		  /* 820D0C74h */ case    5:  		/* lis R21, -32255 */
		/* 820D0C74h case    5:*/		cpu::op::lis<0>(regs,&regs.R21,0xFFFF8201);
		/* 820D0C74h case    5:*/		return 0x820D0C78;
		  /* 820D0C78h */ case    6:  		/* addi R11, R31, 5068 */
		/* 820D0C78h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x13CC);
		/* 820D0C78h case    6:*/		return 0x820D0C7C;
		  /* 820D0C7Ch */ case    7:  		/* addi R10, R30, 5044 */
		/* 820D0C7Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x13B4);
		/* 820D0C7Ch case    7:*/		return 0x820D0C80;
		  /* 820D0C80h */ case    8:  		/* addi R9, R28, 5036 */
		/* 820D0C80h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R28,0x13AC);
		/* 820D0C80h case    8:*/		return 0x820D0C84;
		  /* 820D0C84h */ case    9:  		/* stw R11, <#[R1 + 148]> */
		/* 820D0C84h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 820D0C84h case    9:*/		return 0x820D0C88;
		  /* 820D0C88h */ case   10:  		/* addi R19, R18, 23340 */
		/* 820D0C88h case   10:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R18,0x5B2C);
		/* 820D0C88h case   10:*/		return 0x820D0C8C;
		  /* 820D0C8Ch */ case   11:  		/* stw R10, <#[R1 + 144]> */
		/* 820D0C8Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 820D0C8Ch case   11:*/		return 0x820D0C90;
		  /* 820D0C90h */ case   12:  		/* addi R18, R17, 4936 */
		/* 820D0C90h case   12:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R17,0x1348);
		/* 820D0C90h case   12:*/		return 0x820D0C94;
		  /* 820D0C94h */ case   13:  		/* stw R9, <#[R1 + 136]> */
		/* 820D0C94h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000088) );
		/* 820D0C94h case   13:*/		return 0x820D0C98;
		  /* 820D0C98h */ case   14:  		/* addi R17, R16, 4956 */
		/* 820D0C98h case   14:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R16,0x135C);
		/* 820D0C98h case   14:*/		return 0x820D0C9C;
		  /* 820D0C9Ch */ case   15:  		/* addi R27, R27, -8388 */
		/* 820D0C9Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFDF3C);
		/* 820D0C9Ch case   15:*/		return 0x820D0CA0;
		  /* 820D0CA0h */ case   16:  		/* addi R25, R25, 5020 */
		/* 820D0CA0h case   16:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x139C);
		/* 820D0CA0h case   16:*/		return 0x820D0CA4;
		  /* 820D0CA4h */ case   17:  		/* addi R24, R24, 5004 */
		/* 820D0CA4h case   17:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x138C);
		/* 820D0CA4h case   17:*/		return 0x820D0CA8;
		  /* 820D0CA8h */ case   18:  		/* addi R23, R23, 4984 */
		/* 820D0CA8h case   18:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1378);
		/* 820D0CA8h case   18:*/		return 0x820D0CAC;
		  /* 820D0CACh */ case   19:  		/* addi R22, R22, 4972 */
		/* 820D0CACh case   19:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x136C);
		/* 820D0CACh case   19:*/		return 0x820D0CB0;
		  /* 820D0CB0h */ case   20:  		/* addi R21, R21, 5208 */
		/* 820D0CB0h case   20:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1458);
		/* 820D0CB0h case   20:*/		return 0x820D0CB4;
		  /* 820D0CB4h */ case   21:  		/* li R16, 0 */
		/* 820D0CB4h case   21:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 820D0CB4h case   21:*/		return 0x820D0CB8;
		  /* 820D0CB8h */ case   22:  		/* cmpwi CR6, R15, 0 */
		/* 820D0CB8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 820D0CB8h case   22:*/		return 0x820D0CBC;
		  /* 820D0CBCh */ case   23:  		/* bc 12, CR6_EQ, 28 */
		/* 820D0CBCh case   23:*/		if ( regs.CR[6].eq ) { return 0x820D0CD8;  }
		/* 820D0CBCh case   23:*/		return 0x820D0CC0;
		  /* 820D0CC0h */ case   24:  		/* cmpwi CR6, R15, 95 */
		/* 820D0CC0h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x0000005F);
		/* 820D0CC0h case   24:*/		return 0x820D0CC4;
		  /* 820D0CC4h */ case   25:  		/* bc 12, CR6_EQ, 20 */
		/* 820D0CC4h case   25:*/		if ( regs.CR[6].eq ) { return 0x820D0CD8;  }
		/* 820D0CC4h case   25:*/		return 0x820D0CC8;
		  /* 820D0CC8h */ case   26:  		/* lbzu R11, <#[R29 + 1]> */
		/* 820D0CC8h case   26:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000001) );
		regs.R29 = (uint32)(regs.R29 + 0x00000001);
		/* 820D0CC8h case   26:*/		return 0x820D0CCC;
		  /* 820D0CCCh */ case   27:  		/* extsb. R15, R11 */
		/* 820D0CCCh case   27:*/		cpu::op::extsb<1>(regs,&regs.R15,regs.R11);
		/* 820D0CCCh case   27:*/		return 0x820D0CD0;
		  /* 820D0CD0h */ case   28:  		/* stw R29, <#[R1 + 100]> */
		/* 820D0CD0h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820D0CD0h case   28:*/		return 0x820D0CD4;
		  /* 820D0CD4h */ case   29:  		/* bc 4, CR0_EQ, -20 */
		/* 820D0CD4h case   29:*/		if ( !regs.CR[0].eq ) { return 0x820D0CC0;  }
		/* 820D0CD4h case   29:*/		return 0x820D0CD8;
	}
	return 0x820D0CD8;
} // Block from 820D0C60h-820D0CD8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820D0CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0CD8);
		  /* 820D0CD8h */ case    0:  		/* lwz R4, <#[R1 + 124]> */
		/* 820D0CD8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D0CD8h case    0:*/		return 0x820D0CDC;
		  /* 820D0CDCh */ case    1:  		/* subf R31, R4, R29 */
		/* 820D0CDCh case    1:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R4,regs.R29);
		/* 820D0CDCh case    1:*/		return 0x820D0CE0;
		  /* 820D0CE0h */ case    2:  		/* cmplwi CR6, R31, 15 */
		/* 820D0CE0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x0000000F);
		/* 820D0CE0h case    2:*/		return 0x820D0CE4;
		  /* 820D0CE4h */ case    3:  		/* bc 12, CR6_GT, -632 */
		/* 820D0CE4h case    3:*/		if ( regs.CR[6].gt ) { return 0x820D0A6C;  }
		/* 820D0CE4h case    3:*/		return 0x820D0CE8;
		  /* 820D0CE8h */ case    4:  		/* mr R5, R31 */
		/* 820D0CE8h case    4:*/		regs.R5 = regs.R31;
		/* 820D0CE8h case    4:*/		return 0x820D0CEC;
		  /* 820D0CECh */ case    5:  		/* addi R3, R1, 208 */
		/* 820D0CECh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD0);
		/* 820D0CECh case    5:*/		return 0x820D0CF0;
		  /* 820D0CF0h */ case    6:  		/* bl -258880 */
		/* 820D0CF0h case    6:*/		regs.LR = 0x820D0CF4; return 0x820919B0;
		/* 820D0CF0h case    6:*/		return 0x820D0CF4;
		  /* 820D0CF4h */ case    7:  		/* addi R11, R1, 208 */
		/* 820D0CF4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D0CF4h case    7:*/		return 0x820D0CF8;
		  /* 820D0CF8h */ case    8:  		/* cmpwi CR6, R15, 0 */
		/* 820D0CF8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 820D0CF8h case    8:*/		return 0x820D0CFC;
		  /* 820D0CFCh */ case    9:  		/* stbx R16, <#[R31 + R11]> */
		/* 820D0CFCh case    9:*/		cpu::mem::store8( regs, regs.R16, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820D0CFCh case    9:*/		return 0x820D0D00;
		  /* 820D0D00h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820D0D00h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D0D0C;  }
		/* 820D0D00h case   10:*/		return 0x820D0D04;
		  /* 820D0D04h */ case   11:  		/* addi R29, R29, 1 */
		/* 820D0D04h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820D0D04h case   11:*/		return 0x820D0D08;
		  /* 820D0D08h */ case   12:  		/* stw R29, <#[R1 + 100]> */
		/* 820D0D08h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820D0D08h case   12:*/		return 0x820D0D0C;
	}
	return 0x820D0D0C;
} // Block from 820D0CD8h-820D0D0Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D0D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0D0C);
		  /* 820D0D0Ch */ case    0:  		/* lwz R11, <#[R1 + 128]> */
		/* 820D0D0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820D0D0Ch case    0:*/		return 0x820D0D10;
		  /* 820D0D10h */ case    1:  		/* stw R29, <#[R1 + 124]> */
		/* 820D0D10h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D0D10h case    1:*/		return 0x820D0D14;
		  /* 820D0D14h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820D0D14h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D0D14h case    2:*/		return 0x820D0D18;
		  /* 820D0D18h */ case    3:  		/* bc 12, CR6_EQ, 292 */
		/* 820D0D18h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D0E3C;  }
		/* 820D0D18h case    3:*/		return 0x820D0D1C;
		  /* 820D0D1Ch */ case    4:  		/* mr R10, R17 */
		/* 820D0D1Ch case    4:*/		regs.R10 = regs.R17;
		/* 820D0D1Ch case    4:*/		return 0x820D0D20;
		  /* 820D0D20h */ case    5:  		/* addi R11, R1, 208 */
		/* 820D0D20h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D0D20h case    5:*/		return 0x820D0D24;
		  /* 820D0D24h */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820D0D24h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0D24h case    6:*/		return 0x820D0D28;
		  /* 820D0D28h */ case    7:  		/* lbz R8, <#[R10]> */
		/* 820D0D28h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0D28h case    7:*/		return 0x820D0D2C;
		  /* 820D0D2Ch */ case    8:  		/* cmpwi CR0, R9, 0 */
		/* 820D0D2Ch case    8:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0D2Ch case    8:*/		return 0x820D0D30;
		  /* 820D0D30h */ case    9:  		/* subf R9, R8, R9 */
		/* 820D0D30h case    9:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D0D30h case    9:*/		return 0x820D0D34;
		  /* 820D0D34h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0D34h case   10:*/		if ( regs.CR[0].eq ) { return 0x820D0D48;  }
		/* 820D0D34h case   10:*/		return 0x820D0D38;
		  /* 820D0D38h */ case   11:  		/* addi R11, R11, 1 */
		/* 820D0D38h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0D38h case   11:*/		return 0x820D0D3C;
		  /* 820D0D3Ch */ case   12:  		/* addi R10, R10, 1 */
		/* 820D0D3Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0D3Ch case   12:*/		return 0x820D0D40;
		  /* 820D0D40h */ case   13:  		/* cmpwi CR6, R9, 0 */
		/* 820D0D40h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D0D40h case   13:*/		return 0x820D0D44;
		  /* 820D0D44h */ case   14:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0D44h case   14:*/		if ( regs.CR[6].eq ) { return 0x820D0D24;  }
		/* 820D0D44h case   14:*/		return 0x820D0D48;
	}
	return 0x820D0D48;
} // Block from 820D0D0Ch-820D0D48h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D0D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0D48);
		  /* 820D0D48h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D0D48h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0D48h case    0:*/		return 0x820D0D4C;
		  /* 820D0D4Ch */ case    1:  		/* bc 4, CR0_EQ, 240 */
		/* 820D0D4Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0E3C;  }
		/* 820D0D4Ch case    1:*/		return 0x820D0D50;
	}
	return 0x820D0D50;
} // Block from 820D0D48h-820D0D50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0D50h
// Function '?SplitName@D3DXShader@@YAXPBDPADI1IPAW4DEFCONST_PARSE_TYPE@1@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0D50);
		  /* 820D0D50h */ case    0:  		/* lwz R11, <#[R1 + 104]> */
		/* 820D0D50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820D0D50h case    0:*/		return 0x820D0D54;
		  /* 820D0D54h */ case    1:  		/* stw R16, <#[R1 + 128]> */
		/* 820D0D54h case    1:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000080) );
		/* 820D0D54h case    1:*/		return 0x820D0D58;
		  /* 820D0D58h */ case    2:  		/* oris R11, R11, 16 */
		/* 820D0D58h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820D0D58h case    2:*/		return 0x820D0D5C;
		  /* 820D0D5Ch */ case    3:  		/* stw R11, <#[R1 + 104]> */
		/* 820D0D5Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820D0D5Ch case    3:*/		return 0x820D0D60;
		  /* 820D0D60h */ case    4:  		/* b 2832 */
		/* 820D0D60h case    4:*/		return 0x820D1870;
		/* 820D0D60h case    4:*/		return 0x820D0D64;
	}
	return 0x820D0D64;
} // Block from 820D0D50h-820D0D64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D0D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0D64);
		  /* 820D0D64h */ case    0:  		/* li R28, 263 */
		/* 820D0D64h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x107);
		/* 820D0D64h case    0:*/		return 0x820D0D68;
		  /* 820D0D68h */ case    1:  		/* b -608 */
		/* 820D0D68h case    1:*/		return 0x820D0B08;
		/* 820D0D68h case    1:*/		return 0x820D0D6C;
	}
	return 0x820D0D6C;
} // Block from 820D0D64h-820D0D6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0D6C);
		  /* 820D0D6Ch */ case    0:  		/* cmplwi CR6, R11, 65512 */
		/* 820D0D6Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFE8);
		/* 820D0D6Ch case    0:*/		return 0x820D0D70;
		  /* 820D0D70h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 820D0D70h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D0DA4;  }
		/* 820D0D70h case    1:*/		return 0x820D0D74;
		  /* 820D0D74h */ case    2:  		/* cmplwi CR6, R11, 65513 */
		/* 820D0D74h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFE9);
		/* 820D0D74h case    2:*/		return 0x820D0D78;
		  /* 820D0D78h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 820D0D78h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D0D9C;  }
		/* 820D0D78h case    3:*/		return 0x820D0D7C;
		  /* 820D0D7Ch */ case    4:  		/* cmplwi CR6, R11, 65514 */
		/* 820D0D7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFEA);
		/* 820D0D7Ch case    4:*/		return 0x820D0D80;
		  /* 820D0D80h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820D0D80h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D0D94;  }
		/* 820D0D80h case    5:*/		return 0x820D0D84;
		  /* 820D0D84h */ case    6:  		/* cmplwi CR6, R11, 65515 */
		/* 820D0D84h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFEB);
		/* 820D0D84h case    6:*/		return 0x820D0D88;
		  /* 820D0D88h */ case    7:  		/* bc 4, CR6_EQ, -636 */
		/* 820D0D88h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D0B0C;  }
		/* 820D0D88h case    7:*/		return 0x820D0D8C;
		  /* 820D0D8Ch */ case    8:  		/* li R28, 273 */
		/* 820D0D8Ch case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x111);
		/* 820D0D8Ch case    8:*/		return 0x820D0D90;
		  /* 820D0D90h */ case    9:  		/* b -648 */
		/* 820D0D90h case    9:*/		return 0x820D0B08;
		/* 820D0D90h case    9:*/		return 0x820D0D94;
	}
	return 0x820D0D94;
} // Block from 820D0D6Ch-820D0D94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D0D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0D94);
		  /* 820D0D94h */ case    0:  		/* li R28, 274 */
		/* 820D0D94h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x112);
		/* 820D0D94h case    0:*/		return 0x820D0D98;
		  /* 820D0D98h */ case    1:  		/* b -656 */
		/* 820D0D98h case    1:*/		return 0x820D0B08;
		/* 820D0D98h case    1:*/		return 0x820D0D9C;
	}
	return 0x820D0D9C;
} // Block from 820D0D94h-820D0D9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0D9C);
		  /* 820D0D9Ch */ case    0:  		/* li R28, 275 */
		/* 820D0D9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x113);
		/* 820D0D9Ch case    0:*/		return 0x820D0DA0;
		  /* 820D0DA0h */ case    1:  		/* b -664 */
		/* 820D0DA0h case    1:*/		return 0x820D0B08;
		/* 820D0DA0h case    1:*/		return 0x820D0DA4;
	}
	return 0x820D0DA4;
} // Block from 820D0D9Ch-820D0DA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0DA4);
		  /* 820D0DA4h */ case    0:  		/* li R28, 276 */
		/* 820D0DA4h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x114);
		/* 820D0DA4h case    0:*/		return 0x820D0DA8;
		  /* 820D0DA8h */ case    1:  		/* b -672 */
		/* 820D0DA8h case    1:*/		return 0x820D0B08;
		/* 820D0DA8h case    1:*/		return 0x820D0DAC;
	}
	return 0x820D0DAC;
} // Block from 820D0DA4h-820D0DACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0DAC);
		  /* 820D0DACh */ case    0:  		/* li R28, 272 */
		/* 820D0DACh case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x110);
		/* 820D0DACh case    0:*/		return 0x820D0DB0;
		  /* 820D0DB0h */ case    1:  		/* b -680 */
		/* 820D0DB0h case    1:*/		return 0x820D0B08;
		/* 820D0DB0h case    1:*/		return 0x820D0DB4;
	}
	return 0x820D0DB4;
} // Block from 820D0DACh-820D0DB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0DB4);
		  /* 820D0DB4h */ case    0:  		/* addis R11, R11, -1 */
		/* 820D0DB4h case    0:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D0DB4h case    0:*/		return 0x820D0DB8;
		  /* 820D0DB8h */ case    1:  		/* addi R11, R11, 9 */
		/* 820D0DB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x9);
		/* 820D0DB8h case    1:*/		return 0x820D0DBC;
		  /* 820D0DBCh */ case    2:  		/* cmplwi CR6, R11, 8 */
		/* 820D0DBCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 820D0DBCh case    2:*/		return 0x820D0DC0;
		  /* 820D0DC0h */ case    3:  		/* bc 12, CR6_GT, -692 */
		/* 820D0DC0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820D0B0C;  }
		/* 820D0DC0h case    3:*/		return 0x820D0DC4;
		  /* 820D0DC4h */ case    4:  		/* mtspr CTR, R11 */
		/* 820D0DC4h case    4:*/		regs.CTR = regs.R11;
		/* 820D0DC4h case    4:*/		return 0x820D0DC8;
		  /* 820D0DC8h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820D0DC8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D0DC8h case    5:*/		return 0x820D0DCC;
		  /* 820D0DCCh */ case    6:  		/* bc 12, CR6_EQ, 72 */
		/* 820D0DCCh case    6:*/		if ( regs.CR[6].eq ) { return 0x820D0E14;  }
		/* 820D0DCCh case    6:*/		return 0x820D0DD0;
		  /* 820D0DD0h */ case    7:  		/* bc 18, CR0_LT, 52 */
		/* 820D0DD0h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820D0E04;  }
		/* 820D0DD0h case    7:*/		return 0x820D0DD4;
		  /* 820D0DD4h */ case    8:  		/* bc 18, CR0_LT, 80 */
		/* 820D0DD4h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820D0E24;  }
		/* 820D0DD4h case    8:*/		return 0x820D0DD8;
		  /* 820D0DD8h */ case    9:  		/* bc 18, CR0_LT, 68 */
		/* 820D0DD8h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820D0E1C;  }
		/* 820D0DD8h case    9:*/		return 0x820D0DDC;
		  /* 820D0DDCh */ case   10:  		/* bc 18, CR0_LT, 48 */
		/* 820D0DDCh case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820D0E0C;  }
		/* 820D0DDCh case   10:*/		return 0x820D0DE0;
		  /* 820D0DE0h */ case   11:  		/* bc 18, CR0_LT, 28 */
		/* 820D0DE0h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820D0DFC;  }
		/* 820D0DE0h case   11:*/		return 0x820D0DE4;
		  /* 820D0DE4h */ case   12:  		/* bc 18, CR0_LT, 16 */
		/* 820D0DE4h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR == 0 ) { return 0x820D0DF4;  }
		/* 820D0DE4h case   12:*/		return 0x820D0DE8;
		  /* 820D0DE8h */ case   13:  		/* bc 16, CR0_LT, 68 */
		/* 820D0DE8h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D0E2C;  }
		/* 820D0DE8h case   13:*/		return 0x820D0DEC;
		  /* 820D0DECh */ case   14:  		/* li R28, 265 */
		/* 820D0DECh case   14:*/		cpu::op::li<0>(regs,&regs.R28,0x109);
		/* 820D0DECh case   14:*/		return 0x820D0DF0;
		  /* 820D0DF0h */ case   15:  		/* b -744 */
		/* 820D0DF0h case   15:*/		return 0x820D0B08;
		/* 820D0DF0h case   15:*/		return 0x820D0DF4;
	}
	return 0x820D0DF4;
} // Block from 820D0DB4h-820D0DF4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D0DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0DF4);
		  /* 820D0DF4h */ case    0:  		/* li R28, 264 */
		/* 820D0DF4h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x108);
		/* 820D0DF4h case    0:*/		return 0x820D0DF8;
		  /* 820D0DF8h */ case    1:  		/* b -752 */
		/* 820D0DF8h case    1:*/		return 0x820D0B08;
		/* 820D0DF8h case    1:*/		return 0x820D0DFC;
	}
	return 0x820D0DFC;
} // Block from 820D0DF4h-820D0DFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0DFC);
		  /* 820D0DFCh */ case    0:  		/* li R28, 266 */
		/* 820D0DFCh case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10A);
		/* 820D0DFCh case    0:*/		return 0x820D0E00;
		  /* 820D0E00h */ case    1:  		/* b -760 */
		/* 820D0E00h case    1:*/		return 0x820D0B08;
		/* 820D0E00h case    1:*/		return 0x820D0E04;
	}
	return 0x820D0E04;
} // Block from 820D0DFCh-820D0E04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E04);
		  /* 820D0E04h */ case    0:  		/* li R28, 270 */
		/* 820D0E04h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10E);
		/* 820D0E04h case    0:*/		return 0x820D0E08;
		  /* 820D0E08h */ case    1:  		/* b -768 */
		/* 820D0E08h case    1:*/		return 0x820D0B08;
		/* 820D0E08h case    1:*/		return 0x820D0E0C;
	}
	return 0x820D0E0C;
} // Block from 820D0E04h-820D0E0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E0C);
		  /* 820D0E0Ch */ case    0:  		/* li R28, 267 */
		/* 820D0E0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10B);
		/* 820D0E0Ch case    0:*/		return 0x820D0E10;
		  /* 820D0E10h */ case    1:  		/* b -776 */
		/* 820D0E10h case    1:*/		return 0x820D0B08;
		/* 820D0E10h case    1:*/		return 0x820D0E14;
	}
	return 0x820D0E14;
} // Block from 820D0E0Ch-820D0E14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E14);
		  /* 820D0E14h */ case    0:  		/* li R28, 271 */
		/* 820D0E14h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10F);
		/* 820D0E14h case    0:*/		return 0x820D0E18;
		  /* 820D0E18h */ case    1:  		/* b -784 */
		/* 820D0E18h case    1:*/		return 0x820D0B08;
		/* 820D0E18h case    1:*/		return 0x820D0E1C;
	}
	return 0x820D0E1C;
} // Block from 820D0E14h-820D0E1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E1C);
		  /* 820D0E1Ch */ case    0:  		/* li R28, 268 */
		/* 820D0E1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10C);
		/* 820D0E1Ch case    0:*/		return 0x820D0E20;
		  /* 820D0E20h */ case    1:  		/* b -792 */
		/* 820D0E20h case    1:*/		return 0x820D0B08;
		/* 820D0E20h case    1:*/		return 0x820D0E24;
	}
	return 0x820D0E24;
} // Block from 820D0E1Ch-820D0E24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E24);
		  /* 820D0E24h */ case    0:  		/* li R28, 269 */
		/* 820D0E24h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10D);
		/* 820D0E24h case    0:*/		return 0x820D0E28;
		  /* 820D0E28h */ case    1:  		/* b -800 */
		/* 820D0E28h case    1:*/		return 0x820D0B08;
		/* 820D0E28h case    1:*/		return 0x820D0E2C;
	}
	return 0x820D0E2C;
} // Block from 820D0E24h-820D0E2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E2C);
		  /* 820D0E2Ch */ case    0:  		/* li R11, 2023 */
		/* 820D0E2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7E7);
		/* 820D0E2Ch case    0:*/		return 0x820D0E30;
		  /* 820D0E30h */ case    1:  		/* li R3, 277 */
		/* 820D0E30h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x115);
		/* 820D0E30h case    1:*/		return 0x820D0E34;
		  /* 820D0E34h */ case    2:  		/* stw R11, <#[R29 + 68]> */
		/* 820D0E34h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000044) );
		/* 820D0E34h case    2:*/		return 0x820D0E38;
		  /* 820D0E38h */ case    3:  		/* b 2712 */
		/* 820D0E38h case    3:*/		return 0x820D18D0;
		/* 820D0E38h case    3:*/		return 0x820D0E3C;
	}
	return 0x820D0E3C;
} // Block from 820D0E2Ch-820D0E3Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E3C);
		  /* 820D0E3Ch */ case    0:  		/* lwz R11, <#[R1 + 120]> */
		/* 820D0E3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820D0E3Ch case    0:*/		return 0x820D0E40;
		  /* 820D0E40h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820D0E40h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D0E40h case    1:*/		return 0x820D0E44;
		  /* 820D0E44h */ case    2:  		/* bc 12, CR6_EQ, 140 */
		/* 820D0E44h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D0ED0;  }
		/* 820D0E44h case    2:*/		return 0x820D0E48;
		  /* 820D0E48h */ case    3:  		/* mr R10, R18 */
		/* 820D0E48h case    3:*/		regs.R10 = regs.R18;
		/* 820D0E48h case    3:*/		return 0x820D0E4C;
		  /* 820D0E4Ch */ case    4:  		/* addi R11, R1, 208 */
		/* 820D0E4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D0E4Ch case    4:*/		return 0x820D0E50;
		  /* 820D0E50h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820D0E50h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0E50h case    5:*/		return 0x820D0E54;
		  /* 820D0E54h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820D0E54h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0E54h case    6:*/		return 0x820D0E58;
		  /* 820D0E58h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820D0E58h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0E58h case    7:*/		return 0x820D0E5C;
		  /* 820D0E5Ch */ case    8:  		/* subf R9, R8, R9 */
		/* 820D0E5Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D0E5Ch case    8:*/		return 0x820D0E60;
		  /* 820D0E60h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0E60h case    9:*/		if ( regs.CR[0].eq ) { return 0x820D0E74;  }
		/* 820D0E60h case    9:*/		return 0x820D0E64;
		  /* 820D0E64h */ case   10:  		/* addi R11, R11, 1 */
		/* 820D0E64h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0E64h case   10:*/		return 0x820D0E68;
		  /* 820D0E68h */ case   11:  		/* addi R10, R10, 1 */
		/* 820D0E68h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0E68h case   11:*/		return 0x820D0E6C;
		  /* 820D0E6Ch */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820D0E6Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D0E6Ch case   12:*/		return 0x820D0E70;
		  /* 820D0E70h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0E70h case   13:*/		if ( regs.CR[6].eq ) { return 0x820D0E50;  }
		/* 820D0E70h case   13:*/		return 0x820D0E74;
	}
	return 0x820D0E74;
} // Block from 820D0E3Ch-820D0E74h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E74);
		  /* 820D0E74h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D0E74h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0E74h case    0:*/		return 0x820D0E78;
		  /* 820D0E78h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 820D0E78h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0E8C;  }
		/* 820D0E78h case    1:*/		return 0x820D0E7C;
		  /* 820D0E7Ch */ case    2:  		/* lwz R11, <#[R1 + 104]> */
		/* 820D0E7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820D0E7Ch case    2:*/		return 0x820D0E80;
		  /* 820D0E80h */ case    3:  		/* stw R16, <#[R1 + 120]> */
		/* 820D0E80h case    3:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000078) );
		/* 820D0E80h case    3:*/		return 0x820D0E84;
		  /* 820D0E84h */ case    4:  		/* oris R11, R11, 64 */
		/* 820D0E84h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x40);
		/* 820D0E84h case    4:*/		return 0x820D0E88;
		  /* 820D0E88h */ case    5:  		/* b -300 */
		/* 820D0E88h case    5:*/		return 0x820D0D5C;
		/* 820D0E88h case    5:*/		return 0x820D0E8C;
	}
	return 0x820D0E8C;
} // Block from 820D0E74h-820D0E8Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D0E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0E8C);
		  /* 820D0E8Ch */ case    0:  		/* mr R10, R19 */
		/* 820D0E8Ch case    0:*/		regs.R10 = regs.R19;
		/* 820D0E8Ch case    0:*/		return 0x820D0E90;
		  /* 820D0E90h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D0E90h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D0E90h case    1:*/		return 0x820D0E94;
		  /* 820D0E94h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D0E94h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0E94h case    2:*/		return 0x820D0E98;
		  /* 820D0E98h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D0E98h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0E98h case    3:*/		return 0x820D0E9C;
		  /* 820D0E9Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D0E9Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0E9Ch case    4:*/		return 0x820D0EA0;
		  /* 820D0EA0h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D0EA0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D0EA0h case    5:*/		return 0x820D0EA4;
		  /* 820D0EA4h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0EA4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D0EB8;  }
		/* 820D0EA4h case    6:*/		return 0x820D0EA8;
		  /* 820D0EA8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D0EA8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0EA8h case    7:*/		return 0x820D0EAC;
		  /* 820D0EACh */ case    8:  		/* addi R10, R10, 1 */
		/* 820D0EACh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0EACh case    8:*/		return 0x820D0EB0;
		  /* 820D0EB0h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D0EB0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D0EB0h case    9:*/		return 0x820D0EB4;
		  /* 820D0EB4h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0EB4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D0E94;  }
		/* 820D0EB4h case   10:*/		return 0x820D0EB8;
	}
	return 0x820D0EB8;
} // Block from 820D0E8Ch-820D0EB8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D0EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0EB8);
		  /* 820D0EB8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D0EB8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0EB8h case    0:*/		return 0x820D0EBC;
		  /* 820D0EBCh */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 820D0EBCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0ED0;  }
		/* 820D0EBCh case    1:*/		return 0x820D0EC0;
		  /* 820D0EC0h */ case    2:  		/* lwz R11, <#[R1 + 104]> */
		/* 820D0EC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820D0EC0h case    2:*/		return 0x820D0EC4;
		  /* 820D0EC4h */ case    3:  		/* stw R16, <#[R1 + 120]> */
		/* 820D0EC4h case    3:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000078) );
		/* 820D0EC4h case    3:*/		return 0x820D0EC8;
	}
	return 0x820D0EC8;
} // Block from 820D0EB8h-820D0EC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D0EC8h
// Function '?AddConstant@CUAssembler@D3DXShader@@IAAHPAU_D3DXCONSTANT_DESC@@PBDPAUDEFCONST_DESC@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0EC8);
		  /* 820D0EC8h */ case    0:  		/* oris R11, R11, 128 */
		/* 820D0EC8h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820D0EC8h case    0:*/		return 0x820D0ECC;
		  /* 820D0ECCh */ case    1:  		/* b -368 */
		/* 820D0ECCh case    1:*/		return 0x820D0D5C;
		/* 820D0ECCh case    1:*/		return 0x820D0ED0;
	}
	return 0x820D0ED0;
} // Block from 820D0EC8h-820D0ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0ED0);
		  /* 820D0ED0h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 820D0ED0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820D0ED0h case    0:*/		return 0x820D0ED4;
		  /* 820D0ED4h */ case    1:  		/* bc 12, CR6_EQ, 216 */
		/* 820D0ED4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D0FAC;  }
		/* 820D0ED4h case    1:*/		return 0x820D0ED8;
		  /* 820D0ED8h */ case    2:  		/* mr R10, R20 */
		/* 820D0ED8h case    2:*/		regs.R10 = regs.R20;
		/* 820D0ED8h case    2:*/		return 0x820D0EDC;
		  /* 820D0EDCh */ case    3:  		/* mr R8, R16 */
		/* 820D0EDCh case    3:*/		regs.R8 = regs.R16;
		/* 820D0EDCh case    3:*/		return 0x820D0EE0;
		  /* 820D0EE0h */ case    4:  		/* addi R11, R1, 208 */
		/* 820D0EE0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D0EE0h case    4:*/		return 0x820D0EE4;
		  /* 820D0EE4h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820D0EE4h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0EE4h case    5:*/		return 0x820D0EE8;
		  /* 820D0EE8h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820D0EE8h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0EE8h case    6:*/		return 0x820D0EEC;
		  /* 820D0EECh */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820D0EECh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0EECh case    7:*/		return 0x820D0EF0;
		  /* 820D0EF0h */ case    8:  		/* subf R9, R7, R9 */
		/* 820D0EF0h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D0EF0h case    8:*/		return 0x820D0EF4;
		  /* 820D0EF4h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0EF4h case    9:*/		if ( regs.CR[0].eq ) { return 0x820D0F08;  }
		/* 820D0EF4h case    9:*/		return 0x820D0EF8;
		  /* 820D0EF8h */ case   10:  		/* addi R11, R11, 1 */
		/* 820D0EF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0EF8h case   10:*/		return 0x820D0EFC;
		  /* 820D0EFCh */ case   11:  		/* addi R10, R10, 1 */
		/* 820D0EFCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0EFCh case   11:*/		return 0x820D0F00;
		  /* 820D0F00h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820D0F00h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D0F00h case   12:*/		return 0x820D0F04;
		  /* 820D0F04h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0F04h case   13:*/		if ( regs.CR[6].eq ) { return 0x820D0EE4;  }
		/* 820D0F04h case   13:*/		return 0x820D0F08;
	}
	return 0x820D0F08;
} // Block from 820D0ED0h-820D0F08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D0F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0F08);
		  /* 820D0F08h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D0F08h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0F08h case    0:*/		return 0x820D0F0C;
		  /* 820D0F0Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D0F0Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0F18;  }
		/* 820D0F0Ch case    1:*/		return 0x820D0F10;
		  /* 820D0F10h */ case    2:  		/* lis R8, 4096 */
		/* 820D0F10h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x1000);
		/* 820D0F10h case    2:*/		return 0x820D0F14;
		  /* 820D0F14h */ case    3:  		/* b 120 */
		/* 820D0F14h case    3:*/		return 0x820D0F8C;
		/* 820D0F14h case    3:*/		return 0x820D0F18;
	}
	return 0x820D0F18;
} // Block from 820D0F08h-820D0F18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D0F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0F18);
		  /* 820D0F18h */ case    0:  		/* lwz R10, <#[R1 + 172]> */
		/* 820D0F18h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000AC) );
		/* 820D0F18h case    0:*/		return 0x820D0F1C;
		  /* 820D0F1Ch */ case    1:  		/* addi R11, R1, 208 */
		/* 820D0F1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D0F1Ch case    1:*/		return 0x820D0F20;
		  /* 820D0F20h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D0F20h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0F20h case    2:*/		return 0x820D0F24;
		  /* 820D0F24h */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820D0F24h case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0F24h case    3:*/		return 0x820D0F28;
		  /* 820D0F28h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D0F28h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0F28h case    4:*/		return 0x820D0F2C;
		  /* 820D0F2Ch */ case    5:  		/* subf R9, R7, R9 */
		/* 820D0F2Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D0F2Ch case    5:*/		return 0x820D0F30;
		  /* 820D0F30h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0F30h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D0F44;  }
		/* 820D0F30h case    6:*/		return 0x820D0F34;
		  /* 820D0F34h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D0F34h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0F34h case    7:*/		return 0x820D0F38;
		  /* 820D0F38h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D0F38h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0F38h case    8:*/		return 0x820D0F3C;
		  /* 820D0F3Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D0F3Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D0F3Ch case    9:*/		return 0x820D0F40;
		  /* 820D0F40h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0F40h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D0F20;  }
		/* 820D0F40h case   10:*/		return 0x820D0F44;
	}
	return 0x820D0F44;
} // Block from 820D0F18h-820D0F44h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D0F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0F44);
		  /* 820D0F44h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D0F44h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0F44h case    0:*/		return 0x820D0F48;
		  /* 820D0F48h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D0F48h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0F54;  }
		/* 820D0F48h case    1:*/		return 0x820D0F4C;
		  /* 820D0F4Ch */ case    2:  		/* lis R8, 6144 */
		/* 820D0F4Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x1800);
		/* 820D0F4Ch case    2:*/		return 0x820D0F50;
		  /* 820D0F50h */ case    3:  		/* b 60 */
		/* 820D0F50h case    3:*/		return 0x820D0F8C;
		/* 820D0F50h case    3:*/		return 0x820D0F54;
	}
	return 0x820D0F54;
} // Block from 820D0F44h-820D0F54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D0F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0F54);
		  /* 820D0F54h */ case    0:  		/* mr R10, R21 */
		/* 820D0F54h case    0:*/		regs.R10 = regs.R21;
		/* 820D0F54h case    0:*/		return 0x820D0F58;
		  /* 820D0F58h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D0F58h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D0F58h case    1:*/		return 0x820D0F5C;
		  /* 820D0F5Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D0F5Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D0F5Ch case    2:*/		return 0x820D0F60;
		  /* 820D0F60h */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820D0F60h case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D0F60h case    3:*/		return 0x820D0F64;
		  /* 820D0F64h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D0F64h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0F64h case    4:*/		return 0x820D0F68;
		  /* 820D0F68h */ case    5:  		/* subf R9, R7, R9 */
		/* 820D0F68h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D0F68h case    5:*/		return 0x820D0F6C;
		  /* 820D0F6Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0F6Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820D0F80;  }
		/* 820D0F6Ch case    6:*/		return 0x820D0F70;
		  /* 820D0F70h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D0F70h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D0F70h case    7:*/		return 0x820D0F74;
		  /* 820D0F74h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D0F74h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D0F74h case    8:*/		return 0x820D0F78;
		  /* 820D0F78h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D0F78h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D0F78h case    9:*/		return 0x820D0F7C;
		  /* 820D0F7Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D0F7Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820D0F5C;  }
		/* 820D0F7Ch case   10:*/		return 0x820D0F80;
	}
	return 0x820D0F80;
} // Block from 820D0F54h-820D0F80h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D0F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0F80);
		  /* 820D0F80h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D0F80h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D0F80h case    0:*/		return 0x820D0F84;
		  /* 820D0F84h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 820D0F84h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0F8C;  }
		/* 820D0F84h case    1:*/		return 0x820D0F88;
		  /* 820D0F88h */ case    2:  		/* lis R8, 8192 */
		/* 820D0F88h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x2000);
		/* 820D0F88h case    2:*/		return 0x820D0F8C;
	}
	return 0x820D0F8C;
} // Block from 820D0F80h-820D0F8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D0F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0F8C);
		  /* 820D0F8Ch */ case    0:  		/* or R26, R8, R26 */
		/* 820D0F8Ch case    0:*/		cpu::op::or<0>(regs,&regs.R26,regs.R8,regs.R26);
		/* 820D0F8Ch case    0:*/		return 0x820D0F90;
		  /* 820D0F90h */ case    1:  		/* mr R14, R16 */
		/* 820D0F90h case    1:*/		regs.R14 = regs.R16;
		/* 820D0F90h case    1:*/		return 0x820D0F94;
		  /* 820D0F94h */ case    2:  		/* stw R26, <#[R1 + 116]> */
		/* 820D0F94h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000074) );
		/* 820D0F94h case    2:*/		return 0x820D0F98;
		  /* 820D0F98h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 820D0F98h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D0F98h case    3:*/		return 0x820D0F9C;
		  /* 820D0F9Ch */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 820D0F9Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820D0FAC;  }
		/* 820D0F9Ch case    4:*/		return 0x820D0FA0;
		  /* 820D0FA0h */ case    5:  		/* stw R16, <#[R1 + 112]> */
		/* 820D0FA0h case    5:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000070) );
		/* 820D0FA0h case    5:*/		return 0x820D0FA4;
		  /* 820D0FA4h */ case    6:  		/* stw R16, <#[R1 + 108]> */
		/* 820D0FA4h case    6:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x0000006C) );
		/* 820D0FA4h case    6:*/		return 0x820D0FA8;
		  /* 820D0FA8h */ case    7:  		/* b 2248 */
		/* 820D0FA8h case    7:*/		return 0x820D1870;
		/* 820D0FA8h case    7:*/		return 0x820D0FAC;
	}
	return 0x820D0FAC;
} // Block from 820D0F8Ch-820D0FACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D0FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0FAC);
		  /* 820D0FACh */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D0FACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D0FACh case    0:*/		return 0x820D0FB0;
		  /* 820D0FB0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820D0FB0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D0FB0h case    1:*/		return 0x820D0FB4;
		  /* 820D0FB4h */ case    2:  		/* bc 12, CR6_EQ, 240 */
		/* 820D0FB4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D10A4;  }
		/* 820D0FB4h case    2:*/		return 0x820D0FB8;
		  /* 820D0FB8h */ case    3:  		/* lbz R11, <#[R1 + 208]> */
		/* 820D0FB8h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000D0) );
		/* 820D0FB8h case    3:*/		return 0x820D0FBC;
		  /* 820D0FBCh */ case    4:  		/* addi R31, R1, 208 */
		/* 820D0FBCh case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xD0);
		/* 820D0FBCh case    4:*/		return 0x820D0FC0;
		  /* 820D0FC0h */ case    5:  		/* b 28 */
		/* 820D0FC0h case    5:*/		return 0x820D0FDC;
		/* 820D0FC0h case    5:*/		return 0x820D0FC4;
		  /* 820D0FC4h */ case    6:  		/* lbz R11, <#[R31]> */
		/* 820D0FC4h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D0FC4h case    6:*/		return 0x820D0FC8;
		  /* 820D0FC8h */ case    7:  		/* extsb R3, R11 */
		/* 820D0FC8h case    7:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D0FC8h case    7:*/		return 0x820D0FCC;
		  /* 820D0FCCh */ case    8:  		/* bl -227548 */
		/* 820D0FCCh case    8:*/		regs.LR = 0x820D0FD0; return 0x820996F0;
		/* 820D0FCCh case    8:*/		return 0x820D0FD0;
		  /* 820D0FD0h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820D0FD0h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D0FD0h case    9:*/		return 0x820D0FD4;
		  /* 820D0FD4h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820D0FD4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820D0FE4;  }
		/* 820D0FD4h case   10:*/		return 0x820D0FD8;
		  /* 820D0FD8h */ case   11:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820D0FD8h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820D0FD8h case   11:*/		return 0x820D0FDC;
	}
	return 0x820D0FDC;
} // Block from 820D0FACh-820D0FDCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D0FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0FDC);
		  /* 820D0FDCh */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820D0FDCh case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D0FDCh case    0:*/		return 0x820D0FE0;
		  /* 820D0FE0h */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820D0FE0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0FC4;  }
		/* 820D0FE0h case    1:*/		return 0x820D0FE4;
	}
	return 0x820D0FE4;
} // Block from 820D0FDCh-820D0FE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D0FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D0FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D0FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D0FE4);
		  /* 820D0FE4h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D0FE4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D0FE4h case    0:*/		return 0x820D0FE8;
		  /* 820D0FE8h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D0FE8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D0FE8h case    1:*/		return 0x820D0FEC;
		  /* 820D0FECh */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820D0FECh case    2:*/		if ( regs.CR[0].eq ) { return 0x820D1000;  }
		/* 820D0FECh case    2:*/		return 0x820D0FF0;
		  /* 820D0FF0h */ case    3:  		/* mr R3, R31 */
		/* 820D0FF0h case    3:*/		regs.R3 = regs.R31;
		/* 820D0FF0h case    3:*/		return 0x820D0FF4;
		  /* 820D0FF4h */ case    4:  		/* bl -255116 */
		/* 820D0FF4h case    4:*/		regs.LR = 0x820D0FF8; return 0x82092B68;
		/* 820D0FF4h case    4:*/		return 0x820D0FF8;
		  /* 820D0FF8h */ case    5:  		/* mr R28, R3 */
		/* 820D0FF8h case    5:*/		regs.R28 = regs.R3;
		/* 820D0FF8h case    5:*/		return 0x820D0FFC;
		  /* 820D0FFCh */ case    6:  		/* b 8 */
		/* 820D0FFCh case    6:*/		return 0x820D1004;
		/* 820D0FFCh case    6:*/		return 0x820D1000;
	}
	return 0x820D1000;
} // Block from 820D0FE4h-820D1000h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D1000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1000);
		  /* 820D1000h */ case    0:  		/* mr R28, R16 */
		/* 820D1000h case    0:*/		regs.R28 = regs.R16;
		/* 820D1000h case    0:*/		return 0x820D1004;
	}
	return 0x820D1004;
} // Block from 820D1000h-820D1004h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D1004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1004);
		  /* 820D1004h */ case    0:  		/* cmplwi CR6, R28, 15 */
		/* 820D1004h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x0000000F);
		/* 820D1004h case    0:*/		return 0x820D1008;
		  /* 820D1008h */ case    1:  		/* bc 12, CR6_GT, 156 */
		/* 820D1008h case    1:*/		if ( regs.CR[6].gt ) { return 0x820D10A4;  }
		/* 820D1008h case    1:*/		return 0x820D100C;
		  /* 820D100Ch */ case    2:  		/* lbz R30, <#[R31]> */
		/* 820D100Ch case    2:*/		cpu::mem::load8z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 820D100Ch case    2:*/		return 0x820D1010;
		  /* 820D1010h */ case    3:  		/* mr R29, R31 */
		/* 820D1010h case    3:*/		regs.R29 = regs.R31;
		/* 820D1010h case    3:*/		return 0x820D1014;
		  /* 820D1014h */ case    4:  		/* cmplwi CR0, R30, 0 */
		/* 820D1014h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820D1014h case    4:*/		return 0x820D1018;
		  /* 820D1018h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 820D1018h case    5:*/		if ( regs.CR[0].eq ) { return 0x820D1024;  }
		/* 820D1018h case    5:*/		return 0x820D101C;
		  /* 820D101Ch */ case    6:  		/* stb R16, <#[R31]> */
		/* 820D101Ch case    6:*/		cpu::mem::store8( regs, regs.R16, (uint32)(regs.R31 + 0x00000000) );
		/* 820D101Ch case    6:*/		return 0x820D1020;
		  /* 820D1020h */ case    7:  		/* addi R31, R31, 1 */
		/* 820D1020h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820D1020h case    7:*/		return 0x820D1024;
	}
	return 0x820D1024;
} // Block from 820D1004h-820D1024h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D1024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1024);
		  /* 820D1024h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D1024h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D1024h case    0:*/		return 0x820D1028;
		  /* 820D1028h */ case    1:  		/* b 20 */
		/* 820D1028h case    1:*/		return 0x820D103C;
		/* 820D1028h case    1:*/		return 0x820D102C;
		  /* 820D102Ch */ case    2:  		/* bl -227612 */
		/* 820D102Ch case    2:*/		regs.LR = 0x820D1030; return 0x82099710;
		/* 820D102Ch case    2:*/		return 0x820D1030;
		  /* 820D1030h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D1030h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D1030h case    3:*/		return 0x820D1034;
		  /* 820D1034h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820D1034h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D1044;  }
		/* 820D1034h case    4:*/		return 0x820D1038;
		  /* 820D1038h */ case    5:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820D1038h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820D1038h case    5:*/		return 0x820D103C;
	}
	return 0x820D103C;
} // Block from 820D1024h-820D103Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D103Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D103C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D103C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D103C);
		  /* 820D103Ch */ case    0:  		/* extsb. R3, R11 */
		/* 820D103Ch case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820D103Ch case    0:*/		return 0x820D1040;
		  /* 820D1040h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820D1040h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D102C;  }
		/* 820D1040h case    1:*/		return 0x820D1044;
	}
	return 0x820D1044;
} // Block from 820D103Ch-820D1044h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D1044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1044);
		  /* 820D1044h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D1044h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D1044h case    0:*/		return 0x820D1048;
		  /* 820D1048h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D1048h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D1048h case    1:*/		return 0x820D104C;
		  /* 820D104Ch */ case    2:  		/* bc 4, CR0_EQ, 80 */
		/* 820D104Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820D109C;  }
		/* 820D104Ch case    2:*/		return 0x820D1050;
		  /* 820D1050h */ case    3:  		/* mr R10, R22 */
		/* 820D1050h case    3:*/		regs.R10 = regs.R22;
		/* 820D1050h case    3:*/		return 0x820D1054;
		  /* 820D1054h */ case    4:  		/* addi R11, R1, 208 */
		/* 820D1054h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1054h case    4:*/		return 0x820D1058;
		  /* 820D1058h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820D1058h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1058h case    5:*/		return 0x820D105C;
		  /* 820D105Ch */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820D105Ch case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D105Ch case    6:*/		return 0x820D1060;
		  /* 820D1060h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820D1060h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1060h case    7:*/		return 0x820D1064;
		  /* 820D1064h */ case    8:  		/* subf R9, R8, R9 */
		/* 820D1064h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1064h case    8:*/		return 0x820D1068;
		  /* 820D1068h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1068h case    9:*/		if ( regs.CR[0].eq ) { return 0x820D107C;  }
		/* 820D1068h case    9:*/		return 0x820D106C;
		  /* 820D106Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 820D106Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D106Ch case   10:*/		return 0x820D1070;
		  /* 820D1070h */ case   11:  		/* addi R10, R10, 1 */
		/* 820D1070h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1070h case   11:*/		return 0x820D1074;
		  /* 820D1074h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820D1074h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1074h case   12:*/		return 0x820D1078;
		  /* 820D1078h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1078h case   13:*/		if ( regs.CR[6].eq ) { return 0x820D1058;  }
		/* 820D1078h case   13:*/		return 0x820D107C;
	}
	return 0x820D107C;
} // Block from 820D1044h-820D107Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D107Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D107C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D107C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D107C);
		  /* 820D107Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D107Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D107Ch case    0:*/		return 0x820D1080;
		  /* 820D1080h */ case    1:  		/* bc 4, CR0_EQ, 60 */
		/* 820D1080h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D10BC;  }
		/* 820D1080h case    1:*/		return 0x820D1084;
		  /* 820D1084h */ case    2:  		/* mr R11, R16 */
		/* 820D1084h case    2:*/		regs.R11 = regs.R16;
		/* 820D1084h case    2:*/		return 0x820D1088;
		  /* 820D1088h */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 820D1088h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820D1088h case    3:*/		return 0x820D108C;
		  /* 820D108Ch */ case    4:  		/* bc 4, CR6_EQ, 104 */
		/* 820D108Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D10F4;  }
		/* 820D108Ch case    4:*/		return 0x820D1090;
		  /* 820D1090h */ case    5:  		/* lwz R4, <#[R1 + 176]> */
		/* 820D1090h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000B0) );
		/* 820D1090h case    5:*/		return 0x820D1094;
		  /* 820D1094h */ case    6:  		/* lwz R3, <#[R1 + 404]> */
		/* 820D1094h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000194) );
		/* 820D1094h case    6:*/		return 0x820D1098;
		  /* 820D1098h */ case    7:  		/* bl -1968 */
		/* 820D1098h case    7:*/		regs.LR = 0x820D109C; return 0x820D08E8;
		/* 820D1098h case    7:*/		return 0x820D109C;
	}
	return 0x820D109C;
} // Block from 820D107Ch-820D109Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D109Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D109C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D109C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D109C);
		  /* 820D109Ch */ case    0:  		/* stb R30, <#[R29]> */
		/* 820D109Ch case    0:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 820D109Ch case    0:*/		return 0x820D10A0;
		  /* 820D10A0h */ case    1:  		/* lwz R29, <#[R1 + 100]> */
		/* 820D10A0h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820D10A0h case    1:*/		return 0x820D10A4;
	}
	return 0x820D10A4;
} // Block from 820D109Ch-820D10A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D10A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D10A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D10A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D10A4);
		  /* 820D10A4h */ case    0:  		/* lwz R11, <#[R1 + 108]> */
		/* 820D10A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820D10A4h case    0:*/		return 0x820D10A8;
		  /* 820D10A8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820D10A8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D10A8h case    1:*/		return 0x820D10AC;
		  /* 820D10ACh */ case    2:  		/* bc 12, CR6_EQ, -1600 */
		/* 820D10ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x820D0A6C;  }
		/* 820D10ACh case    2:*/		return 0x820D10B0;
		  /* 820D10B0h */ case    3:  		/* lbz R11, <#[R1 + 208]> */
		/* 820D10B0h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000D0) );
		/* 820D10B0h case    3:*/		return 0x820D10B4;
		  /* 820D10B4h */ case    4:  		/* addi R31, R1, 208 */
		/* 820D10B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xD0);
		/* 820D10B4h case    4:*/		return 0x820D10B8;
		  /* 820D10B8h */ case    5:  		/* b 832 */
		/* 820D10B8h case    5:*/		return 0x820D13F8;
		/* 820D10B8h case    5:*/		return 0x820D10BC;
	}
	return 0x820D10BC;
} // Block from 820D10A4h-820D10BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D10BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D10BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D10BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D10BC);
		  /* 820D10BCh */ case    0:  		/* mr R10, R23 */
		/* 820D10BCh case    0:*/		regs.R10 = regs.R23;
		/* 820D10BCh case    0:*/		return 0x820D10C0;
		  /* 820D10C0h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D10C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D10C0h case    1:*/		return 0x820D10C4;
		  /* 820D10C4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D10C4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D10C4h case    2:*/		return 0x820D10C8;
		  /* 820D10C8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D10C8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D10C8h case    3:*/		return 0x820D10CC;
		  /* 820D10CCh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D10CCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D10CCh case    4:*/		return 0x820D10D0;
		  /* 820D10D0h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D10D0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D10D0h case    5:*/		return 0x820D10D4;
		  /* 820D10D4h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D10D4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D10E8;  }
		/* 820D10D4h case    6:*/		return 0x820D10D8;
		  /* 820D10D8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D10D8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D10D8h case    7:*/		return 0x820D10DC;
		  /* 820D10DCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820D10DCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D10DCh case    8:*/		return 0x820D10E0;
		  /* 820D10E0h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D10E0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D10E0h case    9:*/		return 0x820D10E4;
		  /* 820D10E4h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D10E4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D10C4;  }
		/* 820D10E4h case   10:*/		return 0x820D10E8;
	}
	return 0x820D10E8;
} // Block from 820D10BCh-820D10E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D10E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D10E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D10E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D10E8);
		  /* 820D10E8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D10E8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D10E8h case    0:*/		return 0x820D10EC;
		  /* 820D10ECh */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 820D10ECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1110;  }
		/* 820D10ECh case    1:*/		return 0x820D10F0;
		  /* 820D10F0h */ case    2:  		/* li R11, 1 */
		/* 820D10F0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D10F0h case    2:*/		return 0x820D10F4;
	}
	return 0x820D10F4;
} // Block from 820D10E8h-820D10F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D10F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D10F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D10F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D10F4);
		  /* 820D10F4h */ case    0:  		/* rlwinm R10, R28, 16, 12, 15 */
		/* 820D10F4h case    0:*/		cpu::op::rlwinm<0,16,12,15>(regs,&regs.R10,regs.R28);
		/* 820D10F4h case    0:*/		return 0x820D10F8;
		  /* 820D10F8h */ case    1:  		/* lwz R29, <#[R1 + 100]> */
		/* 820D10F8h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820D10F8h case    1:*/		return 0x820D10FC;
		  /* 820D10FCh */ case    2:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 820D10FCh case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 820D10FCh case    2:*/		return 0x820D1100;
		  /* 820D1100h */ case    3:  		/* stw R16, <#[R1 + 112]> */
		/* 820D1100h case    3:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000070) );
		/* 820D1100h case    3:*/		return 0x820D1104;
		  /* 820D1104h */ case    4:  		/* or R11, R10, R11 */
		/* 820D1104h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D1104h case    4:*/		return 0x820D1108;
		  /* 820D1108h */ case    5:  		/* or R26, R11, R26 */
		/* 820D1108h case    5:*/		cpu::op::or<0>(regs,&regs.R26,regs.R11,regs.R26);
		/* 820D1108h case    5:*/		return 0x820D110C;
		  /* 820D110Ch */ case    6:  		/* b 1884 */
		/* 820D110Ch case    6:*/		return 0x820D1868;
		/* 820D110Ch case    6:*/		return 0x820D1110;
	}
	return 0x820D1110;
} // Block from 820D10F4h-820D1110h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D1110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1110);
		  /* 820D1110h */ case    0:  		/* mr R10, R24 */
		/* 820D1110h case    0:*/		regs.R10 = regs.R24;
		/* 820D1110h case    0:*/		return 0x820D1114;
		  /* 820D1114h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1114h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1114h case    1:*/		return 0x820D1118;
		  /* 820D1118h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1118h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1118h case    2:*/		return 0x820D111C;
		  /* 820D111Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D111Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D111Ch case    3:*/		return 0x820D1120;
		  /* 820D1120h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1120h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1120h case    4:*/		return 0x820D1124;
		  /* 820D1124h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1124h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1124h case    5:*/		return 0x820D1128;
		  /* 820D1128h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1128h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D113C;  }
		/* 820D1128h case    6:*/		return 0x820D112C;
		  /* 820D112Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820D112Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D112Ch case    7:*/		return 0x820D1130;
		  /* 820D1130h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1130h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1130h case    8:*/		return 0x820D1134;
		  /* 820D1134h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1134h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1134h case    9:*/		return 0x820D1138;
		  /* 820D1138h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1138h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1118;  }
		/* 820D1138h case   10:*/		return 0x820D113C;
	}
	return 0x820D113C;
} // Block from 820D1110h-820D113Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D113Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D113C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D113C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D113C);
		  /* 820D113Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D113Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D113Ch case    0:*/		return 0x820D1140;
		  /* 820D1140h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1140h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D114C;  }
		/* 820D1140h case    1:*/		return 0x820D1144;
		  /* 820D1144h */ case    2:  		/* li R11, 2 */
		/* 820D1144h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820D1144h case    2:*/		return 0x820D1148;
		  /* 820D1148h */ case    3:  		/* b -84 */
		/* 820D1148h case    3:*/		return 0x820D10F4;
		/* 820D1148h case    3:*/		return 0x820D114C;
	}
	return 0x820D114C;
} // Block from 820D113Ch-820D114Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D114Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D114C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D114C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D114C);
		  /* 820D114Ch */ case    0:  		/* mr R10, R25 */
		/* 820D114Ch case    0:*/		regs.R10 = regs.R25;
		/* 820D114Ch case    0:*/		return 0x820D1150;
		  /* 820D1150h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1150h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1150h case    1:*/		return 0x820D1154;
		  /* 820D1154h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1154h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1154h case    2:*/		return 0x820D1158;
		  /* 820D1158h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1158h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1158h case    3:*/		return 0x820D115C;
		  /* 820D115Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D115Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D115Ch case    4:*/		return 0x820D1160;
		  /* 820D1160h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1160h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1160h case    5:*/		return 0x820D1164;
		  /* 820D1164h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1164h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1178;  }
		/* 820D1164h case    6:*/		return 0x820D1168;
		  /* 820D1168h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1168h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1168h case    7:*/		return 0x820D116C;
		  /* 820D116Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D116Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D116Ch case    8:*/		return 0x820D1170;
		  /* 820D1170h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1170h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1170h case    9:*/		return 0x820D1174;
		  /* 820D1174h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1174h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1154;  }
		/* 820D1174h case   10:*/		return 0x820D1178;
	}
	return 0x820D1178;
} // Block from 820D114Ch-820D1178h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1178);
		  /* 820D1178h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1178h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1178h case    0:*/		return 0x820D117C;
		  /* 820D117Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D117Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1188;  }
		/* 820D117Ch case    1:*/		return 0x820D1180;
		  /* 820D1180h */ case    2:  		/* li R11, 3 */
		/* 820D1180h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820D1180h case    2:*/		return 0x820D1184;
		  /* 820D1184h */ case    3:  		/* b -144 */
		/* 820D1184h case    3:*/		return 0x820D10F4;
		/* 820D1184h case    3:*/		return 0x820D1188;
	}
	return 0x820D1188;
} // Block from 820D1178h-820D1188h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1188);
		  /* 820D1188h */ case    0:  		/* lwz R10, <#[R1 + 132]> */
		/* 820D1188h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 820D1188h case    0:*/		return 0x820D118C;
		  /* 820D118Ch */ case    1:  		/* addi R11, R1, 208 */
		/* 820D118Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D118Ch case    1:*/		return 0x820D1190;
		  /* 820D1190h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1190h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1190h case    2:*/		return 0x820D1194;
		  /* 820D1194h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1194h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1194h case    3:*/		return 0x820D1198;
	}
	return 0x820D1198;
} // Block from 820D1188h-820D1198h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1198h
// Function '?AddTypeInfo@D3DXShader@@YAIPBUDEFCONST_DESC@1@PAU_D3DXSHADER_TYPEINFO@@PAIPAU_D3DXSHADER_STRUCTMEMBERINFO@@2PADI2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1198);
		  /* 820D1198h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1198h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1198h case    0:*/		return 0x820D119C;
		  /* 820D119Ch */ case    1:  		/* subf R9, R8, R9 */
		/* 820D119Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D119Ch case    1:*/		return 0x820D11A0;
		  /* 820D11A0h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820D11A0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D11B4;  }
		/* 820D11A0h case    2:*/		return 0x820D11A4;
		  /* 820D11A4h */ case    3:  		/* addi R11, R11, 1 */
		/* 820D11A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D11A4h case    3:*/		return 0x820D11A8;
		  /* 820D11A8h */ case    4:  		/* addi R10, R10, 1 */
		/* 820D11A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D11A8h case    4:*/		return 0x820D11AC;
		  /* 820D11ACh */ case    5:  		/* cmpwi CR6, R9, 0 */
		/* 820D11ACh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D11ACh case    5:*/		return 0x820D11B0;
		  /* 820D11B0h */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 820D11B0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D1190;  }
		/* 820D11B0h case    6:*/		return 0x820D11B4;
	}
	return 0x820D11B4;
} // Block from 820D1198h-820D11B4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D11B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D11B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D11B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D11B4);
		  /* 820D11B4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D11B4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D11B4h case    0:*/		return 0x820D11B8;
		  /* 820D11B8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D11B8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D11C4;  }
		/* 820D11B8h case    1:*/		return 0x820D11BC;
		  /* 820D11BCh */ case    2:  		/* li R11, 4 */
		/* 820D11BCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820D11BCh case    2:*/		return 0x820D11C0;
		  /* 820D11C0h */ case    3:  		/* b -204 */
		/* 820D11C0h case    3:*/		return 0x820D10F4;
		/* 820D11C0h case    3:*/		return 0x820D11C4;
	}
	return 0x820D11C4;
} // Block from 820D11B4h-820D11C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D11C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D11C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D11C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D11C4);
		  /* 820D11C4h */ case    0:  		/* mr R10, R27 */
		/* 820D11C4h case    0:*/		regs.R10 = regs.R27;
		/* 820D11C4h case    0:*/		return 0x820D11C8;
		  /* 820D11C8h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D11C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D11C8h case    1:*/		return 0x820D11CC;
		  /* 820D11CCh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D11CCh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D11CCh case    2:*/		return 0x820D11D0;
		  /* 820D11D0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D11D0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D11D0h case    3:*/		return 0x820D11D4;
		  /* 820D11D4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D11D4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D11D4h case    4:*/		return 0x820D11D8;
		  /* 820D11D8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D11D8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D11D8h case    5:*/		return 0x820D11DC;
		  /* 820D11DCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D11DCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820D11F0;  }
		/* 820D11DCh case    6:*/		return 0x820D11E0;
		  /* 820D11E0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D11E0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D11E0h case    7:*/		return 0x820D11E4;
		  /* 820D11E4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D11E4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D11E4h case    8:*/		return 0x820D11E8;
		  /* 820D11E8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D11E8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D11E8h case    9:*/		return 0x820D11EC;
		  /* 820D11ECh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D11ECh case   10:*/		if ( regs.CR[6].eq ) { return 0x820D11CC;  }
		/* 820D11ECh case   10:*/		return 0x820D11F0;
	}
	return 0x820D11F0;
} // Block from 820D11C4h-820D11F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D11F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D11F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D11F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D11F0);
		  /* 820D11F0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D11F0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D11F0h case    0:*/		return 0x820D11F4;
		  /* 820D11F4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D11F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1200;  }
		/* 820D11F4h case    1:*/		return 0x820D11F8;
		  /* 820D11F8h */ case    2:  		/* li R11, 5 */
		/* 820D11F8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820D11F8h case    2:*/		return 0x820D11FC;
		  /* 820D11FCh */ case    3:  		/* b -264 */
		/* 820D11FCh case    3:*/		return 0x820D10F4;
		/* 820D11FCh case    3:*/		return 0x820D1200;
	}
	return 0x820D1200;
} // Block from 820D11F0h-820D1200h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1200);
		  /* 820D1200h */ case    0:  		/* lwz R10, <#[R1 + 136]> */
		/* 820D1200h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 820D1200h case    0:*/		return 0x820D1204;
		  /* 820D1204h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1204h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1204h case    1:*/		return 0x820D1208;
		  /* 820D1208h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1208h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1208h case    2:*/		return 0x820D120C;
		  /* 820D120Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D120Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D120Ch case    3:*/		return 0x820D1210;
		  /* 820D1210h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1210h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1210h case    4:*/		return 0x820D1214;
		  /* 820D1214h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1214h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1214h case    5:*/		return 0x820D1218;
		  /* 820D1218h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1218h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D122C;  }
		/* 820D1218h case    6:*/		return 0x820D121C;
		  /* 820D121Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820D121Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D121Ch case    7:*/		return 0x820D1220;
		  /* 820D1220h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1220h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1220h case    8:*/		return 0x820D1224;
		  /* 820D1224h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1224h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1224h case    9:*/		return 0x820D1228;
		  /* 820D1228h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1228h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1208;  }
		/* 820D1228h case   10:*/		return 0x820D122C;
	}
	return 0x820D122C;
} // Block from 820D1200h-820D122Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D122Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D122C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D122C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D122C);
		  /* 820D122Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D122Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D122Ch case    0:*/		return 0x820D1230;
		  /* 820D1230h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1230h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D123C;  }
		/* 820D1230h case    1:*/		return 0x820D1234;
		  /* 820D1234h */ case    2:  		/* li R11, 6 */
		/* 820D1234h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820D1234h case    2:*/		return 0x820D1238;
		  /* 820D1238h */ case    3:  		/* b -324 */
		/* 820D1238h case    3:*/		return 0x820D10F4;
		/* 820D1238h case    3:*/		return 0x820D123C;
	}
	return 0x820D123C;
} // Block from 820D122Ch-820D123Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D123Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D123C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D123C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D123C);
		  /* 820D123Ch */ case    0:  		/* lwz R10, <#[R1 + 140]> */
		/* 820D123Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 820D123Ch case    0:*/		return 0x820D1240;
		  /* 820D1240h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1240h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1240h case    1:*/		return 0x820D1244;
		  /* 820D1244h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1244h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1244h case    2:*/		return 0x820D1248;
		  /* 820D1248h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1248h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1248h case    3:*/		return 0x820D124C;
		  /* 820D124Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D124Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D124Ch case    4:*/		return 0x820D1250;
		  /* 820D1250h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1250h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1250h case    5:*/		return 0x820D1254;
		  /* 820D1254h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1254h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1268;  }
		/* 820D1254h case    6:*/		return 0x820D1258;
		  /* 820D1258h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1258h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1258h case    7:*/		return 0x820D125C;
		  /* 820D125Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D125Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D125Ch case    8:*/		return 0x820D1260;
		  /* 820D1260h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1260h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1260h case    9:*/		return 0x820D1264;
		  /* 820D1264h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1264h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1244;  }
		/* 820D1264h case   10:*/		return 0x820D1268;
	}
	return 0x820D1268;
} // Block from 820D123Ch-820D1268h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1268);
		  /* 820D1268h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1268h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1268h case    0:*/		return 0x820D126C;
		  /* 820D126Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D126Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1278;  }
		/* 820D126Ch case    1:*/		return 0x820D1270;
		  /* 820D1270h */ case    2:  		/* li R11, 7 */
		/* 820D1270h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820D1270h case    2:*/		return 0x820D1274;
		  /* 820D1274h */ case    3:  		/* b -384 */
		/* 820D1274h case    3:*/		return 0x820D10F4;
		/* 820D1274h case    3:*/		return 0x820D1278;
	}
	return 0x820D1278;
} // Block from 820D1268h-820D1278h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1278);
		  /* 820D1278h */ case    0:  		/* lwz R10, <#[R1 + 144]> */
		/* 820D1278h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 820D1278h case    0:*/		return 0x820D127C;
		  /* 820D127Ch */ case    1:  		/* addi R11, R1, 208 */
		/* 820D127Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D127Ch case    1:*/		return 0x820D1280;
		  /* 820D1280h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1280h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1280h case    2:*/		return 0x820D1284;
		  /* 820D1284h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1284h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1284h case    3:*/		return 0x820D1288;
		  /* 820D1288h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1288h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1288h case    4:*/		return 0x820D128C;
		  /* 820D128Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820D128Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D128Ch case    5:*/		return 0x820D1290;
		  /* 820D1290h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1290h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D12A4;  }
		/* 820D1290h case    6:*/		return 0x820D1294;
		  /* 820D1294h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1294h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1294h case    7:*/		return 0x820D1298;
		  /* 820D1298h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1298h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1298h case    8:*/		return 0x820D129C;
		  /* 820D129Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D129Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D129Ch case    9:*/		return 0x820D12A0;
		  /* 820D12A0h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D12A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1280;  }
		/* 820D12A0h case   10:*/		return 0x820D12A4;
	}
	return 0x820D12A4;
} // Block from 820D1278h-820D12A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D12A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D12A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D12A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D12A4);
		  /* 820D12A4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D12A4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D12A4h case    0:*/		return 0x820D12A8;
		  /* 820D12A8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D12A8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D12B4;  }
		/* 820D12A8h case    1:*/		return 0x820D12AC;
		  /* 820D12ACh */ case    2:  		/* li R11, 8 */
		/* 820D12ACh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820D12ACh case    2:*/		return 0x820D12B0;
		  /* 820D12B0h */ case    3:  		/* b -444 */
		/* 820D12B0h case    3:*/		return 0x820D10F4;
		/* 820D12B0h case    3:*/		return 0x820D12B4;
	}
	return 0x820D12B4;
} // Block from 820D12A4h-820D12B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D12B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D12B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D12B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D12B4);
		  /* 820D12B4h */ case    0:  		/* lwz R10, <#[R1 + 148]> */
		/* 820D12B4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000094) );
		/* 820D12B4h case    0:*/		return 0x820D12B8;
		  /* 820D12B8h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D12B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D12B8h case    1:*/		return 0x820D12BC;
		  /* 820D12BCh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D12BCh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D12BCh case    2:*/		return 0x820D12C0;
		  /* 820D12C0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D12C0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D12C0h case    3:*/		return 0x820D12C4;
		  /* 820D12C4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D12C4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D12C4h case    4:*/		return 0x820D12C8;
		  /* 820D12C8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D12C8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D12C8h case    5:*/		return 0x820D12CC;
		  /* 820D12CCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D12CCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820D12E0;  }
		/* 820D12CCh case    6:*/		return 0x820D12D0;
		  /* 820D12D0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D12D0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D12D0h case    7:*/		return 0x820D12D4;
		  /* 820D12D4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D12D4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D12D4h case    8:*/		return 0x820D12D8;
	}
	return 0x820D12D8;
} // Block from 820D12B4h-820D12D8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D12D8h
// Function '?Static_Error@CUAssembler@D3DXShader@@SAXPAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D12D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D12D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D12D8);
		  /* 820D12D8h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 820D12D8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D12D8h case    0:*/		return 0x820D12DC;
		  /* 820D12DCh */ case    1:  		/* bc 12, CR6_EQ, -32 */
		/* 820D12DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820D12BC;  }
		/* 820D12DCh case    1:*/		return 0x820D12E0;
	}
	return 0x820D12E0;
} // Block from 820D12D8h-820D12E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D12E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D12E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D12E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D12E0);
		  /* 820D12E0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D12E0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D12E0h case    0:*/		return 0x820D12E4;
		  /* 820D12E4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D12E4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D12F0;  }
		/* 820D12E4h case    1:*/		return 0x820D12E8;
		  /* 820D12E8h */ case    2:  		/* lwz R4, <#[R1 + 168]> */
		/* 820D12E8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A8) );
		/* 820D12E8h case    2:*/		return 0x820D12EC;
		  /* 820D12ECh */ case    3:  		/* b -600 */
		/* 820D12ECh case    3:*/		return 0x820D1094;
		/* 820D12ECh case    3:*/		return 0x820D12F0;
	}
	return 0x820D12F0;
} // Block from 820D12E0h-820D12F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D12F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D12F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D12F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D12F0);
		  /* 820D12F0h */ case    0:  		/* lwz R10, <#[R1 + 152]> */
		/* 820D12F0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 820D12F0h case    0:*/		return 0x820D12F4;
		  /* 820D12F4h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D12F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D12F4h case    1:*/		return 0x820D12F8;
		  /* 820D12F8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D12F8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D12F8h case    2:*/		return 0x820D12FC;
		  /* 820D12FCh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D12FCh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D12FCh case    3:*/		return 0x820D1300;
		  /* 820D1300h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1300h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1300h case    4:*/		return 0x820D1304;
		  /* 820D1304h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1304h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1304h case    5:*/		return 0x820D1308;
		  /* 820D1308h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1308h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D131C;  }
		/* 820D1308h case    6:*/		return 0x820D130C;
		  /* 820D130Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820D130Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D130Ch case    7:*/		return 0x820D1310;
		  /* 820D1310h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1310h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1310h case    8:*/		return 0x820D1314;
		  /* 820D1314h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1314h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1314h case    9:*/		return 0x820D1318;
		  /* 820D1318h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1318h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D12F8;  }
		/* 820D1318h case   10:*/		return 0x820D131C;
	}
	return 0x820D131C;
} // Block from 820D12F0h-820D131Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D131Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D131C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D131C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D131C);
		  /* 820D131Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D131Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D131Ch case    0:*/		return 0x820D1320;
		  /* 820D1320h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1320h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D132C;  }
		/* 820D1320h case    1:*/		return 0x820D1324;
		  /* 820D1324h */ case    2:  		/* li R11, 10 */
		/* 820D1324h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820D1324h case    2:*/		return 0x820D1328;
	}
	return 0x820D1328;
} // Block from 820D131Ch-820D1328h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1328h
// Function '?ErrorCallback@CUAssembler@D3DXShader@@KAXPAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1328);
		  /* 820D1328h */ case    0:  		/* b -564 */
		/* 820D1328h case    0:*/		return 0x820D10F4;
		/* 820D1328h case    0:*/		return 0x820D132C;
	}
	return 0x820D132C;
} // Block from 820D1328h-820D132Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D132Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D132C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D132C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D132C);
		  /* 820D132Ch */ case    0:  		/* lwz R10, <#[R1 + 156]> */
		/* 820D132Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000009C) );
		/* 820D132Ch case    0:*/		return 0x820D1330;
		  /* 820D1330h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1330h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1330h case    1:*/		return 0x820D1334;
		  /* 820D1334h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1334h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1334h case    2:*/		return 0x820D1338;
		  /* 820D1338h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1338h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1338h case    3:*/		return 0x820D133C;
		  /* 820D133Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D133Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D133Ch case    4:*/		return 0x820D1340;
		  /* 820D1340h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1340h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1340h case    5:*/		return 0x820D1344;
		  /* 820D1344h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1344h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1358;  }
		/* 820D1344h case    6:*/		return 0x820D1348;
		  /* 820D1348h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1348h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1348h case    7:*/		return 0x820D134C;
		  /* 820D134Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D134Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D134Ch case    8:*/		return 0x820D1350;
		  /* 820D1350h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1350h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1350h case    9:*/		return 0x820D1354;
		  /* 820D1354h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1354h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1334;  }
		/* 820D1354h case   10:*/		return 0x820D1358;
	}
	return 0x820D1358;
} // Block from 820D132Ch-820D1358h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1358);
		  /* 820D1358h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1358h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1358h case    0:*/		return 0x820D135C;
		  /* 820D135Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D135Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1368;  }
		/* 820D135Ch case    1:*/		return 0x820D1360;
		  /* 820D1360h */ case    2:  		/* li R11, 11 */
		/* 820D1360h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820D1360h case    2:*/		return 0x820D1364;
		  /* 820D1364h */ case    3:  		/* b -624 */
		/* 820D1364h case    3:*/		return 0x820D10F4;
		/* 820D1364h case    3:*/		return 0x820D1368;
	}
	return 0x820D1368;
} // Block from 820D1358h-820D1368h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1368);
		  /* 820D1368h */ case    0:  		/* lwz R10, <#[R1 + 160]> */
		/* 820D1368h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A0) );
		/* 820D1368h case    0:*/		return 0x820D136C;
		  /* 820D136Ch */ case    1:  		/* addi R11, R1, 208 */
		/* 820D136Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D136Ch case    1:*/		return 0x820D1370;
		  /* 820D1370h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1370h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1370h case    2:*/		return 0x820D1374;
		  /* 820D1374h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1374h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1374h case    3:*/		return 0x820D1378;
	}
	return 0x820D1378;
} // Block from 820D1368h-820D1378h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1378h
// Function '?DecodeOpcode@CUAssembler@D3DXShader@@IAAHPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1378);
		  /* 820D1378h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1378h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1378h case    0:*/		return 0x820D137C;
		  /* 820D137Ch */ case    1:  		/* subf R9, R8, R9 */
		/* 820D137Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D137Ch case    1:*/		return 0x820D1380;
		  /* 820D1380h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1380h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D1394;  }
		/* 820D1380h case    2:*/		return 0x820D1384;
		  /* 820D1384h */ case    3:  		/* addi R11, R11, 1 */
		/* 820D1384h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1384h case    3:*/		return 0x820D1388;
		  /* 820D1388h */ case    4:  		/* addi R10, R10, 1 */
		/* 820D1388h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1388h case    4:*/		return 0x820D138C;
		  /* 820D138Ch */ case    5:  		/* cmpwi CR6, R9, 0 */
		/* 820D138Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D138Ch case    5:*/		return 0x820D1390;
		  /* 820D1390h */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1390h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D1370;  }
		/* 820D1390h case    6:*/		return 0x820D1394;
	}
	return 0x820D1394;
} // Block from 820D1378h-820D1394h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D1394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1394);
		  /* 820D1394h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1394h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1394h case    0:*/		return 0x820D1398;
		  /* 820D1398h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1398h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D13A4;  }
		/* 820D1398h case    1:*/		return 0x820D139C;
		  /* 820D139Ch */ case    2:  		/* li R11, 12 */
		/* 820D139Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820D139Ch case    2:*/		return 0x820D13A0;
		  /* 820D13A0h */ case    3:  		/* b -684 */
		/* 820D13A0h case    3:*/		return 0x820D10F4;
		/* 820D13A0h case    3:*/		return 0x820D13A4;
	}
	return 0x820D13A4;
} // Block from 820D1394h-820D13A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D13A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D13A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D13A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D13A4);
		  /* 820D13A4h */ case    0:  		/* lwz R10, <#[R1 + 164]> */
		/* 820D13A4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A4) );
		/* 820D13A4h case    0:*/		return 0x820D13A8;
		  /* 820D13A8h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D13A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D13A8h case    1:*/		return 0x820D13AC;
		  /* 820D13ACh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D13ACh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D13ACh case    2:*/		return 0x820D13B0;
		  /* 820D13B0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D13B0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D13B0h case    3:*/		return 0x820D13B4;
		  /* 820D13B4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D13B4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D13B4h case    4:*/		return 0x820D13B8;
		  /* 820D13B8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D13B8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D13B8h case    5:*/		return 0x820D13BC;
		  /* 820D13BCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D13BCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820D13D0;  }
		/* 820D13BCh case    6:*/		return 0x820D13C0;
		  /* 820D13C0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D13C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D13C0h case    7:*/		return 0x820D13C4;
		  /* 820D13C4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D13C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D13C4h case    8:*/		return 0x820D13C8;
		  /* 820D13C8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D13C8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D13C8h case    9:*/		return 0x820D13CC;
		  /* 820D13CCh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D13CCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820D13AC;  }
		/* 820D13CCh case   10:*/		return 0x820D13D0;
	}
	return 0x820D13D0;
} // Block from 820D13A4h-820D13D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D13D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D13D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D13D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D13D0);
		  /* 820D13D0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D13D0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D13D0h case    0:*/		return 0x820D13D4;
		  /* 820D13D4h */ case    1:  		/* bc 4, CR0_EQ, -824 */
		/* 820D13D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D109C;  }
		/* 820D13D4h case    1:*/		return 0x820D13D8;
		  /* 820D13D8h */ case    2:  		/* li R11, 13 */
		/* 820D13D8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820D13D8h case    2:*/		return 0x820D13DC;
		  /* 820D13DCh */ case    3:  		/* b -744 */
		/* 820D13DCh case    3:*/		return 0x820D10F4;
		/* 820D13DCh case    3:*/		return 0x820D13E0;
		  /* 820D13E0h */ case    4:  		/* lbz R11, <#[R31]> */
		/* 820D13E0h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D13E0h case    4:*/		return 0x820D13E4;
		  /* 820D13E4h */ case    5:  		/* extsb R3, R11 */
		/* 820D13E4h case    5:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D13E4h case    5:*/		return 0x820D13E8;
		  /* 820D13E8h */ case    6:  		/* bl -228600 */
		/* 820D13E8h case    6:*/		regs.LR = 0x820D13EC; return 0x820996F0;
		/* 820D13E8h case    6:*/		return 0x820D13EC;
		  /* 820D13ECh */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820D13ECh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D13ECh case    7:*/		return 0x820D13F0;
		  /* 820D13F0h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 820D13F0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820D1400;  }
		/* 820D13F0h case    8:*/		return 0x820D13F4;
		  /* 820D13F4h */ case    9:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820D13F4h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820D13F4h case    9:*/		return 0x820D13F8;
	}
	return 0x820D13F8;
} // Block from 820D13D0h-820D13F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D13F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D13F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D13F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D13F8);
		  /* 820D13F8h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820D13F8h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D13F8h case    0:*/		return 0x820D13FC;
		  /* 820D13FCh */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820D13FCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D13E0;  }
		/* 820D13FCh case    1:*/		return 0x820D1400;
	}
	return 0x820D1400;
} // Block from 820D13F8h-820D1400h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D1400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1400);
		  /* 820D1400h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D1400h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D1400h case    0:*/		return 0x820D1404;
		  /* 820D1404h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D1404h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D1404h case    1:*/		return 0x820D1408;
		  /* 820D1408h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1408h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D141C;  }
		/* 820D1408h case    2:*/		return 0x820D140C;
		  /* 820D140Ch */ case    3:  		/* mr R3, R31 */
		/* 820D140Ch case    3:*/		regs.R3 = regs.R31;
		/* 820D140Ch case    3:*/		return 0x820D1410;
		  /* 820D1410h */ case    4:  		/* bl -256168 */
		/* 820D1410h case    4:*/		regs.LR = 0x820D1414; return 0x82092B68;
		/* 820D1410h case    4:*/		return 0x820D1414;
		  /* 820D1414h */ case    5:  		/* mr R30, R3 */
		/* 820D1414h case    5:*/		regs.R30 = regs.R3;
		/* 820D1414h case    5:*/		return 0x820D1418;
		  /* 820D1418h */ case    6:  		/* b 8 */
		/* 820D1418h case    6:*/		return 0x820D1420;
		/* 820D1418h case    6:*/		return 0x820D141C;
	}
	return 0x820D141C;
} // Block from 820D1400h-820D141Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D141Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D141C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D141C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D141C);
		  /* 820D141Ch */ case    0:  		/* mr R30, R16 */
		/* 820D141Ch case    0:*/		regs.R30 = regs.R16;
		/* 820D141Ch case    0:*/		return 0x820D1420;
	}
	return 0x820D1420;
} // Block from 820D141Ch-820D1420h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D1420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1420);
		  /* 820D1420h */ case    0:  		/* cmplwi CR6, R30, 15 */
		/* 820D1420h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000F);
		/* 820D1420h case    0:*/		return 0x820D1424;
		  /* 820D1424h */ case    1:  		/* bc 12, CR6_GT, -2488 */
		/* 820D1424h case    1:*/		if ( regs.CR[6].gt ) { return 0x820D0A6C;  }
		/* 820D1424h case    1:*/		return 0x820D1428;
		  /* 820D1428h */ case    2:  		/* lbz R11, <#[R31]> */
		/* 820D1428h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D1428h case    2:*/		return 0x820D142C;
		  /* 820D142Ch */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820D142Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D142Ch case    3:*/		return 0x820D1430;
		  /* 820D1430h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 820D1430h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D143C;  }
		/* 820D1430h case    4:*/		return 0x820D1434;
		  /* 820D1434h */ case    5:  		/* stb R16, <#[R31]> */
		/* 820D1434h case    5:*/		cpu::mem::store8( regs, regs.R16, (uint32)(regs.R31 + 0x00000000) );
		/* 820D1434h case    5:*/		return 0x820D1438;
		  /* 820D1438h */ case    6:  		/* addi R31, R31, 1 */
		/* 820D1438h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820D1438h case    6:*/		return 0x820D143C;
	}
	return 0x820D143C;
} // Block from 820D1420h-820D143Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D143Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D143C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D143C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D143C);
		  /* 820D143Ch */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D143Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D143Ch case    0:*/		return 0x820D1440;
		  /* 820D1440h */ case    1:  		/* b 20 */
		/* 820D1440h case    1:*/		return 0x820D1454;
		/* 820D1440h case    1:*/		return 0x820D1444;
		  /* 820D1444h */ case    2:  		/* bl -228660 */
		/* 820D1444h case    2:*/		regs.LR = 0x820D1448; return 0x82099710;
		/* 820D1444h case    2:*/		return 0x820D1448;
		  /* 820D1448h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D1448h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D1448h case    3:*/		return 0x820D144C;
		  /* 820D144Ch */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820D144Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820D145C;  }
		/* 820D144Ch case    4:*/		return 0x820D1450;
		  /* 820D1450h */ case    5:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820D1450h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820D1450h case    5:*/		return 0x820D1454;
	}
	return 0x820D1454;
} // Block from 820D143Ch-820D1454h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D1454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1454);
		  /* 820D1454h */ case    0:  		/* extsb. R3, R11 */
		/* 820D1454h case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820D1454h case    0:*/		return 0x820D1458;
		  /* 820D1458h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820D1458h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1444;  }
		/* 820D1458h case    1:*/		return 0x820D145C;
	}
	return 0x820D145C;
} // Block from 820D1454h-820D145Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D145Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D145C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D145C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D145C);
		  /* 820D145Ch */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D145Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D145Ch case    0:*/		return 0x820D1460;
		  /* 820D1460h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D1460h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D1460h case    1:*/		return 0x820D1464;
		  /* 820D1464h */ case    2:  		/* bc 4, CR0_EQ, -2552 */
		/* 820D1464h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820D0A6C;  }
		/* 820D1464h case    2:*/		return 0x820D1468;
		  /* 820D1468h */ case    3:  		/* mr R10, R22 */
		/* 820D1468h case    3:*/		regs.R10 = regs.R22;
		/* 820D1468h case    3:*/		return 0x820D146C;
		  /* 820D146Ch */ case    4:  		/* addi R11, R1, 208 */
		/* 820D146Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D146Ch case    4:*/		return 0x820D1470;
		  /* 820D1470h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820D1470h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1470h case    5:*/		return 0x820D1474;
		  /* 820D1474h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820D1474h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1474h case    6:*/		return 0x820D1478;
		  /* 820D1478h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820D1478h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1478h case    7:*/		return 0x820D147C;
		  /* 820D147Ch */ case    8:  		/* subf R9, R8, R9 */
		/* 820D147Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D147Ch case    8:*/		return 0x820D1480;
		  /* 820D1480h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1480h case    9:*/		if ( regs.CR[0].eq ) { return 0x820D1494;  }
		/* 820D1480h case    9:*/		return 0x820D1484;
		  /* 820D1484h */ case   10:  		/* addi R11, R11, 1 */
		/* 820D1484h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1484h case   10:*/		return 0x820D1488;
		  /* 820D1488h */ case   11:  		/* addi R10, R10, 1 */
		/* 820D1488h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1488h case   11:*/		return 0x820D148C;
		  /* 820D148Ch */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820D148Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D148Ch case   12:*/		return 0x820D1490;
		  /* 820D1490h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1490h case   13:*/		if ( regs.CR[6].eq ) { return 0x820D1470;  }
		/* 820D1490h case   13:*/		return 0x820D1494;
	}
	return 0x820D1494;
} // Block from 820D145Ch-820D1494h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D1494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1494);
		  /* 820D1494h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1494h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1494h case    0:*/		return 0x820D1498;
		  /* 820D1498h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1498h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D14A4;  }
		/* 820D1498h case    1:*/		return 0x820D149C;
		  /* 820D149Ch */ case    2:  		/* mr R11, R16 */
		/* 820D149Ch case    2:*/		regs.R11 = regs.R16;
		/* 820D149Ch case    2:*/		return 0x820D14A0;
		  /* 820D14A0h */ case    3:  		/* b 952 */
		/* 820D14A0h case    3:*/		return 0x820D1858;
		/* 820D14A0h case    3:*/		return 0x820D14A4;
	}
	return 0x820D14A4;
} // Block from 820D1494h-820D14A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D14A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D14A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D14A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D14A4);
		  /* 820D14A4h */ case    0:  		/* mr R10, R23 */
		/* 820D14A4h case    0:*/		regs.R10 = regs.R23;
		/* 820D14A4h case    0:*/		return 0x820D14A8;
		  /* 820D14A8h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D14A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D14A8h case    1:*/		return 0x820D14AC;
		  /* 820D14ACh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D14ACh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D14ACh case    2:*/		return 0x820D14B0;
		  /* 820D14B0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D14B0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D14B0h case    3:*/		return 0x820D14B4;
		  /* 820D14B4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D14B4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D14B4h case    4:*/		return 0x820D14B8;
		  /* 820D14B8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D14B8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D14B8h case    5:*/		return 0x820D14BC;
		  /* 820D14BCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D14BCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820D14D0;  }
		/* 820D14BCh case    6:*/		return 0x820D14C0;
		  /* 820D14C0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D14C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D14C0h case    7:*/		return 0x820D14C4;
		  /* 820D14C4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D14C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D14C4h case    8:*/		return 0x820D14C8;
		  /* 820D14C8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D14C8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D14C8h case    9:*/		return 0x820D14CC;
		  /* 820D14CCh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D14CCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820D14AC;  }
		/* 820D14CCh case   10:*/		return 0x820D14D0;
	}
	return 0x820D14D0;
} // Block from 820D14A4h-820D14D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D14D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D14D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D14D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D14D0);
		  /* 820D14D0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D14D0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D14D0h case    0:*/		return 0x820D14D4;
		  /* 820D14D4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D14D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D14E0;  }
		/* 820D14D4h case    1:*/		return 0x820D14D8;
		  /* 820D14D8h */ case    2:  		/* li R11, 1 */
		/* 820D14D8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D14D8h case    2:*/		return 0x820D14DC;
		  /* 820D14DCh */ case    3:  		/* b 892 */
		/* 820D14DCh case    3:*/		return 0x820D1858;
		/* 820D14DCh case    3:*/		return 0x820D14E0;
	}
	return 0x820D14E0;
} // Block from 820D14D0h-820D14E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D14E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D14E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D14E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D14E0);
		  /* 820D14E0h */ case    0:  		/* mr R10, R24 */
		/* 820D14E0h case    0:*/		regs.R10 = regs.R24;
		/* 820D14E0h case    0:*/		return 0x820D14E4;
		  /* 820D14E4h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D14E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D14E4h case    1:*/		return 0x820D14E8;
		  /* 820D14E8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D14E8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D14E8h case    2:*/		return 0x820D14EC;
		  /* 820D14ECh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D14ECh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D14ECh case    3:*/		return 0x820D14F0;
		  /* 820D14F0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D14F0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D14F0h case    4:*/		return 0x820D14F4;
		  /* 820D14F4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D14F4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D14F4h case    5:*/		return 0x820D14F8;
		  /* 820D14F8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D14F8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D150C;  }
		/* 820D14F8h case    6:*/		return 0x820D14FC;
		  /* 820D14FCh */ case    7:  		/* addi R11, R11, 1 */
		/* 820D14FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D14FCh case    7:*/		return 0x820D1500;
		  /* 820D1500h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1500h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1500h case    8:*/		return 0x820D1504;
		  /* 820D1504h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1504h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1504h case    9:*/		return 0x820D1508;
		  /* 820D1508h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1508h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D14E8;  }
		/* 820D1508h case   10:*/		return 0x820D150C;
	}
	return 0x820D150C;
} // Block from 820D14E0h-820D150Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D150Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D150C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D150C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D150C);
		  /* 820D150Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D150Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D150Ch case    0:*/		return 0x820D1510;
		  /* 820D1510h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1510h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D151C;  }
		/* 820D1510h case    1:*/		return 0x820D1514;
		  /* 820D1514h */ case    2:  		/* li R11, 2 */
		/* 820D1514h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820D1514h case    2:*/		return 0x820D1518;
		  /* 820D1518h */ case    3:  		/* b 832 */
		/* 820D1518h case    3:*/		return 0x820D1858;
		/* 820D1518h case    3:*/		return 0x820D151C;
	}
	return 0x820D151C;
} // Block from 820D150Ch-820D151Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D151Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D151C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D151C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D151C);
		  /* 820D151Ch */ case    0:  		/* mr R10, R25 */
		/* 820D151Ch case    0:*/		regs.R10 = regs.R25;
		/* 820D151Ch case    0:*/		return 0x820D1520;
		  /* 820D1520h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1520h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1520h case    1:*/		return 0x820D1524;
		  /* 820D1524h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1524h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1524h case    2:*/		return 0x820D1528;
		  /* 820D1528h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1528h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1528h case    3:*/		return 0x820D152C;
		  /* 820D152Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D152Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D152Ch case    4:*/		return 0x820D1530;
		  /* 820D1530h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1530h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1530h case    5:*/		return 0x820D1534;
		  /* 820D1534h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1534h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1548;  }
		/* 820D1534h case    6:*/		return 0x820D1538;
		  /* 820D1538h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1538h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1538h case    7:*/		return 0x820D153C;
		  /* 820D153Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D153Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D153Ch case    8:*/		return 0x820D1540;
		  /* 820D1540h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1540h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1540h case    9:*/		return 0x820D1544;
		  /* 820D1544h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1544h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1524;  }
		/* 820D1544h case   10:*/		return 0x820D1548;
	}
	return 0x820D1548;
} // Block from 820D151Ch-820D1548h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1548);
		  /* 820D1548h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1548h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1548h case    0:*/		return 0x820D154C;
		  /* 820D154Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D154Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1558;  }
		/* 820D154Ch case    1:*/		return 0x820D1550;
		  /* 820D1550h */ case    2:  		/* li R11, 3 */
		/* 820D1550h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820D1550h case    2:*/		return 0x820D1554;
		  /* 820D1554h */ case    3:  		/* b 772 */
		/* 820D1554h case    3:*/		return 0x820D1858;
		/* 820D1554h case    3:*/		return 0x820D1558;
	}
	return 0x820D1558;
} // Block from 820D1548h-820D1558h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1558);
		  /* 820D1558h */ case    0:  		/* lwz R10, <#[R1 + 132]> */
		/* 820D1558h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 820D1558h case    0:*/		return 0x820D155C;
		  /* 820D155Ch */ case    1:  		/* addi R11, R1, 208 */
		/* 820D155Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D155Ch case    1:*/		return 0x820D1560;
		  /* 820D1560h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1560h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1560h case    2:*/		return 0x820D1564;
		  /* 820D1564h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1564h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1564h case    3:*/		return 0x820D1568;
		  /* 820D1568h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1568h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1568h case    4:*/		return 0x820D156C;
		  /* 820D156Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820D156Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D156Ch case    5:*/		return 0x820D1570;
		  /* 820D1570h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1570h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1584;  }
		/* 820D1570h case    6:*/		return 0x820D1574;
		  /* 820D1574h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1574h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1574h case    7:*/		return 0x820D1578;
		  /* 820D1578h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1578h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1578h case    8:*/		return 0x820D157C;
		  /* 820D157Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D157Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D157Ch case    9:*/		return 0x820D1580;
		  /* 820D1580h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1580h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1560;  }
		/* 820D1580h case   10:*/		return 0x820D1584;
	}
	return 0x820D1584;
} // Block from 820D1558h-820D1584h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1584);
		  /* 820D1584h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1584h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1584h case    0:*/		return 0x820D1588;
		  /* 820D1588h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1588h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1594;  }
		/* 820D1588h case    1:*/		return 0x820D158C;
		  /* 820D158Ch */ case    2:  		/* li R11, 4 */
		/* 820D158Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820D158Ch case    2:*/		return 0x820D1590;
		  /* 820D1590h */ case    3:  		/* b 712 */
		/* 820D1590h case    3:*/		return 0x820D1858;
		/* 820D1590h case    3:*/		return 0x820D1594;
	}
	return 0x820D1594;
} // Block from 820D1584h-820D1594h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1594);
		  /* 820D1594h */ case    0:  		/* mr R10, R27 */
		/* 820D1594h case    0:*/		regs.R10 = regs.R27;
		/* 820D1594h case    0:*/		return 0x820D1598;
		  /* 820D1598h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1598h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1598h case    1:*/		return 0x820D159C;
		  /* 820D159Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D159Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D159Ch case    2:*/		return 0x820D15A0;
		  /* 820D15A0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D15A0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D15A0h case    3:*/		return 0x820D15A4;
		  /* 820D15A4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D15A4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D15A4h case    4:*/		return 0x820D15A8;
		  /* 820D15A8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D15A8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D15A8h case    5:*/		return 0x820D15AC;
		  /* 820D15ACh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D15ACh case    6:*/		if ( regs.CR[0].eq ) { return 0x820D15C0;  }
		/* 820D15ACh case    6:*/		return 0x820D15B0;
		  /* 820D15B0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D15B0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D15B0h case    7:*/		return 0x820D15B4;
		  /* 820D15B4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D15B4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D15B4h case    8:*/		return 0x820D15B8;
		  /* 820D15B8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D15B8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D15B8h case    9:*/		return 0x820D15BC;
		  /* 820D15BCh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D15BCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820D159C;  }
		/* 820D15BCh case   10:*/		return 0x820D15C0;
	}
	return 0x820D15C0;
} // Block from 820D1594h-820D15C0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D15C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D15C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D15C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D15C0);
		  /* 820D15C0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D15C0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D15C0h case    0:*/		return 0x820D15C4;
		  /* 820D15C4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D15C4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D15D0;  }
		/* 820D15C4h case    1:*/		return 0x820D15C8;
		  /* 820D15C8h */ case    2:  		/* li R11, 5 */
		/* 820D15C8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820D15C8h case    2:*/		return 0x820D15CC;
		  /* 820D15CCh */ case    3:  		/* b 652 */
		/* 820D15CCh case    3:*/		return 0x820D1858;
		/* 820D15CCh case    3:*/		return 0x820D15D0;
	}
	return 0x820D15D0;
} // Block from 820D15C0h-820D15D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D15D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D15D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D15D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D15D0);
		  /* 820D15D0h */ case    0:  		/* lwz R10, <#[R1 + 136]> */
		/* 820D15D0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 820D15D0h case    0:*/		return 0x820D15D4;
		  /* 820D15D4h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D15D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D15D4h case    1:*/		return 0x820D15D8;
		  /* 820D15D8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D15D8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D15D8h case    2:*/		return 0x820D15DC;
		  /* 820D15DCh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D15DCh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D15DCh case    3:*/		return 0x820D15E0;
		  /* 820D15E0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D15E0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D15E0h case    4:*/		return 0x820D15E4;
		  /* 820D15E4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D15E4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D15E4h case    5:*/		return 0x820D15E8;
		  /* 820D15E8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D15E8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D15FC;  }
		/* 820D15E8h case    6:*/		return 0x820D15EC;
		  /* 820D15ECh */ case    7:  		/* addi R11, R11, 1 */
		/* 820D15ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D15ECh case    7:*/		return 0x820D15F0;
		  /* 820D15F0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D15F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D15F0h case    8:*/		return 0x820D15F4;
		  /* 820D15F4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D15F4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D15F4h case    9:*/		return 0x820D15F8;
		  /* 820D15F8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D15F8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D15D8;  }
		/* 820D15F8h case   10:*/		return 0x820D15FC;
	}
	return 0x820D15FC;
} // Block from 820D15D0h-820D15FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D15FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D15FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D15FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D15FC);
		  /* 820D15FCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D15FCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D15FCh case    0:*/		return 0x820D1600;
		  /* 820D1600h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1600h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D160C;  }
		/* 820D1600h case    1:*/		return 0x820D1604;
		  /* 820D1604h */ case    2:  		/* li R11, 6 */
		/* 820D1604h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820D1604h case    2:*/		return 0x820D1608;
		  /* 820D1608h */ case    3:  		/* b 592 */
		/* 820D1608h case    3:*/		return 0x820D1858;
		/* 820D1608h case    3:*/		return 0x820D160C;
	}
	return 0x820D160C;
} // Block from 820D15FCh-820D160Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D160Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D160C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D160C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D160C);
		  /* 820D160Ch */ case    0:  		/* lwz R10, <#[R1 + 140]> */
		/* 820D160Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 820D160Ch case    0:*/		return 0x820D1610;
		  /* 820D1610h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1610h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1610h case    1:*/		return 0x820D1614;
		  /* 820D1614h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1614h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1614h case    2:*/		return 0x820D1618;
		  /* 820D1618h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1618h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1618h case    3:*/		return 0x820D161C;
		  /* 820D161Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D161Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D161Ch case    4:*/		return 0x820D1620;
		  /* 820D1620h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1620h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1620h case    5:*/		return 0x820D1624;
		  /* 820D1624h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1624h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1638;  }
		/* 820D1624h case    6:*/		return 0x820D1628;
		  /* 820D1628h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1628h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1628h case    7:*/		return 0x820D162C;
		  /* 820D162Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D162Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D162Ch case    8:*/		return 0x820D1630;
		  /* 820D1630h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1630h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1630h case    9:*/		return 0x820D1634;
		  /* 820D1634h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1634h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1614;  }
		/* 820D1634h case   10:*/		return 0x820D1638;
	}
	return 0x820D1638;
} // Block from 820D160Ch-820D1638h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1638);
		  /* 820D1638h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1638h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1638h case    0:*/		return 0x820D163C;
		  /* 820D163Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D163Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1648;  }
		/* 820D163Ch case    1:*/		return 0x820D1640;
		  /* 820D1640h */ case    2:  		/* li R11, 7 */
		/* 820D1640h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820D1640h case    2:*/		return 0x820D1644;
		  /* 820D1644h */ case    3:  		/* b 532 */
		/* 820D1644h case    3:*/		return 0x820D1858;
		/* 820D1644h case    3:*/		return 0x820D1648;
	}
	return 0x820D1648;
} // Block from 820D1638h-820D1648h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1648);
		  /* 820D1648h */ case    0:  		/* lwz R10, <#[R1 + 144]> */
		/* 820D1648h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 820D1648h case    0:*/		return 0x820D164C;
		  /* 820D164Ch */ case    1:  		/* addi R11, R1, 208 */
		/* 820D164Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D164Ch case    1:*/		return 0x820D1650;
		  /* 820D1650h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1650h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1650h case    2:*/		return 0x820D1654;
		  /* 820D1654h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1654h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1654h case    3:*/		return 0x820D1658;
		  /* 820D1658h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1658h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1658h case    4:*/		return 0x820D165C;
		  /* 820D165Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820D165Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D165Ch case    5:*/		return 0x820D1660;
		  /* 820D1660h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1660h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1674;  }
		/* 820D1660h case    6:*/		return 0x820D1664;
		  /* 820D1664h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1664h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1664h case    7:*/		return 0x820D1668;
		  /* 820D1668h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1668h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1668h case    8:*/		return 0x820D166C;
		  /* 820D166Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D166Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D166Ch case    9:*/		return 0x820D1670;
		  /* 820D1670h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1670h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1650;  }
		/* 820D1670h case   10:*/		return 0x820D1674;
	}
	return 0x820D1674;
} // Block from 820D1648h-820D1674h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1674);
		  /* 820D1674h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1674h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1674h case    0:*/		return 0x820D1678;
		  /* 820D1678h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1678h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1684;  }
		/* 820D1678h case    1:*/		return 0x820D167C;
		  /* 820D167Ch */ case    2:  		/* li R11, 8 */
		/* 820D167Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820D167Ch case    2:*/		return 0x820D1680;
		  /* 820D1680h */ case    3:  		/* b 472 */
		/* 820D1680h case    3:*/		return 0x820D1858;
		/* 820D1680h case    3:*/		return 0x820D1684;
	}
	return 0x820D1684;
} // Block from 820D1674h-820D1684h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1684);
		  /* 820D1684h */ case    0:  		/* lwz R10, <#[R1 + 148]> */
		/* 820D1684h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000094) );
		/* 820D1684h case    0:*/		return 0x820D1688;
		  /* 820D1688h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1688h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1688h case    1:*/		return 0x820D168C;
		  /* 820D168Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D168Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D168Ch case    2:*/		return 0x820D1690;
		  /* 820D1690h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1690h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1690h case    3:*/		return 0x820D1694;
		  /* 820D1694h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1694h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1694h case    4:*/		return 0x820D1698;
		  /* 820D1698h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1698h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1698h case    5:*/		return 0x820D169C;
		  /* 820D169Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D169Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820D16B0;  }
		/* 820D169Ch case    6:*/		return 0x820D16A0;
		  /* 820D16A0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D16A0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D16A0h case    7:*/		return 0x820D16A4;
		  /* 820D16A4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D16A4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D16A4h case    8:*/		return 0x820D16A8;
		  /* 820D16A8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D16A8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D16A8h case    9:*/		return 0x820D16AC;
		  /* 820D16ACh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D16ACh case   10:*/		if ( regs.CR[6].eq ) { return 0x820D168C;  }
		/* 820D16ACh case   10:*/		return 0x820D16B0;
	}
	return 0x820D16B0;
} // Block from 820D1684h-820D16B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D16B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D16B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D16B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D16B0);
		  /* 820D16B0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D16B0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D16B0h case    0:*/		return 0x820D16B4;
		  /* 820D16B4h */ case    1:  		/* bc 12, CR0_EQ, 548 */
		/* 820D16B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820D18D8;  }
		/* 820D16B4h case    1:*/		return 0x820D16B8;
		  /* 820D16B8h */ case    2:  		/* lwz R10, <#[R1 + 152]> */
		/* 820D16B8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 820D16B8h case    2:*/		return 0x820D16BC;
		  /* 820D16BCh */ case    3:  		/* addi R11, R1, 208 */
		/* 820D16BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D16BCh case    3:*/		return 0x820D16C0;
		  /* 820D16C0h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820D16C0h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D16C0h case    4:*/		return 0x820D16C4;
		  /* 820D16C4h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820D16C4h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D16C4h case    5:*/		return 0x820D16C8;
		  /* 820D16C8h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820D16C8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D16C8h case    6:*/		return 0x820D16CC;
		  /* 820D16CCh */ case    7:  		/* subf R9, R8, R9 */
		/* 820D16CCh case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D16CCh case    7:*/		return 0x820D16D0;
		  /* 820D16D0h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820D16D0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820D16E4;  }
		/* 820D16D0h case    8:*/		return 0x820D16D4;
		  /* 820D16D4h */ case    9:  		/* addi R11, R11, 1 */
		/* 820D16D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D16D4h case    9:*/		return 0x820D16D8;
		  /* 820D16D8h */ case   10:  		/* addi R10, R10, 1 */
		/* 820D16D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D16D8h case   10:*/		return 0x820D16DC;
		  /* 820D16DCh */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820D16DCh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D16DCh case   11:*/		return 0x820D16E0;
		  /* 820D16E0h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820D16E0h case   12:*/		if ( regs.CR[6].eq ) { return 0x820D16C0;  }
		/* 820D16E0h case   12:*/		return 0x820D16E4;
	}
	return 0x820D16E4;
} // Block from 820D16B0h-820D16E4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D16E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D16E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D16E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D16E4);
		  /* 820D16E4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D16E4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D16E4h case    0:*/		return 0x820D16E8;
		  /* 820D16E8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D16E8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D16F4;  }
		/* 820D16E8h case    1:*/		return 0x820D16EC;
		  /* 820D16ECh */ case    2:  		/* li R11, 10 */
		/* 820D16ECh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820D16ECh case    2:*/		return 0x820D16F0;
		  /* 820D16F0h */ case    3:  		/* b 360 */
		/* 820D16F0h case    3:*/		return 0x820D1858;
		/* 820D16F0h case    3:*/		return 0x820D16F4;
	}
	return 0x820D16F4;
} // Block from 820D16E4h-820D16F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D16F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D16F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D16F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D16F4);
		  /* 820D16F4h */ case    0:  		/* lwz R10, <#[R1 + 156]> */
		/* 820D16F4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000009C) );
		/* 820D16F4h case    0:*/		return 0x820D16F8;
		  /* 820D16F8h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D16F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D16F8h case    1:*/		return 0x820D16FC;
		  /* 820D16FCh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D16FCh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D16FCh case    2:*/		return 0x820D1700;
		  /* 820D1700h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1700h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1700h case    3:*/		return 0x820D1704;
		  /* 820D1704h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1704h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1704h case    4:*/		return 0x820D1708;
		  /* 820D1708h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1708h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1708h case    5:*/		return 0x820D170C;
		  /* 820D170Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D170Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1720;  }
		/* 820D170Ch case    6:*/		return 0x820D1710;
		  /* 820D1710h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1710h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1710h case    7:*/		return 0x820D1714;
		  /* 820D1714h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1714h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1714h case    8:*/		return 0x820D1718;
		  /* 820D1718h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1718h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1718h case    9:*/		return 0x820D171C;
		  /* 820D171Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D171Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820D16FC;  }
		/* 820D171Ch case   10:*/		return 0x820D1720;
	}
	return 0x820D1720;
} // Block from 820D16F4h-820D1720h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1720);
		  /* 820D1720h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1720h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1720h case    0:*/		return 0x820D1724;
		  /* 820D1724h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1724h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1730;  }
		/* 820D1724h case    1:*/		return 0x820D1728;
		  /* 820D1728h */ case    2:  		/* li R11, 11 */
		/* 820D1728h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820D1728h case    2:*/		return 0x820D172C;
		  /* 820D172Ch */ case    3:  		/* b 300 */
		/* 820D172Ch case    3:*/		return 0x820D1858;
		/* 820D172Ch case    3:*/		return 0x820D1730;
	}
	return 0x820D1730;
} // Block from 820D1720h-820D1730h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1730);
		  /* 820D1730h */ case    0:  		/* lwz R10, <#[R1 + 160]> */
		/* 820D1730h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A0) );
		/* 820D1730h case    0:*/		return 0x820D1734;
		  /* 820D1734h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1734h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1734h case    1:*/		return 0x820D1738;
		  /* 820D1738h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1738h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1738h case    2:*/		return 0x820D173C;
		  /* 820D173Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D173Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D173Ch case    3:*/		return 0x820D1740;
		  /* 820D1740h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1740h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1740h case    4:*/		return 0x820D1744;
		  /* 820D1744h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1744h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1744h case    5:*/		return 0x820D1748;
		  /* 820D1748h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1748h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D175C;  }
		/* 820D1748h case    6:*/		return 0x820D174C;
		  /* 820D174Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820D174Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D174Ch case    7:*/		return 0x820D1750;
		  /* 820D1750h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1750h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1750h case    8:*/		return 0x820D1754;
		  /* 820D1754h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1754h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1754h case    9:*/		return 0x820D1758;
		  /* 820D1758h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1758h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1738;  }
		/* 820D1758h case   10:*/		return 0x820D175C;
	}
	return 0x820D175C;
} // Block from 820D1730h-820D175Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D175Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D175C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D175C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D175C);
		  /* 820D175Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D175Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D175Ch case    0:*/		return 0x820D1760;
		  /* 820D1760h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1760h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D176C;  }
		/* 820D1760h case    1:*/		return 0x820D1764;
		  /* 820D1764h */ case    2:  		/* li R11, 12 */
		/* 820D1764h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820D1764h case    2:*/		return 0x820D1768;
		  /* 820D1768h */ case    3:  		/* b 240 */
		/* 820D1768h case    3:*/		return 0x820D1858;
		/* 820D1768h case    3:*/		return 0x820D176C;
	}
	return 0x820D176C;
} // Block from 820D175Ch-820D176Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D176Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D176C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D176C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D176C);
		  /* 820D176Ch */ case    0:  		/* lwz R10, <#[R1 + 164]> */
		/* 820D176Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A4) );
		/* 820D176Ch case    0:*/		return 0x820D1770;
		  /* 820D1770h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1770h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1770h case    1:*/		return 0x820D1774;
		  /* 820D1774h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1774h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1774h case    2:*/		return 0x820D1778;
		  /* 820D1778h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D1778h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1778h case    3:*/		return 0x820D177C;
		  /* 820D177Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D177Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D177Ch case    4:*/		return 0x820D1780;
		  /* 820D1780h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1780h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1780h case    5:*/		return 0x820D1784;
		  /* 820D1784h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1784h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1798;  }
		/* 820D1784h case    6:*/		return 0x820D1788;
		  /* 820D1788h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1788h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1788h case    7:*/		return 0x820D178C;
		  /* 820D178Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D178Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D178Ch case    8:*/		return 0x820D1790;
		  /* 820D1790h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1790h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1790h case    9:*/		return 0x820D1794;
		  /* 820D1794h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1794h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1774;  }
		/* 820D1794h case   10:*/		return 0x820D1798;
	}
	return 0x820D1798;
} // Block from 820D176Ch-820D1798h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1798);
		  /* 820D1798h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1798h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1798h case    0:*/		return 0x820D179C;
		  /* 820D179Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D179Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D17A8;  }
		/* 820D179Ch case    1:*/		return 0x820D17A0;
		  /* 820D17A0h */ case    2:  		/* li R11, 13 */
		/* 820D17A0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820D17A0h case    2:*/		return 0x820D17A4;
		  /* 820D17A4h */ case    3:  		/* b 180 */
		/* 820D17A4h case    3:*/		return 0x820D1858;
		/* 820D17A4h case    3:*/		return 0x820D17A8;
	}
	return 0x820D17A8;
} // Block from 820D1798h-820D17A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D17A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D17A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D17A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D17A8);
		  /* 820D17A8h */ case    0:  		/* lwz R10, <#[R1 + 180]> */
		/* 820D17A8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B4) );
		/* 820D17A8h case    0:*/		return 0x820D17AC;
		  /* 820D17ACh */ case    1:  		/* addi R11, R1, 208 */
		/* 820D17ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D17ACh case    1:*/		return 0x820D17B0;
		  /* 820D17B0h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D17B0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D17B0h case    2:*/		return 0x820D17B4;
		  /* 820D17B4h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D17B4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D17B4h case    3:*/		return 0x820D17B8;
		  /* 820D17B8h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D17B8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D17B8h case    4:*/		return 0x820D17BC;
		  /* 820D17BCh */ case    5:  		/* subf R9, R8, R9 */
		/* 820D17BCh case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D17BCh case    5:*/		return 0x820D17C0;
		  /* 820D17C0h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D17C0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D17D4;  }
		/* 820D17C0h case    6:*/		return 0x820D17C4;
		  /* 820D17C4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D17C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D17C4h case    7:*/		return 0x820D17C8;
		  /* 820D17C8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D17C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D17C8h case    8:*/		return 0x820D17CC;
		  /* 820D17CCh */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D17CCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D17CCh case    9:*/		return 0x820D17D0;
		  /* 820D17D0h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D17D0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D17B0;  }
		/* 820D17D0h case   10:*/		return 0x820D17D4;
	}
	return 0x820D17D4;
} // Block from 820D17A8h-820D17D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D17D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D17D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D17D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D17D4);
		  /* 820D17D4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D17D4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D17D4h case    0:*/		return 0x820D17D8;
		  /* 820D17D8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D17D8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D17E4;  }
		/* 820D17D8h case    1:*/		return 0x820D17DC;
		  /* 820D17DCh */ case    2:  		/* li R11, 9 */
		/* 820D17DCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 820D17DCh case    2:*/		return 0x820D17E0;
		  /* 820D17E0h */ case    3:  		/* b 120 */
		/* 820D17E0h case    3:*/		return 0x820D1858;
		/* 820D17E0h case    3:*/		return 0x820D17E4;
	}
	return 0x820D17E4;
} // Block from 820D17D4h-820D17E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D17E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D17E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D17E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D17E4);
		  /* 820D17E4h */ case    0:  		/* lwz R10, <#[R1 + 184]> */
		/* 820D17E4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 820D17E4h case    0:*/		return 0x820D17E8;
		  /* 820D17E8h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D17E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D17E8h case    1:*/		return 0x820D17EC;
		  /* 820D17ECh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D17ECh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D17ECh case    2:*/		return 0x820D17F0;
		  /* 820D17F0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D17F0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D17F0h case    3:*/		return 0x820D17F4;
		  /* 820D17F4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D17F4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D17F4h case    4:*/		return 0x820D17F8;
		  /* 820D17F8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D17F8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D17F8h case    5:*/		return 0x820D17FC;
		  /* 820D17FCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D17FCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820D1810;  }
		/* 820D17FCh case    6:*/		return 0x820D1800;
		  /* 820D1800h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D1800h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1800h case    7:*/		return 0x820D1804;
		  /* 820D1804h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1804h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1804h case    8:*/		return 0x820D1808;
		  /* 820D1808h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1808h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1808h case    9:*/		return 0x820D180C;
		  /* 820D180Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D180Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820D17EC;  }
		/* 820D180Ch case   10:*/		return 0x820D1810;
	}
	return 0x820D1810;
} // Block from 820D17E4h-820D1810h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D1810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1810);
		  /* 820D1810h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1810h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1810h case    0:*/		return 0x820D1814;
		  /* 820D1814h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1814h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1820;  }
		/* 820D1814h case    1:*/		return 0x820D1818;
		  /* 820D1818h */ case    2:  		/* li R11, 14 */
		/* 820D1818h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 820D1818h case    2:*/		return 0x820D181C;
		  /* 820D181Ch */ case    3:  		/* b 60 */
		/* 820D181Ch case    3:*/		return 0x820D1858;
		/* 820D181Ch case    3:*/		return 0x820D1820;
	}
	return 0x820D1820;
} // Block from 820D1810h-820D1820h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1820);
		  /* 820D1820h */ case    0:  		/* lwz R10, <#[R1 + 188]> */
		/* 820D1820h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000BC) );
		/* 820D1820h case    0:*/		return 0x820D1824;
		  /* 820D1824h */ case    1:  		/* addi R11, R1, 208 */
		/* 820D1824h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 820D1824h case    1:*/		return 0x820D1828;
		  /* 820D1828h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D1828h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1828h case    2:*/		return 0x820D182C;
		  /* 820D182Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D182Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D182Ch case    3:*/		return 0x820D1830;
		  /* 820D1830h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D1830h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1830h case    4:*/		return 0x820D1834;
		  /* 820D1834h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D1834h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D1834h case    5:*/		return 0x820D1838;
		  /* 820D1838h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1838h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D184C;  }
		/* 820D1838h case    6:*/		return 0x820D183C;
		  /* 820D183Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820D183Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D183Ch case    7:*/		return 0x820D1840;
		  /* 820D1840h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D1840h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1840h case    8:*/		return 0x820D1844;
		  /* 820D1844h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D1844h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1844h case    9:*/		return 0x820D1848;
		  /* 820D1848h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1848h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D1828;  }
		/* 820D1848h case   10:*/		return 0x820D184C;
	}
	return 0x820D184C;
} // Block from 820D1820h-820D184Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D184Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D184C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D184C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D184C);
		  /* 820D184Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D184Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D184Ch case    0:*/		return 0x820D1850;
		  /* 820D1850h */ case    1:  		/* bc 4, CR0_EQ, -3556 */
		/* 820D1850h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D0A6C;  }
		/* 820D1850h case    1:*/		return 0x820D1854;
		  /* 820D1854h */ case    2:  		/* li R11, 15 */
		/* 820D1854h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 820D1854h case    2:*/		return 0x820D1858;
	}
	return 0x820D1858;
} // Block from 820D184Ch-820D1858h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1858);
		  /* 820D1858h */ case    0:  		/* rlwinm R10, R30, 16, 12, 15 */
		/* 820D1858h case    0:*/		cpu::op::rlwinm<0,16,12,15>(regs,&regs.R10,regs.R30);
		/* 820D1858h case    0:*/		return 0x820D185C;
		  /* 820D185Ch */ case    1:  		/* stw R16, <#[R1 + 108]> */
		/* 820D185Ch case    1:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x0000006C) );
		/* 820D185Ch case    1:*/		return 0x820D1860;
		  /* 820D1860h */ case    2:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 820D1860h case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 820D1860h case    2:*/		return 0x820D1864;
		  /* 820D1864h */ case    3:  		/* or R26, R10, R11 */
		/* 820D1864h case    3:*/		cpu::op::or<0>(regs,&regs.R26,regs.R10,regs.R11);
		/* 820D1864h case    3:*/		return 0x820D1868;
	}
	return 0x820D1868;
} // Block from 820D1858h-820D1868h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1868);
		  /* 820D1868h */ case    0:  		/* stw R26, <#[R1 + 116]> */
		/* 820D1868h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000074) );
		/* 820D1868h case    0:*/		return 0x820D186C;
		  /* 820D186Ch */ case    1:  		/* mr R14, R16 */
		/* 820D186Ch case    1:*/		regs.R14 = regs.R16;
		/* 820D186Ch case    1:*/		return 0x820D1870;
	}
	return 0x820D1870;
} // Block from 820D1868h-820D1870h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D1870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1870);
		  /* 820D1870h */ case    0:  		/* lbz R11, <#[R29]> */
		/* 820D1870h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820D1870h case    0:*/		return 0x820D1874;
		  /* 820D1874h */ case    1:  		/* extsb. R15, R11 */
		/* 820D1874h case    1:*/		cpu::op::extsb<1>(regs,&regs.R15,regs.R11);
		/* 820D1874h case    1:*/		return 0x820D1878;
		  /* 820D1878h */ case    2:  		/* bc 4, CR0_EQ, -3008 */
		/* 820D1878h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820D0CB8;  }
		/* 820D1878h case    2:*/		return 0x820D187C;
		  /* 820D187Ch */ case    3:  		/* lwz R29, <#[R1 + 404]> */
		/* 820D187Ch case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000194) );
		/* 820D187Ch case    3:*/		return 0x820D1880;
		  /* 820D1880h */ case    4:  		/* li R27, 0 */
		/* 820D1880h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820D1880h case    4:*/		return 0x820D1884;
		  /* 820D1884h */ case    5:  		/* lwz R11, <#[R1 + 192]> */
		/* 820D1884h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 820D1884h case    5:*/		return 0x820D1888;
		  /* 820D1888h */ case    6:  		/* lwz R28, <#[R1 + 96]> */
		/* 820D1888h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 820D1888h case    6:*/		return 0x820D188C;
	}
	return 0x820D188C;
} // Block from 820D1870h-820D188Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D188Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D188C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D188C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D188C);
		  /* 820D188Ch */ case    0:  		/* lwz R10, <#[R1 + 108]> */
		/* 820D188Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 820D188Ch case    0:*/		return 0x820D1890;
		  /* 820D1890h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 820D1890h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820D1890h case    1:*/		return 0x820D1894;
		  /* 820D1894h */ case    2:  		/* bc 4, CR6_EQ, -3624 */
		/* 820D1894h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D0A6C;  }
		/* 820D1894h case    2:*/		return 0x820D1898;
		  /* 820D1898h */ case    3:  		/* lwz R10, <#[R1 + 112]> */
		/* 820D1898h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820D1898h case    3:*/		return 0x820D189C;
		  /* 820D189Ch */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 820D189Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820D189Ch case    4:*/		return 0x820D18A0;
		  /* 820D18A0h */ case    5:  		/* bc 4, CR6_EQ, -3636 */
		/* 820D18A0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D0A6C;  }
		/* 820D18A0h case    5:*/		return 0x820D18A4;
		  /* 820D18A4h */ case    6:  		/* lwz R10, <#[R1 + 196]> */
		/* 820D18A4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000C4) );
		/* 820D18A4h case    6:*/		return 0x820D18A8;
		  /* 820D18A8h */ case    7:  		/* mr R3, R28 */
		/* 820D18A8h case    7:*/		regs.R3 = regs.R28;
		/* 820D18A8h case    7:*/		return 0x820D18AC;
		  /* 820D18ACh */ case    8:  		/* lwz R9, <#[R1 + 200]> */
		/* 820D18ACh case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000C8) );
		/* 820D18ACh case    8:*/		return 0x820D18B0;
		  /* 820D18B0h */ case    9:  		/* lwz R8, <#[R1 + 104]> */
		/* 820D18B0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 820D18B0h case    9:*/		return 0x820D18B4;
		  /* 820D18B4h */ case   10:  		/* lwz R7, <#[R1 + 116]> */
		/* 820D18B4h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 820D18B4h case   10:*/		return 0x820D18B8;
		  /* 820D18B8h */ case   11:  		/* stw R11, <#[R29 + 116]> */
		/* 820D18B8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000074) );
		/* 820D18B8h case   11:*/		return 0x820D18BC;
		  /* 820D18BCh */ case   12:  		/* stw R10, <#[R29 + 112]> */
		/* 820D18BCh case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000070) );
		/* 820D18BCh case   12:*/		return 0x820D18C0;
		  /* 820D18C0h */ case   13:  		/* stw R9, <#[R29 + 120]> */
		/* 820D18C0h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000078) );
		/* 820D18C0h case   13:*/		return 0x820D18C4;
		  /* 820D18C4h */ case   14:  		/* stw R8, <#[R29 + 124]> */
		/* 820D18C4h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R29 + 0x0000007C) );
		/* 820D18C4h case   14:*/		return 0x820D18C8;
		  /* 820D18C8h */ case   15:  		/* stw R7, <#[R29 + 128]> */
		/* 820D18C8h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R29 + 0x00000080) );
		/* 820D18C8h case   15:*/		return 0x820D18CC;
		  /* 820D18CCh */ case   16:  		/* stw R27, <#[R29 + 68]> */
		/* 820D18CCh case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x00000044) );
		/* 820D18CCh case   16:*/		return 0x820D18D0;
	}
	return 0x820D18D0;
} // Block from 820D188Ch-820D18D0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820D18D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D18D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D18D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D18D0);
		  /* 820D18D0h */ case    0:  		/* addi R1, R1, 384 */
		/* 820D18D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x180);
		/* 820D18D0h case    0:*/		return 0x820D18D4;
		  /* 820D18D4h */ case    1:  		/* b -263780 */
		/* 820D18D4h case    1:*/		return 0x82091270;
		/* 820D18D4h case    1:*/		return 0x820D18D8;
	}
	return 0x820D18D8;
} // Block from 820D18D0h-820D18D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D18D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D18D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D18D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D18D8);
		  /* 820D18D8h */ case    0:  		/* lwz R4, <#[R1 + 168]> */
		/* 820D18D8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A8) );
		/* 820D18D8h case    0:*/		return 0x820D18DC;
		  /* 820D18DCh */ case    1:  		/* lwz R3, <#[R1 + 404]> */
		/* 820D18DCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000194) );
		/* 820D18DCh case    1:*/		return 0x820D18E0;
		  /* 820D18E0h */ case    2:  		/* bl -4088 */
		/* 820D18E0h case    2:*/		regs.LR = 0x820D18E4; return 0x820D08E8;
		/* 820D18E0h case    2:*/		return 0x820D18E4;
		  /* 820D18E4h */ case    3:  		/* b -3704 */
		/* 820D18E4h case    3:*/		return 0x820D0A6C;
		/* 820D18E4h case    3:*/		return 0x820D18E8;
	}
	return 0x820D18E8;
} // Block from 820D18D8h-820D18E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D18E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D18E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D18E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D18E8);
		  /* 820D18E8h */ case    0:  		/* mfspr R12, LR */
		/* 820D18E8h case    0:*/		regs.R12 = regs.LR;
		/* 820D18E8h case    0:*/		return 0x820D18EC;
		  /* 820D18ECh */ case    1:  		/* bl -263860 */
		/* 820D18ECh case    1:*/		regs.LR = 0x820D18F0; return 0x82091238;
		/* 820D18ECh case    1:*/		return 0x820D18F0;
		  /* 820D18F0h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820D18F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820D18F0h case    2:*/		return 0x820D18F4;
		  /* 820D18F4h */ case    3:  		/* lwz R11, <#[R4 + 56]> */
		/* 820D18F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000038) );
		/* 820D18F4h case    3:*/		return 0x820D18F8;
		  /* 820D18F8h */ case    4:  		/* mr R21, R3 */
		/* 820D18F8h case    4:*/		regs.R21 = regs.R3;
		/* 820D18F8h case    4:*/		return 0x820D18FC;
		  /* 820D18FCh */ case    5:  		/* mr R31, R4 */
		/* 820D18FCh case    5:*/		regs.R31 = regs.R4;
		/* 820D18FCh case    5:*/		return 0x820D1900;
		  /* 820D1900h */ case    6:  		/* li R22, 1 */
		/* 820D1900h case    6:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820D1900h case    6:*/		return 0x820D1904;
		  /* 820D1904h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820D1904h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1904h case    7:*/		return 0x820D1908;
		  /* 820D1908h */ case    8:  		/* bc 12, CR6_EQ, 1768 */
		/* 820D1908h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D1FF0;  }
		/* 820D1908h case    8:*/		return 0x820D190C;
		  /* 820D190Ch */ case    9:  		/* li R30, 0 */
		/* 820D190Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820D190Ch case    9:*/		return 0x820D1910;
		  /* 820D1910h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820D1910h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1910h case   10:*/		return 0x820D1914;
		  /* 820D1914h */ case   11:  		/* mr R27, R30 */
		/* 820D1914h case   11:*/		regs.R27 = regs.R30;
		/* 820D1914h case   11:*/		return 0x820D1918;
		  /* 820D1918h */ case   12:  		/* bc 12, CR6_EQ, 48 */
		/* 820D1918h case   12:*/		if ( regs.CR[6].eq ) { return 0x820D1948;  }
		/* 820D1918h case   12:*/		return 0x820D191C;
		  /* 820D191Ch */ case   13:  		/* addi R28, R4, 60 */
		/* 820D191Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R4,0x3C);
		/* 820D191Ch case   13:*/		return 0x820D1920;
		  /* 820D1920h */ case   14:  		/* mr R3, R21 */
		/* 820D1920h case   14:*/		regs.R3 = regs.R21;
		/* 820D1920h case   14:*/		return 0x820D1924;
		  /* 820D1924h */ case   15:  		/* lwz R4, <#[R28]> */
		/* 820D1924h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820D1924h case   15:*/		return 0x820D1928;
		  /* 820D1928h */ case   16:  		/* bl -64 */
		/* 820D1928h case   16:*/		regs.LR = 0x820D192C; return 0x820D18E8;
		/* 820D1928h case   16:*/		return 0x820D192C;
		  /* 820D192Ch */ case   17:  		/* cmpwi CR6, R3, -1 */
		/* 820D192Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820D192Ch case   17:*/		return 0x820D1930;
		  /* 820D1930h */ case   18:  		/* bc 12, CR6_EQ, 1552 */
		/* 820D1930h case   18:*/		if ( regs.CR[6].eq ) { return 0x820D1F40;  }
		/* 820D1930h case   18:*/		return 0x820D1934;
		  /* 820D1934h */ case   19:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1934h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1934h case   19:*/		return 0x820D1938;
		  /* 820D1938h */ case   20:  		/* addi R27, R27, 1 */
		/* 820D1938h case   20:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820D1938h case   20:*/		return 0x820D193C;
		  /* 820D193Ch */ case   21:  		/* addi R28, R28, 4 */
		/* 820D193Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820D193Ch case   21:*/		return 0x820D1940;
		  /* 820D1940h */ case   22:  		/* cmplw CR6, R27, R11 */
		/* 820D1940h case   22:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820D1940h case   22:*/		return 0x820D1944;
		  /* 820D1944h */ case   23:  		/* bc 12, CR6_LT, -36 */
		/* 820D1944h case   23:*/		if ( regs.CR[6].lt ) { return 0x820D1920;  }
		/* 820D1944h case   23:*/		return 0x820D1948;
	}
	return 0x820D1948;
} // Block from 820D18E8h-820D1948h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820D1948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1948);
		  /* 820D1948h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820D1948h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820D1948h case    0:*/		return 0x820D194C;
		  /* 820D194Ch */ case    1:  		/* addi R20, R31, 60 */
		/* 820D194Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R31,0x3C);
		/* 820D194Ch case    1:*/		return 0x820D1950;
		  /* 820D1950h */ case    2:  		/* lwz R11, <#[R11 + 48]> */
		/* 820D1950h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 820D1950h case    2:*/		return 0x820D1954;
		  /* 820D1954h */ case    3:  		/* cmpwi CR6, R11, 2 */
		/* 820D1954h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D1954h case    3:*/		return 0x820D1958;
		  /* 820D1958h */ case    4:  		/* bc 4, CR6_EQ, 1176 */
		/* 820D1958h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D1DF0;  }
		/* 820D1958h case    4:*/		return 0x820D195C;
		  /* 820D195Ch */ case    5:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D195Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D195Ch case    5:*/		return 0x820D1960;
		  /* 820D1960h */ case    6:  		/* mr R3, R30 */
		/* 820D1960h case    6:*/		regs.R3 = regs.R30;
		/* 820D1960h case    6:*/		return 0x820D1964;
		  /* 820D1964h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820D1964h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1964h case    7:*/		return 0x820D1968;
		  /* 820D1968h */ case    8:  		/* bc 4, CR6_GT, 164 */
		/* 820D1968h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820D1A0C;  }
		/* 820D1968h case    8:*/		return 0x820D196C;
		  /* 820D196Ch */ case    9:  		/* mr R5, R22 */
		/* 820D196Ch case    9:*/		regs.R5 = regs.R22;
		/* 820D196Ch case    9:*/		return 0x820D1970;
		  /* 820D1970h */ case   10:  		/* mr R10, R20 */
		/* 820D1970h case   10:*/		regs.R10 = regs.R20;
		/* 820D1970h case   10:*/		return 0x820D1974;
		  /* 820D1974h */ case   11:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1974h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1974h case   11:*/		return 0x820D1978;
		  /* 820D1978h */ case   12:  		/* mr R4, R5 */
		/* 820D1978h case   12:*/		regs.R4 = regs.R5;
		/* 820D1978h case   12:*/		return 0x820D197C;
		  /* 820D197Ch */ case   13:  		/* cmplw CR6, R5, R11 */
		/* 820D197Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820D197Ch case   13:*/		return 0x820D1980;
		  /* 820D1980h */ case   14:  		/* bc 4, CR6_LT, 64 */
		/* 820D1980h case   14:*/		if ( !regs.CR[6].lt ) { return 0x820D19C0;  }
		/* 820D1980h case   14:*/		return 0x820D1984;
		  /* 820D1984h */ case   15:  		/* addi R9, R10, 4 */
		/* 820D1984h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 820D1984h case   15:*/		return 0x820D1988;
		  /* 820D1988h */ case   16:  		/* lwz R11, <#[R9]> */
		/* 820D1988h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820D1988h case   16:*/		return 0x820D198C;
		  /* 820D198Ch */ case   17:  		/* lwz R8, <#[R10]> */
		/* 820D198Ch case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D198Ch case   17:*/		return 0x820D1990;
		  /* 820D1990h */ case   18:  		/* lwz R7, <#[R11 + 52]> */
		/* 820D1990h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000034) );
		/* 820D1990h case   18:*/		return 0x820D1994;
		  /* 820D1994h */ case   19:  		/* lwz R6, <#[R8 + 52]> */
		/* 820D1994h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000034) );
		/* 820D1994h case   19:*/		return 0x820D1998;
		  /* 820D1998h */ case   20:  		/* cmplw CR6, R6, R7 */
		/* 820D1998h case   20:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 820D1998h case   20:*/		return 0x820D199C;
		  /* 820D199Ch */ case   21:  		/* bc 12, CR6_EQ, 80 */
		/* 820D199Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x820D19EC;  }
		/* 820D199Ch case   21:*/		return 0x820D19A0;
		  /* 820D19A0h */ case   22:  		/* bc 4, CR6_GT, 12 */
		/* 820D19A0h case   22:*/		if ( !regs.CR[6].gt ) { return 0x820D19AC;  }
		/* 820D19A0h case   22:*/		return 0x820D19A4;
		  /* 820D19A4h */ case   23:  		/* stw R8, <#[R9]> */
		/* 820D19A4h case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820D19A4h case   23:*/		return 0x820D19A8;
		  /* 820D19A8h */ case   24:  		/* stw R11, <#[R10]> */
		/* 820D19A8h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820D19A8h case   24:*/		return 0x820D19AC;
	}
	return 0x820D19AC;
} // Block from 820D1948h-820D19ACh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820D19ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D19AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D19AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D19AC);
		  /* 820D19ACh */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D19ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D19ACh case    0:*/		return 0x820D19B0;
		  /* 820D19B0h */ case    1:  		/* addi R4, R4, 1 */
		/* 820D19B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820D19B0h case    1:*/		return 0x820D19B4;
		  /* 820D19B4h */ case    2:  		/* addi R9, R9, 4 */
		/* 820D19B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820D19B4h case    2:*/		return 0x820D19B8;
		  /* 820D19B8h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 820D19B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820D19B8h case    3:*/		return 0x820D19BC;
		  /* 820D19BCh */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 820D19BCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820D1988;  }
		/* 820D19BCh case    4:*/		return 0x820D19C0;
	}
	return 0x820D19C0;
} // Block from 820D19ACh-820D19C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D19C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D19C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D19C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D19C0);
		  /* 820D19C0h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 820D19C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820D19C0h case    0:*/		return 0x820D19C4;
		  /* 820D19C4h */ case    1:  		/* lwz R11, <#[R11 + 52]> */
		/* 820D19C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 820D19C4h case    1:*/		return 0x820D19C8;
		  /* 820D19C8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820D19C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D19C8h case    2:*/		return 0x820D19CC;
		  /* 820D19CCh */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820D19CCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820D19F8;  }
		/* 820D19CCh case    3:*/		return 0x820D19D0;
		  /* 820D19D0h */ case    4:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D19D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D19D0h case    4:*/		return 0x820D19D4;
		  /* 820D19D4h */ case    5:  		/* addi R3, R3, 1 */
		/* 820D19D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820D19D4h case    5:*/		return 0x820D19D8;
		  /* 820D19D8h */ case    6:  		/* addi R10, R10, 4 */
		/* 820D19D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820D19D8h case    6:*/		return 0x820D19DC;
		  /* 820D19DCh */ case    7:  		/* addi R5, R5, 1 */
		/* 820D19DCh case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820D19DCh case    7:*/		return 0x820D19E0;
		  /* 820D19E0h */ case    8:  		/* cmplw CR6, R3, R11 */
		/* 820D19E0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820D19E0h case    8:*/		return 0x820D19E4;
		  /* 820D19E4h */ case    9:  		/* bc 12, CR6_LT, -112 */
		/* 820D19E4h case    9:*/		if ( regs.CR[6].lt ) { return 0x820D1974;  }
		/* 820D19E4h case    9:*/		return 0x820D19E8;
		  /* 820D19E8h */ case   10:  		/* b 36 */
		/* 820D19E8h case   10:*/		return 0x820D1A0C;
		/* 820D19E8h case   10:*/		return 0x820D19EC;
	}
	return 0x820D19EC;
} // Block from 820D19C0h-820D19ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D19ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D19EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D19EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D19EC);
		  /* 820D19ECh */ case    0:  		/* lis R11, -32255 */
		/* 820D19ECh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D19ECh case    0:*/		return 0x820D19F0;
		  /* 820D19F0h */ case    1:  		/* addi R5, R11, 24092 */
		/* 820D19F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5E1C);
		/* 820D19F0h case    1:*/		return 0x820D19F4;
		  /* 820D19F4h */ case    2:  		/* b 1340 */
		/* 820D19F4h case    2:*/		return 0x820D1F30;
		/* 820D19F4h case    2:*/		return 0x820D19F8;
	}
	return 0x820D19F8;
} // Block from 820D19ECh-820D19F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D19F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D19F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D19F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D19F8);
		  /* 820D19F8h */ case    0:  		/* addi R11, R3, 15 */
		/* 820D19F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xF);
		/* 820D19F8h case    0:*/		return 0x820D19FC;
		  /* 820D19FCh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820D19FCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820D19FCh case    1:*/		return 0x820D1A00;
		  /* 820D1A00h */ case    2:  		/* lwzx R27, <#[R11 + R31]> */
		/* 820D1A00h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820D1A00h case    2:*/		return 0x820D1A04;
		  /* 820D1A04h */ case    3:  		/* cmplwi CR6, R27, 0 */
		/* 820D1A04h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820D1A04h case    3:*/		return 0x820D1A08;
		  /* 820D1A08h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 820D1A08h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D1A18;  }
		/* 820D1A08h case    4:*/		return 0x820D1A0C;
	}
	return 0x820D1A0C;
} // Block from 820D19F8h-820D1A0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D1A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1A0C);
		  /* 820D1A0Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D1A0Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1A0Ch case    0:*/		return 0x820D1A10;
		  /* 820D1A10h */ case    1:  		/* addi R5, R11, 24052 */
		/* 820D1A10h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5DF4);
		/* 820D1A10h case    1:*/		return 0x820D1A14;
		  /* 820D1A14h */ case    2:  		/* b 1308 */
		/* 820D1A14h case    2:*/		return 0x820D1F30;
		/* 820D1A14h case    2:*/		return 0x820D1A18;
	}
	return 0x820D1A18;
} // Block from 820D1A0Ch-820D1A18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1A18);
		  /* 820D1A18h */ case    0:  		/* lwz R25, <#[R27 + 4]> */
		/* 820D1A18h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R27 + 0x00000004) );
		/* 820D1A18h case    0:*/		return 0x820D1A1C;
		  /* 820D1A1Ch */ case    1:  		/* lwz R24, <#[R27 + 28]> */
		/* 820D1A1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R27 + 0x0000001C) );
		/* 820D1A1Ch case    1:*/		return 0x820D1A20;
		  /* 820D1A20h */ case    2:  		/* lwz R23, <#[R27 + 24]> */
		/* 820D1A20h case    2:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R27 + 0x00000018) );
		/* 820D1A20h case    2:*/		return 0x820D1A24;
		  /* 820D1A24h */ case    3:  		/* cmpwi CR6, R25, 2 */
		/* 820D1A24h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000002);
		/* 820D1A24h case    3:*/		return 0x820D1A28;
		  /* 820D1A28h */ case    4:  		/* mullw R11, R23, R24 */
		/* 820D1A28h case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R23,regs.R24);
		/* 820D1A28h case    4:*/		return 0x820D1A2C;
		  /* 820D1A2Ch */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820D1A2Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820D1A40;  }
		/* 820D1A2Ch case    5:*/		return 0x820D1A30;
		  /* 820D1A30h */ case    6:  		/* cmpwi CR6, R25, 1 */
		/* 820D1A30h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000001);
		/* 820D1A30h case    6:*/		return 0x820D1A34;
		  /* 820D1A34h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820D1A34h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D1A40;  }
		/* 820D1A34h case    7:*/		return 0x820D1A38;
		  /* 820D1A38h */ case    8:  		/* mr R26, R11 */
		/* 820D1A38h case    8:*/		regs.R26 = regs.R11;
		/* 820D1A38h case    8:*/		return 0x820D1A3C;
		  /* 820D1A3Ch */ case    9:  		/* b 28 */
		/* 820D1A3Ch case    9:*/		return 0x820D1A58;
		/* 820D1A3Ch case    9:*/		return 0x820D1A40;
	}
	return 0x820D1A40;
} // Block from 820D1A18h-820D1A40h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D1A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1A40);
		  /* 820D1A40h */ case    0:  		/* rlwinm. R10, R11, 0, 30, 31 */
		/* 820D1A40h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R11);
		/* 820D1A40h case    0:*/		return 0x820D1A44;
		  /* 820D1A44h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D1A44h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1A50;  }
		/* 820D1A44h case    1:*/		return 0x820D1A48;
		  /* 820D1A48h */ case    2:  		/* rlwinm R26, R11, 30, 2, 31 */
		/* 820D1A48h case    2:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R26,regs.R11);
		/* 820D1A48h case    2:*/		return 0x820D1A4C;
		  /* 820D1A4Ch */ case    3:  		/* b 12 */
		/* 820D1A4Ch case    3:*/		return 0x820D1A58;
		/* 820D1A4Ch case    3:*/		return 0x820D1A50;
	}
	return 0x820D1A50;
} // Block from 820D1A40h-820D1A50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1A50);
		  /* 820D1A50h */ case    0:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820D1A50h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820D1A50h case    0:*/		return 0x820D1A54;
		  /* 820D1A54h */ case    1:  		/* addi R26, R11, 1 */
		/* 820D1A54h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x1);
		/* 820D1A54h case    1:*/		return 0x820D1A58;
	}
	return 0x820D1A58;
} // Block from 820D1A50h-820D1A58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D1A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1A58);
		  /* 820D1A58h */ case    0:  		/* lwz R4, <#[R31 + 56]> */
		/* 820D1A58h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1A58h case    0:*/		return 0x820D1A5C;
		  /* 820D1A5Ch */ case    1:  		/* mr R28, R30 */
		/* 820D1A5Ch case    1:*/		regs.R28 = regs.R30;
		/* 820D1A5Ch case    1:*/		return 0x820D1A60;
		  /* 820D1A60h */ case    2:  		/* mr R6, R22 */
		/* 820D1A60h case    2:*/		regs.R6 = regs.R22;
		/* 820D1A60h case    2:*/		return 0x820D1A64;
		  /* 820D1A64h */ case    3:  		/* cmplwi CR6, R4, 1 */
		/* 820D1A64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 820D1A64h case    3:*/		return 0x820D1A68;
		  /* 820D1A68h */ case    4:  		/* bc 4, CR6_GT, 496 */
		/* 820D1A68h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820D1C58;  }
		/* 820D1A68h case    4:*/		return 0x820D1A6C;
		  /* 820D1A6Ch */ case    5:  		/* lwz R3, <#[R27]> */
		/* 820D1A6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000000) );
		/* 820D1A6Ch case    5:*/		return 0x820D1A70;
		  /* 820D1A70h */ case    6:  		/* addi R5, R31, 64 */
		/* 820D1A70h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x40);
		/* 820D1A70h case    6:*/		return 0x820D1A74;
		  /* 820D1A74h */ case    7:  		/* lwz R8, <#[R5]> */
		/* 820D1A74h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 820D1A74h case    7:*/		return 0x820D1A78;
		  /* 820D1A78h */ case    8:  		/* mr R10, R3 */
		/* 820D1A78h case    8:*/		regs.R10 = regs.R3;
		/* 820D1A78h case    8:*/		return 0x820D1A7C;
		  /* 820D1A7Ch */ case    9:  		/* lwz R11, <#[R8]> */
		/* 820D1A7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820D1A7Ch case    9:*/		return 0x820D1A80;
		  /* 820D1A80h */ case   10:  		/* lbz R9, <#[R11]> */
		/* 820D1A80h case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1A80h case   10:*/		return 0x820D1A84;
		  /* 820D1A84h */ case   11:  		/* lbz R7, <#[R10]> */
		/* 820D1A84h case   11:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1A84h case   11:*/		return 0x820D1A88;
		  /* 820D1A88h */ case   12:  		/* cmpwi CR0, R9, 0 */
		/* 820D1A88h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1A88h case   12:*/		return 0x820D1A8C;
		  /* 820D1A8Ch */ case   13:  		/* subf R9, R7, R9 */
		/* 820D1A8Ch case   13:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D1A8Ch case   13:*/		return 0x820D1A90;
		  /* 820D1A90h */ case   14:  		/* bc 12, CR0_EQ, 20 */
		/* 820D1A90h case   14:*/		if ( regs.CR[0].eq ) { return 0x820D1AA4;  }
		/* 820D1A90h case   14:*/		return 0x820D1A94;
		  /* 820D1A94h */ case   15:  		/* addi R11, R11, 1 */
		/* 820D1A94h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1A94h case   15:*/		return 0x820D1A98;
		  /* 820D1A98h */ case   16:  		/* addi R10, R10, 1 */
		/* 820D1A98h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1A98h case   16:*/		return 0x820D1A9C;
		  /* 820D1A9Ch */ case   17:  		/* cmpwi CR6, R9, 0 */
		/* 820D1A9Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D1A9Ch case   17:*/		return 0x820D1AA0;
		  /* 820D1AA0h */ case   18:  		/* bc 12, CR6_EQ, -32 */
		/* 820D1AA0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820D1A80;  }
		/* 820D1AA0h case   18:*/		return 0x820D1AA4;
	}
	return 0x820D1AA4;
} // Block from 820D1A58h-820D1AA4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D1AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1AA4);
		  /* 820D1AA4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D1AA4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D1AA4h case    0:*/		return 0x820D1AA8;
		  /* 820D1AA8h */ case    1:  		/* bc 4, CR0_EQ, 668 */
		/* 820D1AA8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D1D44;  }
		/* 820D1AA8h case    1:*/		return 0x820D1AAC;
		  /* 820D1AACh */ case    2:  		/* lwz R11, <#[R8 + 48]> */
		/* 820D1AACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000030) );
		/* 820D1AACh case    2:*/		return 0x820D1AB0;
		  /* 820D1AB0h */ case    3:  		/* lwz R10, <#[R27 + 48]> */
		/* 820D1AB0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000030) );
		/* 820D1AB0h case    3:*/		return 0x820D1AB4;
		  /* 820D1AB4h */ case    4:  		/* cmpw CR6, R11, R10 */
		/* 820D1AB4h case    4:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820D1AB4h case    4:*/		return 0x820D1AB8;
		  /* 820D1AB8h */ case    5:  		/* bc 4, CR6_EQ, 664 */
		/* 820D1AB8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1AB8h case    5:*/		return 0x820D1ABC;
		  /* 820D1ABCh */ case    6:  		/* lwz R11, <#[R8 + 56]> */
		/* 820D1ABCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000038) );
		/* 820D1ABCh case    6:*/		return 0x820D1AC0;
		  /* 820D1AC0h */ case    7:  		/* lwz R10, <#[R27 + 56]> */
		/* 820D1AC0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000038) );
		/* 820D1AC0h case    7:*/		return 0x820D1AC4;
		  /* 820D1AC4h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820D1AC4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D1AC4h case    8:*/		return 0x820D1AC8;
		  /* 820D1AC8h */ case    9:  		/* bc 4, CR6_EQ, 648 */
		/* 820D1AC8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1AC8h case    9:*/		return 0x820D1ACC;
		  /* 820D1ACCh */ case   10:  		/* lwz R11, <#[R8 + 16]> */
		/* 820D1ACCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 820D1ACCh case   10:*/		return 0x820D1AD0;
		  /* 820D1AD0h */ case   11:  		/* lwz R10, <#[R27 + 16]> */
		/* 820D1AD0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 820D1AD0h case   11:*/		return 0x820D1AD4;
		  /* 820D1AD4h */ case   12:  		/* cmpw CR6, R11, R10 */
		/* 820D1AD4h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820D1AD4h case   12:*/		return 0x820D1AD8;
		  /* 820D1AD8h */ case   13:  		/* bc 4, CR6_EQ, 632 */
		/* 820D1AD8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1AD8h case   13:*/		return 0x820D1ADC;
		  /* 820D1ADCh */ case   14:  		/* lwz R11, <#[R8 + 28]> */
		/* 820D1ADCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000001C) );
		/* 820D1ADCh case   14:*/		return 0x820D1AE0;
		  /* 820D1AE0h */ case   15:  		/* cmplw CR6, R11, R24 */
		/* 820D1AE0h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820D1AE0h case   15:*/		return 0x820D1AE4;
		  /* 820D1AE4h */ case   16:  		/* bc 4, CR6_EQ, 620 */
		/* 820D1AE4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1AE4h case   16:*/		return 0x820D1AE8;
		  /* 820D1AE8h */ case   17:  		/* lwz R11, <#[R8 + 24]> */
		/* 820D1AE8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000018) );
		/* 820D1AE8h case   17:*/		return 0x820D1AEC;
		  /* 820D1AECh */ case   18:  		/* cmplw CR6, R11, R23 */
		/* 820D1AECh case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820D1AECh case   18:*/		return 0x820D1AF0;
		  /* 820D1AF0h */ case   19:  		/* bc 4, CR6_EQ, 608 */
		/* 820D1AF0h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1AF0h case   19:*/		return 0x820D1AF4;
		  /* 820D1AF4h */ case   20:  		/* lwz R11, <#[R8 + 4]> */
		/* 820D1AF4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820D1AF4h case   20:*/		return 0x820D1AF8;
		  /* 820D1AF8h */ case   21:  		/* cmpw CR6, R11, R25 */
		/* 820D1AF8h case   21:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R25);
		/* 820D1AF8h case   21:*/		return 0x820D1AFC;
		  /* 820D1AFCh */ case   22:  		/* bc 4, CR6_EQ, 596 */
		/* 820D1AFCh case   22:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1AFCh case   22:*/		return 0x820D1B00;
		  /* 820D1B00h */ case   23:  		/* lwz R11, <#[R8 + 20]> */
		/* 820D1B00h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000014) );
		/* 820D1B00h case   23:*/		return 0x820D1B04;
		  /* 820D1B04h */ case   24:  		/* lwz R10, <#[R27 + 20]> */
		/* 820D1B04h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820D1B04h case   24:*/		return 0x820D1B08;
		  /* 820D1B08h */ case   25:  		/* cmpw CR6, R11, R10 */
		/* 820D1B08h case   25:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820D1B08h case   25:*/		return 0x820D1B0C;
		  /* 820D1B0Ch */ case   26:  		/* bc 4, CR6_EQ, 580 */
		/* 820D1B0Ch case   26:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1B0Ch case   26:*/		return 0x820D1B10;
		  /* 820D1B10h */ case   27:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 820D1B10h case   27:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 820D1B10h case   27:*/		return 0x820D1B14;
		  /* 820D1B14h */ case   28:  		/* lwz R11, <#[R8 + 40]> */
		/* 820D1B14h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000028) );
		/* 820D1B14h case   28:*/		return 0x820D1B18;
		  /* 820D1B18h */ case   29:  		/* bc 12, CR0_EQ, 24 */
		/* 820D1B18h case   29:*/		if ( regs.CR[0].eq ) { return 0x820D1B30;  }
		/* 820D1B18h case   29:*/		return 0x820D1B1C;
		  /* 820D1B1Ch */ case   30:  		/* cmplwi CR6, R11, 0 */
		/* 820D1B1Ch case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1B1Ch case   30:*/		return 0x820D1B20;
		  /* 820D1B20h */ case   31:  		/* bc 12, CR6_EQ, 40 */
		/* 820D1B20h case   31:*/		if ( regs.CR[6].eq ) { return 0x820D1B48;  }
		/* 820D1B20h case   31:*/		return 0x820D1B24;
		  /* 820D1B24h */ case   32:  		/* lis R11, -32255 */
		/* 820D1B24h case   32:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1B24h case   32:*/		return 0x820D1B28;
		  /* 820D1B28h */ case   33:  		/* addi R5, R11, 23968 */
		/* 820D1B28h case   33:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5DA0);
		/* 820D1B28h case   33:*/		return 0x820D1B2C;
		  /* 820D1B2Ch */ case   34:  		/* b 1028 */
		/* 820D1B2Ch case   34:*/		return 0x820D1F30;
		/* 820D1B2Ch case   34:*/		return 0x820D1B30;
	}
	return 0x820D1B30;
} // Block from 820D1AA4h-820D1B30h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820D1B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1B30);
		  /* 820D1B30h */ case    0:  		/* lwz R10, <#[R27 + 40]> */
		/* 820D1B30h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000028) );
		/* 820D1B30h case    0:*/		return 0x820D1B34;
		  /* 820D1B34h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820D1B34h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D1B34h case    1:*/		return 0x820D1B38;
		  /* 820D1B38h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820D1B38h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D1B48;  }
		/* 820D1B38h case    2:*/		return 0x820D1B3C;
		  /* 820D1B3Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820D1B3Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1B3Ch case    3:*/		return 0x820D1B40;
		  /* 820D1B40h */ case    4:  		/* bc 4, CR6_EQ, 528 */
		/* 820D1B40h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D1D50;  }
		/* 820D1B40h case    4:*/		return 0x820D1B44;
		  /* 820D1B44h */ case    5:  		/* mr R28, R22 */
		/* 820D1B44h case    5:*/		regs.R28 = regs.R22;
		/* 820D1B44h case    5:*/		return 0x820D1B48;
	}
	return 0x820D1B48;
} // Block from 820D1B30h-820D1B48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D1B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1B48);
		  /* 820D1B48h */ case    0:  		/* rlwinm. R10, R28, 0, 24, 31 */
		/* 820D1B48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R28);
		/* 820D1B48h case    0:*/		return 0x820D1B4C;
		  /* 820D1B4Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820D1B4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820D1B5C;  }
		/* 820D1B4Ch case    1:*/		return 0x820D1B50;
		  /* 820D1B50h */ case    2:  		/* lwz R11, <#[R8 + 44]> */
		/* 820D1B50h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000002C) );
		/* 820D1B50h case    2:*/		return 0x820D1B54;
		  /* 820D1B54h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820D1B54h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1B54h case    3:*/		return 0x820D1B58;
		  /* 820D1B58h */ case    4:  		/* bc 4, CR6_EQ, 516 */
		/* 820D1B58h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D1D5C;  }
		/* 820D1B58h case    4:*/		return 0x820D1B5C;
	}
	return 0x820D1B5C;
} // Block from 820D1B48h-820D1B5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D1B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1B5C);
		  /* 820D1B5Ch */ case    0:  		/* lwz R11, <#[R8 + 44]> */
		/* 820D1B5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000002C) );
		/* 820D1B5Ch case    0:*/		return 0x820D1B60;
		  /* 820D1B60h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D1B60h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1B60h case    1:*/		return 0x820D1B64;
		  /* 820D1B64h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820D1B64h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D1B74;  }
		/* 820D1B64h case    2:*/		return 0x820D1B68;
		  /* 820D1B68h */ case    3:  		/* lwz R9, <#[R27 + 44]> */
		/* 820D1B68h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x0000002C) );
		/* 820D1B68h case    3:*/		return 0x820D1B6C;
		  /* 820D1B6Ch */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 820D1B6Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D1B6Ch case    4:*/		return 0x820D1B70;
		  /* 820D1B70h */ case    5:  		/* bc 12, CR6_EQ, 952 */
		/* 820D1B70h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D1F28;  }
		/* 820D1B70h case    5:*/		return 0x820D1B74;
	}
	return 0x820D1B74;
} // Block from 820D1B5Ch-820D1B74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D1B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1B74);
		  /* 820D1B74h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820D1B74h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D1B74h case    0:*/		return 0x820D1B78;
		  /* 820D1B78h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820D1B78h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D1B90;  }
		/* 820D1B78h case    1:*/		return 0x820D1B7C;
		  /* 820D1B7Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820D1B7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1B7Ch case    2:*/		return 0x820D1B80;
		  /* 820D1B80h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820D1B80h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D1B90;  }
		/* 820D1B80h case    3:*/		return 0x820D1B84;
		  /* 820D1B84h */ case    4:  		/* lwz R11, <#[R27 + 44]> */
		/* 820D1B84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 820D1B84h case    4:*/		return 0x820D1B88;
		  /* 820D1B88h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820D1B88h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1B88h case    5:*/		return 0x820D1B8C;
		  /* 820D1B8Ch */ case    6:  		/* bc 4, CR6_EQ, 924 */
		/* 820D1B8Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x820D1F28;  }
		/* 820D1B8Ch case    6:*/		return 0x820D1B90;
	}
	return 0x820D1B90;
} // Block from 820D1B74h-820D1B90h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D1B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1B90);
		  /* 820D1B90h */ case    0:  		/* lwz R11, <#[R27 + 44]> */
		/* 820D1B90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 820D1B90h case    0:*/		return 0x820D1B94;
		  /* 820D1B94h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D1B94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1B94h case    1:*/		return 0x820D1B98;
		  /* 820D1B98h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820D1B98h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D1BA8;  }
		/* 820D1B98h case    2:*/		return 0x820D1B9C;
		  /* 820D1B9Ch */ case    3:  		/* lwz R11, <#[R8 + 52]> */
		/* 820D1B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000034) );
		/* 820D1B9Ch case    3:*/		return 0x820D1BA0;
		  /* 820D1BA0h */ case    4:  		/* cmplw CR6, R11, R6 */
		/* 820D1BA0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820D1BA0h case    4:*/		return 0x820D1BA4;
		  /* 820D1BA4h */ case    5:  		/* bc 4, CR6_EQ, 452 */
		/* 820D1BA4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D1D68;  }
		/* 820D1BA4h case    5:*/		return 0x820D1BA8;
	}
	return 0x820D1BA8;
} // Block from 820D1B90h-820D1BA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D1BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1BA8);
		  /* 820D1BA8h */ case    0:  		/* lwz R9, <#[R27 + 12]> */
		/* 820D1BA8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x0000000C) );
		/* 820D1BA8h case    0:*/		return 0x820D1BAC;
		  /* 820D1BACh */ case    1:  		/* cmpwi CR6, R9, -1 */
		/* 820D1BACh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 820D1BACh case    1:*/		return 0x820D1BB0;
		  /* 820D1BB0h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 820D1BB0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D1C38;  }
		/* 820D1BB0h case    2:*/		return 0x820D1BB4;
		  /* 820D1BB4h */ case    3:  		/* cmplw CR6, R9, R26 */
		/* 820D1BB4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R26);
		/* 820D1BB4h case    3:*/		return 0x820D1BB8;
		  /* 820D1BB8h */ case    4:  		/* bc 4, CR6_EQ, 128 */
		/* 820D1BB8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D1C38;  }
		/* 820D1BB8h case    4:*/		return 0x820D1BBC;
		  /* 820D1BBCh */ case    5:  		/* lwz R7, <#[R8 + 12]> */
		/* 820D1BBCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x0000000C) );
		/* 820D1BBCh case    5:*/		return 0x820D1BC0;
		  /* 820D1BC0h */ case    6:  		/* cmpwi CR6, R7, -1 */
		/* 820D1BC0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 820D1BC0h case    6:*/		return 0x820D1BC4;
		  /* 820D1BC4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820D1BC4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D1BD0;  }
		/* 820D1BC4h case    7:*/		return 0x820D1BC8;
		  /* 820D1BC8h */ case    8:  		/* cmplw CR6, R9, R7 */
		/* 820D1BC8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820D1BC8h case    8:*/		return 0x820D1BCC;
		  /* 820D1BCCh */ case    9:  		/* bc 4, CR6_GT, 56 */
		/* 820D1BCCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x820D1C04;  }
		/* 820D1BCCh case    9:*/		return 0x820D1BD0;
	}
	return 0x820D1BD0;
} // Block from 820D1BA8h-820D1BD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D1BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1BD0);
		  /* 820D1BD0h */ case    0:  		/* addi R11, R6, 1 */
		/* 820D1BD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x1);
		/* 820D1BD0h case    0:*/		return 0x820D1BD4;
		  /* 820D1BD4h */ case    1:  		/* cmplw CR6, R11, R4 */
		/* 820D1BD4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 820D1BD4h case    1:*/		return 0x820D1BD8;
		  /* 820D1BD8h */ case    2:  		/* bc 4, CR6_LT, 44 */
		/* 820D1BD8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820D1C04;  }
		/* 820D1BD8h case    2:*/		return 0x820D1BDC;
		  /* 820D1BDCh */ case    3:  		/* addi R10, R5, 4 */
		/* 820D1BDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x4);
		/* 820D1BDCh case    3:*/		return 0x820D1BE0;
		  /* 820D1BE0h */ case    4:  		/* lwz R29, <#[R10]> */
		/* 820D1BE0h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1BE0h case    4:*/		return 0x820D1BE4;
		  /* 820D1BE4h */ case    5:  		/* lwz R29, <#[R29 + 12]> */
		/* 820D1BE4h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000000C) );
		/* 820D1BE4h case    5:*/		return 0x820D1BE8;
		  /* 820D1BE8h */ case    6:  		/* cmpwi CR6, R29, -1 */
		/* 820D1BE8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 820D1BE8h case    6:*/		return 0x820D1BEC;
		  /* 820D1BECh */ case    7:  		/* bc 4, CR6_EQ, 392 */
		/* 820D1BECh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D1D74;  }
		/* 820D1BECh case    7:*/		return 0x820D1BF0;
		  /* 820D1BF0h */ case    8:  		/* lwz R29, <#[R31 + 56]> */
		/* 820D1BF0h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1BF0h case    8:*/		return 0x820D1BF4;
		  /* 820D1BF4h */ case    9:  		/* addi R11, R11, 1 */
		/* 820D1BF4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1BF4h case    9:*/		return 0x820D1BF8;
		  /* 820D1BF8h */ case   10:  		/* addi R10, R10, 4 */
		/* 820D1BF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820D1BF8h case   10:*/		return 0x820D1BFC;
		  /* 820D1BFCh */ case   11:  		/* cmplw CR6, R11, R29 */
		/* 820D1BFCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820D1BFCh case   11:*/		return 0x820D1C00;
		  /* 820D1C00h */ case   12:  		/* bc 12, CR6_LT, -32 */
		/* 820D1C00h case   12:*/		if ( regs.CR[6].lt ) { return 0x820D1BE0;  }
		/* 820D1C00h case   12:*/		return 0x820D1C04;
	}
	return 0x820D1C04;
} // Block from 820D1BD0h-820D1C04h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D1C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1C04);
		  /* 820D1C04h */ case    0:  		/* cmpwi CR6, R7, -1 */
		/* 820D1C04h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 820D1C04h case    0:*/		return 0x820D1C08;
		  /* 820D1C08h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 820D1C08h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D1C44;  }
		/* 820D1C08h case    1:*/		return 0x820D1C0C;
		  /* 820D1C0Ch */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 820D1C0Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820D1C0Ch case    2:*/		return 0x820D1C10;
		  /* 820D1C10h */ case    3:  		/* bc 12, CR6_LT, 356 */
		/* 820D1C10h case    3:*/		if ( regs.CR[6].lt ) { return 0x820D1D74;  }
		/* 820D1C10h case    3:*/		return 0x820D1C14;
		  /* 820D1C14h */ case    4:  		/* lwz R11, <#[R27 + 8]> */
		/* 820D1C14h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820D1C14h case    4:*/		return 0x820D1C18;
		  /* 820D1C18h */ case    5:  		/* mullw R10, R9, R6 */
		/* 820D1C18h case    5:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R6);
		/* 820D1C18h case    5:*/		return 0x820D1C1C;
		  /* 820D1C1Ch */ case    6:  		/* lwz R9, <#[R8 + 8]> */
		/* 820D1C1Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 820D1C1Ch case    6:*/		return 0x820D1C20;
		  /* 820D1C20h */ case    7:  		/* add R11, R10, R11 */
		/* 820D1C20h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D1C20h case    7:*/		return 0x820D1C24;
		  /* 820D1C24h */ case    8:  		/* cmplw CR6, R9, R11 */
		/* 820D1C24h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820D1C24h case    8:*/		return 0x820D1C28;
		  /* 820D1C28h */ case    9:  		/* bc 12, CR6_EQ, 28 */
		/* 820D1C28h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D1C44;  }
		/* 820D1C28h case    9:*/		return 0x820D1C2C;
		  /* 820D1C2Ch */ case   10:  		/* lis R11, -32255 */
		/* 820D1C2Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1C2Ch case   10:*/		return 0x820D1C30;
		  /* 820D1C30h */ case   11:  		/* addi R5, R11, 23916 */
		/* 820D1C30h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5D6C);
		/* 820D1C30h case   11:*/		return 0x820D1C34;
		  /* 820D1C34h */ case   12:  		/* b 764 */
		/* 820D1C34h case   12:*/		return 0x820D1F30;
		/* 820D1C34h case   12:*/		return 0x820D1C38;
	}
	return 0x820D1C38;
} // Block from 820D1C04h-820D1C38h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D1C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1C38);
		  /* 820D1C38h */ case    0:  		/* lwz R11, <#[R8 + 12]> */
		/* 820D1C38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 820D1C38h case    0:*/		return 0x820D1C3C;
		  /* 820D1C3Ch */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820D1C3Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820D1C3Ch case    1:*/		return 0x820D1C40;
		  /* 820D1C40h */ case    2:  		/* bc 4, CR6_EQ, 308 */
		/* 820D1C40h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D1D74;  }
		/* 820D1C40h case    2:*/		return 0x820D1C44;
	}
	return 0x820D1C44;
} // Block from 820D1C38h-820D1C44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1C44);
		  /* 820D1C44h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1C44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1C44h case    0:*/		return 0x820D1C48;
		  /* 820D1C48h */ case    1:  		/* addi R6, R6, 1 */
		/* 820D1C48h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820D1C48h case    1:*/		return 0x820D1C4C;
		  /* 820D1C4Ch */ case    2:  		/* addi R5, R5, 4 */
		/* 820D1C4Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820D1C4Ch case    2:*/		return 0x820D1C50;
		  /* 820D1C50h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 820D1C50h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820D1C50h case    3:*/		return 0x820D1C54;
		  /* 820D1C54h */ case    4:  		/* bc 12, CR6_LT, -480 */
		/* 820D1C54h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D1A74;  }
		/* 820D1C54h case    4:*/		return 0x820D1C58;
	}
	return 0x820D1C58;
} // Block from 820D1C44h-820D1C58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D1C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1C58);
		  /* 820D1C58h */ case    0:  		/* addi R11, R4, 14 */
		/* 820D1C58h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xE);
		/* 820D1C58h case    0:*/		return 0x820D1C5C;
		  /* 820D1C5Ch */ case    1:  		/* lwz R10, <#[R27 + 44]> */
		/* 820D1C5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x0000002C) );
		/* 820D1C5Ch case    1:*/		return 0x820D1C60;
		  /* 820D1C60h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820D1C60h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820D1C60h case    2:*/		return 0x820D1C64;
		  /* 820D1C64h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820D1C64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D1C64h case    3:*/		return 0x820D1C68;
		  /* 820D1C68h */ case    4:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820D1C68h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820D1C68h case    4:*/		return 0x820D1C6C;
		  /* 820D1C6Ch */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820D1C6Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820D1C80;  }
		/* 820D1C6Ch case    5:*/		return 0x820D1C70;
		  /* 820D1C70h */ case    6:  		/* lwz R10, <#[R11 + 52]> */
		/* 820D1C70h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 820D1C70h case    6:*/		return 0x820D1C74;
		  /* 820D1C74h */ case    7:  		/* addi R10, R10, 1 */
		/* 820D1C74h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D1C74h case    7:*/		return 0x820D1C78;
		  /* 820D1C78h */ case    8:  		/* cmplw CR6, R10, R4 */
		/* 820D1C78h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 820D1C78h case    8:*/		return 0x820D1C7C;
		  /* 820D1C7Ch */ case    9:  		/* bc 4, CR6_EQ, 236 */
		/* 820D1C7Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820D1D68;  }
		/* 820D1C7Ch case    9:*/		return 0x820D1C80;
	}
	return 0x820D1C80;
} // Block from 820D1C58h-820D1C80h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D1C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1C80);
		  /* 820D1C80h */ case    0:  		/* lwz R10, <#[R27 + 20]> */
		/* 820D1C80h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820D1C80h case    0:*/		return 0x820D1C84;
		  /* 820D1C84h */ case    1:  		/* stw R10, <#[R31 + 20]> */
		/* 820D1C84h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820D1C84h case    1:*/		return 0x820D1C88;
		  /* 820D1C88h */ case    2:  		/* lwz R10, <#[R27 + 16]> */
		/* 820D1C88h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 820D1C88h case    2:*/		return 0x820D1C8C;
		  /* 820D1C8Ch */ case    3:  		/* stw R10, <#[R31 + 16]> */
		/* 820D1C8Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820D1C8Ch case    3:*/		return 0x820D1C90;
		  /* 820D1C90h */ case    4:  		/* lwz R11, <#[R11 + 52]> */
		/* 820D1C90h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 820D1C90h case    4:*/		return 0x820D1C94;
		  /* 820D1C94h */ case    5:  		/* addi R11, R11, 1 */
		/* 820D1C94h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1C94h case    5:*/		return 0x820D1C98;
		  /* 820D1C98h */ case    6:  		/* stw R30, <#[R31 + 36]> */
		/* 820D1C98h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000024) );
		/* 820D1C98h case    6:*/		return 0x820D1C9C;
		  /* 820D1C9Ch */ case    7:  		/* stw R11, <#[R31 + 32]> */
		/* 820D1C9Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820D1C9Ch case    7:*/		return 0x820D1CA0;
		  /* 820D1CA0h */ case    8:  		/* lwz R11, <#[R27 + 24]> */
		/* 820D1CA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 820D1CA0h case    8:*/		return 0x820D1CA4;
		  /* 820D1CA4h */ case    9:  		/* stw R11, <#[R31 + 24]> */
		/* 820D1CA4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820D1CA4h case    9:*/		return 0x820D1CA8;
		  /* 820D1CA8h */ case   10:  		/* lwz R11, <#[R27 + 28]> */
		/* 820D1CA8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 820D1CA8h case   10:*/		return 0x820D1CAC;
		  /* 820D1CACh */ case   11:  		/* stw R11, <#[R31 + 28]> */
		/* 820D1CACh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820D1CACh case   11:*/		return 0x820D1CB0;
		  /* 820D1CB0h */ case   12:  		/* lwz R11, <#[R27 + 40]> */
		/* 820D1CB0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000028) );
		/* 820D1CB0h case   12:*/		return 0x820D1CB4;
		  /* 820D1CB4h */ case   13:  		/* stw R11, <#[R31 + 40]> */
		/* 820D1CB4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820D1CB4h case   13:*/		return 0x820D1CB8;
		  /* 820D1CB8h */ case   14:  		/* lwz R11, <#[R27 + 44]> */
		/* 820D1CB8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 820D1CB8h case   14:*/		return 0x820D1CBC;
		  /* 820D1CBCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820D1CBCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1CBCh case   15:*/		return 0x820D1CC0;
		  /* 820D1CC0h */ case   16:  		/* bc 12, CR6_EQ, 192 */
		/* 820D1CC0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820D1D80;  }
		/* 820D1CC0h case   16:*/		return 0x820D1CC4;
		  /* 820D1CC4h */ case   17:  		/* lwz R11, <#[R31 + 32]> */
		/* 820D1CC4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820D1CC4h case   17:*/		return 0x820D1CC8;
		  /* 820D1CC8h */ case   18:  		/* li R5, 4 */
		/* 820D1CC8h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D1CC8h case   18:*/		return 0x820D1CCC;
		  /* 820D1CCCh */ case   19:  		/* lwz R10, <#[R27 + 40]> */
		/* 820D1CCCh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000028) );
		/* 820D1CCCh case   19:*/		return 0x820D1CD0;
		  /* 820D1CD0h */ case   20:  		/* lwz R3, <#[R21 + 4]> */
		/* 820D1CD0h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000004) );
		/* 820D1CD0h case   20:*/		return 0x820D1CD4;
		  /* 820D1CD4h */ case   21:  		/* mullw R29, R11, R10 */
		/* 820D1CD4h case   21:*/		cpu::op::mullw<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 820D1CD4h case   21:*/		return 0x820D1CD8;
		  /* 820D1CD8h */ case   22:  		/* mr R4, R29 */
		/* 820D1CD8h case   22:*/		regs.R4 = regs.R29;
		/* 820D1CD8h case   22:*/		return 0x820D1CDC;
		  /* 820D1CDCh */ case   23:  		/* bl -35836 */
		/* 820D1CDCh case   23:*/		regs.LR = 0x820D1CE0; return 0x820C90E0;
		/* 820D1CDCh case   23:*/		return 0x820D1CE0;
		  /* 820D1CE0h */ case   24:  		/* mr R5, R29 */
		/* 820D1CE0h case   24:*/		regs.R5 = regs.R29;
		/* 820D1CE0h case   24:*/		return 0x820D1CE4;
		  /* 820D1CE4h */ case   25:  		/* li R4, 0 */
		/* 820D1CE4h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D1CE4h case   25:*/		return 0x820D1CE8;
		  /* 820D1CE8h */ case   26:  		/* stw R3, <#[R31 + 44]> */
		/* 820D1CE8h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D1CE8h case   26:*/		return 0x820D1CEC;
		  /* 820D1CECh */ case   27:  		/* bl -264620 */
		/* 820D1CECh case   27:*/		regs.LR = 0x820D1CF0; return 0x82091340;
		/* 820D1CECh case   27:*/		return 0x820D1CF0;
		  /* 820D1CF0h */ case   28:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1CF0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1CF0h case   28:*/		return 0x820D1CF4;
		  /* 820D1CF4h */ case   29:  		/* mr R28, R30 */
		/* 820D1CF4h case   29:*/		regs.R28 = regs.R30;
		/* 820D1CF4h case   29:*/		return 0x820D1CF8;
		  /* 820D1CF8h */ case   30:  		/* cmplwi CR6, R11, 0 */
		/* 820D1CF8h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1CF8h case   30:*/		return 0x820D1CFC;
		  /* 820D1CFCh */ case   31:  		/* bc 4, CR6_GT, 136 */
		/* 820D1CFCh case   31:*/		if ( !regs.CR[6].gt ) { return 0x820D1D84;  }
		/* 820D1CFCh case   31:*/		return 0x820D1D00;
		  /* 820D1D00h */ case   32:  		/* mr R26, R20 */
		/* 820D1D00h case   32:*/		regs.R26 = regs.R20;
		/* 820D1D00h case   32:*/		return 0x820D1D04;
		  /* 820D1D04h */ case   33:  		/* lwz R11, <#[R26]> */
		/* 820D1D04h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D1D04h case   33:*/		return 0x820D1D08;
		  /* 820D1D08h */ case   34:  		/* lwz R4, <#[R11 + 44]> */
		/* 820D1D08h case   34:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000002C) );
		/* 820D1D08h case   34:*/		return 0x820D1D0C;
		  /* 820D1D0Ch */ case   35:  		/* cmplwi CR6, R4, 0 */
		/* 820D1D0Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820D1D0Ch case   35:*/		return 0x820D1D10;
		  /* 820D1D10h */ case   36:  		/* bc 12, CR6_EQ, 28 */
		/* 820D1D10h case   36:*/		if ( regs.CR[6].eq ) { return 0x820D1D2C;  }
		/* 820D1D10h case   36:*/		return 0x820D1D14;
		  /* 820D1D14h */ case   37:  		/* lwz R10, <#[R27 + 40]> */
		/* 820D1D14h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000028) );
		/* 820D1D14h case   37:*/		return 0x820D1D18;
		  /* 820D1D18h */ case   38:  		/* lwz R11, <#[R31 + 44]> */
		/* 820D1D18h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D1D18h case   38:*/		return 0x820D1D1C;
		  /* 820D1D1Ch */ case   39:  		/* mullw R10, R10, R28 */
		/* 820D1D1Ch case   39:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 820D1D1Ch case   39:*/		return 0x820D1D20;
		  /* 820D1D20h */ case   40:  		/* lwz R5, <#[R31 + 40]> */
		/* 820D1D20h case   40:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000028) );
		/* 820D1D20h case   40:*/		return 0x820D1D24;
		  /* 820D1D24h */ case   41:  		/* add R3, R10, R11 */
		/* 820D1D24h case   41:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 820D1D24h case   41:*/		return 0x820D1D28;
		  /* 820D1D28h */ case   42:  		/* bl -263032 */
		/* 820D1D28h case   42:*/		regs.LR = 0x820D1D2C; return 0x820919B0;
		/* 820D1D28h case   42:*/		return 0x820D1D2C;
	}
	return 0x820D1D2C;
} // Block from 820D1C80h-820D1D2Ch (43 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D2C);
		  /* 820D1D2Ch */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1D2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1D2Ch case    0:*/		return 0x820D1D30;
		  /* 820D1D30h */ case    1:  		/* addi R28, R28, 1 */
		/* 820D1D30h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820D1D30h case    1:*/		return 0x820D1D34;
		  /* 820D1D34h */ case    2:  		/* addi R26, R26, 4 */
		/* 820D1D34h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 820D1D34h case    2:*/		return 0x820D1D38;
		  /* 820D1D38h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820D1D38h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820D1D38h case    3:*/		return 0x820D1D3C;
		  /* 820D1D3Ch */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 820D1D3Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820D1D04;  }
		/* 820D1D3Ch case    4:*/		return 0x820D1D40;
		  /* 820D1D40h */ case    5:  		/* b 68 */
		/* 820D1D40h case    5:*/		return 0x820D1D84;
		/* 820D1D40h case    5:*/		return 0x820D1D44;
	}
	return 0x820D1D44;
} // Block from 820D1D2Ch-820D1D44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D44);
		  /* 820D1D44h */ case    0:  		/* lis R11, -32255 */
		/* 820D1D44h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1D44h case    0:*/		return 0x820D1D48;
		  /* 820D1D48h */ case    1:  		/* addi R5, R11, 23872 */
		/* 820D1D48h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5D40);
		/* 820D1D48h case    1:*/		return 0x820D1D4C;
		  /* 820D1D4Ch */ case    2:  		/* b 484 */
		/* 820D1D4Ch case    2:*/		return 0x820D1F30;
		/* 820D1D4Ch case    2:*/		return 0x820D1D50;
	}
	return 0x820D1D50;
} // Block from 820D1D44h-820D1D50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D50);
		  /* 820D1D50h */ case    0:  		/* lis R11, -32255 */
		/* 820D1D50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1D50h case    0:*/		return 0x820D1D54;
		  /* 820D1D54h */ case    1:  		/* addi R5, R11, 23824 */
		/* 820D1D54h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5D10);
		/* 820D1D54h case    1:*/		return 0x820D1D58;
		  /* 820D1D58h */ case    2:  		/* b 472 */
		/* 820D1D58h case    2:*/		return 0x820D1F30;
		/* 820D1D58h case    2:*/		return 0x820D1D5C;
	}
	return 0x820D1D5C;
} // Block from 820D1D50h-820D1D5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D5C);
		  /* 820D1D5Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D1D5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1D5Ch case    0:*/		return 0x820D1D60;
		  /* 820D1D60h */ case    1:  		/* addi R5, R11, 23760 */
		/* 820D1D60h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5CD0);
		/* 820D1D60h case    1:*/		return 0x820D1D64;
		  /* 820D1D64h */ case    2:  		/* b 460 */
		/* 820D1D64h case    2:*/		return 0x820D1F30;
		/* 820D1D64h case    2:*/		return 0x820D1D68;
	}
	return 0x820D1D68;
} // Block from 820D1D5Ch-820D1D68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D68);
		  /* 820D1D68h */ case    0:  		/* lis R11, -32255 */
		/* 820D1D68h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1D68h case    0:*/		return 0x820D1D6C;
		  /* 820D1D6Ch */ case    1:  		/* addi R5, R11, 23664 */
		/* 820D1D6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5C70);
		/* 820D1D6Ch case    1:*/		return 0x820D1D70;
		  /* 820D1D70h */ case    2:  		/* b 448 */
		/* 820D1D70h case    2:*/		return 0x820D1F30;
		/* 820D1D70h case    2:*/		return 0x820D1D74;
	}
	return 0x820D1D74;
} // Block from 820D1D68h-820D1D74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D74);
		  /* 820D1D74h */ case    0:  		/* lis R11, -32255 */
		/* 820D1D74h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1D74h case    0:*/		return 0x820D1D78;
		  /* 820D1D78h */ case    1:  		/* addi R5, R11, 23600 */
		/* 820D1D78h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5C30);
		/* 820D1D78h case    1:*/		return 0x820D1D7C;
		  /* 820D1D7Ch */ case    2:  		/* b 436 */
		/* 820D1D7Ch case    2:*/		return 0x820D1F30;
		/* 820D1D7Ch case    2:*/		return 0x820D1D80;
	}
	return 0x820D1D80;
} // Block from 820D1D74h-820D1D80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D80);
		  /* 820D1D80h */ case    0:  		/* stw R30, <#[R31 + 44]> */
		/* 820D1D80h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D1D80h case    0:*/		return 0x820D1D84;
	}
	return 0x820D1D84;
} // Block from 820D1D80h-820D1D84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D1D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1D84);
		  /* 820D1D84h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 820D1D84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820D1D84h case    0:*/		return 0x820D1D88;
		  /* 820D1D88h */ case    1:  		/* stw R11, <#[R31 + 8]> */
		/* 820D1D88h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820D1D88h case    1:*/		return 0x820D1D8C;
		  /* 820D1D8Ch */ case    2:  		/* lwz R11, <#[R27 + 12]> */
		/* 820D1D8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 820D1D8Ch case    2:*/		return 0x820D1D90;
		  /* 820D1D90h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 820D1D90h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820D1D90h case    3:*/		return 0x820D1D94;
		  /* 820D1D94h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 820D1D94h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D1DA4;  }
		/* 820D1D94h case    4:*/		return 0x820D1D98;
		  /* 820D1D98h */ case    5:  		/* li R11, -1 */
		/* 820D1D98h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D1D98h case    5:*/		return 0x820D1D9C;
		  /* 820D1D9Ch */ case    6:  		/* stw R11, <#[R31 + 12]> */
		/* 820D1D9Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1D9Ch case    6:*/		return 0x820D1DA0;
		  /* 820D1DA0h */ case    7:  		/* b 592 */
		/* 820D1DA0h case    7:*/		return 0x820D1FF0;
		/* 820D1DA0h case    7:*/		return 0x820D1DA4;
	}
	return 0x820D1DA4;
} // Block from 820D1D84h-820D1DA4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D1DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1DA4);
		  /* 820D1DA4h */ case    0:  		/* lwz R10, <#[R31 + 56]> */
		/* 820D1DA4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1DA4h case    0:*/		return 0x820D1DA8;
		  /* 820D1DA8h */ case    1:  		/* mr R11, R30 */
		/* 820D1DA8h case    1:*/		regs.R11 = regs.R30;
		/* 820D1DA8h case    1:*/		return 0x820D1DAC;
		  /* 820D1DACh */ case    2:  		/* stw R30, <#[R31 + 12]> */
		/* 820D1DACh case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1DACh case    2:*/		return 0x820D1DB0;
		  /* 820D1DB0h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820D1DB0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D1DB0h case    3:*/		return 0x820D1DB4;
		  /* 820D1DB4h */ case    4:  		/* bc 4, CR6_GT, 572 */
		/* 820D1DB4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820D1FF0;  }
		/* 820D1DB4h case    4:*/		return 0x820D1DB8;
		  /* 820D1DB8h */ case    5:  		/* mr R10, R20 */
		/* 820D1DB8h case    5:*/		regs.R10 = regs.R20;
		/* 820D1DB8h case    5:*/		return 0x820D1DBC;
		  /* 820D1DBCh */ case    6:  		/* lwz R9, <#[R10]> */
		/* 820D1DBCh case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820D1DBCh case    6:*/		return 0x820D1DC0;
		  /* 820D1DC0h */ case    7:  		/* lwz R8, <#[R9 + 12]> */
		/* 820D1DC0h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 820D1DC0h case    7:*/		return 0x820D1DC4;
		  /* 820D1DC4h */ case    8:  		/* cmpwi CR6, R8, -1 */
		/* 820D1DC4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820D1DC4h case    8:*/		return 0x820D1DC8;
		  /* 820D1DC8h */ case    9:  		/* bc 12, CR6_EQ, 552 */
		/* 820D1DC8h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D1FF0;  }
		/* 820D1DC8h case    9:*/		return 0x820D1DCC;
		  /* 820D1DCCh */ case   10:  		/* lwz R9, <#[R31 + 12]> */
		/* 820D1DCCh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1DCCh case   10:*/		return 0x820D1DD0;
		  /* 820D1DD0h */ case   11:  		/* addi R11, R11, 1 */
		/* 820D1DD0h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D1DD0h case   11:*/		return 0x820D1DD4;
		  /* 820D1DD4h */ case   12:  		/* addi R10, R10, 4 */
		/* 820D1DD4h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820D1DD4h case   12:*/		return 0x820D1DD8;
		  /* 820D1DD8h */ case   13:  		/* add R9, R9, R8 */
		/* 820D1DD8h case   13:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820D1DD8h case   13:*/		return 0x820D1DDC;
		  /* 820D1DDCh */ case   14:  		/* stw R9, <#[R31 + 12]> */
		/* 820D1DDCh case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1DDCh case   14:*/		return 0x820D1DE0;
		  /* 820D1DE0h */ case   15:  		/* lwz R9, <#[R31 + 56]> */
		/* 820D1DE0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1DE0h case   15:*/		return 0x820D1DE4;
		  /* 820D1DE4h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 820D1DE4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D1DE4h case   16:*/		return 0x820D1DE8;
		  /* 820D1DE8h */ case   17:  		/* bc 12, CR6_LT, -44 */
		/* 820D1DE8h case   17:*/		if ( regs.CR[6].lt ) { return 0x820D1DBC;  }
		/* 820D1DE8h case   17:*/		return 0x820D1DEC;
		  /* 820D1DECh */ case   18:  		/* b 516 */
		/* 820D1DECh case   18:*/		return 0x820D1FF0;
		/* 820D1DECh case   18:*/		return 0x820D1DF0;
	}
	return 0x820D1DF0;
} // Block from 820D1DA4h-820D1DF0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D1DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1DF0);
		  /* 820D1DF0h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D1DF0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D1DF0h case    0:*/		return 0x820D1DF4;
		  /* 820D1DF4h */ case    1:  		/* bc 4, CR6_EQ, 508 */
		/* 820D1DF4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D1FF0;  }
		/* 820D1DF4h case    1:*/		return 0x820D1DF8;
		  /* 820D1DF8h */ case    2:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1DF8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1DF8h case    2:*/		return 0x820D1DFC;
		  /* 820D1DFCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820D1DFCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1DFCh case    3:*/		return 0x820D1E00;
		  /* 820D1E00h */ case    4:  		/* bc 4, CR6_GT, 108 */
		/* 820D1E00h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820D1E6C;  }
		/* 820D1E00h case    4:*/		return 0x820D1E04;
		  /* 820D1E04h */ case    5:  		/* mr R7, R22 */
		/* 820D1E04h case    5:*/		regs.R7 = regs.R22;
		/* 820D1E04h case    5:*/		return 0x820D1E08;
		  /* 820D1E08h */ case    6:  		/* mr R9, R20 */
		/* 820D1E08h case    6:*/		regs.R9 = regs.R20;
		/* 820D1E08h case    6:*/		return 0x820D1E0C;
		  /* 820D1E0Ch */ case    7:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1E0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1E0Ch case    7:*/		return 0x820D1E10;
		  /* 820D1E10h */ case    8:  		/* mr R6, R7 */
		/* 820D1E10h case    8:*/		regs.R6 = regs.R7;
		/* 820D1E10h case    8:*/		return 0x820D1E14;
		  /* 820D1E14h */ case    9:  		/* cmplw CR6, R7, R11 */
		/* 820D1E14h case    9:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820D1E14h case    9:*/		return 0x820D1E18;
		  /* 820D1E18h */ case   10:  		/* bc 4, CR6_LT, 60 */
		/* 820D1E18h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820D1E54;  }
		/* 820D1E18h case   10:*/		return 0x820D1E1C;
		  /* 820D1E1Ch */ case   11:  		/* addi R11, R9, 4 */
		/* 820D1E1Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x4);
		/* 820D1E1Ch case   11:*/		return 0x820D1E20;
		  /* 820D1E20h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 820D1E20h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1E20h case   12:*/		return 0x820D1E24;
		  /* 820D1E24h */ case   13:  		/* lwz R8, <#[R9]> */
		/* 820D1E24h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820D1E24h case   13:*/		return 0x820D1E28;
		  /* 820D1E28h */ case   14:  		/* lwz R5, <#[R10 + 8]> */
		/* 820D1E28h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000008) );
		/* 820D1E28h case   14:*/		return 0x820D1E2C;
		  /* 820D1E2Ch */ case   15:  		/* lwz R4, <#[R8 + 8]> */
		/* 820D1E2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + 0x00000008) );
		/* 820D1E2Ch case   15:*/		return 0x820D1E30;
		  /* 820D1E30h */ case   16:  		/* cmplw CR6, R4, R5 */
		/* 820D1E30h case   16:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 820D1E30h case   16:*/		return 0x820D1E34;
		  /* 820D1E34h */ case   17:  		/* bc 4, CR6_GT, 12 */
		/* 820D1E34h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820D1E40;  }
		/* 820D1E34h case   17:*/		return 0x820D1E38;
		  /* 820D1E38h */ case   18:  		/* stw R8, <#[R11]> */
		/* 820D1E38h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1E38h case   18:*/		return 0x820D1E3C;
		  /* 820D1E3Ch */ case   19:  		/* stw R10, <#[R9]> */
		/* 820D1E3Ch case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820D1E3Ch case   19:*/		return 0x820D1E40;
	}
	return 0x820D1E40;
} // Block from 820D1DF0h-820D1E40h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820D1E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1E40);
		  /* 820D1E40h */ case    0:  		/* lwz R10, <#[R31 + 56]> */
		/* 820D1E40h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1E40h case    0:*/		return 0x820D1E44;
		  /* 820D1E44h */ case    1:  		/* addi R6, R6, 1 */
		/* 820D1E44h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820D1E44h case    1:*/		return 0x820D1E48;
		  /* 820D1E48h */ case    2:  		/* addi R11, R11, 4 */
		/* 820D1E48h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820D1E48h case    2:*/		return 0x820D1E4C;
		  /* 820D1E4Ch */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 820D1E4Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820D1E4Ch case    3:*/		return 0x820D1E50;
		  /* 820D1E50h */ case    4:  		/* bc 12, CR6_LT, -48 */
		/* 820D1E50h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D1E20;  }
		/* 820D1E50h case    4:*/		return 0x820D1E54;
	}
	return 0x820D1E54;
} // Block from 820D1E40h-820D1E54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D1E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1E54);
		  /* 820D1E54h */ case    0:  		/* addi R7, R7, 1 */
		/* 820D1E54h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820D1E54h case    0:*/		return 0x820D1E58;
		  /* 820D1E58h */ case    1:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1E58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1E58h case    1:*/		return 0x820D1E5C;
		  /* 820D1E5Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 820D1E5Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820D1E5Ch case    2:*/		return 0x820D1E60;
		  /* 820D1E60h */ case    3:  		/* addi R10, R7, -1 */
		/* 820D1E60h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFFFFF);
		/* 820D1E60h case    3:*/		return 0x820D1E64;
		  /* 820D1E64h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820D1E64h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820D1E64h case    4:*/		return 0x820D1E68;
		  /* 820D1E68h */ case    5:  		/* bc 12, CR6_LT, -92 */
		/* 820D1E68h case    5:*/		if ( regs.CR[6].lt ) { return 0x820D1E0C;  }
		/* 820D1E68h case    5:*/		return 0x820D1E6C;
	}
	return 0x820D1E6C;
} // Block from 820D1E54h-820D1E6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D1E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1E6C);
		  /* 820D1E6Ch */ case    0:  		/* li R10, 5 */
		/* 820D1E6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820D1E6Ch case    0:*/		return 0x820D1E70;
		  /* 820D1E70h */ case    1:  		/* stw R30, <#[R31 + 20]> */
		/* 820D1E70h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 820D1E70h case    1:*/		return 0x820D1E74;
		  /* 820D1E74h */ case    2:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1E74h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1E74h case    2:*/		return 0x820D1E78;
		  /* 820D1E78h */ case    3:  		/* mr R6, R30 */
		/* 820D1E78h case    3:*/		regs.R6 = regs.R30;
		/* 820D1E78h case    3:*/		return 0x820D1E7C;
		  /* 820D1E7Ch */ case    4:  		/* stw R10, <#[R31 + 16]> */
		/* 820D1E7Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820D1E7Ch case    4:*/		return 0x820D1E80;
		  /* 820D1E80h */ case    5:  		/* lwz R7, <#[R20]> */
		/* 820D1E80h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R20 + 0x00000000) );
		/* 820D1E80h case    5:*/		return 0x820D1E84;
		  /* 820D1E84h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820D1E84h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1E84h case    6:*/		return 0x820D1E88;
		  /* 820D1E88h */ case    7:  		/* stw R22, <#[R31 + 32]> */
		/* 820D1E88h case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000020) );
		/* 820D1E88h case    7:*/		return 0x820D1E8C;
		  /* 820D1E8Ch */ case    8:  		/* stw R11, <#[R31 + 36]> */
		/* 820D1E8Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820D1E8Ch case    8:*/		return 0x820D1E90;
		  /* 820D1E90h */ case    9:  		/* lwz R11, <#[R7 + 8]> */
		/* 820D1E90h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 820D1E90h case    9:*/		return 0x820D1E94;
		  /* 820D1E94h */ case   10:  		/* stw R11, <#[R31 + 8]> */
		/* 820D1E94h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820D1E94h case   10:*/		return 0x820D1E98;
		  /* 820D1E98h */ case   11:  		/* stw R30, <#[R31 + 12]> */
		/* 820D1E98h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1E98h case   11:*/		return 0x820D1E9C;
		  /* 820D1E9Ch */ case   12:  		/* stw R22, <#[R31 + 24]> */
		/* 820D1E9Ch case   12:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000018) );
		/* 820D1E9Ch case   12:*/		return 0x820D1EA0;
		  /* 820D1EA0h */ case   13:  		/* stw R30, <#[R31 + 28]> */
		/* 820D1EA0h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000001C) );
		/* 820D1EA0h case   13:*/		return 0x820D1EA4;
		  /* 820D1EA4h */ case   14:  		/* stw R30, <#[R31 + 40]> */
		/* 820D1EA4h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000028) );
		/* 820D1EA4h case   14:*/		return 0x820D1EA8;
		  /* 820D1EA8h */ case   15:  		/* bc 12, CR6_EQ, 188 */
		/* 820D1EA8h case   15:*/		if ( regs.CR[6].eq ) { return 0x820D1F64;  }
		/* 820D1EA8h case   15:*/		return 0x820D1EAC;
		  /* 820D1EACh */ case   16:  		/* mr R11, R20 */
		/* 820D1EACh case   16:*/		regs.R11 = regs.R20;
		/* 820D1EACh case   16:*/		return 0x820D1EB0;
		  /* 820D1EB0h */ case   17:  		/* lwz R10, <#[R11]> */
		/* 820D1EB0h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1EB0h case   17:*/		return 0x820D1EB4;
		  /* 820D1EB4h */ case   18:  		/* lwz R10, <#[R10 + 12]> */
		/* 820D1EB4h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820D1EB4h case   18:*/		return 0x820D1EB8;
		  /* 820D1EB8h */ case   19:  		/* cmpwi CR6, R10, -1 */
		/* 820D1EB8h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820D1EB8h case   19:*/		return 0x820D1EBC;
		  /* 820D1EBCh */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 820D1EBCh case   20:*/		if ( regs.CR[6].eq ) { return 0x820D1ECC;  }
		/* 820D1EBCh case   20:*/		return 0x820D1EC0;
		  /* 820D1EC0h */ case   21:  		/* lwz R9, <#[R31 + 12]> */
		/* 820D1EC0h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1EC0h case   21:*/		return 0x820D1EC4;
		  /* 820D1EC4h */ case   22:  		/* add R10, R10, R9 */
		/* 820D1EC4h case   22:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820D1EC4h case   22:*/		return 0x820D1EC8;
		  /* 820D1EC8h */ case   23:  		/* stw R10, <#[R31 + 12]> */
		/* 820D1EC8h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1EC8h case   23:*/		return 0x820D1ECC;
	}
	return 0x820D1ECC;
} // Block from 820D1E6Ch-820D1ECCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 820D1ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1ECC);
		  /* 820D1ECCh */ case    0:  		/* lwz R9, <#[R11]> */
		/* 820D1ECCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1ECCh case    0:*/		return 0x820D1ED0;
		  /* 820D1ED0h */ case    1:  		/* lwz R10, <#[R31 + 28]> */
		/* 820D1ED0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820D1ED0h case    1:*/		return 0x820D1ED4;
		  /* 820D1ED4h */ case    2:  		/* lwz R8, <#[R31 + 40]> */
		/* 820D1ED4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000028) );
		/* 820D1ED4h case    2:*/		return 0x820D1ED8;
		  /* 820D1ED8h */ case    3:  		/* lwz R5, <#[R9 + 32]> */
		/* 820D1ED8h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000020) );
		/* 820D1ED8h case    3:*/		return 0x820D1EDC;
		  /* 820D1EDCh */ case    4:  		/* lwz R4, <#[R9 + 28]> */
		/* 820D1EDCh case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + 0x0000001C) );
		/* 820D1EDCh case    4:*/		return 0x820D1EE0;
		  /* 820D1EE0h */ case    5:  		/* lwz R9, <#[R9 + 24]> */
		/* 820D1EE0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 820D1EE0h case    5:*/		return 0x820D1EE4;
		  /* 820D1EE4h */ case    6:  		/* mullw R5, R5, R4 */
		/* 820D1EE4h case    6:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R5,regs.R4);
		/* 820D1EE4h case    6:*/		return 0x820D1EE8;
		  /* 820D1EE8h */ case    7:  		/* mullw R9, R5, R9 */
		/* 820D1EE8h case    7:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 820D1EE8h case    7:*/		return 0x820D1EEC;
		  /* 820D1EECh */ case    8:  		/* add R10, R9, R10 */
		/* 820D1EECh case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820D1EECh case    8:*/		return 0x820D1EF0;
		  /* 820D1EF0h */ case    9:  		/* stw R10, <#[R31 + 28]> */
		/* 820D1EF0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820D1EF0h case    9:*/		return 0x820D1EF4;
		  /* 820D1EF4h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 820D1EF4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1EF4h case   10:*/		return 0x820D1EF8;
		  /* 820D1EF8h */ case   11:  		/* lwz R9, <#[R10 + 32]> */
		/* 820D1EF8h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000020) );
		/* 820D1EF8h case   11:*/		return 0x820D1EFC;
		  /* 820D1EFCh */ case   12:  		/* lwz R10, <#[R10 + 40]> */
		/* 820D1EFCh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 820D1EFCh case   12:*/		return 0x820D1F00;
		  /* 820D1F00h */ case   13:  		/* mullw R10, R10, R9 */
		/* 820D1F00h case   13:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820D1F00h case   13:*/		return 0x820D1F04;
		  /* 820D1F04h */ case   14:  		/* add R10, R10, R8 */
		/* 820D1F04h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820D1F04h case   14:*/		return 0x820D1F08;
		  /* 820D1F08h */ case   15:  		/* stw R10, <#[R31 + 40]> */
		/* 820D1F08h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820D1F08h case   15:*/		return 0x820D1F0C;
		  /* 820D1F0Ch */ case   16:  		/* lwz R10, <#[R7 + 44]> */
		/* 820D1F0Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000002C) );
		/* 820D1F0Ch case   16:*/		return 0x820D1F10;
		  /* 820D1F10h */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 820D1F10h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D1F10h case   17:*/		return 0x820D1F14;
		  /* 820D1F14h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 820D1F14h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D1F14h case   18:*/		return 0x820D1F18;
		  /* 820D1F18h */ case   19:  		/* lwz R10, <#[R10 + 44]> */
		/* 820D1F18h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000002C) );
		/* 820D1F18h case   19:*/		return 0x820D1F1C;
		  /* 820D1F1Ch */ case   20:  		/* bc 12, CR6_EQ, 44 */
		/* 820D1F1Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x820D1F48;  }
		/* 820D1F1Ch case   20:*/		return 0x820D1F20;
		  /* 820D1F20h */ case   21:  		/* cmplwi CR6, R10, 0 */
		/* 820D1F20h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D1F20h case   21:*/		return 0x820D1F24;
		  /* 820D1F24h */ case   22:  		/* bc 4, CR6_EQ, 44 */
		/* 820D1F24h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820D1F50;  }
		/* 820D1F24h case   22:*/		return 0x820D1F28;
	}
	return 0x820D1F28;
} // Block from 820D1ECCh-820D1F28h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820D1F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1F28);
		  /* 820D1F28h */ case    0:  		/* lis R11, -32255 */
		/* 820D1F28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D1F28h case    0:*/		return 0x820D1F2C;
		  /* 820D1F2Ch */ case    1:  		/* addi R5, R11, 23528 */
		/* 820D1F2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5BE8);
		/* 820D1F2Ch case    1:*/		return 0x820D1F30;
	}
	return 0x820D1F30;
} // Block from 820D1F28h-820D1F30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D1F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1F30);
		  /* 820D1F30h */ case    0:  		/* lis R10, -32255 */
		/* 820D1F30h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D1F30h case    0:*/		return 0x820D1F34;
		  /* 820D1F34h */ case    1:  		/* mr R3, R21 */
		/* 820D1F34h case    1:*/		regs.R3 = regs.R21;
		/* 820D1F34h case    1:*/		return 0x820D1F38;
		  /* 820D1F38h */ case    2:  		/* addi R4, R10, 23508 */
		/* 820D1F38h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x5BD4);
		/* 820D1F38h case    2:*/		return 0x820D1F3C;
		  /* 820D1F3Ch */ case    3:  		/* bl -5716 */
		/* 820D1F3Ch case    3:*/		regs.LR = 0x820D1F40; return 0x820D08E8;
		/* 820D1F3Ch case    3:*/		return 0x820D1F40;
	}
	return 0x820D1F40;
} // Block from 820D1F30h-820D1F40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D1F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1F40);
		  /* 820D1F40h */ case    0:  		/* li R22, -1 */
		/* 820D1F40h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 820D1F40h case    0:*/		return 0x820D1F44;
		  /* 820D1F44h */ case    1:  		/* b 172 */
		/* 820D1F44h case    1:*/		return 0x820D1FF0;
		/* 820D1F44h case    1:*/		return 0x820D1F48;
	}
	return 0x820D1F48;
} // Block from 820D1F40h-820D1F48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D1F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1F48);
		  /* 820D1F48h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820D1F48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D1F48h case    0:*/		return 0x820D1F4C;
		  /* 820D1F4Ch */ case    1:  		/* bc 4, CR6_EQ, -36 */
		/* 820D1F4Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D1F28;  }
		/* 820D1F4Ch case    1:*/		return 0x820D1F50;
	}
	return 0x820D1F50;
} // Block from 820D1F48h-820D1F50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D1F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1F50);
		  /* 820D1F50h */ case    0:  		/* lwz R10, <#[R31 + 56]> */
		/* 820D1F50h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1F50h case    0:*/		return 0x820D1F54;
		  /* 820D1F54h */ case    1:  		/* addi R6, R6, 1 */
		/* 820D1F54h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820D1F54h case    1:*/		return 0x820D1F58;
		  /* 820D1F58h */ case    2:  		/* addi R11, R11, 4 */
		/* 820D1F58h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820D1F58h case    2:*/		return 0x820D1F5C;
		  /* 820D1F5Ch */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 820D1F5Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820D1F5Ch case    3:*/		return 0x820D1F60;
		  /* 820D1F60h */ case    4:  		/* bc 12, CR6_LT, -176 */
		/* 820D1F60h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D1EB0;  }
		/* 820D1F60h case    4:*/		return 0x820D1F64;
	}
	return 0x820D1F64;
} // Block from 820D1F50h-820D1F64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D1F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1F64);
		  /* 820D1F64h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820D1F64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1F64h case    0:*/		return 0x820D1F68;
		  /* 820D1F68h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D1F68h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1F68h case    1:*/		return 0x820D1F6C;
		  /* 820D1F6Ch */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 820D1F6Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D1F78;  }
		/* 820D1F6Ch case    2:*/		return 0x820D1F70;
		  /* 820D1F70h */ case    3:  		/* li R11, -1 */
		/* 820D1F70h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D1F70h case    3:*/		return 0x820D1F74;
		  /* 820D1F74h */ case    4:  		/* stw R11, <#[R31 + 12]> */
		/* 820D1F74h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D1F74h case    4:*/		return 0x820D1F78;
	}
	return 0x820D1F78;
} // Block from 820D1F64h-820D1F78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D1F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1F78);
		  /* 820D1F78h */ case    0:  		/* lwz R11, <#[R7 + 44]> */
		/* 820D1F78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000002C) );
		/* 820D1F78h case    0:*/		return 0x820D1F7C;
		  /* 820D1F7Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D1F7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1F7Ch case    1:*/		return 0x820D1F80;
		  /* 820D1F80h */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 820D1F80h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D1FF0;  }
		/* 820D1F80h case    2:*/		return 0x820D1F84;
		  /* 820D1F84h */ case    3:  		/* li R5, 4 */
		/* 820D1F84h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D1F84h case    3:*/		return 0x820D1F88;
		  /* 820D1F88h */ case    4:  		/* lwz R4, <#[R31 + 40]> */
		/* 820D1F88h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000028) );
		/* 820D1F88h case    4:*/		return 0x820D1F8C;
		  /* 820D1F8Ch */ case    5:  		/* lwz R3, <#[R21 + 4]> */
		/* 820D1F8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000004) );
		/* 820D1F8Ch case    5:*/		return 0x820D1F90;
		  /* 820D1F90h */ case    6:  		/* bl -36528 */
		/* 820D1F90h case    6:*/		regs.LR = 0x820D1F94; return 0x820C90E0;
		/* 820D1F90h case    6:*/		return 0x820D1F94;
		  /* 820D1F94h */ case    7:  		/* lwz R11, <#[R31 + 56]> */
		/* 820D1F94h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1F94h case    7:*/		return 0x820D1F98;
		  /* 820D1F98h */ case    8:  		/* mr R29, R30 */
		/* 820D1F98h case    8:*/		regs.R29 = regs.R30;
		/* 820D1F98h case    8:*/		return 0x820D1F9C;
		  /* 820D1F9Ch */ case    9:  		/* stw R3, <#[R31 + 44]> */
		/* 820D1F9Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D1F9Ch case    9:*/		return 0x820D1FA0;
		  /* 820D1FA0h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820D1FA0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D1FA0h case   10:*/		return 0x820D1FA4;
		  /* 820D1FA4h */ case   11:  		/* bc 4, CR6_GT, 76 */
		/* 820D1FA4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820D1FF0;  }
		/* 820D1FA4h case   11:*/		return 0x820D1FA8;
		  /* 820D1FA8h */ case   12:  		/* addi R28, R20, -4 */
		/* 820D1FA8h case   12:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R20,0xFFFFFFFC);
		/* 820D1FA8h case   12:*/		return 0x820D1FAC;
		  /* 820D1FACh */ case   13:  		/* lwz R10, <#[R28 + 4]> */
		/* 820D1FACh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 820D1FACh case   13:*/		return 0x820D1FB0;
		  /* 820D1FB0h */ case   14:  		/* lwz R11, <#[R31 + 44]> */
		/* 820D1FB0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D1FB0h case   14:*/		return 0x820D1FB4;
		  /* 820D1FB4h */ case   15:  		/* add R3, R11, R29 */
		/* 820D1FB4h case   15:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 820D1FB4h case   15:*/		return 0x820D1FB8;
		  /* 820D1FB8h */ case   16:  		/* lwz R11, <#[R10 + 40]> */
		/* 820D1FB8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000028) );
		/* 820D1FB8h case   16:*/		return 0x820D1FBC;
		  /* 820D1FBCh */ case   17:  		/* lwz R9, <#[R10 + 32]> */
		/* 820D1FBCh case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000020) );
		/* 820D1FBCh case   17:*/		return 0x820D1FC0;
		  /* 820D1FC0h */ case   18:  		/* lwz R4, <#[R10 + 44]> */
		/* 820D1FC0h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000002C) );
		/* 820D1FC0h case   18:*/		return 0x820D1FC4;
		  /* 820D1FC4h */ case   19:  		/* mullw R5, R11, R9 */
		/* 820D1FC4h case   19:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R11,regs.R9);
		/* 820D1FC4h case   19:*/		return 0x820D1FC8;
		  /* 820D1FC8h */ case   20:  		/* bl -263704 */
		/* 820D1FC8h case   20:*/		regs.LR = 0x820D1FCC; return 0x820919B0;
		/* 820D1FC8h case   20:*/		return 0x820D1FCC;
		  /* 820D1FCCh */ case   21:  		/* lwzu R11, <#[R28 + 4]> */
		/* 820D1FCCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 820D1FCCh case   21:*/		return 0x820D1FD0;
		  /* 820D1FD0h */ case   22:  		/* lwz R9, <#[R31 + 56]> */
		/* 820D1FD0h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000038) );
		/* 820D1FD0h case   22:*/		return 0x820D1FD4;
		  /* 820D1FD4h */ case   23:  		/* lwz R10, <#[R11 + 40]> */
		/* 820D1FD4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820D1FD4h case   23:*/		return 0x820D1FD8;
		  /* 820D1FD8h */ case   24:  		/* addi R30, R30, 1 */
		/* 820D1FD8h case   24:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820D1FD8h case   24:*/		return 0x820D1FDC;
		  /* 820D1FDCh */ case   25:  		/* cmplw CR6, R30, R9 */
		/* 820D1FDCh case   25:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 820D1FDCh case   25:*/		return 0x820D1FE0;
		  /* 820D1FE0h */ case   26:  		/* lwz R11, <#[R11 + 32]> */
		/* 820D1FE0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820D1FE0h case   26:*/		return 0x820D1FE4;
		  /* 820D1FE4h */ case   27:  		/* mullw R11, R10, R11 */
		/* 820D1FE4h case   27:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D1FE4h case   27:*/		return 0x820D1FE8;
		  /* 820D1FE8h */ case   28:  		/* add R29, R11, R29 */
		/* 820D1FE8h case   28:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820D1FE8h case   28:*/		return 0x820D1FEC;
		  /* 820D1FECh */ case   29:  		/* bc 12, CR6_LT, -64 */
		/* 820D1FECh case   29:*/		if ( regs.CR[6].lt ) { return 0x820D1FAC;  }
		/* 820D1FECh case   29:*/		return 0x820D1FF0;
	}
	return 0x820D1FF0;
} // Block from 820D1F78h-820D1FF0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820D1FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D1FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D1FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D1FF0);
		  /* 820D1FF0h */ case    0:  		/* mr R3, R22 */
		/* 820D1FF0h case    0:*/		regs.R3 = regs.R22;
		/* 820D1FF0h case    0:*/		return 0x820D1FF4;
		  /* 820D1FF4h */ case    1:  		/* addi R1, R1, 208 */
		/* 820D1FF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820D1FF4h case    1:*/		return 0x820D1FF8;
		  /* 820D1FF8h */ case    2:  		/* b -265584 */
		/* 820D1FF8h case    2:*/		return 0x82091288;
		/* 820D1FF8h case    2:*/		return 0x820D1FFC;
		  /* 820D1FFCh */ case    3:  		/* nop */
		/* 820D1FFCh case    3:*/		cpu::op::nop();
		/* 820D1FFCh case    3:*/		return 0x820D2000;
	}
	return 0x820D2000;
} // Block from 820D1FF0h-820D2000h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D2000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2000);
		  /* 820D2000h */ case    0:  		/* mfspr R12, LR */
		/* 820D2000h case    0:*/		regs.R12 = regs.LR;
		/* 820D2000h case    0:*/		return 0x820D2004;
		  /* 820D2004h */ case    1:  		/* bl -265680 */
		/* 820D2004h case    1:*/		regs.LR = 0x820D2008; return 0x82091234;
		/* 820D2004h case    1:*/		return 0x820D2008;
		  /* 820D2008h */ case    2:  		/* stwu R1, <#[R1 - 336]> */
		/* 820D2008h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEB0);
		/* 820D2008h case    2:*/		return 0x820D200C;
		  /* 820D200Ch */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 820D200Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820D200Ch case    3:*/		return 0x820D2010;
		  /* 820D2010h */ case    4:  		/* li R22, 1 */
		/* 820D2010h case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820D2010h case    4:*/		return 0x820D2014;
		  /* 820D2014h */ case    5:  		/* mr R31, R3 */
		/* 820D2014h case    5:*/		regs.R31 = regs.R3;
		/* 820D2014h case    5:*/		return 0x820D2018;
		  /* 820D2018h */ case    6:  		/* mr R20, R4 */
		/* 820D2018h case    6:*/		regs.R20 = regs.R4;
		/* 820D2018h case    6:*/		return 0x820D201C;
		  /* 820D201Ch */ case    7:  		/* mr R29, R5 */
		/* 820D201Ch case    7:*/		regs.R29 = regs.R5;
		/* 820D201Ch case    7:*/		return 0x820D2020;
		  /* 820D2020h */ case    8:  		/* mr R28, R6 */
		/* 820D2020h case    8:*/		regs.R28 = regs.R6;
		/* 820D2020h case    8:*/		return 0x820D2024;
		  /* 820D2024h */ case    9:  		/* addi R27, R3, 16 */
		/* 820D2024h case    9:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R3,0x10);
		/* 820D2024h case    9:*/		return 0x820D2028;
		  /* 820D2028h */ case   10:  		/* mr R23, R22 */
		/* 820D2028h case   10:*/		regs.R23 = regs.R22;
		/* 820D2028h case   10:*/		return 0x820D202C;
		  /* 820D202Ch */ case   11:  		/* cmpwi CR6, R11, 11 */
		/* 820D202Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D202Ch case   11:*/		return 0x820D2030;
		  /* 820D2030h */ case   12:  		/* bc 4, CR6_EQ, 2872 */
		/* 820D2030h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820D2B68;  }
		/* 820D2030h case   12:*/		return 0x820D2034;
		  /* 820D2034h */ case   13:  		/* lis R11, -32255 */
		/* 820D2034h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2034h case   13:*/		return 0x820D2038;
		  /* 820D2038h */ case   14:  		/* addi R21, R3, 24 */
		/* 820D2038h case   14:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R3,0x18);
		/* 820D2038h case   14:*/		return 0x820D203C;
		  /* 820D203Ch */ case   15:  		/* addi R10, R11, 24784 */
		/* 820D203Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x60D0);
		/* 820D203Ch case   15:*/		return 0x820D2040;
		  /* 820D2040h */ case   16:  		/* lwz R11, <#[R3 + 24]> */
		/* 820D2040h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820D2040h case   16:*/		return 0x820D2044;
		  /* 820D2044h */ case   17:  		/* lbz R9, <#[R11]> */
		/* 820D2044h case   17:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D2044h case   17:*/		return 0x820D2048;
		  /* 820D2048h */ case   18:  		/* lbz R8, <#[R10]> */
		/* 820D2048h case   18:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D2048h case   18:*/		return 0x820D204C;
		  /* 820D204Ch */ case   19:  		/* cmpwi CR0, R9, 0 */
		/* 820D204Ch case   19:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D204Ch case   19:*/		return 0x820D2050;
		  /* 820D2050h */ case   20:  		/* subf R9, R8, R9 */
		/* 820D2050h case   20:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D2050h case   20:*/		return 0x820D2054;
		  /* 820D2054h */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 820D2054h case   21:*/		if ( regs.CR[0].eq ) { return 0x820D2068;  }
		/* 820D2054h case   21:*/		return 0x820D2058;
		  /* 820D2058h */ case   22:  		/* addi R11, R11, 1 */
		/* 820D2058h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D2058h case   22:*/		return 0x820D205C;
		  /* 820D205Ch */ case   23:  		/* addi R10, R10, 1 */
		/* 820D205Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D205Ch case   23:*/		return 0x820D2060;
		  /* 820D2060h */ case   24:  		/* cmpwi CR6, R9, 0 */
		/* 820D2060h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D2060h case   24:*/		return 0x820D2064;
		  /* 820D2064h */ case   25:  		/* bc 12, CR6_EQ, -32 */
		/* 820D2064h case   25:*/		if ( regs.CR[6].eq ) { return 0x820D2044;  }
		/* 820D2064h case   25:*/		return 0x820D2068;
	}
	return 0x820D2068;
} // Block from 820D2000h-820D2068h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820D2068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2068);
		  /* 820D2068h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D2068h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D2068h case    0:*/		return 0x820D206C;
		  /* 820D206Ch */ case    1:  		/* bc 4, CR0_EQ, 2812 */
		/* 820D206Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D2B68;  }
		/* 820D206Ch case    1:*/		return 0x820D2070;
		  /* 820D2070h */ case    2:  		/* li R5, 48 */
		/* 820D2070h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x30);
		/* 820D2070h case    2:*/		return 0x820D2074;
		  /* 820D2074h */ case    3:  		/* li R4, 0 */
		/* 820D2074h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D2074h case    3:*/		return 0x820D2078;
		  /* 820D2078h */ case    4:  		/* mr R3, R20 */
		/* 820D2078h case    4:*/		regs.R3 = regs.R20;
		/* 820D2078h case    4:*/		return 0x820D207C;
		  /* 820D207Ch */ case    5:  		/* bl -265532 */
		/* 820D207Ch case    5:*/		regs.LR = 0x820D2080; return 0x82091340;
		/* 820D207Ch case    5:*/		return 0x820D2080;
		  /* 820D2080h */ case    6:  		/* li R19, 0 */
		/* 820D2080h case    6:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 820D2080h case    6:*/		return 0x820D2084;
		  /* 820D2084h */ case    7:  		/* stw R22, <#[R20 + 32]> */
		/* 820D2084h case    7:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R20 + 0x00000020) );
		/* 820D2084h case    7:*/		return 0x820D2088;
		  /* 820D2088h */ case    8:  		/* stb R19, <#[R29]> */
		/* 820D2088h case    8:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R29 + 0x00000000) );
		/* 820D2088h case    8:*/		return 0x820D208C;
		  /* 820D208Ch */ case    9:  		/* b 24 */
		/* 820D208Ch case    9:*/		return 0x820D20A4;
		/* 820D208Ch case    9:*/		return 0x820D2090;
		  /* 820D2090h */ case   10:  		/* lwz R11, <#[R27]> */
		/* 820D2090h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2090h case   10:*/		return 0x820D2094;
		  /* 820D2094h */ case   11:  		/* cmpwi CR6, R11, 17 */
		/* 820D2094h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2094h case   11:*/		return 0x820D2098;
		  /* 820D2098h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 820D2098h case   12:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2098h case   12:*/		return 0x820D209C;
		  /* 820D209Ch */ case   13:  		/* cmpwi CR6, R11, 16 */
		/* 820D209Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D209Ch case   13:*/		return 0x820D20A0;
		  /* 820D20A0h */ case   14:  		/* bc 4, CR6_EQ, 40 */
		/* 820D20A0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820D20C8;  }
		/* 820D20A0h case   14:*/		return 0x820D20A4;
	}
	return 0x820D20A4;
} // Block from 820D2068h-820D20A4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D20A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D20A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D20A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D20A4);
		  /* 820D20A4h */ case    0:  		/* mr R4, R27 */
		/* 820D20A4h case    0:*/		regs.R4 = regs.R27;
		/* 820D20A4h case    0:*/		return 0x820D20A8;
		  /* 820D20A8h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D20A8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D20A8h case    1:*/		return 0x820D20AC;
		  /* 820D20ACh */ case    2:  		/* bl -14900 */
		/* 820D20ACh case    2:*/		regs.LR = 0x820D20B0; return 0x820CE678;
		/* 820D20ACh case    2:*/		return 0x820D20B0;
		  /* 820D20B0h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D20B0h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D20B0h case    3:*/		return 0x820D20B4;
		  /* 820D20B4h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D20B4h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2090;  }
		/* 820D20B4h case    4:*/		return 0x820D20B8;
		  /* 820D20B8h */ case    5:  		/* b 2628 */
		/* 820D20B8h case    5:*/		return 0x820D2AFC;
		/* 820D20B8h case    5:*/		return 0x820D20BC;
	}
	return 0x820D20BC;
} // Block from 820D20A4h-820D20BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D20BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D20BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D20BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D20BC);
		  /* 820D20BCh */ case    0:  		/* lis R11, -32255 */
		/* 820D20BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D20BCh case    0:*/		return 0x820D20C0;
		  /* 820D20C0h */ case    1:  		/* addi R5, R11, 24756 */
		/* 820D20C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x60B4);
		/* 820D20C0h case    1:*/		return 0x820D20C4;
		  /* 820D20C4h */ case    2:  		/* b 2664 */
		/* 820D20C4h case    2:*/		return 0x820D2B2C;
		/* 820D20C4h case    2:*/		return 0x820D20C8;
	}
	return 0x820D20C8;
} // Block from 820D20BCh-820D20C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D20C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D20C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D20C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D20C8);
		  /* 820D20C8h */ case    0:  		/* mr R30, R19 */
		/* 820D20C8h case    0:*/		regs.R30 = regs.R19;
		/* 820D20C8h case    0:*/		return 0x820D20CC;
		  /* 820D20CCh */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 820D20CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D20CCh case    1:*/		return 0x820D20D0;
		  /* 820D20D0h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820D20D0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D20E0;  }
		/* 820D20D0h case    2:*/		return 0x820D20D4;
		  /* 820D20D4h */ case    3:  		/* lbz R10, <#[R21]> */
		/* 820D20D4h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 820D20D4h case    3:*/		return 0x820D20D8;
		  /* 820D20D8h */ case    4:  		/* cmplwi CR6, R10, 44 */
		/* 820D20D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002C);
		/* 820D20D8h case    4:*/		return 0x820D20DC;
		  /* 820D20DCh */ case    5:  		/* bc 12, CR6_EQ, 224 */
		/* 820D20DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820D21BC;  }
		/* 820D20DCh case    5:*/		return 0x820D20E0;
	}
	return 0x820D20E0;
} // Block from 820D20C8h-820D20E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D20E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D20E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D20E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D20E0);
		  /* 820D20E0h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 820D20E0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D20E0h case    0:*/		return 0x820D20E4;
		  /* 820D20E4h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820D20E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D20FC;  }
		/* 820D20E4h case    1:*/		return 0x820D20E8;
		  /* 820D20E8h */ case    2:  		/* lwz R11, <#[R21]> */
		/* 820D20E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D20E8h case    2:*/		return 0x820D20EC;
		  /* 820D20ECh */ case    3:  		/* mr R30, R19 */
		/* 820D20ECh case    3:*/		regs.R30 = regs.R19;
		/* 820D20ECh case    3:*/		return 0x820D20F0;
		  /* 820D20F0h */ case    4:  		/* stw R11, <#[R20]> */
		/* 820D20F0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820D20F0h case    4:*/		return 0x820D20F4;
		  /* 820D20F4h */ case    5:  		/* lwz R5, <#[R21]> */
		/* 820D20F4h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R21 + 0x00000000) );
		/* 820D20F4h case    5:*/		return 0x820D20F8;
		  /* 820D20F8h */ case    6:  		/* b 140 */
		/* 820D20F8h case    6:*/		return 0x820D2184;
		/* 820D20F8h case    6:*/		return 0x820D20FC;
	}
	return 0x820D20FC;
} // Block from 820D20E0h-820D20FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D20FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D20FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D20FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D20FC);
		  /* 820D20FCh */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D20FCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D20FCh case    0:*/		return 0x820D2100;
		  /* 820D2100h */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 820D2100h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D2164;  }
		/* 820D2100h case    1:*/		return 0x820D2104;
		  /* 820D2104h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D2104h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2104h case    2:*/		return 0x820D2108;
		  /* 820D2108h */ case    3:  		/* extsb R11, R11 */
		/* 820D2108h case    3:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820D2108h case    3:*/		return 0x820D210C;
		  /* 820D210Ch */ case    4:  		/* cmpwi CR6, R11, 91 */
		/* 820D210Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005B);
		/* 820D210Ch case    4:*/		return 0x820D2110;
		  /* 820D2110h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 820D2110h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D212C;  }
		/* 820D2110h case    5:*/		return 0x820D2114;
		  /* 820D2114h */ case    6:  		/* cmpwi CR6, R11, 93 */
		/* 820D2114h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005D);
		/* 820D2114h case    6:*/		return 0x820D2118;
		  /* 820D2118h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820D2118h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D212C;  }
		/* 820D2118h case    7:*/		return 0x820D211C;
		  /* 820D211Ch */ case    8:  		/* cmpwi CR6, R11, 46 */
		/* 820D211Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820D211Ch case    8:*/		return 0x820D2120;
		  /* 820D2120h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820D2120h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D212C;  }
		/* 820D2120h case    9:*/		return 0x820D2124;
		  /* 820D2124h */ case   10:  		/* cmpwi CR6, R11, 36 */
		/* 820D2124h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000024);
		/* 820D2124h case   10:*/		return 0x820D2128;
		  /* 820D2128h */ case   11:  		/* bc 4, CR6_EQ, 2612 */
		/* 820D2128h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820D2B5C;  }
		/* 820D2128h case   11:*/		return 0x820D212C;
	}
	return 0x820D212C;
} // Block from 820D20FCh-820D212Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D212Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D212C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D212C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D212C);
		  /* 820D212Ch */ case    0:  		/* mr R5, R21 */
		/* 820D212Ch case    0:*/		regs.R5 = regs.R21;
		/* 820D212Ch case    0:*/		return 0x820D2130;
		  /* 820D2130h */ case    1:  		/* mr R4, R28 */
		/* 820D2130h case    1:*/		regs.R4 = regs.R28;
		/* 820D2130h case    1:*/		return 0x820D2134;
		  /* 820D2134h */ case    2:  		/* mr R3, R29 */
		/* 820D2134h case    2:*/		regs.R3 = regs.R29;
		/* 820D2134h case    2:*/		return 0x820D2138;
		  /* 820D2138h */ case    3:  		/* bl -176328 */
		/* 820D2138h case    3:*/		regs.LR = 0x820D213C; return 0x820A7070;
		/* 820D2138h case    3:*/		return 0x820D213C;
		  /* 820D213Ch */ case    4:  		/* lbz R11, <#[R21]> */
		/* 820D213Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D213Ch case    4:*/		return 0x820D2140;
		  /* 820D2140h */ case    5:  		/* extsb R11, R11 */
		/* 820D2140h case    5:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820D2140h case    5:*/		return 0x820D2144;
		  /* 820D2144h */ case    6:  		/* cmpwi CR6, R11, 91 */
		/* 820D2144h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005B);
		/* 820D2144h case    6:*/		return 0x820D2148;
		  /* 820D2148h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 820D2148h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D2154;  }
		/* 820D2148h case    7:*/		return 0x820D214C;
		  /* 820D214Ch */ case    8:  		/* cmpwi CR6, R30, 0 */
		/* 820D214Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820D214Ch case    8:*/		return 0x820D2150;
		  /* 820D2150h */ case    9:  		/* bc 4, CR6_EQ, 2560 */
		/* 820D2150h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820D2B50;  }
		/* 820D2150h case    9:*/		return 0x820D2154;
	}
	return 0x820D2154;
} // Block from 820D212Ch-820D2154h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D2154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2154);
		  /* 820D2154h */ case    0:  		/* addi R11, R11, -93 */
		/* 820D2154h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFA3);
		/* 820D2154h case    0:*/		return 0x820D2158;
		  /* 820D2158h */ case    1:  		/* cntlzw R11, R11 */
		/* 820D2158h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820D2158h case    1:*/		return 0x820D215C;
		  /* 820D215Ch */ case    2:  		/* rlwinm R30, R11, 27, 31, 31 */
		/* 820D215Ch case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R30,regs.R11);
		/* 820D215Ch case    2:*/		return 0x820D2160;
		  /* 820D2160h */ case    3:  		/* b 48 */
		/* 820D2160h case    3:*/		return 0x820D2190;
		/* 820D2160h case    3:*/		return 0x820D2164;
	}
	return 0x820D2164;
} // Block from 820D2154h-820D2164h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D2164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2164);
		  /* 820D2164h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820D2164h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D2164h case    0:*/		return 0x820D2168;
		  /* 820D2168h */ case    1:  		/* bc 4, CR6_EQ, 2548 */
		/* 820D2168h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D2B5C;  }
		/* 820D2168h case    1:*/		return 0x820D216C;
		  /* 820D216Ch */ case    2:  		/* li R5, 10 */
		/* 820D216Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 820D216Ch case    2:*/		return 0x820D2170;
		  /* 820D2170h */ case    3:  		/* lwz R3, <#[R21]> */
		/* 820D2170h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2170h case    3:*/		return 0x820D2174;
		  /* 820D2174h */ case    4:  		/* addi R4, R1, 160 */
		/* 820D2174h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 820D2174h case    4:*/		return 0x820D2178;
		  /* 820D2178h */ case    5:  		/* mr R30, R19 */
		/* 820D2178h case    5:*/		regs.R30 = regs.R19;
		/* 820D2178h case    5:*/		return 0x820D217C;
		  /* 820D217Ch */ case    6:  		/* bl 1663436 */
		/* 820D217Ch case    6:*/		regs.LR = 0x820D2180; return 0x82268348;
		/* 820D217Ch case    6:*/		return 0x820D2180;
		  /* 820D2180h */ case    7:  		/* mr R5, R3 */
		/* 820D2180h case    7:*/		regs.R5 = regs.R3;
		/* 820D2180h case    7:*/		return 0x820D2184;
	}
	return 0x820D2184;
} // Block from 820D2164h-820D2184h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D2184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2184);
		  /* 820D2184h */ case    0:  		/* mr R4, R28 */
		/* 820D2184h case    0:*/		regs.R4 = regs.R28;
		/* 820D2184h case    0:*/		return 0x820D2188;
		  /* 820D2188h */ case    1:  		/* mr R3, R29 */
		/* 820D2188h case    1:*/		regs.R3 = regs.R29;
		/* 820D2188h case    1:*/		return 0x820D218C;
		  /* 820D218Ch */ case    2:  		/* bl -176412 */
		/* 820D218Ch case    2:*/		regs.LR = 0x820D2190; return 0x820A7070;
		/* 820D218Ch case    2:*/		return 0x820D2190;
	}
	return 0x820D2190;
} // Block from 820D2184h-820D2190h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D2190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2190);
		  /* 820D2190h */ case    0:  		/* mr R4, R27 */
		/* 820D2190h case    0:*/		regs.R4 = regs.R27;
		/* 820D2190h case    0:*/		return 0x820D2194;
		  /* 820D2194h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2194h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2194h case    1:*/		return 0x820D2198;
		  /* 820D2198h */ case    2:  		/* bl -15136 */
		/* 820D2198h case    2:*/		regs.LR = 0x820D219C; return 0x820CE678;
		/* 820D2198h case    2:*/		return 0x820D219C;
		  /* 820D219Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D219Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D219Ch case    3:*/		return 0x820D21A0;
		  /* 820D21A0h */ case    4:  		/* bc 12, CR0_LT, 2396 */
		/* 820D21A0h case    4:*/		if ( regs.CR[0].lt ) { return 0x820D2AFC;  }
		/* 820D21A0h case    4:*/		return 0x820D21A4;
		  /* 820D21A4h */ case    5:  		/* lwz R11, <#[R27]> */
		/* 820D21A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D21A4h case    5:*/		return 0x820D21A8;
		  /* 820D21A8h */ case    6:  		/* cmpwi CR6, R11, 17 */
		/* 820D21A8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D21A8h case    6:*/		return 0x820D21AC;
		  /* 820D21ACh */ case    7:  		/* bc 12, CR6_EQ, -240 */
		/* 820D21ACh case    7:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D21ACh case    7:*/		return 0x820D21B0;
		  /* 820D21B0h */ case    8:  		/* cmpwi CR6, R11, 16 */
		/* 820D21B0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D21B0h case    8:*/		return 0x820D21B4;
		  /* 820D21B4h */ case    9:  		/* bc 12, CR6_EQ, -36 */
		/* 820D21B4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D2190;  }
		/* 820D21B4h case    9:*/		return 0x820D21B8;
		  /* 820D21B8h */ case   10:  		/* b -236 */
		/* 820D21B8h case   10:*/		return 0x820D20CC;
		/* 820D21B8h case   10:*/		return 0x820D21BC;
	}
	return 0x820D21BC;
} // Block from 820D2190h-820D21BCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D21BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D21BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D21BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D21BC);
		  /* 820D21BCh */ case    0:  		/* lwz R11, <#[R20]> */
		/* 820D21BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 820D21BCh case    0:*/		return 0x820D21C0;
		  /* 820D21C0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D21C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D21C0h case    1:*/		return 0x820D21C4;
		  /* 820D21C4h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820D21C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D21EC;  }
		/* 820D21C4h case    2:*/		return 0x820D21C8;
		  /* 820D21C8h */ case    3:  		/* mr R11, R29 */
		/* 820D21C8h case    3:*/		regs.R11 = regs.R29;
		/* 820D21C8h case    3:*/		return 0x820D21CC;
		  /* 820D21CCh */ case    4:  		/* lbz R10, <#[R11]> */
		/* 820D21CCh case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D21CCh case    4:*/		return 0x820D21D0;
		  /* 820D21D0h */ case    5:  		/* addi R11, R11, 1 */
		/* 820D21D0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D21D0h case    5:*/		return 0x820D21D4;
		  /* 820D21D4h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820D21D4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D21D4h case    6:*/		return 0x820D21D8;
		  /* 820D21D8h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 820D21D8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D21CC;  }
		/* 820D21D8h case    7:*/		return 0x820D21DC;
		  /* 820D21DCh */ case    8:  		/* subf R11, R29, R11 */
		/* 820D21DCh case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 820D21DCh case    8:*/		return 0x820D21E0;
		  /* 820D21E0h */ case    9:  		/* addi R11, R11, -1 */
		/* 820D21E0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D21E0h case    9:*/		return 0x820D21E4;
		  /* 820D21E4h */ case   10:  		/* rlwinm. R11, R11, 0, 0, 31 */
		/* 820D21E4h case   10:*/		cpu::op::rlwinm<1,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820D21E4h case   10:*/		return 0x820D21E8;
		  /* 820D21E8h */ case   11:  		/* bc 4, CR0_EQ, 36 */
		/* 820D21E8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820D220C;  }
		/* 820D21E8h case   11:*/		return 0x820D21EC;
	}
	return 0x820D21EC;
} // Block from 820D21BCh-820D21ECh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D21ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D21EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D21EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D21EC);
		  /* 820D21ECh */ case    0:  		/* lis R11, -32255 */
		/* 820D21ECh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D21ECh case    0:*/		return 0x820D21F0;
		  /* 820D21F0h */ case    1:  		/* addi R5, R11, 24736 */
		/* 820D21F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x60A0);
		/* 820D21F0h case    1:*/		return 0x820D21F4;
		  /* 820D21F4h */ case    2:  		/* b 2360 */
		/* 820D21F4h case    2:*/		return 0x820D2B2C;
		/* 820D21F4h case    2:*/		return 0x820D21F8;
		  /* 820D21F8h */ case    3:  		/* lwz R11, <#[R27]> */
		/* 820D21F8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D21F8h case    3:*/		return 0x820D21FC;
		  /* 820D21FCh */ case    4:  		/* cmpwi CR6, R11, 17 */
		/* 820D21FCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D21FCh case    4:*/		return 0x820D2200;
		  /* 820D2200h */ case    5:  		/* bc 12, CR6_EQ, -324 */
		/* 820D2200h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2200h case    5:*/		return 0x820D2204;
		  /* 820D2204h */ case    6:  		/* cmpwi CR6, R11, 16 */
		/* 820D2204h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2204h case    6:*/		return 0x820D2208;
		  /* 820D2208h */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 820D2208h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D2224;  }
		/* 820D2208h case    7:*/		return 0x820D220C;
	}
	return 0x820D220C;
} // Block from 820D21ECh-820D220Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D220Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D220C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D220C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D220C);
		  /* 820D220Ch */ case    0:  		/* mr R4, R27 */
		/* 820D220Ch case    0:*/		regs.R4 = regs.R27;
		/* 820D220Ch case    0:*/		return 0x820D2210;
		  /* 820D2210h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2210h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2210h case    1:*/		return 0x820D2214;
		  /* 820D2214h */ case    2:  		/* bl -15260 */
		/* 820D2214h case    2:*/		regs.LR = 0x820D2218; return 0x820CE678;
		/* 820D2214h case    2:*/		return 0x820D2218;
		  /* 820D2218h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2218h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2218h case    3:*/		return 0x820D221C;
		  /* 820D221Ch */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D221Ch case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D21F8;  }
		/* 820D221Ch case    4:*/		return 0x820D2220;
		  /* 820D2220h */ case    5:  		/* b 2268 */
		/* 820D2220h case    5:*/		return 0x820D2AFC;
		/* 820D2220h case    5:*/		return 0x820D2224;
	}
	return 0x820D2224;
} // Block from 820D220Ch-820D2224h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2224);
		  /* 820D2224h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 820D2224h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D2224h case    0:*/		return 0x820D2228;
		  /* 820D2228h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820D2228h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D2238;  }
		/* 820D2228h case    1:*/		return 0x820D222C;
		  /* 820D222Ch */ case    2:  		/* lis R11, -32255 */
		/* 820D222Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D222Ch case    2:*/		return 0x820D2230;
		  /* 820D2230h */ case    3:  		/* addi R5, R11, 24716 */
		/* 820D2230h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x608C);
		/* 820D2230h case    3:*/		return 0x820D2234;
		  /* 820D2234h */ case    4:  		/* b 2296 */
		/* 820D2234h case    4:*/		return 0x820D2B2C;
		/* 820D2234h case    4:*/		return 0x820D2238;
	}
	return 0x820D2238;
} // Block from 820D2224h-820D2238h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D2238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2238);
		  /* 820D2238h */ case    0:  		/* lis R11, -32217 */
		/* 820D2238h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820D2238h case    0:*/		return 0x820D223C;
		  /* 820D223Ch */ case    1:  		/* lwz R4, <#[R21]> */
		/* 820D223Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x00000000) );
		/* 820D223Ch case    1:*/		return 0x820D2240;
		  /* 820D2240h */ case    2:  		/* addi R5, R1, 112 */
		/* 820D2240h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820D2240h case    2:*/		return 0x820D2244;
		  /* 820D2244h */ case    3:  		/* addi R3, R11, 11632 */
		/* 820D2244h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2D70);
		/* 820D2244h case    3:*/		return 0x820D2248;
		  /* 820D2248h */ case    4:  		/* bl -13968 */
		/* 820D2248h case    4:*/		regs.LR = 0x820D224C; return 0x820CEBB8;
		/* 820D2248h case    4:*/		return 0x820D224C;
		  /* 820D224Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820D224Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D224Ch case    5:*/		return 0x820D2250;
		  /* 820D2250h */ case    6:  		/* bc 4, CR0_LT, 16 */
		/* 820D2250h case    6:*/		if ( !regs.CR[0].lt ) { return 0x820D2260;  }
		/* 820D2250h case    6:*/		return 0x820D2254;
		  /* 820D2254h */ case    7:  		/* lis R11, -32255 */
		/* 820D2254h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2254h case    7:*/		return 0x820D2258;
		  /* 820D2258h */ case    8:  		/* addi R5, R11, 24692 */
		/* 820D2258h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6074);
		/* 820D2258h case    8:*/		return 0x820D225C;
		  /* 820D225Ch */ case    9:  		/* b 2256 */
		/* 820D225Ch case    9:*/		return 0x820D2B2C;
		/* 820D225Ch case    9:*/		return 0x820D2260;
	}
	return 0x820D2260;
} // Block from 820D2238h-820D2260h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D2260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2260);
		  /* 820D2260h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D2260h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2260h case    0:*/		return 0x820D2264;
		  /* 820D2264h */ case    1:  		/* stw R11, <#[R20 + 20]> */
		/* 820D2264h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000014) );
		/* 820D2264h case    1:*/		return 0x820D2268;
		  /* 820D2268h */ case    2:  		/* b 24 */
		/* 820D2268h case    2:*/		return 0x820D2280;
		/* 820D2268h case    2:*/		return 0x820D226C;
		  /* 820D226Ch */ case    3:  		/* lwz R11, <#[R27]> */
		/* 820D226Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D226Ch case    3:*/		return 0x820D2270;
		  /* 820D2270h */ case    4:  		/* cmpwi CR6, R11, 17 */
		/* 820D2270h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2270h case    4:*/		return 0x820D2274;
		  /* 820D2274h */ case    5:  		/* bc 12, CR6_EQ, -440 */
		/* 820D2274h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2274h case    5:*/		return 0x820D2278;
		  /* 820D2278h */ case    6:  		/* cmpwi CR6, R11, 16 */
		/* 820D2278h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2278h case    6:*/		return 0x820D227C;
		  /* 820D227Ch */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 820D227Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D2298;  }
		/* 820D227Ch case    7:*/		return 0x820D2280;
	}
	return 0x820D2280;
} // Block from 820D2260h-820D2280h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D2280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2280);
		  /* 820D2280h */ case    0:  		/* mr R4, R27 */
		/* 820D2280h case    0:*/		regs.R4 = regs.R27;
		/* 820D2280h case    0:*/		return 0x820D2284;
		  /* 820D2284h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2284h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2284h case    1:*/		return 0x820D2288;
		  /* 820D2288h */ case    2:  		/* bl -15376 */
		/* 820D2288h case    2:*/		regs.LR = 0x820D228C; return 0x820CE678;
		/* 820D2288h case    2:*/		return 0x820D228C;
		  /* 820D228Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D228Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D228Ch case    3:*/		return 0x820D2290;
		  /* 820D2290h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2290h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D226C;  }
		/* 820D2290h case    4:*/		return 0x820D2294;
		  /* 820D2294h */ case    5:  		/* b 2152 */
		/* 820D2294h case    5:*/		return 0x820D2AFC;
		/* 820D2294h case    5:*/		return 0x820D2298;
	}
	return 0x820D2298;
} // Block from 820D2280h-820D2298h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2298);
		  /* 820D2298h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D2298h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D2298h case    0:*/		return 0x820D229C;
		  /* 820D229Ch */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 820D229Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820D22CC;  }
		/* 820D229Ch case    1:*/		return 0x820D22A0;
		  /* 820D22A0h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D22A0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D22A0h case    2:*/		return 0x820D22A4;
		  /* 820D22A4h */ case    3:  		/* cmplwi CR6, R11, 44 */
		/* 820D22A4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 820D22A4h case    3:*/		return 0x820D22A8;
		  /* 820D22A8h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820D22A8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D22CC;  }
		/* 820D22A8h case    4:*/		return 0x820D22AC;
		  /* 820D22ACh */ case    5:  		/* lis R11, -32255 */
		/* 820D22ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D22ACh case    5:*/		return 0x820D22B0;
		  /* 820D22B0h */ case    6:  		/* addi R5, R11, 24664 */
		/* 820D22B0h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6058);
		/* 820D22B0h case    6:*/		return 0x820D22B4;
		  /* 820D22B4h */ case    7:  		/* b 2168 */
		/* 820D22B4h case    7:*/		return 0x820D2B2C;
		/* 820D22B4h case    7:*/		return 0x820D22B8;
		  /* 820D22B8h */ case    8:  		/* lwz R11, <#[R27]> */
		/* 820D22B8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D22B8h case    8:*/		return 0x820D22BC;
		  /* 820D22BCh */ case    9:  		/* cmpwi CR6, R11, 17 */
		/* 820D22BCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D22BCh case    9:*/		return 0x820D22C0;
		  /* 820D22C0h */ case   10:  		/* bc 12, CR6_EQ, -516 */
		/* 820D22C0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D22C0h case   10:*/		return 0x820D22C4;
		  /* 820D22C4h */ case   11:  		/* cmpwi CR6, R11, 16 */
		/* 820D22C4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D22C4h case   11:*/		return 0x820D22C8;
		  /* 820D22C8h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 820D22C8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820D22E4;  }
		/* 820D22C8h case   12:*/		return 0x820D22CC;
	}
	return 0x820D22CC;
} // Block from 820D2298h-820D22CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D22CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D22CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D22CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D22CC);
		  /* 820D22CCh */ case    0:  		/* mr R4, R27 */
		/* 820D22CCh case    0:*/		regs.R4 = regs.R27;
		/* 820D22CCh case    0:*/		return 0x820D22D0;
		  /* 820D22D0h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D22D0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D22D0h case    1:*/		return 0x820D22D4;
		  /* 820D22D4h */ case    2:  		/* bl -15452 */
		/* 820D22D4h case    2:*/		regs.LR = 0x820D22D8; return 0x820CE678;
		/* 820D22D4h case    2:*/		return 0x820D22D8;
		  /* 820D22D8h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D22D8h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D22D8h case    3:*/		return 0x820D22DC;
		  /* 820D22DCh */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D22DCh case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D22B8;  }
		/* 820D22DCh case    4:*/		return 0x820D22E0;
		  /* 820D22E0h */ case    5:  		/* b 2076 */
		/* 820D22E0h case    5:*/		return 0x820D2AFC;
		/* 820D22E0h case    5:*/		return 0x820D22E4;
	}
	return 0x820D22E4;
} // Block from 820D22CCh-820D22E4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D22E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D22E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D22E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D22E4);
		  /* 820D22E4h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 820D22E4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D22E4h case    0:*/		return 0x820D22E8;
		  /* 820D22E8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820D22E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D22F8;  }
		/* 820D22E8h case    1:*/		return 0x820D22EC;
		  /* 820D22ECh */ case    2:  		/* lis R11, -32255 */
		/* 820D22ECh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D22ECh case    2:*/		return 0x820D22F0;
		  /* 820D22F0h */ case    3:  		/* addi R5, R11, 24644 */
		/* 820D22F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6044);
		/* 820D22F0h case    3:*/		return 0x820D22F4;
		  /* 820D22F4h */ case    4:  		/* b 2104 */
		/* 820D22F4h case    4:*/		return 0x820D2B2C;
		/* 820D22F4h case    4:*/		return 0x820D22F8;
	}
	return 0x820D22F8;
} // Block from 820D22E4h-820D22F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D22F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D22F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D22F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D22F8);
		  /* 820D22F8h */ case    0:  		/* lis R11, -32217 */
		/* 820D22F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820D22F8h case    0:*/		return 0x820D22FC;
		  /* 820D22FCh */ case    1:  		/* lwz R4, <#[R21]> */
		/* 820D22FCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x00000000) );
		/* 820D22FCh case    1:*/		return 0x820D2300;
		  /* 820D2300h */ case    2:  		/* addi R5, R1, 112 */
		/* 820D2300h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820D2300h case    2:*/		return 0x820D2304;
		  /* 820D2304h */ case    3:  		/* addi R3, R11, 11576 */
		/* 820D2304h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2D38);
		/* 820D2304h case    3:*/		return 0x820D2308;
		  /* 820D2308h */ case    4:  		/* bl -14160 */
		/* 820D2308h case    4:*/		regs.LR = 0x820D230C; return 0x820CEBB8;
		/* 820D2308h case    4:*/		return 0x820D230C;
		  /* 820D230Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820D230Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D230Ch case    5:*/		return 0x820D2310;
		  /* 820D2310h */ case    6:  		/* bc 4, CR0_LT, 16 */
		/* 820D2310h case    6:*/		if ( !regs.CR[0].lt ) { return 0x820D2320;  }
		/* 820D2310h case    6:*/		return 0x820D2314;
		  /* 820D2314h */ case    7:  		/* lis R11, -32255 */
		/* 820D2314h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2314h case    7:*/		return 0x820D2318;
		  /* 820D2318h */ case    8:  		/* addi R5, R11, 24620 */
		/* 820D2318h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x602C);
		/* 820D2318h case    8:*/		return 0x820D231C;
		  /* 820D231Ch */ case    9:  		/* b 2064 */
		/* 820D231Ch case    9:*/		return 0x820D2B2C;
		/* 820D231Ch case    9:*/		return 0x820D2320;
	}
	return 0x820D2320;
} // Block from 820D22F8h-820D2320h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D2320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2320);
		  /* 820D2320h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D2320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2320h case    0:*/		return 0x820D2324;
		  /* 820D2324h */ case    1:  		/* stw R11, <#[R20 + 16]> */
		/* 820D2324h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000010) );
		/* 820D2324h case    1:*/		return 0x820D2328;
	}
	return 0x820D2328;
} // Block from 820D2320h-820D2328h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D2328h
// Function '?UpdateRootConstants@CUAssembler@D3DXShader@@IAAHPAUDEFCONST_DESC@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2328);
		  /* 820D2328h */ case    0:  		/* b 24 */
		/* 820D2328h case    0:*/		return 0x820D2340;
		/* 820D2328h case    0:*/		return 0x820D232C;
		  /* 820D232Ch */ case    1:  		/* lwz R11, <#[R27]> */
		/* 820D232Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D232Ch case    1:*/		return 0x820D2330;
		  /* 820D2330h */ case    2:  		/* cmpwi CR6, R11, 17 */
		/* 820D2330h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2330h case    2:*/		return 0x820D2334;
		  /* 820D2334h */ case    3:  		/* bc 12, CR6_EQ, -632 */
		/* 820D2334h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2334h case    3:*/		return 0x820D2338;
		  /* 820D2338h */ case    4:  		/* cmpwi CR6, R11, 16 */
		/* 820D2338h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2338h case    4:*/		return 0x820D233C;
		  /* 820D233Ch */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 820D233Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D2358;  }
		/* 820D233Ch case    5:*/		return 0x820D2340;
	}
	return 0x820D2340;
} // Block from 820D2328h-820D2340h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2340);
		  /* 820D2340h */ case    0:  		/* mr R4, R27 */
		/* 820D2340h case    0:*/		regs.R4 = regs.R27;
		/* 820D2340h case    0:*/		return 0x820D2344;
		  /* 820D2344h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2344h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2344h case    1:*/		return 0x820D2348;
		  /* 820D2348h */ case    2:  		/* bl -15568 */
		/* 820D2348h case    2:*/		regs.LR = 0x820D234C; return 0x820CE678;
		/* 820D2348h case    2:*/		return 0x820D234C;
		  /* 820D234Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D234Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D234Ch case    3:*/		return 0x820D2350;
		  /* 820D2350h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2350h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D232C;  }
		/* 820D2350h case    4:*/		return 0x820D2354;
		  /* 820D2354h */ case    5:  		/* b 1960 */
		/* 820D2354h case    5:*/		return 0x820D2AFC;
		/* 820D2354h case    5:*/		return 0x820D2358;
	}
	return 0x820D2358;
} // Block from 820D2340h-820D2358h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2358);
		  /* 820D2358h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D2358h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D2358h case    0:*/		return 0x820D235C;
		  /* 820D235Ch */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820D235Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820D2384;  }
		/* 820D235Ch case    1:*/		return 0x820D2360;
		  /* 820D2360h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D2360h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2360h case    2:*/		return 0x820D2364;
		  /* 820D2364h */ case    3:  		/* cmplwi CR6, R11, 44 */
		/* 820D2364h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 820D2364h case    3:*/		return 0x820D2368;
		  /* 820D2368h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820D2368h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D2384;  }
		/* 820D2368h case    4:*/		return 0x820D236C;
		  /* 820D236Ch */ case    5:  		/* b -192 */
		/* 820D236Ch case    5:*/		return 0x820D22AC;
		/* 820D236Ch case    5:*/		return 0x820D2370;
		  /* 820D2370h */ case    6:  		/* lwz R11, <#[R27]> */
		/* 820D2370h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2370h case    6:*/		return 0x820D2374;
		  /* 820D2374h */ case    7:  		/* cmpwi CR6, R11, 17 */
		/* 820D2374h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2374h case    7:*/		return 0x820D2378;
		  /* 820D2378h */ case    8:  		/* bc 12, CR6_EQ, -700 */
		/* 820D2378h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2378h case    8:*/		return 0x820D237C;
		  /* 820D237Ch */ case    9:  		/* cmpwi CR6, R11, 16 */
		/* 820D237Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D237Ch case    9:*/		return 0x820D2380;
		  /* 820D2380h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 820D2380h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820D239C;  }
		/* 820D2380h case   10:*/		return 0x820D2384;
	}
	return 0x820D2384;
} // Block from 820D2358h-820D2384h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D2384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2384);
		  /* 820D2384h */ case    0:  		/* mr R4, R27 */
		/* 820D2384h case    0:*/		regs.R4 = regs.R27;
		/* 820D2384h case    0:*/		return 0x820D2388;
		  /* 820D2388h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2388h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2388h case    1:*/		return 0x820D238C;
		  /* 820D238Ch */ case    2:  		/* bl -15636 */
		/* 820D238Ch case    2:*/		regs.LR = 0x820D2390; return 0x820CE678;
		/* 820D238Ch case    2:*/		return 0x820D2390;
		  /* 820D2390h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2390h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2390h case    3:*/		return 0x820D2394;
		  /* 820D2394h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2394h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2370;  }
		/* 820D2394h case    4:*/		return 0x820D2398;
		  /* 820D2398h */ case    5:  		/* b 1892 */
		/* 820D2398h case    5:*/		return 0x820D2AFC;
		/* 820D2398h case    5:*/		return 0x820D239C;
	}
	return 0x820D239C;
} // Block from 820D2384h-820D239Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D239Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D239C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D239C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D239C);
		  /* 820D239Ch */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D239Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D239Ch case    0:*/		return 0x820D23A0;
		  /* 820D23A0h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 820D23A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D23D0;  }
		/* 820D23A0h case    1:*/		return 0x820D23A4;
		  /* 820D23A4h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D23A4h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D23A4h case    2:*/		return 0x820D23A8;
		  /* 820D23A8h */ case    3:  		/* cmplwi CR6, R11, 91 */
		/* 820D23A8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005B);
		/* 820D23A8h case    3:*/		return 0x820D23AC;
		  /* 820D23ACh */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820D23ACh case    4:*/		if ( regs.CR[6].eq ) { return 0x820D23D0;  }
		/* 820D23ACh case    4:*/		return 0x820D23B0;
		  /* 820D23B0h */ case    5:  		/* lis R11, -32255 */
		/* 820D23B0h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D23B0h case    5:*/		return 0x820D23B4;
		  /* 820D23B4h */ case    6:  		/* addi R5, R11, 24572 */
		/* 820D23B4h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5FFC);
		/* 820D23B4h case    6:*/		return 0x820D23B8;
		  /* 820D23B8h */ case    7:  		/* b 1908 */
		/* 820D23B8h case    7:*/		return 0x820D2B2C;
		/* 820D23B8h case    7:*/		return 0x820D23BC;
		  /* 820D23BCh */ case    8:  		/* lwz R11, <#[R27]> */
		/* 820D23BCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D23BCh case    8:*/		return 0x820D23C0;
		  /* 820D23C0h */ case    9:  		/* cmpwi CR6, R11, 17 */
		/* 820D23C0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D23C0h case    9:*/		return 0x820D23C4;
		  /* 820D23C4h */ case   10:  		/* bc 12, CR6_EQ, -776 */
		/* 820D23C4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D23C4h case   10:*/		return 0x820D23C8;
		  /* 820D23C8h */ case   11:  		/* cmpwi CR6, R11, 16 */
		/* 820D23C8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D23C8h case   11:*/		return 0x820D23CC;
		  /* 820D23CCh */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 820D23CCh case   12:*/		if ( !regs.CR[6].eq ) { return 0x820D23E8;  }
		/* 820D23CCh case   12:*/		return 0x820D23D0;
	}
	return 0x820D23D0;
} // Block from 820D239Ch-820D23D0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D23D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D23D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D23D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D23D0);
		  /* 820D23D0h */ case    0:  		/* mr R4, R27 */
		/* 820D23D0h case    0:*/		regs.R4 = regs.R27;
		/* 820D23D0h case    0:*/		return 0x820D23D4;
		  /* 820D23D4h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D23D4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D23D4h case    1:*/		return 0x820D23D8;
		  /* 820D23D8h */ case    2:  		/* bl -15712 */
		/* 820D23D8h case    2:*/		regs.LR = 0x820D23DC; return 0x820CE678;
		/* 820D23D8h case    2:*/		return 0x820D23DC;
		  /* 820D23DCh */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D23DCh case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D23DCh case    3:*/		return 0x820D23E0;
		  /* 820D23E0h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D23E0h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D23BC;  }
		/* 820D23E0h case    4:*/		return 0x820D23E4;
		  /* 820D23E4h */ case    5:  		/* b 1816 */
		/* 820D23E4h case    5:*/		return 0x820D2AFC;
		/* 820D23E4h case    5:*/		return 0x820D23E8;
	}
	return 0x820D23E8;
} // Block from 820D23D0h-820D23E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D23E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D23E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D23E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D23E8);
		  /* 820D23E8h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820D23E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D23E8h case    0:*/		return 0x820D23EC;
		  /* 820D23ECh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820D23ECh case    1:*/		if ( regs.CR[6].eq ) { return 0x820D23FC;  }
		/* 820D23ECh case    1:*/		return 0x820D23F0;
		  /* 820D23F0h */ case    2:  		/* lis R11, -32255 */
		/* 820D23F0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D23F0h case    2:*/		return 0x820D23F4;
		  /* 820D23F4h */ case    3:  		/* addi R5, R11, 24528 */
		/* 820D23F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5FD0);
		/* 820D23F4h case    3:*/		return 0x820D23F8;
		  /* 820D23F8h */ case    4:  		/* b 1844 */
		/* 820D23F8h case    4:*/		return 0x820D2B2C;
		/* 820D23F8h case    4:*/		return 0x820D23FC;
	}
	return 0x820D23FC;
} // Block from 820D23E8h-820D23FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D23FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D23FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D23FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D23FC);
		  /* 820D23FCh */ case    0:  		/* lwz R11, <#[R21]> */
		/* 820D23FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D23FCh case    0:*/		return 0x820D2400;
		  /* 820D2400h */ case    1:  		/* stw R11, <#[R20 + 24]> */
		/* 820D2400h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000018) );
		/* 820D2400h case    1:*/		return 0x820D2404;
		  /* 820D2404h */ case    2:  		/* b 24 */
		/* 820D2404h case    2:*/		return 0x820D241C;
		/* 820D2404h case    2:*/		return 0x820D2408;
		  /* 820D2408h */ case    3:  		/* lwz R11, <#[R27]> */
		/* 820D2408h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2408h case    3:*/		return 0x820D240C;
		  /* 820D240Ch */ case    4:  		/* cmpwi CR6, R11, 17 */
		/* 820D240Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D240Ch case    4:*/		return 0x820D2410;
		  /* 820D2410h */ case    5:  		/* bc 12, CR6_EQ, -852 */
		/* 820D2410h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2410h case    5:*/		return 0x820D2414;
		  /* 820D2414h */ case    6:  		/* cmpwi CR6, R11, 16 */
		/* 820D2414h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2414h case    6:*/		return 0x820D2418;
		  /* 820D2418h */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 820D2418h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D2434;  }
		/* 820D2418h case    7:*/		return 0x820D241C;
	}
	return 0x820D241C;
} // Block from 820D23FCh-820D241Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D241Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D241C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D241C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D241C);
		  /* 820D241Ch */ case    0:  		/* mr R4, R27 */
		/* 820D241Ch case    0:*/		regs.R4 = regs.R27;
		/* 820D241Ch case    0:*/		return 0x820D2420;
		  /* 820D2420h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2420h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2420h case    1:*/		return 0x820D2424;
		  /* 820D2424h */ case    2:  		/* bl -15788 */
		/* 820D2424h case    2:*/		regs.LR = 0x820D2428; return 0x820CE678;
		/* 820D2424h case    2:*/		return 0x820D2428;
		  /* 820D2428h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2428h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2428h case    3:*/		return 0x820D242C;
		  /* 820D242Ch */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D242Ch case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2408;  }
		/* 820D242Ch case    4:*/		return 0x820D2430;
		  /* 820D2430h */ case    5:  		/* b 1740 */
		/* 820D2430h case    5:*/		return 0x820D2AFC;
		/* 820D2430h case    5:*/		return 0x820D2434;
	}
	return 0x820D2434;
} // Block from 820D241Ch-820D2434h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2434);
		  /* 820D2434h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D2434h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D2434h case    0:*/		return 0x820D2438;
		  /* 820D2438h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820D2438h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D2460;  }
		/* 820D2438h case    1:*/		return 0x820D243C;
		  /* 820D243Ch */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D243Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D243Ch case    2:*/		return 0x820D2440;
		  /* 820D2440h */ case    3:  		/* cmplwi CR6, R11, 44 */
		/* 820D2440h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 820D2440h case    3:*/		return 0x820D2444;
		  /* 820D2444h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820D2444h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D2460;  }
		/* 820D2444h case    4:*/		return 0x820D2448;
		  /* 820D2448h */ case    5:  		/* b -152 */
		/* 820D2448h case    5:*/		return 0x820D23B0;
		/* 820D2448h case    5:*/		return 0x820D244C;
		  /* 820D244Ch */ case    6:  		/* lwz R11, <#[R27]> */
		/* 820D244Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D244Ch case    6:*/		return 0x820D2450;
		  /* 820D2450h */ case    7:  		/* cmpwi CR6, R11, 17 */
		/* 820D2450h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2450h case    7:*/		return 0x820D2454;
		  /* 820D2454h */ case    8:  		/* bc 12, CR6_EQ, -920 */
		/* 820D2454h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2454h case    8:*/		return 0x820D2458;
		  /* 820D2458h */ case    9:  		/* cmpwi CR6, R11, 16 */
		/* 820D2458h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2458h case    9:*/		return 0x820D245C;
		  /* 820D245Ch */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 820D245Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x820D2478;  }
		/* 820D245Ch case   10:*/		return 0x820D2460;
	}
	return 0x820D2460;
} // Block from 820D2434h-820D2460h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D2460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2460);
		  /* 820D2460h */ case    0:  		/* mr R4, R27 */
		/* 820D2460h case    0:*/		regs.R4 = regs.R27;
		/* 820D2460h case    0:*/		return 0x820D2464;
		  /* 820D2464h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2464h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2464h case    1:*/		return 0x820D2468;
		  /* 820D2468h */ case    2:  		/* bl -15856 */
		/* 820D2468h case    2:*/		regs.LR = 0x820D246C; return 0x820CE678;
		/* 820D2468h case    2:*/		return 0x820D246C;
		  /* 820D246Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D246Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D246Ch case    3:*/		return 0x820D2470;
		  /* 820D2470h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2470h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D244C;  }
		/* 820D2470h case    4:*/		return 0x820D2474;
		  /* 820D2474h */ case    5:  		/* b 1672 */
		/* 820D2474h case    5:*/		return 0x820D2AFC;
		/* 820D2474h case    5:*/		return 0x820D2478;
	}
	return 0x820D2478;
} // Block from 820D2460h-820D2478h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2478);
		  /* 820D2478h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820D2478h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D2478h case    0:*/		return 0x820D247C;
		  /* 820D247Ch */ case    1:  		/* bc 4, CR6_EQ, -140 */
		/* 820D247Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D23F0;  }
		/* 820D247Ch case    1:*/		return 0x820D2480;
		  /* 820D2480h */ case    2:  		/* lwz R11, <#[R21]> */
		/* 820D2480h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2480h case    2:*/		return 0x820D2484;
		  /* 820D2484h */ case    3:  		/* stw R11, <#[R20 + 28]> */
		/* 820D2484h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x0000001C) );
		/* 820D2484h case    3:*/		return 0x820D2488;
		  /* 820D2488h */ case    4:  		/* b 24 */
		/* 820D2488h case    4:*/		return 0x820D24A0;
		/* 820D2488h case    4:*/		return 0x820D248C;
		  /* 820D248Ch */ case    5:  		/* lwz R11, <#[R27]> */
		/* 820D248Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D248Ch case    5:*/		return 0x820D2490;
		  /* 820D2490h */ case    6:  		/* cmpwi CR6, R11, 17 */
		/* 820D2490h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2490h case    6:*/		return 0x820D2494;
		  /* 820D2494h */ case    7:  		/* bc 12, CR6_EQ, -984 */
		/* 820D2494h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2494h case    7:*/		return 0x820D2498;
		  /* 820D2498h */ case    8:  		/* cmpwi CR6, R11, 16 */
		/* 820D2498h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2498h case    8:*/		return 0x820D249C;
		  /* 820D249Ch */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 820D249Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820D24B8;  }
		/* 820D249Ch case    9:*/		return 0x820D24A0;
	}
	return 0x820D24A0;
} // Block from 820D2478h-820D24A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D24A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D24A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D24A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D24A0);
		  /* 820D24A0h */ case    0:  		/* mr R4, R27 */
		/* 820D24A0h case    0:*/		regs.R4 = regs.R27;
		/* 820D24A0h case    0:*/		return 0x820D24A4;
		  /* 820D24A4h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D24A4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D24A4h case    1:*/		return 0x820D24A8;
		  /* 820D24A8h */ case    2:  		/* bl -15920 */
		/* 820D24A8h case    2:*/		regs.LR = 0x820D24AC; return 0x820CE678;
		/* 820D24A8h case    2:*/		return 0x820D24AC;
		  /* 820D24ACh */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D24ACh case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D24ACh case    3:*/		return 0x820D24B0;
		  /* 820D24B0h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D24B0h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D248C;  }
		/* 820D24B0h case    4:*/		return 0x820D24B4;
		  /* 820D24B4h */ case    5:  		/* b 1608 */
		/* 820D24B4h case    5:*/		return 0x820D2AFC;
		/* 820D24B4h case    5:*/		return 0x820D24B8;
	}
	return 0x820D24B8;
} // Block from 820D24A0h-820D24B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D24B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D24B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D24B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D24B8);
		  /* 820D24B8h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D24B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D24B8h case    0:*/		return 0x820D24BC;
		  /* 820D24BCh */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820D24BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820D24E4;  }
		/* 820D24BCh case    1:*/		return 0x820D24C0;
		  /* 820D24C0h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D24C0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D24C0h case    2:*/		return 0x820D24C4;
		  /* 820D24C4h */ case    3:  		/* cmplwi CR6, R11, 93 */
		/* 820D24C4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005D);
		/* 820D24C4h case    3:*/		return 0x820D24C8;
		  /* 820D24C8h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820D24C8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D24E4;  }
		/* 820D24C8h case    4:*/		return 0x820D24CC;
		  /* 820D24CCh */ case    5:  		/* b -284 */
		/* 820D24CCh case    5:*/		return 0x820D23B0;
		/* 820D24CCh case    5:*/		return 0x820D24D0;
		  /* 820D24D0h */ case    6:  		/* lwz R11, <#[R27]> */
		/* 820D24D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D24D0h case    6:*/		return 0x820D24D4;
		  /* 820D24D4h */ case    7:  		/* cmpwi CR6, R11, 17 */
		/* 820D24D4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D24D4h case    7:*/		return 0x820D24D8;
		  /* 820D24D8h */ case    8:  		/* bc 12, CR6_EQ, -1052 */
		/* 820D24D8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D24D8h case    8:*/		return 0x820D24DC;
		  /* 820D24DCh */ case    9:  		/* cmpwi CR6, R11, 16 */
		/* 820D24DCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D24DCh case    9:*/		return 0x820D24E0;
		  /* 820D24E0h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 820D24E0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820D24FC;  }
		/* 820D24E0h case   10:*/		return 0x820D24E4;
	}
	return 0x820D24E4;
} // Block from 820D24B8h-820D24E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D24E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D24E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D24E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D24E4);
		  /* 820D24E4h */ case    0:  		/* mr R4, R27 */
		/* 820D24E4h case    0:*/		regs.R4 = regs.R27;
		/* 820D24E4h case    0:*/		return 0x820D24E8;
		  /* 820D24E8h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D24E8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D24E8h case    1:*/		return 0x820D24EC;
		  /* 820D24ECh */ case    2:  		/* bl -15988 */
		/* 820D24ECh case    2:*/		regs.LR = 0x820D24F0; return 0x820CE678;
		/* 820D24ECh case    2:*/		return 0x820D24F0;
		  /* 820D24F0h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D24F0h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D24F0h case    3:*/		return 0x820D24F4;
		  /* 820D24F4h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D24F4h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D24D0;  }
		/* 820D24F4h case    4:*/		return 0x820D24F8;
		  /* 820D24F8h */ case    5:  		/* b 1540 */
		/* 820D24F8h case    5:*/		return 0x820D2AFC;
		/* 820D24F8h case    5:*/		return 0x820D24FC;
	}
	return 0x820D24FC;
} // Block from 820D24E4h-820D24FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D24FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D24FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D24FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D24FC);
		  /* 820D24FCh */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D24FCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D24FCh case    0:*/		return 0x820D2500;
		  /* 820D2500h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820D2500h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D2528;  }
		/* 820D2500h case    1:*/		return 0x820D2504;
		  /* 820D2504h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D2504h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2504h case    2:*/		return 0x820D2508;
		  /* 820D2508h */ case    3:  		/* cmplwi CR6, R11, 44 */
		/* 820D2508h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 820D2508h case    3:*/		return 0x820D250C;
		  /* 820D250Ch */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820D250Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820D2528;  }
		/* 820D250Ch case    4:*/		return 0x820D2510;
		  /* 820D2510h */ case    5:  		/* b -612 */
		/* 820D2510h case    5:*/		return 0x820D22AC;
		/* 820D2510h case    5:*/		return 0x820D2514;
		  /* 820D2514h */ case    6:  		/* lwz R11, <#[R27]> */
		/* 820D2514h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2514h case    6:*/		return 0x820D2518;
		  /* 820D2518h */ case    7:  		/* cmpwi CR6, R11, 17 */
		/* 820D2518h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2518h case    7:*/		return 0x820D251C;
		  /* 820D251Ch */ case    8:  		/* bc 12, CR6_EQ, -1120 */
		/* 820D251Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D251Ch case    8:*/		return 0x820D2520;
		  /* 820D2520h */ case    9:  		/* cmpwi CR6, R11, 16 */
		/* 820D2520h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2520h case    9:*/		return 0x820D2524;
		  /* 820D2524h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 820D2524h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820D2540;  }
		/* 820D2524h case   10:*/		return 0x820D2528;
	}
	return 0x820D2528;
} // Block from 820D24FCh-820D2528h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D2528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2528);
		  /* 820D2528h */ case    0:  		/* mr R4, R27 */
		/* 820D2528h case    0:*/		regs.R4 = regs.R27;
		/* 820D2528h case    0:*/		return 0x820D252C;
		  /* 820D252Ch */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D252Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D252Ch case    1:*/		return 0x820D2530;
		  /* 820D2530h */ case    2:  		/* bl -16056 */
		/* 820D2530h case    2:*/		regs.LR = 0x820D2534; return 0x820CE678;
		/* 820D2530h case    2:*/		return 0x820D2534;
		  /* 820D2534h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2534h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2534h case    3:*/		return 0x820D2538;
		  /* 820D2538h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2538h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2514;  }
		/* 820D2538h case    4:*/		return 0x820D253C;
		  /* 820D253Ch */ case    5:  		/* b 1472 */
		/* 820D253Ch case    5:*/		return 0x820D2AFC;
		/* 820D253Ch case    5:*/		return 0x820D2540;
	}
	return 0x820D2540;
} // Block from 820D2528h-820D2540h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2540);
		  /* 820D2540h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 820D2540h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D2540h case    0:*/		return 0x820D2544;
		  /* 820D2544h */ case    1:  		/* bc 4, CR6_EQ, 1536 */
		/* 820D2544h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D2B44;  }
		/* 820D2544h case    1:*/		return 0x820D2548;
		  /* 820D2548h */ case    2:  		/* lwz R11, <#[R31 + 52]> */
		/* 820D2548h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 820D2548h case    2:*/		return 0x820D254C;
		  /* 820D254Ch */ case    3:  		/* cmplwi CR6, R11, 2 */
		/* 820D254Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820D254Ch case    3:*/		return 0x820D2550;
		  /* 820D2550h */ case    4:  		/* bc 12, CR6_LT, 1524 */
		/* 820D2550h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D2B44;  }
		/* 820D2550h case    4:*/		return 0x820D2554;
		  /* 820D2554h */ case    5:  		/* lwz R11, <#[R21]> */
		/* 820D2554h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2554h case    5:*/		return 0x820D2558;
		  /* 820D2558h */ case    6:  		/* lbz R11, <#[R11]> */
		/* 820D2558h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820D2558h case    6:*/		return 0x820D255C;
		  /* 820D255Ch */ case    7:  		/* extsb R3, R11 */
		/* 820D255Ch case    7:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D255Ch case    7:*/		return 0x820D2560;
		  /* 820D2560h */ case    8:  		/* bl -233072 */
		/* 820D2560h case    8:*/		regs.LR = 0x820D2564; return 0x820996F0;
		/* 820D2560h case    8:*/		return 0x820D2564;
		  /* 820D2564h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820D2564h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2564h case    9:*/		return 0x820D2568;
		  /* 820D2568h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 820D2568h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820D2578;  }
		/* 820D2568h case   10:*/		return 0x820D256C;
		  /* 820D256Ch */ case   11:  		/* lis R11, -32255 */
		/* 820D256Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D256Ch case   11:*/		return 0x820D2570;
		  /* 820D2570h */ case   12:  		/* addi R5, R11, 24484 */
		/* 820D2570h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5FA4);
		/* 820D2570h case   12:*/		return 0x820D2574;
		  /* 820D2574h */ case   13:  		/* b 1464 */
		/* 820D2574h case   13:*/		return 0x820D2B2C;
		/* 820D2574h case   13:*/		return 0x820D2578;
	}
	return 0x820D2578;
} // Block from 820D2540h-820D2578h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D2578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2578);
		  /* 820D2578h */ case    0:  		/* lwz R11, <#[R21]> */
		/* 820D2578h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2578h case    0:*/		return 0x820D257C;
		  /* 820D257Ch */ case    1:  		/* lbz R11, <#[R11]> */
		/* 820D257Ch case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820D257Ch case    1:*/		return 0x820D2580;
		  /* 820D2580h */ case    2:  		/* extsb R3, R11 */
		/* 820D2580h case    2:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D2580h case    2:*/		return 0x820D2584;
		  /* 820D2584h */ case    3:  		/* bl -232948 */
		/* 820D2584h case    3:*/		regs.LR = 0x820D2588; return 0x82099790;
		/* 820D2584h case    3:*/		return 0x820D2588;
		  /* 820D2588h */ case    4:  		/* extsb R11, R3 */
		/* 820D2588h case    4:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R3);
		/* 820D2588h case    4:*/		return 0x820D258C;
		  /* 820D258Ch */ case    5:  		/* cmpwi CR6, R11, 98 */
		/* 820D258Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000062);
		/* 820D258Ch case    5:*/		return 0x820D2590;
		  /* 820D2590h */ case    6:  		/* bc 12, CR6_EQ, 68 */
		/* 820D2590h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D25D4;  }
		/* 820D2590h case    6:*/		return 0x820D2594;
		  /* 820D2594h */ case    7:  		/* cmpwi CR6, R11, 99 */
		/* 820D2594h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000063);
		/* 820D2594h case    7:*/		return 0x820D2598;
		  /* 820D2598h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 820D2598h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D25C8;  }
		/* 820D2598h case    8:*/		return 0x820D259C;
		  /* 820D259Ch */ case    9:  		/* cmpwi CR6, R11, 105 */
		/* 820D259Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 820D259Ch case    9:*/		return 0x820D25A0;
		  /* 820D25A0h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 820D25A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D25C0;  }
		/* 820D25A0h case   10:*/		return 0x820D25A4;
		  /* 820D25A4h */ case   11:  		/* cmpwi CR6, R11, 115 */
		/* 820D25A4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000073);
		/* 820D25A4h case   11:*/		return 0x820D25A8;
		  /* 820D25A8h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 820D25A8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820D25B8;  }
		/* 820D25A8h case   12:*/		return 0x820D25AC;
		  /* 820D25ACh */ case   13:  		/* lis R11, -32255 */
		/* 820D25ACh case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D25ACh case   13:*/		return 0x820D25B0;
		  /* 820D25B0h */ case   14:  		/* addi R5, R11, 24456 */
		/* 820D25B0h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5F88);
		/* 820D25B0h case   14:*/		return 0x820D25B4;
		  /* 820D25B4h */ case   15:  		/* b 1400 */
		/* 820D25B4h case   15:*/		return 0x820D2B2C;
		/* 820D25B4h case   15:*/		return 0x820D25B8;
	}
	return 0x820D25B8;
} // Block from 820D2578h-820D25B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D25B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D25B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D25B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D25B8);
		  /* 820D25B8h */ case    0:  		/* li R11, 3 */
		/* 820D25B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820D25B8h case    0:*/		return 0x820D25BC;
		  /* 820D25BCh */ case    1:  		/* b 16 */
		/* 820D25BCh case    1:*/		return 0x820D25CC;
		/* 820D25BCh case    1:*/		return 0x820D25C0;
	}
	return 0x820D25C0;
} // Block from 820D25B8h-820D25C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D25C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D25C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D25C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D25C0);
		  /* 820D25C0h */ case    0:  		/* stw R22, <#[R20 + 4]> */
		/* 820D25C0h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R20 + 0x00000004) );
		/* 820D25C0h case    0:*/		return 0x820D25C4;
		  /* 820D25C4h */ case    1:  		/* b 20 */
		/* 820D25C4h case    1:*/		return 0x820D25D8;
		/* 820D25C4h case    1:*/		return 0x820D25C8;
	}
	return 0x820D25C8;
} // Block from 820D25C0h-820D25C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D25C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D25C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D25C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D25C8);
		  /* 820D25C8h */ case    0:  		/* li R11, 2 */
		/* 820D25C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820D25C8h case    0:*/		return 0x820D25CC;
	}
	return 0x820D25CC;
} // Block from 820D25C8h-820D25CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D25CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D25CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D25CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D25CC);
		  /* 820D25CCh */ case    0:  		/* stw R11, <#[R20 + 4]> */
		/* 820D25CCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 820D25CCh case    0:*/		return 0x820D25D0;
		  /* 820D25D0h */ case    1:  		/* b 8 */
		/* 820D25D0h case    1:*/		return 0x820D25D8;
		/* 820D25D0h case    1:*/		return 0x820D25D4;
	}
	return 0x820D25D4;
} // Block from 820D25CCh-820D25D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D25D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D25D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D25D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D25D4);
		  /* 820D25D4h */ case    0:  		/* stw R19, <#[R20 + 4]> */
		/* 820D25D4h case    0:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R20 + 0x00000004) );
		/* 820D25D4h case    0:*/		return 0x820D25D8;
	}
	return 0x820D25D8;
} // Block from 820D25D4h-820D25D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D25D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D25D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D25D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D25D8);
		  /* 820D25D8h */ case    0:  		/* lwz R11, <#[R21]> */
		/* 820D25D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D25D8h case    0:*/		return 0x820D25DC;
		  /* 820D25DCh */ case    1:  		/* lbz R11, <#[R11 + 1]> */
		/* 820D25DCh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000001) );
		/* 820D25DCh case    1:*/		return 0x820D25E0;
		  /* 820D25E0h */ case    2:  		/* extsb R3, R11 */
		/* 820D25E0h case    2:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D25E0h case    2:*/		return 0x820D25E4;
		  /* 820D25E4h */ case    3:  		/* bl -233204 */
		/* 820D25E4h case    3:*/		regs.LR = 0x820D25E8; return 0x820996F0;
		/* 820D25E4h case    3:*/		return 0x820D25E8;
		  /* 820D25E8h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820D25E8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D25E8h case    4:*/		return 0x820D25EC;
		  /* 820D25ECh */ case    5:  		/* bc 12, CR0_EQ, 88 */
		/* 820D25ECh case    5:*/		if ( regs.CR[0].eq ) { return 0x820D2644;  }
		/* 820D25ECh case    5:*/		return 0x820D25F0;
		  /* 820D25F0h */ case    6:  		/* lwz R11, <#[R21]> */
		/* 820D25F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D25F0h case    6:*/		return 0x820D25F4;
		  /* 820D25F4h */ case    7:  		/* lbz R11, <#[R11 + 1]> */
		/* 820D25F4h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000001) );
		/* 820D25F4h case    7:*/		return 0x820D25F8;
		  /* 820D25F8h */ case    8:  		/* extsb R3, R11 */
		/* 820D25F8h case    8:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D25F8h case    8:*/		return 0x820D25FC;
		  /* 820D25FCh */ case    9:  		/* bl -233068 */
		/* 820D25FCh case    9:*/		regs.LR = 0x820D2600; return 0x82099790;
		/* 820D25FCh case    9:*/		return 0x820D2600;
		  /* 820D2600h */ case   10:  		/* cmpwi CR6, R3, 120 */
		/* 820D2600h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000078);
		/* 820D2600h case   10:*/		return 0x820D2604;
		  /* 820D2604h */ case   11:  		/* bc 4, CR6_EQ, 64 */
		/* 820D2604h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820D2644;  }
		/* 820D2604h case   11:*/		return 0x820D2608;
		  /* 820D2608h */ case   12:  		/* li R11, -1 */
		/* 820D2608h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D2608h case   12:*/		return 0x820D260C;
		  /* 820D260Ch */ case   13:  		/* stw R11, <#[R20 + 12]> */
		/* 820D260Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x0000000C) );
		/* 820D260Ch case   13:*/		return 0x820D2610;
		  /* 820D2610h */ case   14:  		/* stw R11, <#[R20 + 8]> */
		/* 820D2610h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 820D2610h case   14:*/		return 0x820D2614;
		  /* 820D2614h */ case   15:  		/* b 24 */
		/* 820D2614h case   15:*/		return 0x820D262C;
		/* 820D2614h case   15:*/		return 0x820D2618;
		  /* 820D2618h */ case   16:  		/* lwz R11, <#[R27]> */
		/* 820D2618h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2618h case   16:*/		return 0x820D261C;
		  /* 820D261Ch */ case   17:  		/* cmpwi CR6, R11, 17 */
		/* 820D261Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D261Ch case   17:*/		return 0x820D2620;
		  /* 820D2620h */ case   18:  		/* bc 12, CR6_EQ, -1380 */
		/* 820D2620h case   18:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2620h case   18:*/		return 0x820D2624;
		  /* 820D2624h */ case   19:  		/* cmpwi CR6, R11, 16 */
		/* 820D2624h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2624h case   19:*/		return 0x820D2628;
		  /* 820D2628h */ case   20:  		/* bc 4, CR6_EQ, 180 */
		/* 820D2628h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820D26DC;  }
		/* 820D2628h case   20:*/		return 0x820D262C;
	}
	return 0x820D262C;
} // Block from 820D25D8h-820D262Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820D262Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D262C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D262C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D262C);
		  /* 820D262Ch */ case    0:  		/* mr R4, R27 */
		/* 820D262Ch case    0:*/		regs.R4 = regs.R27;
		/* 820D262Ch case    0:*/		return 0x820D2630;
		  /* 820D2630h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2630h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2630h case    1:*/		return 0x820D2634;
		  /* 820D2634h */ case    2:  		/* bl -16316 */
		/* 820D2634h case    2:*/		regs.LR = 0x820D2638; return 0x820CE678;
		/* 820D2634h case    2:*/		return 0x820D2638;
		  /* 820D2638h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2638h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2638h case    3:*/		return 0x820D263C;
		  /* 820D263Ch */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D263Ch case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2618;  }
		/* 820D263Ch case    4:*/		return 0x820D2640;
		  /* 820D2640h */ case    5:  		/* b 1212 */
		/* 820D2640h case    5:*/		return 0x820D2AFC;
		/* 820D2640h case    5:*/		return 0x820D2644;
	}
	return 0x820D2644;
} // Block from 820D262Ch-820D2644h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2644);
		  /* 820D2644h */ case    0:  		/* lwz R11, <#[R31 + 52]> */
		/* 820D2644h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 820D2644h case    0:*/		return 0x820D2648;
		  /* 820D2648h */ case    1:  		/* mr R30, R22 */
		/* 820D2648h case    1:*/		regs.R30 = regs.R22;
		/* 820D2648h case    1:*/		return 0x820D264C;
		  /* 820D264Ch */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 820D264Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D264Ch case    2:*/		return 0x820D2650;
		  /* 820D2650h */ case    3:  		/* bc 4, CR6_GT, 44 */
		/* 820D2650h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820D267C;  }
		/* 820D2650h case    3:*/		return 0x820D2654;
		  /* 820D2654h */ case    4:  		/* lwz R11, <#[R21]> */
		/* 820D2654h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2654h case    4:*/		return 0x820D2658;
		  /* 820D2658h */ case    5:  		/* lbzx R11, <#[R30 + R11]> */
		/* 820D2658h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820D2658h case    5:*/		return 0x820D265C;
		  /* 820D265Ch */ case    6:  		/* extsb R3, R11 */
		/* 820D265Ch case    6:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D265Ch case    6:*/		return 0x820D2660;
		  /* 820D2660h */ case    7:  		/* bl -233296 */
		/* 820D2660h case    7:*/		regs.LR = 0x820D2664; return 0x82099710;
		/* 820D2660h case    7:*/		return 0x820D2664;
		  /* 820D2664h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820D2664h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2664h case    8:*/		return 0x820D2668;
		  /* 820D2668h */ case    9:  		/* bc 12, CR0_EQ, -252 */
		/* 820D2668h case    9:*/		if ( regs.CR[0].eq ) { return 0x820D256C;  }
		/* 820D2668h case    9:*/		return 0x820D266C;
		  /* 820D266Ch */ case   10:  		/* lwz R11, <#[R31 + 52]> */
		/* 820D266Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 820D266Ch case   10:*/		return 0x820D2670;
		  /* 820D2670h */ case   11:  		/* addi R30, R30, 1 */
		/* 820D2670h case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820D2670h case   11:*/		return 0x820D2674;
		  /* 820D2674h */ case   12:  		/* cmplw CR6, R30, R11 */
		/* 820D2674h case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820D2674h case   12:*/		return 0x820D2678;
		  /* 820D2678h */ case   13:  		/* bc 12, CR6_LT, -36 */
		/* 820D2678h case   13:*/		if ( regs.CR[6].lt ) { return 0x820D2654;  }
		/* 820D2678h case   13:*/		return 0x820D267C;
	}
	return 0x820D267C;
} // Block from 820D2644h-820D267Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D267Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D267C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D267C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D267C);
		  /* 820D267Ch */ case    0:  		/* lwz R11, <#[R21]> */
		/* 820D267Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D267Ch case    0:*/		return 0x820D2680;
		  /* 820D2680h */ case    1:  		/* addi R3, R11, 1 */
		/* 820D2680h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 820D2680h case    1:*/		return 0x820D2684;
		  /* 820D2684h */ case    2:  		/* bl -260892 */
		/* 820D2684h case    2:*/		regs.LR = 0x820D2688; return 0x82092B68;
		/* 820D2684h case    2:*/		return 0x820D2688;
		  /* 820D2688h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2688h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2688h case    3:*/		return 0x820D268C;
		  /* 820D268Ch */ case    4:  		/* bc 12, CR0_LT, -288 */
		/* 820D268Ch case    4:*/		if ( regs.CR[0].lt ) { return 0x820D256C;  }
		/* 820D268Ch case    4:*/		return 0x820D2690;
		  /* 820D2690h */ case    5:  		/* stw R3, <#[R20 + 8]> */
		/* 820D2690h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R20 + 0x00000008) );
		/* 820D2690h case    5:*/		return 0x820D2694;
		  /* 820D2694h */ case    6:  		/* b 24 */
		/* 820D2694h case    6:*/		return 0x820D26AC;
		/* 820D2694h case    6:*/		return 0x820D2698;
		  /* 820D2698h */ case    7:  		/* lwz R11, <#[R27]> */
		/* 820D2698h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2698h case    7:*/		return 0x820D269C;
		  /* 820D269Ch */ case    8:  		/* cmpwi CR6, R11, 17 */
		/* 820D269Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D269Ch case    8:*/		return 0x820D26A0;
		  /* 820D26A0h */ case    9:  		/* bc 12, CR6_EQ, -1508 */
		/* 820D26A0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D26A0h case    9:*/		return 0x820D26A4;
		  /* 820D26A4h */ case   10:  		/* cmpwi CR6, R11, 16 */
		/* 820D26A4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D26A4h case   10:*/		return 0x820D26A8;
		  /* 820D26A8h */ case   11:  		/* bc 4, CR6_EQ, 28 */
		/* 820D26A8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820D26C4;  }
		/* 820D26A8h case   11:*/		return 0x820D26AC;
	}
	return 0x820D26AC;
} // Block from 820D267Ch-820D26ACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D26ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D26AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D26AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D26AC);
		  /* 820D26ACh */ case    0:  		/* mr R4, R27 */
		/* 820D26ACh case    0:*/		regs.R4 = regs.R27;
		/* 820D26ACh case    0:*/		return 0x820D26B0;
		  /* 820D26B0h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D26B0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D26B0h case    1:*/		return 0x820D26B4;
		  /* 820D26B4h */ case    2:  		/* bl -16444 */
		/* 820D26B4h case    2:*/		regs.LR = 0x820D26B8; return 0x820CE678;
		/* 820D26B4h case    2:*/		return 0x820D26B8;
		  /* 820D26B8h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D26B8h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D26B8h case    3:*/		return 0x820D26BC;
		  /* 820D26BCh */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D26BCh case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2698;  }
		/* 820D26BCh case    4:*/		return 0x820D26C0;
		  /* 820D26C0h */ case    5:  		/* b 1084 */
		/* 820D26C0h case    5:*/		return 0x820D2AFC;
		/* 820D26C0h case    5:*/		return 0x820D26C4;
	}
	return 0x820D26C4;
} // Block from 820D26ACh-820D26C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D26C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D26C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D26C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D26C4);
		  /* 820D26C4h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D26C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D26C4h case    0:*/		return 0x820D26C8;
		  /* 820D26C8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D26C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D26D8;  }
		/* 820D26C8h case    1:*/		return 0x820D26CC;
		  /* 820D26CCh */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D26CCh case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D26CCh case    2:*/		return 0x820D26D0;
		  /* 820D26D0h */ case    3:  		/* cmplwi CR6, R11, 45 */
		/* 820D26D0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 820D26D0h case    3:*/		return 0x820D26D4;
		  /* 820D26D4h */ case    4:  		/* bc 12, CR6_EQ, 84 */
		/* 820D26D4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D2728;  }
		/* 820D26D4h case    4:*/		return 0x820D26D8;
	}
	return 0x820D26D8;
} // Block from 820D26C4h-820D26D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D26D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D26D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D26D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D26D8);
		  /* 820D26D8h */ case    0:  		/* stw R22, <#[R20 + 12]> */
		/* 820D26D8h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R20 + 0x0000000C) );
		/* 820D26D8h case    0:*/		return 0x820D26DC;
	}
	return 0x820D26DC;
} // Block from 820D26D8h-820D26DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D26DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D26DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D26DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D26DC);
		  /* 820D26DCh */ case    0:  		/* stw R19, <#[R20 + 44]> */
		/* 820D26DCh case    0:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R20 + 0x0000002C) );
		/* 820D26DCh case    0:*/		return 0x820D26E0;
		  /* 820D26E0h */ case    1:  		/* stw R19, <#[R20 + 40]> */
		/* 820D26E0h case    1:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R20 + 0x00000028) );
		/* 820D26E0h case    1:*/		return 0x820D26E4;
		  /* 820D26E4h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 820D26E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D26E4h case    2:*/		return 0x820D26E8;
		  /* 820D26E8h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 820D26E8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D26E8h case    3:*/		return 0x820D26EC;
		  /* 820D26ECh */ case    4:  		/* bc 4, CR6_EQ, 1056 */
		/* 820D26ECh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D2B0C;  }
		/* 820D26ECh case    4:*/		return 0x820D26F0;
		  /* 820D26F0h */ case    5:  		/* lbz R11, <#[R21]> */
		/* 820D26F0h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D26F0h case    5:*/		return 0x820D26F4;
		  /* 820D26F4h */ case    6:  		/* cmplwi CR6, R11, 44 */
		/* 820D26F4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 820D26F4h case    6:*/		return 0x820D26F8;
		  /* 820D26F8h */ case    7:  		/* bc 4, CR6_EQ, 1044 */
		/* 820D26F8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D2B0C;  }
		/* 820D26F8h case    7:*/		return 0x820D26FC;
		  /* 820D26FCh */ case    8:  		/* lwz R11, <#[R20 + 4]> */
		/* 820D26FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 820D26FCh case    8:*/		return 0x820D2700;
		  /* 820D2700h */ case    9:  		/* cmpwi CR6, R11, 3 */
		/* 820D2700h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820D2700h case    9:*/		return 0x820D2704;
		  /* 820D2704h */ case   10:  		/* bc 4, CR6_EQ, 160 */
		/* 820D2704h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820D27A4;  }
		/* 820D2704h case   10:*/		return 0x820D2708;
		  /* 820D2708h */ case   11:  		/* lis R11, -32255 */
		/* 820D2708h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2708h case   11:*/		return 0x820D270C;
		  /* 820D270Ch */ case   12:  		/* addi R5, R11, 24416 */
		/* 820D270Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5F60);
		/* 820D270Ch case   12:*/		return 0x820D2710;
		  /* 820D2710h */ case   13:  		/* b 1052 */
		/* 820D2710h case   13:*/		return 0x820D2B2C;
		/* 820D2710h case   13:*/		return 0x820D2714;
		  /* 820D2714h */ case   14:  		/* lwz R11, <#[R27]> */
		/* 820D2714h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2714h case   14:*/		return 0x820D2718;
		  /* 820D2718h */ case   15:  		/* cmpwi CR6, R11, 17 */
		/* 820D2718h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2718h case   15:*/		return 0x820D271C;
		  /* 820D271Ch */ case   16:  		/* bc 12, CR6_EQ, -1632 */
		/* 820D271Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D271Ch case   16:*/		return 0x820D2720;
		  /* 820D2720h */ case   17:  		/* cmpwi CR6, R11, 16 */
		/* 820D2720h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2720h case   17:*/		return 0x820D2724;
		  /* 820D2724h */ case   18:  		/* bc 4, CR6_EQ, 28 */
		/* 820D2724h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820D2740;  }
		/* 820D2724h case   18:*/		return 0x820D2728;
	}
	return 0x820D2728;
} // Block from 820D26DCh-820D2728h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D2728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2728);
		  /* 820D2728h */ case    0:  		/* mr R4, R27 */
		/* 820D2728h case    0:*/		regs.R4 = regs.R27;
		/* 820D2728h case    0:*/		return 0x820D272C;
		  /* 820D272Ch */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D272Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D272Ch case    1:*/		return 0x820D2730;
		  /* 820D2730h */ case    2:  		/* bl -16568 */
		/* 820D2730h case    2:*/		regs.LR = 0x820D2734; return 0x820CE678;
		/* 820D2730h case    2:*/		return 0x820D2734;
		  /* 820D2734h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2734h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2734h case    3:*/		return 0x820D2738;
		  /* 820D2738h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2738h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2714;  }
		/* 820D2738h case    4:*/		return 0x820D273C;
		  /* 820D273Ch */ case    5:  		/* b 960 */
		/* 820D273Ch case    5:*/		return 0x820D2AFC;
		/* 820D273Ch case    5:*/		return 0x820D2740;
	}
	return 0x820D2740;
} // Block from 820D2728h-820D2740h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2740);
		  /* 820D2740h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820D2740h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D2740h case    0:*/		return 0x820D2744;
		  /* 820D2744h */ case    1:  		/* bc 4, CR6_EQ, -472 */
		/* 820D2744h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D256C;  }
		/* 820D2744h case    1:*/		return 0x820D2748;
		  /* 820D2748h */ case    2:  		/* lwz R11, <#[R21]> */
		/* 820D2748h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2748h case    2:*/		return 0x820D274C;
		  /* 820D274Ch */ case    3:  		/* lwz R10, <#[R20 + 8]> */
		/* 820D274Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000008) );
		/* 820D274Ch case    3:*/		return 0x820D2750;
		  /* 820D2750h */ case    4:  		/* subf R11, R10, R11 */
		/* 820D2750h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D2750h case    4:*/		return 0x820D2754;
		  /* 820D2754h */ case    5:  		/* addic. R11, R11, 1 */
		/* 820D2754h case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0x1);
		/* 820D2754h case    5:*/		return 0x820D2758;
		  /* 820D2758h */ case    6:  		/* bc 12, CR0_LT, -492 */
		/* 820D2758h case    6:*/		if ( regs.CR[0].lt ) { return 0x820D256C;  }
		/* 820D2758h case    6:*/		return 0x820D275C;
		  /* 820D275Ch */ case    7:  		/* stw R11, <#[R20 + 12]> */
		/* 820D275Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x0000000C) );
		/* 820D275Ch case    7:*/		return 0x820D2760;
		  /* 820D2760h */ case    8:  		/* b 24 */
		/* 820D2760h case    8:*/		return 0x820D2778;
		/* 820D2760h case    8:*/		return 0x820D2764;
		  /* 820D2764h */ case    9:  		/* lwz R11, <#[R27]> */
		/* 820D2764h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2764h case    9:*/		return 0x820D2768;
		  /* 820D2768h */ case   10:  		/* cmpwi CR6, R11, 17 */
		/* 820D2768h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2768h case   10:*/		return 0x820D276C;
		  /* 820D276Ch */ case   11:  		/* bc 12, CR6_EQ, -1712 */
		/* 820D276Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D276Ch case   11:*/		return 0x820D2770;
		  /* 820D2770h */ case   12:  		/* cmpwi CR6, R11, 16 */
		/* 820D2770h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2770h case   12:*/		return 0x820D2774;
		  /* 820D2774h */ case   13:  		/* bc 4, CR6_EQ, -152 */
		/* 820D2774h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820D26DC;  }
		/* 820D2774h case   13:*/		return 0x820D2778;
	}
	return 0x820D2778;
} // Block from 820D2740h-820D2778h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D2778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2778);
		  /* 820D2778h */ case    0:  		/* mr R4, R27 */
		/* 820D2778h case    0:*/		regs.R4 = regs.R27;
		/* 820D2778h case    0:*/		return 0x820D277C;
		  /* 820D277Ch */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D277Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D277Ch case    1:*/		return 0x820D2780;
		  /* 820D2780h */ case    2:  		/* bl -16648 */
		/* 820D2780h case    2:*/		regs.LR = 0x820D2784; return 0x820CE678;
		/* 820D2780h case    2:*/		return 0x820D2784;
		  /* 820D2784h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2784h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2784h case    3:*/		return 0x820D2788;
		  /* 820D2788h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2788h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2764;  }
		/* 820D2788h case    4:*/		return 0x820D278C;
		  /* 820D278Ch */ case    5:  		/* b 880 */
		/* 820D278Ch case    5:*/		return 0x820D2AFC;
		/* 820D278Ch case    5:*/		return 0x820D2790;
		  /* 820D2790h */ case    6:  		/* lwz R11, <#[R27]> */
		/* 820D2790h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2790h case    6:*/		return 0x820D2794;
		  /* 820D2794h */ case    7:  		/* cmpwi CR6, R11, 17 */
		/* 820D2794h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2794h case    7:*/		return 0x820D2798;
		  /* 820D2798h */ case    8:  		/* bc 12, CR6_EQ, -1756 */
		/* 820D2798h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2798h case    8:*/		return 0x820D279C;
		  /* 820D279Ch */ case    9:  		/* cmpwi CR6, R11, 16 */
		/* 820D279Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D279Ch case    9:*/		return 0x820D27A0;
		  /* 820D27A0h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 820D27A0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820D27BC;  }
		/* 820D27A0h case   10:*/		return 0x820D27A4;
	}
	return 0x820D27A4;
} // Block from 820D2778h-820D27A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D27A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D27A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D27A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D27A4);
		  /* 820D27A4h */ case    0:  		/* mr R4, R27 */
		/* 820D27A4h case    0:*/		regs.R4 = regs.R27;
		/* 820D27A4h case    0:*/		return 0x820D27A8;
		  /* 820D27A8h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D27A8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D27A8h case    1:*/		return 0x820D27AC;
		  /* 820D27ACh */ case    2:  		/* bl -16692 */
		/* 820D27ACh case    2:*/		regs.LR = 0x820D27B0; return 0x820CE678;
		/* 820D27ACh case    2:*/		return 0x820D27B0;
		  /* 820D27B0h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D27B0h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D27B0h case    3:*/		return 0x820D27B4;
		  /* 820D27B4h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D27B4h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2790;  }
		/* 820D27B4h case    4:*/		return 0x820D27B8;
		  /* 820D27B8h */ case    5:  		/* b 836 */
		/* 820D27B8h case    5:*/		return 0x820D2AFC;
		/* 820D27B8h case    5:*/		return 0x820D27BC;
	}
	return 0x820D27BC;
} // Block from 820D27A4h-820D27BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D27BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D27BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D27BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D27BC);
		  /* 820D27BCh */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D27BCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D27BCh case    0:*/		return 0x820D27C0;
		  /* 820D27C0h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820D27C0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D27DC;  }
		/* 820D27C0h case    1:*/		return 0x820D27C4;
		  /* 820D27C4h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D27C4h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D27C4h case    2:*/		return 0x820D27C8;
		  /* 820D27C8h */ case    3:  		/* cmplwi CR6, R11, 123 */
		/* 820D27C8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007B);
		/* 820D27C8h case    3:*/		return 0x820D27CC;
		  /* 820D27CCh */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 820D27CCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820D27DC;  }
		/* 820D27CCh case    4:*/		return 0x820D27D0;
		  /* 820D27D0h */ case    5:  		/* lis R11, -32255 */
		/* 820D27D0h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D27D0h case    5:*/		return 0x820D27D4;
		  /* 820D27D4h */ case    6:  		/* addi R5, R11, 24372 */
		/* 820D27D4h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5F34);
		/* 820D27D4h case    6:*/		return 0x820D27D8;
		  /* 820D27D8h */ case    7:  		/* b 852 */
		/* 820D27D8h case    7:*/		return 0x820D2B2C;
		/* 820D27D8h case    7:*/		return 0x820D27DC;
	}
	return 0x820D27DC;
} // Block from 820D27BCh-820D27DCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D27DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D27DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D27DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D27DC);
		  /* 820D27DCh */ case    0:  		/* lwz R11, <#[R20 + 4]> */
		/* 820D27DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 820D27DCh case    0:*/		return 0x820D27E0;
		  /* 820D27E0h */ case    1:  		/* lwz R29, <#[R20 + 12]> */
		/* 820D27E0h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R20 + 0x0000000C) );
		/* 820D27E0h case    1:*/		return 0x820D27E4;
		  /* 820D27E4h */ case    2:  		/* cmpwi CR6, R11, 2 */
		/* 820D27E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D27E4h case    2:*/		return 0x820D27E8;
		  /* 820D27E8h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820D27E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D27F4;  }
		/* 820D27E8h case    3:*/		return 0x820D27EC;
		  /* 820D27ECh */ case    4:  		/* cmpwi CR6, R11, 1 */
		/* 820D27ECh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D27ECh case    4:*/		return 0x820D27F0;
		  /* 820D27F0h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820D27F0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D27F8;  }
		/* 820D27F0h case    5:*/		return 0x820D27F4;
	}
	return 0x820D27F4;
} // Block from 820D27DCh-820D27F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D27F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D27F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D27F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D27F4);
		  /* 820D27F4h */ case    0:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 820D27F4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 820D27F4h case    0:*/		return 0x820D27F8;
	}
	return 0x820D27F8;
} // Block from 820D27F4h-820D27F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D27F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D27F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D27F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D27F8);
		  /* 820D27F8h */ case    0:  		/* rlwinm R4, R29, 2, 0, 29 */
		/* 820D27F8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R29);
		/* 820D27F8h case    0:*/		return 0x820D27FC;
		  /* 820D27FCh */ case    1:  		/* li R5, 4 */
		/* 820D27FCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D27FCh case    1:*/		return 0x820D2800;
		  /* 820D2800h */ case    2:  		/* stw R4, <#[R20 + 40]> */
		/* 820D2800h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R20 + 0x00000028) );
		/* 820D2800h case    2:*/		return 0x820D2804;
		  /* 820D2804h */ case    3:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2804h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2804h case    3:*/		return 0x820D2808;
		  /* 820D2808h */ case    4:  		/* bl -38696 */
		/* 820D2808h case    4:*/		regs.LR = 0x820D280C; return 0x820C90E0;
		/* 820D2808h case    4:*/		return 0x820D280C;
		  /* 820D280Ch */ case    5:  		/* mr R26, R19 */
		/* 820D280Ch case    5:*/		regs.R26 = regs.R19;
		/* 820D280Ch case    5:*/		return 0x820D2810;
		  /* 820D2810h */ case    6:  		/* stw R3, <#[R20 + 44]> */
		/* 820D2810h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R20 + 0x0000002C) );
		/* 820D2810h case    6:*/		return 0x820D2814;
		  /* 820D2814h */ case    7:  		/* cmplwi CR6, R29, 0 */
		/* 820D2814h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820D2814h case    7:*/		return 0x820D2818;
		  /* 820D2818h */ case    8:  		/* bc 12, CR6_EQ, 652 */
		/* 820D2818h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D2AA4;  }
		/* 820D2818h case    8:*/		return 0x820D281C;
		  /* 820D281Ch */ case    9:  		/* lis R11, -32255 */
		/* 820D281Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D281Ch case    9:*/		return 0x820D2820;
		  /* 820D2820h */ case   10:  		/* lis R10, -32255 */
		/* 820D2820h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D2820h case   10:*/		return 0x820D2824;
		  /* 820D2824h */ case   11:  		/* mr R28, R3 */
		/* 820D2824h case   11:*/		regs.R28 = regs.R3;
		/* 820D2824h case   11:*/		return 0x820D2828;
		  /* 820D2828h */ case   12:  		/* addi R24, R11, 5224 */
		/* 820D2828h case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x1468);
		/* 820D2828h case   12:*/		return 0x820D282C;
		  /* 820D282Ch */ case   13:  		/* addi R25, R10, 5216 */
		/* 820D282Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R10,0x1460);
		/* 820D282Ch case   13:*/		return 0x820D2830;
		  /* 820D2830h */ case   14:  		/* mr R4, R27 */
		/* 820D2830h case   14:*/		regs.R4 = regs.R27;
		/* 820D2830h case   14:*/		return 0x820D2834;
		  /* 820D2834h */ case   15:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2834h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2834h case   15:*/		return 0x820D2838;
		  /* 820D2838h */ case   16:  		/* bl -16832 */
		/* 820D2838h case   16:*/		regs.LR = 0x820D283C; return 0x820CE678;
		/* 820D2838h case   16:*/		return 0x820D283C;
		  /* 820D283Ch */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820D283Ch case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D283Ch case   17:*/		return 0x820D2840;
		  /* 820D2840h */ case   18:  		/* bc 12, CR0_LT, 700 */
		/* 820D2840h case   18:*/		if ( regs.CR[0].lt ) { return 0x820D2AFC;  }
		/* 820D2840h case   18:*/		return 0x820D2844;
		  /* 820D2844h */ case   19:  		/* lwz R11, <#[R27]> */
		/* 820D2844h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2844h case   19:*/		return 0x820D2848;
		  /* 820D2848h */ case   20:  		/* cmpwi CR6, R11, 17 */
		/* 820D2848h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2848h case   20:*/		return 0x820D284C;
		  /* 820D284Ch */ case   21:  		/* bc 12, CR6_EQ, -1936 */
		/* 820D284Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D284Ch case   21:*/		return 0x820D2850;
		  /* 820D2850h */ case   22:  		/* cmpwi CR6, R11, 16 */
		/* 820D2850h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2850h case   22:*/		return 0x820D2854;
		  /* 820D2854h */ case   23:  		/* bc 12, CR6_EQ, -36 */
		/* 820D2854h case   23:*/		if ( regs.CR[6].eq ) { return 0x820D2830;  }
		/* 820D2854h case   23:*/		return 0x820D2858;
		  /* 820D2858h */ case   24:  		/* mr R30, R22 */
		/* 820D2858h case   24:*/		regs.R30 = regs.R22;
		/* 820D2858h case   24:*/		return 0x820D285C;
		  /* 820D285Ch */ case   25:  		/* cmpwi CR6, R11, 1 */
		/* 820D285Ch case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D285Ch case   25:*/		return 0x820D2860;
		  /* 820D2860h */ case   26:  		/* bc 4, CR6_EQ, 60 */
		/* 820D2860h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820D289C;  }
		/* 820D2860h case   26:*/		return 0x820D2864;
		  /* 820D2864h */ case   27:  		/* lbz R10, <#[R21]> */
		/* 820D2864h case   27:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2864h case   27:*/		return 0x820D2868;
		  /* 820D2868h */ case   28:  		/* cmplwi CR6, R10, 45 */
		/* 820D2868h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002D);
		/* 820D2868h case   28:*/		return 0x820D286C;
		  /* 820D286Ch */ case   29:  		/* bc 4, CR6_EQ, 48 */
		/* 820D286Ch case   29:*/		if ( !regs.CR[6].eq ) { return 0x820D289C;  }
		/* 820D286Ch case   29:*/		return 0x820D2870;
		  /* 820D2870h */ case   30:  		/* li R30, -1 */
		/* 820D2870h case   30:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 820D2870h case   30:*/		return 0x820D2874;
		  /* 820D2874h */ case   31:  		/* mr R4, R27 */
		/* 820D2874h case   31:*/		regs.R4 = regs.R27;
		/* 820D2874h case   31:*/		return 0x820D2878;
		  /* 820D2878h */ case   32:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2878h case   32:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2878h case   32:*/		return 0x820D287C;
		  /* 820D287Ch */ case   33:  		/* bl -16900 */
		/* 820D287Ch case   33:*/		regs.LR = 0x820D2880; return 0x820CE678;
		/* 820D287Ch case   33:*/		return 0x820D2880;
		  /* 820D2880h */ case   34:  		/* cmpwi CR0, R3, 0 */
		/* 820D2880h case   34:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2880h case   34:*/		return 0x820D2884;
		  /* 820D2884h */ case   35:  		/* bc 12, CR0_LT, 632 */
		/* 820D2884h case   35:*/		if ( regs.CR[0].lt ) { return 0x820D2AFC;  }
		/* 820D2884h case   35:*/		return 0x820D2888;
		  /* 820D2888h */ case   36:  		/* lwz R11, <#[R27]> */
		/* 820D2888h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2888h case   36:*/		return 0x820D288C;
		  /* 820D288Ch */ case   37:  		/* cmpwi CR6, R11, 17 */
		/* 820D288Ch case   37:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D288Ch case   37:*/		return 0x820D2890;
		  /* 820D2890h */ case   38:  		/* bc 12, CR6_EQ, -2004 */
		/* 820D2890h case   38:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2890h case   38:*/		return 0x820D2894;
		  /* 820D2894h */ case   39:  		/* cmpwi CR6, R11, 16 */
		/* 820D2894h case   39:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2894h case   39:*/		return 0x820D2898;
		  /* 820D2898h */ case   40:  		/* bc 12, CR6_EQ, -36 */
		/* 820D2898h case   40:*/		if ( regs.CR[6].eq ) { return 0x820D2874;  }
		/* 820D2898h case   40:*/		return 0x820D289C;
	}
	return 0x820D289C;
} // Block from 820D27F8h-820D289Ch (41 instructions)

//////////////////////////////////////////////////////
// Block at 820D289Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D289C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D289C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D289C);
		  /* 820D289Ch */ case    0:  		/* lwz R10, <#[R20 + 4]> */
		/* 820D289Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000004) );
		/* 820D289Ch case    0:*/		return 0x820D28A0;
		  /* 820D28A0h */ case    1:  		/* cmplwi CR6, R10, 1 */
		/* 820D28A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820D28A0h case    1:*/		return 0x820D28A4;
		  /* 820D28A4h */ case    2:  		/* bc 12, CR6_LT, 224 */
		/* 820D28A4h case    2:*/		if ( regs.CR[6].lt ) { return 0x820D2984;  }
		/* 820D28A4h case    2:*/		return 0x820D28A8;
		  /* 820D28A8h */ case    3:  		/* bc 12, CR6_EQ, 200 */
		/* 820D28A8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D2970;  }
		/* 820D28A8h case    3:*/		return 0x820D28AC;
		  /* 820D28ACh */ case    4:  		/* cmplwi CR6, R10, 3 */
		/* 820D28ACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820D28ACh case    4:*/		return 0x820D28B0;
		  /* 820D28B0h */ case    5:  		/* bc 4, CR6_LT, 376 */
		/* 820D28B0h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820D2A28;  }
		/* 820D28B0h case    5:*/		return 0x820D28B4;
		  /* 820D28B4h */ case    6:  		/* cmpwi CR6, R11, 2 */
		/* 820D28B4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D28B4h case    6:*/		return 0x820D28B8;
		  /* 820D28B8h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 820D28B8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D28D8;  }
		/* 820D28B8h case    7:*/		return 0x820D28BC;
		  /* 820D28BCh */ case    8:  		/* cmpwi CR6, R11, 4 */
		/* 820D28BCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820D28BCh case    8:*/		return 0x820D28C0;
		  /* 820D28C0h */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 820D28C0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D28D8;  }
		/* 820D28C0h case    9:*/		return 0x820D28C4;
		  /* 820D28C4h */ case   10:  		/* cmpwi CR6, R11, 6 */
		/* 820D28C4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820D28C4h case   10:*/		return 0x820D28C8;
		  /* 820D28C8h */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 820D28C8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820D28DC;  }
		/* 820D28C8h case   11:*/		return 0x820D28CC;
		  /* 820D28CCh */ case   12:  		/* cmpwi CR6, R11, 10 */
		/* 820D28CCh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820D28CCh case   12:*/		return 0x820D28D0;
		  /* 820D28D0h */ case   13:  		/* bc 4, CR6_GT, 36 */
		/* 820D28D0h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820D28F4;  }
		/* 820D28D0h case   13:*/		return 0x820D28D4;
		  /* 820D28D4h */ case   14:  		/* b 8 */
		/* 820D28D4h case   14:*/		return 0x820D28DC;
		/* 820D28D4h case   14:*/		return 0x820D28D8;
	}
	return 0x820D28D8;
} // Block from 820D289Ch-820D28D8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D28D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D28D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D28D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D28D8);
		  /* 820D28D8h */ case    0:  		/* li R11, 2 */
		/* 820D28D8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820D28D8h case    0:*/		return 0x820D28DC;
	}
	return 0x820D28DC;
} // Block from 820D28D8h-820D28DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D28DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D28DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D28DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D28DC);
		  /* 820D28DCh */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820D28DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D28DCh case    0:*/		return 0x820D28E0;
		  /* 820D28E0h */ case    1:  		/* bc 12, CR6_EQ, 92 */
		/* 820D28E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D293C;  }
		/* 820D28E0h case    1:*/		return 0x820D28E4;
		  /* 820D28E4h */ case    2:  		/* cmpwi CR6, R11, 3 */
		/* 820D28E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820D28E4h case    2:*/		return 0x820D28E8;
		  /* 820D28E8h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 820D28E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D2918;  }
		/* 820D28E8h case    3:*/		return 0x820D28EC;
		  /* 820D28ECh */ case    4:  		/* cmpwi CR6, R11, 7 */
		/* 820D28ECh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 820D28ECh case    4:*/		return 0x820D28F0;
		  /* 820D28F0h */ case    5:  		/* bc 4, CR6_EQ, 168 */
		/* 820D28F0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D2998;  }
		/* 820D28F0h case    5:*/		return 0x820D28F4;
	}
	return 0x820D28F4;
} // Block from 820D28DCh-820D28F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D28F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D28F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D28F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D28F4);
		  /* 820D28F4h */ case    0:  		/* extsw R11, R30 */
		/* 820D28F4h case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R30);
		/* 820D28F4h case    0:*/		return 0x820D28F8;
		  /* 820D28F8h */ case    1:  		/* lfd FR0, <#[R21]> */
		/* 820D28F8h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R21 + 0x00000000) );
		/* 820D28F8h case    1:*/		return 0x820D28FC;
		  /* 820D28FCh */ case    2:  		/* std R11, <#[R1 + 112]> */
		/* 820D28FCh case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D28FCh case    2:*/		return 0x820D2900;
		  /* 820D2900h */ case    3:  		/* lfd FR13, <#[R1 + 112]> */
		/* 820D2900h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2900h case    3:*/		return 0x820D2904;
		  /* 820D2904h */ case    4:  		/* fcfid FR13, FR13 */
		/* 820D2904h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820D2904h case    4:*/		return 0x820D2908;
		  /* 820D2908h */ case    5:  		/* frsp FR0, FR0 */
		/* 820D2908h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820D2908h case    5:*/		return 0x820D290C;
		  /* 820D290Ch */ case    6:  		/* frsp FR13, FR13 */
		/* 820D290Ch case    6:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 820D290Ch case    6:*/		return 0x820D2910;
		  /* 820D2910h */ case    7:  		/* fmuls FR0, FR13, FR0 */
		/* 820D2910h case    7:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 820D2910h case    7:*/		return 0x820D2914;
		  /* 820D2914h */ case    8:  		/* b 84 */
		/* 820D2914h case    8:*/		return 0x820D2968;
		/* 820D2914h case    8:*/		return 0x820D2918;
	}
	return 0x820D2918;
} // Block from 820D28F4h-820D2918h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D2918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2918);
		  /* 820D2918h */ case    0:  		/* lwa R10, <#[R21]> */
		/* 820D2918h case    0:*/		cpu::mem::load32a( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2918h case    0:*/		return 0x820D291C;
		  /* 820D291Ch */ case    1:  		/* extsw R11, R30 */
		/* 820D291Ch case    1:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R30);
		/* 820D291Ch case    1:*/		return 0x820D2920;
		  /* 820D2920h */ case    2:  		/* std R10, <#[R1 + 120]> */
		/* 820D2920h case    2:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 820D2920h case    2:*/		return 0x820D2924;
		  /* 820D2924h */ case    3:  		/* std R11, <#[R1 + 128]> */
		/* 820D2924h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820D2924h case    3:*/		return 0x820D2928;
		  /* 820D2928h */ case    4:  		/* lfd FR13, <#[R1 + 128]> */
		/* 820D2928h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000080) );
		/* 820D2928h case    4:*/		return 0x820D292C;
		  /* 820D292Ch */ case    5:  		/* mr R11, R10 */
		/* 820D292Ch case    5:*/		regs.R11 = regs.R10;
		/* 820D292Ch case    5:*/		return 0x820D2930;
		  /* 820D2930h */ case    6:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820D2930h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820D2930h case    6:*/		return 0x820D2934;
		  /* 820D2934h */ case    7:  		/* fcfid FR0, FR0 */
		/* 820D2934h case    7:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820D2934h case    7:*/		return 0x820D2938;
		  /* 820D2938h */ case    8:  		/* b -52 */
		/* 820D2938h case    8:*/		return 0x820D2904;
		/* 820D2938h case    8:*/		return 0x820D293C;
	}
	return 0x820D293C;
} // Block from 820D2918h-820D293Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D293Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D293C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D293C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D293C);
		  /* 820D293Ch */ case    0:  		/* extsw R10, R30 */
		/* 820D293Ch case    0:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R30);
		/* 820D293Ch case    0:*/		return 0x820D2940;
		  /* 820D2940h */ case    1:  		/* lwz R11, <#[R21]> */
		/* 820D2940h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2940h case    1:*/		return 0x820D2944;
		  /* 820D2944h */ case    2:  		/* std R10, <#[R1 + 136]> */
		/* 820D2944h case    2:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 820D2944h case    2:*/		return 0x820D2948;
		  /* 820D2948h */ case    3:  		/* std R11, <#[R1 + 144]> */
		/* 820D2948h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 820D2948h case    3:*/		return 0x820D294C;
		  /* 820D294Ch */ case    4:  		/* lfd FR13, <#[R1 + 144]> */
		/* 820D294Ch case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000090) );
		/* 820D294Ch case    4:*/		return 0x820D2950;
		  /* 820D2950h */ case    5:  		/* fcfid FR13, FR13 */
		/* 820D2950h case    5:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820D2950h case    5:*/		return 0x820D2954;
		  /* 820D2954h */ case    6:  		/* lfd FR0, <#[R1 + 136]> */
		/* 820D2954h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 820D2954h case    6:*/		return 0x820D2958;
		  /* 820D2958h */ case    7:  		/* frsp FR13, FR13 */
		/* 820D2958h case    7:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 820D2958h case    7:*/		return 0x820D295C;
		  /* 820D295Ch */ case    8:  		/* fcfid FR0, FR0 */
		/* 820D295Ch case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820D295Ch case    8:*/		return 0x820D2960;
		  /* 820D2960h */ case    9:  		/* frsp FR0, FR0 */
		/* 820D2960h case    9:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820D2960h case    9:*/		return 0x820D2964;
		  /* 820D2964h */ case   10:  		/* fmuls FR0, FR0, FR13 */
		/* 820D2964h case   10:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 820D2964h case   10:*/		return 0x820D2968;
	}
	return 0x820D2968;
} // Block from 820D293Ch-820D2968h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D2968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2968);
		  /* 820D2968h */ case    0:  		/* stfs FR0, <#[R28]> */
		/* 820D2968h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R28 + 0x00000000) );
		/* 820D2968h case    0:*/		return 0x820D296C;
		  /* 820D296Ch */ case    1:  		/* b 188 */
		/* 820D296Ch case    1:*/		return 0x820D2A28;
		/* 820D296Ch case    1:*/		return 0x820D2970;
	}
	return 0x820D2970;
} // Block from 820D2968h-820D2970h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D2970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2970);
		  /* 820D2970h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820D2970h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D2970h case    0:*/		return 0x820D2974;
		  /* 820D2974h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 820D2974h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D2998;  }
		/* 820D2974h case    1:*/		return 0x820D2978;
		  /* 820D2978h */ case    2:  		/* lwz R11, <#[R21]> */
		/* 820D2978h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2978h case    2:*/		return 0x820D297C;
		  /* 820D297Ch */ case    3:  		/* mullw R11, R30, R11 */
		/* 820D297Ch case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820D297Ch case    3:*/		return 0x820D2980;
		  /* 820D2980h */ case    4:  		/* b 164 */
		/* 820D2980h case    4:*/		return 0x820D2A24;
		/* 820D2980h case    4:*/		return 0x820D2984;
	}
	return 0x820D2984;
} // Block from 820D2970h-820D2984h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D2984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2984);
		  /* 820D2984h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 820D2984h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D2984h case    0:*/		return 0x820D2988;
		  /* 820D2988h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820D2988h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D29A4;  }
		/* 820D2988h case    1:*/		return 0x820D298C;
		  /* 820D298Ch */ case    2:  		/* lwz R11, <#[R21]> */
		/* 820D298Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D298Ch case    2:*/		return 0x820D2990;
		  /* 820D2990h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 820D2990h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D2990h case    3:*/		return 0x820D2994;
		  /* 820D2994h */ case    4:  		/* bc 4, CR6_GT, 144 */
		/* 820D2994h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820D2A24;  }
		/* 820D2994h case    4:*/		return 0x820D2998;
	}
	return 0x820D2998;
} // Block from 820D2984h-820D2998h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D2998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2998);
		  /* 820D2998h */ case    0:  		/* lis R11, -32255 */
		/* 820D2998h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2998h case    0:*/		return 0x820D299C;
		  /* 820D299Ch */ case    1:  		/* addi R5, R11, 24344 */
		/* 820D299Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5F18);
		/* 820D299Ch case    1:*/		return 0x820D29A0;
		  /* 820D29A0h */ case    2:  		/* b 396 */
		/* 820D29A0h case    2:*/		return 0x820D2B2C;
		/* 820D29A0h case    2:*/		return 0x820D29A4;
	}
	return 0x820D29A4;
} // Block from 820D2998h-820D29A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D29A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D29A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D29A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D29A4);
		  /* 820D29A4h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 820D29A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D29A4h case    0:*/		return 0x820D29A8;
		  /* 820D29A8h */ case    1:  		/* bc 4, CR6_EQ, -16 */
		/* 820D29A8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D2998;  }
		/* 820D29A8h case    1:*/		return 0x820D29AC;
		  /* 820D29ACh */ case    2:  		/* lwz R8, <#[R21]> */
		/* 820D29ACh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R21 + 0x00000000) );
		/* 820D29ACh case    2:*/		return 0x820D29B0;
		  /* 820D29B0h */ case    3:  		/* mr R10, R25 */
		/* 820D29B0h case    3:*/		regs.R10 = regs.R25;
		/* 820D29B0h case    3:*/		return 0x820D29B4;
		  /* 820D29B4h */ case    4:  		/* mr R11, R8 */
		/* 820D29B4h case    4:*/		regs.R11 = regs.R8;
		/* 820D29B4h case    4:*/		return 0x820D29B8;
		  /* 820D29B8h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820D29B8h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D29B8h case    5:*/		return 0x820D29BC;
		  /* 820D29BCh */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820D29BCh case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D29BCh case    6:*/		return 0x820D29C0;
		  /* 820D29C0h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820D29C0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D29C0h case    7:*/		return 0x820D29C4;
		  /* 820D29C4h */ case    8:  		/* subf R9, R7, R9 */
		/* 820D29C4h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D29C4h case    8:*/		return 0x820D29C8;
		  /* 820D29C8h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820D29C8h case    9:*/		if ( regs.CR[0].eq ) { return 0x820D29DC;  }
		/* 820D29C8h case    9:*/		return 0x820D29CC;
		  /* 820D29CCh */ case   10:  		/* addi R11, R11, 1 */
		/* 820D29CCh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D29CCh case   10:*/		return 0x820D29D0;
		  /* 820D29D0h */ case   11:  		/* addi R10, R10, 1 */
		/* 820D29D0h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D29D0h case   11:*/		return 0x820D29D4;
		  /* 820D29D4h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820D29D4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D29D4h case   12:*/		return 0x820D29D8;
		  /* 820D29D8h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820D29D8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820D29B8;  }
		/* 820D29D8h case   13:*/		return 0x820D29DC;
	}
	return 0x820D29DC;
} // Block from 820D29A4h-820D29DCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D29DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D29DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D29DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D29DC);
		  /* 820D29DCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D29DCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D29DCh case    0:*/		return 0x820D29E0;
		  /* 820D29E0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D29E0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D29EC;  }
		/* 820D29E0h case    1:*/		return 0x820D29E4;
		  /* 820D29E4h */ case    2:  		/* mr R11, R19 */
		/* 820D29E4h case    2:*/		regs.R11 = regs.R19;
		/* 820D29E4h case    2:*/		return 0x820D29E8;
		  /* 820D29E8h */ case    3:  		/* b 60 */
		/* 820D29E8h case    3:*/		return 0x820D2A24;
		/* 820D29E8h case    3:*/		return 0x820D29EC;
	}
	return 0x820D29EC;
} // Block from 820D29DCh-820D29ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D29ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D29EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D29EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D29EC);
		  /* 820D29ECh */ case    0:  		/* mr R10, R24 */
		/* 820D29ECh case    0:*/		regs.R10 = regs.R24;
		/* 820D29ECh case    0:*/		return 0x820D29F0;
		  /* 820D29F0h */ case    1:  		/* mr R11, R8 */
		/* 820D29F0h case    1:*/		regs.R11 = regs.R8;
		/* 820D29F0h case    1:*/		return 0x820D29F4;
		  /* 820D29F4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D29F4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D29F4h case    2:*/		return 0x820D29F8;
		  /* 820D29F8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D29F8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D29F8h case    3:*/		return 0x820D29FC;
		  /* 820D29FCh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D29FCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D29FCh case    4:*/		return 0x820D2A00;
		  /* 820D2A00h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D2A00h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D2A00h case    5:*/		return 0x820D2A04;
		  /* 820D2A04h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D2A04h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D2A18;  }
		/* 820D2A04h case    6:*/		return 0x820D2A08;
		  /* 820D2A08h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D2A08h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D2A08h case    7:*/		return 0x820D2A0C;
		  /* 820D2A0Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D2A0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D2A0Ch case    8:*/		return 0x820D2A10;
		  /* 820D2A10h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D2A10h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D2A10h case    9:*/		return 0x820D2A14;
		  /* 820D2A14h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D2A14h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D29F4;  }
		/* 820D2A14h case   10:*/		return 0x820D2A18;
	}
	return 0x820D2A18;
} // Block from 820D29ECh-820D2A18h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D2A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2A18);
		  /* 820D2A18h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D2A18h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D2A18h case    0:*/		return 0x820D2A1C;
		  /* 820D2A1Ch */ case    1:  		/* bc 4, CR0_EQ, -132 */
		/* 820D2A1Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D2998;  }
		/* 820D2A1Ch case    1:*/		return 0x820D2A20;
		  /* 820D2A20h */ case    2:  		/* mr R11, R22 */
		/* 820D2A20h case    2:*/		regs.R11 = regs.R22;
		/* 820D2A20h case    2:*/		return 0x820D2A24;
	}
	return 0x820D2A24;
} // Block from 820D2A18h-820D2A24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D2A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2A24);
		  /* 820D2A24h */ case    0:  		/* stw R11, <#[R28]> */
		/* 820D2A24h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820D2A24h case    0:*/		return 0x820D2A28;
	}
	return 0x820D2A28;
} // Block from 820D2A24h-820D2A28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D2A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2A28);
		  /* 820D2A28h */ case    0:  		/* addi R11, R29, -1 */
		/* 820D2A28h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFF);
		/* 820D2A28h case    0:*/		return 0x820D2A2C;
		  /* 820D2A2Ch */ case    1:  		/* cmplw CR6, R26, R11 */
		/* 820D2A2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 820D2A2Ch case    1:*/		return 0x820D2A30;
		  /* 820D2A30h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 820D2A30h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D2A70;  }
		/* 820D2A30h case    2:*/		return 0x820D2A34;
		  /* 820D2A34h */ case    3:  		/* mr R4, R27 */
		/* 820D2A34h case    3:*/		regs.R4 = regs.R27;
		/* 820D2A34h case    3:*/		return 0x820D2A38;
		  /* 820D2A38h */ case    4:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2A38h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2A38h case    4:*/		return 0x820D2A3C;
		  /* 820D2A3Ch */ case    5:  		/* bl -17348 */
		/* 820D2A3Ch case    5:*/		regs.LR = 0x820D2A40; return 0x820CE678;
		/* 820D2A3Ch case    5:*/		return 0x820D2A40;
	}
	return 0x820D2A40;
} // Block from 820D2A28h-820D2A40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2A40h
// Function '?DecodeDefconst@CUAssembler@D3DXShader@@IAAHPAU_D3DXCONSTANT_DESC@@PADI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2A40);
		  /* 820D2A40h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820D2A40h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2A40h case    0:*/		return 0x820D2A44;
		  /* 820D2A44h */ case    1:  		/* bc 12, CR0_LT, 184 */
		/* 820D2A44h case    1:*/		if ( regs.CR[0].lt ) { return 0x820D2AFC;  }
		/* 820D2A44h case    1:*/		return 0x820D2A48;
		  /* 820D2A48h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 820D2A48h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2A48h case    2:*/		return 0x820D2A4C;
		  /* 820D2A4Ch */ case    3:  		/* cmpwi CR6, R11, 17 */
		/* 820D2A4Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2A4Ch case    3:*/		return 0x820D2A50;
		  /* 820D2A50h */ case    4:  		/* bc 12, CR6_EQ, -2452 */
		/* 820D2A50h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2A50h case    4:*/		return 0x820D2A54;
		  /* 820D2A54h */ case    5:  		/* cmpwi CR6, R11, 16 */
		/* 820D2A54h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2A54h case    5:*/		return 0x820D2A58;
		  /* 820D2A58h */ case    6:  		/* bc 12, CR6_EQ, -36 */
		/* 820D2A58h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D2A34;  }
		/* 820D2A58h case    6:*/		return 0x820D2A5C;
		  /* 820D2A5Ch */ case    7:  		/* cmpwi CR6, R11, 1 */
		/* 820D2A5Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D2A5Ch case    7:*/		return 0x820D2A60;
		  /* 820D2A60h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 820D2A60h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D2A70;  }
		/* 820D2A60h case    8:*/		return 0x820D2A64;
		  /* 820D2A64h */ case    9:  		/* lbz R11, <#[R21]> */
		/* 820D2A64h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2A64h case    9:*/		return 0x820D2A68;
		  /* 820D2A68h */ case   10:  		/* cmplwi CR6, R11, 44 */
		/* 820D2A68h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 820D2A68h case   10:*/		return 0x820D2A6C;
		  /* 820D2A6Ch */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 820D2A6Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x820D2A84;  }
		/* 820D2A6Ch case   11:*/		return 0x820D2A70;
	}
	return 0x820D2A70;
} // Block from 820D2A40h-820D2A70h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D2A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2A70);
		  /* 820D2A70h */ case    0:  		/* addi R26, R26, 1 */
		/* 820D2A70h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820D2A70h case    0:*/		return 0x820D2A74;
		  /* 820D2A74h */ case    1:  		/* addi R28, R28, 4 */
		/* 820D2A74h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820D2A74h case    1:*/		return 0x820D2A78;
		  /* 820D2A78h */ case    2:  		/* cmplw CR6, R26, R29 */
		/* 820D2A78h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R29);
		/* 820D2A78h case    2:*/		return 0x820D2A7C;
		  /* 820D2A7Ch */ case    3:  		/* bc 12, CR6_LT, -588 */
		/* 820D2A7Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820D2830;  }
		/* 820D2A7Ch case    3:*/		return 0x820D2A80;
		  /* 820D2A80h */ case    4:  		/* b 36 */
		/* 820D2A80h case    4:*/		return 0x820D2AA4;
		/* 820D2A80h case    4:*/		return 0x820D2A84;
	}
	return 0x820D2A84;
} // Block from 820D2A70h-820D2A84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D2A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2A84);
		  /* 820D2A84h */ case    0:  		/* lis R11, -32255 */
		/* 820D2A84h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2A84h case    0:*/		return 0x820D2A88;
		  /* 820D2A88h */ case    1:  		/* addi R5, R11, 24284 */
		/* 820D2A88h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5EDC);
		/* 820D2A88h case    1:*/		return 0x820D2A8C;
		  /* 820D2A8Ch */ case    2:  		/* b 160 */
		/* 820D2A8Ch case    2:*/		return 0x820D2B2C;
		/* 820D2A8Ch case    2:*/		return 0x820D2A90;
		  /* 820D2A90h */ case    3:  		/* lwz R11, <#[R27]> */
		/* 820D2A90h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2A90h case    3:*/		return 0x820D2A94;
		  /* 820D2A94h */ case    4:  		/* cmpwi CR6, R11, 17 */
		/* 820D2A94h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2A94h case    4:*/		return 0x820D2A98;
		  /* 820D2A98h */ case    5:  		/* bc 12, CR6_EQ, -2524 */
		/* 820D2A98h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2A98h case    5:*/		return 0x820D2A9C;
		  /* 820D2A9Ch */ case    6:  		/* cmpwi CR6, R11, 16 */
		/* 820D2A9Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2A9Ch case    6:*/		return 0x820D2AA0;
		  /* 820D2AA0h */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 820D2AA0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D2ABC;  }
		/* 820D2AA0h case    7:*/		return 0x820D2AA4;
	}
	return 0x820D2AA4;
} // Block from 820D2A84h-820D2AA4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D2AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2AA4);
		  /* 820D2AA4h */ case    0:  		/* mr R4, R27 */
		/* 820D2AA4h case    0:*/		regs.R4 = regs.R27;
		/* 820D2AA4h case    0:*/		return 0x820D2AA8;
		  /* 820D2AA8h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2AA8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2AA8h case    1:*/		return 0x820D2AAC;
		  /* 820D2AACh */ case    2:  		/* bl -17460 */
		/* 820D2AACh case    2:*/		regs.LR = 0x820D2AB0; return 0x820CE678;
		/* 820D2AACh case    2:*/		return 0x820D2AB0;
		  /* 820D2AB0h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2AB0h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2AB0h case    3:*/		return 0x820D2AB4;
		  /* 820D2AB4h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2AB4h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2A90;  }
		/* 820D2AB4h case    4:*/		return 0x820D2AB8;
		  /* 820D2AB8h */ case    5:  		/* b 68 */
		/* 820D2AB8h case    5:*/		return 0x820D2AFC;
		/* 820D2AB8h case    5:*/		return 0x820D2ABC;
	}
	return 0x820D2ABC;
} // Block from 820D2AA4h-820D2ABCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2ABC);
		  /* 820D2ABCh */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D2ABCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D2ABCh case    0:*/		return 0x820D2AC0;
		  /* 820D2AC0h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820D2AC0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D2AE8;  }
		/* 820D2AC0h case    1:*/		return 0x820D2AC4;
		  /* 820D2AC4h */ case    2:  		/* lbz R11, <#[R21]> */
		/* 820D2AC4h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 820D2AC4h case    2:*/		return 0x820D2AC8;
		  /* 820D2AC8h */ case    3:  		/* cmplwi CR6, R11, 125 */
		/* 820D2AC8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 820D2AC8h case    3:*/		return 0x820D2ACC;
		  /* 820D2ACCh */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820D2ACCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820D2AE8;  }
		/* 820D2ACCh case    4:*/		return 0x820D2AD0;
		  /* 820D2AD0h */ case    5:  		/* b -768 */
		/* 820D2AD0h case    5:*/		return 0x820D27D0;
		/* 820D2AD0h case    5:*/		return 0x820D2AD4;
		  /* 820D2AD4h */ case    6:  		/* lwz R11, <#[R27]> */
		/* 820D2AD4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820D2AD4h case    6:*/		return 0x820D2AD8;
		  /* 820D2AD8h */ case    7:  		/* cmpwi CR6, R11, 17 */
		/* 820D2AD8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 820D2AD8h case    7:*/		return 0x820D2ADC;
		  /* 820D2ADCh */ case    8:  		/* bc 12, CR6_EQ, -2592 */
		/* 820D2ADCh case    8:*/		if ( regs.CR[6].eq ) { return 0x820D20BC;  }
		/* 820D2ADCh case    8:*/		return 0x820D2AE0;
		  /* 820D2AE0h */ case    9:  		/* cmpwi CR6, R11, 16 */
		/* 820D2AE0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D2AE0h case    9:*/		return 0x820D2AE4;
		  /* 820D2AE4h */ case   10:  		/* bc 4, CR6_EQ, 40 */
		/* 820D2AE4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820D2B0C;  }
		/* 820D2AE4h case   10:*/		return 0x820D2AE8;
	}
	return 0x820D2AE8;
} // Block from 820D2ABCh-820D2AE8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D2AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2AE8);
		  /* 820D2AE8h */ case    0:  		/* mr R4, R27 */
		/* 820D2AE8h case    0:*/		regs.R4 = regs.R27;
		/* 820D2AE8h case    0:*/		return 0x820D2AEC;
		  /* 820D2AECh */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820D2AECh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820D2AECh case    1:*/		return 0x820D2AF0;
		  /* 820D2AF0h */ case    2:  		/* bl -17528 */
		/* 820D2AF0h case    2:*/		regs.LR = 0x820D2AF4; return 0x820CE678;
		/* 820D2AF0h case    2:*/		return 0x820D2AF4;
		  /* 820D2AF4h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D2AF4h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2AF4h case    3:*/		return 0x820D2AF8;
		  /* 820D2AF8h */ case    4:  		/* bc 4, CR0_LT, -36 */
		/* 820D2AF8h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D2AD4;  }
		/* 820D2AF8h case    4:*/		return 0x820D2AFC;
	}
	return 0x820D2AFC;
} // Block from 820D2AE8h-820D2AFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D2AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2AFC);
		  /* 820D2AFCh */ case    0:  		/* stw R22, <#[R31 + 60]> */
		/* 820D2AFCh case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x0000003C) );
		/* 820D2AFCh case    0:*/		return 0x820D2B00;
		  /* 820D2B00h */ case    1:  		/* li R23, -1 */
		/* 820D2B00h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 820D2B00h case    1:*/		return 0x820D2B04;
		  /* 820D2B04h */ case    2:  		/* stw R22, <#[R31 + 64]> */
		/* 820D2B04h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000040) );
		/* 820D2B04h case    2:*/		return 0x820D2B08;
		  /* 820D2B08h */ case    3:  		/* b 100 */
		/* 820D2B08h case    3:*/		return 0x820D2B6C;
		/* 820D2B08h case    3:*/		return 0x820D2B0C;
	}
	return 0x820D2B0C;
} // Block from 820D2AFCh-820D2B0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B0C);
		  /* 820D2B0Ch */ case    0:  		/* lwz R11, <#[R20 + 32]> */
		/* 820D2B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000020) );
		/* 820D2B0Ch case    0:*/		return 0x820D2B10;
		  /* 820D2B10h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820D2B10h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820D2B10h case    1:*/		return 0x820D2B14;
		  /* 820D2B14h */ case    2:  		/* bc 4, CR6_EQ, 88 */
		/* 820D2B14h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D2B6C;  }
		/* 820D2B14h case    2:*/		return 0x820D2B18;
		  /* 820D2B18h */ case    3:  		/* lwz R11, <#[R20 + 36]> */
		/* 820D2B18h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000024) );
		/* 820D2B18h case    3:*/		return 0x820D2B1C;
		  /* 820D2B1Ch */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 820D2B1Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820D2B1Ch case    4:*/		return 0x820D2B20;
		  /* 820D2B20h */ case    5:  		/* bc 4, CR6_EQ, 76 */
		/* 820D2B20h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D2B6C;  }
		/* 820D2B20h case    5:*/		return 0x820D2B24;
		  /* 820D2B24h */ case    6:  		/* lis R11, -32255 */
		/* 820D2B24h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2B24h case    6:*/		return 0x820D2B28;
		  /* 820D2B28h */ case    7:  		/* addi R5, R11, 24228 */
		/* 820D2B28h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5EA4);
		/* 820D2B28h case    7:*/		return 0x820D2B2C;
	}
	return 0x820D2B2C;
} // Block from 820D2B0Ch-820D2B2Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B2C);
		  /* 820D2B2Ch */ case    0:  		/* lis R10, -32255 */
		/* 820D2B2Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D2B2Ch case    0:*/		return 0x820D2B30;
		  /* 820D2B30h */ case    1:  		/* mr R3, R31 */
		/* 820D2B30h case    1:*/		regs.R3 = regs.R31;
		/* 820D2B30h case    1:*/		return 0x820D2B34;
		  /* 820D2B34h */ case    2:  		/* addi R4, R10, 23508 */
		/* 820D2B34h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x5BD4);
		/* 820D2B34h case    2:*/		return 0x820D2B38;
		  /* 820D2B38h */ case    3:  		/* bl -8784 */
		/* 820D2B38h case    3:*/		regs.LR = 0x820D2B3C; return 0x820D08E8;
		/* 820D2B38h case    3:*/		return 0x820D2B3C;
		  /* 820D2B3Ch */ case    4:  		/* li R23, -1 */
		/* 820D2B3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 820D2B3Ch case    4:*/		return 0x820D2B40;
		  /* 820D2B40h */ case    5:  		/* b 44 */
		/* 820D2B40h case    5:*/		return 0x820D2B6C;
		/* 820D2B40h case    5:*/		return 0x820D2B44;
	}
	return 0x820D2B44;
} // Block from 820D2B2Ch-820D2B44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B44);
		  /* 820D2B44h */ case    0:  		/* lis R11, -32255 */
		/* 820D2B44h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2B44h case    0:*/		return 0x820D2B48;
		  /* 820D2B48h */ case    1:  		/* addi R5, R11, 24200 */
		/* 820D2B48h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5E88);
		/* 820D2B48h case    1:*/		return 0x820D2B4C;
		  /* 820D2B4Ch */ case    2:  		/* b -32 */
		/* 820D2B4Ch case    2:*/		return 0x820D2B2C;
		/* 820D2B4Ch case    2:*/		return 0x820D2B50;
	}
	return 0x820D2B50;
} // Block from 820D2B44h-820D2B50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B50);
		  /* 820D2B50h */ case    0:  		/* lis R11, -32255 */
		/* 820D2B50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2B50h case    0:*/		return 0x820D2B54;
		  /* 820D2B54h */ case    1:  		/* addi R5, R11, 24156 */
		/* 820D2B54h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5E5C);
		/* 820D2B54h case    1:*/		return 0x820D2B58;
		  /* 820D2B58h */ case    2:  		/* b -44 */
		/* 820D2B58h case    2:*/		return 0x820D2B2C;
		/* 820D2B58h case    2:*/		return 0x820D2B5C;
	}
	return 0x820D2B5C;
} // Block from 820D2B50h-820D2B5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B5C);
		  /* 820D2B5Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D2B5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2B5Ch case    0:*/		return 0x820D2B60;
		  /* 820D2B60h */ case    1:  		/* addi R5, R11, 24136 */
		/* 820D2B60h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5E48);
		/* 820D2B60h case    1:*/		return 0x820D2B64;
		  /* 820D2B64h */ case    2:  		/* b -56 */
		/* 820D2B64h case    2:*/		return 0x820D2B2C;
		/* 820D2B64h case    2:*/		return 0x820D2B68;
	}
	return 0x820D2B68;
} // Block from 820D2B5Ch-820D2B68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B68);
		  /* 820D2B68h */ case    0:  		/* li R23, 280 */
		/* 820D2B68h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x118);
		/* 820D2B68h case    0:*/		return 0x820D2B6C;
	}
	return 0x820D2B6C;
} // Block from 820D2B68h-820D2B6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B6C);
		  /* 820D2B6Ch */ case    0:  		/* mr R3, R23 */
		/* 820D2B6Ch case    0:*/		regs.R3 = regs.R23;
		/* 820D2B6Ch case    0:*/		return 0x820D2B70;
		  /* 820D2B70h */ case    1:  		/* addi R1, R1, 336 */
		/* 820D2B70h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x150);
		/* 820D2B70h case    1:*/		return 0x820D2B74;
		  /* 820D2B74h */ case    2:  		/* b -268528 */
		/* 820D2B74h case    2:*/		return 0x82091284;
		/* 820D2B74h case    2:*/		return 0x820D2B78;
	}
	return 0x820D2B78;
} // Block from 820D2B6Ch-820D2B78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D2B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2B78);
		  /* 820D2B78h */ case    0:  		/* mfspr R12, LR */
		/* 820D2B78h case    0:*/		regs.R12 = regs.LR;
		/* 820D2B78h case    0:*/		return 0x820D2B7C;
		  /* 820D2B7Ch */ case    1:  		/* bl -268636 */
		/* 820D2B7Ch case    1:*/		regs.LR = 0x820D2B80; return 0x82091220;
		/* 820D2B7Ch case    1:*/		return 0x820D2B80;
		  /* 820D2B80h */ case    2:  		/* stwu R1, <#[R1 - 1552]> */
		/* 820D2B80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF9F0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF9F0);
		/* 820D2B80h case    2:*/		return 0x820D2B84;
		  /* 820D2B84h */ case    3:  		/* li R11, 5 */
		/* 820D2B84h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820D2B84h case    3:*/		return 0x820D2B88;
		  /* 820D2B88h */ case    4:  		/* mr R23, R3 */
		/* 820D2B88h case    4:*/		regs.R23 = regs.R3;
		/* 820D2B88h case    4:*/		return 0x820D2B8C;
		  /* 820D2B8Ch */ case    5:  		/* li R14, 284 */
		/* 820D2B8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R14,0x11C);
		/* 820D2B8Ch case    5:*/		return 0x820D2B90;
		  /* 820D2B90h */ case    6:  		/* addi R9, R3, 8 */
		/* 820D2B90h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 820D2B90h case    6:*/		return 0x820D2B94;
		  /* 820D2B94h */ case    7:  		/* addi R10, R4, -8 */
		/* 820D2B94h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFF8);
		/* 820D2B94h case    7:*/		return 0x820D2B98;
		  /* 820D2B98h */ case    8:  		/* mtspr CTR, R11 */
		/* 820D2B98h case    8:*/		regs.CTR = regs.R11;
		/* 820D2B98h case    8:*/		return 0x820D2B9C;
		  /* 820D2B9Ch */ case    9:  		/* ldu R11, <#[R10 + 8]> */
		/* 820D2B9Ch case    9:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820D2B9Ch case    9:*/		return 0x820D2BA0;
		  /* 820D2BA0h */ case   10:  		/* stdu R11, <#[R9 + 8]> */
		/* 820D2BA0h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820D2BA0h case   10:*/		return 0x820D2BA4;
		  /* 820D2BA4h */ case   11:  		/* bc 16, CR0_LT, -8 */
		/* 820D2BA4h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D2B9C;  }
		/* 820D2BA4h case   11:*/		return 0x820D2BA8;
		  /* 820D2BA8h */ case   12:  		/* lwz R11, <#[R23 + 100]> */
		/* 820D2BA8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000064) );
		/* 820D2BA8h case   12:*/		return 0x820D2BAC;
		  /* 820D2BACh */ case   13:  		/* cmpwi CR6, R11, 0 */
		/* 820D2BACh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D2BACh case   13:*/		return 0x820D2BB0;
		  /* 820D2BB0h */ case   14:  		/* bc 12, CR6_EQ, 44 */
		/* 820D2BB0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820D2BDC;  }
		/* 820D2BB0h case   14:*/		return 0x820D2BB4;
		  /* 820D2BB4h */ case   15:  		/* lis R11, -32255 */
		/* 820D2BB4h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2BB4h case   15:*/		return 0x820D2BB8;
		  /* 820D2BB8h */ case   16:  		/* addi R5, R11, 24920 */
		/* 820D2BB8h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6158);
		/* 820D2BB8h case   16:*/		return 0x820D2BBC;
		  /* 820D2BBCh */ case   17:  		/* lis R10, -32255 */
		/* 820D2BBCh case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D2BBCh case   17:*/		return 0x820D2BC0;
		  /* 820D2BC0h */ case   18:  		/* mr R3, R23 */
		/* 820D2BC0h case   18:*/		regs.R3 = regs.R23;
		/* 820D2BC0h case   18:*/		return 0x820D2BC4;
		  /* 820D2BC4h */ case   19:  		/* addi R4, R10, 23508 */
		/* 820D2BC4h case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x5BD4);
		/* 820D2BC4h case   19:*/		return 0x820D2BC8;
		  /* 820D2BC8h */ case   20:  		/* bl -8928 */
		/* 820D2BC8h case   20:*/		regs.LR = 0x820D2BCC; return 0x820D08E8;
		/* 820D2BC8h case   20:*/		return 0x820D2BCC;
		  /* 820D2BCCh */ case   21:  		/* li R14, -1 */
		/* 820D2BCCh case   21:*/		cpu::op::li<0>(regs,&regs.R14,0xFFFFFFFF);
		/* 820D2BCCh case   21:*/		return 0x820D2BD0;
		  /* 820D2BD0h */ case   22:  		/* mr R3, R14 */
		/* 820D2BD0h case   22:*/		regs.R3 = regs.R14;
		/* 820D2BD0h case   22:*/		return 0x820D2BD4;
		  /* 820D2BD4h */ case   23:  		/* addi R1, R1, 1552 */
		/* 820D2BD4h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x610);
		/* 820D2BD4h case   23:*/		return 0x820D2BD8;
		  /* 820D2BD8h */ case   24:  		/* b -268648 */
		/* 820D2BD8h case   24:*/		return 0x82091270;
		/* 820D2BD8h case   24:*/		return 0x820D2BDC;
	}
	return 0x820D2BDC;
} // Block from 820D2B78h-820D2BDCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820D2BDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2BDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2BDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2BDC);
		  /* 820D2BDCh */ case    0:  		/* li R11, 1 */
		/* 820D2BDCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D2BDCh case    0:*/		return 0x820D2BE0;
		  /* 820D2BE0h */ case    1:  		/* li R24, 0 */
		/* 820D2BE0h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820D2BE0h case    1:*/		return 0x820D2BE4;
		  /* 820D2BE4h */ case    2:  		/* stw R11, <#[R23 + 100]> */
		/* 820D2BE4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000064) );
		/* 820D2BE4h case    2:*/		return 0x820D2BE8;
		  /* 820D2BE8h */ case    3:  		/* lwz R3, <#[R23 + 136]> */
		/* 820D2BE8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000088) );
		/* 820D2BE8h case    3:*/		return 0x820D2BEC;
		  /* 820D2BECh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820D2BECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820D2BECh case    4:*/		return 0x820D2BF0;
		  /* 820D2BF0h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820D2BF0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D2C08;  }
		/* 820D2BF0h case    5:*/		return 0x820D2BF4;
		  /* 820D2BF4h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820D2BF4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820D2BF4h case    6:*/		return 0x820D2BF8;
		  /* 820D2BF8h */ case    7:  		/* lwz R11, <#[R11 + 8]> */
		/* 820D2BF8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820D2BF8h case    7:*/		return 0x820D2BFC;
		  /* 820D2BFCh */ case    8:  		/* mtspr CTR, R11 */
		/* 820D2BFCh case    8:*/		regs.CTR = regs.R11;
		/* 820D2BFCh case    8:*/		return 0x820D2C00;
		  /* 820D2C00h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820D2C00h case    9:*/		if ( 1 ) { regs.LR = 0x820D2C04; return (uint32)regs.CTR; }
		/* 820D2C00h case    9:*/		return 0x820D2C04;
		  /* 820D2C04h */ case   10:  		/* stw R24, <#[R23 + 136]> */
		/* 820D2C04h case   10:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R23 + 0x00000088) );
		/* 820D2C04h case   10:*/		return 0x820D2C08;
	}
	return 0x820D2C08;
} // Block from 820D2BDCh-820D2C08h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D2C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2C08);
		  /* 820D2C08h */ case    0:  		/* li R5, 1084 */
		/* 820D2C08h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x43C);
		/* 820D2C08h case    0:*/		return 0x820D2C0C;
		  /* 820D2C0Ch */ case    1:  		/* li R4, 0 */
		/* 820D2C0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D2C0Ch case    1:*/		return 0x820D2C10;
		  /* 820D2C10h */ case    2:  		/* addi R3, R1, 304 */
		/* 820D2C10h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x130);
		/* 820D2C10h case    2:*/		return 0x820D2C14;
		  /* 820D2C14h */ case    3:  		/* bl -268500 */
		/* 820D2C14h case    3:*/		regs.LR = 0x820D2C18; return 0x82091340;
		/* 820D2C14h case    3:*/		return 0x820D2C18;
		  /* 820D2C18h */ case    4:  		/* mr R31, R24 */
		/* 820D2C18h case    4:*/		regs.R31 = regs.R24;
		/* 820D2C18h case    4:*/		return 0x820D2C1C;
		  /* 820D2C1Ch */ case    5:  		/* b 44 */
		/* 820D2C1Ch case    5:*/		return 0x820D2C48;
		/* 820D2C1Ch case    5:*/		return 0x820D2C20;
		  /* 820D2C20h */ case    6:  		/* cmpwi CR6, R3, 280 */
		/* 820D2C20h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000118);
		/* 820D2C20h case    6:*/		return 0x820D2C24;
		  /* 820D2C24h */ case    7:  		/* bc 12, CR6_EQ, 68 */
		/* 820D2C24h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D2C68;  }
		/* 820D2C24h case    7:*/		return 0x820D2C28;
		  /* 820D2C28h */ case    8:  		/* addi R6, R1, 304 */
		/* 820D2C28h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x130);
		/* 820D2C28h case    8:*/		return 0x820D2C2C;
		  /* 820D2C2Ch */ case    9:  		/* addi R5, R1, 176 */
		/* 820D2C2Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB0);
		/* 820D2C2Ch case    9:*/		return 0x820D2C30;
		  /* 820D2C30h */ case   10:  		/* addi R4, R1, 128 */
		/* 820D2C30h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820D2C30h case   10:*/		return 0x820D2C34;
		  /* 820D2C34h */ case   11:  		/* mr R3, R23 */
		/* 820D2C34h case   11:*/		regs.R3 = regs.R23;
		/* 820D2C34h case   11:*/		return 0x820D2C38;
		  /* 820D2C38h */ case   12:  		/* bl -10160 */
		/* 820D2C38h case   12:*/		regs.LR = 0x820D2C3C; return 0x820D0488;
		/* 820D2C38h case   12:*/		return 0x820D2C3C;
		  /* 820D2C3Ch */ case   13:  		/* cmpwi CR6, R3, -1 */
		/* 820D2C3Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820D2C3Ch case   13:*/		return 0x820D2C40;
		  /* 820D2C40h */ case   14:  		/* bc 12, CR6_EQ, -116 */
		/* 820D2C40h case   14:*/		if ( regs.CR[6].eq ) { return 0x820D2BCC;  }
		/* 820D2C40h case   14:*/		return 0x820D2C44;
		  /* 820D2C44h */ case   15:  		/* addi R31, R31, 1 */
		/* 820D2C44h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820D2C44h case   15:*/		return 0x820D2C48;
	}
	return 0x820D2C48;
} // Block from 820D2C08h-820D2C48h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D2C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2C48);
		  /* 820D2C48h */ case    0:  		/* li R6, 128 */
		/* 820D2C48h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x80);
		/* 820D2C48h case    0:*/		return 0x820D2C4C;
		  /* 820D2C4Ch */ case    1:  		/* addi R5, R1, 176 */
		/* 820D2C4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB0);
		/* 820D2C4Ch case    1:*/		return 0x820D2C50;
		  /* 820D2C50h */ case    2:  		/* addi R4, R1, 128 */
		/* 820D2C50h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820D2C50h case    2:*/		return 0x820D2C54;
		  /* 820D2C54h */ case    3:  		/* mr R3, R23 */
		/* 820D2C54h case    3:*/		regs.R3 = regs.R23;
		/* 820D2C54h case    3:*/		return 0x820D2C58;
		  /* 820D2C58h */ case    4:  		/* bl -3160 */
		/* 820D2C58h case    4:*/		regs.LR = 0x820D2C5C; return 0x820D2000;
		/* 820D2C58h case    4:*/		return 0x820D2C5C;
		  /* 820D2C5Ch */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 820D2C5Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820D2C5Ch case    5:*/		return 0x820D2C60;
		  /* 820D2C60h */ case    6:  		/* bc 4, CR6_EQ, -64 */
		/* 820D2C60h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820D2C20;  }
		/* 820D2C60h case    6:*/		return 0x820D2C64;
		  /* 820D2C64h */ case    7:  		/* b -152 */
		/* 820D2C64h case    7:*/		return 0x820D2BCC;
		/* 820D2C64h case    7:*/		return 0x820D2C68;
	}
	return 0x820D2C68;
} // Block from 820D2C48h-820D2C68h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D2C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2C68);
		  /* 820D2C68h */ case    0:  		/* lwz R30, <#[R1 + 360]> */
		/* 820D2C68h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000168) );
		/* 820D2C68h case    0:*/		return 0x820D2C6C;
		  /* 820D2C6Ch */ case    1:  		/* mr R29, R24 */
		/* 820D2C6Ch case    1:*/		regs.R29 = regs.R24;
		/* 820D2C6Ch case    1:*/		return 0x820D2C70;
		  /* 820D2C70h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 820D2C70h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820D2C70h case    2:*/		return 0x820D2C74;
		  /* 820D2C74h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820D2C74h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D2CA0;  }
		/* 820D2C74h case    3:*/		return 0x820D2C78;
		  /* 820D2C78h */ case    4:  		/* addi R28, R1, 364 */
		/* 820D2C78h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x16C);
		/* 820D2C78h case    4:*/		return 0x820D2C7C;
		  /* 820D2C7Ch */ case    5:  		/* mr R3, R23 */
		/* 820D2C7Ch case    5:*/		regs.R3 = regs.R23;
		/* 820D2C7Ch case    5:*/		return 0x820D2C80;
		  /* 820D2C80h */ case    6:  		/* lwz R4, <#[R28]> */
		/* 820D2C80h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820D2C80h case    6:*/		return 0x820D2C84;
		  /* 820D2C84h */ case    7:  		/* bl -5020 */
		/* 820D2C84h case    7:*/		regs.LR = 0x820D2C88; return 0x820D18E8;
		/* 820D2C84h case    7:*/		return 0x820D2C88;
		  /* 820D2C88h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 820D2C88h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820D2C88h case    8:*/		return 0x820D2C8C;
		  /* 820D2C8Ch */ case    9:  		/* bc 12, CR6_EQ, -192 */
		/* 820D2C8Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820D2BCC;  }
		/* 820D2C8Ch case    9:*/		return 0x820D2C90;
		  /* 820D2C90h */ case   10:  		/* addi R29, R29, 1 */
		/* 820D2C90h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820D2C90h case   10:*/		return 0x820D2C94;
		  /* 820D2C94h */ case   11:  		/* addi R28, R28, 4 */
		/* 820D2C94h case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820D2C94h case   11:*/		return 0x820D2C98;
		  /* 820D2C98h */ case   12:  		/* cmplw CR6, R29, R30 */
		/* 820D2C98h case   12:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820D2C98h case   12:*/		return 0x820D2C9C;
		  /* 820D2C9Ch */ case   13:  		/* bc 12, CR6_LT, -32 */
		/* 820D2C9Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x820D2C7C;  }
		/* 820D2C9Ch case   13:*/		return 0x820D2CA0;
	}
	return 0x820D2CA0;
} // Block from 820D2C68h-820D2CA0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D2CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2CA0);
		  /* 820D2CA0h */ case    0:  		/* li R5, 4 */
		/* 820D2CA0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D2CA0h case    0:*/		return 0x820D2CA4;
		  /* 820D2CA4h */ case    1:  		/* lwz R3, <#[R23 + 4]> */
		/* 820D2CA4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 820D2CA4h case    1:*/		return 0x820D2CA8;
		  /* 820D2CA8h */ case    2:  		/* mulli R4, R30, 20 */
		/* 820D2CA8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R30,0x14);
		/* 820D2CA8h case    2:*/		return 0x820D2CAC;
		  /* 820D2CACh */ case    3:  		/* bl -39884 */
		/* 820D2CACh case    3:*/		regs.LR = 0x820D2CB0; return 0x820C90E0;
		/* 820D2CACh case    3:*/		return 0x820D2CB0;
		  /* 820D2CB0h */ case    4:  		/* mulli R19, R31, 66 */
		/* 820D2CB0h case    4:*/		cpu::op::mulli<0>(regs,&regs.R19,regs.R31,0x42);
		/* 820D2CB0h case    4:*/		return 0x820D2CB4;
		  /* 820D2CB4h */ case    5:  		/* li R5, 4 */
		/* 820D2CB4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D2CB4h case    5:*/		return 0x820D2CB8;
		  /* 820D2CB8h */ case    6:  		/* rlwinm R4, R19, 4, 0, 27 */
		/* 820D2CB8h case    6:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R4,regs.R19);
		/* 820D2CB8h case    6:*/		return 0x820D2CBC;
		  /* 820D2CBCh */ case    7:  		/* mr R21, R3 */
		/* 820D2CBCh case    7:*/		regs.R21 = regs.R3;
		/* 820D2CBCh case    7:*/		return 0x820D2CC0;
		  /* 820D2CC0h */ case    8:  		/* lwz R3, <#[R23 + 4]> */
		/* 820D2CC0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 820D2CC0h case    8:*/		return 0x820D2CC4;
		  /* 820D2CC4h */ case    9:  		/* mr R29, R24 */
		/* 820D2CC4h case    9:*/		regs.R29 = regs.R24;
		/* 820D2CC4h case    9:*/		return 0x820D2CC8;
		  /* 820D2CC8h */ case   10:  		/* bl -39912 */
		/* 820D2CC8h case   10:*/		regs.LR = 0x820D2CCC; return 0x820C90E0;
		/* 820D2CC8h case   10:*/		return 0x820D2CCC;
		  /* 820D2CCCh */ case   11:  		/* stw R24, <#[R1 + 112]> */
		/* 820D2CCCh case   11:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2CCCh case   11:*/		return 0x820D2CD0;
		  /* 820D2CD0h */ case   12:  		/* li R5, 4 */
		/* 820D2CD0h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D2CD0h case   12:*/		return 0x820D2CD4;
		  /* 820D2CD4h */ case   13:  		/* rlwinm R4, R31, 3, 0, 28 */
		/* 820D2CD4h case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R31);
		/* 820D2CD4h case   13:*/		return 0x820D2CD8;
		  /* 820D2CD8h */ case   14:  		/* mr R18, R3 */
		/* 820D2CD8h case   14:*/		regs.R18 = regs.R3;
		/* 820D2CD8h case   14:*/		return 0x820D2CDC;
		  /* 820D2CDCh */ case   15:  		/* lwz R3, <#[R23 + 4]> */
		/* 820D2CDCh case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 820D2CDCh case   15:*/		return 0x820D2CE0;
		  /* 820D2CE0h */ case   16:  		/* bl -39936 */
		/* 820D2CE0h case   16:*/		regs.LR = 0x820D2CE4; return 0x820C90E0;
		/* 820D2CE0h case   16:*/		return 0x820D2CE4;
		  /* 820D2CE4h */ case   17:  		/* mr R16, R3 */
		/* 820D2CE4h case   17:*/		regs.R16 = regs.R3;
		/* 820D2CE4h case   17:*/		return 0x820D2CE8;
		  /* 820D2CE8h */ case   18:  		/* stw R24, <#[R1 + 116]> */
		/* 820D2CE8h case   18:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000074) );
		/* 820D2CE8h case   18:*/		return 0x820D2CEC;
		  /* 820D2CECh */ case   19:  		/* mr R22, R24 */
		/* 820D2CECh case   19:*/		regs.R22 = regs.R24;
		/* 820D2CECh case   19:*/		return 0x820D2CF0;
		  /* 820D2CF0h */ case   20:  		/* cmplwi CR6, R30, 0 */
		/* 820D2CF0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820D2CF0h case   20:*/		return 0x820D2CF4;
		  /* 820D2CF4h */ case   21:  		/* bc 12, CR6_EQ, 36 */
		/* 820D2CF4h case   21:*/		if ( regs.CR[6].eq ) { return 0x820D2D18;  }
		/* 820D2CF4h case   21:*/		return 0x820D2CF8;
		  /* 820D2CF8h */ case   22:  		/* addi R10, R1, 360 */
		/* 820D2CF8h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x168);
		/* 820D2CF8h case   22:*/		return 0x820D2CFC;
		  /* 820D2CFCh */ case   23:  		/* mtspr CTR, R30 */
		/* 820D2CFCh case   23:*/		regs.CTR = regs.R30;
		/* 820D2CFCh case   23:*/		return 0x820D2D00;
		  /* 820D2D00h */ case   24:  		/* lwzu R11, <#[R10 + 4]> */
		/* 820D2D00h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820D2D00h case   24:*/		return 0x820D2D04;
		  /* 820D2D04h */ case   25:  		/* lwz R9, <#[R11 + 40]> */
		/* 820D2D04h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000028) );
		/* 820D2D04h case   25:*/		return 0x820D2D08;
		  /* 820D2D08h */ case   26:  		/* lwz R11, <#[R11 + 32]> */
		/* 820D2D08h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 820D2D08h case   26:*/		return 0x820D2D0C;
		  /* 820D2D0Ch */ case   27:  		/* mullw R11, R9, R11 */
		/* 820D2D0Ch case   27:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820D2D0Ch case   27:*/		return 0x820D2D10;
		  /* 820D2D10h */ case   28:  		/* add R22, R11, R22 */
		/* 820D2D10h case   28:*/		cpu::op::add<0>(regs,&regs.R22,regs.R11,regs.R22);
		/* 820D2D10h case   28:*/		return 0x820D2D14;
		  /* 820D2D14h */ case   29:  		/* bc 16, CR0_LT, -20 */
		/* 820D2D14h case   29:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D2D00;  }
		/* 820D2D14h case   29:*/		return 0x820D2D18;
	}
	return 0x820D2D18;
} // Block from 820D2CA0h-820D2D18h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820D2D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2D18);
		  /* 820D2D18h */ case    0:  		/* li R5, 4 */
		/* 820D2D18h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D2D18h case    0:*/		return 0x820D2D1C;
		  /* 820D2D1Ch */ case    1:  		/* lwz R3, <#[R23 + 4]> */
		/* 820D2D1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 820D2D1Ch case    1:*/		return 0x820D2D20;
		  /* 820D2D20h */ case    2:  		/* mr R4, R22 */
		/* 820D2D20h case    2:*/		regs.R4 = regs.R22;
		/* 820D2D20h case    2:*/		return 0x820D2D24;
		  /* 820D2D24h */ case    3:  		/* bl -40004 */
		/* 820D2D24h case    3:*/		regs.LR = 0x820D2D28; return 0x820C90E0;
		/* 820D2D24h case    3:*/		return 0x820D2D28;
		  /* 820D2D28h */ case    4:  		/* rlwinm R27, R31, 7, 0, 24 */
		/* 820D2D28h case    4:*/		cpu::op::rlwinm<0,7,0,24>(regs,&regs.R27,regs.R31);
		/* 820D2D28h case    4:*/		return 0x820D2D2C;
		  /* 820D2D2Ch */ case    5:  		/* li R5, 16 */
		/* 820D2D2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820D2D2Ch case    5:*/		return 0x820D2D30;
		  /* 820D2D30h */ case    6:  		/* mr R4, R27 */
		/* 820D2D30h case    6:*/		regs.R4 = regs.R27;
		/* 820D2D30h case    6:*/		return 0x820D2D34;
		  /* 820D2D34h */ case    7:  		/* mr R15, R3 */
		/* 820D2D34h case    7:*/		regs.R15 = regs.R3;
		/* 820D2D34h case    7:*/		return 0x820D2D38;
		  /* 820D2D38h */ case    8:  		/* lwz R3, <#[R23 + 4]> */
		/* 820D2D38h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 820D2D38h case    8:*/		return 0x820D2D3C;
		  /* 820D2D3Ch */ case    9:  		/* mr R20, R24 */
		/* 820D2D3Ch case    9:*/		regs.R20 = regs.R24;
		/* 820D2D3Ch case    9:*/		return 0x820D2D40;
		  /* 820D2D40h */ case   10:  		/* bl -40032 */
		/* 820D2D40h case   10:*/		regs.LR = 0x820D2D44; return 0x820C90E0;
		/* 820D2D40h case   10:*/		return 0x820D2D44;
		  /* 820D2D44h */ case   11:  		/* stw R24, <#[R1 + 120]> */
		/* 820D2D44h case   11:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000078) );
		/* 820D2D44h case   11:*/		return 0x820D2D48;
		  /* 820D2D48h */ case   12:  		/* mr R17, R3 */
		/* 820D2D48h case   12:*/		regs.R17 = regs.R3;
		/* 820D2D48h case   12:*/		return 0x820D2D4C;
		  /* 820D2D4Ch */ case   13:  		/* cmplwi CR6, R30, 0 */
		/* 820D2D4Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820D2D4Ch case   13:*/		return 0x820D2D50;
		  /* 820D2D50h */ case   14:  		/* bc 12, CR6_EQ, 188 */
		/* 820D2D50h case   14:*/		if ( regs.CR[6].eq ) { return 0x820D2E0C;  }
		/* 820D2D50h case   14:*/		return 0x820D2D54;
		  /* 820D2D54h */ case   15:  		/* addi R28, R1, 364 */
		/* 820D2D54h case   15:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x16C);
		/* 820D2D54h case   15:*/		return 0x820D2D58;
		  /* 820D2D58h */ case   16:  		/* addi R31, R21, -8 */
		/* 820D2D58h case   16:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R21,0xFFFFFFF8);
		/* 820D2D58h case   16:*/		return 0x820D2D5C;
		  /* 820D2D5Ch */ case   17:  		/* mr R26, R30 */
		/* 820D2D5Ch case   17:*/		regs.R26 = regs.R30;
		/* 820D2D5Ch case   17:*/		return 0x820D2D60;
		  /* 820D2D60h */ case   18:  		/* mr R29, R30 */
		/* 820D2D60h case   18:*/		regs.R29 = regs.R30;
		/* 820D2D60h case   18:*/		return 0x820D2D64;
		  /* 820D2D64h */ case   19:  		/* lwz R30, <#[R28]> */
		/* 820D2D64h case   19:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 820D2D64h case   19:*/		return 0x820D2D68;
		  /* 820D2D68h */ case   20:  		/* addi R6, R1, 120 */
		/* 820D2D68h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x78);
		/* 820D2D68h case   20:*/		return 0x820D2D6C;
		  /* 820D2D6Ch */ case   21:  		/* mr R5, R27 */
		/* 820D2D6Ch case   21:*/		regs.R5 = regs.R27;
		/* 820D2D6Ch case   21:*/		return 0x820D2D70;
		  /* 820D2D70h */ case   22:  		/* mr R4, R17 */
		/* 820D2D70h case   22:*/		regs.R4 = regs.R17;
		/* 820D2D70h case   22:*/		return 0x820D2D74;
		  /* 820D2D74h */ case   23:  		/* lwz R3, <#[R30]> */
		/* 820D2D74h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820D2D74h case   23:*/		return 0x820D2D78;
		  /* 820D2D78h */ case   24:  		/* bl -11096 */
		/* 820D2D78h case   24:*/		regs.LR = 0x820D2D7C; return 0x820D0220;
		/* 820D2D78h case   24:*/		return 0x820D2D7C;
		  /* 820D2D7Ch */ case   25:  		/* stw R3, <#[R31 + 8]> */
		/* 820D2D7Ch case   25:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820D2D7Ch case   25:*/		return 0x820D2D80;
		  /* 820D2D80h */ case   26:  		/* lwz R11, <#[R30 + 4]> */
		/* 820D2D80h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820D2D80h case   26:*/		return 0x820D2D84;
		  /* 820D2D84h */ case   27:  		/* sth R11, <#[R31 + 12]> */
		/* 820D2D84h case   27:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D2D84h case   27:*/		return 0x820D2D88;
		  /* 820D2D88h */ case   28:  		/* lwz R11, <#[R30 + 8]> */
		/* 820D2D88h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820D2D88h case   28:*/		return 0x820D2D8C;
		  /* 820D2D8Ch */ case   29:  		/* sth R11, <#[R31 + 14]> */
		/* 820D2D8Ch case   29:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x0000000E) );
		/* 820D2D8Ch case   29:*/		return 0x820D2D90;
		  /* 820D2D90h */ case   30:  		/* lwz R11, <#[R30 + 12]> */
		/* 820D2D90h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820D2D90h case   30:*/		return 0x820D2D94;
		  /* 820D2D94h */ case   31:  		/* sth R11, <#[R31 + 16]> */
		/* 820D2D94h case   31:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820D2D94h case   31:*/		return 0x820D2D98;
		  /* 820D2D98h */ case   32:  		/* sth R24, <#[R31 + 18]> */
		/* 820D2D98h case   32:*/		cpu::mem::store16( regs, regs.R24, (uint32)(regs.R31 + 0x00000012) );
		/* 820D2D98h case   32:*/		return 0x820D2D9C;
		  /* 820D2D9Ch */ case   33:  		/* lwz R11, <#[R30 + 44]> */
		/* 820D2D9Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820D2D9Ch case   33:*/		return 0x820D2DA0;
		  /* 820D2DA0h */ case   34:  		/* cmplwi CR6, R11, 0 */
		/* 820D2DA0h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D2DA0h case   34:*/		return 0x820D2DA4;
		  /* 820D2DA4h */ case   35:  		/* bc 12, CR6_EQ, 44 */
		/* 820D2DA4h case   35:*/		if ( regs.CR[6].eq ) { return 0x820D2DD0;  }
		/* 820D2DA4h case   35:*/		return 0x820D2DA8;
		  /* 820D2DA8h */ case   36:  		/* stw R20, <#[R31 + 24]> */
		/* 820D2DA8h case   36:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R31 + 0x00000018) );
		/* 820D2DA8h case   36:*/		return 0x820D2DAC;
		  /* 820D2DACh */ case   37:  		/* add R3, R20, R15 */
		/* 820D2DACh case   37:*/		cpu::op::add<0>(regs,&regs.R3,regs.R20,regs.R15);
		/* 820D2DACh case   37:*/		return 0x820D2DB0;
		  /* 820D2DB0h */ case   38:  		/* lwz R4, <#[R30 + 44]> */
		/* 820D2DB0h case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000002C) );
		/* 820D2DB0h case   38:*/		return 0x820D2DB4;
		  /* 820D2DB4h */ case   39:  		/* lwz R11, <#[R30 + 40]> */
		/* 820D2DB4h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820D2DB4h case   39:*/		return 0x820D2DB8;
		  /* 820D2DB8h */ case   40:  		/* lwz R10, <#[R30 + 32]> */
		/* 820D2DB8h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000020) );
		/* 820D2DB8h case   40:*/		return 0x820D2DBC;
		  /* 820D2DBCh */ case   41:  		/* mullw R25, R11, R10 */
		/* 820D2DBCh case   41:*/		cpu::op::mullw<0>(regs,&regs.R25,regs.R11,regs.R10);
		/* 820D2DBCh case   41:*/		return 0x820D2DC0;
		  /* 820D2DC0h */ case   42:  		/* mr R5, R25 */
		/* 820D2DC0h case   42:*/		regs.R5 = regs.R25;
		/* 820D2DC0h case   42:*/		return 0x820D2DC4;
		  /* 820D2DC4h */ case   43:  		/* bl -267284 */
		/* 820D2DC4h case   43:*/		regs.LR = 0x820D2DC8; return 0x820919B0;
		/* 820D2DC4h case   43:*/		return 0x820D2DC8;
		  /* 820D2DC8h */ case   44:  		/* add R20, R25, R20 */
		/* 820D2DC8h case   44:*/		cpu::op::add<0>(regs,&regs.R20,regs.R25,regs.R20);
		/* 820D2DC8h case   44:*/		return 0x820D2DCC;
		  /* 820D2DCCh */ case   45:  		/* b 12 */
		/* 820D2DCCh case   45:*/		return 0x820D2DD8;
		/* 820D2DCCh case   45:*/		return 0x820D2DD0;
	}
	return 0x820D2DD0;
} // Block from 820D2D18h-820D2DD0h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820D2DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2DD0);
		  /* 820D2DD0h */ case    0:  		/* li R11, -1 */
		/* 820D2DD0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D2DD0h case    0:*/		return 0x820D2DD4;
		  /* 820D2DD4h */ case    1:  		/* stw R11, <#[R31 + 24]> */
		/* 820D2DD4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820D2DD4h case    1:*/		return 0x820D2DD8;
	}
	return 0x820D2DD8;
} // Block from 820D2DD0h-820D2DD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D2DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2DD8);
		  /* 820D2DD8h */ case    0:  		/* addi R10, R1, 120 */
		/* 820D2DD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x78);
		/* 820D2DD8h case    0:*/		return 0x820D2DDC;
		  /* 820D2DDCh */ case    1:  		/* mr R9, R27 */
		/* 820D2DDCh case    1:*/		regs.R9 = regs.R27;
		/* 820D2DDCh case    1:*/		return 0x820D2DE0;
		  /* 820D2DE0h */ case    2:  		/* mr R8, R17 */
		/* 820D2DE0h case    2:*/		regs.R8 = regs.R17;
		/* 820D2DE0h case    2:*/		return 0x820D2DE4;
		  /* 820D2DE4h */ case    3:  		/* addi R7, R1, 116 */
		/* 820D2DE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 820D2DE4h case    3:*/		return 0x820D2DE8;
		  /* 820D2DE8h */ case    4:  		/* mr R6, R16 */
		/* 820D2DE8h case    4:*/		regs.R6 = regs.R16;
		/* 820D2DE8h case    4:*/		return 0x820D2DEC;
		  /* 820D2DECh */ case    5:  		/* addi R5, R1, 112 */
		/* 820D2DECh case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820D2DECh case    5:*/		return 0x820D2DF0;
		  /* 820D2DF0h */ case    6:  		/* mr R4, R18 */
		/* 820D2DF0h case    6:*/		regs.R4 = regs.R18;
		/* 820D2DF0h case    6:*/		return 0x820D2DF4;
		  /* 820D2DF4h */ case    7:  		/* mr R3, R30 */
		/* 820D2DF4h case    7:*/		regs.R3 = regs.R30;
		/* 820D2DF4h case    7:*/		return 0x820D2DF8;
		  /* 820D2DF8h */ case    8:  		/* bl -9888 */
		/* 820D2DF8h case    8:*/		regs.LR = 0x820D2DFC; return 0x820D0758;
		/* 820D2DF8h case    8:*/		return 0x820D2DFC;
		  /* 820D2DFCh */ case    9:  		/* addic. R26, R26, -1 */
		/* 820D2DFCh case    9:*/		cpu::op::addic<1>(regs,&regs.R26,regs.R26,0xFFFFFFFF);
		/* 820D2DFCh case    9:*/		return 0x820D2E00;
		  /* 820D2E00h */ case   10:  		/* stwu R3, <#[R31 + 20]> */
		/* 820D2E00h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		regs.R31 = (uint32)(regs.R31 + 0x00000014);
		/* 820D2E00h case   10:*/		return 0x820D2E04;
		  /* 820D2E04h */ case   11:  		/* addi R28, R28, 4 */
		/* 820D2E04h case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820D2E04h case   11:*/		return 0x820D2E08;
		  /* 820D2E08h */ case   12:  		/* bc 4, CR0_EQ, -164 */
		/* 820D2E08h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820D2D64;  }
		/* 820D2E08h case   12:*/		return 0x820D2E0C;
	}
	return 0x820D2E0C;
} // Block from 820D2DD8h-820D2E0Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D2E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2E0C);
		  /* 820D2E0Ch */ case    0:  		/* cmplw CR6, R20, R22 */
		/* 820D2E0Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R22);
		/* 820D2E0Ch case    0:*/		return 0x820D2E10;
		  /* 820D2E10h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820D2E10h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D2E20;  }
		/* 820D2E10h case    1:*/		return 0x820D2E14;
		  /* 820D2E14h */ case    2:  		/* lis R11, -32255 */
		/* 820D2E14h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2E14h case    2:*/		return 0x820D2E18;
		  /* 820D2E18h */ case    3:  		/* addi R5, R11, 24888 */
		/* 820D2E18h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6138);
		/* 820D2E18h case    3:*/		return 0x820D2E1C;
		  /* 820D2E1Ch */ case    4:  		/* b -608 */
		/* 820D2E1Ch case    4:*/		return 0x820D2BBC;
		/* 820D2E1Ch case    4:*/		return 0x820D2E20;
	}
	return 0x820D2E20;
} // Block from 820D2E0Ch-820D2E20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D2E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2E20);
		  /* 820D2E20h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D2E20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2E20h case    0:*/		return 0x820D2E24;
		  /* 820D2E24h */ case    1:  		/* cmplw CR6, R11, R19 */
		/* 820D2E24h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 820D2E24h case    1:*/		return 0x820D2E28;
		  /* 820D2E28h */ case    2:  		/* bc 4, CR6_GT, 16 */
		/* 820D2E28h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820D2E38;  }
		/* 820D2E28h case    2:*/		return 0x820D2E2C;
		  /* 820D2E2Ch */ case    3:  		/* lis R11, -32255 */
		/* 820D2E2Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2E2Ch case    3:*/		return 0x820D2E30;
		  /* 820D2E30h */ case    4:  		/* addi R5, R11, 24836 */
		/* 820D2E30h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6104);
		/* 820D2E30h case    4:*/		return 0x820D2E34;
		  /* 820D2E34h */ case    5:  		/* b -632 */
		/* 820D2E34h case    5:*/		return 0x820D2BBC;
		/* 820D2E34h case    5:*/		return 0x820D2E38;
	}
	return 0x820D2E38;
} // Block from 820D2E20h-820D2E38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D2E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2E38);
		  /* 820D2E38h */ case    0:  		/* mulli R30, R29, 20 */
		/* 820D2E38h case    0:*/		cpu::op::mulli<0>(regs,&regs.R30,regs.R29,0x14);
		/* 820D2E38h case    0:*/		return 0x820D2E3C;
		  /* 820D2E3Ch */ case    1:  		/* lwz R10, <#[R1 + 116]> */
		/* 820D2E3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820D2E3Ch case    1:*/		return 0x820D2E40;
		  /* 820D2E40h */ case    2:  		/* lwz R9, <#[R1 + 120]> */
		/* 820D2E40h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000078) );
		/* 820D2E40h case    2:*/		return 0x820D2E44;
		  /* 820D2E44h */ case    3:  		/* lwz R3, <#[R23 + 4]> */
		/* 820D2E44h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 820D2E44h case    3:*/		return 0x820D2E48;
		  /* 820D2E48h */ case    4:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 820D2E48h case    4:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 820D2E48h case    4:*/		return 0x820D2E4C;
		  /* 820D2E4Ch */ case    5:  		/* addi R28, R30, 28 */
		/* 820D2E4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x1C);
		/* 820D2E4Ch case    5:*/		return 0x820D2E50;
		  /* 820D2E50h */ case    6:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 820D2E50h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 820D2E50h case    6:*/		return 0x820D2E54;
		  /* 820D2E54h */ case    7:  		/* add R26, R11, R28 */
		/* 820D2E54h case    7:*/		cpu::op::add<0>(regs,&regs.R26,regs.R11,regs.R28);
		/* 820D2E54h case    7:*/		return 0x820D2E58;
		  /* 820D2E58h */ case    8:  		/* li R5, 4 */
		/* 820D2E58h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820D2E58h case    8:*/		return 0x820D2E5C;
		  /* 820D2E5Ch */ case    9:  		/* add R25, R10, R26 */
		/* 820D2E5Ch case    9:*/		cpu::op::add<0>(regs,&regs.R25,regs.R10,regs.R26);
		/* 820D2E5Ch case    9:*/		return 0x820D2E60;
		  /* 820D2E60h */ case   10:  		/* add R27, R25, R20 */
		/* 820D2E60h case   10:*/		cpu::op::add<0>(regs,&regs.R27,regs.R25,regs.R20);
		/* 820D2E60h case   10:*/		return 0x820D2E64;
		  /* 820D2E64h */ case   11:  		/* add R22, R27, R9 */
		/* 820D2E64h case   11:*/		cpu::op::add<0>(regs,&regs.R22,regs.R27,regs.R9);
		/* 820D2E64h case   11:*/		return 0x820D2E68;
		  /* 820D2E68h */ case   12:  		/* mr R4, R22 */
		/* 820D2E68h case   12:*/		regs.R4 = regs.R22;
		/* 820D2E68h case   12:*/		return 0x820D2E6C;
		  /* 820D2E6Ch */ case   13:  		/* bl -40332 */
		/* 820D2E6Ch case   13:*/		regs.LR = 0x820D2E70; return 0x820C90E0;
		/* 820D2E6Ch case   13:*/		return 0x820D2E70;
		  /* 820D2E70h */ case   14:  		/* li R11, 28 */
		/* 820D2E70h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1C);
		/* 820D2E70h case   14:*/		return 0x820D2E74;
		  /* 820D2E74h */ case   15:  		/* stw R29, <#[R3 + 12]> */
		/* 820D2E74h case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x0000000C) );
		/* 820D2E74h case   15:*/		return 0x820D2E78;
		  /* 820D2E78h */ case   16:  		/* mr R5, R30 */
		/* 820D2E78h case   16:*/		regs.R5 = regs.R30;
		/* 820D2E78h case   16:*/		return 0x820D2E7C;
		  /* 820D2E7Ch */ case   17:  		/* stw R11, <#[R3]> */
		/* 820D2E7Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820D2E7Ch case   17:*/		return 0x820D2E80;
		  /* 820D2E80h */ case   18:  		/* addi R30, R3, 28 */
		/* 820D2E80h case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x1C);
		/* 820D2E80h case   18:*/		return 0x820D2E84;
		  /* 820D2E84h */ case   19:  		/* stw R11, <#[R3 + 16]> */
		/* 820D2E84h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820D2E84h case   19:*/		return 0x820D2E88;
		  /* 820D2E88h */ case   20:  		/* mr R31, R3 */
		/* 820D2E88h case   20:*/		regs.R31 = regs.R3;
		/* 820D2E88h case   20:*/		return 0x820D2E8C;
		  /* 820D2E8Ch */ case   21:  		/* stw R24, <#[R3 + 4]> */
		/* 820D2E8Ch case   21:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000004) );
		/* 820D2E8Ch case   21:*/		return 0x820D2E90;
		  /* 820D2E90h */ case   22:  		/* mr R4, R21 */
		/* 820D2E90h case   22:*/		regs.R4 = regs.R21;
		/* 820D2E90h case   22:*/		return 0x820D2E94;
		  /* 820D2E94h */ case   23:  		/* stw R24, <#[R3 + 20]> */
		/* 820D2E94h case   23:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000014) );
		/* 820D2E94h case   23:*/		return 0x820D2E98;
		  /* 820D2E98h */ case   24:  		/* stw R24, <#[R3 + 8]> */
		/* 820D2E98h case   24:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000008) );
		/* 820D2E98h case   24:*/		return 0x820D2E9C;
		  /* 820D2E9Ch */ case   25:  		/* stw R24, <#[R3 + 24]> */
		/* 820D2E9Ch case   25:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000018) );
		/* 820D2E9Ch case   25:*/		return 0x820D2EA0;
		  /* 820D2EA0h */ case   26:  		/* mr R3, R30 */
		/* 820D2EA0h case   26:*/		regs.R3 = regs.R30;
		/* 820D2EA0h case   26:*/		return 0x820D2EA4;
		  /* 820D2EA4h */ case   27:  		/* bl -267508 */
		/* 820D2EA4h case   27:*/		regs.LR = 0x820D2EA8; return 0x820919B0;
		/* 820D2EA4h case   27:*/		return 0x820D2EA8;
		  /* 820D2EA8h */ case   28:  		/* cmplwi CR6, R29, 0 */
		/* 820D2EA8h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820D2EA8h case   28:*/		return 0x820D2EAC;
		  /* 820D2EACh */ case   29:  		/* bc 12, CR6_EQ, 68 */
		/* 820D2EACh case   29:*/		if ( regs.CR[6].eq ) { return 0x820D2EF0;  }
		/* 820D2EACh case   29:*/		return 0x820D2EB0;
		  /* 820D2EB0h */ case   30:  		/* addi R11, R30, -20 */
		/* 820D2EB0h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFEC);
		/* 820D2EB0h case   30:*/		return 0x820D2EB4;
		  /* 820D2EB4h */ case   31:  		/* mtspr CTR, R29 */
		/* 820D2EB4h case   31:*/		regs.CTR = regs.R29;
		/* 820D2EB4h case   31:*/		return 0x820D2EB8;
		  /* 820D2EB8h */ case   32:  		/* lwz R10, <#[R11 + 36]> */
		/* 820D2EB8h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 820D2EB8h case   32:*/		return 0x820D2EBC;
		  /* 820D2EBCh */ case   33:  		/* cmpwi CR6, R10, -1 */
		/* 820D2EBCh case   33:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820D2EBCh case   33:*/		return 0x820D2EC0;
		  /* 820D2EC0h */ case   34:  		/* bc 12, CR6_EQ, 16 */
		/* 820D2EC0h case   34:*/		if ( regs.CR[6].eq ) { return 0x820D2ED0;  }
		/* 820D2EC0h case   34:*/		return 0x820D2EC4;
		  /* 820D2EC4h */ case   35:  		/* add R10, R10, R25 */
		/* 820D2EC4h case   35:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R25);
		/* 820D2EC4h case   35:*/		return 0x820D2EC8;
		  /* 820D2EC8h */ case   36:  		/* stw R10, <#[R11 + 36]> */
		/* 820D2EC8h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 820D2EC8h case   36:*/		return 0x820D2ECC;
		  /* 820D2ECCh */ case   37:  		/* b 8 */
		/* 820D2ECCh case   37:*/		return 0x820D2ED4;
		/* 820D2ECCh case   37:*/		return 0x820D2ED0;
	}
	return 0x820D2ED0;
} // Block from 820D2E38h-820D2ED0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820D2ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2ED0);
		  /* 820D2ED0h */ case    0:  		/* stw R24, <#[R11 + 36]> */
		/* 820D2ED0h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000024) );
		/* 820D2ED0h case    0:*/		return 0x820D2ED4;
	}
	return 0x820D2ED4;
} // Block from 820D2ED0h-820D2ED4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D2ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2ED4);
		  /* 820D2ED4h */ case    0:  		/* lwz R10, <#[R11 + 32]> */
		/* 820D2ED4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 820D2ED4h case    0:*/		return 0x820D2ED8;
		  /* 820D2ED8h */ case    1:  		/* lwz R9, <#[R11 + 20]> */
		/* 820D2ED8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820D2ED8h case    1:*/		return 0x820D2EDC;
		  /* 820D2EDCh */ case    2:  		/* add R10, R10, R28 */
		/* 820D2EDCh case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 820D2EDCh case    2:*/		return 0x820D2EE0;
		  /* 820D2EE0h */ case    3:  		/* add R9, R9, R27 */
		/* 820D2EE0h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R27);
		/* 820D2EE0h case    3:*/		return 0x820D2EE4;
		  /* 820D2EE4h */ case    4:  		/* stw R10, <#[R11 + 32]> */
		/* 820D2EE4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 820D2EE4h case    4:*/		return 0x820D2EE8;
		  /* 820D2EE8h */ case    5:  		/* stwu R9, <#[R11 + 20]> */
		/* 820D2EE8h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		regs.R11 = (uint32)(regs.R11 + 0x00000014);
		/* 820D2EE8h case    5:*/		return 0x820D2EEC;
		  /* 820D2EECh */ case    6:  		/* bc 16, CR0_LT, -52 */
		/* 820D2EECh case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D2EB8;  }
		/* 820D2EECh case    6:*/		return 0x820D2EF0;
	}
	return 0x820D2EF0;
} // Block from 820D2ED4h-820D2EF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D2EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2EF0);
		  /* 820D2EF0h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D2EF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2EF0h case    0:*/		return 0x820D2EF4;
		  /* 820D2EF4h */ case    1:  		/* add R30, R31, R28 */
		/* 820D2EF4h case    1:*/		cpu::op::add<0>(regs,&regs.R30,regs.R31,regs.R28);
		/* 820D2EF4h case    1:*/		return 0x820D2EF8;
		  /* 820D2EF8h */ case    2:  		/* mr R4, R18 */
		/* 820D2EF8h case    2:*/		regs.R4 = regs.R18;
		/* 820D2EF8h case    2:*/		return 0x820D2EFC;
		  /* 820D2EFCh */ case    3:  		/* rlwinm R5, R11, 4, 0, 27 */
		/* 820D2EFCh case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R11);
		/* 820D2EFCh case    3:*/		return 0x820D2F00;
		  /* 820D2F00h */ case    4:  		/* mr R3, R30 */
		/* 820D2F00h case    4:*/		regs.R3 = regs.R30;
		/* 820D2F00h case    4:*/		return 0x820D2F04;
		  /* 820D2F04h */ case    5:  		/* bl -267604 */
		/* 820D2F04h case    5:*/		regs.LR = 0x820D2F08; return 0x820919B0;
		/* 820D2F04h case    5:*/		return 0x820D2F08;
		  /* 820D2F08h */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D2F08h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2F08h case    6:*/		return 0x820D2F0C;
		  /* 820D2F0Ch */ case    7:  		/* mr R9, R24 */
		/* 820D2F0Ch case    7:*/		regs.R9 = regs.R24;
		/* 820D2F0Ch case    7:*/		return 0x820D2F10;
		  /* 820D2F10h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820D2F10h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D2F10h case    8:*/		return 0x820D2F14;
		  /* 820D2F14h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 820D2F14h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D2F48;  }
		/* 820D2F14h case    9:*/		return 0x820D2F18;
		  /* 820D2F18h */ case   10:  		/* addi R11, R30, 12 */
		/* 820D2F18h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xC);
		/* 820D2F18h case   10:*/		return 0x820D2F1C;
		  /* 820D2F1Ch */ case   11:  		/* lhz R10, <#[R11 - 2]> */
		/* 820D2F1Ch case   11:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFFE) );
		/* 820D2F1Ch case   11:*/		return 0x820D2F20;
		  /* 820D2F20h */ case   12:  		/* cmplwi CR0, R10, 0 */
		/* 820D2F20h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820D2F20h case   12:*/		return 0x820D2F24;
		  /* 820D2F24h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 820D2F24h case   13:*/		if ( regs.CR[0].eq ) { return 0x820D2F34;  }
		/* 820D2F24h case   13:*/		return 0x820D2F28;
		  /* 820D2F28h */ case   14:  		/* lwz R10, <#[R11]> */
		/* 820D2F28h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D2F28h case   14:*/		return 0x820D2F2C;
		  /* 820D2F2Ch */ case   15:  		/* add R10, R10, R26 */
		/* 820D2F2Ch case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 820D2F2Ch case   15:*/		return 0x820D2F30;
		  /* 820D2F30h */ case   16:  		/* stw R10, <#[R11]> */
		/* 820D2F30h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D2F30h case   16:*/		return 0x820D2F34;
	}
	return 0x820D2F34;
} // Block from 820D2EF0h-820D2F34h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820D2F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2F34);
		  /* 820D2F34h */ case    0:  		/* lwz R10, <#[R1 + 112]> */
		/* 820D2F34h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820D2F34h case    0:*/		return 0x820D2F38;
		  /* 820D2F38h */ case    1:  		/* addi R9, R9, 1 */
		/* 820D2F38h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820D2F38h case    1:*/		return 0x820D2F3C;
		  /* 820D2F3Ch */ case    2:  		/* addi R11, R11, 16 */
		/* 820D2F3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820D2F3Ch case    2:*/		return 0x820D2F40;
		  /* 820D2F40h */ case    3:  		/* cmplw CR6, R9, R10 */
		/* 820D2F40h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820D2F40h case    3:*/		return 0x820D2F44;
		  /* 820D2F44h */ case    4:  		/* bc 12, CR6_LT, -40 */
		/* 820D2F44h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D2F1C;  }
		/* 820D2F44h case    4:*/		return 0x820D2F48;
	}
	return 0x820D2F48;
} // Block from 820D2F34h-820D2F48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D2F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2F48);
		  /* 820D2F48h */ case    0:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D2F48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D2F48h case    0:*/		return 0x820D2F4C;
		  /* 820D2F4Ch */ case    1:  		/* add R30, R31, R26 */
		/* 820D2F4Ch case    1:*/		cpu::op::add<0>(regs,&regs.R30,regs.R31,regs.R26);
		/* 820D2F4Ch case    1:*/		return 0x820D2F50;
		  /* 820D2F50h */ case    2:  		/* mr R4, R16 */
		/* 820D2F50h case    2:*/		regs.R4 = regs.R16;
		/* 820D2F50h case    2:*/		return 0x820D2F54;
		  /* 820D2F54h */ case    3:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 820D2F54h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 820D2F54h case    3:*/		return 0x820D2F58;
		  /* 820D2F58h */ case    4:  		/* mr R3, R30 */
		/* 820D2F58h case    4:*/		regs.R3 = regs.R30;
		/* 820D2F58h case    4:*/		return 0x820D2F5C;
		  /* 820D2F5Ch */ case    5:  		/* bl -267692 */
		/* 820D2F5Ch case    5:*/		regs.LR = 0x820D2F60; return 0x820919B0;
		/* 820D2F5Ch case    5:*/		return 0x820D2F60;
		  /* 820D2F60h */ case    6:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D2F60h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D2F60h case    6:*/		return 0x820D2F64;
		  /* 820D2F64h */ case    7:  		/* mr R10, R24 */
		/* 820D2F64h case    7:*/		regs.R10 = regs.R24;
		/* 820D2F64h case    7:*/		return 0x820D2F68;
		  /* 820D2F68h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820D2F68h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D2F68h case    8:*/		return 0x820D2F6C;
		  /* 820D2F6Ch */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 820D2F6Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820D2F9C;  }
		/* 820D2F6Ch case    9:*/		return 0x820D2F70;
		  /* 820D2F70h */ case   10:  		/* addi R11, R30, -4 */
		/* 820D2F70h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFC);
		/* 820D2F70h case   10:*/		return 0x820D2F74;
		  /* 820D2F74h */ case   11:  		/* lwz R9, <#[R11 + 4]> */
		/* 820D2F74h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820D2F74h case   11:*/		return 0x820D2F78;
		  /* 820D2F78h */ case   12:  		/* addi R10, R10, 1 */
		/* 820D2F78h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D2F78h case   12:*/		return 0x820D2F7C;
		  /* 820D2F7Ch */ case   13:  		/* lwz R8, <#[R11 + 8]> */
		/* 820D2F7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 820D2F7Ch case   13:*/		return 0x820D2F80;
		  /* 820D2F80h */ case   14:  		/* add R9, R9, R27 */
		/* 820D2F80h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R27);
		/* 820D2F80h case   14:*/		return 0x820D2F84;
		  /* 820D2F84h */ case   15:  		/* add R8, R8, R28 */
		/* 820D2F84h case   15:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R28);
		/* 820D2F84h case   15:*/		return 0x820D2F88;
		  /* 820D2F88h */ case   16:  		/* stw R9, <#[R11 + 4]> */
		/* 820D2F88h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820D2F88h case   16:*/		return 0x820D2F8C;
		  /* 820D2F8Ch */ case   17:  		/* stwu R8, <#[R11 + 8]> */
		/* 820D2F8Ch case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 820D2F8Ch case   17:*/		return 0x820D2F90;
		  /* 820D2F90h */ case   18:  		/* lwz R9, <#[R1 + 116]> */
		/* 820D2F90h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000074) );
		/* 820D2F90h case   18:*/		return 0x820D2F94;
		  /* 820D2F94h */ case   19:  		/* cmplw CR6, R10, R9 */
		/* 820D2F94h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820D2F94h case   19:*/		return 0x820D2F98;
		  /* 820D2F98h */ case   20:  		/* bc 12, CR6_LT, -36 */
		/* 820D2F98h case   20:*/		if ( regs.CR[6].lt ) { return 0x820D2F74;  }
		/* 820D2F98h case   20:*/		return 0x820D2F9C;
	}
	return 0x820D2F9C;
} // Block from 820D2F48h-820D2F9Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820D2F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2F9C);
		  /* 820D2F9Ch */ case    0:  		/* mr R5, R20 */
		/* 820D2F9Ch case    0:*/		regs.R5 = regs.R20;
		/* 820D2F9Ch case    0:*/		return 0x820D2FA0;
		  /* 820D2FA0h */ case    1:  		/* mr R4, R15 */
		/* 820D2FA0h case    1:*/		regs.R4 = regs.R15;
		/* 820D2FA0h case    1:*/		return 0x820D2FA4;
		  /* 820D2FA4h */ case    2:  		/* add R3, R31, R25 */
		/* 820D2FA4h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R31,regs.R25);
		/* 820D2FA4h case    2:*/		return 0x820D2FA8;
		  /* 820D2FA8h */ case    3:  		/* bl -267768 */
		/* 820D2FA8h case    3:*/		regs.LR = 0x820D2FAC; return 0x820919B0;
		/* 820D2FA8h case    3:*/		return 0x820D2FAC;
		  /* 820D2FACh */ case    4:  		/* mr R4, R17 */
		/* 820D2FACh case    4:*/		regs.R4 = regs.R17;
		/* 820D2FACh case    4:*/		return 0x820D2FB0;
		  /* 820D2FB0h */ case    5:  		/* add R3, R31, R27 */
		/* 820D2FB0h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R31,regs.R27);
		/* 820D2FB0h case    5:*/		return 0x820D2FB4;
		  /* 820D2FB4h */ case    6:  		/* lwz R5, <#[R1 + 120]> */
		/* 820D2FB4h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000078) );
		/* 820D2FB4h case    6:*/		return 0x820D2FB8;
		  /* 820D2FB8h */ case    7:  		/* bl -267784 */
		/* 820D2FB8h case    7:*/		regs.LR = 0x820D2FBC; return 0x820919B0;
		/* 820D2FB8h case    7:*/		return 0x820D2FBC;
		  /* 820D2FBCh */ case    8:  		/* lis R4, 9345 */
		/* 820D2FBCh case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820D2FBCh case    8:*/		return 0x820D2FC0;
		  /* 820D2FC0h */ case    9:  		/* li R3, 32 */
		/* 820D2FC0h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x20);
		/* 820D2FC0h case    9:*/		return 0x820D2FC4;
		  /* 820D2FC4h */ case   10:  		/* bl -306628 */
		/* 820D2FC4h case   10:*/		regs.LR = 0x820D2FC8; return 0x82088200;
		/* 820D2FC4h case   10:*/		return 0x820D2FC8;
		  /* 820D2FC8h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820D2FC8h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820D2FC8h case   11:*/		return 0x820D2FCC;
		  /* 820D2FCCh */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820D2FCCh case   12:*/		if ( regs.CR[0].eq ) { return 0x820D2FDC;  }
		/* 820D2FCCh case   12:*/		return 0x820D2FD0;
		  /* 820D2FD0h */ case   13:  		/* bl -43608 */
		/* 820D2FD0h case   13:*/		regs.LR = 0x820D2FD4; return 0x820C8578;
		/* 820D2FD0h case   13:*/		return 0x820D2FD4;
		  /* 820D2FD4h */ case   14:  		/* mr R30, R3 */
		/* 820D2FD4h case   14:*/		regs.R30 = regs.R3;
		/* 820D2FD4h case   14:*/		return 0x820D2FD8;
		  /* 820D2FD8h */ case   15:  		/* b 8 */
		/* 820D2FD8h case   15:*/		return 0x820D2FE0;
		/* 820D2FD8h case   15:*/		return 0x820D2FDC;
	}
	return 0x820D2FDC;
} // Block from 820D2F9Ch-820D2FDCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D2FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2FDC);
		  /* 820D2FDCh */ case    0:  		/* mr R30, R24 */
		/* 820D2FDCh case    0:*/		regs.R30 = regs.R24;
		/* 820D2FDCh case    0:*/		return 0x820D2FE0;
	}
	return 0x820D2FE0;
} // Block from 820D2FDCh-820D2FE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D2FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D2FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D2FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D2FE0);
		  /* 820D2FE0h */ case    0:  		/* li R6, 0 */
		/* 820D2FE0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820D2FE0h case    0:*/		return 0x820D2FE4;
		  /* 820D2FE4h */ case    1:  		/* mr R5, R22 */
		/* 820D2FE4h case    1:*/		regs.R5 = regs.R22;
		/* 820D2FE4h case    1:*/		return 0x820D2FE8;
		  /* 820D2FE8h */ case    2:  		/* mr R4, R31 */
		/* 820D2FE8h case    2:*/		regs.R4 = regs.R31;
		/* 820D2FE8h case    2:*/		return 0x820D2FEC;
		  /* 820D2FECh */ case    3:  		/* mr R3, R30 */
		/* 820D2FECh case    3:*/		regs.R3 = regs.R30;
		/* 820D2FECh case    3:*/		return 0x820D2FF0;
		  /* 820D2FF0h */ case    4:  		/* bl -43592 */
		/* 820D2FF0h case    4:*/		regs.LR = 0x820D2FF4; return 0x820C85A8;
		/* 820D2FF0h case    4:*/		return 0x820D2FF4;
		  /* 820D2FF4h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820D2FF4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D2FF4h case    5:*/		return 0x820D2FF8;
		  /* 820D2FF8h */ case    6:  		/* bc 4, CR0_LT, 16 */
		/* 820D2FF8h case    6:*/		if ( !regs.CR[0].lt ) { return 0x820D3008;  }
		/* 820D2FF8h case    6:*/		return 0x820D2FFC;
		  /* 820D2FFCh */ case    7:  		/* lis R11, -32255 */
		/* 820D2FFCh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D2FFCh case    7:*/		return 0x820D3000;
		  /* 820D3000h */ case    8:  		/* addi R5, R11, 24796 */
		/* 820D3000h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x60DC);
		/* 820D3000h case    8:*/		return 0x820D3004;
		  /* 820D3004h */ case    9:  		/* b -1096 */
		/* 820D3004h case    9:*/		return 0x820D2BBC;
		/* 820D3004h case    9:*/		return 0x820D3008;
	}
	return 0x820D3008;
} // Block from 820D2FE0h-820D3008h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D3008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3008);
		  /* 820D3008h */ case    0:  		/* lwz R11, <#[R23 + 332]> */
		/* 820D3008h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000014C) );
		/* 820D3008h case    0:*/		return 0x820D300C;
		  /* 820D300Ch */ case    1:  		/* stw R30, <#[R23 + 136]> */
		/* 820D300Ch case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000088) );
		/* 820D300Ch case    1:*/		return 0x820D3010;
		  /* 820D3010h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820D3010h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D3010h case    2:*/		return 0x820D3014;
		  /* 820D3014h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820D3014h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D3028;  }
		/* 820D3014h case    3:*/		return 0x820D3018;
		  /* 820D3018h */ case    4:  		/* mr R5, R22 */
		/* 820D3018h case    4:*/		regs.R5 = regs.R22;
		/* 820D3018h case    4:*/		return 0x820D301C;
		  /* 820D301Ch */ case    5:  		/* lwz R3, <#[R23 + 324]> */
		/* 820D301Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000144) );
		/* 820D301Ch case    5:*/		return 0x820D3020;
		  /* 820D3020h */ case    6:  		/* mr R4, R31 */
		/* 820D3020h case    6:*/		regs.R4 = regs.R31;
		/* 820D3020h case    6:*/		return 0x820D3024;
		  /* 820D3024h */ case    7:  		/* bl 480596 */
		/* 820D3024h case    7:*/		regs.LR = 0x820D3028; return 0x82148578;
		/* 820D3024h case    7:*/		return 0x820D3028;
	}
	return 0x820D3028;
} // Block from 820D3008h-820D3028h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D3028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3028);
		  /* 820D3028h */ case    0:  		/* stw R24, <#[R23 + 132]> */
		/* 820D3028h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R23 + 0x00000084) );
		/* 820D3028h case    0:*/		return 0x820D302C;
		  /* 820D302Ch */ case    1:  		/* b -1116 */
		/* 820D302Ch case    1:*/		return 0x820D2BD0;
		/* 820D302Ch case    1:*/		return 0x820D3030;
	}
	return 0x820D3030;
} // Block from 820D3028h-820D3030h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3030);
		  /* 820D3030h */ case    0:  		/* mfspr R12, LR */
		/* 820D3030h case    0:*/		regs.R12 = regs.LR;
		/* 820D3030h case    0:*/		return 0x820D3034;
		  /* 820D3034h */ case    1:  		/* bl -269836 */
		/* 820D3034h case    1:*/		regs.LR = 0x820D3038; return 0x82091228;
		/* 820D3034h case    1:*/		return 0x820D3038;
		  /* 820D3038h */ case    2:  		/* stwu R1, <#[R1 - 592]> */
		/* 820D3038h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFDB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFDB0);
		/* 820D3038h case    2:*/		return 0x820D303C;
		  /* 820D303Ch */ case    3:  		/* lwz R25, <#[R4 + 8]> */
		/* 820D303Ch case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R4 + 0x00000008) );
		/* 820D303Ch case    3:*/		return 0x820D3040;
		  /* 820D3040h */ case    4:  		/* li R18, 0 */
		/* 820D3040h case    4:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 820D3040h case    4:*/		return 0x820D3044;
		  /* 820D3044h */ case    5:  		/* mr R17, R3 */
		/* 820D3044h case    5:*/		regs.R17 = regs.R3;
		/* 820D3044h case    5:*/		return 0x820D3048;
		  /* 820D3048h */ case    6:  		/* stw R18, <#[R1 + 112]> */
		/* 820D3048h case    6:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000070) );
		/* 820D3048h case    6:*/		return 0x820D304C;
		  /* 820D304Ch */ case    7:  		/* mr R21, R4 */
		/* 820D304Ch case    7:*/		regs.R21 = regs.R4;
		/* 820D304Ch case    7:*/		return 0x820D3050;
		  /* 820D3050h */ case    8:  		/* mr R19, R5 */
		/* 820D3050h case    8:*/		regs.R19 = regs.R5;
		/* 820D3050h case    8:*/		return 0x820D3054;
		  /* 820D3054h */ case    9:  		/* li R27, 1 */
		/* 820D3054h case    9:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820D3054h case    9:*/		return 0x820D3058;
		  /* 820D3058h */ case   10:  		/* lbz R11, <#[R25]> */
		/* 820D3058h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820D3058h case   10:*/		return 0x820D305C;
		  /* 820D305Ch */ case   11:  		/* mr R29, R18 */
		/* 820D305Ch case   11:*/		regs.R29 = regs.R18;
		/* 820D305Ch case   11:*/		return 0x820D3060;
		  /* 820D3060h */ case   12:  		/* mr R30, R18 */
		/* 820D3060h case   12:*/		regs.R30 = regs.R18;
		/* 820D3060h case   12:*/		return 0x820D3064;
		  /* 820D3064h */ case   13:  		/* mr R20, R18 */
		/* 820D3064h case   13:*/		regs.R20 = regs.R18;
		/* 820D3064h case   13:*/		return 0x820D3068;
		  /* 820D3068h */ case   14:  		/* mr R23, R18 */
		/* 820D3068h case   14:*/		regs.R23 = regs.R18;
		/* 820D3068h case   14:*/		return 0x820D306C;
		  /* 820D306Ch */ case   15:  		/* mr R24, R25 */
		/* 820D306Ch case   15:*/		regs.R24 = regs.R25;
		/* 820D306Ch case   15:*/		return 0x820D3070;
		  /* 820D3070h */ case   16:  		/* mr R28, R18 */
		/* 820D3070h case   16:*/		regs.R28 = regs.R18;
		/* 820D3070h case   16:*/		return 0x820D3074;
		  /* 820D3074h */ case   17:  		/* mr R26, R25 */
		/* 820D3074h case   17:*/		regs.R26 = regs.R25;
		/* 820D3074h case   17:*/		return 0x820D3078;
		  /* 820D3078h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 820D3078h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3078h case   18:*/		return 0x820D307C;
		  /* 820D307Ch */ case   19:  		/* bc 12, CR0_EQ, 1140 */
		/* 820D307Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x820D34F0;  }
		/* 820D307Ch case   19:*/		return 0x820D3080;
		  /* 820D3080h */ case   20:  		/* lis R11, -32255 */
		/* 820D3080h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3080h case   20:*/		return 0x820D3084;
		  /* 820D3084h */ case   21:  		/* lis R10, -32255 */
		/* 820D3084h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D3084h case   21:*/		return 0x820D3088;
		  /* 820D3088h */ case   22:  		/* addi R16, R11, -8328 */
		/* 820D3088h case   22:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R11,0xFFFFDF78);
		/* 820D3088h case   22:*/		return 0x820D308C;
		  /* 820D308Ch */ case   23:  		/* addi R22, R10, 21328 */
		/* 820D308Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R10,0x5350);
		/* 820D308Ch case   23:*/		return 0x820D3090;
		  /* 820D3090h */ case   24:  		/* lbz R11, <#[R26]> */
		/* 820D3090h case   24:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D3090h case   24:*/		return 0x820D3094;
		  /* 820D3094h */ case   25:  		/* b 16 */
		/* 820D3094h case   25:*/		return 0x820D30A4;
		/* 820D3094h case   25:*/		return 0x820D3098;
		  /* 820D3098h */ case   26:  		/* cmpwi CR6, R11, 95 */
		/* 820D3098h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 820D3098h case   26:*/		return 0x820D309C;
		  /* 820D309Ch */ case   27:  		/* bc 12, CR6_EQ, 16 */
		/* 820D309Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x820D30AC;  }
		/* 820D309Ch case   27:*/		return 0x820D30A0;
		  /* 820D30A0h */ case   28:  		/* lbzu R11, <#[R26 + 1]> */
		/* 820D30A0h case   28:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000001) );
		regs.R26 = (uint32)(regs.R26 + 0x00000001);
		/* 820D30A0h case   28:*/		return 0x820D30A4;
	}
	return 0x820D30A4;
} // Block from 820D3030h-820D30A4h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820D30A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D30A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D30A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D30A4);
		  /* 820D30A4h */ case    0:  		/* extsb. R11, R11 */
		/* 820D30A4h case    0:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 820D30A4h case    0:*/		return 0x820D30A8;
		  /* 820D30A8h */ case    1:  		/* bc 4, CR0_EQ, -16 */
		/* 820D30A8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3098;  }
		/* 820D30A8h case    1:*/		return 0x820D30AC;
	}
	return 0x820D30AC;
} // Block from 820D30A4h-820D30ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D30ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D30AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D30AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D30AC);
		  /* 820D30ACh */ case    0:  		/* subf R31, R24, R26 */
		/* 820D30ACh case    0:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R24,regs.R26);
		/* 820D30ACh case    0:*/		return 0x820D30B0;
		  /* 820D30B0h */ case    1:  		/* cmplwi CR6, R31, 15 */
		/* 820D30B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x0000000F);
		/* 820D30B0h case    1:*/		return 0x820D30B4;
		  /* 820D30B4h */ case    2:  		/* bc 4, CR6_GT, 68 */
		/* 820D30B4h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820D30F8;  }
		/* 820D30B4h case    2:*/		return 0x820D30B8;
		  /* 820D30B8h */ case    3:  		/* cmpwi CR6, R27, 0 */
		/* 820D30B8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820D30B8h case    3:*/		return 0x820D30BC;
		  /* 820D30BCh */ case    4:  		/* bc 4, CR6_EQ, 348 */
		/* 820D30BCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D3218;  }
		/* 820D30BCh case    4:*/		return 0x820D30C0;
		  /* 820D30C0h */ case    5:  		/* cmplwi CR6, R19, 0 */
		/* 820D30C0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820D30C0h case    5:*/		return 0x820D30C4;
		  /* 820D30C4h */ case    6:  		/* bc 12, CR6_EQ, 1144 */
		/* 820D30C4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D353C;  }
		/* 820D30C4h case    6:*/		return 0x820D30C8;
		  /* 820D30C8h */ case    7:  		/* lwz R11, <#[R19 + 40]> */
		/* 820D30C8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000028) );
		/* 820D30C8h case    7:*/		return 0x820D30CC;
		  /* 820D30CCh */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820D30CCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D30CCh case    8:*/		return 0x820D30D0;
		  /* 820D30D0h */ case    9:  		/* bc 4, CR6_EQ, 1108 */
		/* 820D30D0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820D3524;  }
		/* 820D30D0h case    9:*/		return 0x820D30D4;
		  /* 820D30D4h */ case   10:  		/* lis R11, -32255 */
		/* 820D30D4h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D30D4h case   10:*/		return 0x820D30D8;
		  /* 820D30D8h */ case   11:  		/* lwz R8, <#[R19 + 24]> */
		/* 820D30D8h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R19 + 0x00000018) );
		/* 820D30D8h case   11:*/		return 0x820D30DC;
		  /* 820D30DCh */ case   12:  		/* mr R7, R25 */
		/* 820D30DCh case   12:*/		regs.R7 = regs.R25;
		/* 820D30DCh case   12:*/		return 0x820D30E0;
		  /* 820D30E0h */ case   13:  		/* lwz R3, <#[R17]> */
		/* 820D30E0h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 820D30E0h case   13:*/		return 0x820D30E4;
		  /* 820D30E4h */ case   14:  		/* addi R6, R11, 3316 */
		/* 820D30E4h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xCF4);
		/* 820D30E4h case   14:*/		return 0x820D30E8;
		  /* 820D30E8h */ case   15:  		/* li R5, 2005 */
		/* 820D30E8h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820D30E8h case   15:*/		return 0x820D30EC;
		  /* 820D30ECh */ case   16:  		/* mr R4, R21 */
		/* 820D30ECh case   16:*/		regs.R4 = regs.R21;
		/* 820D30ECh case   16:*/		return 0x820D30F0;
		  /* 820D30F0h */ case   17:  		/* bl -180064 */
		/* 820D30F0h case   17:*/		regs.LR = 0x820D30F4; return 0x820A7190;
		/* 820D30F0h case   17:*/		return 0x820D30F4;
		  /* 820D30F4h */ case   18:  		/* b 1124 */
		/* 820D30F4h case   18:*/		return 0x820D3558;
		/* 820D30F4h case   18:*/		return 0x820D30F8;
	}
	return 0x820D30F8;
} // Block from 820D30ACh-820D30F8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D30F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D30F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D30F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D30F8);
		  /* 820D30F8h */ case    0:  		/* mr R5, R31 */
		/* 820D30F8h case    0:*/		regs.R5 = regs.R31;
		/* 820D30F8h case    0:*/		return 0x820D30FC;
		  /* 820D30FCh */ case    1:  		/* mr R4, R24 */
		/* 820D30FCh case    1:*/		regs.R4 = regs.R24;
		/* 820D30FCh case    1:*/		return 0x820D3100;
		  /* 820D3100h */ case    2:  		/* addi R3, R1, 128 */
		/* 820D3100h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 820D3100h case    2:*/		return 0x820D3104;
		  /* 820D3104h */ case    3:  		/* bl -268116 */
		/* 820D3104h case    3:*/		regs.LR = 0x820D3108; return 0x820919B0;
		/* 820D3104h case    3:*/		return 0x820D3108;
		  /* 820D3108h */ case    4:  		/* addi R11, R1, 128 */
		/* 820D3108h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820D3108h case    4:*/		return 0x820D310C;
		  /* 820D310Ch */ case    5:  		/* stbx R18, <#[R31 + R11]> */
		/* 820D310Ch case    5:*/		cpu::mem::store8( regs, regs.R18, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820D310Ch case    5:*/		return 0x820D3110;
		  /* 820D3110h */ case    6:  		/* lbz R11, <#[R26]> */
		/* 820D3110h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D3110h case    6:*/		return 0x820D3114;
		  /* 820D3114h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 820D3114h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3114h case    7:*/		return 0x820D3118;
		  /* 820D3118h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 820D3118h case    8:*/		if ( regs.CR[0].eq ) { return 0x820D3120;  }
		/* 820D3118h case    8:*/		return 0x820D311C;
		  /* 820D311Ch */ case    9:  		/* addi R26, R26, 1 */
		/* 820D311Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820D311Ch case    9:*/		return 0x820D3120;
	}
	return 0x820D3120;
} // Block from 820D30F8h-820D3120h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D3120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3120);
		  /* 820D3120h */ case    0:  		/* mr R24, R26 */
		/* 820D3120h case    0:*/		regs.R24 = regs.R26;
		/* 820D3120h case    0:*/		return 0x820D3124;
		  /* 820D3124h */ case    1:  		/* cmpwi CR6, R27, 0 */
		/* 820D3124h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820D3124h case    1:*/		return 0x820D3128;
		  /* 820D3128h */ case    2:  		/* bc 12, CR6_EQ, 888 */
		/* 820D3128h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D34A0;  }
		/* 820D3128h case    2:*/		return 0x820D312C;
		  /* 820D312Ch */ case    3:  		/* lbz R11, <#[R1 + 128]> */
		/* 820D312Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820D312Ch case    3:*/		return 0x820D3130;
		  /* 820D3130h */ case    4:  		/* addi R31, R1, 128 */
		/* 820D3130h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x80);
		/* 820D3130h case    4:*/		return 0x820D3134;
		  /* 820D3134h */ case    5:  		/* b 28 */
		/* 820D3134h case    5:*/		return 0x820D3150;
		/* 820D3134h case    5:*/		return 0x820D3138;
		  /* 820D3138h */ case    6:  		/* lbz R11, <#[R31]> */
		/* 820D3138h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D3138h case    6:*/		return 0x820D313C;
		  /* 820D313Ch */ case    7:  		/* extsb R3, R11 */
		/* 820D313Ch case    7:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820D313Ch case    7:*/		return 0x820D3140;
		  /* 820D3140h */ case    8:  		/* bl -236112 */
		/* 820D3140h case    8:*/		regs.LR = 0x820D3144; return 0x820996F0;
		/* 820D3140h case    8:*/		return 0x820D3144;
		  /* 820D3144h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820D3144h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D3144h case    9:*/		return 0x820D3148;
		  /* 820D3148h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820D3148h case   10:*/		if ( regs.CR[0].eq ) { return 0x820D3158;  }
		/* 820D3148h case   10:*/		return 0x820D314C;
		  /* 820D314Ch */ case   11:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820D314Ch case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820D314Ch case   11:*/		return 0x820D3150;
	}
	return 0x820D3150;
} // Block from 820D3120h-820D3150h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D3150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3150);
		  /* 820D3150h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820D3150h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3150h case    0:*/		return 0x820D3154;
		  /* 820D3154h */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820D3154h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3138;  }
		/* 820D3154h case    1:*/		return 0x820D3158;
	}
	return 0x820D3158;
} // Block from 820D3150h-820D3158h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3158);
		  /* 820D3158h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D3158h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D3158h case    0:*/		return 0x820D315C;
		  /* 820D315Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D315Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D315Ch case    1:*/		return 0x820D3160;
		  /* 820D3160h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820D3160h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D3174;  }
		/* 820D3160h case    2:*/		return 0x820D3164;
		  /* 820D3164h */ case    3:  		/* mr R3, R31 */
		/* 820D3164h case    3:*/		regs.R3 = regs.R31;
		/* 820D3164h case    3:*/		return 0x820D3168;
		  /* 820D3168h */ case    4:  		/* bl -263680 */
		/* 820D3168h case    4:*/		regs.LR = 0x820D316C; return 0x82092B68;
		/* 820D3168h case    4:*/		return 0x820D316C;
		  /* 820D316Ch */ case    5:  		/* mr R30, R3 */
		/* 820D316Ch case    5:*/		regs.R30 = regs.R3;
		/* 820D316Ch case    5:*/		return 0x820D3170;
		  /* 820D3170h */ case    6:  		/* b 12 */
		/* 820D3170h case    6:*/		return 0x820D317C;
		/* 820D3170h case    6:*/		return 0x820D3174;
	}
	return 0x820D3174;
} // Block from 820D3158h-820D3174h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3174);
		  /* 820D3174h */ case    0:  		/* lis R30, 0 */
		/* 820D3174h case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0x0);
		/* 820D3174h case    0:*/		return 0x820D3178;
		  /* 820D3178h */ case    1:  		/* ori R30, R30, 65535 */
		/* 820D3178h case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xFFFF);
		/* 820D3178h case    1:*/		return 0x820D317C;
	}
	return 0x820D317C;
} // Block from 820D3174h-820D317Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D317Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D317C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D317C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D317C);
		  /* 820D317Ch */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D317Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D317Ch case    0:*/		return 0x820D3180;
		  /* 820D3180h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D3180h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3180h case    1:*/		return 0x820D3184;
		  /* 820D3184h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 820D3184h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D3190;  }
		/* 820D3184h case    2:*/		return 0x820D3188;
		  /* 820D3188h */ case    3:  		/* stb R18, <#[R31]> */
		/* 820D3188h case    3:*/		cpu::mem::store8( regs, regs.R18, (uint32)(regs.R31 + 0x00000000) );
		/* 820D3188h case    3:*/		return 0x820D318C;
		  /* 820D318Ch */ case    4:  		/* addi R31, R31, 1 */
		/* 820D318Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820D318Ch case    4:*/		return 0x820D3190;
	}
	return 0x820D3190;
} // Block from 820D317Ch-820D3190h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3190);
		  /* 820D3190h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D3190h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D3190h case    0:*/		return 0x820D3194;
		  /* 820D3194h */ case    1:  		/* b 20 */
		/* 820D3194h case    1:*/		return 0x820D31A8;
		/* 820D3194h case    1:*/		return 0x820D3198;
		  /* 820D3198h */ case    2:  		/* bl -236168 */
		/* 820D3198h case    2:*/		regs.LR = 0x820D319C; return 0x82099710;
		/* 820D3198h case    2:*/		return 0x820D319C;
		  /* 820D319Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820D319Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D319Ch case    3:*/		return 0x820D31A0;
		  /* 820D31A0h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820D31A0h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D31B0;  }
		/* 820D31A0h case    4:*/		return 0x820D31A4;
		  /* 820D31A4h */ case    5:  		/* lbzu R11, <#[R31 + 1]> */
		/* 820D31A4h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000001) );
		regs.R31 = (uint32)(regs.R31 + 0x00000001);
		/* 820D31A4h case    5:*/		return 0x820D31A8;
	}
	return 0x820D31A8;
} // Block from 820D3190h-820D31A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D31A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D31A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D31A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D31A8);
		  /* 820D31A8h */ case    0:  		/* extsb. R3, R11 */
		/* 820D31A8h case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820D31A8h case    0:*/		return 0x820D31AC;
		  /* 820D31ACh */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820D31ACh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3198;  }
		/* 820D31ACh case    1:*/		return 0x820D31B0;
	}
	return 0x820D31B0;
} // Block from 820D31A8h-820D31B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D31B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D31B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D31B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D31B0);
		  /* 820D31B0h */ case    0:  		/* lbz R11, <#[R31]> */
		/* 820D31B0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D31B0h case    0:*/		return 0x820D31B4;
		  /* 820D31B4h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D31B4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D31B4h case    1:*/		return 0x820D31B8;
		  /* 820D31B8h */ case    2:  		/* bc 4, CR0_EQ, 108 */
		/* 820D31B8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820D3224;  }
		/* 820D31B8h case    2:*/		return 0x820D31BC;
		  /* 820D31BCh */ case    3:  		/* mr R8, R22 */
		/* 820D31BCh case    3:*/		regs.R8 = regs.R22;
		/* 820D31BCh case    3:*/		return 0x820D31C0;
		  /* 820D31C0h */ case    4:  		/* mr R9, R18 */
		/* 820D31C0h case    4:*/		regs.R9 = regs.R18;
		/* 820D31C0h case    4:*/		return 0x820D31C4;
		  /* 820D31C4h */ case    5:  		/* mr R6, R18 */
		/* 820D31C4h case    5:*/		regs.R6 = regs.R18;
		/* 820D31C4h case    5:*/		return 0x820D31C8;
		  /* 820D31C8h */ case    6:  		/* lwz R10, <#[R8]> */
		/* 820D31C8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820D31C8h case    6:*/		return 0x820D31CC;
		  /* 820D31CCh */ case    7:  		/* addi R11, R1, 128 */
		/* 820D31CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820D31CCh case    7:*/		return 0x820D31D0;
		  /* 820D31D0h */ case    8:  		/* lbz R7, <#[R11]> */
		/* 820D31D0h case    8:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820D31D0h case    8:*/		return 0x820D31D4;
		  /* 820D31D4h */ case    9:  		/* lbz R5, <#[R10]> */
		/* 820D31D4h case    9:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 820D31D4h case    9:*/		return 0x820D31D8;
		  /* 820D31D8h */ case   10:  		/* cmpwi CR0, R7, 0 */
		/* 820D31D8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R7,0x00000000);
		/* 820D31D8h case   10:*/		return 0x820D31DC;
		  /* 820D31DCh */ case   11:  		/* subf R7, R5, R7 */
		/* 820D31DCh case   11:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 820D31DCh case   11:*/		return 0x820D31E0;
		  /* 820D31E0h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 820D31E0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820D31F4;  }
		/* 820D31E0h case   12:*/		return 0x820D31E4;
		  /* 820D31E4h */ case   13:  		/* addi R11, R11, 1 */
		/* 820D31E4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D31E4h case   13:*/		return 0x820D31E8;
		  /* 820D31E8h */ case   14:  		/* addi R10, R10, 1 */
		/* 820D31E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D31E8h case   14:*/		return 0x820D31EC;
		  /* 820D31ECh */ case   15:  		/* cmpwi CR6, R7, 0 */
		/* 820D31ECh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820D31ECh case   15:*/		return 0x820D31F0;
		  /* 820D31F0h */ case   16:  		/* bc 12, CR6_EQ, -32 */
		/* 820D31F0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820D31D0;  }
		/* 820D31F0h case   16:*/		return 0x820D31F4;
	}
	return 0x820D31F4;
} // Block from 820D31B0h-820D31F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820D31F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D31F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D31F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D31F4);
		  /* 820D31F4h */ case    0:  		/* cmpwi CR0, R7, 0 */
		/* 820D31F4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R7,0x00000000);
		/* 820D31F4h case    0:*/		return 0x820D31F8;
		  /* 820D31F8h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820D31F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820D3210;  }
		/* 820D31F8h case    1:*/		return 0x820D31FC;
		  /* 820D31FCh */ case    2:  		/* addi R6, R6, 24 */
		/* 820D31FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x18);
		/* 820D31FCh case    2:*/		return 0x820D3200;
		  /* 820D3200h */ case    3:  		/* addi R9, R9, 1 */
		/* 820D3200h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820D3200h case    3:*/		return 0x820D3204;
		  /* 820D3204h */ case    4:  		/* addi R8, R8, 24 */
		/* 820D3204h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x18);
		/* 820D3204h case    4:*/		return 0x820D3208;
		  /* 820D3208h */ case    5:  		/* cmplwi CR6, R6, 432 */
		/* 820D3208h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x000001B0);
		/* 820D3208h case    5:*/		return 0x820D320C;
		  /* 820D320Ch */ case    6:  		/* bc 12, CR6_LT, -68 */
		/* 820D320Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x820D31C8;  }
		/* 820D320Ch case    6:*/		return 0x820D3210;
	}
	return 0x820D3210;
} // Block from 820D31F4h-820D3210h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3210);
		  /* 820D3210h */ case    0:  		/* cmplwi CR6, R9, 18 */
		/* 820D3210h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000012);
		/* 820D3210h case    0:*/		return 0x820D3214;
		  /* 820D3214h */ case    1:  		/* bc 4, CR6_EQ, 276 */
		/* 820D3214h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3328;  }
		/* 820D3214h case    1:*/		return 0x820D3218;
	}
	return 0x820D3218;
} // Block from 820D3210h-820D3218h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3218);
		  /* 820D3218h */ case    0:  		/* lwz R11, <#[R17 + 80]> */
		/* 820D3218h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000050) );
		/* 820D3218h case    0:*/		return 0x820D321C;
		  /* 820D321Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820D321Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D321Ch case    1:*/		return 0x820D3220;
		  /* 820D3220h */ case    2:  		/* bc 12, CR6_EQ, -352 */
		/* 820D3220h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D30C0;  }
		/* 820D3220h case    2:*/		return 0x820D3224;
	}
	return 0x820D3224;
} // Block from 820D3218h-820D3224h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3224);
		  /* 820D3224h */ case    0:  		/* lwz R11, <#[R17 + 80]> */
		/* 820D3224h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000050) );
		/* 820D3224h case    0:*/		return 0x820D3228;
		  /* 820D3228h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820D3228h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D3228h case    1:*/		return 0x820D322C;
		  /* 820D322Ch */ case    2:  		/* bc 12, CR6_EQ, 628 */
		/* 820D322Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820D34A0;  }
		/* 820D322Ch case    2:*/		return 0x820D3230;
		  /* 820D3230h */ case    3:  		/* mr R11, R25 */
		/* 820D3230h case    3:*/		regs.R11 = regs.R25;
		/* 820D3230h case    3:*/		return 0x820D3234;
		  /* 820D3234h */ case    4:  		/* lbz R10, <#[R11]> */
		/* 820D3234h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3234h case    4:*/		return 0x820D3238;
		  /* 820D3238h */ case    5:  		/* addi R11, R11, 1 */
		/* 820D3238h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3238h case    5:*/		return 0x820D323C;
		  /* 820D323Ch */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820D323Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D323Ch case    6:*/		return 0x820D3240;
		  /* 820D3240h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 820D3240h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D3234;  }
		/* 820D3240h case    7:*/		return 0x820D3244;
		  /* 820D3244h */ case    8:  		/* subf R11, R25, R11 */
		/* 820D3244h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 820D3244h case    8:*/		return 0x820D3248;
		  /* 820D3248h */ case    9:  		/* addi R11, R11, -1 */
		/* 820D3248h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D3248h case    9:*/		return 0x820D324C;
		  /* 820D324Ch */ case   10:  		/* rlwinm R31, R11, 0, 0, 31 */
		/* 820D324Ch case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R31,regs.R11);
		/* 820D324Ch case   10:*/		return 0x820D3250;
		  /* 820D3250h */ case   11:  		/* cmplwi CR6, R31, 256 */
		/* 820D3250h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000100);
		/* 820D3250h case   11:*/		return 0x820D3254;
		  /* 820D3254h */ case   12:  		/* bc 4, CR6_LT, -404 */
		/* 820D3254h case   12:*/		if ( !regs.CR[6].lt ) { return 0x820D30C0;  }
		/* 820D3254h case   12:*/		return 0x820D3258;
		  /* 820D3258h */ case   13:  		/* addi R5, R31, 1 */
		/* 820D3258h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x1);
		/* 820D3258h case   13:*/		return 0x820D325C;
		  /* 820D325Ch */ case   14:  		/* mr R4, R25 */
		/* 820D325Ch case   14:*/		regs.R4 = regs.R25;
		/* 820D325Ch case   14:*/		return 0x820D3260;
		  /* 820D3260h */ case   15:  		/* addi R3, R1, 192 */
		/* 820D3260h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xC0);
		/* 820D3260h case   15:*/		return 0x820D3264;
		  /* 820D3264h */ case   16:  		/* bl -268468 */
		/* 820D3264h case   16:*/		regs.LR = 0x820D3268; return 0x820919B0;
		/* 820D3264h case   16:*/		return 0x820D3268;
		  /* 820D3268h */ case   17:  		/* cmplwi CR6, R31, 4 */
		/* 820D3268h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 820D3268h case   17:*/		return 0x820D326C;
		  /* 820D326Ch */ case   18:  		/* bc 4, CR6_GT, 92 */
		/* 820D326Ch case   18:*/		if ( !regs.CR[6].gt ) { return 0x820D32C8;  }
		/* 820D326Ch case   18:*/		return 0x820D3270;
		  /* 820D3270h */ case   19:  		/* addi R11, R1, 192 */
		/* 820D3270h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820D3270h case   19:*/		return 0x820D3274;
		  /* 820D3274h */ case   20:  		/* add R10, R31, R11 */
		/* 820D3274h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R31,regs.R11);
		/* 820D3274h case   20:*/		return 0x820D3278;
		  /* 820D3278h */ case   21:  		/* lbz R11, <#[R10 - 4]> */
		/* 820D3278h case   21:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820D3278h case   21:*/		return 0x820D327C;
		  /* 820D327Ch */ case   22:  		/* cmplwi CR6, R11, 95 */
		/* 820D327Ch case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820D327Ch case   22:*/		return 0x820D3280;
		  /* 820D3280h */ case   23:  		/* bc 4, CR6_EQ, 72 */
		/* 820D3280h case   23:*/		if ( !regs.CR[6].eq ) { return 0x820D32C8;  }
		/* 820D3280h case   23:*/		return 0x820D3284;
		  /* 820D3284h */ case   24:  		/* addi R11, R1, 192 */
		/* 820D3284h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820D3284h case   24:*/		return 0x820D3288;
		  /* 820D3288h */ case   25:  		/* add R11, R31, R11 */
		/* 820D3288h case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820D3288h case   25:*/		return 0x820D328C;
		  /* 820D328Ch */ case   26:  		/* lbz R11, <#[R11 - 3]> */
		/* 820D328Ch case   26:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFFD) );
		/* 820D328Ch case   26:*/		return 0x820D3290;
		  /* 820D3290h */ case   27:  		/* cmplwi CR6, R11, 97 */
		/* 820D3290h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 820D3290h case   27:*/		return 0x820D3294;
		  /* 820D3294h */ case   28:  		/* bc 4, CR6_EQ, 52 */
		/* 820D3294h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820D32C8;  }
		/* 820D3294h case   28:*/		return 0x820D3298;
		  /* 820D3298h */ case   29:  		/* addi R11, R1, 192 */
		/* 820D3298h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820D3298h case   29:*/		return 0x820D329C;
		  /* 820D329Ch */ case   30:  		/* add R11, R31, R11 */
		/* 820D329Ch case   30:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820D329Ch case   30:*/		return 0x820D32A0;
		  /* 820D32A0h */ case   31:  		/* lbz R11, <#[R11 - 2]> */
		/* 820D32A0h case   31:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFFE) );
		/* 820D32A0h case   31:*/		return 0x820D32A4;
		  /* 820D32A4h */ case   32:  		/* cmplwi CR6, R11, 98 */
		/* 820D32A4h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000062);
		/* 820D32A4h case   32:*/		return 0x820D32A8;
		  /* 820D32A8h */ case   33:  		/* bc 4, CR6_EQ, 32 */
		/* 820D32A8h case   33:*/		if ( !regs.CR[6].eq ) { return 0x820D32C8;  }
		/* 820D32A8h case   33:*/		return 0x820D32AC;
		  /* 820D32ACh */ case   34:  		/* addi R11, R1, 192 */
		/* 820D32ACh case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820D32ACh case   34:*/		return 0x820D32B0;
		  /* 820D32B0h */ case   35:  		/* add R11, R31, R11 */
		/* 820D32B0h case   35:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820D32B0h case   35:*/		return 0x820D32B4;
		  /* 820D32B4h */ case   36:  		/* lbz R11, <#[R11 - 1]> */
		/* 820D32B4h case   36:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 820D32B4h case   36:*/		return 0x820D32B8;
		  /* 820D32B8h */ case   37:  		/* cmplwi CR6, R11, 115 */
		/* 820D32B8h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000073);
		/* 820D32B8h case   37:*/		return 0x820D32BC;
		  /* 820D32BCh */ case   38:  		/* bc 4, CR6_EQ, 12 */
		/* 820D32BCh case   38:*/		if ( !regs.CR[6].eq ) { return 0x820D32C8;  }
		/* 820D32BCh case   38:*/		return 0x820D32C0;
		  /* 820D32C0h */ case   39:  		/* addi R31, R31, -3 */
		/* 820D32C0h case   39:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFD);
		/* 820D32C0h case   39:*/		return 0x820D32C4;
		  /* 820D32C4h */ case   40:  		/* stb R18, <#[R10 - 4]> */
		/* 820D32C4h case   40:*/		cpu::mem::store8( regs, regs.R18, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 820D32C4h case   40:*/		return 0x820D32C8;
	}
	return 0x820D32C8;
} // Block from 820D3224h-820D32C8h (41 instructions)

//////////////////////////////////////////////////////
// Block at 820D32C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D32C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D32C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D32C8);
		  /* 820D32C8h */ case    0:  		/* li R11, 5 */
		/* 820D32C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820D32C8h case    0:*/		return 0x820D32CC;
		  /* 820D32CCh */ case    1:  		/* addi R10, R1, 136 */
		/* 820D32CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x88);
		/* 820D32CCh case    1:*/		return 0x820D32D0;
		  /* 820D32D0h */ case    2:  		/* addi R9, R21, -8 */
		/* 820D32D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R21,0xFFFFFFF8);
		/* 820D32D0h case    2:*/		return 0x820D32D4;
		  /* 820D32D4h */ case    3:  		/* mtspr CTR, R11 */
		/* 820D32D4h case    3:*/		regs.CTR = regs.R11;
		/* 820D32D4h case    3:*/		return 0x820D32D8;
		  /* 820D32D8h */ case    4:  		/* ldu R11, <#[R9 + 8]> */
		/* 820D32D8h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820D32D8h case    4:*/		return 0x820D32DC;
		  /* 820D32DCh */ case    5:  		/* stdu R11, <#[R10 + 8]> */
		/* 820D32DCh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820D32DCh case    5:*/		return 0x820D32E0;
		  /* 820D32E0h */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 820D32E0h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D32D8;  }
		/* 820D32E0h case    6:*/		return 0x820D32E4;
		  /* 820D32E4h */ case    7:  		/* addi R11, R1, 192 */
		/* 820D32E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820D32E4h case    7:*/		return 0x820D32E8;
		  /* 820D32E8h */ case    8:  		/* lwz R10, <#[R17 + 88]> */
		/* 820D32E8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000058) );
		/* 820D32E8h case    8:*/		return 0x820D32EC;
		  /* 820D32ECh */ case    9:  		/* addi R6, R1, 112 */
		/* 820D32ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 820D32ECh case    9:*/		return 0x820D32F0;
		  /* 820D32F0h */ case   10:  		/* lwz R3, <#[R17 + 84]> */
		/* 820D32F0h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000054) );
		/* 820D32F0h case   10:*/		return 0x820D32F4;
		  /* 820D32F4h */ case   11:  		/* stw R11, <#[R1 + 152]> */
		/* 820D32F4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 820D32F4h case   11:*/		return 0x820D32F8;
		  /* 820D32F8h */ case   12:  		/* li R5, 1 */
		/* 820D32F8h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820D32F8h case   12:*/		return 0x820D32FC;
		  /* 820D32FCh */ case   13:  		/* addi R4, R1, 144 */
		/* 820D32FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 820D32FCh case   13:*/		return 0x820D3300;
		  /* 820D3300h */ case   14:  		/* mtspr CTR, R10 */
		/* 820D3300h case   14:*/		regs.CTR = regs.R10;
		/* 820D3300h case   14:*/		return 0x820D3304;
		  /* 820D3304h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 820D3304h case   15:*/		if ( 1 ) { regs.LR = 0x820D3308; return (uint32)regs.CTR; }
		/* 820D3304h case   15:*/		return 0x820D3308;
		  /* 820D3308h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820D3308h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D3308h case   16:*/		return 0x820D330C;
		  /* 820D330Ch */ case   17:  		/* bc 4, CR0_EQ, -588 */
		/* 820D330Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x820D30C0;  }
		/* 820D330Ch case   17:*/		return 0x820D3310;
		  /* 820D3310h */ case   18:  		/* add R26, R31, R25 */
		/* 820D3310h case   18:*/		cpu::op::add<0>(regs,&regs.R26,regs.R31,regs.R25);
		/* 820D3310h case   18:*/		return 0x820D3314;
		  /* 820D3314h */ case   19:  		/* mr R29, R18 */
		/* 820D3314h case   19:*/		regs.R29 = regs.R18;
		/* 820D3314h case   19:*/		return 0x820D3318;
		  /* 820D3318h */ case   20:  		/* mr R30, R18 */
		/* 820D3318h case   20:*/		regs.R30 = regs.R18;
		/* 820D3318h case   20:*/		return 0x820D331C;
		  /* 820D331Ch */ case   21:  		/* mr R23, R18 */
		/* 820D331Ch case   21:*/		regs.R23 = regs.R18;
		/* 820D331Ch case   21:*/		return 0x820D3320;
		  /* 820D3320h */ case   22:  		/* mr R24, R26 */
		/* 820D3320h case   22:*/		regs.R24 = regs.R26;
		/* 820D3320h case   22:*/		return 0x820D3324;
		  /* 820D3324h */ case   23:  		/* b 368 */
		/* 820D3324h case   23:*/		return 0x820D3494;
		/* 820D3324h case   23:*/		return 0x820D3328;
	}
	return 0x820D3328;
} // Block from 820D32C8h-820D3328h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820D3328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3328);
		  /* 820D3328h */ case    0:  		/* lwz R11, <#[R17 + 72]> */
		/* 820D3328h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000048) );
		/* 820D3328h case    0:*/		return 0x820D332C;
		  /* 820D332Ch */ case    1:  		/* mulli R10, R9, 12 */
		/* 820D332Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R9,0xC);
		/* 820D332Ch case    1:*/		return 0x820D3330;
		  /* 820D3330h */ case    2:  		/* add R11, R10, R11 */
		/* 820D3330h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D3330h case    2:*/		return 0x820D3334;
		  /* 820D3334h */ case    3:  		/* addi R10, R22, 8 */
		/* 820D3334h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0x8);
		/* 820D3334h case    3:*/		return 0x820D3338;
		  /* 820D3338h */ case    4:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820D3338h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820D3338h case    4:*/		return 0x820D333C;
		  /* 820D333Ch */ case    5:  		/* lhzx R10, <#[R11 + R10]> */
		/* 820D333Ch case    5:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820D333Ch case    5:*/		return 0x820D3340;
		  /* 820D3340h */ case    6:  		/* cmplwi CR6, R10, 65535 */
		/* 820D3340h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000FFFF);
		/* 820D3340h case    6:*/		return 0x820D3344;
		  /* 820D3344h */ case    7:  		/* bc 12, CR6_EQ, -644 */
		/* 820D3344h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D30C0;  }
		/* 820D3344h case    7:*/		return 0x820D3348;
		  /* 820D3348h */ case    8:  		/* mulli R9, R9, 24 */
		/* 820D3348h case    8:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0x18);
		/* 820D3348h case    8:*/		return 0x820D334C;
		  /* 820D334Ch */ case    9:  		/* addi R11, R22, 20 */
		/* 820D334Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x14);
		/* 820D334Ch case    9:*/		return 0x820D3350;
		  /* 820D3350h */ case   10:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820D3350h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820D3350h case   10:*/		return 0x820D3354;
		  /* 820D3354h */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 820D3354h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D3354h case   11:*/		return 0x820D3358;
		  /* 820D3358h */ case   12:  		/* bc 12, CR6_EQ, 48 */
		/* 820D3358h case   12:*/		if ( regs.CR[6].eq ) { return 0x820D3388;  }
		/* 820D3358h case   12:*/		return 0x820D335C;
		  /* 820D335Ch */ case   13:  		/* cmplwi CR6, R30, 65535 */
		/* 820D335Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000FFFF);
		/* 820D335Ch case   13:*/		return 0x820D3360;
		  /* 820D3360h */ case   14:  		/* bc 4, CR6_EQ, 20 */
		/* 820D3360h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820D3374;  }
		/* 820D3360h case   14:*/		return 0x820D3364;
		  /* 820D3364h */ case   15:  		/* cmplwi CR6, R19, 0 */
		/* 820D3364h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820D3364h case   15:*/		return 0x820D3368;
		  /* 820D3368h */ case   16:  		/* bc 12, CR6_EQ, 468 */
		/* 820D3368h case   16:*/		if ( regs.CR[6].eq ) { return 0x820D353C;  }
		/* 820D3368h case   16:*/		return 0x820D336C;
		  /* 820D336Ch */ case   17:  		/* lwz R30, <#[R19 + 24]> */
		/* 820D336Ch case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R19 + 0x00000018) );
		/* 820D336Ch case   17:*/		return 0x820D3370;
		  /* 820D3370h */ case   18:  		/* b 32 */
		/* 820D3370h case   18:*/		return 0x820D3390;
		/* 820D3370h case   18:*/		return 0x820D3374;
	}
	return 0x820D3374;
} // Block from 820D3328h-820D3374h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D3374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3374);
		  /* 820D3374h */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 820D3374h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820D3374h case    0:*/		return 0x820D3378;
		  /* 820D3378h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820D3378h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3390;  }
		/* 820D3378h case    1:*/		return 0x820D337C;
		  /* 820D337Ch */ case    2:  		/* lwz R11, <#[R19 + 24]> */
		/* 820D337Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000018) );
		/* 820D337Ch case    2:*/		return 0x820D3380;
		  /* 820D3380h */ case    3:  		/* add R30, R11, R30 */
		/* 820D3380h case    3:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820D3380h case    3:*/		return 0x820D3384;
		  /* 820D3384h */ case    4:  		/* b 12 */
		/* 820D3384h case    4:*/		return 0x820D3390;
		/* 820D3384h case    4:*/		return 0x820D3388;
	}
	return 0x820D3388;
} // Block from 820D3374h-820D3388h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3388);
		  /* 820D3388h */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 820D3388h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820D3388h case    0:*/		return 0x820D338C;
		  /* 820D338Ch */ case    1:  		/* bc 4, CR6_EQ, -708 */
		/* 820D338Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D30C8;  }
		/* 820D338Ch case    1:*/		return 0x820D3390;
	}
	return 0x820D3390;
} // Block from 820D3388h-820D3390h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3390);
		  /* 820D3390h */ case    0:  		/* cmplwi CR6, R30, 65535 */
		/* 820D3390h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000FFFF);
		/* 820D3390h case    0:*/		return 0x820D3394;
		  /* 820D3394h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 820D3394h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D33A8;  }
		/* 820D3394h case    1:*/		return 0x820D3398;
		  /* 820D3398h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820D3398h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D3398h case    2:*/		return 0x820D339C;
		  /* 820D339Ch */ case    3:  		/* bc 4, CR6_EQ, -376 */
		/* 820D339Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D3224;  }
		/* 820D339Ch case    3:*/		return 0x820D33A0;
		  /* 820D33A0h */ case    4:  		/* mr R30, R18 */
		/* 820D33A0h case    4:*/		regs.R30 = regs.R18;
		/* 820D33A0h case    4:*/		return 0x820D33A4;
		  /* 820D33A4h */ case    5:  		/* b 32 */
		/* 820D33A4h case    5:*/		return 0x820D33C4;
		/* 820D33A4h case    5:*/		return 0x820D33A8;
	}
	return 0x820D33A8;
} // Block from 820D3390h-820D33A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D33A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D33A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D33A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D33A8);
		  /* 820D33A8h */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 820D33A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820D33A8h case    0:*/		return 0x820D33AC;
		  /* 820D33ACh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820D33ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820D33BC;  }
		/* 820D33ACh case    1:*/		return 0x820D33B0;
		  /* 820D33B0h */ case    2:  		/* lwz R11, <#[R19 + 40]> */
		/* 820D33B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000028) );
		/* 820D33B0h case    2:*/		return 0x820D33B4;
		  /* 820D33B4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820D33B4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D33B4h case    3:*/		return 0x820D33B8;
		  /* 820D33B8h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 820D33B8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D33C4;  }
		/* 820D33B8h case    4:*/		return 0x820D33BC;
	}
	return 0x820D33BC;
} // Block from 820D33A8h-820D33BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D33BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D33BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D33BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D33BC);
		  /* 820D33BCh */ case    0:  		/* cmplw CR6, R30, R10 */
		/* 820D33BCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 820D33BCh case    0:*/		return 0x820D33C0;
		  /* 820D33C0h */ case    1:  		/* bc 4, CR6_LT, -768 */
		/* 820D33C0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820D30C0;  }
		/* 820D33C0h case    1:*/		return 0x820D33C4;
	}
	return 0x820D33C4;
} // Block from 820D33BCh-820D33C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D33C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D33C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D33C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D33C4);
		  /* 820D33C4h */ case    0:  		/* addi R11, R22, 4 */
		/* 820D33C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x4);
		/* 820D33C4h case    0:*/		return 0x820D33C8;
		  /* 820D33C8h */ case    1:  		/* addi R10, R22, 16 */
		/* 820D33C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0x10);
		/* 820D33C8h case    1:*/		return 0x820D33CC;
		  /* 820D33CCh */ case    2:  		/* lwzx R29, <#[R9 + R11]> */
		/* 820D33CCh case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820D33CCh case    2:*/		return 0x820D33D0;
		  /* 820D33D0h */ case    3:  		/* lwzx R23, <#[R9 + R10]> */
		/* 820D33D0h case    3:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820D33D0h case    3:*/		return 0x820D33D4;
		  /* 820D33D4h */ case    4:  		/* cmplwi CR6, R29, 2 */
		/* 820D33D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000002);
		/* 820D33D4h case    4:*/		return 0x820D33D8;
		  /* 820D33D8h */ case    5:  		/* bc 4, CR6_EQ, 68 */
		/* 820D33D8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D341C;  }
		/* 820D33D8h case    5:*/		return 0x820D33DC;
		  /* 820D33DCh */ case    6:  		/* rlwinm R11, R30, 0, 19, 31 */
		/* 820D33DCh case    6:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R30);
		/* 820D33DCh case    6:*/		return 0x820D33E0;
		  /* 820D33E0h */ case    7:  		/* cmplwi CR6, R11, 2048 */
		/* 820D33E0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000800);
		/* 820D33E0h case    7:*/		return 0x820D33E4;
		  /* 820D33E4h */ case    8:  		/* bc 12, CR6_LT, 48 */
		/* 820D33E4h case    8:*/		if ( regs.CR[6].lt ) { return 0x820D3414;  }
		/* 820D33E4h case    8:*/		return 0x820D33E8;
		  /* 820D33E8h */ case    9:  		/* cmplwi CR6, R11, 4096 */
		/* 820D33E8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 820D33E8h case    9:*/		return 0x820D33EC;
		  /* 820D33ECh */ case   10:  		/* bc 4, CR6_LT, 12 */
		/* 820D33ECh case   10:*/		if ( !regs.CR[6].lt ) { return 0x820D33F8;  }
		/* 820D33ECh case   10:*/		return 0x820D33F0;
		  /* 820D33F0h */ case   11:  		/* li R29, 11 */
		/* 820D33F0h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0xB);
		/* 820D33F0h case   11:*/		return 0x820D33F4;
		  /* 820D33F4h */ case   12:  		/* b 32 */
		/* 820D33F4h case   12:*/		return 0x820D3414;
		/* 820D33F4h case   12:*/		return 0x820D33F8;
	}
	return 0x820D33F8;
} // Block from 820D33C4h-820D33F8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D33F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D33F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D33F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D33F8);
		  /* 820D33F8h */ case    0:  		/* cmplwi CR6, R11, 6144 */
		/* 820D33F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001800);
		/* 820D33F8h case    0:*/		return 0x820D33FC;
		  /* 820D33FCh */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820D33FCh case    1:*/		if ( !regs.CR[6].lt ) { return 0x820D3408;  }
		/* 820D33FCh case    1:*/		return 0x820D3400;
		  /* 820D3400h */ case    2:  		/* li R29, 12 */
		/* 820D3400h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0xC);
		/* 820D3400h case    2:*/		return 0x820D3404;
		  /* 820D3404h */ case    3:  		/* b 16 */
		/* 820D3404h case    3:*/		return 0x820D3414;
		/* 820D3404h case    3:*/		return 0x820D3408;
	}
	return 0x820D3408;
} // Block from 820D33F8h-820D3408h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D3408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3408);
		  /* 820D3408h */ case    0:  		/* cmplwi CR6, R11, 8192 */
		/* 820D3408h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002000);
		/* 820D3408h case    0:*/		return 0x820D340C;
		  /* 820D340Ch */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 820D340Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x820D3414;  }
		/* 820D340Ch case    1:*/		return 0x820D3410;
		  /* 820D3410h */ case    2:  		/* li R29, 13 */
		/* 820D3410h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0xD);
		/* 820D3410h case    2:*/		return 0x820D3414;
	}
	return 0x820D3414;
} // Block from 820D3408h-820D3414h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3414);
		  /* 820D3414h */ case    0:  		/* rlwinm R30, R11, 0, 21, 31 */
		/* 820D3414h case    0:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R30,regs.R11);
		/* 820D3414h case    0:*/		return 0x820D3418;
		  /* 820D3418h */ case    1:  		/* b 124 */
		/* 820D3418h case    1:*/		return 0x820D3494;
		/* 820D3418h case    1:*/		return 0x820D341C;
	}
	return 0x820D341C;
} // Block from 820D3414h-820D341Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D341Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D341C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D341C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D341C);
		  /* 820D341Ch */ case    0:  		/* cmpwi CR6, R29, -3 */
		/* 820D341Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFD);
		/* 820D341Ch case    0:*/		return 0x820D3420;
		  /* 820D3420h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3420h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D342C;  }
		/* 820D3420h case    1:*/		return 0x820D3424;
		  /* 820D3424h */ case    2:  		/* li R30, 62 */
		/* 820D3424h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x3E);
		/* 820D3424h case    2:*/		return 0x820D3428;
		  /* 820D3428h */ case    3:  		/* b 104 */
		/* 820D3428h case    3:*/		return 0x820D3490;
		/* 820D3428h case    3:*/		return 0x820D342C;
	}
	return 0x820D342C;
} // Block from 820D341Ch-820D342Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D342Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D342C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D342C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D342C);
		  /* 820D342Ch */ case    0:  		/* cmpwi CR6, R29, -4 */
		/* 820D342Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFC);
		/* 820D342Ch case    0:*/		return 0x820D3430;
		  /* 820D3430h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3430h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D343C;  }
		/* 820D3430h case    1:*/		return 0x820D3434;
		  /* 820D3434h */ case    2:  		/* li R30, 63 */
		/* 820D3434h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x3F);
		/* 820D3434h case    2:*/		return 0x820D3438;
		  /* 820D3438h */ case    3:  		/* b 88 */
		/* 820D3438h case    3:*/		return 0x820D3490;
		/* 820D3438h case    3:*/		return 0x820D343C;
	}
	return 0x820D343C;
} // Block from 820D342Ch-820D343Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D343Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D343C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D343C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D343C);
		  /* 820D343Ch */ case    0:  		/* cmplwi CR6, R29, 9 */
		/* 820D343Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000009);
		/* 820D343Ch case    0:*/		return 0x820D3440;
		  /* 820D3440h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3440h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D344C;  }
		/* 820D3440h case    1:*/		return 0x820D3444;
		  /* 820D3444h */ case    2:  		/* li R30, 61 */
		/* 820D3444h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x3D);
		/* 820D3444h case    2:*/		return 0x820D3448;
		  /* 820D3448h */ case    3:  		/* b 72 */
		/* 820D3448h case    3:*/		return 0x820D3490;
		/* 820D3448h case    3:*/		return 0x820D344C;
	}
	return 0x820D344C;
} // Block from 820D343Ch-820D344Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D344Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D344C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D344C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D344C);
		  /* 820D344Ch */ case    0:  		/* cmpwi CR6, R29, -6 */
		/* 820D344Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFA);
		/* 820D344Ch case    0:*/		return 0x820D3450;
		  /* 820D3450h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D3450h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3460;  }
		/* 820D3450h case    1:*/		return 0x820D3454;
		  /* 820D3454h */ case    2:  		/* li R29, 17 */
		/* 820D3454h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x11);
		/* 820D3454h case    2:*/		return 0x820D3458;
		  /* 820D3458h */ case    3:  		/* mr R30, R18 */
		/* 820D3458h case    3:*/		regs.R30 = regs.R18;
		/* 820D3458h case    3:*/		return 0x820D345C;
		  /* 820D345Ch */ case    4:  		/* b 56 */
		/* 820D345Ch case    4:*/		return 0x820D3494;
		/* 820D345Ch case    4:*/		return 0x820D3460;
	}
	return 0x820D3460;
} // Block from 820D344Ch-820D3460h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3460);
		  /* 820D3460h */ case    0:  		/* cmpwi CR6, R29, -7 */
		/* 820D3460h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFF9);
		/* 820D3460h case    0:*/		return 0x820D3464;
		  /* 820D3464h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D3464h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3474;  }
		/* 820D3464h case    1:*/		return 0x820D3468;
		  /* 820D3468h */ case    2:  		/* li R29, 17 */
		/* 820D3468h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x11);
		/* 820D3468h case    2:*/		return 0x820D346C;
		  /* 820D346Ch */ case    3:  		/* li R30, 1 */
		/* 820D346Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820D346Ch case    3:*/		return 0x820D3470;
		  /* 820D3470h */ case    4:  		/* b 36 */
		/* 820D3470h case    4:*/		return 0x820D3494;
		/* 820D3470h case    4:*/		return 0x820D3474;
	}
	return 0x820D3474;
} // Block from 820D3460h-820D3474h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3474);
		  /* 820D3474h */ case    0:  		/* cmpwi CR6, R29, -1000 */
		/* 820D3474h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFC18);
		/* 820D3474h case    0:*/		return 0x820D3478;
		  /* 820D3478h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3478h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3484;  }
		/* 820D3478h case    1:*/		return 0x820D347C;
		  /* 820D347Ch */ case    2:  		/* li R30, 32 */
		/* 820D347Ch case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x20);
		/* 820D347Ch case    2:*/		return 0x820D3480;
		  /* 820D3480h */ case    3:  		/* b 16 */
		/* 820D3480h case    3:*/		return 0x820D3490;
		/* 820D3480h case    3:*/		return 0x820D3484;
	}
	return 0x820D3484;
} // Block from 820D3474h-820D3484h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D3484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3484);
		  /* 820D3484h */ case    0:  		/* cmpwi CR6, R29, -1001 */
		/* 820D3484h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFC17);
		/* 820D3484h case    0:*/		return 0x820D3488;
		  /* 820D3488h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3488h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3494;  }
		/* 820D3488h case    1:*/		return 0x820D348C;
		  /* 820D348Ch */ case    2:  		/* addi R30, R30, 33 */
		/* 820D348Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x21);
		/* 820D348Ch case    2:*/		return 0x820D3490;
	}
	return 0x820D3490;
} // Block from 820D3484h-820D3490h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3490);
		  /* 820D3490h */ case    0:  		/* li R29, 4 */
		/* 820D3490h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 820D3490h case    0:*/		return 0x820D3494;
	}
	return 0x820D3494;
} // Block from 820D3490h-820D3494h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3494);
		  /* 820D3494h */ case    0:  		/* mr R27, R18 */
		/* 820D3494h case    0:*/		regs.R27 = regs.R18;
		/* 820D3494h case    0:*/		return 0x820D3498;
		  /* 820D3498h */ case    1:  		/* li R28, 1 */
		/* 820D3498h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820D3498h case    1:*/		return 0x820D349C;
		  /* 820D349Ch */ case    2:  		/* b 72 */
		/* 820D349Ch case    2:*/		return 0x820D34E4;
		/* 820D349Ch case    2:*/		return 0x820D34A0;
	}
	return 0x820D34A0;
} // Block from 820D3494h-820D34A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D34A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D34A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D34A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D34A0);
		  /* 820D34A0h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820D34A0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820D34A0h case    0:*/		return 0x820D34A4;
		  /* 820D34A4h */ case    1:  		/* bc 12, CR6_EQ, -996 */
		/* 820D34A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D30C0;  }
		/* 820D34A4h case    1:*/		return 0x820D34A8;
		  /* 820D34A8h */ case    2:  		/* mr R10, R16 */
		/* 820D34A8h case    2:*/		regs.R10 = regs.R16;
		/* 820D34A8h case    2:*/		return 0x820D34AC;
		  /* 820D34ACh */ case    3:  		/* addi R11, R1, 128 */
		/* 820D34ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820D34ACh case    3:*/		return 0x820D34B0;
		  /* 820D34B0h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820D34B0h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D34B0h case    4:*/		return 0x820D34B4;
		  /* 820D34B4h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820D34B4h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D34B4h case    5:*/		return 0x820D34B8;
		  /* 820D34B8h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820D34B8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D34B8h case    6:*/		return 0x820D34BC;
		  /* 820D34BCh */ case    7:  		/* subf R9, R8, R9 */
		/* 820D34BCh case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D34BCh case    7:*/		return 0x820D34C0;
		  /* 820D34C0h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820D34C0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820D34D4;  }
		/* 820D34C0h case    8:*/		return 0x820D34C4;
		  /* 820D34C4h */ case    9:  		/* addi R11, R11, 1 */
		/* 820D34C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D34C4h case    9:*/		return 0x820D34C8;
		  /* 820D34C8h */ case   10:  		/* addi R10, R10, 1 */
		/* 820D34C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D34C8h case   10:*/		return 0x820D34CC;
		  /* 820D34CCh */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820D34CCh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D34CCh case   11:*/		return 0x820D34D0;
		  /* 820D34D0h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820D34D0h case   12:*/		if ( regs.CR[6].eq ) { return 0x820D34B0;  }
		/* 820D34D0h case   12:*/		return 0x820D34D4;
	}
	return 0x820D34D4;
} // Block from 820D34A0h-820D34D4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D34D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D34D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D34D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D34D4);
		  /* 820D34D4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D34D4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D34D4h case    0:*/		return 0x820D34D8;
		  /* 820D34D8h */ case    1:  		/* bc 4, CR0_EQ, -1048 */
		/* 820D34D8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D30C0;  }
		/* 820D34D8h case    1:*/		return 0x820D34DC;
		  /* 820D34DCh */ case    2:  		/* lis R20, 2816 */
		/* 820D34DCh case    2:*/		cpu::op::lis<0>(regs,&regs.R20,0xB00);
		/* 820D34DCh case    2:*/		return 0x820D34E0;
		  /* 820D34E0h */ case    3:  		/* mr R28, R18 */
		/* 820D34E0h case    3:*/		regs.R28 = regs.R18;
		/* 820D34E0h case    3:*/		return 0x820D34E4;
	}
	return 0x820D34E4;
} // Block from 820D34D4h-820D34E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D34E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D34E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D34E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D34E4);
		  /* 820D34E4h */ case    0:  		/* lbz R11, <#[R26]> */
		/* 820D34E4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D34E4h case    0:*/		return 0x820D34E8;
		  /* 820D34E8h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D34E8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D34E8h case    1:*/		return 0x820D34EC;
		  /* 820D34ECh */ case    2:  		/* bc 4, CR0_EQ, -1116 */
		/* 820D34ECh case    2:*/		if ( !regs.CR[0].eq ) { return 0x820D3090;  }
		/* 820D34ECh case    2:*/		return 0x820D34F0;
	}
	return 0x820D34F0;
} // Block from 820D34E4h-820D34F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D34F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D34F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D34F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D34F0);
		  /* 820D34F0h */ case    0:  		/* li R3, 88 */
		/* 820D34F0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x58);
		/* 820D34F0h case    0:*/		return 0x820D34F4;
		  /* 820D34F4h */ case    1:  		/* bl -41676 */
		/* 820D34F4h case    1:*/		regs.LR = 0x820D34F8; return 0x820C9228;
		/* 820D34F4h case    1:*/		return 0x820D34F8;
		  /* 820D34F8h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820D34F8h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820D34F8h case    2:*/		return 0x820D34FC;
		  /* 820D34FCh */ case    3:  		/* bc 12, CR0_EQ, 156 */
		/* 820D34FCh case    3:*/		if ( regs.CR[0].eq ) { return 0x820D3598;  }
		/* 820D34FCh case    3:*/		return 0x820D3500;
		  /* 820D3500h */ case    4:  		/* li R9, 0 */
		/* 820D3500h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820D3500h case    4:*/		return 0x820D3504;
		  /* 820D3504h */ case    5:  		/* mr R8, R23 */
		/* 820D3504h case    5:*/		regs.R8 = regs.R23;
		/* 820D3504h case    5:*/		return 0x820D3508;
		  /* 820D3508h */ case    6:  		/* mr R7, R30 */
		/* 820D3508h case    6:*/		regs.R7 = regs.R30;
		/* 820D3508h case    6:*/		return 0x820D350C;
		  /* 820D350Ch */ case    7:  		/* mr R6, R20 */
		/* 820D350Ch case    7:*/		regs.R6 = regs.R20;
		/* 820D350Ch case    7:*/		return 0x820D3510;
		  /* 820D3510h */ case    8:  		/* mr R5, R29 */
		/* 820D3510h case    8:*/		regs.R5 = regs.R29;
		/* 820D3510h case    8:*/		return 0x820D3514;
		  /* 820D3514h */ case    9:  		/* mr R4, R21 */
		/* 820D3514h case    9:*/		regs.R4 = regs.R21;
		/* 820D3514h case    9:*/		return 0x820D3518;
		  /* 820D3518h */ case   10:  		/* bl 462240 */
		/* 820D3518h case   10:*/		regs.LR = 0x820D351C; return 0x821442B8;
		/* 820D3518h case   10:*/		return 0x820D351C;
		  /* 820D351Ch */ case   11:  		/* mr R31, R3 */
		/* 820D351Ch case   11:*/		regs.R31 = regs.R3;
		/* 820D351Ch case   11:*/		return 0x820D3520;
		  /* 820D3520h */ case   12:  		/* b 124 */
		/* 820D3520h case   12:*/		return 0x820D359C;
		/* 820D3520h case   12:*/		return 0x820D3524;
	}
	return 0x820D3524;
} // Block from 820D34F0h-820D3524h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D3524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3524);
		  /* 820D3524h */ case    0:  		/* lwz R11, <#[R11 + 16]> */
		/* 820D3524h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820D3524h case    0:*/		return 0x820D3528;
		  /* 820D3528h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820D3528h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820D3528h case    1:*/		return 0x820D352C;
		  /* 820D352Ch */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 820D352Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820D3558;  }
		/* 820D352Ch case    2:*/		return 0x820D3530;
		  /* 820D3530h */ case    3:  		/* lis R11, -32255 */
		/* 820D3530h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3530h case    3:*/		return 0x820D3534;
		  /* 820D3534h */ case    4:  		/* addi R6, R11, 3288 */
		/* 820D3534h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xCD8);
		/* 820D3534h case    4:*/		return 0x820D3538;
		  /* 820D3538h */ case    5:  		/* b 12 */
		/* 820D3538h case    5:*/		return 0x820D3544;
		/* 820D3538h case    5:*/		return 0x820D353C;
	}
	return 0x820D353C;
} // Block from 820D3524h-820D353Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D353Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D353C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D353C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D353C);
		  /* 820D353Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D353Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D353Ch case    0:*/		return 0x820D3540;
		  /* 820D3540h */ case    1:  		/* addi R6, R11, 3264 */
		/* 820D3540h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xCC0);
		/* 820D3540h case    1:*/		return 0x820D3544;
	}
	return 0x820D3544;
} // Block from 820D353Ch-820D3544h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3544);
		  /* 820D3544h */ case    0:  		/* mr R7, R25 */
		/* 820D3544h case    0:*/		regs.R7 = regs.R25;
		/* 820D3544h case    0:*/		return 0x820D3548;
		  /* 820D3548h */ case    1:  		/* lwz R3, <#[R17]> */
		/* 820D3548h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x00000000) );
		/* 820D3548h case    1:*/		return 0x820D354C;
		  /* 820D354Ch */ case    2:  		/* li R5, 2005 */
		/* 820D354Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D5);
		/* 820D354Ch case    2:*/		return 0x820D3550;
		  /* 820D3550h */ case    3:  		/* mr R4, R21 */
		/* 820D3550h case    3:*/		regs.R4 = regs.R21;
		/* 820D3550h case    3:*/		return 0x820D3554;
		  /* 820D3554h */ case    4:  		/* bl -181188 */
		/* 820D3554h case    4:*/		regs.LR = 0x820D3558; return 0x820A7190;
		/* 820D3554h case    4:*/		return 0x820D3558;
	}
	return 0x820D3558;
} // Block from 820D3544h-820D3558h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3558);
		  /* 820D3558h */ case    0:  		/* li R11, 1 */
		/* 820D3558h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D3558h case    0:*/		return 0x820D355C;
		  /* 820D355Ch */ case    1:  		/* li R3, 88 */
		/* 820D355Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x58);
		/* 820D355Ch case    1:*/		return 0x820D3560;
		  /* 820D3560h */ case    2:  		/* stw R11, <#[R17 + 60]> */
		/* 820D3560h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x0000003C) );
		/* 820D3560h case    2:*/		return 0x820D3564;
		  /* 820D3564h */ case    3:  		/* bl -41788 */
		/* 820D3564h case    3:*/		regs.LR = 0x820D3568; return 0x820C9228;
		/* 820D3564h case    3:*/		return 0x820D3568;
		  /* 820D3568h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820D3568h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820D3568h case    4:*/		return 0x820D356C;
		  /* 820D356Ch */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 820D356Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820D3590;  }
		/* 820D356Ch case    5:*/		return 0x820D3570;
		  /* 820D3570h */ case    6:  		/* li R9, 0 */
		/* 820D3570h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820D3570h case    6:*/		return 0x820D3574;
		  /* 820D3574h */ case    7:  		/* li R8, 0 */
		/* 820D3574h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820D3574h case    7:*/		return 0x820D3578;
		  /* 820D3578h */ case    8:  		/* li R7, 0 */
		/* 820D3578h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820D3578h case    8:*/		return 0x820D357C;
		  /* 820D357Ch */ case    9:  		/* li R6, 0 */
		/* 820D357Ch case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820D357Ch case    9:*/		return 0x820D3580;
		  /* 820D3580h */ case   10:  		/* li R5, -1 */
		/* 820D3580h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 820D3580h case   10:*/		return 0x820D3584;
		  /* 820D3584h */ case   11:  		/* mr R4, R21 */
		/* 820D3584h case   11:*/		regs.R4 = regs.R21;
		/* 820D3584h case   11:*/		return 0x820D3588;
		  /* 820D3588h */ case   12:  		/* bl 462128 */
		/* 820D3588h case   12:*/		regs.LR = 0x820D358C; return 0x821442B8;
		/* 820D3588h case   12:*/		return 0x820D358C;
		  /* 820D358Ch */ case   13:  		/* b 152 */
		/* 820D358Ch case   13:*/		return 0x820D3624;
		/* 820D358Ch case   13:*/		return 0x820D3590;
	}
	return 0x820D3590;
} // Block from 820D3558h-820D3590h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D3590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3590);
		  /* 820D3590h */ case    0:  		/* mr R3, R18 */
		/* 820D3590h case    0:*/		regs.R3 = regs.R18;
		/* 820D3590h case    0:*/		return 0x820D3594;
		  /* 820D3594h */ case    1:  		/* b 144 */
		/* 820D3594h case    1:*/		return 0x820D3624;
		/* 820D3594h case    1:*/		return 0x820D3598;
	}
	return 0x820D3598;
} // Block from 820D3590h-820D3598h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3598);
		  /* 820D3598h */ case    0:  		/* mr R31, R18 */
		/* 820D3598h case    0:*/		regs.R31 = regs.R18;
		/* 820D3598h case    0:*/		return 0x820D359C;
	}
	return 0x820D359C;
} // Block from 820D3598h-820D359Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D359Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D359C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D359C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D359C);
		  /* 820D359Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820D359Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D359Ch case    0:*/		return 0x820D35A0;
		  /* 820D35A0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D35A0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D35AC;  }
		/* 820D35A0h case    1:*/		return 0x820D35A4;
		  /* 820D35A4h */ case    2:  		/* li R3, 0 */
		/* 820D35A4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820D35A4h case    2:*/		return 0x820D35A8;
		  /* 820D35A8h */ case    3:  		/* b 124 */
		/* 820D35A8h case    3:*/		return 0x820D3624;
		/* 820D35A8h case    3:*/		return 0x820D35AC;
	}
	return 0x820D35AC;
} // Block from 820D359Ch-820D35ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D35ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D35AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D35AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D35AC);
		  /* 820D35ACh */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D35ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D35ACh case    0:*/		return 0x820D35B0;
		  /* 820D35B0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D35B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D35B0h case    1:*/		return 0x820D35B4;
		  /* 820D35B4h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820D35B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D35BC;  }
		/* 820D35B4h case    2:*/		return 0x820D35B8;
	}
	return 0x820D35B8;
} // Block from 820D35ACh-820D35B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D35B8h
// Function '?DecodeConstantTable@CUAssembler@D3DXShader@@IAAHPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D35B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D35B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D35B8);
		  /* 820D35B8h */ case    0:  		/* stw R11, <#[R31 + 44]> */
		/* 820D35B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820D35B8h case    0:*/		return 0x820D35BC;
	}
	return 0x820D35BC;
} // Block from 820D35B8h-820D35BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D35BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D35BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D35BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D35BC);
		  /* 820D35BCh */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 820D35BCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820D35BCh case    0:*/		return 0x820D35C0;
		  /* 820D35C0h */ case    1:  		/* bc 12, CR6_EQ, 96 */
		/* 820D35C0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3620;  }
		/* 820D35C0h case    1:*/		return 0x820D35C4;
		  /* 820D35C4h */ case    2:  		/* lwz R11, <#[R19 + 40]> */
		/* 820D35C4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000028) );
		/* 820D35C4h case    2:*/		return 0x820D35C8;
		  /* 820D35C8h */ case    3:  		/* stw R11, <#[R31 + 40]> */
		/* 820D35C8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820D35C8h case    3:*/		return 0x820D35CC;
		  /* 820D35CCh */ case    4:  		/* lwz R11, <#[R1 + 112]> */
		/* 820D35CCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D35CCh case    4:*/		return 0x820D35D0;
		  /* 820D35D0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820D35D0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D35D0h case    5:*/		return 0x820D35D4;
		  /* 820D35D4h */ case    6:  		/* stw R18, <#[R19 + 40]> */
		/* 820D35D4h case    6:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R19 + 0x00000028) );
		/* 820D35D4h case    6:*/		return 0x820D35D8;
		  /* 820D35D8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820D35D8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D35EC;  }
		/* 820D35D8h case    7:*/		return 0x820D35DC;
		  /* 820D35DCh */ case    8:  		/* lwz R11, <#[R19 + 24]> */
		/* 820D35DCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000018) );
		/* 820D35DCh case    8:*/		return 0x820D35E0;
		  /* 820D35E0h */ case    9:  		/* addi R11, R11, 1 */
		/* 820D35E0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D35E0h case    9:*/		return 0x820D35E4;
		  /* 820D35E4h */ case   10:  		/* stw R11, <#[R31 + 24]> */
		/* 820D35E4h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820D35E4h case   10:*/		return 0x820D35E8;
		  /* 820D35E8h */ case   11:  		/* b 56 */
		/* 820D35E8h case   11:*/		return 0x820D3620;
		/* 820D35E8h case   11:*/		return 0x820D35EC;
	}
	return 0x820D35EC;
} // Block from 820D35BCh-820D35ECh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D35ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D35EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D35EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D35EC);
		  /* 820D35ECh */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820D35ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820D35ECh case    0:*/		return 0x820D35F0;
		  /* 820D35F0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D35F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D35F0h case    1:*/		return 0x820D35F4;
		  /* 820D35F4h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 820D35F4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D3620;  }
		/* 820D35F4h case    2:*/		return 0x820D35F8;
		  /* 820D35F8h */ case    3:  		/* lwz R11, <#[R31 + 40]> */
		/* 820D35F8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820D35F8h case    3:*/		return 0x820D35FC;
		  /* 820D35FCh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820D35FCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D35FCh case    4:*/		return 0x820D3600;
		  /* 820D3600h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 820D3600h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D3620;  }
		/* 820D3600h case    5:*/		return 0x820D3604;
		  /* 820D3604h */ case    6:  		/* lwz R11, <#[R11 + 16]> */
		/* 820D3604h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820D3604h case    6:*/		return 0x820D3608;
		  /* 820D3608h */ case    7:  		/* cmplwi CR6, R11, 15 */
		/* 820D3608h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 820D3608h case    7:*/		return 0x820D360C;
		  /* 820D360Ch */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 820D360Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820D3620;  }
		/* 820D360Ch case    8:*/		return 0x820D3610;
		  /* 820D3610h */ case    9:  		/* lis R11, -32255 */
		/* 820D3610h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3610h case    9:*/		return 0x820D3614;
		  /* 820D3614h */ case   10:  		/* mr R3, R17 */
		/* 820D3614h case   10:*/		regs.R3 = regs.R17;
		/* 820D3614h case   10:*/		return 0x820D3618;
		  /* 820D3618h */ case   11:  		/* addi R4, R11, 24968 */
		/* 820D3618h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6188);
		/* 820D3618h case   11:*/		return 0x820D361C;
		  /* 820D361Ch */ case   12:  		/* bl -11572 */
		/* 820D361Ch case   12:*/		regs.LR = 0x820D3620; return 0x820D08E8;
		/* 820D361Ch case   12:*/		return 0x820D3620;
	}
	return 0x820D3620;
} // Block from 820D35ECh-820D3620h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D3620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3620);
		  /* 820D3620h */ case    0:  		/* mr R3, R31 */
		/* 820D3620h case    0:*/		regs.R3 = regs.R31;
		/* 820D3620h case    0:*/		return 0x820D3624;
	}
	return 0x820D3624;
} // Block from 820D3620h-820D3624h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3624);
		  /* 820D3624h */ case    0:  		/* addi R1, R1, 592 */
		/* 820D3624h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x250);
		/* 820D3624h case    0:*/		return 0x820D3628;
		  /* 820D3628h */ case    1:  		/* b -271280 */
		/* 820D3628h case    1:*/		return 0x82091278;
		/* 820D3628h case    1:*/		return 0x820D362C;
		  /* 820D362Ch */ case    2:  		/* nop */
		/* 820D362Ch case    2:*/		cpu::op::nop();
		/* 820D362Ch case    2:*/		return 0x820D3630;
	}
	return 0x820D3630;
} // Block from 820D3624h-820D3630h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3630);
		  /* 820D3630h */ case    0:  		/* mfspr R12, LR */
		/* 820D3630h case    0:*/		regs.R12 = regs.LR;
		/* 820D3630h case    0:*/		return 0x820D3634;
		  /* 820D3634h */ case    1:  		/* bl -271328 */
		/* 820D3634h case    1:*/		regs.LR = 0x820D3638; return 0x82091254;
		/* 820D3634h case    1:*/		return 0x820D3638;
		  /* 820D3638h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820D3638h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820D3638h case    2:*/		return 0x820D363C;
		  /* 820D363Ch */ case    3:  		/* lwz R11, <#[R4 + 56]> */
		/* 820D363Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000038) );
		/* 820D363Ch case    3:*/		return 0x820D3640;
		  /* 820D3640h */ case    4:  		/* mr R27, R3 */
		/* 820D3640h case    4:*/		regs.R27 = regs.R3;
		/* 820D3640h case    4:*/		return 0x820D3644;
		  /* 820D3644h */ case    5:  		/* mr R30, R4 */
		/* 820D3644h case    5:*/		regs.R30 = regs.R4;
		/* 820D3644h case    5:*/		return 0x820D3648;
		  /* 820D3648h */ case    6:  		/* mr R29, R5 */
		/* 820D3648h case    6:*/		regs.R29 = regs.R5;
		/* 820D3648h case    6:*/		return 0x820D364C;
		  /* 820D364Ch */ case    7:  		/* cmplwi CR6, R11, 2 */
		/* 820D364Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820D364Ch case    7:*/		return 0x820D3650;
		  /* 820D3650h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 820D3650h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D3660;  }
		/* 820D3650h case    8:*/		return 0x820D3654;
		  /* 820D3654h */ case    9:  		/* mr R11, R4 */
		/* 820D3654h case    9:*/		regs.R11 = regs.R4;
		/* 820D3654h case    9:*/		return 0x820D3658;
		  /* 820D3658h */ case   10:  		/* mr R30, R5 */
		/* 820D3658h case   10:*/		regs.R30 = regs.R5;
		/* 820D3658h case   10:*/		return 0x820D365C;
		  /* 820D365Ch */ case   11:  		/* mr R29, R4 */
		/* 820D365Ch case   11:*/		regs.R29 = regs.R4;
		/* 820D365Ch case   11:*/		return 0x820D3660;
	}
	return 0x820D3660;
} // Block from 820D3630h-820D3660h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D3660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3660);
		  /* 820D3660h */ case    0:  		/* lwz R11, <#[R30 + 56]> */
		/* 820D3660h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 820D3660h case    0:*/		return 0x820D3664;
		  /* 820D3664h */ case    1:  		/* cmplwi CR6, R11, 2 */
		/* 820D3664h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820D3664h case    1:*/		return 0x820D3668;
		  /* 820D3668h */ case    2:  		/* bc 4, CR6_EQ, 1076 */
		/* 820D3668h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D3A9C;  }
		/* 820D3668h case    2:*/		return 0x820D366C;
		  /* 820D366Ch */ case    3:  		/* lwz R11, <#[R29 + 56]> */
		/* 820D366Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000038) );
		/* 820D366Ch case    3:*/		return 0x820D3670;
		  /* 820D3670h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820D3670h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820D3670h case    4:*/		return 0x820D3674;
		  /* 820D3674h */ case    5:  		/* bc 4, CR6_EQ, 1064 */
		/* 820D3674h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D3A9C;  }
		/* 820D3674h case    5:*/		return 0x820D3678;
		  /* 820D3678h */ case    6:  		/* lwz R28, <#[R29 + 64]> */
		/* 820D3678h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000040) );
		/* 820D3678h case    6:*/		return 0x820D367C;
		  /* 820D367Ch */ case    7:  		/* lwz R7, <#[R30 + 60]> */
		/* 820D367Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x0000003C) );
		/* 820D367Ch case    7:*/		return 0x820D3680;
		  /* 820D3680h */ case    8:  		/* cmplwi CR6, R28, 27 */
		/* 820D3680h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x0000001B);
		/* 820D3680h case    8:*/		return 0x820D3684;
		  /* 820D3684h */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 820D3684h case    9:*/		if ( regs.CR[6].lt ) { return 0x820D3694;  }
		/* 820D3684h case    9:*/		return 0x820D3688;
		  /* 820D3688h */ case   10:  		/* cmplwi CR6, R28, 34 */
		/* 820D3688h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000022);
		/* 820D3688h case   10:*/		return 0x820D368C;
		  /* 820D368Ch */ case   11:  		/* li R11, 1 */
		/* 820D368Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D368Ch case   11:*/		return 0x820D3690;
		  /* 820D3690h */ case   12:  		/* bc 4, CR6_GT, 8 */
		/* 820D3690h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820D3698;  }
		/* 820D3690h case   12:*/		return 0x820D3694;
	}
	return 0x820D3694;
} // Block from 820D3660h-820D3694h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D3694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3694);
		  /* 820D3694h */ case    0:  		/* li R11, 0 */
		/* 820D3694h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3694h case    0:*/		return 0x820D3698;
	}
	return 0x820D3698;
} // Block from 820D3694h-820D3698h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3698);
		  /* 820D3698h */ case    0:  		/* rlwinm R9, R11, 0, 24, 31 */
		/* 820D3698h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R11);
		/* 820D3698h case    0:*/		return 0x820D369C;
		  /* 820D369Ch */ case    1:  		/* cmplwi CR6, R28, 35 */
		/* 820D369Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000023);
		/* 820D369Ch case    1:*/		return 0x820D36A0;
		  /* 820D36A0h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 820D36A0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820D36B0;  }
		/* 820D36A0h case    2:*/		return 0x820D36A4;
		  /* 820D36A4h */ case    3:  		/* cmplwi CR6, R28, 39 */
		/* 820D36A4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000027);
		/* 820D36A4h case    3:*/		return 0x820D36A8;
		  /* 820D36A8h */ case    4:  		/* li R11, 1 */
		/* 820D36A8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D36A8h case    4:*/		return 0x820D36AC;
		  /* 820D36ACh */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820D36ACh case    5:*/		if ( !regs.CR[6].gt ) { return 0x820D36B4;  }
		/* 820D36ACh case    5:*/		return 0x820D36B0;
	}
	return 0x820D36B0;
} // Block from 820D3698h-820D36B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D36B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D36B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D36B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D36B0);
		  /* 820D36B0h */ case    0:  		/* li R11, 0 */
		/* 820D36B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D36B0h case    0:*/		return 0x820D36B4;
	}
	return 0x820D36B4;
} // Block from 820D36B0h-820D36B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D36B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D36B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D36B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D36B4);
		  /* 820D36B4h */ case    0:  		/* rlwinm R8, R11, 0, 24, 31 */
		/* 820D36B4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R11);
		/* 820D36B4h case    0:*/		return 0x820D36B8;
		  /* 820D36B8h */ case    1:  		/* cmplwi CR6, R7, 20 */
		/* 820D36B8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000014);
		/* 820D36B8h case    1:*/		return 0x820D36BC;
		  /* 820D36BCh */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 820D36BCh case    2:*/		if ( regs.CR[6].lt ) { return 0x820D36CC;  }
		/* 820D36BCh case    2:*/		return 0x820D36C0;
		  /* 820D36C0h */ case    3:  		/* cmplwi CR6, R7, 23 */
		/* 820D36C0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000017);
		/* 820D36C0h case    3:*/		return 0x820D36C4;
		  /* 820D36C4h */ case    4:  		/* li R11, 1 */
		/* 820D36C4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D36C4h case    4:*/		return 0x820D36C8;
		  /* 820D36C8h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820D36C8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820D36D0;  }
		/* 820D36C8h case    5:*/		return 0x820D36CC;
	}
	return 0x820D36CC;
} // Block from 820D36B4h-820D36CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D36CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D36CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D36CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D36CC);
		  /* 820D36CCh */ case    0:  		/* li R11, 0 */
		/* 820D36CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D36CCh case    0:*/		return 0x820D36D0;
	}
	return 0x820D36D0;
} // Block from 820D36CCh-820D36D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D36D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D36D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D36D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D36D0);
		  /* 820D36D0h */ case    0:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 820D36D0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 820D36D0h case    0:*/		return 0x820D36D4;
		  /* 820D36D4h */ case    1:  		/* cmplwi CR6, R7, 24 */
		/* 820D36D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000018);
		/* 820D36D4h case    1:*/		return 0x820D36D8;
		  /* 820D36D8h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 820D36D8h case    2:*/		if ( regs.CR[6].lt ) { return 0x820D36E8;  }
		/* 820D36D8h case    2:*/		return 0x820D36DC;
		  /* 820D36DCh */ case    3:  		/* cmplwi CR6, R7, 27 */
		/* 820D36DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000001B);
		/* 820D36DCh case    3:*/		return 0x820D36E0;
		  /* 820D36E0h */ case    4:  		/* li R11, 1 */
		/* 820D36E0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D36E0h case    4:*/		return 0x820D36E4;
		  /* 820D36E4h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820D36E4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820D36EC;  }
		/* 820D36E4h case    5:*/		return 0x820D36E8;
	}
	return 0x820D36E8;
} // Block from 820D36D0h-820D36E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D36E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D36E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D36E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D36E8);
		  /* 820D36E8h */ case    0:  		/* li R11, 0 */
		/* 820D36E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D36E8h case    0:*/		return 0x820D36EC;
	}
	return 0x820D36EC;
} // Block from 820D36E8h-820D36ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D36ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D36EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D36EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D36EC);
		  /* 820D36ECh */ case    0:  		/* rlwinm. R6, R9, 0, 24, 31 */
		/* 820D36ECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R6,regs.R9);
		/* 820D36ECh case    0:*/		return 0x820D36F0;
		  /* 820D36F0h */ case    1:  		/* rlwinm R9, R11, 0, 24, 31 */
		/* 820D36F0h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R11);
		/* 820D36F0h case    1:*/		return 0x820D36F4;
		  /* 820D36F4h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820D36F4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820D3704;  }
		/* 820D36F4h case    2:*/		return 0x820D36F8;
		  /* 820D36F8h */ case    3:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 820D36F8h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 820D36F8h case    3:*/		return 0x820D36FC;
		  /* 820D36FCh */ case    4:  		/* li R11, 0 */
		/* 820D36FCh case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D36FCh case    4:*/		return 0x820D3700;
		  /* 820D3700h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 820D3700h case    5:*/		if ( regs.CR[0].eq ) { return 0x820D3708;  }
		/* 820D3700h case    5:*/		return 0x820D3704;
	}
	return 0x820D3704;
} // Block from 820D36ECh-820D3704h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D3704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3704);
		  /* 820D3704h */ case    0:  		/* li R11, 1 */
		/* 820D3704h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D3704h case    0:*/		return 0x820D3708;
	}
	return 0x820D3708;
} // Block from 820D3704h-820D3708h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3708);
		  /* 820D3708h */ case    0:  		/* rlwinm. R8, R10, 0, 24, 31 */
		/* 820D3708h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R8,regs.R10);
		/* 820D3708h case    0:*/		return 0x820D370C;
		  /* 820D370Ch */ case    1:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 820D370Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 820D370Ch case    1:*/		return 0x820D3710;
		  /* 820D3710h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820D3710h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820D3720;  }
		/* 820D3710h case    2:*/		return 0x820D3714;
		  /* 820D3714h */ case    3:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 820D3714h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 820D3714h case    3:*/		return 0x820D3718;
		  /* 820D3718h */ case    4:  		/* li R11, 0 */
		/* 820D3718h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3718h case    4:*/		return 0x820D371C;
		  /* 820D371Ch */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 820D371Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820D3724;  }
		/* 820D371Ch case    5:*/		return 0x820D3720;
	}
	return 0x820D3720;
} // Block from 820D3708h-820D3720h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D3720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3720);
		  /* 820D3720h */ case    0:  		/* li R11, 1 */
		/* 820D3720h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D3720h case    0:*/		return 0x820D3724;
	}
	return 0x820D3724;
} // Block from 820D3720h-820D3724h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3724);
		  /* 820D3724h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 820D3724h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 820D3724h case    0:*/		return 0x820D3728;
		  /* 820D3728h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820D3728h case    1:*/		if ( regs.CR[0].eq ) { return 0x820D3740;  }
		/* 820D3728h case    1:*/		return 0x820D372C;
		  /* 820D372Ch */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 820D372Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820D372Ch case    2:*/		return 0x820D3730;
		  /* 820D3730h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820D3730h case    3:*/		if ( regs.CR[0].eq ) { return 0x820D3740;  }
		/* 820D3730h case    3:*/		return 0x820D3734;
		  /* 820D3734h */ case    4:  		/* lis R11, -32255 */
		/* 820D3734h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3734h case    4:*/		return 0x820D3738;
		  /* 820D3738h */ case    5:  		/* addi R4, R11, 25992 */
		/* 820D3738h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6588);
		/* 820D3738h case    5:*/		return 0x820D373C;
		  /* 820D373Ch */ case    6:  		/* b 872 */
		/* 820D373Ch case    6:*/		return 0x820D3AA4;
		/* 820D373Ch case    6:*/		return 0x820D3740;
	}
	return 0x820D3740;
} // Block from 820D3724h-820D3740h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3740);
		  /* 820D3740h */ case    0:  		/* cmplwi CR6, R28, 23 */
		/* 820D3740h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000017);
		/* 820D3740h case    0:*/		return 0x820D3744;
		  /* 820D3744h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820D3744h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3764;  }
		/* 820D3744h case    1:*/		return 0x820D3748;
		  /* 820D3748h */ case    2:  		/* cmplwi CR6, R28, 24 */
		/* 820D3748h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000018);
		/* 820D3748h case    2:*/		return 0x820D374C;
		  /* 820D374Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820D374Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820D3764;  }
		/* 820D374Ch case    3:*/		return 0x820D3750;
		  /* 820D3750h */ case    4:  		/* cmplwi CR6, R28, 252 */
		/* 820D3750h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x000000FC);
		/* 820D3750h case    4:*/		return 0x820D3754;
		  /* 820D3754h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820D3754h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D3764;  }
		/* 820D3754h case    5:*/		return 0x820D3758;
		  /* 820D3758h */ case    6:  		/* cmplwi CR6, R28, 253 */
		/* 820D3758h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x000000FD);
		/* 820D3758h case    6:*/		return 0x820D375C;
		  /* 820D375Ch */ case    7:  		/* li R11, 0 */
		/* 820D375Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D375Ch case    7:*/		return 0x820D3760;
		  /* 820D3760h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 820D3760h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820D3768;  }
		/* 820D3760h case    8:*/		return 0x820D3764;
	}
	return 0x820D3764;
} // Block from 820D3740h-820D3764h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D3764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3764);
		  /* 820D3764h */ case    0:  		/* li R11, 1 */
		/* 820D3764h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D3764h case    0:*/		return 0x820D3768;
	}
	return 0x820D3768;
} // Block from 820D3764h-820D3768h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3768);
		  /* 820D3768h */ case    0:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 820D3768h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 820D3768h case    0:*/		return 0x820D376C;
		  /* 820D376Ch */ case    1:  		/* cmplwi CR6, R7, 29 */
		/* 820D376Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000001D);
		/* 820D376Ch case    1:*/		return 0x820D3770;
		  /* 820D3770h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820D3770h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D3780;  }
		/* 820D3770h case    2:*/		return 0x820D3774;
		  /* 820D3774h */ case    3:  		/* cmplwi CR6, R7, 244 */
		/* 820D3774h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x000000F4);
		/* 820D3774h case    3:*/		return 0x820D3778;
		  /* 820D3778h */ case    4:  		/* li R11, 0 */
		/* 820D3778h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3778h case    4:*/		return 0x820D377C;
		  /* 820D377Ch */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820D377Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D3784;  }
		/* 820D377Ch case    5:*/		return 0x820D3780;
	}
	return 0x820D3780;
} // Block from 820D3768h-820D3780h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D3780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3780);
		  /* 820D3780h */ case    0:  		/* li R11, 1 */
		/* 820D3780h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D3780h case    0:*/		return 0x820D3784;
	}
	return 0x820D3784;
} // Block from 820D3780h-820D3784h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3784);
		  /* 820D3784h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 820D3784h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 820D3784h case    0:*/		return 0x820D3788;
		  /* 820D3788h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820D3788h case    1:*/		if ( regs.CR[0].eq ) { return 0x820D37A0;  }
		/* 820D3788h case    1:*/		return 0x820D378C;
		  /* 820D378Ch */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 820D378Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820D378Ch case    2:*/		return 0x820D3790;
		  /* 820D3790h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820D3790h case    3:*/		if ( regs.CR[0].eq ) { return 0x820D37A0;  }
		/* 820D3790h case    3:*/		return 0x820D3794;
		  /* 820D3794h */ case    4:  		/* lis R11, -32255 */
		/* 820D3794h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3794h case    4:*/		return 0x820D3798;
		  /* 820D3798h */ case    5:  		/* addi R4, R11, 25948 */
		/* 820D3798h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x655C);
		/* 820D3798h case    5:*/		return 0x820D379C;
		  /* 820D379Ch */ case    6:  		/* b 776 */
		/* 820D379Ch case    6:*/		return 0x820D3AA4;
		/* 820D379Ch case    6:*/		return 0x820D37A0;
	}
	return 0x820D37A0;
} // Block from 820D3784h-820D37A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D37A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D37A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D37A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D37A0);
		  /* 820D37A0h */ case    0:  		/* lwz R31, <#[R30 + 112]> */
		/* 820D37A0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000070) );
		/* 820D37A0h case    0:*/		return 0x820D37A4;
		  /* 820D37A4h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820D37A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D37A4h case    1:*/		return 0x820D37A8;
		  /* 820D37A8h */ case    2:  		/* bc 12, CR6_EQ, 364 */
		/* 820D37A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D3914;  }
		/* 820D37A8h case    2:*/		return 0x820D37AC;
		  /* 820D37ACh */ case    3:  		/* lwz R10, <#[R29 + 104]> */
		/* 820D37ACh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000068) );
		/* 820D37ACh case    3:*/		return 0x820D37B0;
		  /* 820D37B0h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820D37B0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D37B0h case    4:*/		return 0x820D37B4;
		  /* 820D37B4h */ case    5:  		/* bc 12, CR6_EQ, 352 */
		/* 820D37B4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D3914;  }
		/* 820D37B4h case    5:*/		return 0x820D37B8;
		  /* 820D37B8h */ case    6:  		/* li R6, 0 */
		/* 820D37B8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820D37B8h case    6:*/		return 0x820D37BC;
		  /* 820D37BCh */ case    7:  		/* cmplwi CR6, R28, 241 */
		/* 820D37BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x000000F1);
		/* 820D37BCh case    7:*/		return 0x820D37C0;
		  /* 820D37C0h */ case    8:  		/* bc 12, CR6_EQ, 68 */
		/* 820D37C0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D3804;  }
		/* 820D37C0h case    8:*/		return 0x820D37C4;
		  /* 820D37C4h */ case    9:  		/* cmplwi CR6, R28, 243 */
		/* 820D37C4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x000000F3);
		/* 820D37C4h case    9:*/		return 0x820D37C8;
		  /* 820D37C8h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 820D37C8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D37EC;  }
		/* 820D37C8h case   10:*/		return 0x820D37CC;
		  /* 820D37CCh */ case   11:  		/* cmplwi CR6, R28, 251 */
		/* 820D37CCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x000000FB);
		/* 820D37CCh case   11:*/		return 0x820D37D0;
		  /* 820D37D0h */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 820D37D0h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820D37DC;  }
		/* 820D37D0h case   12:*/		return 0x820D37D4;
		  /* 820D37D4h */ case   13:  		/* cmplwi CR6, R28, 253 */
		/* 820D37D4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x000000FD);
		/* 820D37D4h case   13:*/		return 0x820D37D8;
		  /* 820D37D8h */ case   14:  		/* bc 4, CR6_GT, 20 */
		/* 820D37D8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820D37EC;  }
		/* 820D37D8h case   14:*/		return 0x820D37DC;
	}
	return 0x820D37DC;
} // Block from 820D37A0h-820D37DCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D37DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D37DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D37DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D37DC);
		  /* 820D37DCh */ case    0:  		/* lis R11, -32217 */
		/* 820D37DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820D37DCh case    0:*/		return 0x820D37E0;
		  /* 820D37E0h */ case    1:  		/* addi R11, R11, 11384 */
		/* 820D37E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2C78);
		/* 820D37E0h case    1:*/		return 0x820D37E4;
		  /* 820D37E4h */ case    2:  		/* lbzx R6, <#[R28 + R11]> */
		/* 820D37E4h case    2:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820D37E4h case    2:*/		return 0x820D37E8;
		  /* 820D37E8h */ case    3:  		/* b 8 */
		/* 820D37E8h case    3:*/		return 0x820D37F0;
		/* 820D37E8h case    3:*/		return 0x820D37EC;
	}
	return 0x820D37EC;
} // Block from 820D37DCh-820D37ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D37ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D37EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D37EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D37EC);
		  /* 820D37ECh */ case    0:  		/* li R6, 2 */
		/* 820D37ECh case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820D37ECh case    0:*/		return 0x820D37F0;
	}
	return 0x820D37F0;
} // Block from 820D37ECh-820D37F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D37F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D37F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D37F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D37F0);
		  /* 820D37F0h */ case    0:  		/* cmplwi CR6, R6, 4 */
		/* 820D37F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000004);
		/* 820D37F0h case    0:*/		return 0x820D37F4;
		  /* 820D37F4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D37F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3804;  }
		/* 820D37F4h case    1:*/		return 0x820D37F8;
		  /* 820D37F8h */ case    2:  		/* lis R11, -32255 */
		/* 820D37F8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D37F8h case    2:*/		return 0x820D37FC;
		  /* 820D37FCh */ case    3:  		/* addi R5, R11, 25840 */
		/* 820D37FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x64F0);
		/* 820D37FCh case    3:*/		return 0x820D3800;
		  /* 820D3800h */ case    4:  		/* b 12 */
		/* 820D3800h case    4:*/		return 0x820D380C;
		/* 820D3800h case    4:*/		return 0x820D3804;
	}
	return 0x820D3804;
} // Block from 820D37F0h-820D3804h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3804);
		  /* 820D3804h */ case    0:  		/* lis R11, -32255 */
		/* 820D3804h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3804h case    0:*/		return 0x820D3808;
		  /* 820D3808h */ case    1:  		/* addi R5, R11, 25736 */
		/* 820D3808h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6488);
		/* 820D3808h case    1:*/		return 0x820D380C;
	}
	return 0x820D380C;
} // Block from 820D3804h-820D380Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D380Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D380C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D380C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D380C);
		  /* 820D380Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820D380Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820D380Ch case    0:*/		return 0x820D3810;
		  /* 820D3810h */ case    1:  		/* lwz R9, <#[R10 + 16]> */
		/* 820D3810h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820D3810h case    1:*/		return 0x820D3814;
		  /* 820D3814h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 820D3814h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D3814h case    2:*/		return 0x820D3818;
		  /* 820D3818h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820D3818h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D3830;  }
		/* 820D3818h case    3:*/		return 0x820D381C;
		  /* 820D381Ch */ case    4:  		/* lis R11, -32255 */
		/* 820D381Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D381Ch case    4:*/		return 0x820D3820;
		  /* 820D3820h */ case    5:  		/* addi R4, R11, 25708 */
		/* 820D3820h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x646C);
		/* 820D3820h case    5:*/		return 0x820D3824;
		  /* 820D3824h */ case    6:  		/* mr R3, R27 */
		/* 820D3824h case    6:*/		regs.R3 = regs.R27;
		/* 820D3824h case    6:*/		return 0x820D3828;
		  /* 820D3828h */ case    7:  		/* bl -12096 */
		/* 820D3828h case    7:*/		regs.LR = 0x820D382C; return 0x820D08E8;
		/* 820D3828h case    7:*/		return 0x820D382C;
		  /* 820D382Ch */ case    8:  		/* b 640 */
		/* 820D382Ch case    8:*/		return 0x820D3AAC;
		/* 820D382Ch case    8:*/		return 0x820D3830;
	}
	return 0x820D3830;
} // Block from 820D380Ch-820D3830h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D3830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3830);
		  /* 820D3830h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820D3830h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820D3830h case    0:*/		return 0x820D3834;
		  /* 820D3834h */ case    1:  		/* lwz R9, <#[R10 + 24]> */
		/* 820D3834h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 820D3834h case    1:*/		return 0x820D3838;
		  /* 820D3838h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 820D3838h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D3838h case    2:*/		return 0x820D383C;
		  /* 820D383Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820D383Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820D384C;  }
		/* 820D383Ch case    3:*/		return 0x820D3840;
		  /* 820D3840h */ case    4:  		/* lis R11, -32255 */
		/* 820D3840h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3840h case    4:*/		return 0x820D3844;
		  /* 820D3844h */ case    5:  		/* addi R4, R11, 25676 */
		/* 820D3844h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x644C);
		/* 820D3844h case    5:*/		return 0x820D3848;
		  /* 820D3848h */ case    6:  		/* b -36 */
		/* 820D3848h case    6:*/		return 0x820D3824;
		/* 820D3848h case    6:*/		return 0x820D384C;
	}
	return 0x820D384C;
} // Block from 820D3830h-820D384Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D384Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D384C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D384C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D384C);
		  /* 820D384Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820D384Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820D384Ch case    0:*/		return 0x820D3850;
		  /* 820D3850h */ case    1:  		/* lwz R9, <#[R10 + 20]> */
		/* 820D3850h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 820D3850h case    1:*/		return 0x820D3854;
		  /* 820D3854h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 820D3854h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D3854h case    2:*/		return 0x820D3858;
		  /* 820D3858h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820D3858h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D3868;  }
		/* 820D3858h case    3:*/		return 0x820D385C;
		  /* 820D385Ch */ case    4:  		/* lis R11, -32255 */
		/* 820D385Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D385Ch case    4:*/		return 0x820D3860;
		  /* 820D3860h */ case    5:  		/* addi R4, R11, 25640 */
		/* 820D3860h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6428);
		/* 820D3860h case    5:*/		return 0x820D3864;
		  /* 820D3864h */ case    6:  		/* b -64 */
		/* 820D3864h case    6:*/		return 0x820D3824;
		/* 820D3864h case    6:*/		return 0x820D3868;
	}
	return 0x820D3868;
} // Block from 820D384Ch-820D3868h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3868);
		  /* 820D3868h */ case    0:  		/* lwz R10, <#[R10 + 40]> */
		/* 820D3868h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 820D3868h case    0:*/		return 0x820D386C;
		  /* 820D386Ch */ case    1:  		/* lwz R11, <#[R31 + 40]> */
		/* 820D386Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820D386Ch case    1:*/		return 0x820D3870;
		  /* 820D3870h */ case    2:  		/* addic R9, R10, -1 */
		/* 820D3870h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 820D3870h case    2:*/		return 0x820D3874;
		  /* 820D3874h */ case    3:  		/* subfe R9, R9, R10 */
		/* 820D3874h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 820D3874h case    3:*/		return 0x820D3878;
		  /* 820D3878h */ case    4:  		/* addic R8, R11, -1 */
		/* 820D3878h case    4:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 820D3878h case    4:*/		return 0x820D387C;
		  /* 820D387Ch */ case    5:  		/* subfe R8, R8, R11 */
		/* 820D387Ch case    5:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 820D387Ch case    5:*/		return 0x820D3880;
		  /* 820D3880h */ case    6:  		/* xor. R9, R9, R8 */
		/* 820D3880h case    6:*/		cpu::op::xor<1>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820D3880h case    6:*/		return 0x820D3884;
		  /* 820D3884h */ case    7:  		/* bc 4, CR0_EQ, 132 */
		/* 820D3884h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820D3908;  }
		/* 820D3884h case    7:*/		return 0x820D3888;
		  /* 820D3888h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820D3888h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D3888h case    8:*/		return 0x820D388C;
		  /* 820D388Ch */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 820D388Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820D38A0;  }
		/* 820D388Ch case    9:*/		return 0x820D3890;
		  /* 820D3890h */ case   10:  		/* lwz R11, <#[R11 + 16]> */
		/* 820D3890h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820D3890h case   10:*/		return 0x820D3894;
		  /* 820D3894h */ case   11:  		/* lwz R10, <#[R10 + 16]> */
		/* 820D3894h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820D3894h case   11:*/		return 0x820D3898;
		  /* 820D3898h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820D3898h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D3898h case   12:*/		return 0x820D389C;
		  /* 820D389Ch */ case   13:  		/* bc 4, CR6_EQ, 108 */
		/* 820D389Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820D3908;  }
		/* 820D389Ch case   13:*/		return 0x820D38A0;
	}
	return 0x820D38A0;
} // Block from 820D3868h-820D38A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D38A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D38A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D38A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D38A0);
		  /* 820D38A0h */ case    0:  		/* li R11, 0 */
		/* 820D38A0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D38A0h case    0:*/		return 0x820D38A4;
		  /* 820D38A4h */ case    1:  		/* cmplwi CR6, R7, 11 */
		/* 820D38A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000000B);
		/* 820D38A4h case    1:*/		return 0x820D38A8;
		  /* 820D38A8h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 820D38A8h case    2:*/		if ( regs.CR[6].lt ) { return 0x820D38B8;  }
		/* 820D38A8h case    2:*/		return 0x820D38AC;
		  /* 820D38ACh */ case    3:  		/* cmplwi CR6, R7, 14 */
		/* 820D38ACh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000000E);
		/* 820D38ACh case    3:*/		return 0x820D38B0;
		  /* 820D38B0h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 820D38B0h case    4:*/		if ( regs.CR[6].gt ) { return 0x820D38B8;  }
		/* 820D38B0h case    4:*/		return 0x820D38B4;
		  /* 820D38B4h */ case    5:  		/* li R11, 5 */
		/* 820D38B4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820D38B4h case    5:*/		return 0x820D38B8;
	}
	return 0x820D38B8;
} // Block from 820D38A0h-820D38B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D38B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D38B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D38B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D38B8);
		  /* 820D38B8h */ case    0:  		/* lis R10, -32255 */
		/* 820D38B8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D38B8h case    0:*/		return 0x820D38BC;
		  /* 820D38BCh */ case    1:  		/* add R11, R11, R6 */
		/* 820D38BCh case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 820D38BCh case    1:*/		return 0x820D38C0;
		  /* 820D38C0h */ case    2:  		/* addi R10, R10, 25628 */
		/* 820D38C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x641C);
		/* 820D38C0h case    2:*/		return 0x820D38C4;
		  /* 820D38C4h */ case    3:  		/* li R4, 0 */
		/* 820D38C4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D38C4h case    3:*/		return 0x820D38C8;
		  /* 820D38C8h */ case    4:  		/* mr R3, R29 */
		/* 820D38C8h case    4:*/		regs.R3 = regs.R29;
		/* 820D38C8h case    4:*/		return 0x820D38CC;
		  /* 820D38CCh */ case    5:  		/* lbzx R5, <#[R11 + R10]> */
		/* 820D38CCh case    5:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820D38CCh case    5:*/		return 0x820D38D0;
		  /* 820D38D0h */ case    6:  		/* bl -18432 */
		/* 820D38D0h case    6:*/		regs.LR = 0x820D38D4; return 0x820CF0D0;
		/* 820D38D0h case    6:*/		return 0x820D38D4;
		  /* 820D38D4h */ case    7:  		/* lwz R11, <#[R31 + 36]> */
		/* 820D38D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820D38D4h case    7:*/		return 0x820D38D8;
		  /* 820D38D8h */ case    8:  		/* and R10, R3, R5 */
		/* 820D38D8h case    8:*/		cpu::op::and<0>(regs,&regs.R10,regs.R3,regs.R5);
		/* 820D38D8h case    8:*/		return 0x820D38DC;
		  /* 820D38DCh */ case    9:  		/* and R11, R11, R5 */
		/* 820D38DCh case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 820D38DCh case    9:*/		return 0x820D38E0;
		  /* 820D38E0h */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 820D38E0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820D38E0h case   10:*/		return 0x820D38E4;
		  /* 820D38E4h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 820D38E4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820D38F4;  }
		/* 820D38E4h case   11:*/		return 0x820D38E8;
		  /* 820D38E8h */ case   12:  		/* lis R11, -32255 */
		/* 820D38E8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D38E8h case   12:*/		return 0x820D38EC;
		  /* 820D38ECh */ case   13:  		/* addi R4, R11, 25528 */
		/* 820D38ECh case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x63B8);
		/* 820D38ECh case   13:*/		return 0x820D38F0;
		  /* 820D38F0h */ case   14:  		/* b 436 */
		/* 820D38F0h case   14:*/		return 0x820D3AA4;
		/* 820D38F0h case   14:*/		return 0x820D38F4;
	}
	return 0x820D38F4;
} // Block from 820D38B8h-820D38F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D38F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D38F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D38F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D38F4);
		  /* 820D38F4h */ case    0:  		/* cmplwi CR6, R6, 4 */
		/* 820D38F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000004);
		/* 820D38F4h case    0:*/		return 0x820D38F8;
		  /* 820D38F8h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820D38F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3914;  }
		/* 820D38F8h case    1:*/		return 0x820D38FC;
		  /* 820D38FCh */ case    2:  		/* lis R11, -32255 */
		/* 820D38FCh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D38FCh case    2:*/		return 0x820D3900;
		  /* 820D3900h */ case    3:  		/* addi R4, R11, 25424 */
		/* 820D3900h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6350);
		/* 820D3900h case    3:*/		return 0x820D3904;
		  /* 820D3904h */ case    4:  		/* b 416 */
		/* 820D3904h case    4:*/		return 0x820D3AA4;
		/* 820D3904h case    4:*/		return 0x820D3908;
	}
	return 0x820D3908;
} // Block from 820D38F4h-820D3908h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3908);
		  /* 820D3908h */ case    0:  		/* lis R11, -32255 */
		/* 820D3908h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3908h case    0:*/		return 0x820D390C;
		  /* 820D390Ch */ case    1:  		/* addi R4, R11, 25372 */
		/* 820D390Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x631C);
		/* 820D390Ch case    1:*/		return 0x820D3910;
		  /* 820D3910h */ case    2:  		/* b -236 */
		/* 820D3910h case    2:*/		return 0x820D3824;
		/* 820D3910h case    2:*/		return 0x820D3914;
	}
	return 0x820D3914;
} // Block from 820D3908h-820D3914h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3914);
		  /* 820D3914h */ case    0:  		/* lwz R11, <#[R30 + 100]> */
		/* 820D3914h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000064) );
		/* 820D3914h case    0:*/		return 0x820D3918;
		  /* 820D3918h */ case    1:  		/* lis R9, 3328 */
		/* 820D3918h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xD00);
		/* 820D3918h case    1:*/		return 0x820D391C;
		  /* 820D391Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820D391Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D391Ch case    2:*/		return 0x820D3920;
		  /* 820D3920h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 820D3920h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D3940;  }
		/* 820D3920h case    3:*/		return 0x820D3924;
		  /* 820D3924h */ case    4:  		/* lwz R11, <#[R11 + 20]> */
		/* 820D3924h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820D3924h case    4:*/		return 0x820D3928;
		  /* 820D3928h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 820D3928h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D3928h case    5:*/		return 0x820D392C;
		  /* 820D392Ch */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 820D392Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x820D3938;  }
		/* 820D392Ch case    6:*/		return 0x820D3930;
		  /* 820D3930h */ case    7:  		/* li R10, -1 */
		/* 820D3930h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820D3930h case    7:*/		return 0x820D3934;
		  /* 820D3934h */ case    8:  		/* b 16 */
		/* 820D3934h case    8:*/		return 0x820D3944;
		/* 820D3934h case    8:*/		return 0x820D3938;
	}
	return 0x820D3938;
} // Block from 820D3914h-820D3938h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D3938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3938);
		  /* 820D3938h */ case    0:  		/* li R10, 1 */
		/* 820D3938h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820D3938h case    0:*/		return 0x820D393C;
		  /* 820D393Ch */ case    1:  		/* b 8 */
		/* 820D393Ch case    1:*/		return 0x820D3944;
		/* 820D393Ch case    1:*/		return 0x820D3940;
	}
	return 0x820D3940;
} // Block from 820D3938h-820D3940h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3940);
		  /* 820D3940h */ case    0:  		/* li R10, 0 */
		/* 820D3940h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820D3940h case    0:*/		return 0x820D3944;
	}
	return 0x820D3944;
} // Block from 820D3940h-820D3944h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3944);
		  /* 820D3944h */ case    0:  		/* lwz R11, <#[R29 + 100]> */
		/* 820D3944h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000064) );
		/* 820D3944h case    0:*/		return 0x820D3948;
		  /* 820D3948h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D3948h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D3948h case    1:*/		return 0x820D394C;
		  /* 820D394Ch */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820D394Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820D396C;  }
		/* 820D394Ch case    2:*/		return 0x820D3950;
		  /* 820D3950h */ case    3:  		/* lwz R11, <#[R11 + 20]> */
		/* 820D3950h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820D3950h case    3:*/		return 0x820D3954;
		  /* 820D3954h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 820D3954h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D3954h case    4:*/		return 0x820D3958;
		  /* 820D3958h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3958h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D3964;  }
		/* 820D3958h case    5:*/		return 0x820D395C;
		  /* 820D395Ch */ case    6:  		/* li R11, -1 */
		/* 820D395Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D395Ch case    6:*/		return 0x820D3960;
		  /* 820D3960h */ case    7:  		/* b 16 */
		/* 820D3960h case    7:*/		return 0x820D3970;
		/* 820D3960h case    7:*/		return 0x820D3964;
	}
	return 0x820D3964;
} // Block from 820D3944h-820D3964h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D3964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3964);
		  /* 820D3964h */ case    0:  		/* li R11, 1 */
		/* 820D3964h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D3964h case    0:*/		return 0x820D3968;
		  /* 820D3968h */ case    1:  		/* b 8 */
		/* 820D3968h case    1:*/		return 0x820D3970;
		/* 820D3968h case    1:*/		return 0x820D396C;
	}
	return 0x820D396C;
} // Block from 820D3964h-820D396Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D396Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D396C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D396C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D396C);
		  /* 820D396Ch */ case    0:  		/* li R11, 0 */
		/* 820D396Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D396Ch case    0:*/		return 0x820D3970;
	}
	return 0x820D3970;
} // Block from 820D396Ch-820D3970h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3970);
		  /* 820D3970h */ case    0:  		/* cmpw CR6, R10, R11 */
		/* 820D3970h case    0:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 820D3970h case    0:*/		return 0x820D3974;
		  /* 820D3974h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820D3974h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3984;  }
		/* 820D3974h case    1:*/		return 0x820D3978;
		  /* 820D3978h */ case    2:  		/* lis R11, -32255 */
		/* 820D3978h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3978h case    2:*/		return 0x820D397C;
		  /* 820D397Ch */ case    3:  		/* addi R4, R11, 25312 */
		/* 820D397Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x62E0);
		/* 820D397Ch case    3:*/		return 0x820D3980;
		  /* 820D3980h */ case    4:  		/* b 292 */
		/* 820D3980h case    4:*/		return 0x820D3AA4;
		/* 820D3980h case    4:*/		return 0x820D3984;
	}
	return 0x820D3984;
} // Block from 820D3970h-820D3984h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3984);
		  /* 820D3984h */ case    0:  		/* lwz R7, <#[R30 + 92]> */
		/* 820D3984h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x0000005C) );
		/* 820D3984h case    0:*/		return 0x820D3988;
		  /* 820D3988h */ case    1:  		/* lwz R8, <#[R29 + 96]> */
		/* 820D3988h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000060) );
		/* 820D3988h case    1:*/		return 0x820D398C;
		  /* 820D398Ch */ case    2:  		/* cmplwi CR6, R7, 0 */
		/* 820D398Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820D398Ch case    2:*/		return 0x820D3990;
		  /* 820D3990h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820D3990h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D39A4;  }
		/* 820D3990h case    3:*/		return 0x820D3994;
		  /* 820D3994h */ case    4:  		/* lwz R11, <#[R7 + 16]> */
		/* 820D3994h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000010) );
		/* 820D3994h case    4:*/		return 0x820D3998;
		  /* 820D3998h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820D3998h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D3998h case    5:*/		return 0x820D399C;
		  /* 820D399Ch */ case    6:  		/* li R11, 1 */
		/* 820D399Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D399Ch case    6:*/		return 0x820D39A0;
		  /* 820D39A0h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 820D39A0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D39A8;  }
		/* 820D39A0h case    7:*/		return 0x820D39A4;
	}
	return 0x820D39A4;
} // Block from 820D3984h-820D39A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D39A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D39A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D39A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D39A4);
		  /* 820D39A4h */ case    0:  		/* li R11, 0 */
		/* 820D39A4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D39A4h case    0:*/		return 0x820D39A8;
	}
	return 0x820D39A8;
} // Block from 820D39A4h-820D39A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D39A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D39A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D39A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D39A8);
		  /* 820D39A8h */ case    0:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 820D39A8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 820D39A8h case    0:*/		return 0x820D39AC;
		  /* 820D39ACh */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 820D39ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820D39ACh case    1:*/		return 0x820D39B0;
		  /* 820D39B0h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820D39B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D39C4;  }
		/* 820D39B0h case    2:*/		return 0x820D39B4;
		  /* 820D39B4h */ case    3:  		/* lwz R11, <#[R7 + 16]> */
		/* 820D39B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000010) );
		/* 820D39B4h case    3:*/		return 0x820D39B8;
		  /* 820D39B8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820D39B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D39B8h case    4:*/		return 0x820D39BC;
		  /* 820D39BCh */ case    5:  		/* li R11, 1 */
		/* 820D39BCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D39BCh case    5:*/		return 0x820D39C0;
		  /* 820D39C0h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 820D39C0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D39C8;  }
		/* 820D39C0h case    6:*/		return 0x820D39C4;
	}
	return 0x820D39C4;
} // Block from 820D39A8h-820D39C4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D39C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D39C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D39C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D39C4);
		  /* 820D39C4h */ case    0:  		/* li R11, 0 */
		/* 820D39C4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D39C4h case    0:*/		return 0x820D39C8;
	}
	return 0x820D39C8;
} // Block from 820D39C4h-820D39C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D39C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D39C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D39C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D39C8);
		  /* 820D39C8h */ case    0:  		/* rlwinm R6, R11, 0, 24, 31 */
		/* 820D39C8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R6,regs.R11);
		/* 820D39C8h case    0:*/		return 0x820D39CC;
		  /* 820D39CCh */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 820D39CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D39CCh case    1:*/		return 0x820D39D0;
		  /* 820D39D0h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820D39D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D39E4;  }
		/* 820D39D0h case    2:*/		return 0x820D39D4;
		  /* 820D39D4h */ case    3:  		/* lwz R11, <#[R8 + 16]> */
		/* 820D39D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 820D39D4h case    3:*/		return 0x820D39D8;
		  /* 820D39D8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820D39D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D39D8h case    4:*/		return 0x820D39DC;
		  /* 820D39DCh */ case    5:  		/* li R11, 1 */
		/* 820D39DCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D39DCh case    5:*/		return 0x820D39E0;
		  /* 820D39E0h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 820D39E0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820D39E8;  }
		/* 820D39E0h case    6:*/		return 0x820D39E4;
	}
	return 0x820D39E4;
} // Block from 820D39C8h-820D39E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D39E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D39E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D39E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D39E4);
		  /* 820D39E4h */ case    0:  		/* li R11, 0 */
		/* 820D39E4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D39E4h case    0:*/		return 0x820D39E8;
	}
	return 0x820D39E8;
} // Block from 820D39E4h-820D39E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D39E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D39E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D39E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D39E8);
		  /* 820D39E8h */ case    0:  		/* rlwinm R9, R11, 0, 24, 31 */
		/* 820D39E8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R11);
		/* 820D39E8h case    0:*/		return 0x820D39EC;
		  /* 820D39ECh */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 820D39ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D39ECh case    1:*/		return 0x820D39F0;
		  /* 820D39F0h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820D39F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D3A04;  }
		/* 820D39F0h case    2:*/		return 0x820D39F4;
		  /* 820D39F4h */ case    3:  		/* lwz R11, <#[R8 + 16]> */
		/* 820D39F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 820D39F4h case    3:*/		return 0x820D39F8;
		  /* 820D39F8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820D39F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D39F8h case    4:*/		return 0x820D39FC;
		  /* 820D39FCh */ case    5:  		/* li R11, 1 */
		/* 820D39FCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D39FCh case    5:*/		return 0x820D3A00;
		  /* 820D3A00h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 820D3A00h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D3A08;  }
		/* 820D3A00h case    6:*/		return 0x820D3A04;
	}
	return 0x820D3A04;
} // Block from 820D39E8h-820D3A04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A04);
		  /* 820D3A04h */ case    0:  		/* li R11, 0 */
		/* 820D3A04h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3A04h case    0:*/		return 0x820D3A08;
	}
	return 0x820D3A08;
} // Block from 820D3A04h-820D3A08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A08);
		  /* 820D3A08h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 820D3A08h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 820D3A08h case    0:*/		return 0x820D3A0C;
		  /* 820D3A0Ch */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 820D3A0Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820D3A0Ch case    1:*/		return 0x820D3A10;
		  /* 820D3A10h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 820D3A10h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D3A38;  }
		/* 820D3A10h case    2:*/		return 0x820D3A14;
		  /* 820D3A14h */ case    3:  		/* rlwinm. R5, R9, 0, 24, 31 */
		/* 820D3A14h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R5,regs.R9);
		/* 820D3A14h case    3:*/		return 0x820D3A18;
		  /* 820D3A18h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 820D3A18h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D3A38;  }
		/* 820D3A18h case    4:*/		return 0x820D3A1C;
		  /* 820D3A1Ch */ case    5:  		/* lwz R7, <#[R7 + 24]> */
		/* 820D3A1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000018) );
		/* 820D3A1Ch case    5:*/		return 0x820D3A20;
		  /* 820D3A20h */ case    6:  		/* lwz R8, <#[R8 + 24]> */
		/* 820D3A20h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000018) );
		/* 820D3A20h case    6:*/		return 0x820D3A24;
		  /* 820D3A24h */ case    7:  		/* cmplw CR6, R7, R8 */
		/* 820D3A24h case    7:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820D3A24h case    7:*/		return 0x820D3A28;
		  /* 820D3A28h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 820D3A28h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D3A38;  }
		/* 820D3A28h case    8:*/		return 0x820D3A2C;
		  /* 820D3A2Ch */ case    9:  		/* lis R11, -32255 */
		/* 820D3A2Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3A2Ch case    9:*/		return 0x820D3A30;
		  /* 820D3A30h */ case   10:  		/* addi R4, R11, 25240 */
		/* 820D3A30h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6298);
		/* 820D3A30h case   10:*/		return 0x820D3A34;
		  /* 820D3A34h */ case   11:  		/* b 112 */
		/* 820D3A34h case   11:*/		return 0x820D3AA4;
		/* 820D3A34h case   11:*/		return 0x820D3A38;
	}
	return 0x820D3A38;
} // Block from 820D3A08h-820D3A38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A38);
		  /* 820D3A38h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820D3A38h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D3A38h case    0:*/		return 0x820D3A3C;
		  /* 820D3A3Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820D3A3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3A48;  }
		/* 820D3A3Ch case    1:*/		return 0x820D3A40;
		  /* 820D3A40h */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 820D3A40h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820D3A40h case    2:*/		return 0x820D3A44;
		  /* 820D3A44h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 820D3A44h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820D3A58;  }
		/* 820D3A44h case    3:*/		return 0x820D3A48;
	}
	return 0x820D3A48;
} // Block from 820D3A38h-820D3A48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A48);
		  /* 820D3A48h */ case    0:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 820D3A48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 820D3A48h case    0:*/		return 0x820D3A4C;
		  /* 820D3A4Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820D3A4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820D3A64;  }
		/* 820D3A4Ch case    1:*/		return 0x820D3A50;
		  /* 820D3A50h */ case    2:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 820D3A50h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 820D3A50h case    2:*/		return 0x820D3A54;
		  /* 820D3A54h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820D3A54h case    3:*/		if ( regs.CR[0].eq ) { return 0x820D3A64;  }
		/* 820D3A54h case    3:*/		return 0x820D3A58;
	}
	return 0x820D3A58;
} // Block from 820D3A48h-820D3A58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A58);
		  /* 820D3A58h */ case    0:  		/* lis R11, -32255 */
		/* 820D3A58h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3A58h case    0:*/		return 0x820D3A5C;
		  /* 820D3A5Ch */ case    1:  		/* addi R4, R11, 25112 */
		/* 820D3A5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6218);
		/* 820D3A5Ch case    1:*/		return 0x820D3A60;
		  /* 820D3A60h */ case    2:  		/* b 68 */
		/* 820D3A60h case    2:*/		return 0x820D3AA4;
		/* 820D3A60h case    2:*/		return 0x820D3A64;
	}
	return 0x820D3A64;
} // Block from 820D3A58h-820D3A64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A64);
		  /* 820D3A64h */ case    0:  		/* stw R28, <#[R30 + 64]> */
		/* 820D3A64h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000040) );
		/* 820D3A64h case    0:*/		return 0x820D3A68;
		  /* 820D3A68h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820D3A68h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D3A68h case    1:*/		return 0x820D3A6C;
		  /* 820D3A6Ch */ case    2:  		/* lwz R11, <#[R29 + 80]> */
		/* 820D3A6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000050) );
		/* 820D3A6Ch case    2:*/		return 0x820D3A70;
	}
	return 0x820D3A70;
} // Block from 820D3A64h-820D3A70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A70h
// Function '?DecodeRegister@CUAssembler@D3DXShader@@IAAPAVCNode@2@PAUD3DXTOKEN@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A70);
		  /* 820D3A70h */ case    0:  		/* stw R11, <#[R30 + 80]> */
		/* 820D3A70h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 820D3A70h case    0:*/		return 0x820D3A74;
		  /* 820D3A74h */ case    1:  		/* lwz R11, <#[R29 + 96]> */
		/* 820D3A74h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000060) );
		/* 820D3A74h case    1:*/		return 0x820D3A78;
		  /* 820D3A78h */ case    2:  		/* stw R11, <#[R30 + 96]> */
		/* 820D3A78h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000060) );
		/* 820D3A78h case    2:*/		return 0x820D3A7C;
		  /* 820D3A7Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3A7Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D3A88;  }
		/* 820D3A7Ch case    3:*/		return 0x820D3A80;
		  /* 820D3A80h */ case    4:  		/* lwz R11, <#[R29 + 104]> */
		/* 820D3A80h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000068) );
		/* 820D3A80h case    4:*/		return 0x820D3A84;
		  /* 820D3A84h */ case    5:  		/* stw R11, <#[R30 + 112]> */
		/* 820D3A84h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000070) );
		/* 820D3A84h case    5:*/		return 0x820D3A88;
	}
	return 0x820D3A88;
} // Block from 820D3A70h-820D3A88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A88);
		  /* 820D3A88h */ case    0:  		/* lwz R11, <#[R29 + 108]> */
		/* 820D3A88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000006C) );
		/* 820D3A88h case    0:*/		return 0x820D3A8C;
		  /* 820D3A8Ch */ case    1:  		/* li R10, 4 */
		/* 820D3A8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820D3A8Ch case    1:*/		return 0x820D3A90;
		  /* 820D3A90h */ case    2:  		/* stw R10, <#[R30 + 56]> */
		/* 820D3A90h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000038) );
		/* 820D3A90h case    2:*/		return 0x820D3A94;
		  /* 820D3A94h */ case    3:  		/* stw R11, <#[R30 + 116]> */
		/* 820D3A94h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000074) );
		/* 820D3A94h case    3:*/		return 0x820D3A98;
		  /* 820D3A98h */ case    4:  		/* b 20 */
		/* 820D3A98h case    4:*/		return 0x820D3AAC;
		/* 820D3A98h case    4:*/		return 0x820D3A9C;
	}
	return 0x820D3A9C;
} // Block from 820D3A88h-820D3A9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3A9C);
		  /* 820D3A9Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D3A9Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3A9Ch case    0:*/		return 0x820D3AA0;
		  /* 820D3AA0h */ case    1:  		/* addi R4, R11, 25040 */
		/* 820D3AA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x61D0);
		/* 820D3AA0h case    1:*/		return 0x820D3AA4;
	}
	return 0x820D3AA4;
} // Block from 820D3A9Ch-820D3AA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3AA4);
		  /* 820D3AA4h */ case    0:  		/* mr R3, R27 */
		/* 820D3AA4h case    0:*/		regs.R3 = regs.R27;
		/* 820D3AA4h case    0:*/		return 0x820D3AA8;
		  /* 820D3AA8h */ case    1:  		/* bl -12736 */
		/* 820D3AA8h case    1:*/		regs.LR = 0x820D3AAC; return 0x820D08E8;
		/* 820D3AA8h case    1:*/		return 0x820D3AAC;
	}
	return 0x820D3AAC;
} // Block from 820D3AA4h-820D3AACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3AAC);
		  /* 820D3AACh */ case    0:  		/* mr R3, R30 */
		/* 820D3AACh case    0:*/		regs.R3 = regs.R30;
		/* 820D3AACh case    0:*/		return 0x820D3AB0;
		  /* 820D3AB0h */ case    1:  		/* addi R1, R1, 160 */
		/* 820D3AB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820D3AB0h case    1:*/		return 0x820D3AB4;
		  /* 820D3AB4h */ case    2:  		/* b -272400 */
		/* 820D3AB4h case    2:*/		return 0x820912A4;
		/* 820D3AB4h case    2:*/		return 0x820D3AB8;
	}
	return 0x820D3AB8;
} // Block from 820D3AACh-820D3AB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3AB8);
		  /* 820D3AB8h */ case    0:  		/* mfspr R12, LR */
		/* 820D3AB8h case    0:*/		regs.R12 = regs.LR;
		/* 820D3AB8h case    0:*/		return 0x820D3ABC;
		  /* 820D3ABCh */ case    1:  		/* bl -272540 */
		/* 820D3ABCh case    1:*/		regs.LR = 0x820D3AC0; return 0x82091220;
		/* 820D3ABCh case    1:*/		return 0x820D3AC0;
		  /* 820D3AC0h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 820D3AC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 820D3AC0h case    2:*/		return 0x820D3AC4;
		  /* 820D3AC4h */ case    3:  		/* lwz R11, <#[R5 + 120]> */
		/* 820D3AC4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000078) );
		/* 820D3AC4h case    3:*/		return 0x820D3AC8;
		  /* 820D3AC8h */ case    4:  		/* li R25, 0 */
		/* 820D3AC8h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820D3AC8h case    4:*/		return 0x820D3ACC;
		  /* 820D3ACCh */ case    5:  		/* li R10, 1 */
		/* 820D3ACCh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820D3ACCh case    5:*/		return 0x820D3AD0;
		  /* 820D3AD0h */ case    6:  		/* stw R4, <#[R1 + 316]> */
		/* 820D3AD0h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000013C) );
		/* 820D3AD0h case    6:*/		return 0x820D3AD4;
		  /* 820D3AD4h */ case    7:  		/* mr R24, R3 */
		/* 820D3AD4h case    7:*/		regs.R24 = regs.R3;
		/* 820D3AD4h case    7:*/		return 0x820D3AD8;
		  /* 820D3AD8h */ case    8:  		/* stw R25, <#[R1 + 116]> */
		/* 820D3AD8h case    8:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3AD8h case    8:*/		return 0x820D3ADC;
		  /* 820D3ADCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820D3ADCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D3ADCh case    9:*/		return 0x820D3AE0;
		  /* 820D3AE0h */ case   10:  		/* stb R25, <#[R1 + 112]> */
		/* 820D3AE0h case   10:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 820D3AE0h case   10:*/		return 0x820D3AE4;
		  /* 820D3AE4h */ case   11:  		/* stb R10, <#[R1 + 115]> */
		/* 820D3AE4h case   11:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000073) );
		/* 820D3AE4h case   11:*/		return 0x820D3AE8;
		  /* 820D3AE8h */ case   12:  		/* stw R11, <#[R1 + 120]> */
		/* 820D3AE8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820D3AE8h case   12:*/		return 0x820D3AEC;
		  /* 820D3AECh */ case   13:  		/* stb R25, <#[R1 + 113]> */
		/* 820D3AECh case   13:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R1 + 0x00000071) );
		/* 820D3AECh case   13:*/		return 0x820D3AF0;
		  /* 820D3AF0h */ case   14:  		/* stb R25, <#[R1 + 114]> */
		/* 820D3AF0h case   14:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R1 + 0x00000072) );
		/* 820D3AF0h case   14:*/		return 0x820D3AF4;
		  /* 820D3AF4h */ case   15:  		/* bc 12, CR6_EQ, 992 */
		/* 820D3AF4h case   15:*/		if ( regs.CR[6].eq ) { return 0x820D3ED4;  }
		/* 820D3AF4h case   15:*/		return 0x820D3AF8;
		  /* 820D3AF8h */ case   16:  		/* lis R7, -32255 */
		/* 820D3AF8h case   16:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820D3AF8h case   16:*/		return 0x820D3AFC;
		  /* 820D3AFCh */ case   17:  		/* lis R6, -32255 */
		/* 820D3AFCh case   17:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820D3AFCh case   17:*/		return 0x820D3B00;
		  /* 820D3B00h */ case   18:  		/* lis R5, -32255 */
		/* 820D3B00h case   18:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820D3B00h case   18:*/		return 0x820D3B04;
		  /* 820D3B04h */ case   19:  		/* lis R4, -32255 */
		/* 820D3B04h case   19:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 820D3B04h case   19:*/		return 0x820D3B08;
		  /* 820D3B08h */ case   20:  		/* lis R3, -32255 */
		/* 820D3B08h case   20:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8201);
		/* 820D3B08h case   20:*/		return 0x820D3B0C;
		  /* 820D3B0Ch */ case   21:  		/* lis R31, -32255 */
		/* 820D3B0Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820D3B0Ch case   21:*/		return 0x820D3B10;
		  /* 820D3B10h */ case   22:  		/* lis R30, -32255 */
		/* 820D3B10h case   22:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8201);
		/* 820D3B10h case   22:*/		return 0x820D3B14;
		  /* 820D3B14h */ case   23:  		/* lis R29, -32255 */
		/* 820D3B14h case   23:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8201);
		/* 820D3B14h case   23:*/		return 0x820D3B18;
		  /* 820D3B18h */ case   24:  		/* lis R28, -32255 */
		/* 820D3B18h case   24:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8201);
		/* 820D3B18h case   24:*/		return 0x820D3B1C;
		  /* 820D3B1Ch */ case   25:  		/* lis R27, -32255 */
		/* 820D3B1Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8201);
		/* 820D3B1Ch case   25:*/		return 0x820D3B20;
		  /* 820D3B20h */ case   26:  		/* lis R26, -32255 */
		/* 820D3B20h case   26:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8201);
		/* 820D3B20h case   26:*/		return 0x820D3B24;
		  /* 820D3B24h */ case   27:  		/* lis R8, -32255 */
		/* 820D3B24h case   27:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820D3B24h case   27:*/		return 0x820D3B28;
		  /* 820D3B28h */ case   28:  		/* lis R9, -32255 */
		/* 820D3B28h case   28:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820D3B28h case   28:*/		return 0x820D3B2C;
		  /* 820D3B2Ch */ case   29:  		/* lis R10, -32255 */
		/* 820D3B2Ch case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D3B2Ch case   29:*/		return 0x820D3B30;
		  /* 820D3B30h */ case   30:  		/* lis R11, -32255 */
		/* 820D3B30h case   30:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3B30h case   30:*/		return 0x820D3B34;
		  /* 820D3B34h */ case   31:  		/* addi R20, R7, 26596 */
		/* 820D3B34h case   31:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R7,0x67E4);
		/* 820D3B34h case   31:*/		return 0x820D3B38;
		  /* 820D3B38h */ case   32:  		/* addi R22, R6, 26552 */
		/* 820D3B38h case   32:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R6,0x67B8);
		/* 820D3B38h case   32:*/		return 0x820D3B3C;
		  /* 820D3B3Ch */ case   33:  		/* addi R23, R5, 26504 */
		/* 820D3B3Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R5,0x6788);
		/* 820D3B3Ch case   33:*/		return 0x820D3B40;
		  /* 820D3B40h */ case   34:  		/* addi R15, R4, 26496 */
		/* 820D3B40h case   34:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R4,0x6780);
		/* 820D3B40h case   34:*/		return 0x820D3B44;
		  /* 820D3B44h */ case   35:  		/* addi R14, R3, 26488 */
		/* 820D3B44h case   35:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R3,0x6778);
		/* 820D3B44h case   35:*/		return 0x820D3B48;
		  /* 820D3B48h */ case   36:  		/* addi R21, R31, 26408 */
		/* 820D3B48h case   36:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R31,0x6728);
		/* 820D3B48h case   36:*/		return 0x820D3B4C;
		  /* 820D3B4Ch */ case   37:  		/* addi R30, R30, 26384 */
		/* 820D3B4Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x6710);
		/* 820D3B4Ch case   37:*/		return 0x820D3B50;
		  /* 820D3B50h */ case   38:  		/* addi R29, R29, 26332 */
		/* 820D3B50h case   38:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x66DC);
		/* 820D3B50h case   38:*/		return 0x820D3B54;
		  /* 820D3B54h */ case   39:  		/* addi R28, R28, 26280 */
		/* 820D3B54h case   39:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x66A8);
		/* 820D3B54h case   39:*/		return 0x820D3B58;
		  /* 820D3B58h */ case   40:  		/* addi R27, R27, 26264 */
		/* 820D3B58h case   40:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x6698);
		/* 820D3B58h case   40:*/		return 0x820D3B5C;
		  /* 820D3B5Ch */ case   41:  		/* addi R26, R26, 26228 */
		/* 820D3B5Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x6674);
		/* 820D3B5Ch case   41:*/		return 0x820D3B60;
		  /* 820D3B60h */ case   42:  		/* addi R19, R8, 26220 */
		/* 820D3B60h case   42:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R8,0x666C);
		/* 820D3B60h case   42:*/		return 0x820D3B64;
		  /* 820D3B64h */ case   43:  		/* addi R18, R9, 26212 */
		/* 820D3B64h case   43:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R9,0x6664);
		/* 820D3B64h case   43:*/		return 0x820D3B68;
		  /* 820D3B68h */ case   44:  		/* addi R17, R10, 26196 */
		/* 820D3B68h case   44:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R10,0x6654);
		/* 820D3B68h case   44:*/		return 0x820D3B6C;
		  /* 820D3B6Ch */ case   45:  		/* addi R16, R11, 4972 */
		/* 820D3B6Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R11,0x136C);
		/* 820D3B6Ch case   45:*/		return 0x820D3B70;
		  /* 820D3B70h */ case   46:  		/* lwz R11, <#[R1 + 120]> */
		/* 820D3B70h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820D3B70h case   46:*/		return 0x820D3B74;
		  /* 820D3B74h */ case   47:  		/* lwz R10, <#[R11 + 8]> */
		/* 820D3B74h case   47:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820D3B74h case   47:*/		return 0x820D3B78;
		  /* 820D3B78h */ case   48:  		/* lwz R11, <#[R11 + 12]> */
		/* 820D3B78h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820D3B78h case   48:*/		return 0x820D3B7C;
		  /* 820D3B7Ch */ case   49:  		/* lwz R9, <#[R10 + 8]> */
		/* 820D3B7Ch case   49:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820D3B7Ch case   49:*/		return 0x820D3B80;
		  /* 820D3B80h */ case   50:  		/* lwz R8, <#[R10 + 12]> */
		/* 820D3B80h case   50:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 820D3B80h case   50:*/		return 0x820D3B84;
		  /* 820D3B84h */ case   51:  		/* stw R11, <#[R1 + 120]> */
		/* 820D3B84h case   51:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820D3B84h case   51:*/		return 0x820D3B88;
		  /* 820D3B88h */ case   52:  		/* cmplwi CR6, R8, 0 */
		/* 820D3B88h case   52:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D3B88h case   52:*/		return 0x820D3B8C;
		  /* 820D3B8Ch */ case   53:  		/* addi R3, R8, 16 */
		/* 820D3B8Ch case   53:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R8,0x10);
		/* 820D3B8Ch case   53:*/		return 0x820D3B90;
		  /* 820D3B90h */ case   54:  		/* lwz R31, <#[R9 + 24]> */
		/* 820D3B90h case   54:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000018) );
		/* 820D3B90h case   54:*/		return 0x820D3B94;
		  /* 820D3B94h */ case   55:  		/* bc 4, CR6_EQ, 8 */
		/* 820D3B94h case   55:*/		if ( !regs.CR[6].eq ) { return 0x820D3B9C;  }
		/* 820D3B94h case   55:*/		return 0x820D3B98;
		  /* 820D3B98h */ case   56:  		/* li R3, 0 */
		/* 820D3B98h case   56:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820D3B98h case   56:*/		return 0x820D3B9C;
	}
	return 0x820D3B9C;
} // Block from 820D3AB8h-820D3B9Ch (57 instructions)

//////////////////////////////////////////////////////
// Block at 820D3B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3B9C);
		  /* 820D3B9Ch */ case    0:  		/* mr R10, R16 */
		/* 820D3B9Ch case    0:*/		regs.R10 = regs.R16;
		/* 820D3B9Ch case    0:*/		return 0x820D3BA0;
		  /* 820D3BA0h */ case    1:  		/* mr R11, R31 */
		/* 820D3BA0h case    1:*/		regs.R11 = regs.R31;
		/* 820D3BA0h case    1:*/		return 0x820D3BA4;
		  /* 820D3BA4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D3BA4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3BA4h case    2:*/		return 0x820D3BA8;
		  /* 820D3BA8h */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820D3BA8h case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D3BA8h case    3:*/		return 0x820D3BAC;
		  /* 820D3BACh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D3BACh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3BACh case    4:*/		return 0x820D3BB0;
		  /* 820D3BB0h */ case    5:  		/* subf R9, R7, R9 */
		/* 820D3BB0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D3BB0h case    5:*/		return 0x820D3BB4;
		  /* 820D3BB4h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D3BB4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D3BC8;  }
		/* 820D3BB4h case    6:*/		return 0x820D3BB8;
		  /* 820D3BB8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D3BB8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3BB8h case    7:*/		return 0x820D3BBC;
		  /* 820D3BBCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820D3BBCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D3BBCh case    8:*/		return 0x820D3BC0;
		  /* 820D3BC0h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D3BC0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D3BC0h case    9:*/		return 0x820D3BC4;
		  /* 820D3BC4h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D3BC4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D3BA4;  }
		/* 820D3BC4h case   10:*/		return 0x820D3BC8;
	}
	return 0x820D3BC8;
} // Block from 820D3B9Ch-820D3BC8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D3BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3BC8);
		  /* 820D3BC8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D3BC8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3BC8h case    0:*/		return 0x820D3BCC;
		  /* 820D3BCCh */ case    1:  		/* bc 4, CR0_EQ, 64 */
		/* 820D3BCCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3C0C;  }
		/* 820D3BCCh case    1:*/		return 0x820D3BD0;
		  /* 820D3BD0h */ case    2:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D3BD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3BD0h case    2:*/		return 0x820D3BD4;
		  /* 820D3BD4h */ case    3:  		/* lwz R10, <#[R24 + 72]> */
		/* 820D3BD4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000048) );
		/* 820D3BD4h case    3:*/		return 0x820D3BD8;
		  /* 820D3BD8h */ case    4:  		/* addi R11, R11, 1 */
		/* 820D3BD8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3BD8h case    4:*/		return 0x820D3BDC;
		  /* 820D3BDCh */ case    5:  		/* cmpwi CR6, R10, 1 */
		/* 820D3BDCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820D3BDCh case    5:*/		return 0x820D3BE0;
		  /* 820D3BE0h */ case    6:  		/* stw R11, <#[R1 + 116]> */
		/* 820D3BE0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3BE0h case    6:*/		return 0x820D3BE4;
		  /* 820D3BE4h */ case    7:  		/* li R10, 1 */
		/* 820D3BE4h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820D3BE4h case    7:*/		return 0x820D3BE8;
		  /* 820D3BE8h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 820D3BE8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820D3BF0;  }
		/* 820D3BE8h case    8:*/		return 0x820D3BEC;
		  /* 820D3BECh */ case    9:  		/* stb R10, <#[R1 + 112]> */
		/* 820D3BECh case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820D3BECh case    9:*/		return 0x820D3BF0;
	}
	return 0x820D3BF0;
} // Block from 820D3BC8h-820D3BF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D3BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3BF0);
		  /* 820D3BF0h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820D3BF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D3BF0h case    0:*/		return 0x820D3BF4;
		  /* 820D3BF4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820D3BF4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3BFC;  }
		/* 820D3BF4h case    1:*/		return 0x820D3BF8;
		  /* 820D3BF8h */ case    2:  		/* stb R10, <#[R1 + 113]> */
		/* 820D3BF8h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000071) );
		/* 820D3BF8h case    2:*/		return 0x820D3BFC;
	}
	return 0x820D3BFC;
} // Block from 820D3BF0h-820D3BFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3BFC);
		  /* 820D3BFCh */ case    0:  		/* lwz R11, <#[R1 + 316]> */
		/* 820D3BFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 820D3BFCh case    0:*/		return 0x820D3C00;
		  /* 820D3C00h */ case    1:  		/* lwz R9, <#[R11 + 4]> */
		/* 820D3C00h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820D3C00h case    1:*/		return 0x820D3C04;
		  /* 820D3C04h */ case    2:  		/* rlwimi R9, R10, 9, 21, 22 */
		/* 820D3C04h case    2:*/		cpu::op::rlwimi<0,9,21,22>(regs,&regs.R9,regs.R10);
		/* 820D3C04h case    2:*/		return 0x820D3C08;
		  /* 820D3C08h */ case    3:  		/* b 196 */
		/* 820D3C08h case    3:*/		return 0x820D3CCC;
		/* 820D3C08h case    3:*/		return 0x820D3C0C;
	}
	return 0x820D3C0C;
} // Block from 820D3BFCh-820D3C0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D3C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3C0C);
		  /* 820D3C0Ch */ case    0:  		/* mr R10, R17 */
		/* 820D3C0Ch case    0:*/		regs.R10 = regs.R17;
		/* 820D3C0Ch case    0:*/		return 0x820D3C10;
		  /* 820D3C10h */ case    1:  		/* mr R11, R31 */
		/* 820D3C10h case    1:*/		regs.R11 = regs.R31;
		/* 820D3C10h case    1:*/		return 0x820D3C14;
		  /* 820D3C14h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D3C14h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3C14h case    2:*/		return 0x820D3C18;
		  /* 820D3C18h */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820D3C18h case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D3C18h case    3:*/		return 0x820D3C1C;
		  /* 820D3C1Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D3C1Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3C1Ch case    4:*/		return 0x820D3C20;
		  /* 820D3C20h */ case    5:  		/* subf R9, R7, R9 */
		/* 820D3C20h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D3C20h case    5:*/		return 0x820D3C24;
		  /* 820D3C24h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D3C24h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D3C38;  }
		/* 820D3C24h case    6:*/		return 0x820D3C28;
		  /* 820D3C28h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D3C28h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3C28h case    7:*/		return 0x820D3C2C;
		  /* 820D3C2Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820D3C2Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D3C2Ch case    8:*/		return 0x820D3C30;
		  /* 820D3C30h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D3C30h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D3C30h case    9:*/		return 0x820D3C34;
		  /* 820D3C34h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D3C34h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D3C14;  }
		/* 820D3C34h case   10:*/		return 0x820D3C38;
	}
	return 0x820D3C38;
} // Block from 820D3C0Ch-820D3C38h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D3C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3C38);
		  /* 820D3C38h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D3C38h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3C38h case    0:*/		return 0x820D3C3C;
		  /* 820D3C3Ch */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 820D3C3Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3C60;  }
		/* 820D3C3Ch case    1:*/		return 0x820D3C40;
		  /* 820D3C40h */ case    2:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D3C40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3C40h case    2:*/		return 0x820D3C44;
		  /* 820D3C44h */ case    3:  		/* lwz R10, <#[R24 + 72]> */
		/* 820D3C44h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000048) );
		/* 820D3C44h case    3:*/		return 0x820D3C48;
		  /* 820D3C48h */ case    4:  		/* addi R11, R11, 1 */
		/* 820D3C48h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3C48h case    4:*/		return 0x820D3C4C;
		  /* 820D3C4Ch */ case    5:  		/* cmpwi CR6, R10, 1 */
		/* 820D3C4Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820D3C4Ch case    5:*/		return 0x820D3C50;
		  /* 820D3C50h */ case    6:  		/* stw R11, <#[R1 + 116]> */
		/* 820D3C50h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3C50h case    6:*/		return 0x820D3C54;
		  /* 820D3C54h */ case    7:  		/* li R10, 1 */
		/* 820D3C54h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820D3C54h case    7:*/		return 0x820D3C58;
		  /* 820D3C58h */ case    8:  		/* bc 4, CR6_EQ, 92 */
		/* 820D3C58h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820D3CB4;  }
		/* 820D3C58h case    8:*/		return 0x820D3C5C;
		  /* 820D3C5Ch */ case    9:  		/* b 84 */
		/* 820D3C5Ch case    9:*/		return 0x820D3CB0;
		/* 820D3C5Ch case    9:*/		return 0x820D3C60;
	}
	return 0x820D3C60;
} // Block from 820D3C38h-820D3C60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D3C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3C60);
		  /* 820D3C60h */ case    0:  		/* mr R10, R18 */
		/* 820D3C60h case    0:*/		regs.R10 = regs.R18;
		/* 820D3C60h case    0:*/		return 0x820D3C64;
		  /* 820D3C64h */ case    1:  		/* mr R11, R31 */
		/* 820D3C64h case    1:*/		regs.R11 = regs.R31;
		/* 820D3C64h case    1:*/		return 0x820D3C68;
		  /* 820D3C68h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D3C68h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3C68h case    2:*/		return 0x820D3C6C;
		  /* 820D3C6Ch */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820D3C6Ch case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D3C6Ch case    3:*/		return 0x820D3C70;
		  /* 820D3C70h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D3C70h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3C70h case    4:*/		return 0x820D3C74;
		  /* 820D3C74h */ case    5:  		/* subf R9, R7, R9 */
		/* 820D3C74h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D3C74h case    5:*/		return 0x820D3C78;
		  /* 820D3C78h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D3C78h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D3C8C;  }
		/* 820D3C78h case    6:*/		return 0x820D3C7C;
		  /* 820D3C7Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820D3C7Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3C7Ch case    7:*/		return 0x820D3C80;
		  /* 820D3C80h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D3C80h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D3C80h case    8:*/		return 0x820D3C84;
		  /* 820D3C84h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D3C84h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D3C84h case    9:*/		return 0x820D3C88;
		  /* 820D3C88h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D3C88h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D3C68;  }
		/* 820D3C88h case   10:*/		return 0x820D3C8C;
	}
	return 0x820D3C8C;
} // Block from 820D3C60h-820D3C8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D3C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3C8C);
		  /* 820D3C8Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D3C8Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3C8Ch case    0:*/		return 0x820D3C90;
		  /* 820D3C90h */ case    1:  		/* bc 4, CR0_EQ, 68 */
		/* 820D3C90h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3CD4;  }
		/* 820D3C90h case    1:*/		return 0x820D3C94;
		  /* 820D3C94h */ case    2:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D3C94h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3C94h case    2:*/		return 0x820D3C98;
		  /* 820D3C98h */ case    3:  		/* lwz R10, <#[R24 + 72]> */
		/* 820D3C98h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000048) );
		/* 820D3C98h case    3:*/		return 0x820D3C9C;
		  /* 820D3C9Ch */ case    4:  		/* addi R11, R11, 1 */
		/* 820D3C9Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3C9Ch case    4:*/		return 0x820D3CA0;
		  /* 820D3CA0h */ case    5:  		/* cmpwi CR6, R10, 1 */
		/* 820D3CA0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820D3CA0h case    5:*/		return 0x820D3CA4;
		  /* 820D3CA4h */ case    6:  		/* stw R11, <#[R1 + 116]> */
		/* 820D3CA4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3CA4h case    6:*/		return 0x820D3CA8;
		  /* 820D3CA8h */ case    7:  		/* li R10, 1 */
		/* 820D3CA8h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820D3CA8h case    7:*/		return 0x820D3CAC;
		  /* 820D3CACh */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 820D3CACh case    8:*/		if ( regs.CR[6].eq ) { return 0x820D3CB4;  }
		/* 820D3CACh case    8:*/		return 0x820D3CB0;
	}
	return 0x820D3CB0;
} // Block from 820D3C8Ch-820D3CB0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D3CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3CB0);
		  /* 820D3CB0h */ case    0:  		/* stb R10, <#[R1 + 112]> */
		/* 820D3CB0h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820D3CB0h case    0:*/		return 0x820D3CB4;
	}
	return 0x820D3CB4;
} // Block from 820D3CB0h-820D3CB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3CB4);
		  /* 820D3CB4h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820D3CB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D3CB4h case    0:*/		return 0x820D3CB8;
		  /* 820D3CB8h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820D3CB8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3CC0;  }
		/* 820D3CB8h case    1:*/		return 0x820D3CBC;
		  /* 820D3CBCh */ case    2:  		/* stb R10, <#[R1 + 113]> */
		/* 820D3CBCh case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000071) );
		/* 820D3CBCh case    2:*/		return 0x820D3CC0;
	}
	return 0x820D3CC0;
} // Block from 820D3CB4h-820D3CC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3CC0);
		  /* 820D3CC0h */ case    0:  		/* lwz R11, <#[R1 + 316]> */
		/* 820D3CC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 820D3CC0h case    0:*/		return 0x820D3CC4;
		  /* 820D3CC4h */ case    1:  		/* lwz R9, <#[R11 + 4]> */
		/* 820D3CC4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820D3CC4h case    1:*/		return 0x820D3CC8;
		  /* 820D3CC8h */ case    2:  		/* rlwimi R9, R10, 10, 21, 22 */
		/* 820D3CC8h case    2:*/		cpu::op::rlwimi<0,10,21,22>(regs,&regs.R9,regs.R10);
		/* 820D3CC8h case    2:*/		return 0x820D3CCC;
	}
	return 0x820D3CCC;
} // Block from 820D3CC0h-820D3CCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D3CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3CCC);
		  /* 820D3CCCh */ case    0:  		/* stw R9, <#[R11 + 4]> */
		/* 820D3CCCh case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820D3CCCh case    0:*/		return 0x820D3CD0;
		  /* 820D3CD0h */ case    1:  		/* b 296 */
		/* 820D3CD0h case    1:*/		return 0x820D3DF8;
		/* 820D3CD0h case    1:*/		return 0x820D3CD4;
	}
	return 0x820D3CD4;
} // Block from 820D3CCCh-820D3CD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3CD4);
		  /* 820D3CD4h */ case    0:  		/* mr R10, R19 */
		/* 820D3CD4h case    0:*/		regs.R10 = regs.R19;
		/* 820D3CD4h case    0:*/		return 0x820D3CD8;
		  /* 820D3CD8h */ case    1:  		/* mr R11, R31 */
		/* 820D3CD8h case    1:*/		regs.R11 = regs.R31;
		/* 820D3CD8h case    1:*/		return 0x820D3CDC;
		  /* 820D3CDCh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D3CDCh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3CDCh case    2:*/		return 0x820D3CE0;
		  /* 820D3CE0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D3CE0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D3CE0h case    3:*/		return 0x820D3CE4;
		  /* 820D3CE4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D3CE4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3CE4h case    4:*/		return 0x820D3CE8;
		  /* 820D3CE8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D3CE8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D3CE8h case    5:*/		return 0x820D3CEC;
		  /* 820D3CECh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D3CECh case    6:*/		if ( regs.CR[0].eq ) { return 0x820D3D00;  }
		/* 820D3CECh case    6:*/		return 0x820D3CF0;
		  /* 820D3CF0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820D3CF0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3CF0h case    7:*/		return 0x820D3CF4;
		  /* 820D3CF4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D3CF4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D3CF4h case    8:*/		return 0x820D3CF8;
		  /* 820D3CF8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D3CF8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D3CF8h case    9:*/		return 0x820D3CFC;
		  /* 820D3CFCh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D3CFCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820D3CDC;  }
		/* 820D3CFCh case   10:*/		return 0x820D3D00;
	}
	return 0x820D3D00;
} // Block from 820D3CD4h-820D3D00h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D3D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3D00);
		  /* 820D3D00h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D3D00h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3D00h case    0:*/		return 0x820D3D04;
		  /* 820D3D04h */ case    1:  		/* bc 4, CR0_EQ, 92 */
		/* 820D3D04h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3D60;  }
		/* 820D3D04h case    1:*/		return 0x820D3D08;
		  /* 820D3D08h */ case    2:  		/* li R6, 2 */
		/* 820D3D08h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 820D3D08h case    2:*/		return 0x820D3D0C;
		  /* 820D3D0Ch */ case    3:  		/* li R5, 1 */
		/* 820D3D0Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820D3D0Ch case    3:*/		return 0x820D3D10;
		  /* 820D3D10h */ case    4:  		/* addi R4, R1, 128 */
		/* 820D3D10h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820D3D10h case    4:*/		return 0x820D3D14;
		  /* 820D3D14h */ case    5:  		/* bl -18916 */
		/* 820D3D14h case    5:*/		regs.LR = 0x820D3D18; return 0x820CF330;
		/* 820D3D14h case    5:*/		return 0x820D3D18;
		  /* 820D3D18h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820D3D18h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D3D18h case    6:*/		return 0x820D3D1C;
		  /* 820D3D1Ch */ case    7:  		/* bc 4, CR0_LT, 20 */
		/* 820D3D1Ch case    7:*/		if ( !regs.CR[0].lt ) { return 0x820D3D30;  }
		/* 820D3D1Ch case    7:*/		return 0x820D3D20;
		  /* 820D3D20h */ case    8:  		/* mr R4, R26 */
		/* 820D3D20h case    8:*/		regs.R4 = regs.R26;
		/* 820D3D20h case    8:*/		return 0x820D3D24;
		  /* 820D3D24h */ case    9:  		/* mr R3, R24 */
		/* 820D3D24h case    9:*/		regs.R3 = regs.R24;
		/* 820D3D24h case    9:*/		return 0x820D3D28;
		  /* 820D3D28h */ case   10:  		/* bl -13376 */
		/* 820D3D28h case   10:*/		regs.LR = 0x820D3D2C; return 0x820D08E8;
		/* 820D3D28h case   10:*/		return 0x820D3D2C;
		  /* 820D3D2Ch */ case   11:  		/* b 200 */
		/* 820D3D2Ch case   11:*/		return 0x820D3DF4;
		/* 820D3D2Ch case   11:*/		return 0x820D3D30;
	}
	return 0x820D3D30;
} // Block from 820D3D00h-820D3D30h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D3D30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3D30);
		  /* 820D3D30h */ case    0:  		/* lwz R11, <#[R1 + 316]> */
		/* 820D3D30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 820D3D30h case    0:*/		return 0x820D3D34;
		  /* 820D3D34h */ case    1:  		/* lwz R10, <#[R1 + 116]> */
		/* 820D3D34h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3D34h case    1:*/		return 0x820D3D38;
		  /* 820D3D38h */ case    2:  		/* lwz R9, <#[R1 + 128]> */
		/* 820D3D38h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000080) );
		/* 820D3D38h case    2:*/		return 0x820D3D3C;
		  /* 820D3D3Ch */ case    3:  		/* addi R10, R10, 1 */
		/* 820D3D3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D3D3Ch case    3:*/		return 0x820D3D40;
		  /* 820D3D40h */ case    4:  		/* lwz R8, <#[R11]> */
		/* 820D3D40h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3D40h case    4:*/		return 0x820D3D44;
		  /* 820D3D44h */ case    5:  		/* lwz R7, <#[R11 + 4]> */
		/* 820D3D44h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820D3D44h case    5:*/		return 0x820D3D48;
		  /* 820D3D48h */ case    6:  		/* stw R10, <#[R1 + 116]> */
		/* 820D3D48h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3D48h case    6:*/		return 0x820D3D4C;
		  /* 820D3D4Ch */ case    7:  		/* rlwimi R8, R9, 0, 29, 31 */
		/* 820D3D4Ch case    7:*/		cpu::op::rlwimi<0,0,29,31>(regs,&regs.R8,regs.R9);
		/* 820D3D4Ch case    7:*/		return 0x820D3D50;
		  /* 820D3D50h */ case    8:  		/* ori R10, R7, 1536 */
		/* 820D3D50h case    8:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R7,0x600);
		/* 820D3D50h case    8:*/		return 0x820D3D54;
		  /* 820D3D54h */ case    9:  		/* stw R8, <#[R11]> */
		/* 820D3D54h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3D54h case    9:*/		return 0x820D3D58;
		  /* 820D3D58h */ case   10:  		/* stw R10, <#[R11 + 4]> */
		/* 820D3D58h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820D3D58h case   10:*/		return 0x820D3D5C;
		  /* 820D3D5Ch */ case   11:  		/* b 156 */
		/* 820D3D5Ch case   11:*/		return 0x820D3DF8;
		/* 820D3D5Ch case   11:*/		return 0x820D3D60;
	}
	return 0x820D3D60;
} // Block from 820D3D30h-820D3D60h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D3D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3D60);
		  /* 820D3D60h */ case    0:  		/* mr R10, R27 */
		/* 820D3D60h case    0:*/		regs.R10 = regs.R27;
		/* 820D3D60h case    0:*/		return 0x820D3D64;
		  /* 820D3D64h */ case    1:  		/* mr R11, R31 */
		/* 820D3D64h case    1:*/		regs.R11 = regs.R31;
		/* 820D3D64h case    1:*/		return 0x820D3D68;
		  /* 820D3D68h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820D3D68h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3D68h case    2:*/		return 0x820D3D6C;
		  /* 820D3D6Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820D3D6Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D3D6Ch case    3:*/		return 0x820D3D70;
		  /* 820D3D70h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820D3D70h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3D70h case    4:*/		return 0x820D3D74;
		  /* 820D3D74h */ case    5:  		/* subf R9, R8, R9 */
		/* 820D3D74h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D3D74h case    5:*/		return 0x820D3D78;
		  /* 820D3D78h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820D3D78h case    6:*/		if ( regs.CR[0].eq ) { return 0x820D3D8C;  }
		/* 820D3D78h case    6:*/		return 0x820D3D7C;
		  /* 820D3D7Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820D3D7Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3D7Ch case    7:*/		return 0x820D3D80;
		  /* 820D3D80h */ case    8:  		/* addi R10, R10, 1 */
		/* 820D3D80h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D3D80h case    8:*/		return 0x820D3D84;
		  /* 820D3D84h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820D3D84h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D3D84h case    9:*/		return 0x820D3D88;
		  /* 820D3D88h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820D3D88h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D3D68;  }
		/* 820D3D88h case   10:*/		return 0x820D3D8C;
	}
	return 0x820D3D8C;
} // Block from 820D3D60h-820D3D8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D3D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3D8C);
		  /* 820D3D8Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D3D8Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3D8Ch case    0:*/		return 0x820D3D90;
		  /* 820D3D90h */ case    1:  		/* bc 4, CR0_EQ, 84 */
		/* 820D3D90h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3DE4;  }
		/* 820D3D90h case    1:*/		return 0x820D3D94;
		  /* 820D3D94h */ case    2:  		/* lbz R11, <#[R1 + 114]> */
		/* 820D3D94h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000072) );
		/* 820D3D94h case    2:*/		return 0x820D3D98;
		  /* 820D3D98h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820D3D98h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3D98h case    3:*/		return 0x820D3D9C;
		  /* 820D3D9Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 820D3D9Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820D3DA8;  }
		/* 820D3D9Ch case    4:*/		return 0x820D3DA0;
		  /* 820D3DA0h */ case    5:  		/* mr R4, R28 */
		/* 820D3DA0h case    5:*/		regs.R4 = regs.R28;
		/* 820D3DA0h case    5:*/		return 0x820D3DA4;
		  /* 820D3DA4h */ case    6:  		/* b -128 */
		/* 820D3DA4h case    6:*/		return 0x820D3D24;
		/* 820D3DA4h case    6:*/		return 0x820D3DA8;
	}
	return 0x820D3DA8;
} // Block from 820D3D8Ch-820D3DA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3DA8);
		  /* 820D3DA8h */ case    0:  		/* li R11, 0 */
		/* 820D3DA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3DA8h case    0:*/		return 0x820D3DAC;
		  /* 820D3DACh */ case    1:  		/* li R10, 1 */
		/* 820D3DACh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820D3DACh case    1:*/		return 0x820D3DB0;
		  /* 820D3DB0h */ case    2:  		/* addi R4, R1, 124 */
		/* 820D3DB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x7C);
		/* 820D3DB0h case    2:*/		return 0x820D3DB4;
		  /* 820D3DB4h */ case    3:  		/* stw R11, <#[R1 + 124]> */
		/* 820D3DB4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D3DB4h case    3:*/		return 0x820D3DB8;
		  /* 820D3DB8h */ case    4:  		/* stb R10, <#[R1 + 114]> */
		/* 820D3DB8h case    4:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000072) );
		/* 820D3DB8h case    4:*/		return 0x820D3DBC;
		  /* 820D3DBCh */ case    5:  		/* bl -18852 */
		/* 820D3DBCh case    5:*/		regs.LR = 0x820D3DC0; return 0x820CF418;
		/* 820D3DBCh case    5:*/		return 0x820D3DC0;
		  /* 820D3DC0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820D3DC0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D3DC0h case    6:*/		return 0x820D3DC4;
		  /* 820D3DC4h */ case    7:  		/* bc 12, CR0_LT, 24 */
		/* 820D3DC4h case    7:*/		if ( regs.CR[0].lt ) { return 0x820D3DDC;  }
		/* 820D3DC4h case    7:*/		return 0x820D3DC8;
		  /* 820D3DC8h */ case    8:  		/* lwz R11, <#[R1 + 316]> */
		/* 820D3DC8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 820D3DC8h case    8:*/		return 0x820D3DCC;
		  /* 820D3DCCh */ case    9:  		/* lwz R10, <#[R1 + 124]> */
		/* 820D3DCCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D3DCCh case    9:*/		return 0x820D3DD0;
		  /* 820D3DD0h */ case   10:  		/* lwz R9, <#[R11 + 4]> */
		/* 820D3DD0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820D3DD0h case   10:*/		return 0x820D3DD4;
		  /* 820D3DD4h */ case   11:  		/* rlwimi R9, R10, 8, 23, 23 */
		/* 820D3DD4h case   11:*/		cpu::op::rlwimi<0,8,23,23>(regs,&regs.R9,regs.R10);
		/* 820D3DD4h case   11:*/		return 0x820D3DD8;
		  /* 820D3DD8h */ case   12:  		/* b -268 */
		/* 820D3DD8h case   12:*/		return 0x820D3CCC;
		/* 820D3DD8h case   12:*/		return 0x820D3DDC;
	}
	return 0x820D3DDC;
} // Block from 820D3DA8h-820D3DDCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D3DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3DDC);
		  /* 820D3DDCh */ case    0:  		/* mr R4, R29 */
		/* 820D3DDCh case    0:*/		regs.R4 = regs.R29;
		/* 820D3DDCh case    0:*/		return 0x820D3DE0;
		  /* 820D3DE0h */ case    1:  		/* b -188 */
		/* 820D3DE0h case    1:*/		return 0x820D3D24;
		/* 820D3DE0h case    1:*/		return 0x820D3DE4;
	}
	return 0x820D3DE4;
} // Block from 820D3DDCh-820D3DE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3DE4);
		  /* 820D3DE4h */ case    0:  		/* mr R4, R30 */
		/* 820D3DE4h case    0:*/		regs.R4 = regs.R30;
		/* 820D3DE4h case    0:*/		return 0x820D3DE8;
		  /* 820D3DE8h */ case    1:  		/* mr R5, R31 */
		/* 820D3DE8h case    1:*/		regs.R5 = regs.R31;
		/* 820D3DE8h case    1:*/		return 0x820D3DEC;
		  /* 820D3DECh */ case    2:  		/* mr R3, R24 */
		/* 820D3DECh case    2:*/		regs.R3 = regs.R24;
		/* 820D3DECh case    2:*/		return 0x820D3DF0;
		  /* 820D3DF0h */ case    3:  		/* bl -13576 */
		/* 820D3DF0h case    3:*/		regs.LR = 0x820D3DF4; return 0x820D08E8;
		/* 820D3DF0h case    3:*/		return 0x820D3DF4;
	}
	return 0x820D3DF4;
} // Block from 820D3DE4h-820D3DF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D3DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3DF4);
		  /* 820D3DF4h */ case    0:  		/* li R25, 1 */
		/* 820D3DF4h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D3DF4h case    0:*/		return 0x820D3DF8;
	}
	return 0x820D3DF8;
} // Block from 820D3DF4h-820D3DF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D3DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3DF8);
		  /* 820D3DF8h */ case    0:  		/* lbz R11, <#[R1 + 115]> */
		/* 820D3DF8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000073) );
		/* 820D3DF8h case    0:*/		return 0x820D3DFC;
		  /* 820D3DFCh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D3DFCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3DFCh case    1:*/		return 0x820D3E00;
		  /* 820D3E00h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 820D3E00h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D3E34;  }
		/* 820D3E00h case    2:*/		return 0x820D3E04;
		  /* 820D3E04h */ case    3:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D3E04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3E04h case    3:*/		return 0x820D3E08;
		  /* 820D3E08h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820D3E08h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D3E08h case    4:*/		return 0x820D3E0C;
		  /* 820D3E0Ch */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 820D3E0Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D3E2C;  }
		/* 820D3E0Ch case    5:*/		return 0x820D3E10;
		  /* 820D3E10h */ case    6:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 820D3E10h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 820D3E10h case    6:*/		return 0x820D3E14;
		  /* 820D3E14h */ case    7:  		/* bc 4, CR0_EQ, 24 */
		/* 820D3E14h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820D3E2C;  }
		/* 820D3E14h case    7:*/		return 0x820D3E18;
		  /* 820D3E18h */ case    8:  		/* mr R4, R21 */
		/* 820D3E18h case    8:*/		regs.R4 = regs.R21;
		/* 820D3E18h case    8:*/		return 0x820D3E1C;
		  /* 820D3E1Ch */ case    9:  		/* mr R5, R31 */
		/* 820D3E1Ch case    9:*/		regs.R5 = regs.R31;
		/* 820D3E1Ch case    9:*/		return 0x820D3E20;
		  /* 820D3E20h */ case   10:  		/* mr R3, R24 */
		/* 820D3E20h case   10:*/		regs.R3 = regs.R24;
		/* 820D3E20h case   10:*/		return 0x820D3E24;
		  /* 820D3E24h */ case   11:  		/* bl -13628 */
		/* 820D3E24h case   11:*/		regs.LR = 0x820D3E28; return 0x820D08E8;
		/* 820D3E24h case   11:*/		return 0x820D3E28;
		  /* 820D3E28h */ case   12:  		/* li R25, 1 */
		/* 820D3E28h case   12:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D3E28h case   12:*/		return 0x820D3E2C;
	}
	return 0x820D3E2C;
} // Block from 820D3DF8h-820D3E2Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D3E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3E2C);
		  /* 820D3E2Ch */ case    0:  		/* li R11, 0 */
		/* 820D3E2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3E2Ch case    0:*/		return 0x820D3E30;
		  /* 820D3E30h */ case    1:  		/* stb R11, <#[R1 + 115]> */
		/* 820D3E30h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000073) );
		/* 820D3E30h case    1:*/		return 0x820D3E34;
	}
	return 0x820D3E34;
} // Block from 820D3E2Ch-820D3E34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3E34);
		  /* 820D3E34h */ case    0:  		/* lbz R11, <#[R1 + 112]> */
		/* 820D3E34h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D3E34h case    0:*/		return 0x820D3E38;
		  /* 820D3E38h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D3E38h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3E38h case    1:*/		return 0x820D3E3C;
		  /* 820D3E3Ch */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 820D3E3Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820D3E70;  }
		/* 820D3E3Ch case    2:*/		return 0x820D3E40;
		  /* 820D3E40h */ case    3:  		/* lwz R11, <#[R24 + 72]> */
		/* 820D3E40h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000048) );
		/* 820D3E40h case    3:*/		return 0x820D3E44;
		  /* 820D3E44h */ case    4:  		/* mr R6, R14 */
		/* 820D3E44h case    4:*/		regs.R6 = regs.R14;
		/* 820D3E44h case    4:*/		return 0x820D3E48;
		  /* 820D3E48h */ case    5:  		/* cmpwi CR6, R11, 1 */
		/* 820D3E48h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D3E48h case    5:*/		return 0x820D3E4C;
		  /* 820D3E4Ch */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 820D3E4Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820D3E54;  }
		/* 820D3E4Ch case    6:*/		return 0x820D3E50;
		  /* 820D3E50h */ case    7:  		/* mr R6, R15 */
		/* 820D3E50h case    7:*/		regs.R6 = regs.R15;
		/* 820D3E50h case    7:*/		return 0x820D3E54;
	}
	return 0x820D3E54;
} // Block from 820D3E34h-820D3E54h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D3E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3E54);
		  /* 820D3E54h */ case    0:  		/* mr R4, R23 */
		/* 820D3E54h case    0:*/		regs.R4 = regs.R23;
		/* 820D3E54h case    0:*/		return 0x820D3E58;
		  /* 820D3E58h */ case    1:  		/* mr R5, R31 */
		/* 820D3E58h case    1:*/		regs.R5 = regs.R31;
		/* 820D3E58h case    1:*/		return 0x820D3E5C;
		  /* 820D3E5Ch */ case    2:  		/* mr R3, R24 */
		/* 820D3E5Ch case    2:*/		regs.R3 = regs.R24;
		/* 820D3E5Ch case    2:*/		return 0x820D3E60;
		  /* 820D3E60h */ case    3:  		/* bl -13688 */
		/* 820D3E60h case    3:*/		regs.LR = 0x820D3E64; return 0x820D08E8;
		/* 820D3E60h case    3:*/		return 0x820D3E64;
		  /* 820D3E64h */ case    4:  		/* li R11, 0 */
		/* 820D3E64h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3E64h case    4:*/		return 0x820D3E68;
		  /* 820D3E68h */ case    5:  		/* li R25, 1 */
		/* 820D3E68h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D3E68h case    5:*/		return 0x820D3E6C;
		  /* 820D3E6Ch */ case    6:  		/* stb R11, <#[R1 + 112]> */
		/* 820D3E6Ch case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820D3E6Ch case    6:*/		return 0x820D3E70;
	}
	return 0x820D3E70;
} // Block from 820D3E54h-820D3E70h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3E70);
		  /* 820D3E70h */ case    0:  		/* lbz R11, <#[R1 + 113]> */
		/* 820D3E70h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000071) );
		/* 820D3E70h case    0:*/		return 0x820D3E74;
		  /* 820D3E74h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820D3E74h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D3E74h case    1:*/		return 0x820D3E78;
		  /* 820D3E78h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 820D3E78h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D3E98;  }
		/* 820D3E78h case    2:*/		return 0x820D3E7C;
		  /* 820D3E7Ch */ case    3:  		/* mr R4, R22 */
		/* 820D3E7Ch case    3:*/		regs.R4 = regs.R22;
		/* 820D3E7Ch case    3:*/		return 0x820D3E80;
		  /* 820D3E80h */ case    4:  		/* mr R5, R31 */
		/* 820D3E80h case    4:*/		regs.R5 = regs.R31;
		/* 820D3E80h case    4:*/		return 0x820D3E84;
		  /* 820D3E84h */ case    5:  		/* mr R3, R24 */
		/* 820D3E84h case    5:*/		regs.R3 = regs.R24;
		/* 820D3E84h case    5:*/		return 0x820D3E88;
		  /* 820D3E88h */ case    6:  		/* bl -13728 */
		/* 820D3E88h case    6:*/		regs.LR = 0x820D3E8C; return 0x820D08E8;
		/* 820D3E88h case    6:*/		return 0x820D3E8C;
		  /* 820D3E8Ch */ case    7:  		/* li R11, 0 */
		/* 820D3E8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D3E8Ch case    7:*/		return 0x820D3E90;
		  /* 820D3E90h */ case    8:  		/* li R25, 1 */
		/* 820D3E90h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D3E90h case    8:*/		return 0x820D3E94;
		  /* 820D3E94h */ case    9:  		/* stb R11, <#[R1 + 113]> */
		/* 820D3E94h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000071) );
		/* 820D3E94h case    9:*/		return 0x820D3E98;
	}
	return 0x820D3E98;
} // Block from 820D3E70h-820D3E98h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D3E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3E98);
		  /* 820D3E98h */ case    0:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D3E98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3E98h case    0:*/		return 0x820D3E9C;
		  /* 820D3E9Ch */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 820D3E9Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D3E9Ch case    1:*/		return 0x820D3EA0;
		  /* 820D3EA0h */ case    2:  		/* bc 4, CR6_GT, 28 */
		/* 820D3EA0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820D3EBC;  }
		/* 820D3EA0h case    2:*/		return 0x820D3EA4;
		  /* 820D3EA4h */ case    3:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 820D3EA4h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 820D3EA4h case    3:*/		return 0x820D3EA8;
		  /* 820D3EA8h */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 820D3EA8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820D3EBC;  }
		/* 820D3EA8h case    4:*/		return 0x820D3EAC;
		  /* 820D3EACh */ case    5:  		/* mr R4, R20 */
		/* 820D3EACh case    5:*/		regs.R4 = regs.R20;
		/* 820D3EACh case    5:*/		return 0x820D3EB0;
		  /* 820D3EB0h */ case    6:  		/* mr R3, R24 */
		/* 820D3EB0h case    6:*/		regs.R3 = regs.R24;
		/* 820D3EB0h case    6:*/		return 0x820D3EB4;
		  /* 820D3EB4h */ case    7:  		/* bl -13772 */
		/* 820D3EB4h case    7:*/		regs.LR = 0x820D3EB8; return 0x820D08E8;
		/* 820D3EB4h case    7:*/		return 0x820D3EB8;
		  /* 820D3EB8h */ case    8:  		/* li R25, 1 */
		/* 820D3EB8h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D3EB8h case    8:*/		return 0x820D3EBC;
	}
	return 0x820D3EBC;
} // Block from 820D3E98h-820D3EBCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D3EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3EBC);
		  /* 820D3EBCh */ case    0:  		/* lwz R11, <#[R1 + 120]> */
		/* 820D3EBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820D3EBCh case    0:*/		return 0x820D3EC0;
		  /* 820D3EC0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D3EC0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D3EC0h case    1:*/		return 0x820D3EC4;
		  /* 820D3EC4h */ case    2:  		/* bc 4, CR6_EQ, -852 */
		/* 820D3EC4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D3B70;  }
		/* 820D3EC4h case    2:*/		return 0x820D3EC8;
		  /* 820D3EC8h */ case    3:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D3EC8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D3EC8h case    3:*/		return 0x820D3ECC;
		  /* 820D3ECCh */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820D3ECCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D3ECCh case    4:*/		return 0x820D3ED0;
		  /* 820D3ED0h */ case    5:  		/* bc 4, CR6_EQ, 64 */
		/* 820D3ED0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D3F10;  }
		/* 820D3ED0h case    5:*/		return 0x820D3ED4;
	}
	return 0x820D3ED4;
} // Block from 820D3EBCh-820D3ED4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D3ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3ED4);
		  /* 820D3ED4h */ case    0:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 820D3ED4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 820D3ED4h case    0:*/		return 0x820D3ED8;
		  /* 820D3ED8h */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 820D3ED8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3F10;  }
		/* 820D3ED8h case    1:*/		return 0x820D3EDC;
		  /* 820D3EDCh */ case    2:  		/* lwz R11, <#[R24 + 72]> */
		/* 820D3EDCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000048) );
		/* 820D3EDCh case    2:*/		return 0x820D3EE0;
		  /* 820D3EE0h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 820D3EE0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D3EE0h case    3:*/		return 0x820D3EE4;
		  /* 820D3EE4h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 820D3EE4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D3EF4;  }
		/* 820D3EE4h case    4:*/		return 0x820D3EE8;
		  /* 820D3EE8h */ case    5:  		/* lis R11, -32255 */
		/* 820D3EE8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3EE8h case    5:*/		return 0x820D3EEC;
		  /* 820D3EECh */ case    6:  		/* addi R5, R11, 26176 */
		/* 820D3EECh case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6640);
		/* 820D3EECh case    6:*/		return 0x820D3EF0;
		  /* 820D3EF0h */ case    7:  		/* b 12 */
		/* 820D3EF0h case    7:*/		return 0x820D3EFC;
		/* 820D3EF0h case    7:*/		return 0x820D3EF4;
	}
	return 0x820D3EF4;
} // Block from 820D3ED4h-820D3EF4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D3EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3EF4);
		  /* 820D3EF4h */ case    0:  		/* lis R11, -32255 */
		/* 820D3EF4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3EF4h case    0:*/		return 0x820D3EF8;
		  /* 820D3EF8h */ case    1:  		/* addi R5, R11, 26140 */
		/* 820D3EF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x661C);
		/* 820D3EF8h case    1:*/		return 0x820D3EFC;
	}
	return 0x820D3EFC;
} // Block from 820D3EF4h-820D3EFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3EFC);
		  /* 820D3EFCh */ case    0:  		/* lis R11, -32255 */
		/* 820D3EFCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3EFCh case    0:*/		return 0x820D3F00;
		  /* 820D3F00h */ case    1:  		/* mr R3, R24 */
		/* 820D3F00h case    1:*/		regs.R3 = regs.R24;
		/* 820D3F00h case    1:*/		return 0x820D3F04;
		  /* 820D3F04h */ case    2:  		/* addi R4, R11, 26084 */
		/* 820D3F04h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x65E4);
		/* 820D3F04h case    2:*/		return 0x820D3F08;
		  /* 820D3F08h */ case    3:  		/* bl -13856 */
		/* 820D3F08h case    3:*/		regs.LR = 0x820D3F0C; return 0x820D08E8;
		/* 820D3F08h case    3:*/		return 0x820D3F0C;
		  /* 820D3F0Ch */ case    4:  		/* li R25, 1 */
		/* 820D3F0Ch case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D3F0Ch case    4:*/		return 0x820D3F10;
	}
	return 0x820D3F10;
} // Block from 820D3EFCh-820D3F10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D3F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3F10);
		  /* 820D3F10h */ case    0:  		/* rlwinm R11, R25, 0, 24, 31 */
		/* 820D3F10h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R25);
		/* 820D3F10h case    0:*/		return 0x820D3F14;
		  /* 820D3F14h */ case    1:  		/* lis R10, -32768 */
		/* 820D3F14h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 820D3F14h case    1:*/		return 0x820D3F18;
		  /* 820D3F18h */ case    2:  		/* subfic R11, R11, 0 */
		/* 820D3F18h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820D3F18h case    2:*/		return 0x820D3F1C;
		  /* 820D3F1Ch */ case    3:  		/* ori R10, R10, 16389 */
		/* 820D3F1Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4005);
		/* 820D3F1Ch case    3:*/		return 0x820D3F20;
		  /* 820D3F20h */ case    4:  		/* subfe R11, R11, R11 */
		/* 820D3F20h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820D3F20h case    4:*/		return 0x820D3F24;
		  /* 820D3F24h */ case    5:  		/* and R3, R11, R10 */
		/* 820D3F24h case    5:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820D3F24h case    5:*/		return 0x820D3F28;
		  /* 820D3F28h */ case    6:  		/* addi R1, R1, 288 */
		/* 820D3F28h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 820D3F28h case    6:*/		return 0x820D3F2C;
		  /* 820D3F2Ch */ case    7:  		/* b -273596 */
		/* 820D3F2Ch case    7:*/		return 0x82091270;
		/* 820D3F2Ch case    7:*/		return 0x820D3F30;
	}
	return 0x820D3F30;
} // Block from 820D3F10h-820D3F30h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D3F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3F30);
		  /* 820D3F30h */ case    0:  		/* mfspr R12, LR */
		/* 820D3F30h case    0:*/		regs.R12 = regs.LR;
		/* 820D3F30h case    0:*/		return 0x820D3F34;
		  /* 820D3F34h */ case    1:  		/* bl -273636 */
		/* 820D3F34h case    1:*/		regs.LR = 0x820D3F38; return 0x82091250;
		/* 820D3F34h case    1:*/		return 0x820D3F38;
		  /* 820D3F38h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820D3F38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820D3F38h case    2:*/		return 0x820D3F3C;
		  /* 820D3F3Ch */ case    3:  		/* mr R27, R3 */
		/* 820D3F3Ch case    3:*/		regs.R27 = regs.R3;
		/* 820D3F3Ch case    3:*/		return 0x820D3F40;
		  /* 820D3F40h */ case    4:  		/* mr R30, R5 */
		/* 820D3F40h case    4:*/		regs.R30 = regs.R5;
		/* 820D3F40h case    4:*/		return 0x820D3F44;
		  /* 820D3F44h */ case    5:  		/* mr R26, R6 */
		/* 820D3F44h case    5:*/		regs.R26 = regs.R6;
		/* 820D3F44h case    5:*/		return 0x820D3F48;
		  /* 820D3F48h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 820D3F48h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820D3F48h case    6:*/		return 0x820D3F4C;
		  /* 820D3F4Ch */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 820D3F4Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D3F58;  }
		/* 820D3F4Ch case    7:*/		return 0x820D3F50;
		  /* 820D3F50h */ case    8:  		/* li R3, 0 */
		/* 820D3F50h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820D3F50h case    8:*/		return 0x820D3F54;
		  /* 820D3F54h */ case    9:  		/* b 180 */
		/* 820D3F54h case    9:*/		return 0x820D4008;
		/* 820D3F54h case    9:*/		return 0x820D3F58;
	}
	return 0x820D3F58;
} // Block from 820D3F30h-820D3F58h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D3F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3F58);
		  /* 820D3F58h */ case    0:  		/* lwz R31, <#[R4 + 120]> */
		/* 820D3F58h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000078) );
		/* 820D3F58h case    0:*/		return 0x820D3F5C;
		  /* 820D3F5Ch */ case    1:  		/* li R29, 0 */
		/* 820D3F5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820D3F5Ch case    1:*/		return 0x820D3F60;
		  /* 820D3F60h */ case    2:  		/* li R7, 0 */
		/* 820D3F60h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820D3F60h case    2:*/		return 0x820D3F64;
		  /* 820D3F64h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 820D3F64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D3F64h case    3:*/		return 0x820D3F68;
		  /* 820D3F68h */ case    4:  		/* bc 12, CR6_EQ, 144 */
		/* 820D3F68h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D3FF8;  }
		/* 820D3F68h case    4:*/		return 0x820D3F6C;
		  /* 820D3F6Ch */ case    5:  		/* lis R11, -32255 */
		/* 820D3F6Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D3F6Ch case    5:*/		return 0x820D3F70;
		  /* 820D3F70h */ case    6:  		/* addi R28, R11, 26636 */
		/* 820D3F70h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x680C);
		/* 820D3F70h case    6:*/		return 0x820D3F74;
		  /* 820D3F74h */ case    7:  		/* lwz R8, <#[R31 + 8]> */
		/* 820D3F74h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820D3F74h case    7:*/		return 0x820D3F78;
		  /* 820D3F78h */ case    8:  		/* mr R10, R30 */
		/* 820D3F78h case    8:*/		regs.R10 = regs.R30;
		/* 820D3F78h case    8:*/		return 0x820D3F7C;
		  /* 820D3F7Ch */ case    9:  		/* lwz R31, <#[R31 + 12]> */
		/* 820D3F7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820D3F7Ch case    9:*/		return 0x820D3F80;
		  /* 820D3F80h */ case   10:  		/* lwz R11, <#[R8 + 8]> */
		/* 820D3F80h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 820D3F80h case   10:*/		return 0x820D3F84;
		  /* 820D3F84h */ case   11:  		/* lwz R5, <#[R11 + 24]> */
		/* 820D3F84h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000018) );
		/* 820D3F84h case   11:*/		return 0x820D3F88;
		  /* 820D3F88h */ case   12:  		/* mr R11, R5 */
		/* 820D3F88h case   12:*/		regs.R11 = regs.R5;
		/* 820D3F88h case   12:*/		return 0x820D3F8C;
		  /* 820D3F8Ch */ case   13:  		/* lbz R9, <#[R11]> */
		/* 820D3F8Ch case   13:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D3F8Ch case   13:*/		return 0x820D3F90;
		  /* 820D3F90h */ case   14:  		/* lbz R6, <#[R10]> */
		/* 820D3F90h case   14:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 820D3F90h case   14:*/		return 0x820D3F94;
		  /* 820D3F94h */ case   15:  		/* cmpwi CR0, R9, 0 */
		/* 820D3F94h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3F94h case   15:*/		return 0x820D3F98;
		  /* 820D3F98h */ case   16:  		/* subf R9, R6, R9 */
		/* 820D3F98h case   16:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 820D3F98h case   16:*/		return 0x820D3F9C;
		  /* 820D3F9Ch */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 820D3F9Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x820D3FB0;  }
		/* 820D3F9Ch case   17:*/		return 0x820D3FA0;
		  /* 820D3FA0h */ case   18:  		/* addi R11, R11, 1 */
		/* 820D3FA0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D3FA0h case   18:*/		return 0x820D3FA4;
		  /* 820D3FA4h */ case   19:  		/* addi R10, R10, 1 */
		/* 820D3FA4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D3FA4h case   19:*/		return 0x820D3FA8;
		  /* 820D3FA8h */ case   20:  		/* cmpwi CR6, R9, 0 */
		/* 820D3FA8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D3FA8h case   20:*/		return 0x820D3FAC;
		  /* 820D3FACh */ case   21:  		/* bc 12, CR6_EQ, -32 */
		/* 820D3FACh case   21:*/		if ( regs.CR[6].eq ) { return 0x820D3F8C;  }
		/* 820D3FACh case   21:*/		return 0x820D3FB0;
	}
	return 0x820D3FB0;
} // Block from 820D3F58h-820D3FB0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820D3FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3FB0);
		  /* 820D3FB0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D3FB0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D3FB0h case    0:*/		return 0x820D3FB4;
		  /* 820D3FB4h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 820D3FB4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D3FD4;  }
		/* 820D3FB4h case    1:*/		return 0x820D3FB8;
		  /* 820D3FB8h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 820D3FB8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820D3FB8h case    2:*/		return 0x820D3FBC;
		  /* 820D3FBCh */ case    3:  		/* bc 4, CR6_EQ, 84 */
		/* 820D3FBCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D4010;  }
		/* 820D3FBCh case    3:*/		return 0x820D3FC0;
		  /* 820D3FC0h */ case    4:  		/* lwz R11, <#[R8 + 12]> */
		/* 820D3FC0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 820D3FC0h case    4:*/		return 0x820D3FC4;
		  /* 820D3FC4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820D3FC4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D3FC4h case    5:*/		return 0x820D3FC8;
		  /* 820D3FC8h */ case    6:  		/* bc 12, CR6_EQ, 96 */
		/* 820D3FC8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D4028;  }
		/* 820D3FC8h case    6:*/		return 0x820D3FCC;
		  /* 820D3FCCh */ case    7:  		/* addi R29, R11, 16 */
		/* 820D3FCCh case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x10);
		/* 820D3FCCh case    7:*/		return 0x820D3FD0;
		  /* 820D3FD0h */ case    8:  		/* b 32 */
		/* 820D3FD0h case    8:*/		return 0x820D3FF0;
		/* 820D3FD0h case    8:*/		return 0x820D3FD4;
	}
	return 0x820D3FD4;
} // Block from 820D3FB0h-820D3FD4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D3FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3FD4);
		  /* 820D3FD4h */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 820D3FD4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820D3FD4h case    0:*/		return 0x820D3FD8;
		  /* 820D3FD8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820D3FD8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D3FF0;  }
		/* 820D3FD8h case    1:*/		return 0x820D3FDC;
		  /* 820D3FDCh */ case    2:  		/* mr R4, R28 */
		/* 820D3FDCh case    2:*/		regs.R4 = regs.R28;
		/* 820D3FDCh case    2:*/		return 0x820D3FE0;
		  /* 820D3FE0h */ case    3:  		/* mr R6, R30 */
		/* 820D3FE0h case    3:*/		regs.R6 = regs.R30;
		/* 820D3FE0h case    3:*/		return 0x820D3FE4;
		  /* 820D3FE4h */ case    4:  		/* mr R3, R27 */
		/* 820D3FE4h case    4:*/		regs.R3 = regs.R27;
		/* 820D3FE4h case    4:*/		return 0x820D3FE8;
		  /* 820D3FE8h */ case    5:  		/* bl -14080 */
		/* 820D3FE8h case    5:*/		regs.LR = 0x820D3FEC; return 0x820D08E8;
		/* 820D3FE8h case    5:*/		return 0x820D3FEC;
		  /* 820D3FECh */ case    6:  		/* li R7, 1 */
		/* 820D3FECh case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820D3FECh case    6:*/		return 0x820D3FF0;
	}
	return 0x820D3FF0;
} // Block from 820D3FD4h-820D3FF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D3FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3FF0);
		  /* 820D3FF0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820D3FF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D3FF0h case    0:*/		return 0x820D3FF4;
		  /* 820D3FF4h */ case    1:  		/* bc 4, CR6_EQ, -128 */
		/* 820D3FF4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D3F74;  }
		/* 820D3FF4h case    1:*/		return 0x820D3FF8;
	}
	return 0x820D3FF8;
} // Block from 820D3FF0h-820D3FF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D3FF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D3FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D3FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D3FF8);
		  /* 820D3FF8h */ case    0:  		/* rlwinm R11, R7, 0, 24, 31 */
		/* 820D3FF8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R7);
		/* 820D3FF8h case    0:*/		return 0x820D3FFC;
		  /* 820D3FFCh */ case    1:  		/* addic R11, R11, -1 */
		/* 820D3FFCh case    1:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D3FFCh case    1:*/		return 0x820D4000;
		  /* 820D4000h */ case    2:  		/* subfe R11, R11, R11 */
		/* 820D4000h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820D4000h case    2:*/		return 0x820D4004;
		  /* 820D4004h */ case    3:  		/* and R3, R11, R29 */
		/* 820D4004h case    3:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 820D4004h case    3:*/		return 0x820D4008;
	}
	return 0x820D4008;
} // Block from 820D3FF8h-820D4008h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4008);
		  /* 820D4008h */ case    0:  		/* addi R1, R1, 176 */
		/* 820D4008h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820D4008h case    0:*/		return 0x820D400C;
		  /* 820D400Ch */ case    1:  		/* b -273772 */
		/* 820D400Ch case    1:*/		return 0x820912A0;
		/* 820D400Ch case    1:*/		return 0x820D4010;
	}
	return 0x820D4010;
} // Block from 820D4008h-820D4010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4010);
		  /* 820D4010h */ case    0:  		/* lis R11, -32255 */
		/* 820D4010h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4010h case    0:*/		return 0x820D4014;
		  /* 820D4014h */ case    1:  		/* addi R4, R11, 22752 */
		/* 820D4014h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x58E0);
		/* 820D4014h case    1:*/		return 0x820D4018;
		  /* 820D4018h */ case    2:  		/* mr R5, R30 */
		/* 820D4018h case    2:*/		regs.R5 = regs.R30;
		/* 820D4018h case    2:*/		return 0x820D401C;
		  /* 820D401Ch */ case    3:  		/* mr R3, R27 */
		/* 820D401Ch case    3:*/		regs.R3 = regs.R27;
		/* 820D401Ch case    3:*/		return 0x820D4020;
		  /* 820D4020h */ case    4:  		/* bl -14136 */
		/* 820D4020h case    4:*/		regs.LR = 0x820D4024; return 0x820D08E8;
		/* 820D4020h case    4:*/		return 0x820D4024;
		  /* 820D4024h */ case    5:  		/* b -212 */
		/* 820D4024h case    5:*/		return 0x820D3F50;
		/* 820D4024h case    5:*/		return 0x820D4028;
	}
	return 0x820D4028;
} // Block from 820D4010h-820D4028h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D4028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4028);
		  /* 820D4028h */ case    0:  		/* lis R11, -32255 */
		/* 820D4028h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4028h case    0:*/		return 0x820D402C;
		  /* 820D402Ch */ case    1:  		/* addi R4, R11, 22976 */
		/* 820D402Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x59C0);
		/* 820D402Ch case    1:*/		return 0x820D4030;
		  /* 820D4030h */ case    2:  		/* b -24 */
		/* 820D4030h case    2:*/		return 0x820D4018;
		/* 820D4030h case    2:*/		return 0x820D4034;
		  /* 820D4034h */ case    3:  		/* nop */
		/* 820D4034h case    3:*/		cpu::op::nop();
		/* 820D4034h case    3:*/		return 0x820D4038;
	}
	return 0x820D4038;
} // Block from 820D4028h-820D4038h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4038);
		  /* 820D4038h */ case    0:  		/* mfspr R12, LR */
		/* 820D4038h case    0:*/		regs.R12 = regs.LR;
		/* 820D4038h case    0:*/		return 0x820D403C;
		  /* 820D403Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820D403Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D403Ch case    1:*/		return 0x820D4040;
		  /* 820D4040h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820D4040h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820D4040h case    2:*/		return 0x820D4044;
		  /* 820D4044h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 820D4044h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820D4044h case    3:*/		return 0x820D4048;
		  /* 820D4048h */ case    4:  		/* lis R11, -32255 */
		/* 820D4048h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4048h case    4:*/		return 0x820D404C;
		  /* 820D404Ch */ case    5:  		/* li R6, 1 */
		/* 820D404Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820D404Ch case    5:*/		return 0x820D4050;
		  /* 820D4050h */ case    6:  		/* addi R5, R11, 26676 */
		/* 820D4050h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6834);
		/* 820D4050h case    6:*/		return 0x820D4054;
		  /* 820D4054h */ case    7:  		/* li R31, 0 */
		/* 820D4054h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820D4054h case    7:*/		return 0x820D4058;
		  /* 820D4058h */ case    8:  		/* bl -296 */
		/* 820D4058h case    8:*/		regs.LR = 0x820D405C; return 0x820D3F30;
		/* 820D4058h case    8:*/		return 0x820D405C;
		  /* 820D405Ch */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820D405Ch case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820D405Ch case    9:*/		return 0x820D4060;
		  /* 820D4060h */ case   10:  		/* bc 12, CR0_EQ, 28 */
		/* 820D4060h case   10:*/		if ( regs.CR[0].eq ) { return 0x820D407C;  }
		/* 820D4060h case   10:*/		return 0x820D4064;
		  /* 820D4064h */ case   11:  		/* addi R4, R1, 80 */
		/* 820D4064h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820D4064h case   11:*/		return 0x820D4068;
		  /* 820D4068h */ case   12:  		/* stw R31, <#[R1 + 80]> */
		/* 820D4068h case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 820D4068h case   12:*/		return 0x820D406C;
		  /* 820D406Ch */ case   13:  		/* bl -19540 */
		/* 820D406Ch case   13:*/		regs.LR = 0x820D4070; return 0x820CF418;
		/* 820D406Ch case   13:*/		return 0x820D4070;
	}
	return 0x820D4070;
} // Block from 820D4038h-820D4070h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D4070h
// Function '?MergeInstructions@CUAssembler@D3DXShader@@IAAPAVCNodeUAsmInstruction@2@PAV32@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4070);
		  /* 820D4070h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820D4070h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D4070h case    0:*/		return 0x820D4074;
		  /* 820D4074h */ case    1:  		/* bc 12, CR0_LT, 8 */
		/* 820D4074h case    1:*/		if ( regs.CR[0].lt ) { return 0x820D407C;  }
		/* 820D4074h case    1:*/		return 0x820D4078;
		  /* 820D4078h */ case    2:  		/* lwz R31, <#[R1 + 80]> */
		/* 820D4078h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 820D4078h case    2:*/		return 0x820D407C;
	}
	return 0x820D407C;
} // Block from 820D4070h-820D407Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D407Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D407C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D407C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D407C);
		  /* 820D407Ch */ case    0:  		/* mr R3, R31 */
		/* 820D407Ch case    0:*/		regs.R3 = regs.R31;
		/* 820D407Ch case    0:*/		return 0x820D4080;
		  /* 820D4080h */ case    1:  		/* addi R1, R1, 112 */
		/* 820D4080h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820D4080h case    1:*/		return 0x820D4084;
		  /* 820D4084h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820D4084h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D4084h case    2:*/		return 0x820D4088;
		  /* 820D4088h */ case    3:  		/* mtspr LR, R12 */
		/* 820D4088h case    3:*/		regs.LR = regs.R12;
		/* 820D4088h case    3:*/		return 0x820D408C;
		  /* 820D408Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820D408Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820D408Ch case    4:*/		return 0x820D4090;
		  /* 820D4090h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820D4090h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820D4090h case    5:*/		return 0x820D4094;
	}
	return 0x820D4094;
} // Block from 820D407Ch-820D4094h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D4094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4094);
		  /* 820D4094h */ case    0:  		/* nop */
		/* 820D4094h case    0:*/		cpu::op::nop();
		/* 820D4094h case    0:*/		return 0x820D4098;
	}
	return 0x820D4098;
} // Block from 820D4094h-820D4098h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4098);
		  /* 820D4098h */ case    0:  		/* mfspr R12, LR */
		/* 820D4098h case    0:*/		regs.R12 = regs.LR;
		/* 820D4098h case    0:*/		return 0x820D409C;
		  /* 820D409Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820D409Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D409Ch case    1:*/		return 0x820D40A0;
		  /* 820D40A0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820D40A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820D40A0h case    2:*/		return 0x820D40A4;
		  /* 820D40A4h */ case    3:  		/* lwz R10, <#[R3 + 96]> */
		/* 820D40A4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000060) );
		/* 820D40A4h case    3:*/		return 0x820D40A8;
		  /* 820D40A8h */ case    4:  		/* mr R5, R4 */
		/* 820D40A8h case    4:*/		regs.R5 = regs.R4;
		/* 820D40A8h case    4:*/		return 0x820D40AC;
		  /* 820D40ACh */ case    5:  		/* li R11, 0 */
		/* 820D40ACh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D40ACh case    5:*/		return 0x820D40B0;
		  /* 820D40B0h */ case    6:  		/* cmpwi CR6, R10, 0 */
		/* 820D40B0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820D40B0h case    6:*/		return 0x820D40B4;
		  /* 820D40B4h */ case    7:  		/* bc 4, CR6_GT, 24 */
		/* 820D40B4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x820D40CC;  }
		/* 820D40B4h case    7:*/		return 0x820D40B8;
		  /* 820D40B8h */ case    8:  		/* lis R11, -32255 */
		/* 820D40B8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D40B8h case    8:*/		return 0x820D40BC;
		  /* 820D40BCh */ case    9:  		/* addi R4, R11, 26688 */
		/* 820D40BCh case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6840);
		/* 820D40BCh case    9:*/		return 0x820D40C0;
		  /* 820D40C0h */ case   10:  		/* bl -14296 */
		/* 820D40C0h case   10:*/		regs.LR = 0x820D40C4; return 0x820D08E8;
		/* 820D40C0h case   10:*/		return 0x820D40C4;
		  /* 820D40C4h */ case   11:  		/* lis R11, -32768 */
		/* 820D40C4h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 820D40C4h case   11:*/		return 0x820D40C8;
		  /* 820D40C8h */ case   12:  		/* ori R11, R11, 16389 */
		/* 820D40C8h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4005);
		/* 820D40C8h case   12:*/		return 0x820D40CC;
	}
	return 0x820D40CC;
} // Block from 820D4098h-820D40CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D40CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D40CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D40CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D40CC);
		  /* 820D40CCh */ case    0:  		/* mr R3, R11 */
		/* 820D40CCh case    0:*/		regs.R3 = regs.R11;
		/* 820D40CCh case    0:*/		return 0x820D40D0;
		  /* 820D40D0h */ case    1:  		/* addi R1, R1, 112 */
		/* 820D40D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820D40D0h case    1:*/		return 0x820D40D4;
		  /* 820D40D4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820D40D4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820D40D4h case    2:*/		return 0x820D40D8;
		  /* 820D40D8h */ case    3:  		/* mtspr LR, R12 */
		/* 820D40D8h case    3:*/		regs.LR = regs.R12;
		/* 820D40D8h case    3:*/		return 0x820D40DC;
		  /* 820D40DCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 820D40DCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820D40DCh case    4:*/		return 0x820D40E0;
	}
	return 0x820D40E0;
} // Block from 820D40CCh-820D40E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D40E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D40E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D40E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D40E0);
		  /* 820D40E0h */ case    0:  		/* mfspr R12, LR */
		/* 820D40E0h case    0:*/		regs.R12 = regs.LR;
		/* 820D40E0h case    0:*/		return 0x820D40E4;
		  /* 820D40E4h */ case    1:  		/* bl -274068 */
		/* 820D40E4h case    1:*/		regs.LR = 0x820D40E8; return 0x82091250;
		/* 820D40E4h case    1:*/		return 0x820D40E8;
		  /* 820D40E8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820D40E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820D40E8h case    2:*/		return 0x820D40EC;
		  /* 820D40ECh */ case    3:  		/* li R11, 4 */
		/* 820D40ECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820D40ECh case    3:*/		return 0x820D40F0;
		  /* 820D40F0h */ case    4:  		/* lwz R9, <#[R6 + 36]> */
		/* 820D40F0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 820D40F0h case    4:*/		return 0x820D40F4;
		  /* 820D40F4h */ case    5:  		/* mr R31, R4 */
		/* 820D40F4h case    5:*/		regs.R31 = regs.R4;
		/* 820D40F4h case    5:*/		return 0x820D40F8;
		  /* 820D40F8h */ case    6:  		/* mr R26, R5 */
		/* 820D40F8h case    6:*/		regs.R26 = regs.R5;
		/* 820D40F8h case    6:*/		return 0x820D40FC;
		  /* 820D40FCh */ case    7:  		/* li R28, 0 */
		/* 820D40FCh case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820D40FCh case    7:*/		return 0x820D4100;
		  /* 820D4100h */ case    8:  		/* li R8, 0 */
		/* 820D4100h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820D4100h case    8:*/		return 0x820D4104;
		  /* 820D4104h */ case    9:  		/* mtspr CTR, R11 */
		/* 820D4104h case    9:*/		regs.CTR = regs.R11;
		/* 820D4104h case    9:*/		return 0x820D4108;
		  /* 820D4108h */ case   10:  		/* li R27, 0 */
		/* 820D4108h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820D4108h case   10:*/		return 0x820D410C;
		  /* 820D410Ch */ case   11:  		/* li R30, 0 */
		/* 820D410Ch case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820D410Ch case   11:*/		return 0x820D4110;
		  /* 820D4110h */ case   12:  		/* li R29, 0 */
		/* 820D4110h case   12:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820D4110h case   12:*/		return 0x820D4114;
		  /* 820D4114h */ case   13:  		/* li R10, 0 */
		/* 820D4114h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820D4114h case   13:*/		return 0x820D4118;
		  /* 820D4118h */ case   14:  		/* li R11, 0 */
		/* 820D4118h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D4118h case   14:*/		return 0x820D411C;
		  /* 820D411Ch */ case   15:  		/* srw R7, R9, R11 */
		/* 820D411Ch case   15:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R9,regs.R11);
		/* 820D411Ch case   15:*/		return 0x820D4120;
		  /* 820D4120h */ case   16:  		/* subf R7, R10, R7 */
		/* 820D4120h case   16:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R10,regs.R7);
		/* 820D4120h case   16:*/		return 0x820D4124;
		  /* 820D4124h */ case   17:  		/* addi R10, R10, 1 */
		/* 820D4124h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D4124h case   17:*/		return 0x820D4128;
		  /* 820D4128h */ case   18:  		/* rlwinm R7, R7, 0, 30, 31 */
		/* 820D4128h case   18:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R7);
		/* 820D4128h case   18:*/		return 0x820D412C;
		  /* 820D412Ch */ case   19:  		/* slw R7, R7, R11 */
		/* 820D412Ch case   19:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 820D412Ch case   19:*/		return 0x820D4130;
		  /* 820D4130h */ case   20:  		/* or R28, R7, R28 */
		/* 820D4130h case   20:*/		cpu::op::or<0>(regs,&regs.R28,regs.R7,regs.R28);
		/* 820D4130h case   20:*/		return 0x820D4134;
		  /* 820D4134h */ case   21:  		/* addi R11, R11, 2 */
		/* 820D4134h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820D4134h case   21:*/		return 0x820D4138;
		  /* 820D4138h */ case   22:  		/* bc 16, CR0_LT, -28 */
		/* 820D4138h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D411C;  }
		/* 820D4138h case   22:*/		return 0x820D413C;
		  /* 820D413Ch */ case   23:  		/* lwz R11, <#[R6 + 20]> */
		/* 820D413Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000014) );
		/* 820D413Ch case   23:*/		return 0x820D4140;
		  /* 820D4140h */ case   24:  		/* lis R10, 256 */
		/* 820D4140h case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0x100);
		/* 820D4140h case   24:*/		return 0x820D4144;
		  /* 820D4144h */ case   25:  		/* cmplw CR6, R11, R10 */
		/* 820D4144h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D4144h case   25:*/		return 0x820D4148;
		  /* 820D4148h */ case   26:  		/* bc 12, CR6_EQ, 32 */
		/* 820D4148h case   26:*/		if ( regs.CR[6].eq ) { return 0x820D4168;  }
		/* 820D4148h case   26:*/		return 0x820D414C;
		  /* 820D414Ch */ case   27:  		/* lis R10, 2816 */
		/* 820D414Ch case   27:*/		cpu::op::lis<0>(regs,&regs.R10,0xB00);
		/* 820D414Ch case   27:*/		return 0x820D4150;
		  /* 820D4150h */ case   28:  		/* cmplw CR6, R11, R10 */
		/* 820D4150h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D4150h case   28:*/		return 0x820D4154;
		  /* 820D4154h */ case   29:  		/* bc 12, CR6_EQ, 64 */
		/* 820D4154h case   29:*/		if ( regs.CR[6].eq ) { return 0x820D4194;  }
		/* 820D4154h case   29:*/		return 0x820D4158;
		  /* 820D4158h */ case   30:  		/* lis R10, 3072 */
		/* 820D4158h case   30:*/		cpu::op::lis<0>(regs,&regs.R10,0xC00);
		/* 820D4158h case   30:*/		return 0x820D415C;
		  /* 820D415Ch */ case   31:  		/* cmplw CR6, R11, R10 */
		/* 820D415Ch case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D415Ch case   31:*/		return 0x820D4160;
		  /* 820D4160h */ case   32:  		/* bc 4, CR6_EQ, 12 */
		/* 820D4160h case   32:*/		if ( !regs.CR[6].eq ) { return 0x820D416C;  }
		/* 820D4160h case   32:*/		return 0x820D4164;
		  /* 820D4164h */ case   33:  		/* li R8, 1 */
		/* 820D4164h case   33:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820D4164h case   33:*/		return 0x820D4168;
	}
	return 0x820D4168;
} // Block from 820D40E0h-820D4168h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820D4168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4168);
		  /* 820D4168h */ case    0:  		/* li R27, 1 */
		/* 820D4168h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820D4168h case    0:*/		return 0x820D416C;
	}
	return 0x820D416C;
} // Block from 820D4168h-820D416Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D416Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D416C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D416C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D416C);
		  /* 820D416Ch */ case    0:  		/* lwz R11, <#[R6 + 16]> */
		/* 820D416Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000010) );
		/* 820D416Ch case    0:*/		return 0x820D4170;
		  /* 820D4170h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D4170h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D4170h case    1:*/		return 0x820D4174;
		  /* 820D4174h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820D4174h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D41A8;  }
		/* 820D4174h case    2:*/		return 0x820D4178;
		  /* 820D4178h */ case    3:  		/* cmplwi CR6, R11, 2 */
		/* 820D4178h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820D4178h case    3:*/		return 0x820D417C;
		  /* 820D417Ch */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 820D417Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820D419C;  }
		/* 820D417Ch case    4:*/		return 0x820D4180;
		  /* 820D4180h */ case    5:  		/* lis R11, -32255 */
		/* 820D4180h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4180h case    5:*/		return 0x820D4184;
		  /* 820D4184h */ case    6:  		/* addi R5, R26, 1 */
		/* 820D4184h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R26,0x1);
		/* 820D4184h case    6:*/		return 0x820D4188;
		  /* 820D4188h */ case    7:  		/* addi R4, R11, 26816 */
		/* 820D4188h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x68C0);
		/* 820D4188h case    7:*/		return 0x820D418C;
		  /* 820D418Ch */ case    8:  		/* bl -14500 */
		/* 820D418Ch case    8:*/		regs.LR = 0x820D4190; return 0x820D08E8;
		/* 820D418Ch case    8:*/		return 0x820D4190;
		  /* 820D4190h */ case    9:  		/* b 76 */
		/* 820D4190h case    9:*/		return 0x820D41DC;
		/* 820D4190h case    9:*/		return 0x820D4194;
	}
	return 0x820D4194;
} // Block from 820D416Ch-820D4194h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D4194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4194);
		  /* 820D4194h */ case    0:  		/* li R8, 1 */
		/* 820D4194h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820D4194h case    0:*/		return 0x820D4198;
		  /* 820D4198h */ case    1:  		/* b -44 */
		/* 820D4198h case    1:*/		return 0x820D416C;
		/* 820D4198h case    1:*/		return 0x820D419C;
	}
	return 0x820D419C;
} // Block from 820D4194h-820D419Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D419Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D419C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D419C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D419C);
		  /* 820D419Ch */ case    0:  		/* lbz R30, <#[R6 + 27]> */
		/* 820D419Ch case    0:*/		cpu::mem::load8z( regs, &regs.R30, (uint32)(regs.R6 + 0x0000001B) );
		/* 820D419Ch case    0:*/		return 0x820D41A0;
		  /* 820D41A0h */ case    1:  		/* li R29, 0 */
		/* 820D41A0h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820D41A0h case    1:*/		return 0x820D41A4;
		  /* 820D41A4h */ case    2:  		/* b 56 */
		/* 820D41A4h case    2:*/		return 0x820D41DC;
		/* 820D41A4h case    2:*/		return 0x820D41A8;
	}
	return 0x820D41A8;
} // Block from 820D419Ch-820D41A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D41A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D41A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D41A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D41A8);
		  /* 820D41A8h */ case    0:  		/* lwz R11, <#[R6 + 24]> */
		/* 820D41A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000018) );
		/* 820D41A8h case    0:*/		return 0x820D41AC;
		  /* 820D41ACh */ case    1:  		/* li R29, 1 */
		/* 820D41ACh case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820D41ACh case    1:*/		return 0x820D41B0;
		  /* 820D41B0h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 820D41B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D41B0h case    2:*/		return 0x820D41B4;
		  /* 820D41B4h */ case    3:  		/* rlwinm R30, R11, 0, 26, 31 */
		/* 820D41B4h case    3:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R30,regs.R11);
		/* 820D41B4h case    3:*/		return 0x820D41B8;
		  /* 820D41B8h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 820D41B8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D41C0;  }
		/* 820D41B8h case    4:*/		return 0x820D41BC;
		  /* 820D41BCh */ case    5:  		/* ori R30, R30, 128 */
		/* 820D41BCh case    5:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x80);
		/* 820D41BCh case    5:*/		return 0x820D41C0;
	}
	return 0x820D41C0;
} // Block from 820D41A8h-820D41C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D41C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D41C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D41C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D41C0);
		  /* 820D41C0h */ case    0:  		/* lwz R11, <#[R6 + 40]> */
		/* 820D41C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000028) );
		/* 820D41C0h case    0:*/		return 0x820D41C4;
		  /* 820D41C4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D41C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D41C4h case    1:*/		return 0x820D41C8;
		  /* 820D41C8h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820D41C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D41DC;  }
		/* 820D41C8h case    2:*/		return 0x820D41CC;
		  /* 820D41CCh */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 820D41CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820D41CCh case    3:*/		return 0x820D41D0;
		  /* 820D41D0h */ case    4:  		/* cmplwi CR6, R11, 15 */
		/* 820D41D0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 820D41D0h case    4:*/		return 0x820D41D4;
		  /* 820D41D4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820D41D4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D41DC;  }
		/* 820D41D4h case    5:*/		return 0x820D41D8;
		  /* 820D41D8h */ case    6:  		/* ori R30, R30, 64 */
		/* 820D41D8h case    6:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x40);
		/* 820D41D8h case    6:*/		return 0x820D41DC;
	}
	return 0x820D41DC;
} // Block from 820D41C0h-820D41DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D41DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D41DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D41DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D41DC);
		  /* 820D41DCh */ case    0:  		/* cmplwi CR6, R26, 1 */
		/* 820D41DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000001);
		/* 820D41DCh case    0:*/		return 0x820D41E0;
		  /* 820D41E0h */ case    1:  		/* bc 12, CR6_LT, 80 */
		/* 820D41E0h case    1:*/		if ( regs.CR[6].lt ) { return 0x820D4230;  }
		/* 820D41E0h case    1:*/		return 0x820D41E4;
		  /* 820D41E4h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820D41E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D420C;  }
		/* 820D41E4h case    2:*/		return 0x820D41E8;
		  /* 820D41E8h */ case    3:  		/* cmplwi CR6, R26, 3 */
		/* 820D41E8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000003);
		/* 820D41E8h case    3:*/		return 0x820D41EC;
		  /* 820D41ECh */ case    4:  		/* bc 4, CR6_LT, 100 */
		/* 820D41ECh case    4:*/		if ( !regs.CR[6].lt ) { return 0x820D4250;  }
		/* 820D41ECh case    4:*/		return 0x820D41F0;
		  /* 820D41F0h */ case    5:  		/* stb R28, <#[R31 + 7]> */
		/* 820D41F0h case    5:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x00000007) );
		/* 820D41F0h case    5:*/		return 0x820D41F4;
		  /* 820D41F4h */ case    6:  		/* lwz R10, <#[R31 + 4]> */
		/* 820D41F4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820D41F4h case    6:*/		return 0x820D41F8;
		  /* 820D41F8h */ case    7:  		/* stb R30, <#[R31 + 11]> */
		/* 820D41F8h case    7:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x0000000B) );
		/* 820D41F8h case    7:*/		return 0x820D41FC;
		  /* 820D41FCh */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 820D41FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820D41FCh case    8:*/		return 0x820D4200;
		  /* 820D4200h */ case    9:  		/* rlwimi R11, R29, 29, 2, 2 */
		/* 820D4200h case    9:*/		cpu::op::rlwimi<0,29,2,2>(regs,&regs.R11,regs.R29);
		/* 820D4200h case    9:*/		return 0x820D4204;
		  /* 820D4204h */ case   10:  		/* rlwimi R10, R27, 24, 7, 7 */
		/* 820D4204h case   10:*/		cpu::op::rlwimi<0,24,7,7>(regs,&regs.R10,regs.R27);
		/* 820D4204h case   10:*/		return 0x820D4208;
		  /* 820D4208h */ case   11:  		/* b 28 */
		/* 820D4208h case   11:*/		return 0x820D4224;
		/* 820D4208h case   11:*/		return 0x820D420C;
	}
	return 0x820D420C;
} // Block from 820D41DCh-820D420Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D420Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D420C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D420C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D420C);
		  /* 820D420Ch */ case    0:  		/* stb R30, <#[R31 + 10]> */
		/* 820D420Ch case    0:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x0000000A) );
		/* 820D420Ch case    0:*/		return 0x820D4210;
		  /* 820D4210h */ case    1:  		/* stb R28, <#[R31 + 6]> */
		/* 820D4210h case    1:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x00000006) );
		/* 820D4210h case    1:*/		return 0x820D4214;
		  /* 820D4214h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 820D4214h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820D4214h case    2:*/		return 0x820D4218;
		  /* 820D4218h */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 820D4218h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820D4218h case    3:*/		return 0x820D421C;
		  /* 820D421Ch */ case    4:  		/* rlwimi R11, R29, 30, 1, 1 */
		/* 820D421Ch case    4:*/		cpu::op::rlwimi<0,30,1,1>(regs,&regs.R11,regs.R29);
		/* 820D421Ch case    4:*/		return 0x820D4220;
		  /* 820D4220h */ case    5:  		/* rlwimi R10, R27, 25, 6, 6 */
		/* 820D4220h case    5:*/		cpu::op::rlwimi<0,25,6,6>(regs,&regs.R10,regs.R27);
		/* 820D4220h case    5:*/		return 0x820D4224;
	}
	return 0x820D4224;
} // Block from 820D420Ch-820D4224h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D4224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4224);
		  /* 820D4224h */ case    0:  		/* stw R10, <#[R31 + 4]> */
		/* 820D4224h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820D4224h case    0:*/		return 0x820D4228;
		  /* 820D4228h */ case    1:  		/* stw R11, <#[R31 + 8]> */
		/* 820D4228h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820D4228h case    1:*/		return 0x820D422C;
		  /* 820D422Ch */ case    2:  		/* b 36 */
		/* 820D422Ch case    2:*/		return 0x820D4250;
		/* 820D422Ch case    2:*/		return 0x820D4230;
	}
	return 0x820D4230;
} // Block from 820D4224h-820D4230h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4230);
		  /* 820D4230h */ case    0:  		/* stb R28, <#[R31 + 5]> */
		/* 820D4230h case    0:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x00000005) );
		/* 820D4230h case    0:*/		return 0x820D4234;
		  /* 820D4234h */ case    1:  		/* stb R30, <#[R31 + 9]> */
		/* 820D4234h case    1:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x00000009) );
		/* 820D4234h case    1:*/		return 0x820D4238;
		  /* 820D4238h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 820D4238h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820D4238h case    2:*/		return 0x820D423C;
		  /* 820D423Ch */ case    3:  		/* rlwimi R10, R29, 31, 0, 0 */
		/* 820D423Ch case    3:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R10,regs.R29);
		/* 820D423Ch case    3:*/		return 0x820D4240;
		  /* 820D4240h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 820D4240h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820D4240h case    4:*/		return 0x820D4244;
		  /* 820D4244h */ case    5:  		/* stw R10, <#[R31 + 8]> */
		/* 820D4244h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820D4244h case    5:*/		return 0x820D4248;
		  /* 820D4248h */ case    6:  		/* rlwimi R11, R27, 26, 5, 5 */
		/* 820D4248h case    6:*/		cpu::op::rlwimi<0,26,5,5>(regs,&regs.R11,regs.R27);
		/* 820D4248h case    6:*/		return 0x820D424C;
		  /* 820D424Ch */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 820D424Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820D424Ch case    7:*/		return 0x820D4250;
	}
	return 0x820D4250;
} // Block from 820D4230h-820D4250h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D4250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4250);
		  /* 820D4250h */ case    0:  		/* addi R1, R1, 176 */
		/* 820D4250h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820D4250h case    0:*/		return 0x820D4254;
		  /* 820D4254h */ case    1:  		/* b -274356 */
		/* 820D4254h case    1:*/		return 0x820912A0;
		/* 820D4254h case    1:*/		return 0x820D4258;
	}
	return 0x820D4258;
} // Block from 820D4250h-820D4258h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4258);
		  /* 820D4258h */ case    0:  		/* mfspr R12, LR */
		/* 820D4258h case    0:*/		regs.R12 = regs.LR;
		/* 820D4258h case    0:*/		return 0x820D425C;
		  /* 820D425Ch */ case    1:  		/* bl -274456 */
		/* 820D425Ch case    1:*/		regs.LR = 0x820D4260; return 0x82091244;
		/* 820D425Ch case    1:*/		return 0x820D4260;
		  /* 820D4260h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820D4260h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820D4260h case    2:*/		return 0x820D4264;
		  /* 820D4264h */ case    3:  		/* addi R11, R1, 112 */
		/* 820D4264h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820D4264h case    3:*/		return 0x820D4268;
		  /* 820D4268h */ case    4:  		/* li R25, 0 */
		/* 820D4268h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820D4268h case    4:*/		return 0x820D426C;
		  /* 820D426Ch */ case    5:  		/* mr R24, R3 */
		/* 820D426Ch case    5:*/		regs.R24 = regs.R3;
		/* 820D426Ch case    5:*/		return 0x820D4270;
		  /* 820D4270h */ case    6:  		/* mr R26, R4 */
		/* 820D4270h case    6:*/		regs.R26 = regs.R4;
		/* 820D4270h case    6:*/		return 0x820D4274;
		  /* 820D4274h */ case    7:  		/* addi R31, R1, 112 */
		/* 820D4274h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x70);
		/* 820D4274h case    7:*/		return 0x820D4278;
		  /* 820D4278h */ case    8:  		/* std R25, <#[R11]> */
		/* 820D4278h case    8:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 820D4278h case    8:*/		return 0x820D427C;
		  /* 820D427Ch */ case    9:  		/* lis R11, -32255 */
		/* 820D427Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D427Ch case    9:*/		return 0x820D4280;
		  /* 820D4280h */ case   10:  		/* mr R28, R25 */
		/* 820D4280h case   10:*/		regs.R28 = regs.R25;
		/* 820D4280h case   10:*/		return 0x820D4284;
		  /* 820D4284h */ case   11:  		/* addi R29, R5, 76 */
		/* 820D4284h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R5,0x4C);
		/* 820D4284h case   11:*/		return 0x820D4288;
		  /* 820D4288h */ case   12:  		/* li R23, 1 */
		/* 820D4288h case   12:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 820D4288h case   12:*/		return 0x820D428C;
		  /* 820D428Ch */ case   13:  		/* addi R27, R11, 27620 */
		/* 820D428Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x6BE4);
		/* 820D428Ch case   13:*/		return 0x820D4290;
		  /* 820D4290h */ case   14:  		/* lwz R30, <#[R29 + 16]> */
		/* 820D4290h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000010) );
		/* 820D4290h case   14:*/		return 0x820D4294;
		  /* 820D4294h */ case   15:  		/* cmplwi CR6, R30, 0 */
		/* 820D4294h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820D4294h case   15:*/		return 0x820D4298;
		  /* 820D4298h */ case   16:  		/* bc 12, CR6_EQ, 280 */
		/* 820D4298h case   16:*/		if ( regs.CR[6].eq ) { return 0x820D43B0;  }
		/* 820D4298h case   16:*/		return 0x820D429C;
		  /* 820D429Ch */ case   17:  		/* lwz R11, <#[R30 + 16]> */
		/* 820D429Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820D429Ch case   17:*/		return 0x820D42A0;
		  /* 820D42A0h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820D42A0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D42A0h case   18:*/		return 0x820D42A4;
		  /* 820D42A4h */ case   19:  		/* bc 12, CR6_EQ, 80 */
		/* 820D42A4h case   19:*/		if ( regs.CR[6].eq ) { return 0x820D42F4;  }
		/* 820D42A4h case   19:*/		return 0x820D42A8;
		  /* 820D42A8h */ case   20:  		/* cmplwi CR6, R11, 2 */
		/* 820D42A8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820D42A8h case   20:*/		return 0x820D42AC;
		  /* 820D42ACh */ case   21:  		/* bc 12, CR6_EQ, 452 */
		/* 820D42ACh case   21:*/		if ( regs.CR[6].eq ) { return 0x820D4470;  }
		/* 820D42ACh case   21:*/		return 0x820D42B0;
		  /* 820D42B0h */ case   22:  		/* cmplwi CR6, R11, 4 */
		/* 820D42B0h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820D42B0h case   22:*/		return 0x820D42B4;
		  /* 820D42B4h */ case   23:  		/* bc 12, CR6_EQ, 36 */
		/* 820D42B4h case   23:*/		if ( regs.CR[6].eq ) { return 0x820D42D8;  }
		/* 820D42B4h case   23:*/		return 0x820D42B8;
		  /* 820D42B8h */ case   24:  		/* cmplwi CR6, R11, 6 */
		/* 820D42B8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 820D42B8h case   24:*/		return 0x820D42BC;
		  /* 820D42BCh */ case   25:  		/* bc 12, CR6_EQ, 28 */
		/* 820D42BCh case   25:*/		if ( regs.CR[6].eq ) { return 0x820D42D8;  }
		/* 820D42BCh case   25:*/		return 0x820D42C0;
		  /* 820D42C0h */ case   26:  		/* cmplwi CR6, R11, 8 */
		/* 820D42C0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 820D42C0h case   26:*/		return 0x820D42C4;
		  /* 820D42C4h */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 820D42C4h case   27:*/		if ( regs.CR[6].eq ) { return 0x820D42D8;  }
		/* 820D42C4h case   27:*/		return 0x820D42C8;
		  /* 820D42C8h */ case   28:  		/* mr R4, R27 */
		/* 820D42C8h case   28:*/		regs.R4 = regs.R27;
		/* 820D42C8h case   28:*/		return 0x820D42CC;
		  /* 820D42CCh */ case   29:  		/* mr R3, R24 */
		/* 820D42CCh case   29:*/		regs.R3 = regs.R24;
		/* 820D42CCh case   29:*/		return 0x820D42D0;
		  /* 820D42D0h */ case   30:  		/* bl -14824 */
		/* 820D42D0h case   30:*/		regs.LR = 0x820D42D4; return 0x820D08E8;
		/* 820D42D0h case   30:*/		return 0x820D42D4;
		  /* 820D42D4h */ case   31:  		/* b 48 */
		/* 820D42D4h case   31:*/		return 0x820D4304;
		/* 820D42D4h case   31:*/		return 0x820D42D8;
	}
	return 0x820D42D8;
} // Block from 820D4258h-820D42D8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820D42D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D42D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D42D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D42D8);
		  /* 820D42D8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820D42D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D42D8h case    0:*/		return 0x820D42DC;
		  /* 820D42DCh */ case    1:  		/* lis R10, -32768 */
		/* 820D42DCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 820D42DCh case    1:*/		return 0x820D42E0;
		  /* 820D42E0h */ case    2:  		/* lwz R9, <#[R30 + 24]> */
		/* 820D42E0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000018) );
		/* 820D42E0h case    2:*/		return 0x820D42E4;
		  /* 820D42E4h */ case    3:  		/* rlwinm R11, R11, 0, 7, 31 */
		/* 820D42E4h case    3:*/		cpu::op::rlwinm<0,0,7,31>(regs,&regs.R11,regs.R11);
		/* 820D42E4h case    3:*/		return 0x820D42E8;
		  /* 820D42E8h */ case    4:  		/* rlwimi R10, R9, 25, 1, 6 */
		/* 820D42E8h case    4:*/		cpu::op::rlwimi<0,25,1,6>(regs,&regs.R10,regs.R9);
		/* 820D42E8h case    4:*/		return 0x820D42EC;
		  /* 820D42ECh */ case    5:  		/* or R11, R10, R11 */
		/* 820D42ECh case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D42ECh case    5:*/		return 0x820D42F0;
		  /* 820D42F0h */ case    6:  		/* b 16 */
		/* 820D42F0h case    6:*/		return 0x820D4300;
		/* 820D42F0h case    6:*/		return 0x820D42F4;
	}
	return 0x820D42F4;
} // Block from 820D42D8h-820D42F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D42F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D42F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D42F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D42F4);
		  /* 820D42F4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820D42F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D42F4h case    0:*/		return 0x820D42F8;
		  /* 820D42F8h */ case    1:  		/* lwz R10, <#[R30 + 24]> */
		/* 820D42F8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 820D42F8h case    1:*/		return 0x820D42FC;
		  /* 820D42FCh */ case    2:  		/* rlwimi R11, R10, 25, 1, 6 */
		/* 820D42FCh case    2:*/		cpu::op::rlwimi<0,25,1,6>(regs,&regs.R11,regs.R10);
		/* 820D42FCh case    2:*/		return 0x820D4300;
	}
	return 0x820D4300;
} // Block from 820D42F4h-820D4300h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4300);
		  /* 820D4300h */ case    0:  		/* stw R11, <#[R31]> */
		/* 820D4300h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D4300h case    0:*/		return 0x820D4304;
	}
	return 0x820D4304;
} // Block from 820D4300h-820D4304h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4304);
		  /* 820D4304h */ case    0:  		/* mr R3, R24 */
		/* 820D4304h case    0:*/		regs.R3 = regs.R24;
		/* 820D4304h case    0:*/		return 0x820D4308;
		  /* 820D4308h */ case    1:  		/* lwz R4, <#[R30 + 32]> */
		/* 820D4308h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000020) );
		/* 820D4308h case    1:*/		return 0x820D430C;
		  /* 820D430Ch */ case    2:  		/* bl -21452 */
		/* 820D430Ch case    2:*/		regs.LR = 0x820D4310; return 0x820CEF40;
		/* 820D430Ch case    2:*/		return 0x820D4310;
		  /* 820D4310h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 820D4310h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820D4310h case    3:*/		return 0x820D4314;
		  /* 820D4314h */ case    4:  		/* bc 12, CR6_EQ, 368 */
		/* 820D4314h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D4484;  }
		/* 820D4314h case    4:*/		return 0x820D4318;
		  /* 820D4318h */ case    5:  		/* mr R8, R25 */
		/* 820D4318h case    5:*/		regs.R8 = regs.R25;
		/* 820D4318h case    5:*/		return 0x820D431C;
		  /* 820D431Ch */ case    6:  		/* mr R10, R25 */
		/* 820D431Ch case    6:*/		regs.R10 = regs.R25;
		/* 820D431Ch case    6:*/		return 0x820D4320;
		  /* 820D4320h */ case    7:  		/* mr R9, R25 */
		/* 820D4320h case    7:*/		regs.R9 = regs.R25;
		/* 820D4320h case    7:*/		return 0x820D4324;
		  /* 820D4324h */ case    8:  		/* srw R11, R3, R9 */
		/* 820D4324h case    8:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R3,regs.R9);
		/* 820D4324h case    8:*/		return 0x820D4328;
		  /* 820D4328h */ case    9:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 820D4328h case    9:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 820D4328h case    9:*/		return 0x820D432C;
		  /* 820D432Ch */ case   10:  		/* cmplwi CR6, R11, 1 */
		/* 820D432Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D432Ch case   10:*/		return 0x820D4330;
		  /* 820D4330h */ case   11:  		/* bc 12, CR6_LT, 28 */
		/* 820D4330h case   11:*/		if ( regs.CR[6].lt ) { return 0x820D434C;  }
		/* 820D4330h case   11:*/		return 0x820D4334;
		  /* 820D4334h */ case   12:  		/* cmplwi CR6, R11, 5 */
		/* 820D4334h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 820D4334h case   12:*/		return 0x820D4338;
		  /* 820D4338h */ case   13:  		/* bc 12, CR6_LT, 292 */
		/* 820D4338h case   13:*/		if ( regs.CR[6].lt ) { return 0x820D445C;  }
		/* 820D4338h case   13:*/		return 0x820D433C;
		  /* 820D433Ch */ case   14:  		/* bc 12, CR6_EQ, 248 */
		/* 820D433Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820D4434;  }
		/* 820D433Ch case   14:*/		return 0x820D4340;
		  /* 820D4340h */ case   15:  		/* cmplwi CR6, R11, 7 */
		/* 820D4340h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 820D4340h case   15:*/		return 0x820D4344;
		  /* 820D4344h */ case   16:  		/* bc 12, CR6_LT, 220 */
		/* 820D4344h case   16:*/		if ( regs.CR[6].lt ) { return 0x820D4420;  }
		/* 820D4344h case   16:*/		return 0x820D4348;
		  /* 820D4348h */ case   17:  		/* bc 4, CR6_EQ, 28 */
		/* 820D4348h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820D4364;  }
		/* 820D4348h case   17:*/		return 0x820D434C;
	}
	return 0x820D434C;
} // Block from 820D4304h-820D434Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820D434Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D434C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D434C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D434C);
		  /* 820D434Ch */ case    0:  		/* slw R11, R25, R10 */
		/* 820D434Ch case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R10);
		/* 820D434Ch case    0:*/		return 0x820D4350;
		  /* 820D4350h */ case    1:  		/* lwz R7, <#[R31]> */
		/* 820D4350h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 820D4350h case    1:*/		return 0x820D4354;
		  /* 820D4354h */ case    2:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 820D4354h case    2:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 820D4354h case    2:*/		return 0x820D4358;
		  /* 820D4358h */ case    3:  		/* or R11, R11, R7 */
		/* 820D4358h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820D4358h case    3:*/		return 0x820D435C;
		  /* 820D435Ch */ case    4:  		/* rlwimi R11, R7, 0, 15, 6 */
		/* 820D435Ch case    4:*/		cpu::op::rlwimi<0,0,15,6>(regs,&regs.R11,regs.R7);
		/* 820D435Ch case    4:*/		return 0x820D4360;
		  /* 820D4360h */ case    5:  		/* stw R11, <#[R31]> */
		/* 820D4360h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D4360h case    5:*/		return 0x820D4364;
	}
	return 0x820D4364;
} // Block from 820D434Ch-820D4364h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D4364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4364);
		  /* 820D4364h */ case    0:  		/* addi R9, R9, 3 */
		/* 820D4364h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x3);
		/* 820D4364h case    0:*/		return 0x820D4368;
		  /* 820D4368h */ case    1:  		/* addi R8, R8, 1 */
		/* 820D4368h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820D4368h case    1:*/		return 0x820D436C;
		  /* 820D436Ch */ case    2:  		/* addi R10, R10, 2 */
		/* 820D436Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820D436Ch case    2:*/		return 0x820D4370;
		  /* 820D4370h */ case    3:  		/* cmplwi CR6, R9, 12 */
		/* 820D4370h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000C);
		/* 820D4370h case    3:*/		return 0x820D4374;
		  /* 820D4374h */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 820D4374h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D4324;  }
		/* 820D4374h case    4:*/		return 0x820D4378;
		  /* 820D4378h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820D4378h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D4378h case    5:*/		return 0x820D437C;
		  /* 820D437Ch */ case    6:  		/* lwz R9, <#[R29]> */
		/* 820D437Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 820D437Ch case    6:*/		return 0x820D4380;
		  /* 820D4380h */ case    7:  		/* lwz R10, <#[R30 + 40]> */
		/* 820D4380h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 820D4380h case    7:*/		return 0x820D4384;
		  /* 820D4384h */ case    8:  		/* rlwimi R11, R9, 28, 15, 15 */
		/* 820D4384h case    8:*/		cpu::op::rlwimi<0,28,15,15>(regs,&regs.R11,regs.R9);
		/* 820D4384h case    8:*/		return 0x820D4388;
		  /* 820D4388h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820D4388h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820D4388h case    9:*/		return 0x820D438C;
		  /* 820D438Ch */ case   10:  		/* stw R11, <#[R31]> */
		/* 820D438Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D438Ch case   10:*/		return 0x820D4390;
		  /* 820D4390h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820D4390h case   11:*/		if ( regs.CR[6].eq ) { return 0x820D43B0;  }
		/* 820D4390h case   11:*/		return 0x820D4394;
		  /* 820D4394h */ case   12:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 820D4394h case   12:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 820D4394h case   12:*/		return 0x820D4398;
		  /* 820D4398h */ case   13:  		/* bc 4, CR0_EQ, 316 */
		/* 820D4398h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820D44D4;  }
		/* 820D4398h case   13:*/		return 0x820D439C;
		  /* 820D439Ch */ case   14:  		/* lwz R10, <#[R10 + 16]> */
		/* 820D439Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820D439Ch case   14:*/		return 0x820D43A0;
		  /* 820D43A0h */ case   15:  		/* cmplwi CR6, R10, 15 */
		/* 820D43A0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000F);
		/* 820D43A0h case   15:*/		return 0x820D43A4;
		  /* 820D43A4h */ case   16:  		/* bc 4, CR6_EQ, 316 */
		/* 820D43A4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820D44E0;  }
		/* 820D43A4h case   16:*/		return 0x820D43A8;
		  /* 820D43A8h */ case   17:  		/* ori R11, R11, 32768 */
		/* 820D43A8h case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 820D43A8h case   17:*/		return 0x820D43AC;
		  /* 820D43ACh */ case   18:  		/* stw R11, <#[R31]> */
		/* 820D43ACh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D43ACh case   18:*/		return 0x820D43B0;
	}
	return 0x820D43B0;
} // Block from 820D4364h-820D43B0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D43B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D43B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D43B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D43B0);
		  /* 820D43B0h */ case    0:  		/* addi R28, R28, 1 */
		/* 820D43B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820D43B0h case    0:*/		return 0x820D43B4;
		  /* 820D43B4h */ case    1:  		/* addi R29, R29, 4 */
		/* 820D43B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820D43B4h case    1:*/		return 0x820D43B8;
		  /* 820D43B8h */ case    2:  		/* addi R31, R31, 4 */
		/* 820D43B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820D43B8h case    2:*/		return 0x820D43BC;
		  /* 820D43BCh */ case    3:  		/* cmplwi CR6, R28, 2 */
		/* 820D43BCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000002);
		/* 820D43BCh case    3:*/		return 0x820D43C0;
		  /* 820D43C0h */ case    4:  		/* bc 12, CR6_LT, -304 */
		/* 820D43C0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820D4290;  }
		/* 820D43C0h case    4:*/		return 0x820D43C4;
		  /* 820D43C4h */ case    5:  		/* li R10, 2 */
		/* 820D43C4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820D43C4h case    5:*/		return 0x820D43C8;
		  /* 820D43C8h */ case    6:  		/* mr R9, R25 */
		/* 820D43C8h case    6:*/		regs.R9 = regs.R25;
		/* 820D43C8h case    6:*/		return 0x820D43CC;
		  /* 820D43CCh */ case    7:  		/* mr R8, R25 */
		/* 820D43CCh case    7:*/		regs.R8 = regs.R25;
		/* 820D43CCh case    7:*/		return 0x820D43D0;
		  /* 820D43D0h */ case    8:  		/* addi R11, R1, 112 */
		/* 820D43D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820D43D0h case    8:*/		return 0x820D43D4;
		  /* 820D43D4h */ case    9:  		/* mtspr CTR, R10 */
		/* 820D43D4h case    9:*/		regs.CTR = regs.R10;
		/* 820D43D4h case    9:*/		return 0x820D43D8;
		  /* 820D43D8h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 820D43D8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820D43D8h case   10:*/		return 0x820D43DC;
		  /* 820D43DCh */ case   11:  		/* rlwinm. R7, R10, 1, 31, 31 */
		/* 820D43DCh case   11:*/		cpu::op::rlwinm<1,1,31,31>(regs,&regs.R7,regs.R10);
		/* 820D43DCh case   11:*/		return 0x820D43E0;
		  /* 820D43E0h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 820D43E0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820D43F0;  }
		/* 820D43E0h case   12:*/		return 0x820D43E4;
		  /* 820D43E4h */ case   13:  		/* rlwinm. R10, R10, 0, 7, 14 */
		/* 820D43E4h case   13:*/		cpu::op::rlwinm<1,0,7,14>(regs,&regs.R10,regs.R10);
		/* 820D43E4h case   13:*/		return 0x820D43E8;
		  /* 820D43E8h */ case   14:  		/* mr R10, R23 */
		/* 820D43E8h case   14:*/		regs.R10 = regs.R23;
		/* 820D43E8h case   14:*/		return 0x820D43EC;
		  /* 820D43ECh */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 820D43ECh case   15:*/		if ( !regs.CR[0].eq ) { return 0x820D43F4;  }
		/* 820D43ECh case   15:*/		return 0x820D43F0;
	}
	return 0x820D43F0;
} // Block from 820D43B0h-820D43F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D43F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D43F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D43F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D43F0);
		  /* 820D43F0h */ case    0:  		/* mr R10, R25 */
		/* 820D43F0h case    0:*/		regs.R10 = regs.R25;
		/* 820D43F0h case    0:*/		return 0x820D43F4;
	}
	return 0x820D43F4;
} // Block from 820D43F0h-820D43F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D43F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D43F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D43F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D43F4);
		  /* 820D43F4h */ case    0:  		/* add R9, R10, R9 */
		/* 820D43F4h case    0:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820D43F4h case    0:*/		return 0x820D43F8;
		  /* 820D43F8h */ case    1:  		/* add R8, R7, R8 */
		/* 820D43F8h case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820D43F8h case    1:*/		return 0x820D43FC;
		  /* 820D43FCh */ case    2:  		/* addi R11, R11, 4 */
		/* 820D43FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820D43FCh case    2:*/		return 0x820D4400;
		  /* 820D4400h */ case    3:  		/* bc 16, CR0_LT, -40 */
		/* 820D4400h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D43D8;  }
		/* 820D4400h case    3:*/		return 0x820D4404;
		  /* 820D4404h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 820D4404h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D4404h case    4:*/		return 0x820D4408;
		  /* 820D4408h */ case    5:  		/* bc 12, CR6_EQ, 228 */
		/* 820D4408h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D44EC;  }
		/* 820D4408h case    5:*/		return 0x820D440C;
		  /* 820D440Ch */ case    6:  		/* cmplwi CR6, R8, 0 */
		/* 820D440Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820D440Ch case    6:*/		return 0x820D4410;
		  /* 820D4410h */ case    7:  		/* bc 12, CR6_EQ, 220 */
		/* 820D4410h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D44EC;  }
		/* 820D4410h case    7:*/		return 0x820D4414;
		  /* 820D4414h */ case    8:  		/* lis R11, -32255 */
		/* 820D4414h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4414h case    8:*/		return 0x820D4418;
		  /* 820D4418h */ case    9:  		/* addi R4, R11, 27560 */
		/* 820D4418h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6BA8);
		/* 820D4418h case    9:*/		return 0x820D441C;
		  /* 820D441Ch */ case   10:  		/* b 92 */
		/* 820D441Ch case   10:*/		return 0x820D4478;
		/* 820D441Ch case   10:*/		return 0x820D4420;
	}
	return 0x820D4420;
} // Block from 820D43F4h-820D4420h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D4420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4420);
		  /* 820D4420h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820D4420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D4420h case    0:*/		return 0x820D4424;
		  /* 820D4424h */ case    1:  		/* rlwinm. R7, R11, 0, 0, 0 */
		/* 820D4424h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R7,regs.R11);
		/* 820D4424h case    1:*/		return 0x820D4428;
		  /* 820D4428h */ case    2:  		/* bc 12, CR0_EQ, 112 */
		/* 820D4428h case    2:*/		if ( regs.CR[0].eq ) { return 0x820D4498;  }
		/* 820D4428h case    2:*/		return 0x820D442C;
		  /* 820D442Ch */ case    3:  		/* li R7, 3 */
		/* 820D442Ch case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 820D442Ch case    3:*/		return 0x820D4430;
		  /* 820D4430h */ case    4:  		/* b 20 */
		/* 820D4430h case    4:*/		return 0x820D4444;
		/* 820D4430h case    4:*/		return 0x820D4434;
	}
	return 0x820D4434;
} // Block from 820D4420h-820D4434h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D4434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4434);
		  /* 820D4434h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820D4434h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820D4434h case    0:*/		return 0x820D4438;
		  /* 820D4438h */ case    1:  		/* rlwinm. R7, R11, 0, 0, 0 */
		/* 820D4438h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R7,regs.R11);
		/* 820D4438h case    1:*/		return 0x820D443C;
		  /* 820D443Ch */ case    2:  		/* bc 12, CR0_EQ, 104 */
		/* 820D443Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820D44A4;  }
		/* 820D443Ch case    2:*/		return 0x820D4440;
		  /* 820D4440h */ case    3:  		/* li R7, 2 */
		/* 820D4440h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 820D4440h case    3:*/		return 0x820D4444;
	}
	return 0x820D4444;
} // Block from 820D4434h-820D4444h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4444);
		  /* 820D4444h */ case    0:  		/* slw R7, R7, R10 */
		/* 820D4444h case    0:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 820D4444h case    0:*/		return 0x820D4448;
		  /* 820D4448h */ case    1:  		/* rlwinm R7, R7, 17, 0, 14 */
		/* 820D4448h case    1:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R7,regs.R7);
		/* 820D4448h case    1:*/		return 0x820D444C;
		  /* 820D444Ch */ case    2:  		/* or R7, R7, R11 */
		/* 820D444Ch case    2:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 820D444Ch case    2:*/		return 0x820D4450;
		  /* 820D4450h */ case    3:  		/* rlwimi R7, R11, 0, 15, 6 */
		/* 820D4450h case    3:*/		cpu::op::rlwimi<0,0,15,6>(regs,&regs.R7,regs.R11);
		/* 820D4450h case    3:*/		return 0x820D4454;
		  /* 820D4454h */ case    4:  		/* stw R7, <#[R31]> */
		/* 820D4454h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 820D4454h case    4:*/		return 0x820D4458;
		  /* 820D4458h */ case    5:  		/* b -244 */
		/* 820D4458h case    5:*/		return 0x820D4364;
		/* 820D4458h case    5:*/		return 0x820D445C;
	}
	return 0x820D445C;
} // Block from 820D4444h-820D445Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D445Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D445C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D445C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D445C);
		  /* 820D445Ch */ case    0:  		/* addi R7, R8, 1 */
		/* 820D445Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R8,0x1);
		/* 820D445Ch case    0:*/		return 0x820D4460;
		  /* 820D4460h */ case    1:  		/* cmplw CR6, R11, R7 */
		/* 820D4460h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820D4460h case    1:*/		return 0x820D4464;
		  /* 820D4464h */ case    2:  		/* bc 4, CR6_EQ, 76 */
		/* 820D4464h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D44B0;  }
		/* 820D4464h case    2:*/		return 0x820D4468;
		  /* 820D4468h */ case    3:  		/* slw R11, R23, R10 */
		/* 820D4468h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R23,regs.R10);
		/* 820D4468h case    3:*/		return 0x820D446C;
		  /* 820D446Ch */ case    4:  		/* b -284 */
		/* 820D446Ch case    4:*/		return 0x820D4350;
		/* 820D446Ch case    4:*/		return 0x820D4470;
	}
	return 0x820D4470;
} // Block from 820D445Ch-820D4470h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D4470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4470);
		  /* 820D4470h */ case    0:  		/* lis R11, -32255 */
		/* 820D4470h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4470h case    0:*/		return 0x820D4474;
		  /* 820D4474h */ case    1:  		/* addi R4, R11, 27528 */
		/* 820D4474h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6B88);
		/* 820D4474h case    1:*/		return 0x820D4478;
	}
	return 0x820D4478;
} // Block from 820D4470h-820D4478h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4478);
		  /* 820D4478h */ case    0:  		/* mr R3, R24 */
		/* 820D4478h case    0:*/		regs.R3 = regs.R24;
		/* 820D4478h case    0:*/		return 0x820D447C;
		  /* 820D447Ch */ case    1:  		/* bl -15252 */
		/* 820D447Ch case    1:*/		regs.LR = 0x820D4480; return 0x820D08E8;
		/* 820D447Ch case    1:*/		return 0x820D4480;
		  /* 820D4480h */ case    2:  		/* b 748 */
		/* 820D4480h case    2:*/		return 0x820D476C;
		/* 820D4480h case    2:*/		return 0x820D4484;
	}
	return 0x820D4484;
} // Block from 820D4478h-820D4484h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4484);
		  /* 820D4484h */ case    0:  		/* lis R11, -32255 */
		/* 820D4484h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4484h case    0:*/		return 0x820D4488;
		  /* 820D4488h */ case    1:  		/* mr R3, R24 */
		/* 820D4488h case    1:*/		regs.R3 = regs.R24;
		/* 820D4488h case    1:*/		return 0x820D448C;
		  /* 820D448Ch */ case    2:  		/* addi R4, R11, 27488 */
		/* 820D448Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6B60);
		/* 820D448Ch case    2:*/		return 0x820D4490;
		  /* 820D4490h */ case    3:  		/* bl -15272 */
		/* 820D4490h case    3:*/		regs.LR = 0x820D4494; return 0x820D08E8;
		/* 820D4490h case    3:*/		return 0x820D4494;
		  /* 820D4494h */ case    4:  		/* b -208 */
		/* 820D4494h case    4:*/		return 0x820D43C4;
		/* 820D4494h case    4:*/		return 0x820D4498;
	}
	return 0x820D4498;
} // Block from 820D4484h-820D4498h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D4498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4498);
		  /* 820D4498h */ case    0:  		/* lis R11, -32255 */
		/* 820D4498h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4498h case    0:*/		return 0x820D449C;
		  /* 820D449Ch */ case    1:  		/* addi R4, R11, 27416 */
		/* 820D449Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6B18);
		/* 820D449Ch case    1:*/		return 0x820D44A0;
		  /* 820D44A0h */ case    2:  		/* b -40 */
		/* 820D44A0h case    2:*/		return 0x820D4478;
		/* 820D44A0h case    2:*/		return 0x820D44A4;
	}
	return 0x820D44A4;
} // Block from 820D4498h-820D44A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D44A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D44A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D44A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D44A4);
		  /* 820D44A4h */ case    0:  		/* lis R11, -32255 */
		/* 820D44A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D44A4h case    0:*/		return 0x820D44A8;
		  /* 820D44A8h */ case    1:  		/* addi R4, R11, 27344 */
		/* 820D44A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6AD0);
		/* 820D44A8h case    1:*/		return 0x820D44AC;
		  /* 820D44ACh */ case    2:  		/* b -52 */
		/* 820D44ACh case    2:*/		return 0x820D4478;
		/* 820D44ACh case    2:*/		return 0x820D44B0;
	}
	return 0x820D44B0;
} // Block from 820D44A4h-820D44B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D44B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D44B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D44B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D44B0);
		  /* 820D44B0h */ case    0:  		/* lis R11, -32255 */
		/* 820D44B0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D44B0h case    0:*/		return 0x820D44B4;
		  /* 820D44B4h */ case    1:  		/* lis R10, -32255 */
		/* 820D44B4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D44B4h case    1:*/		return 0x820D44B8;
		  /* 820D44B8h */ case    2:  		/* addi R11, R11, 12500 */
		/* 820D44B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30D4);
		/* 820D44B8h case    2:*/		return 0x820D44BC;
		  /* 820D44BCh */ case    3:  		/* addi R4, R10, 27312 */
		/* 820D44BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x6AB0);
		/* 820D44BCh case    3:*/		return 0x820D44C0;
		  /* 820D44C0h */ case    4:  		/* lbzx R11, <#[R8 + R11]> */
		/* 820D44C0h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820D44C0h case    4:*/		return 0x820D44C4;
		  /* 820D44C4h */ case    5:  		/* mr R3, R24 */
		/* 820D44C4h case    5:*/		regs.R3 = regs.R24;
		/* 820D44C4h case    5:*/		return 0x820D44C8;
		  /* 820D44C8h */ case    6:  		/* extsb R5, R11 */
		/* 820D44C8h case    6:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 820D44C8h case    6:*/		return 0x820D44CC;
		  /* 820D44CCh */ case    7:  		/* bl -15332 */
		/* 820D44CCh case    7:*/		regs.LR = 0x820D44D0; return 0x820D08E8;
		/* 820D44CCh case    7:*/		return 0x820D44D0;
		  /* 820D44D0h */ case    8:  		/* b 668 */
		/* 820D44D0h case    8:*/		return 0x820D476C;
		/* 820D44D0h case    8:*/		return 0x820D44D4;
	}
	return 0x820D44D4;
} // Block from 820D44B0h-820D44D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D44D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D44D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D44D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D44D4);
		  /* 820D44D4h */ case    0:  		/* lis R11, -32255 */
		/* 820D44D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D44D4h case    0:*/		return 0x820D44D8;
		  /* 820D44D8h */ case    1:  		/* addi R4, R11, 27240 */
		/* 820D44D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6A68);
		/* 820D44D8h case    1:*/		return 0x820D44DC;
		  /* 820D44DCh */ case    2:  		/* b -100 */
		/* 820D44DCh case    2:*/		return 0x820D4478;
		/* 820D44DCh case    2:*/		return 0x820D44E0;
	}
	return 0x820D44E0;
} // Block from 820D44D4h-820D44E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D44E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D44E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D44E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D44E0);
		  /* 820D44E0h */ case    0:  		/* lis R11, -32255 */
		/* 820D44E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D44E0h case    0:*/		return 0x820D44E4;
		  /* 820D44E4h */ case    1:  		/* addi R4, R11, 27160 */
		/* 820D44E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6A18);
		/* 820D44E4h case    1:*/		return 0x820D44E8;
		  /* 820D44E8h */ case    2:  		/* b -112 */
		/* 820D44E8h case    2:*/		return 0x820D4478;
		/* 820D44E8h case    2:*/		return 0x820D44EC;
	}
	return 0x820D44EC;
} // Block from 820D44E0h-820D44ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D44ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D44EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D44EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D44EC);
		  /* 820D44ECh */ case    0:  		/* lwz R28, <#[R1 + 112]> */
		/* 820D44ECh case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000070) );
		/* 820D44ECh case    0:*/		return 0x820D44F0;
		  /* 820D44F0h */ case    1:  		/* lwz R29, <#[R1 + 116]> */
		/* 820D44F0h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000074) );
		/* 820D44F0h case    1:*/		return 0x820D44F4;
		  /* 820D44F4h */ case    2:  		/* rlwinm. R11, R28, 0, 0, 0 */
		/* 820D44F4h case    2:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R28);
		/* 820D44F4h case    2:*/		return 0x820D44F8;
	}
	return 0x820D44F8;
} // Block from 820D44ECh-820D44F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D44F8h
// Function '?HandleAlloc@CUAssembler@D3DXShader@@IAAJAATGPUFLOW_ALLOC@@PAVCNodeUAsmInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D44F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D44F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D44F8);
		  /* 820D44F8h */ case    0:  		/* bc 4, CR0_EQ, 16 */
		/* 820D44F8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x820D4508;  }
		/* 820D44F8h case    0:*/		return 0x820D44FC;
		  /* 820D44FCh */ case    1:  		/* rlwinm. R11, R29, 0, 0, 0 */
		/* 820D44FCh case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R29);
		/* 820D44FCh case    1:*/		return 0x820D4500;
		  /* 820D4500h */ case    2:  		/* mr R11, R25 */
		/* 820D4500h case    2:*/		regs.R11 = regs.R25;
		/* 820D4500h case    2:*/		return 0x820D4504;
		  /* 820D4504h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 820D4504h case    3:*/		if ( regs.CR[0].eq ) { return 0x820D450C;  }
		/* 820D4504h case    3:*/		return 0x820D4508;
	}
	return 0x820D4508;
} // Block from 820D44F8h-820D4508h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4508);
		  /* 820D4508h */ case    0:  		/* mr R11, R23 */
		/* 820D4508h case    0:*/		regs.R11 = regs.R23;
		/* 820D4508h case    0:*/		return 0x820D450C;
	}
	return 0x820D450C;
} // Block from 820D4508h-820D450Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D450Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D450C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D450C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D450C);
		  /* 820D450Ch */ case    0:  		/* lwz R10, <#[R26]> */
		/* 820D450Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820D450Ch case    0:*/		return 0x820D4510;
		  /* 820D4510h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 820D4510h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820D4510h case    1:*/		return 0x820D4514;
		  /* 820D4514h */ case    2:  		/* rlwimi R10, R11, 15, 16, 16 */
		/* 820D4514h case    2:*/		cpu::op::rlwimi<0,15,16,16>(regs,&regs.R10,regs.R11);
		/* 820D4514h case    2:*/		return 0x820D4518;
		  /* 820D4518h */ case    3:  		/* stw R10, <#[R26]> */
		/* 820D4518h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4518h case    3:*/		return 0x820D451C;
		  /* 820D451Ch */ case    4:  		/* bc 12, CR0_EQ, 404 */
		/* 820D451Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820D46B0;  }
		/* 820D451Ch case    4:*/		return 0x820D4520;
		  /* 820D4520h */ case    5:  		/* rlwinm. R31, R28, 15, 24, 31 */
		/* 820D4520h case    5:*/		cpu::op::rlwinm<1,15,24,31>(regs,&regs.R31,regs.R28);
		/* 820D4520h case    5:*/		return 0x820D4524;
		  /* 820D4524h */ case    6:  		/* rlwinm R11, R28, 7, 26, 31 */
		/* 820D4524h case    6:*/		cpu::op::rlwinm<0,7,26,31>(regs,&regs.R11,regs.R28);
		/* 820D4524h case    6:*/		return 0x820D4528;
		  /* 820D4528h */ case    7:  		/* bc 4, CR0_EQ, 8 */
		/* 820D4528h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820D4530;  }
		/* 820D4528h case    7:*/		return 0x820D452C;
		  /* 820D452Ch */ case    8:  		/* rlwinm R11, R29, 7, 26, 31 */
		/* 820D452Ch case    8:*/		cpu::op::rlwinm<0,7,26,31>(regs,&regs.R11,regs.R29);
		/* 820D452Ch case    8:*/		return 0x820D4530;
	}
	return 0x820D4530;
} // Block from 820D450Ch-820D4530h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D4530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4530);
		  /* 820D4530h */ case    0:  		/* rlwinm R10, R29, 7, 26, 31 */
		/* 820D4530h case    0:*/		cpu::op::rlwinm<0,7,26,31>(regs,&regs.R10,regs.R29);
		/* 820D4530h case    0:*/		return 0x820D4534;
		  /* 820D4534h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820D4534h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D4534h case    1:*/		return 0x820D4538;
		  /* 820D4538h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820D4538h case    2:*/		if ( regs.CR[6].eq ) { return 0x820D4550;  }
		/* 820D4538h case    2:*/		return 0x820D453C;
		  /* 820D453Ch */ case    3:  		/* rlwinm. R10, R29, 0, 7, 14 */
		/* 820D453Ch case    3:*/		cpu::op::rlwinm<1,0,7,14>(regs,&regs.R10,regs.R29);
		/* 820D453Ch case    3:*/		return 0x820D4540;
		  /* 820D4540h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820D4540h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D4550;  }
		/* 820D4540h case    4:*/		return 0x820D4544;
		  /* 820D4544h */ case    5:  		/* lis R11, -32255 */
		/* 820D4544h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4544h case    5:*/		return 0x820D4548;
		  /* 820D4548h */ case    6:  		/* addi R4, R11, 27096 */
		/* 820D4548h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x69D8);
		/* 820D4548h case    6:*/		return 0x820D454C;
		  /* 820D454Ch */ case    7:  		/* b -212 */
		/* 820D454Ch case    7:*/		return 0x820D4478;
		/* 820D454Ch case    7:*/		return 0x820D4550;
	}
	return 0x820D4550;
} // Block from 820D4530h-820D4550h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D4550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4550);
		  /* 820D4550h */ case    0:  		/* lwz R10, <#[R26]> */
		/* 820D4550h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4550h case    0:*/		return 0x820D4554;
		  /* 820D4554h */ case    1:  		/* mr R4, R25 */
		/* 820D4554h case    1:*/		regs.R4 = regs.R25;
		/* 820D4554h case    1:*/		return 0x820D4558;
		  /* 820D4558h */ case    2:  		/* mr R30, R25 */
		/* 820D4558h case    2:*/		regs.R30 = regs.R25;
		/* 820D4558h case    2:*/		return 0x820D455C;
		  /* 820D455Ch */ case    3:  		/* rlwimi R10, R11, 0, 26, 31 */
		/* 820D455Ch case    3:*/		cpu::op::rlwimi<0,0,26,31>(regs,&regs.R10,regs.R11);
		/* 820D455Ch case    3:*/		return 0x820D4560;
		  /* 820D4560h */ case    4:  		/* rlwinm R3, R29, 15, 24, 31 */
		/* 820D4560h case    4:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R3,regs.R29);
		/* 820D4560h case    4:*/		return 0x820D4564;
		  /* 820D4564h */ case    5:  		/* stw R10, <#[R26]> */
		/* 820D4564h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4564h case    5:*/		return 0x820D4568;
		  /* 820D4568h */ case    6:  		/* mr R6, R25 */
		/* 820D4568h case    6:*/		regs.R6 = regs.R25;
		/* 820D4568h case    6:*/		return 0x820D456C;
		  /* 820D456Ch */ case    7:  		/* mr R5, R25 */
		/* 820D456Ch case    7:*/		regs.R5 = regs.R25;
		/* 820D456Ch case    7:*/		return 0x820D4570;
		  /* 820D4570h */ case    8:  		/* mr R7, R25 */
		/* 820D4570h case    8:*/		regs.R7 = regs.R25;
		/* 820D4570h case    8:*/		return 0x820D4574;
		  /* 820D4574h */ case    9:  		/* mr R8, R25 */
		/* 820D4574h case    9:*/		regs.R8 = regs.R25;
		/* 820D4574h case    9:*/		return 0x820D4578;
		  /* 820D4578h */ case   10:  		/* srw R11, R31, R8 */
		/* 820D4578h case   10:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R31,regs.R8);
		/* 820D4578h case   10:*/		return 0x820D457C;
		  /* 820D457Ch */ case   11:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 820D457Ch case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 820D457Ch case   11:*/		return 0x820D4580;
		  /* 820D4580h */ case   12:  		/* srw R10, R3, R8 */
		/* 820D4580h case   12:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R3,regs.R8);
		/* 820D4580h case   12:*/		return 0x820D4584;
		  /* 820D4584h */ case   13:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 820D4584h case   13:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 820D4584h case   13:*/		return 0x820D4588;
		  /* 820D4588h */ case   14:  		/* cmplwi CR6, R11, 1 */
		/* 820D4588h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D4588h case   14:*/		return 0x820D458C;
		  /* 820D458Ch */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 820D458Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x820D4598;  }
		/* 820D458Ch case   15:*/		return 0x820D4590;
		  /* 820D4590h */ case   16:  		/* cmplwi CR6, R10, 1 */
		/* 820D4590h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820D4590h case   16:*/		return 0x820D4594;
		  /* 820D4594h */ case   17:  		/* bc 12, CR6_EQ, 248 */
		/* 820D4594h case   17:*/		if ( regs.CR[6].eq ) { return 0x820D468C;  }
		/* 820D4594h case   17:*/		return 0x820D4598;
	}
	return 0x820D4598;
} // Block from 820D4550h-820D4598h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820D4598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4598);
		  /* 820D4598h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820D4598h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D4598h case    0:*/		return 0x820D459C;
		  /* 820D459Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820D459Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820D45B0;  }
		/* 820D459Ch case    1:*/		return 0x820D45A0;
		  /* 820D45A0h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 820D45A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D45A0h case    2:*/		return 0x820D45A4;
		  /* 820D45A4h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 820D45A4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820D45B0;  }
		/* 820D45A4h case    3:*/		return 0x820D45A8;
		  /* 820D45A8h */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820D45A8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820D45A8h case    4:*/		return 0x820D45AC;
		  /* 820D45ACh */ case    5:  		/* bc 4, CR6_LT, 248 */
		/* 820D45ACh case    5:*/		if ( !regs.CR[6].lt ) { return 0x820D46A4;  }
		/* 820D45ACh case    5:*/		return 0x820D45B0;
	}
	return 0x820D45B0;
} // Block from 820D4598h-820D45B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D45B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D45B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D45B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D45B0);
		  /* 820D45B0h */ case    0:  		/* mr R9, R11 */
		/* 820D45B0h case    0:*/		regs.R9 = regs.R11;
		/* 820D45B0h case    0:*/		return 0x820D45B4;
		  /* 820D45B4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D45B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D45B4h case    1:*/		return 0x820D45B8;
		  /* 820D45B8h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 820D45B8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D45CC;  }
		/* 820D45B8h case    2:*/		return 0x820D45BC;
		  /* 820D45BCh */ case    3:  		/* mr R9, R10 */
		/* 820D45BCh case    3:*/		regs.R9 = regs.R10;
		/* 820D45BCh case    3:*/		return 0x820D45C0;
		  /* 820D45C0h */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820D45C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820D45C0h case    4:*/		return 0x820D45C4;
		  /* 820D45C4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820D45C4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D45CC;  }
		/* 820D45C4h case    5:*/		return 0x820D45C8;
		  /* 820D45C8h */ case    6:  		/* li R9, 4 */
		/* 820D45C8h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820D45C8h case    6:*/		return 0x820D45CC;
	}
	return 0x820D45CC;
} // Block from 820D45B0h-820D45CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D45CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D45CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D45CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D45CC);
		  /* 820D45CCh */ case    0:  		/* mr R11, R25 */
		/* 820D45CCh case    0:*/		regs.R11 = regs.R25;
		/* 820D45CCh case    0:*/		return 0x820D45D0;
		  /* 820D45D0h */ case    1:  		/* mr R10, R25 */
		/* 820D45D0h case    1:*/		regs.R10 = regs.R25;
		/* 820D45D0h case    1:*/		return 0x820D45D4;
		  /* 820D45D4h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820D45D4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820D45D4h case    2:*/		return 0x820D45D8;
		  /* 820D45D8h */ case    3:  		/* bc 12, CR6_LT, 64 */
		/* 820D45D8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820D4618;  }
		/* 820D45D8h case    3:*/		return 0x820D45DC;
		  /* 820D45DCh */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 820D45DCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820D460C;  }
		/* 820D45DCh case    4:*/		return 0x820D45E0;
		  /* 820D45E0h */ case    5:  		/* cmplwi CR6, R9, 3 */
		/* 820D45E0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000003);
		/* 820D45E0h case    5:*/		return 0x820D45E4;
		  /* 820D45E4h */ case    6:  		/* bc 12, CR6_LT, 32 */
		/* 820D45E4h case    6:*/		if ( regs.CR[6].lt ) { return 0x820D4604;  }
		/* 820D45E4h case    6:*/		return 0x820D45E8;
		  /* 820D45E8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820D45E8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D45FC;  }
		/* 820D45E8h case    7:*/		return 0x820D45EC;
		  /* 820D45ECh */ case    8:  		/* cmplwi CR6, R9, 5 */
		/* 820D45ECh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000005);
		/* 820D45ECh case    8:*/		return 0x820D45F0;
		  /* 820D45F0h */ case    9:  		/* bc 4, CR6_LT, 52 */
		/* 820D45F0h case    9:*/		if ( !regs.CR[6].lt ) { return 0x820D4624;  }
		/* 820D45F0h case    9:*/		return 0x820D45F4;
		  /* 820D45F4h */ case   10:  		/* mr R11, R23 */
		/* 820D45F4h case   10:*/		regs.R11 = regs.R23;
		/* 820D45F4h case   10:*/		return 0x820D45F8;
		  /* 820D45F8h */ case   11:  		/* b 40 */
		/* 820D45F8h case   11:*/		return 0x820D4620;
		/* 820D45F8h case   11:*/		return 0x820D45FC;
	}
	return 0x820D45FC;
} // Block from 820D45CCh-820D45FCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D45FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D45FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D45FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D45FC);
		  /* 820D45FCh */ case    0:  		/* mr R11, R23 */
		/* 820D45FCh case    0:*/		regs.R11 = regs.R23;
		/* 820D45FCh case    0:*/		return 0x820D4600;
		  /* 820D4600h */ case    1:  		/* b 16 */
		/* 820D4600h case    1:*/		return 0x820D4610;
		/* 820D4600h case    1:*/		return 0x820D4604;
	}
	return 0x820D4604;
} // Block from 820D45FCh-820D4604h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4604);
		  /* 820D4604h */ case    0:  		/* mr R4, R23 */
		/* 820D4604h case    0:*/		regs.R4 = regs.R23;
		/* 820D4604h case    0:*/		return 0x820D4608;
		  /* 820D4608h */ case    1:  		/* b 20 */
		/* 820D4608h case    1:*/		return 0x820D461C;
		/* 820D4608h case    1:*/		return 0x820D460C;
	}
	return 0x820D460C;
} // Block from 820D4604h-820D460Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D460Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D460C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D460C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D460C);
		  /* 820D460Ch */ case    0:  		/* mr R11, R25 */
		/* 820D460Ch case    0:*/		regs.R11 = regs.R25;
		/* 820D460Ch case    0:*/		return 0x820D4610;
	}
	return 0x820D4610;
} // Block from 820D460Ch-820D4610h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4610);
		  /* 820D4610h */ case    0:  		/* mr R10, R23 */
		/* 820D4610h case    0:*/		regs.R10 = regs.R23;
		/* 820D4610h case    0:*/		return 0x820D4614;
		  /* 820D4614h */ case    1:  		/* b 16 */
		/* 820D4614h case    1:*/		return 0x820D4624;
		/* 820D4614h case    1:*/		return 0x820D4618;
	}
	return 0x820D4618;
} // Block from 820D4610h-820D4618h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4618);
		  /* 820D4618h */ case    0:  		/* mr R30, R23 */
		/* 820D4618h case    0:*/		regs.R30 = regs.R23;
		/* 820D4618h case    0:*/		return 0x820D461C;
	}
	return 0x820D461C;
} // Block from 820D4618h-820D461Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D461Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D461C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D461C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D461C);
		  /* 820D461Ch */ case    0:  		/* mr R11, R25 */
		/* 820D461Ch case    0:*/		regs.R11 = regs.R25;
		/* 820D461Ch case    0:*/		return 0x820D4620;
	}
	return 0x820D4620;
} // Block from 820D461Ch-820D4620h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4620);
		  /* 820D4620h */ case    0:  		/* mr R10, R25 */
		/* 820D4620h case    0:*/		regs.R10 = regs.R25;
		/* 820D4620h case    0:*/		return 0x820D4624;
	}
	return 0x820D4624;
} // Block from 820D4620h-820D4624h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4624);
		  /* 820D4624h */ case    0:  		/* slw R10, R10, R7 */
		/* 820D4624h case    0:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820D4624h case    0:*/		return 0x820D4628;
		  /* 820D4628h */ case    1:  		/* slw R11, R11, R7 */
		/* 820D4628h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820D4628h case    1:*/		return 0x820D462C;
		  /* 820D462Ch */ case    2:  		/* addi R8, R8, 2 */
		/* 820D462Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x2);
		/* 820D462Ch case    2:*/		return 0x820D4630;
		  /* 820D4630h */ case    3:  		/* or R6, R10, R6 */
		/* 820D4630h case    3:*/		cpu::op::or<0>(regs,&regs.R6,regs.R10,regs.R6);
		/* 820D4630h case    3:*/		return 0x820D4634;
		  /* 820D4634h */ case    4:  		/* or R5, R11, R5 */
		/* 820D4634h case    4:*/		cpu::op::or<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820D4634h case    4:*/		return 0x820D4638;
		  /* 820D4638h */ case    5:  		/* addi R7, R7, 1 */
		/* 820D4638h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820D4638h case    5:*/		return 0x820D463C;
		  /* 820D463Ch */ case    6:  		/* cmpwi CR6, R8, 8 */
		/* 820D463Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000008);
		/* 820D463Ch case    6:*/		return 0x820D4640;
		  /* 820D4640h */ case    7:  		/* bc 12, CR6_LT, -200 */
		/* 820D4640h case    7:*/		if ( regs.CR[6].lt ) { return 0x820D4578;  }
		/* 820D4640h case    7:*/		return 0x820D4644;
		  /* 820D4644h */ case    8:  		/* lwz R11, <#[R26]> */
		/* 820D4644h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4644h case    8:*/		return 0x820D4648;
		  /* 820D4648h */ case    9:  		/* rlwimi R6, R5, 4, 24, 27 */
		/* 820D4648h case    9:*/		cpu::op::rlwimi<0,4,24,27>(regs,&regs.R6,regs.R5);
		/* 820D4648h case    9:*/		return 0x820D464C;
		  /* 820D464Ch */ case   10:  		/* rlwinm. R31, R4, 0, 24, 31 */
		/* 820D464Ch case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R31,regs.R4);
		/* 820D464Ch case   10:*/		return 0x820D4650;
		  /* 820D4650h */ case   11:  		/* rlwimi R11, R6, 16, 8, 15 */
		/* 820D4650h case   11:*/		cpu::op::rlwimi<0,16,8,15>(regs,&regs.R11,regs.R6);
		/* 820D4650h case   11:*/		return 0x820D4654;
		  /* 820D4654h */ case   12:  		/* stw R11, <#[R26]> */
		/* 820D4654h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4654h case   12:*/		return 0x820D4658;
		  /* 820D4658h */ case   13:  		/* bc 12, CR0_EQ, 28 */
		/* 820D4658h case   13:*/		if ( regs.CR[0].eq ) { return 0x820D4674;  }
		/* 820D4658h case   13:*/		return 0x820D465C;
		  /* 820D465Ch */ case   14:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 820D465Ch case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 820D465Ch case   14:*/		return 0x820D4660;
		  /* 820D4660h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4660h case   15:*/		if ( regs.CR[0].eq ) { return 0x820D4674;  }
		/* 820D4660h case   15:*/		return 0x820D4664;
		  /* 820D4664h */ case   16:  		/* lis R11, -32255 */
		/* 820D4664h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4664h case   16:*/		return 0x820D4668;
		  /* 820D4668h */ case   17:  		/* mr R3, R24 */
		/* 820D4668h case   17:*/		regs.R3 = regs.R24;
		/* 820D4668h case   17:*/		return 0x820D466C;
		  /* 820D466Ch */ case   18:  		/* addi R4, R11, 27048 */
		/* 820D466Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x69A8);
		/* 820D466Ch case   18:*/		return 0x820D4670;
		  /* 820D4670h */ case   19:  		/* bl -15752 */
		/* 820D4670h case   19:*/		regs.LR = 0x820D4674; return 0x820D08E8;
		/* 820D4670h case   19:*/		return 0x820D4674;
	}
	return 0x820D4674;
} // Block from 820D4624h-820D4674h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820D4674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4674);
		  /* 820D4674h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820D4674h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D4674h case    0:*/		return 0x820D4678;
		  /* 820D4678h */ case    1:  		/* bc 12, CR6_EQ, 228 */
		/* 820D4678h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D475C;  }
		/* 820D4678h case    1:*/		return 0x820D467C;
		  /* 820D467Ch */ case    2:  		/* lwz R11, <#[R26]> */
		/* 820D467Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D467Ch case    2:*/		return 0x820D4680;
		  /* 820D4680h */ case    3:  		/* ori R11, R11, 16384 */
		/* 820D4680h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 820D4680h case    3:*/		return 0x820D4684;
		  /* 820D4684h */ case    4:  		/* stw R11, <#[R26]> */
		/* 820D4684h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4684h case    4:*/		return 0x820D4688;
		  /* 820D4688h */ case    5:  		/* b 212 */
		/* 820D4688h case    5:*/		return 0x820D475C;
		/* 820D4688h case    5:*/		return 0x820D468C;
	}
	return 0x820D468C;
} // Block from 820D4674h-820D468Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D468Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D468C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D468C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D468C);
		  /* 820D468Ch */ case    0:  		/* lis R10, -32255 */
		/* 820D468Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D468Ch case    0:*/		return 0x820D4690;
		  /* 820D4690h */ case    1:  		/* addi R4, R10, 26976 */
		/* 820D4690h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x6960);
		/* 820D4690h case    1:*/		return 0x820D4694;
		  /* 820D4694h */ case    2:  		/* lis R11, -32255 */
		/* 820D4694h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4694h case    2:*/		return 0x820D4698;
		  /* 820D4698h */ case    3:  		/* addi R11, R11, 12500 */
		/* 820D4698h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30D4);
		/* 820D4698h case    3:*/		return 0x820D469C;
		  /* 820D469Ch */ case    4:  		/* lbzx R11, <#[R7 + R11]> */
		/* 820D469Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820D469Ch case    4:*/		return 0x820D46A0;
		  /* 820D46A0h */ case    5:  		/* b -476 */
		/* 820D46A0h case    5:*/		return 0x820D44C4;
		/* 820D46A0h case    5:*/		return 0x820D46A4;
	}
	return 0x820D46A4;
} // Block from 820D468Ch-820D46A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D46A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D46A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D46A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D46A4);
		  /* 820D46A4h */ case    0:  		/* lis R10, -32255 */
		/* 820D46A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D46A4h case    0:*/		return 0x820D46A8;
		  /* 820D46A8h */ case    1:  		/* addi R4, R10, 26916 */
		/* 820D46A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x6924);
		/* 820D46A8h case    1:*/		return 0x820D46AC;
		  /* 820D46ACh */ case    2:  		/* b -24 */
		/* 820D46ACh case    2:*/		return 0x820D4694;
		/* 820D46ACh case    2:*/		return 0x820D46B0;
	}
	return 0x820D46B0;
} // Block from 820D46A4h-820D46B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D46B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D46B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D46B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D46B0);
		  /* 820D46B0h */ case    0:  		/* mr R5, R25 */
		/* 820D46B0h case    0:*/		regs.R5 = regs.R25;
		/* 820D46B0h case    0:*/		return 0x820D46B4;
		  /* 820D46B4h */ case    1:  		/* addi R6, R1, 112 */
		/* 820D46B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 820D46B4h case    1:*/		return 0x820D46B8;
		  /* 820D46B8h */ case    2:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 820D46B8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 820D46B8h case    2:*/		return 0x820D46BC;
		  /* 820D46BCh */ case    3:  		/* li R10, 4 */
		/* 820D46BCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820D46BCh case    3:*/		return 0x820D46C0;
		  /* 820D46C0h */ case    4:  		/* mr R9, R25 */
		/* 820D46C0h case    4:*/		regs.R9 = regs.R25;
		/* 820D46C0h case    4:*/		return 0x820D46C4;
		  /* 820D46C4h */ case    5:  		/* mr R8, R25 */
		/* 820D46C4h case    5:*/		regs.R8 = regs.R25;
		/* 820D46C4h case    5:*/		return 0x820D46C8;
		  /* 820D46C8h */ case    6:  		/* mr R7, R25 */
		/* 820D46C8h case    6:*/		regs.R7 = regs.R25;
		/* 820D46C8h case    6:*/		return 0x820D46CC;
		  /* 820D46CCh */ case    7:  		/* lwzx R11, <#[R11 + R6]> */
		/* 820D46CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820D46CCh case    7:*/		return 0x820D46D0;
		  /* 820D46D0h */ case    8:  		/* mtspr CTR, R10 */
		/* 820D46D0h case    8:*/		regs.CTR = regs.R10;
		/* 820D46D0h case    8:*/		return 0x820D46D4;
		  /* 820D46D4h */ case    9:  		/* rlwinm R6, R11, 15, 17, 31 */
		/* 820D46D4h case    9:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R6,regs.R11);
		/* 820D46D4h case    9:*/		return 0x820D46D8;
		  /* 820D46D8h */ case   10:  		/* rlwinm R10, R11, 15, 24, 31 */
		/* 820D46D8h case   10:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R10,regs.R11);
		/* 820D46D8h case   10:*/		return 0x820D46DC;
		  /* 820D46DCh */ case   11:  		/* srw R4, R10, R7 */
		/* 820D46DCh case   11:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R10,regs.R7);
		/* 820D46DCh case   11:*/		return 0x820D46E0;
		  /* 820D46E0h */ case   12:  		/* rlwinm R4, R4, 0, 30, 31 */
		/* 820D46E0h case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R4);
		/* 820D46E0h case   12:*/		return 0x820D46E4;
		  /* 820D46E4h */ case   13:  		/* cmplwi CR6, R4, 1 */
		/* 820D46E4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 820D46E4h case   13:*/		return 0x820D46E8;
		  /* 820D46E8h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 820D46E8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820D46F4;  }
		/* 820D46E8h case   14:*/		return 0x820D46EC;
		  /* 820D46ECh */ case   15:  		/* slw R4, R23, R8 */
		/* 820D46ECh case   15:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R23,regs.R8);
		/* 820D46ECh case   15:*/		return 0x820D46F0;
		  /* 820D46F0h */ case   16:  		/* or R9, R4, R9 */
		/* 820D46F0h case   16:*/		cpu::op::or<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 820D46F0h case   16:*/		return 0x820D46F4;
	}
	return 0x820D46F4;
} // Block from 820D46B0h-820D46F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820D46F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D46F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D46F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D46F4);
		  /* 820D46F4h */ case    0:  		/* addi R8, R8, 1 */
		/* 820D46F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820D46F4h case    0:*/		return 0x820D46F8;
		  /* 820D46F8h */ case    1:  		/* addi R7, R7, 2 */
		/* 820D46F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x2);
		/* 820D46F8h case    1:*/		return 0x820D46FC;
		  /* 820D46FCh */ case    2:  		/* bc 16, CR0_LT, -32 */
		/* 820D46FCh case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D46DC;  }
		/* 820D46FCh case    2:*/		return 0x820D4700;
		  /* 820D4700h */ case    3:  		/* lwz R10, <#[R26]> */
		/* 820D4700h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4700h case    3:*/		return 0x820D4704;
		  /* 820D4704h */ case    4:  		/* cmpwi CR6, R5, 0 */
		/* 820D4704h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820D4704h case    4:*/		return 0x820D4708;
		  /* 820D4708h */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 820D4708h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D4728;  }
		/* 820D4708h case    5:*/		return 0x820D470C;
		  /* 820D470Ch */ case    6:  		/* mr R11, R28 */
		/* 820D470Ch case    6:*/		regs.R11 = regs.R28;
		/* 820D470Ch case    6:*/		return 0x820D4710;
		  /* 820D4710h */ case    7:  		/* rlwinm R10, R10, 0, 0, 24 */
		/* 820D4710h case    7:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R10,regs.R10);
		/* 820D4710h case    7:*/		return 0x820D4714;
		  /* 820D4714h */ case    8:  		/* rlwimi R11, R28, 16, 17, 22 */
		/* 820D4714h case    8:*/		cpu::op::rlwimi<0,16,17,22>(regs,&regs.R11,regs.R28);
		/* 820D4714h case    8:*/		return 0x820D4718;
		  /* 820D4718h */ case    9:  		/* rlwinm R9, R9, 16, 12, 15 */
		/* 820D4718h case    9:*/		cpu::op::rlwinm<0,16,12,15>(regs,&regs.R9,regs.R9);
		/* 820D4718h case    9:*/		return 0x820D471C;
		  /* 820D471Ch */ case   10:  		/* rlwinm R10, R10, 0, 16, 11 */
		/* 820D471Ch case   10:*/		cpu::op::rlwinm<0,0,16,11>(regs,&regs.R10,regs.R10);
		/* 820D471Ch case   10:*/		return 0x820D4720;
		  /* 820D4720h */ case   11:  		/* rlwinm R11, R11, 23, 25, 31 */
		/* 820D4720h case   11:*/		cpu::op::rlwinm<0,23,25,31>(regs,&regs.R11,regs.R11);
		/* 820D4720h case   11:*/		return 0x820D4724;
		  /* 820D4724h */ case   12:  		/* b 32 */
		/* 820D4724h case   12:*/		return 0x820D4744;
		/* 820D4724h case   12:*/		return 0x820D4728;
	}
	return 0x820D4728;
} // Block from 820D46F4h-820D4728h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D4728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4728);
		  /* 820D4728h */ case    0:  		/* rlwimi R10, R6, 0, 18, 23 */
		/* 820D4728h case    0:*/		cpu::op::rlwimi<0,0,18,23>(regs,&regs.R10,regs.R6);
		/* 820D4728h case    0:*/		return 0x820D472C;
		  /* 820D472Ch */ case    1:  		/* rlwinm R11, R11, 31, 17, 17 */
		/* 820D472Ch case    1:*/		cpu::op::rlwinm<0,31,17,17>(regs,&regs.R11,regs.R11);
		/* 820D472Ch case    1:*/		return 0x820D4730;
		  /* 820D4730h */ case    2:  		/* stw R10, <#[R26]> */
		/* 820D4730h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4730h case    2:*/		return 0x820D4734;
		  /* 820D4734h */ case    3:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 820D4734h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 820D4734h case    3:*/		return 0x820D4738;
		  /* 820D4738h */ case    4:  		/* rlwinm R9, R9, 20, 8, 11 */
		/* 820D4738h case    4:*/		cpu::op::rlwinm<0,20,8,11>(regs,&regs.R9,regs.R9);
		/* 820D4738h case    4:*/		return 0x820D473C;
		  /* 820D473Ch */ case    5:  		/* rlwinm R10, R10, 0, 18, 16 */
		/* 820D473Ch case    5:*/		cpu::op::rlwinm<0,0,18,16>(regs,&regs.R10,regs.R10);
		/* 820D473Ch case    5:*/		return 0x820D4740;
		  /* 820D4740h */ case    6:  		/* rlwinm R10, R10, 0, 12, 7 */
		/* 820D4740h case    6:*/		cpu::op::rlwinm<0,0,12,7>(regs,&regs.R10,regs.R10);
		/* 820D4740h case    6:*/		return 0x820D4744;
	}
	return 0x820D4744;
} // Block from 820D4728h-820D4744h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D4744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4744);
		  /* 820D4744h */ case    0:  		/* or R11, R11, R9 */
		/* 820D4744h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820D4744h case    0:*/		return 0x820D4748;
		  /* 820D4748h */ case    1:  		/* addi R5, R5, 1 */
		/* 820D4748h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820D4748h case    1:*/		return 0x820D474C;
		  /* 820D474Ch */ case    2:  		/* or R11, R11, R10 */
		/* 820D474Ch case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820D474Ch case    2:*/		return 0x820D4750;
		  /* 820D4750h */ case    3:  		/* cmpwi CR6, R5, 2 */
		/* 820D4750h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000002);
		/* 820D4750h case    3:*/		return 0x820D4754;
		  /* 820D4754h */ case    4:  		/* stw R11, <#[R26]> */
		/* 820D4754h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4754h case    4:*/		return 0x820D4758;
		  /* 820D4758h */ case    5:  		/* bc 12, CR6_LT, -164 */
		/* 820D4758h case    5:*/		if ( regs.CR[6].lt ) { return 0x820D46B4;  }
		/* 820D4758h case    5:*/		return 0x820D475C;
	}
	return 0x820D475C;
} // Block from 820D4744h-820D475Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D475Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D475C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D475C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D475C);
		  /* 820D475Ch */ case    0:  		/* lwz R11, <#[R26]> */
		/* 820D475Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D475Ch case    0:*/		return 0x820D4760;
		  /* 820D4760h */ case    1:  		/* rlwimi R28, R29, 1, 14, 14 */
		/* 820D4760h case    1:*/		cpu::op::rlwimi<0,1,14,14>(regs,&regs.R28,regs.R29);
		/* 820D4760h case    1:*/		return 0x820D4764;
		  /* 820D4764h */ case    2:  		/* rlwimi R11, R28, 8, 6, 7 */
		/* 820D4764h case    2:*/		cpu::op::rlwimi<0,8,6,7>(regs,&regs.R11,regs.R28);
		/* 820D4764h case    2:*/		return 0x820D4768;
		  /* 820D4768h */ case    3:  		/* stw R11, <#[R26]> */
		/* 820D4768h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4768h case    3:*/		return 0x820D476C;
	}
	return 0x820D476C;
} // Block from 820D475Ch-820D476Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D476Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D476C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D476C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D476C);
		  /* 820D476Ch */ case    0:  		/* addi R1, R1, 208 */
		/* 820D476Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820D476Ch case    0:*/		return 0x820D4770;
		  /* 820D4770h */ case    1:  		/* b -275676 */
		/* 820D4770h case    1:*/		return 0x82091294;
		/* 820D4770h case    1:*/		return 0x820D4774;
		  /* 820D4774h */ case    2:  		/* nop */
		/* 820D4774h case    2:*/		cpu::op::nop();
		/* 820D4774h case    2:*/		return 0x820D4778;
	}
	return 0x820D4778;
} // Block from 820D476Ch-820D4778h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4778);
		  /* 820D4778h */ case    0:  		/* mfspr R12, LR */
		/* 820D4778h case    0:*/		regs.R12 = regs.LR;
		/* 820D4778h case    0:*/		return 0x820D477C;
		  /* 820D477Ch */ case    1:  		/* bl -275748 */
		/* 820D477Ch case    1:*/		regs.LR = 0x820D4780; return 0x82091258;
		/* 820D477Ch case    1:*/		return 0x820D4780;
		  /* 820D4780h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820D4780h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820D4780h case    2:*/		return 0x820D4784;
		  /* 820D4784h */ case    3:  		/* lwz R31, <#[R4 + 20]> */
		/* 820D4784h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000014) );
		/* 820D4784h case    3:*/		return 0x820D4788;
		  /* 820D4788h */ case    4:  		/* lis R11, 256 */
		/* 820D4788h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x100);
		/* 820D4788h case    4:*/		return 0x820D478C;
		  /* 820D478Ch */ case    5:  		/* mr R30, R3 */
		/* 820D478Ch case    5:*/		regs.R30 = regs.R3;
		/* 820D478Ch case    5:*/		return 0x820D4790;
		  /* 820D4790h */ case    6:  		/* mr R29, R5 */
		/* 820D4790h case    6:*/		regs.R29 = regs.R5;
		/* 820D4790h case    6:*/		return 0x820D4794;
		  /* 820D4794h */ case    7:  		/* lis R28, 3072 */
		/* 820D4794h case    7:*/		cpu::op::lis<0>(regs,&regs.R28,0xC00);
		/* 820D4794h case    7:*/		return 0x820D4798;
		  /* 820D4798h */ case    8:  		/* li R3, 0 */
		/* 820D4798h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820D4798h case    8:*/		return 0x820D479C;
		  /* 820D479Ch */ case    9:  		/* cmplw CR6, R31, R11 */
		/* 820D479Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820D479Ch case    9:*/		return 0x820D47A0;
		  /* 820D47A0h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820D47A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D47AC;  }
		/* 820D47A0h case   10:*/		return 0x820D47A4;
		  /* 820D47A4h */ case   11:  		/* cmplw CR6, R31, R28 */
		/* 820D47A4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 820D47A4h case   11:*/		return 0x820D47A8;
		  /* 820D47A8h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 820D47A8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820D47C4;  }
		/* 820D47A8h case   12:*/		return 0x820D47AC;
	}
	return 0x820D47AC;
} // Block from 820D4778h-820D47ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D47ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D47AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D47AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D47AC);
		  /* 820D47ACh */ case    0:  		/* lis R11, -32255 */
		/* 820D47ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D47ACh case    0:*/		return 0x820D47B0;
		  /* 820D47B0h */ case    1:  		/* mr R5, R29 */
		/* 820D47B0h case    1:*/		regs.R5 = regs.R29;
		/* 820D47B0h case    1:*/		return 0x820D47B4;
		  /* 820D47B4h */ case    2:  		/* addi R4, R11, 27728 */
		/* 820D47B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6C50);
		/* 820D47B4h case    2:*/		return 0x820D47B8;
		  /* 820D47B8h */ case    3:  		/* mr R3, R30 */
		/* 820D47B8h case    3:*/		regs.R3 = regs.R30;
		/* 820D47B8h case    3:*/		return 0x820D47BC;
		  /* 820D47BCh */ case    4:  		/* bl -16084 */
		/* 820D47BCh case    4:*/		regs.LR = 0x820D47C0; return 0x820D08E8;
		/* 820D47BCh case    4:*/		return 0x820D47C0;
		  /* 820D47C0h */ case    5:  		/* li R3, 1 */
		/* 820D47C0h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820D47C0h case    5:*/		return 0x820D47C4;
	}
	return 0x820D47C4;
} // Block from 820D47ACh-820D47C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D47C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D47C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D47C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D47C4);
		  /* 820D47C4h */ case    0:  		/* lis R11, 2816 */
		/* 820D47C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xB00);
		/* 820D47C4h case    0:*/		return 0x820D47C8;
		  /* 820D47C8h */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 820D47C8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820D47C8h case    1:*/		return 0x820D47CC;
		  /* 820D47CCh */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820D47CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820D47D8;  }
		/* 820D47CCh case    2:*/		return 0x820D47D0;
		  /* 820D47D0h */ case    3:  		/* cmplw CR6, R31, R28 */
		/* 820D47D0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 820D47D0h case    3:*/		return 0x820D47D4;
		  /* 820D47D4h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 820D47D4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D47F0;  }
		/* 820D47D4h case    4:*/		return 0x820D47D8;
	}
	return 0x820D47D8;
} // Block from 820D47C4h-820D47D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D47D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D47D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D47D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D47D8);
		  /* 820D47D8h */ case    0:  		/* lis R11, -32255 */
		/* 820D47D8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D47D8h case    0:*/		return 0x820D47DC;
		  /* 820D47DCh */ case    1:  		/* mr R5, R29 */
		/* 820D47DCh case    1:*/		regs.R5 = regs.R29;
		/* 820D47DCh case    1:*/		return 0x820D47E0;
		  /* 820D47E0h */ case    2:  		/* addi R4, R11, 27656 */
		/* 820D47E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6C08);
		/* 820D47E0h case    2:*/		return 0x820D47E4;
		  /* 820D47E4h */ case    3:  		/* mr R3, R30 */
		/* 820D47E4h case    3:*/		regs.R3 = regs.R30;
		/* 820D47E4h case    3:*/		return 0x820D47E8;
		  /* 820D47E8h */ case    4:  		/* bl -16128 */
		/* 820D47E8h case    4:*/		regs.LR = 0x820D47EC; return 0x820D08E8;
		/* 820D47E8h case    4:*/		return 0x820D47EC;
		  /* 820D47ECh */ case    5:  		/* li R3, 1 */
		/* 820D47ECh case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820D47ECh case    5:*/		return 0x820D47F0;
	}
	return 0x820D47F0;
} // Block from 820D47D8h-820D47F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D47F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D47F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D47F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D47F0);
		  /* 820D47F0h */ case    0:  		/* addi R1, R1, 144 */
		/* 820D47F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820D47F0h case    0:*/		return 0x820D47F4;
		  /* 820D47F4h */ case    1:  		/* b -275788 */
		/* 820D47F4h case    1:*/		return 0x820912A8;
		/* 820D47F4h case    1:*/		return 0x820D47F8;
	}
	return 0x820D47F8;
} // Block from 820D47F0h-820D47F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D47F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D47F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D47F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D47F8);
		  /* 820D47F8h */ case    0:  		/* mfspr R12, LR */
		/* 820D47F8h case    0:*/		regs.R12 = regs.LR;
		/* 820D47F8h case    0:*/		return 0x820D47FC;
		  /* 820D47FCh */ case    1:  		/* bl -275892 */
		/* 820D47FCh case    1:*/		regs.LR = 0x820D4800; return 0x82091248;
		/* 820D47FCh case    1:*/		return 0x820D4800;
		  /* 820D4800h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820D4800h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820D4800h case    2:*/		return 0x820D4804;
		  /* 820D4804h */ case    3:  		/* lwz R11, <#[R5 + 100]> */
		/* 820D4804h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000064) );
		/* 820D4804h case    3:*/		return 0x820D4808;
		  /* 820D4808h */ case    4:  		/* mr R25, R3 */
		/* 820D4808h case    4:*/		regs.R25 = regs.R3;
		/* 820D4808h case    4:*/		return 0x820D480C;
		  /* 820D480Ch */ case    5:  		/* lwz R31, <#[R4]> */
		/* 820D480Ch case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000000) );
		/* 820D480Ch case    5:*/		return 0x820D4810;
		  /* 820D4810h */ case    6:  		/* mr R26, R4 */
		/* 820D4810h case    6:*/		regs.R26 = regs.R4;
		/* 820D4810h case    6:*/		return 0x820D4814;
		  /* 820D4814h */ case    7:  		/* lwz R29, <#[R4 + 4]> */
		/* 820D4814h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x00000004) );
		/* 820D4814h case    7:*/		return 0x820D4818;
		  /* 820D4818h */ case    8:  		/* mr R28, R5 */
		/* 820D4818h case    8:*/		regs.R28 = regs.R5;
		/* 820D4818h case    8:*/		return 0x820D481C;
		  /* 820D481Ch */ case    9:  		/* lwz R24, <#[R4 + 8]> */
		/* 820D481Ch case    9:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R4 + 0x00000008) );
		/* 820D481Ch case    9:*/		return 0x820D4820;
		  /* 820D4820h */ case   10:  		/* mr R27, R6 */
		/* 820D4820h case   10:*/		regs.R27 = regs.R6;
		/* 820D4820h case   10:*/		return 0x820D4824;
		  /* 820D4824h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820D4824h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D4824h case   11:*/		return 0x820D4828;
		  /* 820D4828h */ case   12:  		/* bc 12, CR6_EQ, 48 */
		/* 820D4828h case   12:*/		if ( regs.CR[6].eq ) { return 0x820D4858;  }
		/* 820D4828h case   12:*/		return 0x820D482C;
		  /* 820D482Ch */ case   13:  		/* lwz R11, <#[R11 + 20]> */
		/* 820D482Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820D482Ch case   13:*/		return 0x820D4830;
		  /* 820D4830h */ case   14:  		/* lis R10, 3328 */
		/* 820D4830h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xD00);
		/* 820D4830h case   14:*/		return 0x820D4834;
		  /* 820D4834h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820D4834h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D4834h case   15:*/		return 0x820D4838;
		  /* 820D4838h */ case   16:  		/* li R11, -1 */
		/* 820D4838h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820D4838h case   16:*/		return 0x820D483C;
		  /* 820D483Ch */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 820D483Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820D4844;  }
		/* 820D483Ch case   17:*/		return 0x820D4840;
		  /* 820D4840h */ case   18:  		/* li R11, 1 */
		/* 820D4840h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820D4840h case   18:*/		return 0x820D4844;
	}
	return 0x820D4844;
} // Block from 820D47F8h-820D4844h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D4844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4844);
		  /* 820D4844h */ case    0:  		/* neg R10, R11 */
		/* 820D4844h case    0:*/		cpu::op::neg<0>(regs,&regs.R10,regs.R11);
		/* 820D4844h case    0:*/		return 0x820D4848;
		  /* 820D4848h */ case    1:  		/* oris R29, R29, 32768 */
		/* 820D4848h case    1:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R29,0x8000);
		/* 820D4848h case    1:*/		return 0x820D484C;
		  /* 820D484Ch */ case    2:  		/* andc R11, R10, R11 */
		/* 820D484Ch case    2:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820D484Ch case    2:*/		return 0x820D4850;
		  /* 820D4850h */ case    3:  		/* rlwinm R11, R11, 1, 31, 31 */
		/* 820D4850h case    3:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R11);
		/* 820D4850h case    3:*/		return 0x820D4854;
		  /* 820D4854h */ case    4:  		/* rlwimi R24, R11, 31, 0, 0 */
		/* 820D4854h case    4:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R24,regs.R11);
		/* 820D4854h case    4:*/		return 0x820D4858;
	}
	return 0x820D4858;
} // Block from 820D4844h-820D4858h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D4858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4858);
		  /* 820D4858h */ case    0:  		/* rlwinm R11, R31, 0, 27, 31 */
		/* 820D4858h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R31);
		/* 820D4858h case    0:*/		return 0x820D485C;
		  /* 820D485Ch */ case    1:  		/* cmplwi CR6, R11, 19 */
		/* 820D485Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000013);
		/* 820D485Ch case    1:*/		return 0x820D4860;
		  /* 820D4860h */ case    2:  		/* bc 12, CR6_GT, 188 */
		/* 820D4860h case    2:*/		if ( regs.CR[6].gt ) { return 0x820D491C;  }
		/* 820D4860h case    2:*/		return 0x820D4864;
		  /* 820D4864h */ case    3:  		/* lwz R30, <#[R28 + 92]> */
		/* 820D4864h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x0000005C) );
		/* 820D4864h case    3:*/		return 0x820D4868;
		  /* 820D4868h */ case    4:  		/* lis R11, -32255 */
		/* 820D4868h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4868h case    4:*/		return 0x820D486C;
		  /* 820D486Ch */ case    5:  		/* mr R3, R25 */
		/* 820D486Ch case    5:*/		regs.R3 = regs.R25;
		/* 820D486Ch case    5:*/		return 0x820D4870;
		  /* 820D4870h */ case    6:  		/* addi R5, R11, 28352 */
		/* 820D4870h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6EC0);
		/* 820D4870h case    6:*/		return 0x820D4874;
		  /* 820D4874h */ case    7:  		/* mr R4, R30 */
		/* 820D4874h case    7:*/		regs.R4 = regs.R30;
		/* 820D4874h case    7:*/		return 0x820D4878;
		  /* 820D4878h */ case    8:  		/* bl -256 */
		/* 820D4878h case    8:*/		regs.LR = 0x820D487C; return 0x820D4778;
		/* 820D4878h case    8:*/		return 0x820D487C;
		  /* 820D487Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820D487Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D487Ch case    9:*/		return 0x820D4880;
		  /* 820D4880h */ case   10:  		/* bc 4, CR0_EQ, 460 */
		/* 820D4880h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820D4A4C;  }
		/* 820D4880h case   10:*/		return 0x820D4884;
		  /* 820D4884h */ case   11:  		/* lwz R11, <#[R30 + 16]> */
		/* 820D4884h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820D4884h case   11:*/		return 0x820D4888;
		  /* 820D4888h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 820D4888h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D4888h case   12:*/		return 0x820D488C;
		  /* 820D488Ch */ case   13:  		/* bc 12, CR6_EQ, 24 */
		/* 820D488Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820D48A4;  }
		/* 820D488Ch case   13:*/		return 0x820D4890;
		  /* 820D4890h */ case   14:  		/* lis R11, -32255 */
		/* 820D4890h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4890h case   14:*/		return 0x820D4894;
		  /* 820D4894h */ case   15:  		/* addi R4, R11, 28292 */
		/* 820D4894h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6E84);
		/* 820D4894h case   15:*/		return 0x820D4898;
		  /* 820D4898h */ case   16:  		/* mr R3, R25 */
		/* 820D4898h case   16:*/		regs.R3 = regs.R25;
		/* 820D4898h case   16:*/		return 0x820D489C;
		  /* 820D489Ch */ case   17:  		/* bl -16308 */
		/* 820D489Ch case   17:*/		regs.LR = 0x820D48A0; return 0x820D08E8;
		/* 820D489Ch case   17:*/		return 0x820D48A0;
		  /* 820D48A0h */ case   18:  		/* b 428 */
		/* 820D48A0h case   18:*/		return 0x820D4A4C;
		/* 820D48A0h case   18:*/		return 0x820D48A4;
	}
	return 0x820D48A4;
} // Block from 820D4858h-820D48A4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820D48A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D48A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D48A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D48A4);
		  /* 820D48A4h */ case    0:  		/* lwz R10, <#[R30 + 24]> */
		/* 820D48A4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 820D48A4h case    0:*/		return 0x820D48A8;
		  /* 820D48A8h */ case    1:  		/* lwz R11, <#[R30 + 40]> */
		/* 820D48A8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820D48A8h case    1:*/		return 0x820D48AC;
		  /* 820D48ACh */ case    2:  		/* rlwimi R31, R10, 12, 14, 19 */
		/* 820D48ACh case    2:*/		cpu::op::rlwimi<0,12,14,19>(regs,&regs.R31,regs.R10);
		/* 820D48ACh case    2:*/		return 0x820D48B0;
		  /* 820D48B0h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820D48B0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D48B0h case    3:*/		return 0x820D48B4;
		  /* 820D48B4h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 820D48B4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D48D4;  }
		/* 820D48B4h case    4:*/		return 0x820D48B8;
		  /* 820D48B8h */ case    5:  		/* lwz R11, <#[R11 + 16]> */
		/* 820D48B8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820D48B8h case    5:*/		return 0x820D48BC;
		  /* 820D48BCh */ case    6:  		/* cmplwi CR6, R11, 15 */
		/* 820D48BCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 820D48BCh case    6:*/		return 0x820D48C0;
		  /* 820D48C0h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 820D48C0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D48D0;  }
		/* 820D48C0h case    7:*/		return 0x820D48C4;
		  /* 820D48C4h */ case    8:  		/* lis R11, -32255 */
		/* 820D48C4h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D48C4h case    8:*/		return 0x820D48C8;
		  /* 820D48C8h */ case    9:  		/* addi R4, R11, 28200 */
		/* 820D48C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6E28);
		/* 820D48C8h case    9:*/		return 0x820D48CC;
		  /* 820D48CCh */ case   10:  		/* b -52 */
		/* 820D48CCh case   10:*/		return 0x820D4898;
		/* 820D48CCh case   10:*/		return 0x820D48D0;
	}
	return 0x820D48D0;
} // Block from 820D48A4h-820D48D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D48D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D48D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D48D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D48D0);
		  /* 820D48D0h */ case    0:  		/* oris R31, R31, 4 */
		/* 820D48D0h case    0:*/		cpu::op::oris<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820D48D0h case    0:*/		return 0x820D48D4;
	}
	return 0x820D48D4;
} // Block from 820D48D0h-820D48D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D48D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D48D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D48D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D48D4);
		  /* 820D48D4h */ case    0:  		/* lwz R11, <#[R30 + 32]> */
		/* 820D48D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820D48D4h case    0:*/		return 0x820D48D8;
		  /* 820D48D8h */ case    1:  		/* lis R10, -32255 */
		/* 820D48D8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D48D8h case    1:*/		return 0x820D48DC;
		  /* 820D48DCh */ case    2:  		/* rlwinm R9, R29, 0, 0, 19 */
		/* 820D48DCh case    2:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R9,regs.R29);
		/* 820D48DCh case    2:*/		return 0x820D48E0;
		  /* 820D48E0h */ case    3:  		/* addi R10, R10, 28164 */
		/* 820D48E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6E04);
		/* 820D48E0h case    3:*/		return 0x820D48E4;
		  /* 820D48E4h */ case    4:  		/* rlwinm R8, R11, 25, 27, 29 */
		/* 820D48E4h case    4:*/		cpu::op::rlwinm<0,25,27,29>(regs,&regs.R8,regs.R11);
		/* 820D48E4h case    4:*/		return 0x820D48E8;
		  /* 820D48E8h */ case    5:  		/* rlwinm R7, R11, 28, 27, 29 */
		/* 820D48E8h case    5:*/		cpu::op::rlwinm<0,28,27,29>(regs,&regs.R7,regs.R11);
		/* 820D48E8h case    5:*/		return 0x820D48EC;
		  /* 820D48ECh */ case    6:  		/* rlwinm R6, R11, 31, 27, 29 */
		/* 820D48ECh case    6:*/		cpu::op::rlwinm<0,31,27,29>(regs,&regs.R6,regs.R11);
		/* 820D48ECh case    6:*/		return 0x820D48F0;
		  /* 820D48F0h */ case    7:  		/* rlwinm R11, R11, 2, 27, 29 */
		/* 820D48F0h case    7:*/		cpu::op::rlwinm<0,2,27,29>(regs,&regs.R11,regs.R11);
		/* 820D48F0h case    7:*/		return 0x820D48F4;
		  /* 820D48F4h */ case    8:  		/* lwzx R8, <#[R8 + R10]> */
		/* 820D48F4h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820D48F4h case    8:*/		return 0x820D48F8;
		  /* 820D48F8h */ case    9:  		/* lwzx R7, <#[R7 + R10]> */
		/* 820D48F8h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820D48F8h case    9:*/		return 0x820D48FC;
		  /* 820D48FCh */ case   10:  		/* lwzx R6, <#[R6 + R10]> */
		/* 820D48FCh case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 820D48FCh case   10:*/		return 0x820D4900;
		  /* 820D4900h */ case   11:  		/* rlwimi R7, R8, 3, 26, 28 */
		/* 820D4900h case   11:*/		cpu::op::rlwimi<0,3,26,28>(regs,&regs.R7,regs.R8);
		/* 820D4900h case   11:*/		return 0x820D4904;
		  /* 820D4904h */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820D4904h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820D4904h case   12:*/		return 0x820D4908;
		  /* 820D4908h */ case   13:  		/* rlwinm R10, R7, 0, 26, 31 */
		/* 820D4908h case   13:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R7);
		/* 820D4908h case   13:*/		return 0x820D490C;
		  /* 820D490Ch */ case   14:  		/* rlwimi R6, R10, 3, 0, 28 */
		/* 820D490Ch case   14:*/		cpu::op::rlwimi<0,3,0,28>(regs,&regs.R6,regs.R10);
		/* 820D490Ch case   14:*/		return 0x820D4910;
		  /* 820D4910h */ case   15:  		/* rlwimi R11, R6, 3, 0, 28 */
		/* 820D4910h case   15:*/		cpu::op::rlwimi<0,3,0,28>(regs,&regs.R11,regs.R6);
		/* 820D4910h case   15:*/		return 0x820D4914;
		  /* 820D4914h */ case   16:  		/* or R29, R11, R9 */
		/* 820D4914h case   16:*/		cpu::op::or<0>(regs,&regs.R29,regs.R11,regs.R9);
		/* 820D4914h case   16:*/		return 0x820D4918;
		  /* 820D4918h */ case   17:  		/* b 8 */
		/* 820D4918h case   17:*/		return 0x820D4920;
		/* 820D4918h case   17:*/		return 0x820D491C;
	}
	return 0x820D491C;
} // Block from 820D48D4h-820D491Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820D491Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D491C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D491C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D491C);
		  /* 820D491Ch */ case    0:  		/* ori R29, R29, 4095 */
		/* 820D491Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0xFFF);
		/* 820D491Ch case    0:*/		return 0x820D4920;
	}
	return 0x820D4920;
} // Block from 820D491Ch-820D4920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4920);
		  /* 820D4920h */ case    0:  		/* cmplwi CR6, R27, 1 */
		/* 820D4920h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 820D4920h case    0:*/		return 0x820D4924;
		  /* 820D4924h */ case    1:  		/* bc 12, CR6_EQ, 284 */
		/* 820D4924h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D4A40;  }
		/* 820D4924h case    1:*/		return 0x820D4928;
		  /* 820D4928h */ case    2:  		/* lwz R30, <#[R28 + 104]> */
		/* 820D4928h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000068) );
		/* 820D4928h case    2:*/		return 0x820D492C;
		  /* 820D492Ch */ case    3:  		/* lwz R11, <#[R30 + 16]> */
		/* 820D492Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820D492Ch case    3:*/		return 0x820D4930;
		  /* 820D4930h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820D4930h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D4930h case    4:*/		return 0x820D4934;
		  /* 820D4934h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820D4934h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D4944;  }
		/* 820D4934h case    5:*/		return 0x820D4938;
		  /* 820D4938h */ case    6:  		/* lis R11, -32255 */
		/* 820D4938h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4938h case    6:*/		return 0x820D493C;
		  /* 820D493Ch */ case    7:  		/* addi R4, R11, 28096 */
		/* 820D493Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6DC0);
		/* 820D493Ch case    7:*/		return 0x820D4940;
		  /* 820D4940h */ case    8:  		/* b -168 */
		/* 820D4940h case    8:*/		return 0x820D4898;
		/* 820D4940h case    8:*/		return 0x820D4944;
	}
	return 0x820D4944;
} // Block from 820D4920h-820D4944h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D4944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4944);
		  /* 820D4944h */ case    0:  		/* lwz R11, <#[R30 + 40]> */
		/* 820D4944h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820D4944h case    0:*/		return 0x820D4948;
		  /* 820D4948h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D4948h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D4948h case    1:*/		return 0x820D494C;
		  /* 820D494Ch */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820D494Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820D496C;  }
		/* 820D494Ch case    2:*/		return 0x820D4950;
		  /* 820D4950h */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 820D4950h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820D4950h case    3:*/		return 0x820D4954;
		  /* 820D4954h */ case    4:  		/* cmplwi CR6, R11, 15 */
		/* 820D4954h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 820D4954h case    4:*/		return 0x820D4958;
		  /* 820D4958h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820D4958h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D4968;  }
		/* 820D4958h case    5:*/		return 0x820D495C;
		  /* 820D495Ch */ case    6:  		/* lis R11, -32255 */
		/* 820D495Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D495Ch case    6:*/		return 0x820D4960;
		  /* 820D4960h */ case    7:  		/* addi R4, R11, 28008 */
		/* 820D4960h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6D68);
		/* 820D4960h case    7:*/		return 0x820D4964;
		  /* 820D4964h */ case    8:  		/* b -204 */
		/* 820D4964h case    8:*/		return 0x820D4898;
		/* 820D4964h case    8:*/		return 0x820D4968;
	}
	return 0x820D4968;
} // Block from 820D4944h-820D4968h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D4968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4968);
		  /* 820D4968h */ case    0:  		/* ori R31, R31, 2048 */
		/* 820D4968h case    0:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x800);
		/* 820D4968h case    0:*/		return 0x820D496C;
	}
	return 0x820D496C;
} // Block from 820D4968h-820D496Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D496Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D496C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D496C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D496C);
		  /* 820D496Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D496Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D496Ch case    0:*/		return 0x820D4970;
	}
	return 0x820D4970;
} // Block from 820D496Ch-820D4970h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4970h
// Function '?GetOptionValue@CUAssembler@D3DXShader@@IAAPAUD3DXTOKEN@2@PAVCNodeUAsmInstruction@2@PBDH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4970);
		  /* 820D4970h */ case    0:  		/* mr R4, R30 */
		/* 820D4970h case    0:*/		regs.R4 = regs.R30;
		/* 820D4970h case    0:*/		return 0x820D4974;
		  /* 820D4974h */ case    1:  		/* addi R5, R11, 27996 */
		/* 820D4974h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6D5C);
		/* 820D4974h case    1:*/		return 0x820D4978;
		  /* 820D4978h */ case    2:  		/* mr R3, R25 */
		/* 820D4978h case    2:*/		regs.R3 = regs.R25;
		/* 820D4978h case    2:*/		return 0x820D497C;
		  /* 820D497Ch */ case    3:  		/* bl -516 */
		/* 820D497Ch case    3:*/		regs.LR = 0x820D4980; return 0x820D4778;
		/* 820D497Ch case    3:*/		return 0x820D4980;
		  /* 820D4980h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820D4980h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D4980h case    4:*/		return 0x820D4984;
		  /* 820D4984h */ case    5:  		/* bc 4, CR0_EQ, 200 */
		/* 820D4984h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820D4A4C;  }
		/* 820D4984h case    5:*/		return 0x820D4988;
		  /* 820D4988h */ case    6:  		/* lwz R11, <#[R30 + 24]> */
		/* 820D4988h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820D4988h case    6:*/		return 0x820D498C;
		  /* 820D498Ch */ case    7:  		/* lwz R10, <#[R30 + 36]> */
		/* 820D498Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000024) );
		/* 820D498Ch case    7:*/		return 0x820D4990;
		  /* 820D4990h */ case    8:  		/* rlwimi R31, R11, 5, 21, 26 */
		/* 820D4990h case    8:*/		cpu::op::rlwimi<0,5,21,26>(regs,&regs.R31,regs.R11);
		/* 820D4990h case    8:*/		return 0x820D4994;
		  /* 820D4994h */ case    9:  		/* mr R11, R31 */
		/* 820D4994h case    9:*/		regs.R11 = regs.R31;
		/* 820D4994h case    9:*/		return 0x820D4998;
		  /* 820D4998h */ case   10:  		/* rlwinm. R9, R31, 0, 27, 31 */
		/* 820D4998h case   10:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R31);
		/* 820D4998h case   10:*/		return 0x820D499C;
		  /* 820D499Ch */ case   11:  		/* bc 12, CR0_EQ, 156 */
		/* 820D499Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x820D4A38;  }
		/* 820D499Ch case   11:*/		return 0x820D49A0;
		  /* 820D49A0h */ case   12:  		/* rlwimi R11, R10, 26, 0, 5 */
		/* 820D49A0h case   12:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R11,regs.R10);
		/* 820D49A0h case   12:*/		return 0x820D49A4;
		  /* 820D49A4h */ case   13:  		/* cmplwi CR6, R9, 18 */
		/* 820D49A4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000012);
		/* 820D49A4h case   13:*/		return 0x820D49A8;
		  /* 820D49A8h */ case   14:  		/* mr R31, R11 */
		/* 820D49A8h case   14:*/		regs.R31 = regs.R11;
		/* 820D49A8h case   14:*/		return 0x820D49AC;
		  /* 820D49ACh */ case   15:  		/* bc 12, CR6_EQ, 100 */
		/* 820D49ACh case   15:*/		if ( regs.CR[6].eq ) { return 0x820D4A10;  }
		/* 820D49ACh case   15:*/		return 0x820D49B0;
		  /* 820D49B0h */ case   16:  		/* cmplwi CR6, R9, 24 */
		/* 820D49B0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000018);
		/* 820D49B0h case   16:*/		return 0x820D49B4;
		  /* 820D49B4h */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 820D49B4h case   17:*/		if ( regs.CR[6].eq ) { return 0x820D49D4;  }
		/* 820D49B4h case   17:*/		return 0x820D49B8;
		  /* 820D49B8h */ case   18:  		/* rlwinm R11, R11, 8, 24, 31 */
		/* 820D49B8h case   18:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R11);
		/* 820D49B8h case   18:*/		return 0x820D49BC;
		  /* 820D49BCh */ case   19:  		/* xor R11, R11, R10 */
		/* 820D49BCh case   19:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820D49BCh case   19:*/		return 0x820D49C0;
		  /* 820D49C0h */ case   20:  		/* rlwinm. R11, R11, 0, 24, 25 */
		/* 820D49C0h case   20:*/		cpu::op::rlwinm<1,0,24,25>(regs,&regs.R11,regs.R11);
		/* 820D49C0h case   20:*/		return 0x820D49C4;
		  /* 820D49C4h */ case   21:  		/* bc 12, CR0_EQ, 124 */
		/* 820D49C4h case   21:*/		if ( regs.CR[0].eq ) { return 0x820D4A40;  }
		/* 820D49C4h case   21:*/		return 0x820D49C8;
		  /* 820D49C8h */ case   22:  		/* lis R11, -32255 */
		/* 820D49C8h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D49C8h case   22:*/		return 0x820D49CC;
		  /* 820D49CCh */ case   23:  		/* addi R4, R11, 27928 */
		/* 820D49CCh case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6D18);
		/* 820D49CCh case   23:*/		return 0x820D49D0;
		  /* 820D49D0h */ case   24:  		/* b 52 */
		/* 820D49D0h case   24:*/		return 0x820D4A04;
		/* 820D49D0h case   24:*/		return 0x820D49D4;
	}
	return 0x820D49D4;
} // Block from 820D4970h-820D49D4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820D49D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D49D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D49D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D49D4);
		  /* 820D49D4h */ case    0:  		/* rlwinm R11, R31, 6, 30, 31 */
		/* 820D49D4h case    0:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R11,regs.R31);
		/* 820D49D4h case    0:*/		return 0x820D49D8;
		  /* 820D49D8h */ case    1:  		/* rlwinm R9, R31, 4, 30, 31 */
		/* 820D49D8h case    1:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R9,regs.R31);
		/* 820D49D8h case    1:*/		return 0x820D49DC;
		  /* 820D49DCh */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 820D49DCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D49DCh case    2:*/		return 0x820D49E0;
		  /* 820D49E0h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 820D49E0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D49FC;  }
		/* 820D49E0h case    3:*/		return 0x820D49E4;
		  /* 820D49E4h */ case    4:  		/* rlwinm R9, R31, 2, 30, 31 */
		/* 820D49E4h case    4:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R9,regs.R31);
		/* 820D49E4h case    4:*/		return 0x820D49E8;
		  /* 820D49E8h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 820D49E8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D49E8h case    5:*/		return 0x820D49EC;
		  /* 820D49ECh */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820D49ECh case    6:*/		if ( !regs.CR[6].eq ) { return 0x820D49FC;  }
		/* 820D49ECh case    6:*/		return 0x820D49F0;
		  /* 820D49F0h */ case    7:  		/* rlwinm R10, R10, 26, 30, 31 */
		/* 820D49F0h case    7:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R10,regs.R10);
		/* 820D49F0h case    7:*/		return 0x820D49F4;
		  /* 820D49F4h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820D49F4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D49F4h case    8:*/		return 0x820D49F8;
		  /* 820D49F8h */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 820D49F8h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D4A40;  }
		/* 820D49F8h case    9:*/		return 0x820D49FC;
	}
	return 0x820D49FC;
} // Block from 820D49D4h-820D49FCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D49FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D49FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D49FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D49FC);
		  /* 820D49FCh */ case    0:  		/* lis R11, -32255 */
		/* 820D49FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D49FCh case    0:*/		return 0x820D4A00;
		  /* 820D4A00h */ case    1:  		/* addi R4, R11, 27864 */
		/* 820D4A00h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6CD8);
		/* 820D4A00h case    1:*/		return 0x820D4A04;
	}
	return 0x820D4A04;
} // Block from 820D49FCh-820D4A04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A04);
		  /* 820D4A04h */ case    0:  		/* mr R3, R25 */
		/* 820D4A04h case    0:*/		regs.R3 = regs.R25;
		/* 820D4A04h case    0:*/		return 0x820D4A08;
		  /* 820D4A08h */ case    1:  		/* bl -16672 */
		/* 820D4A08h case    1:*/		regs.LR = 0x820D4A0C; return 0x820D08E8;
		/* 820D4A08h case    1:*/		return 0x820D4A0C;
		  /* 820D4A0Ch */ case    2:  		/* b 52 */
		/* 820D4A0Ch case    2:*/		return 0x820D4A40;
		/* 820D4A0Ch case    2:*/		return 0x820D4A10;
	}
	return 0x820D4A10;
} // Block from 820D4A04h-820D4A10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A10);
		  /* 820D4A10h */ case    0:  		/* rlwinm R11, R31, 4, 30, 31 */
		/* 820D4A10h case    0:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R11,regs.R31);
		/* 820D4A10h case    0:*/		return 0x820D4A14;
		  /* 820D4A14h */ case    1:  		/* rlwinm R9, R31, 2, 30, 31 */
		/* 820D4A14h case    1:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R9,regs.R31);
		/* 820D4A14h case    1:*/		return 0x820D4A18;
		  /* 820D4A18h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 820D4A18h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820D4A18h case    2:*/		return 0x820D4A1C;
		  /* 820D4A1Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820D4A1Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820D4A2C;  }
		/* 820D4A1Ch case    3:*/		return 0x820D4A20;
		  /* 820D4A20h */ case    4:  		/* rlwinm R10, R10, 26, 30, 31 */
		/* 820D4A20h case    4:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R10,regs.R10);
		/* 820D4A20h case    4:*/		return 0x820D4A24;
		  /* 820D4A24h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820D4A24h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820D4A24h case    5:*/		return 0x820D4A28;
		  /* 820D4A28h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820D4A28h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D4A40;  }
		/* 820D4A28h case    6:*/		return 0x820D4A2C;
	}
	return 0x820D4A2C;
} // Block from 820D4A10h-820D4A2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A2C);
		  /* 820D4A2Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D4A2Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4A2Ch case    0:*/		return 0x820D4A30;
		  /* 820D4A30h */ case    1:  		/* addi R4, R11, 27796 */
		/* 820D4A30h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6C94);
		/* 820D4A30h case    1:*/		return 0x820D4A34;
		  /* 820D4A34h */ case    2:  		/* b -48 */
		/* 820D4A34h case    2:*/		return 0x820D4A04;
		/* 820D4A34h case    2:*/		return 0x820D4A38;
	}
	return 0x820D4A38;
} // Block from 820D4A2Ch-820D4A38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A38);
		  /* 820D4A38h */ case    0:  		/* rlwimi R11, R10, 30, 0, 1 */
		/* 820D4A38h case    0:*/		cpu::op::rlwimi<0,30,0,1>(regs,&regs.R11,regs.R10);
		/* 820D4A38h case    0:*/		return 0x820D4A3C;
		  /* 820D4A3Ch */ case    1:  		/* mr R31, R11 */
		/* 820D4A3Ch case    1:*/		regs.R31 = regs.R11;
		/* 820D4A3Ch case    1:*/		return 0x820D4A40;
	}
	return 0x820D4A40;
} // Block from 820D4A38h-820D4A40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A40);
		  /* 820D4A40h */ case    0:  		/* stw R31, <#[R26]> */
		/* 820D4A40h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + 0x00000000) );
		/* 820D4A40h case    0:*/		return 0x820D4A44;
		  /* 820D4A44h */ case    1:  		/* stw R29, <#[R26 + 4]> */
		/* 820D4A44h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R26 + 0x00000004) );
		/* 820D4A44h case    1:*/		return 0x820D4A48;
		  /* 820D4A48h */ case    2:  		/* stw R24, <#[R26 + 8]> */
		/* 820D4A48h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R26 + 0x00000008) );
		/* 820D4A48h case    2:*/		return 0x820D4A4C;
	}
	return 0x820D4A4C;
} // Block from 820D4A40h-820D4A4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A4C);
		  /* 820D4A4Ch */ case    0:  		/* addi R1, R1, 192 */
		/* 820D4A4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820D4A4Ch case    0:*/		return 0x820D4A50;
		  /* 820D4A50h */ case    1:  		/* b -276408 */
		/* 820D4A50h case    1:*/		return 0x82091298;
		/* 820D4A50h case    1:*/		return 0x820D4A54;
		  /* 820D4A54h */ case    2:  		/* nop */
		/* 820D4A54h case    2:*/		cpu::op::nop();
		/* 820D4A54h case    2:*/		return 0x820D4A58;
	}
	return 0x820D4A58;
} // Block from 820D4A4Ch-820D4A58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A58);
		  /* 820D4A58h */ case    0:  		/* mfspr R12, LR */
		/* 820D4A58h case    0:*/		regs.R12 = regs.LR;
		/* 820D4A58h case    0:*/		return 0x820D4A5C;
		  /* 820D4A5Ch */ case    1:  		/* bl -276492 */
		/* 820D4A5Ch case    1:*/		regs.LR = 0x820D4A60; return 0x82091250;
		/* 820D4A5Ch case    1:*/		return 0x820D4A60;
		  /* 820D4A60h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820D4A60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820D4A60h case    2:*/		return 0x820D4A64;
		  /* 820D4A64h */ case    3:  		/* lwz R11, <#[R3 + 104]> */
		/* 820D4A64h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000068) );
		/* 820D4A64h case    3:*/		return 0x820D4A68;
		  /* 820D4A68h */ case    4:  		/* mr R29, R3 */
		/* 820D4A68h case    4:*/		regs.R29 = regs.R3;
		/* 820D4A68h case    4:*/		return 0x820D4A6C;
		  /* 820D4A6Ch */ case    5:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 820D4A6Ch case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 820D4A6Ch case    5:*/		return 0x820D4A70;
		  /* 820D4A70h */ case    6:  		/* bc 4, CR0_EQ, 196 */
		/* 820D4A70h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820D4B34;  }
		/* 820D4A70h case    6:*/		return 0x820D4A74;
		  /* 820D4A74h */ case    7:  		/* li R10, 16 */
		/* 820D4A74h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 820D4A74h case    7:*/		return 0x820D4A78;
	}
	return 0x820D4A78;
} // Block from 820D4A58h-820D4A78h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D4A78h
// Function '?GetYieldValue@CUAssembler@D3DXShader@@IAAHPAVCNodeUAsmInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4A78);
		  /* 820D4A78h */ case    0:  		/* li R9, 0 */
		/* 820D4A78h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820D4A78h case    0:*/		return 0x820D4A7C;
		  /* 820D4A7Ch */ case    1:  		/* li R28, 0 */
		/* 820D4A7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820D4A7Ch case    1:*/		return 0x820D4A80;
		  /* 820D4A80h */ case    2:  		/* li R11, 0 */
		/* 820D4A80h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820D4A80h case    2:*/		return 0x820D4A84;
		  /* 820D4A84h */ case    3:  		/* addi R26, R3, 172 */
		/* 820D4A84h case    3:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0xAC);
		/* 820D4A84h case    3:*/		return 0x820D4A88;
		  /* 820D4A88h */ case    4:  		/* mtspr CTR, R10 */
		/* 820D4A88h case    4:*/		regs.CTR = regs.R10;
		/* 820D4A88h case    4:*/		return 0x820D4A8C;
		  /* 820D4A8Ch */ case    5:  		/* lbzx R10, <#[R26 + R11]> */
		/* 820D4A8Ch case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 820D4A8Ch case    5:*/		return 0x820D4A90;
		  /* 820D4A90h */ case    6:  		/* cmplwi CR0, R10, 0 */
		/* 820D4A90h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820D4A90h case    6:*/		return 0x820D4A94;
		  /* 820D4A94h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 820D4A94h case    7:*/		if ( regs.CR[0].eq ) { return 0x820D4AA0;  }
		/* 820D4A94h case    7:*/		return 0x820D4A98;
		  /* 820D4A98h */ case    8:  		/* addi R9, R9, 1 */
		/* 820D4A98h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820D4A98h case    8:*/		return 0x820D4A9C;
		  /* 820D4A9Ch */ case    9:  		/* mr R28, R11 */
		/* 820D4A9Ch case    9:*/		regs.R28 = regs.R11;
		/* 820D4A9Ch case    9:*/		return 0x820D4AA0;
	}
	return 0x820D4AA0;
} // Block from 820D4A78h-820D4AA0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D4AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4AA0);
		  /* 820D4AA0h */ case    0:  		/* addi R11, R11, 1 */
		/* 820D4AA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D4AA0h case    0:*/		return 0x820D4AA4;
		  /* 820D4AA4h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820D4AA4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820D4A8C;  }
		/* 820D4AA4h case    1:*/		return 0x820D4AA8;
		  /* 820D4AA8h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 820D4AA8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D4AA8h case    2:*/		return 0x820D4AAC;
		  /* 820D4AACh */ case    3:  		/* bc 12, CR6_EQ, 136 */
		/* 820D4AACh case    3:*/		if ( regs.CR[6].eq ) { return 0x820D4B34;  }
		/* 820D4AACh case    3:*/		return 0x820D4AB0;
		  /* 820D4AB0h */ case    4:  		/* addi R11, R28, 1 */
		/* 820D4AB0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1);
		/* 820D4AB0h case    4:*/		return 0x820D4AB4;
		  /* 820D4AB4h */ case    5:  		/* cmplw CR6, R9, R11 */
		/* 820D4AB4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820D4AB4h case    5:*/		return 0x820D4AB8;
		  /* 820D4AB8h */ case    6:  		/* bc 12, CR6_EQ, 124 */
		/* 820D4AB8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D4B34;  }
		/* 820D4AB8h case    6:*/		return 0x820D4ABC;
		  /* 820D4ABCh */ case    7:  		/* lwz R11, <#[R29 + 72]> */
		/* 820D4ABCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000048) );
		/* 820D4ABCh case    7:*/		return 0x820D4AC0;
		  /* 820D4AC0h */ case    8:  		/* lis R10, -32255 */
		/* 820D4AC0h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D4AC0h case    8:*/		return 0x820D4AC4;
		  /* 820D4AC4h */ case    9:  		/* mr R3, R29 */
		/* 820D4AC4h case    9:*/		regs.R3 = regs.R29;
		/* 820D4AC4h case    9:*/		return 0x820D4AC8;
		  /* 820D4AC8h */ case   10:  		/* addi R11, R11, -1 */
		/* 820D4AC8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820D4AC8h case   10:*/		return 0x820D4ACC;
		  /* 820D4ACCh */ case   11:  		/* addi R4, R10, 28416 */
		/* 820D4ACCh case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x6F00);
		/* 820D4ACCh case   11:*/		return 0x820D4AD0;
		  /* 820D4AD0h */ case   12:  		/* cntlzw R11, R11 */
		/* 820D4AD0h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820D4AD0h case   12:*/		return 0x820D4AD4;
		  /* 820D4AD4h */ case   13:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820D4AD4h case   13:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820D4AD4h case   13:*/		return 0x820D4AD8;
	}
	return 0x820D4AD8;
} // Block from 820D4AA0h-820D4AD8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D4AD8h
// Function '?InitCheck@CUAssembler@D3DXShader@@IAAJPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4AD8);
		  /* 820D4AD8h */ case    0:  		/* subfic R11, R11, 0 */
		/* 820D4AD8h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820D4AD8h case    0:*/		return 0x820D4ADC;
		  /* 820D4ADCh */ case    1:  		/* subfe R11, R11, R11 */
		/* 820D4ADCh case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820D4ADCh case    1:*/		return 0x820D4AE0;
		  /* 820D4AE0h */ case    2:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 820D4AE0h case    2:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 820D4AE0h case    2:*/		return 0x820D4AE4;
		  /* 820D4AE4h */ case    3:  		/* addi R11, R11, 111 */
		/* 820D4AE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6F);
		/* 820D4AE4h case    3:*/		return 0x820D4AE8;
		  /* 820D4AE8h */ case    4:  		/* extsb R30, R11 */
		/* 820D4AE8h case    4:*/		cpu::op::extsb<0>(regs,&regs.R30,regs.R11);
		/* 820D4AE8h case    4:*/		return 0x820D4AEC;
		  /* 820D4AECh */ case    5:  		/* mr R5, R30 */
		/* 820D4AECh case    5:*/		regs.R5 = regs.R30;
		/* 820D4AECh case    5:*/		return 0x820D4AF0;
		  /* 820D4AF0h */ case    6:  		/* bl -16904 */
		/* 820D4AF0h case    6:*/		regs.LR = 0x820D4AF4; return 0x820D08E8;
		/* 820D4AF0h case    6:*/		return 0x820D4AF4;
		  /* 820D4AF4h */ case    7:  		/* li R31, 0 */
		/* 820D4AF4h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820D4AF4h case    7:*/		return 0x820D4AF8;
		  /* 820D4AF8h */ case    8:  		/* cmplwi CR6, R28, 0 */
		/* 820D4AF8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820D4AF8h case    8:*/		return 0x820D4AFC;
		  /* 820D4AFCh */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 820D4AFCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820D4B34;  }
		/* 820D4AFCh case    9:*/		return 0x820D4B00;
		  /* 820D4B00h */ case   10:  		/* lis R11, -32255 */
		/* 820D4B00h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4B00h case   10:*/		return 0x820D4B04;
		  /* 820D4B04h */ case   11:  		/* addi R27, R11, 28364 */
		/* 820D4B04h case   11:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x6ECC);
		/* 820D4B04h case   11:*/		return 0x820D4B08;
		  /* 820D4B08h */ case   12:  		/* lbzx R11, <#[R26 + R31]> */
		/* 820D4B08h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + regs.R31 + 0x00000000) );
		/* 820D4B08h case   12:*/		return 0x820D4B0C;
		  /* 820D4B0Ch */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 820D4B0Ch case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D4B0Ch case   13:*/		return 0x820D4B10;
		  /* 820D4B10h */ case   14:  		/* bc 4, CR0_EQ, 24 */
		/* 820D4B10h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820D4B28;  }
		/* 820D4B10h case   14:*/		return 0x820D4B14;
		  /* 820D4B14h */ case   15:  		/* mr R4, R27 */
		/* 820D4B14h case   15:*/		regs.R4 = regs.R27;
		/* 820D4B14h case   15:*/		return 0x820D4B18;
		  /* 820D4B18h */ case   16:  		/* mr R6, R31 */
		/* 820D4B18h case   16:*/		regs.R6 = regs.R31;
		/* 820D4B18h case   16:*/		return 0x820D4B1C;
		  /* 820D4B1Ch */ case   17:  		/* mr R5, R30 */
		/* 820D4B1Ch case   17:*/		regs.R5 = regs.R30;
		/* 820D4B1Ch case   17:*/		return 0x820D4B20;
	}
	return 0x820D4B20;
} // Block from 820D4AD8h-820D4B20h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820D4B20h
// Function '?DoSrcReg@CUAssembler@D3DXShader@@IAAXAATGPUALU_INSTRUCTION@@KPAVCNodeUAsmRegister@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4B20);
		  /* 820D4B20h */ case    0:  		/* mr R3, R29 */
		/* 820D4B20h case    0:*/		regs.R3 = regs.R29;
		/* 820D4B20h case    0:*/		return 0x820D4B24;
		  /* 820D4B24h */ case    1:  		/* bl -16956 */
		/* 820D4B24h case    1:*/		regs.LR = 0x820D4B28; return 0x820D08E8;
		/* 820D4B24h case    1:*/		return 0x820D4B28;
	}
	return 0x820D4B28;
} // Block from 820D4B20h-820D4B28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4B28);
		  /* 820D4B28h */ case    0:  		/* addi R31, R31, 1 */
		/* 820D4B28h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820D4B28h case    0:*/		return 0x820D4B2C;
		  /* 820D4B2Ch */ case    1:  		/* cmplw CR6, R31, R28 */
		/* 820D4B2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 820D4B2Ch case    1:*/		return 0x820D4B30;
		  /* 820D4B30h */ case    2:  		/* bc 12, CR6_LT, -40 */
		/* 820D4B30h case    2:*/		if ( regs.CR[6].lt ) { return 0x820D4B08;  }
		/* 820D4B30h case    2:*/		return 0x820D4B34;
	}
	return 0x820D4B34;
} // Block from 820D4B28h-820D4B34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4B34);
		  /* 820D4B34h */ case    0:  		/* addi R1, R1, 176 */
		/* 820D4B34h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820D4B34h case    0:*/		return 0x820D4B38;
		  /* 820D4B38h */ case    1:  		/* b -276632 */
		/* 820D4B38h case    1:*/		return 0x820912A0;
		/* 820D4B38h case    1:*/		return 0x820D4B3C;
		  /* 820D4B3Ch */ case    2:  		/* nop */
		/* 820D4B3Ch case    2:*/		cpu::op::nop();
		/* 820D4B3Ch case    2:*/		return 0x820D4B40;
	}
	return 0x820D4B40;
} // Block from 820D4B34h-820D4B40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4B40);
		  /* 820D4B40h */ case    0:  		/* mfspr R12, LR */
		/* 820D4B40h case    0:*/		regs.R12 = regs.LR;
		/* 820D4B40h case    0:*/		return 0x820D4B44;
		  /* 820D4B44h */ case    1:  		/* bl -276716 */
		/* 820D4B44h case    1:*/		regs.LR = 0x820D4B48; return 0x82091258;
		/* 820D4B44h case    1:*/		return 0x820D4B48;
		  /* 820D4B48h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820D4B48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820D4B48h case    2:*/		return 0x820D4B4C;
		  /* 820D4B4Ch */ case    3:  		/* mr R30, R3 */
		/* 820D4B4Ch case    3:*/		regs.R30 = regs.R3;
		/* 820D4B4Ch case    3:*/		return 0x820D4B50;
		  /* 820D4B50h */ case    4:  		/* li R31, 1 */
		/* 820D4B50h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820D4B50h case    4:*/		return 0x820D4B54;
		  /* 820D4B54h */ case    5:  		/* li R29, 0 */
		/* 820D4B54h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820D4B54h case    5:*/		return 0x820D4B58;
		  /* 820D4B58h */ case    6:  		/* lwz R11, <#[R30 + 132]> */
		/* 820D4B58h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 820D4B58h case    6:*/		return 0x820D4B5C;
		  /* 820D4B5Ch */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820D4B5Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D4B5Ch case    7:*/		return 0x820D4B60;
		  /* 820D4B60h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820D4B60h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D4B78;  }
		/* 820D4B60h case    8:*/		return 0x820D4B64;
		  /* 820D4B64h */ case    9:  		/* addi R4, R30, 16 */
		/* 820D4B64h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820D4B64h case    9:*/		return 0x820D4B68;
		  /* 820D4B68h */ case   10:  		/* lwz R3, <#[R30 + 4]> */
		/* 820D4B68h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 820D4B68h case   10:*/		return 0x820D4B6C;
		  /* 820D4B6Ch */ case   11:  		/* bl -25844 */
		/* 820D4B6Ch case   11:*/		regs.LR = 0x820D4B70; return 0x820CE678;
		/* 820D4B6Ch case   11:*/		return 0x820D4B70;
		  /* 820D4B70h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820D4B70h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820D4B70h case   12:*/		return 0x820D4B74;
		  /* 820D4B74h */ case   13:  		/* bc 12, CR0_LT, 204 */
		/* 820D4B74h case   13:*/		if ( regs.CR[0].lt ) { return 0x820D4C40;  }
		/* 820D4B74h case   13:*/		return 0x820D4B78;
	}
	return 0x820D4B78;
} // Block from 820D4B40h-820D4B78h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D4B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4B78);
		  /* 820D4B78h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820D4B78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820D4B78h case    0:*/		return 0x820D4B7C;
		  /* 820D4B7Ch */ case    1:  		/* addi R28, R30, 16 */
		/* 820D4B7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x10);
		/* 820D4B7Ch case    1:*/		return 0x820D4B80;
		  /* 820D4B80h */ case    2:  		/* stw R31, <#[R30 + 132]> */
		/* 820D4B80h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000084) );
		/* 820D4B80h case    2:*/		return 0x820D4B84;
		  /* 820D4B84h */ case    3:  		/* cmpwi CR6, R11, 16 */
		/* 820D4B84h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000010);
		/* 820D4B84h case    3:*/		return 0x820D4B88;
		  /* 820D4B88h */ case    4:  		/* bc 12, CR6_EQ, 132 */
		/* 820D4B88h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D4C0C;  }
		/* 820D4B88h case    4:*/		return 0x820D4B8C;
		  /* 820D4B8Ch */ case    5:  		/* lbz R10, <#[R30 + 8]> */
		/* 820D4B8Ch case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 820D4B8Ch case    5:*/		return 0x820D4B90;
		  /* 820D4B90h */ case    6:  		/* cmplwi CR6, R10, 1 */
		/* 820D4B90h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820D4B90h case    6:*/		return 0x820D4B94;
		  /* 820D4B94h */ case    7:  		/* bc 12, CR6_LT, 80 */
		/* 820D4B94h case    7:*/		if ( regs.CR[6].lt ) { return 0x820D4BE4;  }
		/* 820D4B94h case    7:*/		return 0x820D4B98;
		  /* 820D4B98h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820D4B98h case    8:*/		if ( regs.CR[6].eq ) { return 0x820D4BB8;  }
		/* 820D4B98h case    8:*/		return 0x820D4B9C;
		  /* 820D4B9Ch */ case    9:  		/* cmplwi CR6, R10, 3 */
		/* 820D4B9Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820D4B9Ch case    9:*/		return 0x820D4BA0;
		  /* 820D4BA0h */ case   10:  		/* bc 4, CR6_LT, 108 */
		/* 820D4BA0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820D4C0C;  }
		/* 820D4BA0h case   10:*/		return 0x820D4BA4;
		  /* 820D4BA4h */ case   11:  		/* stb R29, <#[R30 + 8]> */
		/* 820D4BA4h case   11:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 820D4BA4h case   11:*/		return 0x820D4BA8;
		  /* 820D4BA8h */ case   12:  		/* li R4, 0 */
		/* 820D4BA8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D4BA8h case   12:*/		return 0x820D4BAC;
		  /* 820D4BACh */ case   13:  		/* lwz R3, <#[R30 + 4]> */
		/* 820D4BACh case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 820D4BACh case   13:*/		return 0x820D4BB0;
		  /* 820D4BB0h */ case   14:  		/* bl -212952 */
		/* 820D4BB0h case   14:*/		regs.LR = 0x820D4BB4; return 0x820A0BD8;
		/* 820D4BB0h case   14:*/		return 0x820D4BB4;
		  /* 820D4BB4h */ case   15:  		/* b 88 */
		/* 820D4BB4h case   15:*/		return 0x820D4C0C;
		/* 820D4BB4h case   15:*/		return 0x820D4BB8;
	}
	return 0x820D4BB8;
} // Block from 820D4B78h-820D4BB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D4BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4BB8);
		  /* 820D4BB8h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820D4BB8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820D4BB8h case    0:*/		return 0x820D4BBC;
		  /* 820D4BBCh */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 820D4BBCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D4BA4;  }
		/* 820D4BBCh case    1:*/		return 0x820D4BC0;
		  /* 820D4BC0h */ case    2:  		/* lbz R11, <#[R30 + 25]> */
		/* 820D4BC0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000019) );
		/* 820D4BC0h case    2:*/		return 0x820D4BC4;
		  /* 820D4BC4h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820D4BC4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D4BC4h case    3:*/		return 0x820D4BC8;
		  /* 820D4BC8h */ case    4:  		/* bc 4, CR0_EQ, -36 */
		/* 820D4BC8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820D4BA4;  }
		/* 820D4BC8h case    4:*/		return 0x820D4BCC;
		  /* 820D4BCCh */ case    5:  		/* lbz R11, <#[R30 + 24]> */
		/* 820D4BCCh case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820D4BCCh case    5:*/		return 0x820D4BD0;
		  /* 820D4BD0h */ case    6:  		/* cmplwi CR6, R11, 46 */
		/* 820D4BD0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002E);
		/* 820D4BD0h case    6:*/		return 0x820D4BD4;
		  /* 820D4BD4h */ case    7:  		/* bc 4, CR6_EQ, -48 */
		/* 820D4BD4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820D4BA4;  }
		/* 820D4BD4h case    7:*/		return 0x820D4BD8;
		  /* 820D4BD8h */ case    8:  		/* li R11, 2 */
		/* 820D4BD8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820D4BD8h case    8:*/		return 0x820D4BDC;
		  /* 820D4BDCh */ case    9:  		/* stb R11, <#[R30 + 8]> */
		/* 820D4BDCh case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820D4BDCh case    9:*/		return 0x820D4BE0;
		  /* 820D4BE0h */ case   10:  		/* b 44 */
		/* 820D4BE0h case   10:*/		return 0x820D4C0C;
		/* 820D4BE0h case   10:*/		return 0x820D4BE4;
	}
	return 0x820D4BE4;
} // Block from 820D4BB8h-820D4BE4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D4BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4BE4);
		  /* 820D4BE4h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 820D4BE4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D4BE4h case    0:*/		return 0x820D4BE8;
		  /* 820D4BE8h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 820D4BE8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D4C0C;  }
		/* 820D4BE8h case    1:*/		return 0x820D4BEC;
		  /* 820D4BECh */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820D4BECh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820D4BECh case    2:*/		return 0x820D4BF0;
		  /* 820D4BF0h */ case    3:  		/* bl -26256 */
		/* 820D4BF0h case    3:*/		regs.LR = 0x820D4BF4; return 0x820CE560;
		/* 820D4BF0h case    3:*/		return 0x820D4BF4;
		  /* 820D4BF4h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 820D4BF4h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 820D4BF4h case    4:*/		return 0x820D4BF8;
		  /* 820D4BF8h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4BF8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820D4C0C;  }
		/* 820D4BF8h case    5:*/		return 0x820D4BFC;
		  /* 820D4BFCh */ case    6:  		/* li R4, 1 */
		/* 820D4BFCh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820D4BFCh case    6:*/		return 0x820D4C00;
		  /* 820D4C00h */ case    7:  		/* lwz R3, <#[R30 + 4]> */
		/* 820D4C00h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 820D4C00h case    7:*/		return 0x820D4C04;
		  /* 820D4C04h */ case    8:  		/* bl -213036 */
		/* 820D4C04h case    8:*/		regs.LR = 0x820D4C08; return 0x820A0BD8;
		/* 820D4C04h case    8:*/		return 0x820D4C08;
		  /* 820D4C08h */ case    9:  		/* stb R31, <#[R30 + 8]> */
		/* 820D4C08h case    9:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R30 + 0x00000008) );
		/* 820D4C08h case    9:*/		return 0x820D4C0C;
	}
	return 0x820D4C0C;
} // Block from 820D4BE4h-820D4C0Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D4C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4C0C);
		  /* 820D4C0Ch */ case    0:  		/* lwz R11, <#[R28]> */
		/* 820D4C0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820D4C0Ch case    0:*/		return 0x820D4C10;
		  /* 820D4C10h */ case    1:  		/* cmplwi CR6, R11, 17 */
		/* 820D4C10h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 820D4C10h case    1:*/		return 0x820D4C14;
		  /* 820D4C14h */ case    2:  		/* bc 12, CR6_GT, 436 */
		/* 820D4C14h case    2:*/		if ( regs.CR[6].gt ) { return 0x820D4DC8;  }
		/* 820D4C14h case    2:*/		return 0x820D4C18;
		  /* 820D4C18h */ case    3:  		/* lis R12, -32255 */
		/* 820D4C18h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820D4C18h case    3:*/		return 0x820D4C1C;
		  /* 820D4C1Ch */ case    4:  		/* addi R12, R12, 21864 */
		/* 820D4C1Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5568);
		/* 820D4C1Ch case    4:*/		return 0x820D4C20;
		  /* 820D4C20h */ case    5:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820D4C20h case    5:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820D4C20h case    5:*/		return 0x820D4C24;
		  /* 820D4C24h */ case    6:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820D4C24h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820D4C24h case    6:*/		return 0x820D4C28;
		  /* 820D4C28h */ case    7:  		/* lis R12, -32243 */
		/* 820D4C28h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820D);
		/* 820D4C28h case    7:*/		return 0x820D4C2C;
		  /* 820D4C2Ch */ case    8:  		/* ori R0, R0, 0 */
		/* 820D4C2Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820D4C2Ch case    8:*/		return 0x820D4C30;
		  /* 820D4C30h */ case    9:  		/* addi R12, R12, 19288 */
		/* 820D4C30h case    9:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x4B58);
		/* 820D4C30h case    9:*/		return 0x820D4C34;
		  /* 820D4C34h */ case   10:  		/* add R12, R12, R0 */
		/* 820D4C34h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820D4C34h case   10:*/		return 0x820D4C38;
		  /* 820D4C38h */ case   11:  		/* mtspr CTR, R12 */
		/* 820D4C38h case   11:*/		regs.CTR = regs.R12;
		/* 820D4C38h case   11:*/		return 0x820D4C3C;
		  /* 820D4C3Ch */ case   12:  		/* bcctr 20, CR0_LT */
		/* 820D4C3Ch case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820D4C3Ch case   12:*/		return 0x820D4C40;
	}
	return 0x820D4C40;
} // Block from 820D4C0Ch-820D4C40h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820D4C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4C40);
		  /* 820D4C40h */ case    0:  		/* stw R31, <#[R30 + 60]> */
		/* 820D4C40h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000003C) );
		/* 820D4C40h case    0:*/		return 0x820D4C44;
		  /* 820D4C44h */ case    1:  		/* stw R31, <#[R30 + 64]> */
		/* 820D4C44h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000040) );
		/* 820D4C44h case    1:*/		return 0x820D4C48;
		  /* 820D4C48h */ case    2:  		/* li R3, -1 */
		/* 820D4C48h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820D4C48h case    2:*/		return 0x820D4C4C;
		  /* 820D4C4Ch */ case    3:  		/* b 384 */
		/* 820D4C4Ch case    3:*/		return 0x820D4DCC;
		/* 820D4C4Ch case    3:*/		return 0x820D4C50;
		  /* 820D4C50h */ case    4:  		/* lbz R11, <#[R30 + 25]> */
		/* 820D4C50h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000019) );
		/* 820D4C50h case    4:*/		return 0x820D4C54;
		  /* 820D4C54h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820D4C54h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820D4C54h case    5:*/		return 0x820D4C58;
		  /* 820D4C58h */ case    6:  		/* bc 4, CR0_EQ, 368 */
		/* 820D4C58h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820D4DC8;  }
		/* 820D4C58h case    6:*/		return 0x820D4C5C;
		  /* 820D4C5Ch */ case    7:  		/* lbz R3, <#[R30 + 24]> */
		/* 820D4C5Ch case    7:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820D4C5Ch case    7:*/		return 0x820D4C60;
		  /* 820D4C60h */ case    8:  		/* b 364 */
		/* 820D4C60h case    8:*/		return 0x820D4DCC;
		/* 820D4C60h case    8:*/		return 0x820D4C64;
		  /* 820D4C64h */ case    9:  		/* li R3, 278 */
		/* 820D4C64h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x116);
		/* 820D4C64h case    9:*/		return 0x820D4C68;
		  /* 820D4C68h */ case   10:  		/* b 356 */
		/* 820D4C68h case   10:*/		return 0x820D4DCC;
		/* 820D4C68h case   10:*/		return 0x820D4C6C;
		  /* 820D4C6Ch */ case   11:  		/* li R3, 279 */
		/* 820D4C6Ch case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x117);
		/* 820D4C6Ch case   11:*/		return 0x820D4C70;
		  /* 820D4C70h */ case   12:  		/* b 348 */
		/* 820D4C70h case   12:*/		return 0x820D4DCC;
		/* 820D4C70h case   12:*/		return 0x820D4C74;
		  /* 820D4C74h */ case   13:  		/* lis R11, -32255 */
		/* 820D4C74h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4C74h case   13:*/		return 0x820D4C78;
		  /* 820D4C78h */ case   14:  		/* lwz R8, <#[R30 + 24]> */
		/* 820D4C78h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000018) );
		/* 820D4C78h case   14:*/		return 0x820D4C7C;
		  /* 820D4C7Ch */ case   15:  		/* addi R10, R11, 5232 */
		/* 820D4C7Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1470);
		/* 820D4C7Ch case   15:*/		return 0x820D4C80;
		  /* 820D4C80h */ case   16:  		/* mr R11, R8 */
		/* 820D4C80h case   16:*/		regs.R11 = regs.R8;
		/* 820D4C80h case   16:*/		return 0x820D4C84;
		  /* 820D4C84h */ case   17:  		/* lbz R9, <#[R11]> */
		/* 820D4C84h case   17:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D4C84h case   17:*/		return 0x820D4C88;
		  /* 820D4C88h */ case   18:  		/* lbz R7, <#[R10]> */
		/* 820D4C88h case   18:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D4C88h case   18:*/		return 0x820D4C8C;
		  /* 820D4C8Ch */ case   19:  		/* cmpwi CR0, R9, 0 */
		/* 820D4C8Ch case   19:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4C8Ch case   19:*/		return 0x820D4C90;
		  /* 820D4C90h */ case   20:  		/* subf R9, R7, R9 */
		/* 820D4C90h case   20:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D4C90h case   20:*/		return 0x820D4C94;
		  /* 820D4C94h */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4C94h case   21:*/		if ( regs.CR[0].eq ) { return 0x820D4CA8;  }
		/* 820D4C94h case   21:*/		return 0x820D4C98;
	}
	return 0x820D4C98;
} // Block from 820D4C40h-820D4C98h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820D4C98h
// Function '?DoDest@CUAssembler@D3DXShader@@IAAXAATGPUALU_INSTRUCTION@@PAVCNodeUAsmInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4C98);
		  /* 820D4C98h */ case    0:  		/* addi R11, R11, 1 */
		/* 820D4C98h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D4C98h case    0:*/		return 0x820D4C9C;
		  /* 820D4C9Ch */ case    1:  		/* addi R10, R10, 1 */
		/* 820D4C9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D4C9Ch case    1:*/		return 0x820D4CA0;
		  /* 820D4CA0h */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820D4CA0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D4CA0h case    2:*/		return 0x820D4CA4;
		  /* 820D4CA4h */ case    3:  		/* bc 12, CR6_EQ, -32 */
		/* 820D4CA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820D4C84;  }
		/* 820D4CA4h case    3:*/		return 0x820D4CA8;
	}
	return 0x820D4CA8;
} // Block from 820D4C98h-820D4CA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4CA8);
		  /* 820D4CA8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D4CA8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4CA8h case    0:*/		return 0x820D4CAC;
		  /* 820D4CACh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D4CACh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D4CB8;  }
		/* 820D4CACh case    1:*/		return 0x820D4CB0;
		  /* 820D4CB0h */ case    2:  		/* li R3, 257 */
		/* 820D4CB0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x101);
		/* 820D4CB0h case    2:*/		return 0x820D4CB4;
		  /* 820D4CB4h */ case    3:  		/* b 280 */
		/* 820D4CB4h case    3:*/		return 0x820D4DCC;
		/* 820D4CB4h case    3:*/		return 0x820D4CB8;
	}
	return 0x820D4CB8;
} // Block from 820D4CA8h-820D4CB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4CB8);
		  /* 820D4CB8h */ case    0:  		/* lis R10, -32255 */
		/* 820D4CB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D4CB8h case    0:*/		return 0x820D4CBC;
		  /* 820D4CBCh */ case    1:  		/* mr R11, R8 */
		/* 820D4CBCh case    1:*/		regs.R11 = regs.R8;
		/* 820D4CBCh case    1:*/		return 0x820D4CC0;
		  /* 820D4CC0h */ case    2:  		/* addi R10, R10, 5224 */
		/* 820D4CC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1468);
		/* 820D4CC0h case    2:*/		return 0x820D4CC4;
		  /* 820D4CC4h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820D4CC4h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D4CC4h case    3:*/		return 0x820D4CC8;
		  /* 820D4CC8h */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820D4CC8h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D4CC8h case    4:*/		return 0x820D4CCC;
		  /* 820D4CCCh */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820D4CCCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4CCCh case    5:*/		return 0x820D4CD0;
		  /* 820D4CD0h */ case    6:  		/* subf R9, R7, R9 */
		/* 820D4CD0h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D4CD0h case    6:*/		return 0x820D4CD4;
		  /* 820D4CD4h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4CD4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820D4CE8;  }
		/* 820D4CD4h case    7:*/		return 0x820D4CD8;
		  /* 820D4CD8h */ case    8:  		/* addi R11, R11, 1 */
		/* 820D4CD8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D4CD8h case    8:*/		return 0x820D4CDC;
		  /* 820D4CDCh */ case    9:  		/* addi R10, R10, 1 */
		/* 820D4CDCh case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D4CDCh case    9:*/		return 0x820D4CE0;
		  /* 820D4CE0h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820D4CE0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D4CE0h case   10:*/		return 0x820D4CE4;
		  /* 820D4CE4h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820D4CE4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820D4CC4;  }
		/* 820D4CE4h case   11:*/		return 0x820D4CE8;
	}
	return 0x820D4CE8;
} // Block from 820D4CB8h-820D4CE8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D4CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4CE8);
		  /* 820D4CE8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D4CE8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4CE8h case    0:*/		return 0x820D4CEC;
		  /* 820D4CECh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D4CECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D4CF8;  }
		/* 820D4CECh case    1:*/		return 0x820D4CF0;
		  /* 820D4CF0h */ case    2:  		/* li R3, 281 */
		/* 820D4CF0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x119);
		/* 820D4CF0h case    2:*/		return 0x820D4CF4;
		  /* 820D4CF4h */ case    3:  		/* b 216 */
		/* 820D4CF4h case    3:*/		return 0x820D4DCC;
		/* 820D4CF4h case    3:*/		return 0x820D4CF8;
	}
	return 0x820D4CF8;
} // Block from 820D4CE8h-820D4CF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4CF8);
		  /* 820D4CF8h */ case    0:  		/* lis R10, -32255 */
		/* 820D4CF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D4CF8h case    0:*/		return 0x820D4CFC;
		  /* 820D4CFCh */ case    1:  		/* mr R11, R8 */
		/* 820D4CFCh case    1:*/		regs.R11 = regs.R8;
		/* 820D4CFCh case    1:*/		return 0x820D4D00;
		  /* 820D4D00h */ case    2:  		/* addi R10, R10, 5216 */
		/* 820D4D00h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1460);
		/* 820D4D00h case    2:*/		return 0x820D4D04;
		  /* 820D4D04h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820D4D04h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D4D04h case    3:*/		return 0x820D4D08;
		  /* 820D4D08h */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820D4D08h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D4D08h case    4:*/		return 0x820D4D0C;
		  /* 820D4D0Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820D4D0Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4D0Ch case    5:*/		return 0x820D4D10;
		  /* 820D4D10h */ case    6:  		/* subf R9, R7, R9 */
		/* 820D4D10h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D4D10h case    6:*/		return 0x820D4D14;
		  /* 820D4D14h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4D14h case    7:*/		if ( regs.CR[0].eq ) { return 0x820D4D28;  }
		/* 820D4D14h case    7:*/		return 0x820D4D18;
		  /* 820D4D18h */ case    8:  		/* addi R11, R11, 1 */
		/* 820D4D18h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D4D18h case    8:*/		return 0x820D4D1C;
		  /* 820D4D1Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820D4D1Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D4D1Ch case    9:*/		return 0x820D4D20;
		  /* 820D4D20h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820D4D20h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D4D20h case   10:*/		return 0x820D4D24;
		  /* 820D4D24h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820D4D24h case   11:*/		if ( regs.CR[6].eq ) { return 0x820D4D04;  }
		/* 820D4D24h case   11:*/		return 0x820D4D28;
	}
	return 0x820D4D28;
} // Block from 820D4CF8h-820D4D28h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D4D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4D28);
		  /* 820D4D28h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D4D28h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4D28h case    0:*/		return 0x820D4D2C;
		  /* 820D4D2Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D4D2Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D4D38;  }
		/* 820D4D2Ch case    1:*/		return 0x820D4D30;
		  /* 820D4D30h */ case    2:  		/* li R3, 282 */
		/* 820D4D30h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x11A);
		/* 820D4D30h case    2:*/		return 0x820D4D34;
		  /* 820D4D34h */ case    3:  		/* b 152 */
		/* 820D4D34h case    3:*/		return 0x820D4DCC;
		/* 820D4D34h case    3:*/		return 0x820D4D38;
	}
	return 0x820D4D38;
} // Block from 820D4D28h-820D4D38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4D38);
		  /* 820D4D38h */ case    0:  		/* lis R10, -32255 */
		/* 820D4D38h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D4D38h case    0:*/		return 0x820D4D3C;
		  /* 820D4D3Ch */ case    1:  		/* mr R11, R8 */
		/* 820D4D3Ch case    1:*/		regs.R11 = regs.R8;
		/* 820D4D3Ch case    1:*/		return 0x820D4D40;
		  /* 820D4D40h */ case    2:  		/* addi R10, R10, 28524 */
		/* 820D4D40h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6F6C);
		/* 820D4D40h case    2:*/		return 0x820D4D44;
		  /* 820D4D44h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820D4D44h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D4D44h case    3:*/		return 0x820D4D48;
		  /* 820D4D48h */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820D4D48h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820D4D48h case    4:*/		return 0x820D4D4C;
		  /* 820D4D4Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820D4D4Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4D4Ch case    5:*/		return 0x820D4D50;
		  /* 820D4D50h */ case    6:  		/* subf R9, R7, R9 */
		/* 820D4D50h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820D4D50h case    6:*/		return 0x820D4D54;
		  /* 820D4D54h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4D54h case    7:*/		if ( regs.CR[0].eq ) { return 0x820D4D68;  }
		/* 820D4D54h case    7:*/		return 0x820D4D58;
		  /* 820D4D58h */ case    8:  		/* addi R11, R11, 1 */
		/* 820D4D58h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D4D58h case    8:*/		return 0x820D4D5C;
		  /* 820D4D5Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820D4D5Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D4D5Ch case    9:*/		return 0x820D4D60;
		  /* 820D4D60h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820D4D60h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D4D60h case   10:*/		return 0x820D4D64;
		  /* 820D4D64h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820D4D64h case   11:*/		if ( regs.CR[6].eq ) { return 0x820D4D44;  }
		/* 820D4D64h case   11:*/		return 0x820D4D68;
	}
	return 0x820D4D68;
} // Block from 820D4D38h-820D4D68h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D4D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4D68);
		  /* 820D4D68h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D4D68h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4D68h case    0:*/		return 0x820D4D6C;
		  /* 820D4D6Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820D4D6Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D4D78;  }
		/* 820D4D6Ch case    1:*/		return 0x820D4D70;
		  /* 820D4D70h */ case    2:  		/* li R3, 283 */
		/* 820D4D70h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x11B);
		/* 820D4D70h case    2:*/		return 0x820D4D74;
		  /* 820D4D74h */ case    3:  		/* b 88 */
		/* 820D4D74h case    3:*/		return 0x820D4DCC;
		/* 820D4D74h case    3:*/		return 0x820D4D78;
	}
	return 0x820D4D78;
} // Block from 820D4D68h-820D4D78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4D78);
		  /* 820D4D78h */ case    0:  		/* lis R10, -32255 */
		/* 820D4D78h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D4D78h case    0:*/		return 0x820D4D7C;
		  /* 820D4D7Ch */ case    1:  		/* mr R11, R8 */
		/* 820D4D7Ch case    1:*/		regs.R11 = regs.R8;
		/* 820D4D7Ch case    1:*/		return 0x820D4D80;
		  /* 820D4D80h */ case    2:  		/* addi R10, R10, 24784 */
		/* 820D4D80h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x60D0);
		/* 820D4D80h case    2:*/		return 0x820D4D84;
		  /* 820D4D84h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820D4D84h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D4D84h case    3:*/		return 0x820D4D88;
		  /* 820D4D88h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820D4D88h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D4D88h case    4:*/		return 0x820D4D8C;
		  /* 820D4D8Ch */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820D4D8Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4D8Ch case    5:*/		return 0x820D4D90;
		  /* 820D4D90h */ case    6:  		/* subf R9, R8, R9 */
		/* 820D4D90h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D4D90h case    6:*/		return 0x820D4D94;
		  /* 820D4D94h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4D94h case    7:*/		if ( regs.CR[0].eq ) { return 0x820D4DA8;  }
		/* 820D4D94h case    7:*/		return 0x820D4D98;
		  /* 820D4D98h */ case    8:  		/* addi R11, R11, 1 */
		/* 820D4D98h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D4D98h case    8:*/		return 0x820D4D9C;
		  /* 820D4D9Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 820D4D9Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D4D9Ch case    9:*/		return 0x820D4DA0;
		  /* 820D4DA0h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820D4DA0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D4DA0h case   10:*/		return 0x820D4DA4;
		  /* 820D4DA4h */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820D4DA4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820D4D84;  }
		/* 820D4DA4h case   11:*/		return 0x820D4DA8;
	}
	return 0x820D4DA8;
} // Block from 820D4D78h-820D4DA8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D4DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4DA8);
		  /* 820D4DA8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D4DA8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4DA8h case    0:*/		return 0x820D4DAC;
		  /* 820D4DACh */ case    1:  		/* mr R4, R28 */
		/* 820D4DACh case    1:*/		regs.R4 = regs.R28;
		/* 820D4DACh case    1:*/		return 0x820D4DB0;
		  /* 820D4DB0h */ case    2:  		/* mr R3, R30 */
		/* 820D4DB0h case    2:*/		regs.R3 = regs.R30;
		/* 820D4DB0h case    2:*/		return 0x820D4DB4;
		  /* 820D4DB4h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 820D4DB4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820D4DC0;  }
		/* 820D4DB4h case    3:*/		return 0x820D4DB8;
		  /* 820D4DB8h */ case    4:  		/* bl -8768 */
		/* 820D4DB8h case    4:*/		regs.LR = 0x820D4DBC; return 0x820D2B78;
		/* 820D4DB8h case    4:*/		return 0x820D4DBC;
		  /* 820D4DBCh */ case    5:  		/* b 16 */
		/* 820D4DBCh case    5:*/		return 0x820D4DCC;
		/* 820D4DBCh case    5:*/		return 0x820D4DC0;
	}
	return 0x820D4DC0;
} // Block from 820D4DA8h-820D4DC0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D4DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4DC0);
		  /* 820D4DC0h */ case    0:  		/* bl -17544 */
		/* 820D4DC0h case    0:*/		regs.LR = 0x820D4DC4; return 0x820D0938;
		/* 820D4DC0h case    0:*/		return 0x820D4DC4;
		  /* 820D4DC4h */ case    1:  		/* b 8 */
		/* 820D4DC4h case    1:*/		return 0x820D4DCC;
		/* 820D4DC4h case    1:*/		return 0x820D4DC8;
	}
	return 0x820D4DC8;
} // Block from 820D4DC0h-820D4DC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D4DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4DC8);
		  /* 820D4DC8h */ case    0:  		/* li R3, 280 */
		/* 820D4DC8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x118);
		/* 820D4DC8h case    0:*/		return 0x820D4DCC;
	}
	return 0x820D4DCC;
} // Block from 820D4DC8h-820D4DCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4DCC);
		  /* 820D4DCCh */ case    0:  		/* addi R1, R1, 128 */
		/* 820D4DCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820D4DCCh case    0:*/		return 0x820D4DD0;
		  /* 820D4DD0h */ case    1:  		/* b -277288 */
		/* 820D4DD0h case    1:*/		return 0x820912A8;
		/* 820D4DD0h case    1:*/		return 0x820D4DD4;
		  /* 820D4DD4h */ case    2:  		/* nop */
		/* 820D4DD4h case    2:*/		cpu::op::nop();
		/* 820D4DD4h case    2:*/		return 0x820D4DD8;
	}
	return 0x820D4DD8;
} // Block from 820D4DCCh-820D4DD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D4DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4DD8);
		  /* 820D4DD8h */ case    0:  		/* mfspr R12, LR */
		/* 820D4DD8h case    0:*/		regs.R12 = regs.LR;
		/* 820D4DD8h case    0:*/		return 0x820D4DDC;
		  /* 820D4DDCh */ case    1:  		/* bl -277436 */
		/* 820D4DDCh case    1:*/		regs.LR = 0x820D4DE0; return 0x82091220;
		/* 820D4DDCh case    1:*/		return 0x820D4DE0;
		  /* 820D4DE0h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 820D4DE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 820D4DE0h case    2:*/		return 0x820D4DE4;
		  /* 820D4DE4h */ case    3:  		/* lwz R11, <#[R4 + 88]> */
		/* 820D4DE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000058) );
		/* 820D4DE4h case    3:*/		return 0x820D4DE8;
		  /* 820D4DE8h */ case    4:  		/* lis R10, -32768 */
		/* 820D4DE8h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 820D4DE8h case    4:*/		return 0x820D4DEC;
		  /* 820D4DECh */ case    5:  		/* mr R29, R3 */
		/* 820D4DECh case    5:*/		regs.R29 = regs.R3;
		/* 820D4DECh case    5:*/		return 0x820D4DF0;
		  /* 820D4DF0h */ case    6:  		/* mr R31, R4 */
		/* 820D4DF0h case    6:*/		regs.R31 = regs.R4;
		/* 820D4DF0h case    6:*/		return 0x820D4DF4;
		  /* 820D4DF4h */ case    7:  		/* li R28, 0 */
		/* 820D4DF4h case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820D4DF4h case    7:*/		return 0x820D4DF8;
		  /* 820D4DF8h */ case    8:  		/* ori R27, R10, 16389 */
		/* 820D4DF8h case    8:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R10,0x4005);
		/* 820D4DF8h case    8:*/		return 0x820D4DFC;
		  /* 820D4DFCh */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 820D4DFCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D4DFCh case    9:*/		return 0x820D4E00;
		  /* 820D4E00h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 820D4E00h case   10:*/		if ( regs.CR[6].eq ) { return 0x820D4E14;  }
		/* 820D4E00h case   10:*/		return 0x820D4E04;
		  /* 820D4E04h */ case   11:  		/* lis R11, -32255 */
		/* 820D4E04h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D4E04h case   11:*/		return 0x820D4E08;
		  /* 820D4E08h */ case   12:  		/* addi R4, R11, 28872 */
		/* 820D4E08h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x70C8);
		/* 820D4E08h case   12:*/		return 0x820D4E0C;
		  /* 820D4E0Ch */ case   13:  		/* bl -17700 */
		/* 820D4E0Ch case   13:*/		regs.LR = 0x820D4E10; return 0x820D08E8;
		/* 820D4E0Ch case   13:*/		return 0x820D4E10;
		  /* 820D4E10h */ case   14:  		/* mr R28, R27 */
		/* 820D4E10h case   14:*/		regs.R28 = regs.R27;
		/* 820D4E10h case   14:*/		return 0x820D4E14;
	}
	return 0x820D4E14;
} // Block from 820D4DD8h-820D4E14h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820D4E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4E14);
		  /* 820D4E14h */ case    0:  		/* lwz R26, <#[R31 + 120]> */
		/* 820D4E14h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x00000078) );
		/* 820D4E14h case    0:*/		return 0x820D4E18;
		  /* 820D4E18h */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 820D4E18h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820D4E18h case    1:*/		return 0x820D4E1C;
		  /* 820D4E1Ch */ case    2:  		/* bc 12, CR6_EQ, 1120 */
		/* 820D4E1Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820D527C;  }
		/* 820D4E1Ch case    2:*/		return 0x820D4E20;
		  /* 820D4E20h */ case    3:  		/* lis R9, -32255 */
		/* 820D4E20h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820D4E20h case    3:*/		return 0x820D4E24;
		  /* 820D4E24h */ case    4:  		/* lis R10, -32255 */
		/* 820D4E24h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820D4E24h case    4:*/		return 0x820D4E28;
		  /* 820D4E28h */ case    5:  		/* lis R5, -32255 */
		/* 820D4E28h case    5:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820D4E28h case    5:*/		return 0x820D4E2C;
		  /* 820D4E2Ch */ case    6:  		/* lis R4, -32255 */
		/* 820D4E2Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 820D4E2Ch case    6:*/		return 0x820D4E30;
		  /* 820D4E30h */ case    7:  		/* lis R3, -32255 */
		/* 820D4E30h case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8201);
		/* 820D4E30h case    7:*/		return 0x820D4E34;
		  /* 820D4E34h */ case    8:  		/* lis R31, -32255 */
		/* 820D4E34h case    8:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820D4E34h case    8:*/		return 0x820D4E38;
		  /* 820D4E38h */ case    9:  		/* lis R30, -32255 */
		/* 820D4E38h case    9:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8201);
		/* 820D4E38h case    9:*/		return 0x820D4E3C;
		  /* 820D4E3Ch */ case   10:  		/* lis R6, -32255 */
		/* 820D4E3Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820D4E3Ch case   10:*/		return 0x820D4E40;
		  /* 820D4E40h */ case   11:  		/* lis R7, -32255 */
		/* 820D4E40h case   11:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820D4E40h case   11:*/		return 0x820D4E44;
		  /* 820D4E44h */ case   12:  		/* lis R8, -32255 */
		/* 820D4E44h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820D4E44h case   12:*/		return 0x820D4E48;
		  /* 820D4E48h */ case   13:  		/* lis R11, -32217 */
		/* 820D4E48h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820D4E48h case   13:*/		return 0x820D4E4C;
		  /* 820D4E4Ch */ case   14:  		/* addi R9, R9, 26496 */
		/* 820D4E4Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x6780);
		/* 820D4E4Ch case   14:*/		return 0x820D4E50;
		  /* 820D4E50h */ case   15:  		/* addi R10, R10, 26488 */
		/* 820D4E50h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6778);
		/* 820D4E50h case   15:*/		return 0x820D4E54;
		  /* 820D4E54h */ case   16:  		/* addi R20, R5, 28836 */
		/* 820D4E54h case   16:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R5,0x70A4);
		/* 820D4E54h case   16:*/		return 0x820D4E58;
		  /* 820D4E58h */ case   17:  		/* stw R9, <#[R1 + 124]> */
		/* 820D4E58h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D4E58h case   17:*/		return 0x820D4E5C;
		  /* 820D4E5Ch */ case   18:  		/* addi R24, R4, 28780 */
		/* 820D4E5Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R4,0x706C);
		/* 820D4E5Ch case   18:*/		return 0x820D4E60;
		  /* 820D4E60h */ case   19:  		/* stw R10, <#[R1 + 120]> */
		/* 820D4E60h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 820D4E60h case   19:*/		return 0x820D4E64;
		  /* 820D4E64h */ case   20:  		/* addi R15, R3, 28740 */
		/* 820D4E64h case   20:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R3,0x7044);
		/* 820D4E64h case   20:*/		return 0x820D4E68;
		  /* 820D4E68h */ case   21:  		/* addi R23, R31, 28708 */
		/* 820D4E68h case   21:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R31,0x7024);
		/* 820D4E68h case   21:*/		return 0x820D4E6C;
		  /* 820D4E6Ch */ case   22:  		/* addi R19, R30, 28668 */
		/* 820D4E6Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R30,0x6FFC);
		/* 820D4E6Ch case   22:*/		return 0x820D4E70;
		  /* 820D4E70h */ case   23:  		/* addi R14, R6, 28608 */
		/* 820D4E70h case   23:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R6,0x6FC0);
		/* 820D4E70h case   23:*/		return 0x820D4E74;
		  /* 820D4E74h */ case   24:  		/* addi R18, R7, 28576 */
		/* 820D4E74h case   24:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R7,0x6FA0);
		/* 820D4E74h case   24:*/		return 0x820D4E78;
		  /* 820D4E78h */ case   25:  		/* addi R22, R8, 28536 */
		/* 820D4E78h case   25:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R8,0x6F78);
		/* 820D4E78h case   25:*/		return 0x820D4E7C;
		  /* 820D4E7Ch */ case   26:  		/* addi R17, R11, 11104 */
		/* 820D4E7Ch case   26:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R11,0x2B60);
		/* 820D4E7Ch case   26:*/		return 0x820D4E80;
		  /* 820D4E80h */ case   27:  		/* b 8 */
		/* 820D4E80h case   27:*/		return 0x820D4E88;
		/* 820D4E80h case   27:*/		return 0x820D4E84;
		  /* 820D4E84h */ case   28:  		/* lwz R26, <#[R1 + 116]> */
		/* 820D4E84h case   28:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000074) );
		/* 820D4E84h case   28:*/		return 0x820D4E88;
	}
	return 0x820D4E88;
} // Block from 820D4E14h-820D4E88h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820D4E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4E88);
		  /* 820D4E88h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 820D4E88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820D4E88h case    0:*/		return 0x820D4E8C;
		  /* 820D4E8Ch */ case    1:  		/* lwz R10, <#[R26 + 12]> */
		/* 820D4E8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000000C) );
		/* 820D4E8Ch case    1:*/		return 0x820D4E90;
		  /* 820D4E90h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 820D4E90h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820D4E90h case    2:*/		return 0x820D4E94;
		  /* 820D4E94h */ case    3:  		/* lwz R11, <#[R11 + 12]> */
		/* 820D4E94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820D4E94h case    3:*/		return 0x820D4E98;
		  /* 820D4E98h */ case    4:  		/* stw R10, <#[R1 + 116]> */
		/* 820D4E98h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820D4E98h case    4:*/		return 0x820D4E9C;
		  /* 820D4E9Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820D4E9Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D4E9Ch case    5:*/		return 0x820D4EA0;
		  /* 820D4EA0h */ case    6:  		/* addi R26, R11, 16 */
		/* 820D4EA0h case    6:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x10);
		/* 820D4EA0h case    6:*/		return 0x820D4EA4;
		  /* 820D4EA4h */ case    7:  		/* lwz R21, <#[R9 + 24]> */
		/* 820D4EA4h case    7:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R9 + 0x00000018) );
		/* 820D4EA4h case    7:*/		return 0x820D4EA8;
		  /* 820D4EA8h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 820D4EA8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820D4EB0;  }
		/* 820D4EA8h case    8:*/		return 0x820D4EAC;
		  /* 820D4EACh */ case    9:  		/* li R26, 0 */
		/* 820D4EACh case    9:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820D4EACh case    9:*/		return 0x820D4EB0;
	}
	return 0x820D4EB0;
} // Block from 820D4E88h-820D4EB0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D4EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4EB0);
		  /* 820D4EB0h */ case    0:  		/* li R25, 0 */
		/* 820D4EB0h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820D4EB0h case    0:*/		return 0x820D4EB4;
		  /* 820D4EB4h */ case    1:  		/* li R16, 0 */
		/* 820D4EB4h case    1:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 820D4EB4h case    1:*/		return 0x820D4EB8;
		  /* 820D4EB8h */ case    2:  		/* addi R30, R17, 16 */
		/* 820D4EB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R17,0x10);
		/* 820D4EB8h case    2:*/		return 0x820D4EBC;
		  /* 820D4EBCh */ case    3:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 820D4EBCh case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 820D4EBCh case    3:*/		return 0x820D4EC0;
		  /* 820D4EC0h */ case    4:  		/* bc 4, CR0_EQ, 916 */
		/* 820D4EC0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820D5254;  }
		/* 820D4EC0h case    4:*/		return 0x820D4EC4;
		  /* 820D4EC4h */ case    5:  		/* lwz R5, <#[R30 - 16]> */
		/* 820D4EC4h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0xFFFFFFF0) );
		/* 820D4EC4h case    5:*/		return 0x820D4EC8;
		  /* 820D4EC8h */ case    6:  		/* mr R11, R21 */
		/* 820D4EC8h case    6:*/		regs.R11 = regs.R21;
		/* 820D4EC8h case    6:*/		return 0x820D4ECC;
		  /* 820D4ECCh */ case    7:  		/* mr R10, R5 */
		/* 820D4ECCh case    7:*/		regs.R10 = regs.R5;
		/* 820D4ECCh case    7:*/		return 0x820D4ED0;
		  /* 820D4ED0h */ case    8:  		/* lbz R9, <#[R11]> */
		/* 820D4ED0h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820D4ED0h case    8:*/		return 0x820D4ED4;
		  /* 820D4ED4h */ case    9:  		/* lbz R8, <#[R10]> */
		/* 820D4ED4h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820D4ED4h case    9:*/		return 0x820D4ED8;
		  /* 820D4ED8h */ case   10:  		/* cmpwi CR0, R9, 0 */
		/* 820D4ED8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4ED8h case   10:*/		return 0x820D4EDC;
		  /* 820D4EDCh */ case   11:  		/* subf R9, R8, R9 */
		/* 820D4EDCh case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820D4EDCh case   11:*/		return 0x820D4EE0;
		  /* 820D4EE0h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 820D4EE0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820D4EF4;  }
		/* 820D4EE0h case   12:*/		return 0x820D4EE4;
		  /* 820D4EE4h */ case   13:  		/* addi R11, R11, 1 */
		/* 820D4EE4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D4EE4h case   13:*/		return 0x820D4EE8;
		  /* 820D4EE8h */ case   14:  		/* addi R10, R10, 1 */
		/* 820D4EE8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D4EE8h case   14:*/		return 0x820D4EEC;
		  /* 820D4EECh */ case   15:  		/* cmpwi CR6, R9, 0 */
		/* 820D4EECh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820D4EECh case   15:*/		return 0x820D4EF0;
		  /* 820D4EF0h */ case   16:  		/* bc 12, CR6_EQ, -32 */
		/* 820D4EF0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820D4ED0;  }
		/* 820D4EF0h case   16:*/		return 0x820D4EF4;
	}
	return 0x820D4EF4;
} // Block from 820D4EB0h-820D4EF4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820D4EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4EF4);
		  /* 820D4EF4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820D4EF4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820D4EF4h case    0:*/		return 0x820D4EF8;
		  /* 820D4EF8h */ case    1:  		/* bc 4, CR0_EQ, 844 */
		/* 820D4EF8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D5244;  }
		/* 820D4EF8h case    1:*/		return 0x820D4EFC;
		  /* 820D4EFCh */ case    2:  		/* lwz R10, <#[R29 + 76]> */
		/* 820D4EFCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000004C) );
		/* 820D4EFCh case    2:*/		return 0x820D4F00;
		  /* 820D4F00h */ case    3:  		/* li R25, 1 */
		/* 820D4F00h case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820D4F00h case    3:*/		return 0x820D4F04;
		  /* 820D4F04h */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 820D4F04h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820D4F04h case    4:*/		return 0x820D4F08;
		  /* 820D4F08h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820D4F08h case    5:*/		if ( regs.CR[6].eq ) { return 0x820D4F14;  }
		/* 820D4F08h case    5:*/		return 0x820D4F0C;
		  /* 820D4F0Ch */ case    6:  		/* lwz R11, <#[R30 - 12]> */
		/* 820D4F0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFFFFF4) );
		/* 820D4F0Ch case    6:*/		return 0x820D4F10;
		  /* 820D4F10h */ case    7:  		/* b 8 */
		/* 820D4F10h case    7:*/		return 0x820D4F18;
		/* 820D4F10h case    7:*/		return 0x820D4F14;
	}
	return 0x820D4F14;
} // Block from 820D4EF4h-820D4F14h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820D4F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4F14);
		  /* 820D4F14h */ case    0:  		/* lwz R11, <#[R30 - 8]> */
		/* 820D4F14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFFFFF8) );
		/* 820D4F14h case    0:*/		return 0x820D4F18;
	}
	return 0x820D4F18;
} // Block from 820D4F14h-820D4F18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D4F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4F18);
		  /* 820D4F18h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 820D4F18h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D4F18h case    0:*/		return 0x820D4F1C;
		  /* 820D4F1Ch */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 820D4F1Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D4F40;  }
		/* 820D4F1Ch case    1:*/		return 0x820D4F20;
		  /* 820D4F20h */ case    2:  		/* lwz R6, <#[R1 + 120]> */
		/* 820D4F20h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000078) );
		/* 820D4F20h case    2:*/		return 0x820D4F24;
		  /* 820D4F24h */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 820D4F24h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820D4F24h case    3:*/		return 0x820D4F28;
		  /* 820D4F28h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 820D4F28h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D4F30;  }
		/* 820D4F28h case    4:*/		return 0x820D4F2C;
		  /* 820D4F2Ch */ case    5:  		/* lwz R6, <#[R1 + 124]> */
		/* 820D4F2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000007C) );
		/* 820D4F2Ch case    5:*/		return 0x820D4F30;
	}
	return 0x820D4F30;
} // Block from 820D4F18h-820D4F30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D4F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4F30);
		  /* 820D4F30h */ case    0:  		/* mr R4, R22 */
		/* 820D4F30h case    0:*/		regs.R4 = regs.R22;
		/* 820D4F30h case    0:*/		return 0x820D4F34;
		  /* 820D4F34h */ case    1:  		/* mr R3, R29 */
		/* 820D4F34h case    1:*/		regs.R3 = regs.R29;
		/* 820D4F34h case    1:*/		return 0x820D4F38;
		  /* 820D4F38h */ case    2:  		/* bl -18000 */
		/* 820D4F38h case    2:*/		regs.LR = 0x820D4F3C; return 0x820D08E8;
		/* 820D4F38h case    2:*/		return 0x820D4F3C;
		  /* 820D4F3Ch */ case    3:  		/* mr R28, R27 */
		/* 820D4F3Ch case    3:*/		regs.R28 = regs.R27;
		/* 820D4F3Ch case    3:*/		return 0x820D4F40;
	}
	return 0x820D4F40;
} // Block from 820D4F30h-820D4F40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D4F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4F40);
		  /* 820D4F40h */ case    0:  		/* lbz R11, <#[R30 - 4]> */
		/* 820D4F40h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFFFFFC) );
		/* 820D4F40h case    0:*/		return 0x820D4F44;
		  /* 820D4F44h */ case    1:  		/* li R10, 1 */
		/* 820D4F44h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820D4F44h case    1:*/		return 0x820D4F48;
		  /* 820D4F48h */ case    2:  		/* lwz R9, <#[R29 + 304]> */
		/* 820D4F48h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000130) );
		/* 820D4F48h case    2:*/		return 0x820D4F4C;
		  /* 820D4F4Ch */ case    3:  		/* slw R31, R10, R11 */
		/* 820D4F4Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 820D4F4Ch case    3:*/		return 0x820D4F50;
		  /* 820D4F50h */ case    4:  		/* and. R11, R9, R31 */
		/* 820D4F50h case    4:*/		cpu::op::and<1>(regs,&regs.R11,regs.R9,regs.R31);
		/* 820D4F50h case    4:*/		return 0x820D4F54;
		  /* 820D4F54h */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 820D4F54h case    5:*/		if ( regs.CR[0].eq ) { return 0x820D4F6C;  }
		/* 820D4F54h case    5:*/		return 0x820D4F58;
		  /* 820D4F58h */ case    6:  		/* mr R4, R18 */
		/* 820D4F58h case    6:*/		regs.R4 = regs.R18;
		/* 820D4F58h case    6:*/		return 0x820D4F5C;
		  /* 820D4F5Ch */ case    7:  		/* lwz R5, <#[R30 - 16]> */
		/* 820D4F5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0xFFFFFFF0) );
		/* 820D4F5Ch case    7:*/		return 0x820D4F60;
		  /* 820D4F60h */ case    8:  		/* mr R3, R29 */
		/* 820D4F60h case    8:*/		regs.R3 = regs.R29;
		/* 820D4F60h case    8:*/		return 0x820D4F64;
		  /* 820D4F64h */ case    9:  		/* bl -18044 */
		/* 820D4F64h case    9:*/		regs.LR = 0x820D4F68; return 0x820D08E8;
		/* 820D4F64h case    9:*/		return 0x820D4F68;
		  /* 820D4F68h */ case   10:  		/* mr R28, R27 */
		/* 820D4F68h case   10:*/		regs.R28 = regs.R27;
		/* 820D4F68h case   10:*/		return 0x820D4F6C;
	}
	return 0x820D4F6C;
} // Block from 820D4F40h-820D4F6Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D4F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4F6C);
		  /* 820D4F6Ch */ case    0:  		/* lwz R11, <#[R29 + 304]> */
		/* 820D4F6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000130) );
		/* 820D4F6Ch case    0:*/		return 0x820D4F70;
		  /* 820D4F70h */ case    1:  		/* lwz R10, <#[R29 + 308]> */
		/* 820D4F70h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000134) );
		/* 820D4F70h case    1:*/		return 0x820D4F74;
		  /* 820D4F74h */ case    2:  		/* or R11, R11, R31 */
		/* 820D4F74h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820D4F74h case    2:*/		return 0x820D4F78;
		  /* 820D4F78h */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 820D4F78h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820D4F78h case    3:*/		return 0x820D4F7C;
		  /* 820D4F7Ch */ case    4:  		/* stw R11, <#[R29 + 304]> */
		/* 820D4F7Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000130) );
		/* 820D4F7Ch case    4:*/		return 0x820D4F80;
		  /* 820D4F80h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 820D4F80h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D4F94;  }
		/* 820D4F80h case    5:*/		return 0x820D4F84;
		  /* 820D4F84h */ case    6:  		/* mr R4, R14 */
		/* 820D4F84h case    6:*/		regs.R4 = regs.R14;
		/* 820D4F84h case    6:*/		return 0x820D4F88;
		  /* 820D4F88h */ case    7:  		/* mr R3, R29 */
		/* 820D4F88h case    7:*/		regs.R3 = regs.R29;
		/* 820D4F88h case    7:*/		return 0x820D4F8C;
		  /* 820D4F8Ch */ case    8:  		/* bl -18084 */
		/* 820D4F8Ch case    8:*/		regs.LR = 0x820D4F90; return 0x820D08E8;
		/* 820D4F8Ch case    8:*/		return 0x820D4F90;
		  /* 820D4F90h */ case    9:  		/* mr R28, R27 */
		/* 820D4F90h case    9:*/		regs.R28 = regs.R27;
		/* 820D4F90h case    9:*/		return 0x820D4F94;
	}
	return 0x820D4F94;
} // Block from 820D4F6Ch-820D4F94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D4F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4F94);
		  /* 820D4F94h */ case    0:  		/* li R31, 0 */
		/* 820D4F94h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820D4F94h case    0:*/		return 0x820D4F98;
		  /* 820D4F98h */ case    1:  		/* cmpwi CR6, R28, 0 */
		/* 820D4F98h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820D4F98h case    1:*/		return 0x820D4F9C;
		  /* 820D4F9Ch */ case    2:  		/* stw R31, <#[R1 + 112]> */
		/* 820D4F9Ch case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000070) );
		/* 820D4F9Ch case    2:*/		return 0x820D4FA0;
		  /* 820D4FA0h */ case    3:  		/* bc 12, CR6_LT, 676 */
		/* 820D4FA0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820D5244;  }
		/* 820D4FA0h case    3:*/		return 0x820D4FA4;
		  /* 820D4FA4h */ case    4:  		/* lbz R11, <#[R30 - 3]> */
		/* 820D4FA4h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFFFFFD) );
		/* 820D4FA4h case    4:*/		return 0x820D4FA8;
		  /* 820D4FA8h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 820D4FA8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D4FA8h case    5:*/		return 0x820D4FAC;
		  /* 820D4FACh */ case    6:  		/* bc 12, CR6_LT, 112 */
		/* 820D4FACh case    6:*/		if ( regs.CR[6].lt ) { return 0x820D501C;  }
		/* 820D4FACh case    6:*/		return 0x820D4FB0;
		  /* 820D4FB0h */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 820D4FB0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D4FF0;  }
		/* 820D4FB0h case    7:*/		return 0x820D4FB4;
		  /* 820D4FB4h */ case    8:  		/* cmplwi CR6, R11, 3 */
		/* 820D4FB4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820D4FB4h case    8:*/		return 0x820D4FB8;
		  /* 820D4FB8h */ case    9:  		/* bc 4, CR6_LT, 248 */
		/* 820D4FB8h case    9:*/		if ( !regs.CR[6].lt ) { return 0x820D50B0;  }
		/* 820D4FB8h case    9:*/		return 0x820D4FBC;
		  /* 820D4FBCh */ case   10:  		/* li R5, 0 */
		/* 820D4FBCh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820D4FBCh case   10:*/		return 0x820D4FC0;
		  /* 820D4FC0h */ case   11:  		/* lwz R6, <#[R30]> */
		/* 820D4FC0h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000000) );
		/* 820D4FC0h case   11:*/		return 0x820D4FC4;
		  /* 820D4FC4h */ case   12:  		/* addi R4, R1, 112 */
		/* 820D4FC4h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820D4FC4h case   12:*/		return 0x820D4FC8;
		  /* 820D4FC8h */ case   13:  		/* mr R3, R26 */
		/* 820D4FC8h case   13:*/		regs.R3 = regs.R26;
		/* 820D4FC8h case   13:*/		return 0x820D4FCC;
		  /* 820D4FCCh */ case   14:  		/* bl -23708 */
		/* 820D4FCCh case   14:*/		regs.LR = 0x820D4FD0; return 0x820CF330;
		/* 820D4FCCh case   14:*/		return 0x820D4FD0;
		  /* 820D4FD0h */ case   15:  		/* or. R28, R3, R3 */
		/* 820D4FD0h case   15:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820D4FD0h case   15:*/		return 0x820D4FD4;
		  /* 820D4FD4h */ case   16:  		/* bc 4, CR0_LT, 232 */
		/* 820D4FD4h case   16:*/		if ( !regs.CR[0].lt ) { return 0x820D50BC;  }
		/* 820D4FD4h case   16:*/		return 0x820D4FD8;
		  /* 820D4FD8h */ case   17:  		/* mr R4, R24 */
		/* 820D4FD8h case   17:*/		regs.R4 = regs.R24;
		/* 820D4FD8h case   17:*/		return 0x820D4FDC;
		  /* 820D4FDCh */ case   18:  		/* mr R3, R29 */
		/* 820D4FDCh case   18:*/		regs.R3 = regs.R29;
		/* 820D4FDCh case   18:*/		return 0x820D4FE0;
		  /* 820D4FE0h */ case   19:  		/* lwz R5, <#[R30 - 16]> */
		/* 820D4FE0h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0xFFFFFFF0) );
		/* 820D4FE0h case   19:*/		return 0x820D4FE4;
		  /* 820D4FE4h */ case   20:  		/* bl -18172 */
		/* 820D4FE4h case   20:*/		regs.LR = 0x820D4FE8; return 0x820D08E8;
		/* 820D4FE4h case   20:*/		return 0x820D4FE8;
		  /* 820D4FE8h */ case   21:  		/* mr R28, R27 */
		/* 820D4FE8h case   21:*/		regs.R28 = regs.R27;
		/* 820D4FE8h case   21:*/		return 0x820D4FEC;
		  /* 820D4FECh */ case   22:  		/* b 600 */
		/* 820D4FECh case   22:*/		return 0x820D5244;
		/* 820D4FECh case   22:*/		return 0x820D4FF0;
	}
	return 0x820D4FF0;
} // Block from 820D4F94h-820D4FF0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820D4FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D4FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D4FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D4FF0);
		  /* 820D4FF0h */ case    0:  		/* addi R4, R1, 112 */
		/* 820D4FF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820D4FF0h case    0:*/		return 0x820D4FF4;
		  /* 820D4FF4h */ case    1:  		/* mr R3, R26 */
		/* 820D4FF4h case    1:*/		regs.R3 = regs.R26;
		/* 820D4FF4h case    1:*/		return 0x820D4FF8;
		  /* 820D4FF8h */ case    2:  		/* bl -23520 */
		/* 820D4FF8h case    2:*/		regs.LR = 0x820D4FFC; return 0x820CF418;
		/* 820D4FF8h case    2:*/		return 0x820D4FFC;
		  /* 820D4FFCh */ case    3:  		/* or. R28, R3, R3 */
		/* 820D4FFCh case    3:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820D4FFCh case    3:*/		return 0x820D5000;
		  /* 820D5000h */ case    4:  		/* bc 4, CR0_LT, 188 */
		/* 820D5000h case    4:*/		if ( !regs.CR[0].lt ) { return 0x820D50BC;  }
		/* 820D5000h case    4:*/		return 0x820D5004;
		  /* 820D5004h */ case    5:  		/* mr R4, R15 */
		/* 820D5004h case    5:*/		regs.R4 = regs.R15;
		/* 820D5004h case    5:*/		return 0x820D5008;
		  /* 820D5008h */ case    6:  		/* lwz R5, <#[R30 - 16]> */
		/* 820D5008h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0xFFFFFFF0) );
		/* 820D5008h case    6:*/		return 0x820D500C;
		  /* 820D500Ch */ case    7:  		/* mr R3, R29 */
		/* 820D500Ch case    7:*/		regs.R3 = regs.R29;
		/* 820D500Ch case    7:*/		return 0x820D5010;
		  /* 820D5010h */ case    8:  		/* bl -18216 */
		/* 820D5010h case    8:*/		regs.LR = 0x820D5014; return 0x820D08E8;
		/* 820D5010h case    8:*/		return 0x820D5014;
		  /* 820D5014h */ case    9:  		/* lwz R31, <#[R1 + 112]> */
		/* 820D5014h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000070) );
		/* 820D5014h case    9:*/		return 0x820D5018;
		  /* 820D5018h */ case   10:  		/* b 152 */
		/* 820D5018h case   10:*/		return 0x820D50B0;
		/* 820D5018h case   10:*/		return 0x820D501C;
	}
	return 0x820D501C;
} // Block from 820D4FF0h-820D501Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D501Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D501C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D501C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D501C);
		  /* 820D501Ch */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820D501Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820D501Ch case    0:*/		return 0x820D5020;
		  /* 820D5020h */ case    1:  		/* bc 12, CR6_EQ, 124 */
		/* 820D5020h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D509C;  }
		/* 820D5020h case    1:*/		return 0x820D5024;
		  /* 820D5024h */ case    2:  		/* lwz R11, <#[R26]> */
		/* 820D5024h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820D5024h case    2:*/		return 0x820D5028;
		  /* 820D5028h */ case    3:  		/* cmpwi CR6, R11, 11 */
		/* 820D5028h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820D5028h case    3:*/		return 0x820D502C;
		  /* 820D502Ch */ case    4:  		/* bc 4, CR6_EQ, 112 */
		/* 820D502Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D509C;  }
		/* 820D502Ch case    4:*/		return 0x820D5030;
		  /* 820D5030h */ case    5:  		/* lwz R7, <#[R30]> */
		/* 820D5030h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 820D5030h case    5:*/		return 0x820D5034;
		  /* 820D5034h */ case    6:  		/* lwz R6, <#[R26 + 8]> */
		/* 820D5034h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000008) );
		/* 820D5034h case    6:*/		return 0x820D5038;
		  /* 820D5038h */ case    7:  		/* lwz R9, <#[R7]> */
		/* 820D5038h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 820D5038h case    7:*/		return 0x820D503C;
		  /* 820D503Ch */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 820D503Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D503Ch case    8:*/		return 0x820D5040;
		  /* 820D5040h */ case    9:  		/* bc 12, CR6_EQ, 76 */
		/* 820D5040h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D508C;  }
		/* 820D5040h case    9:*/		return 0x820D5044;
		  /* 820D5044h */ case   10:  		/* mr R10, R9 */
		/* 820D5044h case   10:*/		regs.R10 = regs.R9;
		/* 820D5044h case   10:*/		return 0x820D5048;
		  /* 820D5048h */ case   11:  		/* mr R11, R6 */
		/* 820D5048h case   11:*/		regs.R11 = regs.R6;
		/* 820D5048h case   11:*/		return 0x820D504C;
		  /* 820D504Ch */ case   12:  		/* lbz R8, <#[R11]> */
		/* 820D504Ch case   12:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820D504Ch case   12:*/		return 0x820D5050;
		  /* 820D5050h */ case   13:  		/* lbz R5, <#[R10]> */
		/* 820D5050h case   13:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 820D5050h case   13:*/		return 0x820D5054;
		  /* 820D5054h */ case   14:  		/* cmpwi CR0, R8, 0 */
		/* 820D5054h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820D5054h case   14:*/		return 0x820D5058;
		  /* 820D5058h */ case   15:  		/* subf R8, R5, R8 */
		/* 820D5058h case   15:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820D5058h case   15:*/		return 0x820D505C;
		  /* 820D505Ch */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 820D505Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x820D5070;  }
		/* 820D505Ch case   16:*/		return 0x820D5060;
		  /* 820D5060h */ case   17:  		/* addi R11, R11, 1 */
		/* 820D5060h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820D5060h case   17:*/		return 0x820D5064;
		  /* 820D5064h */ case   18:  		/* addi R10, R10, 1 */
		/* 820D5064h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820D5064h case   18:*/		return 0x820D5068;
		  /* 820D5068h */ case   19:  		/* cmpwi CR6, R8, 0 */
		/* 820D5068h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820D5068h case   19:*/		return 0x820D506C;
		  /* 820D506Ch */ case   20:  		/* bc 12, CR6_EQ, -32 */
		/* 820D506Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x820D504C;  }
		/* 820D506Ch case   20:*/		return 0x820D5070;
	}
	return 0x820D5070;
} // Block from 820D501Ch-820D5070h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820D5070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5070);
		  /* 820D5070h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820D5070h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820D5070h case    0:*/		return 0x820D5074;
		  /* 820D5074h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820D5074h case    1:*/		if ( regs.CR[0].eq ) { return 0x820D5084;  }
		/* 820D5074h case    1:*/		return 0x820D5078;
		  /* 820D5078h */ case    2:  		/* lwzu R9, <#[R7 + 8]> */
		/* 820D5078h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000008) );
		regs.R7 = (uint32)(regs.R7 + 0x00000008);
		/* 820D5078h case    2:*/		return 0x820D507C;
		  /* 820D507Ch */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 820D507Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D507Ch case    3:*/		return 0x820D5080;
		  /* 820D5080h */ case    4:  		/* bc 4, CR6_EQ, -60 */
		/* 820D5080h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820D5044;  }
		/* 820D5080h case    4:*/		return 0x820D5084;
	}
	return 0x820D5084;
} // Block from 820D5070h-820D5084h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D5084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5084);
		  /* 820D5084h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 820D5084h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820D5084h case    0:*/		return 0x820D5088;
		  /* 820D5088h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820D5088h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D5094;  }
		/* 820D5088h case    1:*/		return 0x820D508C;
	}
	return 0x820D508C;
} // Block from 820D5084h-820D508Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D508Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D508C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D508C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D508C);
		  /* 820D508Ch */ case    0:  		/* mr R4, R23 */
		/* 820D508Ch case    0:*/		regs.R4 = regs.R23;
		/* 820D508Ch case    0:*/		return 0x820D5090;
		  /* 820D5090h */ case    1:  		/* b -180 */
		/* 820D5090h case    1:*/		return 0x820D4FDC;
		/* 820D5090h case    1:*/		return 0x820D5094;
	}
	return 0x820D5094;
} // Block from 820D508Ch-820D5094h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D5094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5094);
		  /* 820D5094h */ case    0:  		/* lbz R31, <#[R7 + 4]> */
		/* 820D5094h case    0:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R7 + 0x00000004) );
		/* 820D5094h case    0:*/		return 0x820D5098;
		  /* 820D5098h */ case    1:  		/* b 24 */
		/* 820D5098h case    1:*/		return 0x820D50B0;
		/* 820D5098h case    1:*/		return 0x820D509C;
	}
	return 0x820D509C;
} // Block from 820D5094h-820D509Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D509Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D509C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D509C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D509C);
		  /* 820D509Ch */ case    0:  		/* mr R4, R19 */
		/* 820D509Ch case    0:*/		regs.R4 = regs.R19;
		/* 820D509Ch case    0:*/		return 0x820D50A0;
		  /* 820D50A0h */ case    1:  		/* lwz R5, <#[R30 - 16]> */
		/* 820D50A0h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0xFFFFFFF0) );
		/* 820D50A0h case    1:*/		return 0x820D50A4;
		  /* 820D50A4h */ case    2:  		/* mr R3, R29 */
		/* 820D50A4h case    2:*/		regs.R3 = regs.R29;
		/* 820D50A4h case    2:*/		return 0x820D50A8;
		  /* 820D50A8h */ case    3:  		/* bl -18368 */
		/* 820D50A8h case    3:*/		regs.LR = 0x820D50AC; return 0x820D08E8;
		/* 820D50A8h case    3:*/		return 0x820D50AC;
		  /* 820D50ACh */ case    4:  		/* mr R28, R27 */
		/* 820D50ACh case    4:*/		regs.R28 = regs.R27;
		/* 820D50ACh case    4:*/		return 0x820D50B0;
	}
	return 0x820D50B0;
} // Block from 820D509Ch-820D50B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D50B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D50B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D50B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D50B0);
		  /* 820D50B0h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820D50B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820D50B0h case    0:*/		return 0x820D50B4;
		  /* 820D50B4h */ case    1:  		/* bc 12, CR6_LT, 400 */
		/* 820D50B4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820D5244;  }
		/* 820D50B4h case    1:*/		return 0x820D50B8;
		  /* 820D50B8h */ case    2:  		/* b 8 */
		/* 820D50B8h case    2:*/		return 0x820D50C0;
		/* 820D50B8h case    2:*/		return 0x820D50BC;
	}
	return 0x820D50BC;
} // Block from 820D50B0h-820D50BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D50BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D50BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D50BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D50BC);
		  /* 820D50BCh */ case    0:  		/* lwz R31, <#[R1 + 112]> */
		/* 820D50BCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000070) );
		/* 820D50BCh case    0:*/		return 0x820D50C0;
	}
	return 0x820D50C0;
} // Block from 820D50BCh-820D50C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D50C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D50C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D50C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D50C0);
		  /* 820D50C0h */ case    0:  		/* lbz R11, <#[R30 - 4]> */
		/* 820D50C0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFFFFFC) );
		/* 820D50C0h case    0:*/		return 0x820D50C4;
		  /* 820D50C4h */ case    1:  		/* cmplwi CR6, R11, 21 */
		/* 820D50C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 820D50C4h case    1:*/		return 0x820D50C8;
		  /* 820D50C8h */ case    2:  		/* bc 12, CR6_GT, 380 */
		/* 820D50C8h case    2:*/		if ( regs.CR[6].gt ) { return 0x820D5244;  }
		/* 820D50C8h case    2:*/		return 0x820D50CC;
		  /* 820D50CCh */ case    3:  		/* lis R12, -32255 */
		/* 820D50CCh case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820D50CCh case    3:*/		return 0x820D50D0;
		  /* 820D50D0h */ case    4:  		/* addi R12, R12, 21888 */
		/* 820D50D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x5580);
		/* 820D50D0h case    4:*/		return 0x820D50D4;
		  /* 820D50D4h */ case    5:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820D50D4h case    5:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820D50D4h case    5:*/		return 0x820D50D8;
		  /* 820D50D8h */ case    6:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820D50D8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820D50D8h case    6:*/		return 0x820D50DC;
		  /* 820D50DCh */ case    7:  		/* lis R12, -32243 */
		/* 820D50DCh case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820D);
		/* 820D50DCh case    7:*/		return 0x820D50E0;
		  /* 820D50E0h */ case    8:  		/* ori R0, R0, 0 */
		/* 820D50E0h case    8:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820D50E0h case    8:*/		return 0x820D50E4;
		  /* 820D50E4h */ case    9:  		/* addi R12, R12, 20724 */
		/* 820D50E4h case    9:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x50F4);
		/* 820D50E4h case    9:*/		return 0x820D50E8;
		  /* 820D50E8h */ case   10:  		/* add R12, R12, R0 */
		/* 820D50E8h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820D50E8h case   10:*/		return 0x820D50EC;
		  /* 820D50ECh */ case   11:  		/* mtspr CTR, R12 */
		/* 820D50ECh case   11:*/		regs.CTR = regs.R12;
		/* 820D50ECh case   11:*/		return 0x820D50F0;
		  /* 820D50F0h */ case   12:  		/* bcctr 20, CR0_LT */
		/* 820D50F0h case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820D50F0h case   12:*/		return 0x820D50F4;
		  /* 820D50F4h */ case   13:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D50F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D50F4h case   13:*/		return 0x820D50F8;
		  /* 820D50F8h */ case   14:  		/* rlwimi R31, R11, 0, 0, 25 */
		/* 820D50F8h case   14:*/		cpu::op::rlwimi<0,0,0,25>(regs,&regs.R31,regs.R11);
		/* 820D50F8h case   14:*/		return 0x820D50FC;
		  /* 820D50FCh */ case   15:  		/* stw R31, <#[R29 + 296]> */
		/* 820D50FCh case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000128) );
		/* 820D50FCh case   15:*/		return 0x820D5100;
		  /* 820D5100h */ case   16:  		/* b 324 */
		/* 820D5100h case   16:*/		return 0x820D5244;
		/* 820D5100h case   16:*/		return 0x820D5104;
		  /* 820D5104h */ case   17:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5104h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5104h case   17:*/		return 0x820D5108;
		  /* 820D5108h */ case   18:  		/* rlwimi R11, R31, 8, 18, 23 */
		/* 820D5108h case   18:*/		cpu::op::rlwimi<0,8,18,23>(regs,&regs.R11,regs.R31);
		/* 820D5108h case   18:*/		return 0x820D510C;
		  /* 820D510Ch */ case   19:  		/* stw R11, <#[R29 + 296]> */
		/* 820D510Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D510Ch case   19:*/		return 0x820D5110;
		  /* 820D5110h */ case   20:  		/* b 308 */
		/* 820D5110h case   20:*/		return 0x820D5244;
		/* 820D5110h case   20:*/		return 0x820D5114;
		  /* 820D5114h */ case   21:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5114h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5114h case   21:*/		return 0x820D5118;
		  /* 820D5118h */ case   22:  		/* rlwimi R11, R31, 16, 15, 15 */
		/* 820D5118h case   22:*/		cpu::op::rlwimi<0,16,15,15>(regs,&regs.R11,regs.R31);
		/* 820D5118h case   22:*/		return 0x820D511C;
		  /* 820D511Ch */ case   23:  		/* b -16 */
		/* 820D511Ch case   23:*/		return 0x820D510C;
		/* 820D511Ch case   23:*/		return 0x820D5120;
		  /* 820D5120h */ case   24:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5120h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5120h case   24:*/		return 0x820D5124;
		  /* 820D5124h */ case   25:  		/* rlwimi R11, R31, 17, 14, 14 */
		/* 820D5124h case   25:*/		cpu::op::rlwimi<0,17,14,14>(regs,&regs.R11,regs.R31);
		/* 820D5124h case   25:*/		return 0x820D5128;
		  /* 820D5128h */ case   26:  		/* b -28 */
		/* 820D5128h case   26:*/		return 0x820D510C;
		/* 820D5128h case   26:*/		return 0x820D512C;
		  /* 820D512Ch */ case   27:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D512Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D512Ch case   27:*/		return 0x820D5130;
		  /* 820D5130h */ case   28:  		/* rlwimi R11, R31, 18, 13, 13 */
		/* 820D5130h case   28:*/		cpu::op::rlwimi<0,18,13,13>(regs,&regs.R11,regs.R31);
		/* 820D5130h case   28:*/		return 0x820D5134;
		  /* 820D5134h */ case   29:  		/* b -40 */
		/* 820D5134h case   29:*/		return 0x820D510C;
		/* 820D5134h case   29:*/		return 0x820D5138;
		  /* 820D5138h */ case   30:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5138h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5138h case   30:*/		return 0x820D513C;
		  /* 820D513Ch */ case   31:  		/* rlwimi R11, R31, 19, 12, 12 */
		/* 820D513Ch case   31:*/		cpu::op::rlwimi<0,19,12,12>(regs,&regs.R11,regs.R31);
		/* 820D513Ch case   31:*/		return 0x820D5140;
		  /* 820D5140h */ case   32:  		/* b -52 */
		/* 820D5140h case   32:*/		return 0x820D510C;
		/* 820D5140h case   32:*/		return 0x820D5144;
		  /* 820D5144h */ case   33:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5144h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5144h case   33:*/		return 0x820D5148;
		  /* 820D5148h */ case   34:  		/* rlwimi R11, R31, 20, 8, 11 */
		/* 820D5148h case   34:*/		cpu::op::rlwimi<0,20,8,11>(regs,&regs.R11,regs.R31);
		/* 820D5148h case   34:*/		return 0x820D514C;
		  /* 820D514Ch */ case   35:  		/* b -64 */
		/* 820D514Ch case   35:*/		return 0x820D510C;
		/* 820D514Ch case   35:*/		return 0x820D5150;
		  /* 820D5150h */ case   36:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5150h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5150h case   36:*/		return 0x820D5154;
		  /* 820D5154h */ case   37:  		/* rlwimi R11, R31, 24, 5, 7 */
		/* 820D5154h case   37:*/		cpu::op::rlwimi<0,24,5,7>(regs,&regs.R11,regs.R31);
		/* 820D5154h case   37:*/		return 0x820D5158;
		  /* 820D5158h */ case   38:  		/* b -76 */
		/* 820D5158h case   38:*/		return 0x820D510C;
		/* 820D5158h case   38:*/		return 0x820D515C;
		  /* 820D515Ch */ case   39:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D515Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D515Ch case   39:*/		return 0x820D5160;
		  /* 820D5160h */ case   40:  		/* rlwimi R11, R31, 27, 4, 4 */
		/* 820D5160h case   40:*/		cpu::op::rlwimi<0,27,4,4>(regs,&regs.R11,regs.R31);
		/* 820D5160h case   40:*/		return 0x820D5164;
		  /* 820D5164h */ case   41:  		/* b -88 */
		/* 820D5164h case   41:*/		return 0x820D510C;
		/* 820D5164h case   41:*/		return 0x820D5168;
		  /* 820D5168h */ case   42:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5168h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5168h case   42:*/		return 0x820D516C;
		  /* 820D516Ch */ case   43:  		/* rlwimi R11, R31, 28, 1, 3 */
		/* 820D516Ch case   43:*/		cpu::op::rlwimi<0,28,1,3>(regs,&regs.R11,regs.R31);
		/* 820D516Ch case   43:*/		return 0x820D5170;
		  /* 820D5170h */ case   44:  		/* b -100 */
		/* 820D5170h case   44:*/		return 0x820D510C;
		/* 820D5170h case   44:*/		return 0x820D5174;
		  /* 820D5174h */ case   45:  		/* lwz R11, <#[R29 + 296]> */
		/* 820D5174h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000128) );
		/* 820D5174h case   45:*/		return 0x820D5178;
		  /* 820D5178h */ case   46:  		/* rlwimi R11, R31, 31, 0, 0 */
		/* 820D5178h case   46:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R11,regs.R31);
		/* 820D5178h case   46:*/		return 0x820D517C;
		  /* 820D517Ch */ case   47:  		/* b -112 */
		/* 820D517Ch case   47:*/		return 0x820D510C;
		/* 820D517Ch case   47:*/		return 0x820D5180;
		  /* 820D5180h */ case   48:  		/* lwz R11, <#[R29 + 300]> */
		/* 820D5180h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000012C) );
		/* 820D5180h case   48:*/		return 0x820D5184;
		  /* 820D5184h */ case   49:  		/* rlwimi R11, R31, 0, 31, 31 */
		/* 820D5184h case   49:*/		cpu::op::rlwimi<0,0,31,31>(regs,&regs.R11,regs.R31);
		/* 820D5184h case   49:*/		return 0x820D5188;
		  /* 820D5188h */ case   50:  		/* stw R11, <#[R29 + 300]> */
		/* 820D5188h case   50:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000012C) );
		/* 820D5188h case   50:*/		return 0x820D518C;
		  /* 820D518Ch */ case   51:  		/* b 184 */
		/* 820D518Ch case   51:*/		return 0x820D5244;
		/* 820D518Ch case   51:*/		return 0x820D5190;
		  /* 820D5190h */ case   52:  		/* lwz R11, <#[R29 + 300]> */
		/* 820D5190h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000012C) );
		/* 820D5190h case   52:*/		return 0x820D5194;
		  /* 820D5194h */ case   53:  		/* rlwimi R11, R31, 1, 30, 30 */
		/* 820D5194h case   53:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R11,regs.R31);
		/* 820D5194h case   53:*/		return 0x820D5198;
		  /* 820D5198h */ case   54:  		/* b -16 */
		/* 820D5198h case   54:*/		return 0x820D5188;
		/* 820D5198h case   54:*/		return 0x820D519C;
		  /* 820D519Ch */ case   55:  		/* rlwinm R11, R31, 0, 24, 31 */
		/* 820D519Ch case   55:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R31);
		/* 820D519Ch case   55:*/		return 0x820D51A0;
		  /* 820D51A0h */ case   56:  		/* stb R11, <#[R29 + 302]> */
		/* 820D51A0h case   56:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x0000012E) );
		/* 820D51A0h case   56:*/		return 0x820D51A4;
		  /* 820D51A4h */ case   57:  		/* b 160 */
		/* 820D51A4h case   57:*/		return 0x820D5244;
		/* 820D51A4h case   57:*/		return 0x820D51A8;
		  /* 820D51A8h */ case   58:  		/* lwz R11, <#[R29 + 300]> */
		/* 820D51A8h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000012C) );
		/* 820D51A8h case   58:*/		return 0x820D51AC;
		  /* 820D51ACh */ case   59:  		/* rlwimi R11, R31, 16, 15, 15 */
		/* 820D51ACh case   59:*/		cpu::op::rlwimi<0,16,15,15>(regs,&regs.R11,regs.R31);
		/* 820D51ACh case   59:*/		return 0x820D51B0;
		  /* 820D51B0h */ case   60:  		/* b -40 */
		/* 820D51B0h case   60:*/		return 0x820D5188;
		/* 820D51B0h case   60:*/		return 0x820D51B4;
		  /* 820D51B4h */ case   61:  		/* lwz R11, <#[R29 + 300]> */
		/* 820D51B4h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000012C) );
		/* 820D51B4h case   61:*/		return 0x820D51B8;
	}
	return 0x820D51B8;
} // Block from 820D50C0h-820D51B8h (62 instructions)

//////////////////////////////////////////////////////
// Block at 820D51B8h
// Function '?DetectBias@CUAssembler@D3DXShader@@IAAHPAVCNodeUAsmRegister@2@PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D51B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D51B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D51B8);
		  /* 820D51B8h */ case    0:  		/* rlwimi R11, R31, 17, 14, 14 */
		/* 820D51B8h case    0:*/		cpu::op::rlwimi<0,17,14,14>(regs,&regs.R11,regs.R31);
		/* 820D51B8h case    0:*/		return 0x820D51BC;
		  /* 820D51BCh */ case    1:  		/* b -52 */
		/* 820D51BCh case    1:*/		return 0x820D5188;
		/* 820D51BCh case    1:*/		return 0x820D51C0;
		  /* 820D51C0h */ case    2:  		/* lwz R11, <#[R29 + 300]> */
		/* 820D51C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000012C) );
		/* 820D51C0h case    2:*/		return 0x820D51C4;
		  /* 820D51C4h */ case    3:  		/* rlwimi R11, R31, 18, 13, 13 */
		/* 820D51C4h case    3:*/		cpu::op::rlwimi<0,18,13,13>(regs,&regs.R11,regs.R31);
		/* 820D51C4h case    3:*/		return 0x820D51C8;
		  /* 820D51C8h */ case    4:  		/* b -64 */
		/* 820D51C8h case    4:*/		return 0x820D5188;
		/* 820D51C8h case    4:*/		return 0x820D51CC;
		  /* 820D51CCh */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 820D51CCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D51CCh case    5:*/		return 0x820D51D0;
		  /* 820D51D0h */ case    6:  		/* bc 12, CR6_EQ, 116 */
		/* 820D51D0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D5244;  }
		/* 820D51D0h case    6:*/		return 0x820D51D4;
		  /* 820D51D4h */ case    7:  		/* lwz R11, <#[R29 + 104]> */
		/* 820D51D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000068) );
		/* 820D51D4h case    7:*/		return 0x820D51D8;
		  /* 820D51D8h */ case    8:  		/* ori R11, R11, 8 */
		/* 820D51D8h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820D51D8h case    8:*/		return 0x820D51DC;
		  /* 820D51DCh */ case    9:  		/* b 100 */
		/* 820D51DCh case    9:*/		return 0x820D5240;
		/* 820D51DCh case    9:*/		return 0x820D51E0;
		  /* 820D51E0h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820D51E0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D51E0h case   10:*/		return 0x820D51E4;
		  /* 820D51E4h */ case   11:  		/* bc 4, CR6_EQ, 96 */
		/* 820D51E4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820D5244;  }
		/* 820D51E4h case   11:*/		return 0x820D51E8;
		  /* 820D51E8h */ case   12:  		/* lwz R11, <#[R29 + 104]> */
		/* 820D51E8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000068) );
		/* 820D51E8h case   12:*/		return 0x820D51EC;
		  /* 820D51ECh */ case   13:  		/* ori R11, R11, 32 */
		/* 820D51ECh case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 820D51ECh case   13:*/		return 0x820D51F0;
		  /* 820D51F0h */ case   14:  		/* b 80 */
		/* 820D51F0h case   14:*/		return 0x820D5240;
		/* 820D51F0h case   14:*/		return 0x820D51F4;
		  /* 820D51F4h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 820D51F4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D51F4h case   15:*/		return 0x820D51F8;
		  /* 820D51F8h */ case   16:  		/* bc 4, CR6_EQ, 76 */
		/* 820D51F8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820D5244;  }
		/* 820D51F8h case   16:*/		return 0x820D51FC;
		  /* 820D51FCh */ case   17:  		/* lwz R11, <#[R29 + 104]> */
		/* 820D51FCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000068) );
		/* 820D51FCh case   17:*/		return 0x820D5200;
		  /* 820D5200h */ case   18:  		/* ori R11, R11, 128 */
		/* 820D5200h case   18:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820D5200h case   18:*/		return 0x820D5204;
		  /* 820D5204h */ case   19:  		/* b 60 */
		/* 820D5204h case   19:*/		return 0x820D5240;
		/* 820D5204h case   19:*/		return 0x820D5208;
		  /* 820D5208h */ case   20:  		/* cmplwi CR6, R31, 0 */
		/* 820D5208h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D5208h case   20:*/		return 0x820D520C;
		  /* 820D520Ch */ case   21:  		/* bc 4, CR6_EQ, 56 */
		/* 820D520Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x820D5244;  }
		/* 820D520Ch case   21:*/		return 0x820D5210;
		  /* 820D5210h */ case   22:  		/* lwz R11, <#[R29 + 104]> */
		/* 820D5210h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000068) );
		/* 820D5210h case   22:*/		return 0x820D5214;
		  /* 820D5214h */ case   23:  		/* ori R11, R11, 16 */
		/* 820D5214h case   23:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820D5214h case   23:*/		return 0x820D5218;
		  /* 820D5218h */ case   24:  		/* b 40 */
		/* 820D5218h case   24:*/		return 0x820D5240;
		/* 820D5218h case   24:*/		return 0x820D521C;
		  /* 820D521Ch */ case   25:  		/* mr R4, R21 */
		/* 820D521Ch case   25:*/		regs.R4 = regs.R21;
		/* 820D521Ch case   25:*/		return 0x820D5220;
		  /* 820D5220h */ case   26:  		/* mr R3, R29 */
		/* 820D5220h case   26:*/		regs.R3 = regs.R29;
		/* 820D5220h case   26:*/		return 0x820D5224;
		  /* 820D5224h */ case   27:  		/* bl -4492 */
		/* 820D5224h case   27:*/		regs.LR = 0x820D5228; return 0x820D4098;
		/* 820D5224h case   27:*/		return 0x820D5228;
		  /* 820D5228h */ case   28:  		/* or. R28, R3, R3 */
		/* 820D5228h case   28:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820D5228h case   28:*/		return 0x820D522C;
		  /* 820D522Ch */ case   29:  		/* bc 12, CR0_LT, 24 */
		/* 820D522Ch case   29:*/		if ( regs.CR[0].lt ) { return 0x820D5244;  }
		/* 820D522Ch case   29:*/		return 0x820D5230;
		  /* 820D5230h */ case   30:  		/* cmplwi CR6, R31, 0 */
		/* 820D5230h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820D5230h case   30:*/		return 0x820D5234;
		  /* 820D5234h */ case   31:  		/* bc 12, CR6_EQ, 16 */
		/* 820D5234h case   31:*/		if ( regs.CR[6].eq ) { return 0x820D5244;  }
		/* 820D5234h case   31:*/		return 0x820D5238;
	}
	return 0x820D5238;
} // Block from 820D51B8h-820D5238h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820D5238h
// Function '?DoFetchSrcDest@CUAssembler@D3DXShader@@IAAXPATGPUTEXTURE_FETCH_INSTRUCTION@@PAVCNodeUAsmInstruction@2@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5238);
		  /* 820D5238h */ case    0:  		/* lwz R11, <#[R29 + 104]> */
		/* 820D5238h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000068) );
		/* 820D5238h case    0:*/		return 0x820D523C;
		  /* 820D523Ch */ case    1:  		/* ori R11, R11, 64 */
		/* 820D523Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 820D523Ch case    1:*/		return 0x820D5240;
	}
	return 0x820D5240;
} // Block from 820D5238h-820D5240h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D5240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5240);
		  /* 820D5240h */ case    0:  		/* stw R11, <#[R29 + 104]> */
		/* 820D5240h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000068) );
		/* 820D5240h case    0:*/		return 0x820D5244;
	}
	return 0x820D5244;
} // Block from 820D5240h-820D5244h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D5244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5244);
		  /* 820D5244h */ case    0:  		/* addi R16, R16, 1 */
		/* 820D5244h case    0:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 820D5244h case    0:*/		return 0x820D5248;
		  /* 820D5248h */ case    1:  		/* addi R30, R30, 20 */
		/* 820D5248h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x14);
		/* 820D5248h case    1:*/		return 0x820D524C;
		  /* 820D524Ch */ case    2:  		/* cmplwi CR6, R16, 14 */
		/* 820D524Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x0000000E);
		/* 820D524Ch case    2:*/		return 0x820D5250;
		  /* 820D5250h */ case    3:  		/* bc 12, CR6_LT, -916 */
		/* 820D5250h case    3:*/		if ( regs.CR[6].lt ) { return 0x820D4EBC;  }
		/* 820D5250h case    3:*/		return 0x820D5254;
	}
	return 0x820D5254;
} // Block from 820D5244h-820D5254h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D5254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5254);
		  /* 820D5254h */ case    0:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 820D5254h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 820D5254h case    0:*/		return 0x820D5258;
		  /* 820D5258h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 820D5258h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820D5270;  }
		/* 820D5258h case    1:*/		return 0x820D525C;
		  /* 820D525Ch */ case    2:  		/* mr R4, R20 */
		/* 820D525Ch case    2:*/		regs.R4 = regs.R20;
		/* 820D525Ch case    2:*/		return 0x820D5260;
		  /* 820D5260h */ case    3:  		/* mr R5, R21 */
		/* 820D5260h case    3:*/		regs.R5 = regs.R21;
		/* 820D5260h case    3:*/		return 0x820D5264;
		  /* 820D5264h */ case    4:  		/* mr R3, R29 */
		/* 820D5264h case    4:*/		regs.R3 = regs.R29;
		/* 820D5264h case    4:*/		return 0x820D5268;
		  /* 820D5268h */ case    5:  		/* bl -18816 */
		/* 820D5268h case    5:*/		regs.LR = 0x820D526C; return 0x820D08E8;
		/* 820D5268h case    5:*/		return 0x820D526C;
		  /* 820D526Ch */ case    6:  		/* mr R28, R27 */
		/* 820D526Ch case    6:*/		regs.R28 = regs.R27;
		/* 820D526Ch case    6:*/		return 0x820D5270;
	}
	return 0x820D5270;
} // Block from 820D5254h-820D5270h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820D5270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5270);
		  /* 820D5270h */ case    0:  		/* lwz R11, <#[R1 + 116]> */
		/* 820D5270h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820D5270h case    0:*/		return 0x820D5274;
		  /* 820D5274h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820D5274h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820D5274h case    1:*/		return 0x820D5278;
		  /* 820D5278h */ case    2:  		/* bc 4, CR6_EQ, -1012 */
		/* 820D5278h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820D4E84;  }
		/* 820D5278h case    2:*/		return 0x820D527C;
	}
	return 0x820D527C;
} // Block from 820D5270h-820D527Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D527Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D527C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D527C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D527C);
		  /* 820D527Ch */ case    0:  		/* mr R3, R28 */
		/* 820D527Ch case    0:*/		regs.R3 = regs.R28;
		/* 820D527Ch case    0:*/		return 0x820D5280;
		  /* 820D5280h */ case    1:  		/* addi R1, R1, 288 */
		/* 820D5280h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 820D5280h case    1:*/		return 0x820D5284;
		  /* 820D5284h */ case    2:  		/* b -278548 */
		/* 820D5284h case    2:*/		return 0x82091270;
		/* 820D5284h case    2:*/		return 0x820D5288;
	}
	return 0x820D5288;
} // Block from 820D527Ch-820D5288h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D5288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5288);
		  /* 820D5288h */ case    0:  		/* mfspr R12, LR */
		/* 820D5288h case    0:*/		regs.R12 = regs.LR;
		/* 820D5288h case    0:*/		return 0x820D528C;
		  /* 820D528Ch */ case    1:  		/* bl -278576 */
		/* 820D528Ch case    1:*/		regs.LR = 0x820D5290; return 0x8209125C;
		/* 820D528Ch case    1:*/		return 0x820D5290;
		  /* 820D5290h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820D5290h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820D5290h case    2:*/		return 0x820D5294;
		  /* 820D5294h */ case    3:  		/* lwz R11, <#[R3 + 92]> */
		/* 820D5294h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000005C) );
		/* 820D5294h case    3:*/		return 0x820D5298;
		  /* 820D5298h */ case    4:  		/* mr R31, R3 */
		/* 820D5298h case    4:*/		regs.R31 = regs.R3;
		/* 820D5298h case    4:*/		return 0x820D529C;
		  /* 820D529Ch */ case    5:  		/* mr R29, R4 */
		/* 820D529Ch case    5:*/		regs.R29 = regs.R4;
		/* 820D529Ch case    5:*/		return 0x820D52A0;
		  /* 820D52A0h */ case    6:  		/* li R30, 1 */
		/* 820D52A0h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820D52A0h case    6:*/		return 0x820D52A4;
		  /* 820D52A4h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820D52A4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D52A4h case    7:*/		return 0x820D52A8;
		  /* 820D52A8h */ case    8:  		/* bc 4, CR6_EQ, 24 */
		/* 820D52A8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820D52C0;  }
		/* 820D52A8h case    8:*/		return 0x820D52AC;
		  /* 820D52ACh */ case    9:  		/* stw R30, <#[R3 + 92]> */
		/* 820D52ACh case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000005C) );
		/* 820D52ACh case    9:*/		return 0x820D52B0;
		  /* 820D52B0h */ case   10:  		/* bl -2136 */
		/* 820D52B0h case   10:*/		regs.LR = 0x820D52B4; return 0x820D4A58;
		/* 820D52B0h case   10:*/		return 0x820D52B4;
		  /* 820D52B4h */ case   11:  		/* lwz R4, <#[R31 + 104]> */
		/* 820D52B4h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000068) );
		/* 820D52B4h case   11:*/		return 0x820D52B8;
		  /* 820D52B8h */ case   12:  		/* lwz R3, <#[R31 + 320]> */
		/* 820D52B8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000140) );
		/* 820D52B8h case   12:*/		return 0x820D52BC;
		  /* 820D52BCh */ case   13:  		/* bl -423604 */
		/* 820D52BCh case   13:*/		regs.LR = 0x820D52C0; return 0x8206DC08;
		/* 820D52BCh case   13:*/		return 0x820D52C0;
	}
	return 0x820D52C0;
} // Block from 820D5288h-820D52C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D52C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D52C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D52C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D52C0);
		  /* 820D52C0h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 820D52C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820D52C0h case    0:*/		return 0x820D52C4;
		  /* 820D52C4h */ case    1:  		/* bc 12, CR6_EQ, 108 */
		/* 820D52C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820D5330;  }
		/* 820D52C4h case    1:*/		return 0x820D52C8;
		  /* 820D52C8h */ case    2:  		/* lwz R11, <#[R31 + 96]> */
		/* 820D52C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820D52C8h case    2:*/		return 0x820D52CC;
		  /* 820D52CCh */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820D52CCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D52CCh case    3:*/		return 0x820D52D0;
		  /* 820D52D0h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 820D52D0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820D5308;  }
		/* 820D52D0h case    4:*/		return 0x820D52D4;
		  /* 820D52D4h */ case    5:  		/* cmpwi CR6, R11, 2 */
		/* 820D52D4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820D52D4h case    5:*/		return 0x820D52D8;
		  /* 820D52D8h */ case    6:  		/* bc 4, CR6_EQ, 88 */
		/* 820D52D8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820D5330;  }
		/* 820D52D8h case    6:*/		return 0x820D52DC;
		  /* 820D52DCh */ case    7:  		/* li R11, 3 */
		/* 820D52DCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820D52DCh case    7:*/		return 0x820D52E0;
		  /* 820D52E0h */ case    8:  		/* lwz R4, <#[R31 + 104]> */
		/* 820D52E0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000068) );
		/* 820D52E0h case    8:*/		return 0x820D52E4;
		  /* 820D52E4h */ case    9:  		/* lwz R3, <#[R31 + 320]> */
		/* 820D52E4h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000140) );
		/* 820D52E4h case    9:*/		return 0x820D52E8;
		  /* 820D52E8h */ case   10:  		/* stw R11, <#[R31 + 96]> */
		/* 820D52E8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820D52E8h case   10:*/		return 0x820D52EC;
		  /* 820D52ECh */ case   11:  		/* rlwimi R4, R30, 0, 29, 23 */
		/* 820D52ECh case   11:*/		cpu::op::rlwimi<0,0,29,23>(regs,&regs.R4,regs.R30);
		/* 820D52ECh case   11:*/		return 0x820D52F0;
		  /* 820D52F0h */ case   12:  		/* bl -447408 */
		/* 820D52F0h case   12:*/		regs.LR = 0x820D52F4; return 0x82067F40;
		/* 820D52F0h case   12:*/		return 0x820D52F4;
		  /* 820D52F4h */ case   13:  		/* lwz R3, <#[R31 + 324]> */
		/* 820D52F4h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000144) );
		/* 820D52F4h case   13:*/		return 0x820D52F8;
		  /* 820D52F8h */ case   14:  		/* cmplwi CR6, R3, 0 */
		/* 820D52F8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820D52F8h case   14:*/		return 0x820D52FC;
		  /* 820D52FCh */ case   15:  		/* bc 12, CR6_EQ, 52 */
		/* 820D52FCh case   15:*/		if ( regs.CR[6].eq ) { return 0x820D5330;  }
		/* 820D52FCh case   15:*/		return 0x820D5300;
		  /* 820D5300h */ case   16:  		/* li R4, 1 */
		/* 820D5300h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820D5300h case   16:*/		return 0x820D5304;
		  /* 820D5304h */ case   17:  		/* b 40 */
		/* 820D5304h case   17:*/		return 0x820D532C;
		/* 820D5304h case   17:*/		return 0x820D5308;
	}
	return 0x820D5308;
} // Block from 820D52C0h-820D5308h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820D5308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5308);
		  /* 820D5308h */ case    0:  		/* stw R30, <#[R31 + 96]> */
		/* 820D5308h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000060) );
		/* 820D5308h case    0:*/		return 0x820D530C;
		  /* 820D530Ch */ case    1:  		/* lwz R11, <#[R31 + 104]> */
		/* 820D530Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820D530Ch case    1:*/		return 0x820D5310;
		  /* 820D5310h */ case    2:  		/* lwz R3, <#[R31 + 320]> */
		/* 820D5310h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000140) );
		/* 820D5310h case    2:*/		return 0x820D5314;
		  /* 820D5314h */ case    3:  		/* rlwinm R4, R11, 0, 24, 28 */
		/* 820D5314h case    3:*/		cpu::op::rlwinm<0,0,24,28>(regs,&regs.R4,regs.R11);
		/* 820D5314h case    3:*/		return 0x820D5318;
		  /* 820D5318h */ case    4:  		/* bl -447448 */
		/* 820D5318h case    4:*/		regs.LR = 0x820D531C; return 0x82067F40;
		/* 820D5318h case    4:*/		return 0x820D531C;
		  /* 820D531Ch */ case    5:  		/* lwz R3, <#[R31 + 324]> */
		/* 820D531Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000144) );
		/* 820D531Ch case    5:*/		return 0x820D5320;
		  /* 820D5320h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820D5320h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820D5320h case    6:*/		return 0x820D5324;
		  /* 820D5324h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820D5324h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D5330;  }
		/* 820D5324h case    7:*/		return 0x820D5328;
		  /* 820D5328h */ case    8:  		/* li R4, 0 */
		/* 820D5328h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820D5328h case    8:*/		return 0x820D532C;
	}
	return 0x820D532C;
} // Block from 820D5308h-820D532Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D532Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D532C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D532C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D532C);
		  /* 820D532Ch */ case    0:  		/* bl 463468 */
		/* 820D532Ch case    0:*/		regs.LR = 0x820D5330; return 0x82146598;
		/* 820D532Ch case    0:*/		return 0x820D5330;
	}
	return 0x820D5330;
} // Block from 820D532Ch-820D5330h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D5330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5330);
		  /* 820D5330h */ case    0:  		/* lwz R3, <#[R31 + 320]> */
		/* 820D5330h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000140) );
		/* 820D5330h case    0:*/		return 0x820D5334;
		  /* 820D5334h */ case    1:  		/* addi R1, R1, 112 */
		/* 820D5334h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820D5334h case    1:*/		return 0x820D5338;
		  /* 820D5338h */ case    2:  		/* b -278668 */
		/* 820D5338h case    2:*/		return 0x820912AC;
		/* 820D5338h case    2:*/		return 0x820D533C;
		  /* 820D533Ch */ case    3:  		/* nop */
		/* 820D533Ch case    3:*/		cpu::op::nop();
		/* 820D533Ch case    3:*/		return 0x820D5340;
	}
	return 0x820D5340;
} // Block from 820D5330h-820D5340h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D5340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5340);
		  /* 820D5340h */ case    0:  		/* mfspr R12, LR */
		/* 820D5340h case    0:*/		regs.R12 = regs.LR;
		/* 820D5340h case    0:*/		return 0x820D5344;
		  /* 820D5344h */ case    1:  		/* bl -278788 */
		/* 820D5344h case    1:*/		regs.LR = 0x820D5348; return 0x82091240;
		/* 820D5344h case    1:*/		return 0x820D5348;
		  /* 820D5348h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820D5348h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820D5348h case    2:*/		return 0x820D534C;
		  /* 820D534Ch */ case    3:  		/* li R28, 0 */
		/* 820D534Ch case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820D534Ch case    3:*/		return 0x820D5350;
		  /* 820D5350h */ case    4:  		/* mr R31, R3 */
		/* 820D5350h case    4:*/		regs.R31 = regs.R3;
		/* 820D5350h case    4:*/		return 0x820D5354;
		  /* 820D5354h */ case    5:  		/* stw R28, <#[R3 + 308]> */
		/* 820D5354h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000134) );
		/* 820D5354h case    5:*/		return 0x820D5358;
		  /* 820D5358h */ case    6:  		/* mr R30, R4 */
		/* 820D5358h case    6:*/		regs.R30 = regs.R4;
		/* 820D5358h case    6:*/		return 0x820D535C;
		  /* 820D535Ch */ case    7:  		/* lwz R11, <#[R4 + 60]> */
		/* 820D535Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000003C) );
		/* 820D535Ch case    7:*/		return 0x820D5360;
		  /* 820D5360h */ case    8:  		/* cmplwi CR6, R11, 245 */
		/* 820D5360h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F5);
		/* 820D5360h case    8:*/		return 0x820D5364;
		  /* 820D5364h */ case    9:  		/* bc 12, CR6_EQ, 1472 */
		/* 820D5364h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D5924;  }
		/* 820D5364h case    9:*/		return 0x820D5368;
		  /* 820D5368h */ case   10:  		/* cmplwi CR6, R11, 246 */
		/* 820D5368h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F6);
		/* 820D5368h case   10:*/		return 0x820D536C;
		  /* 820D536Ch */ case   11:  		/* bc 12, CR6_EQ, 1080 */
		/* 820D536Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820D57A4;  }
		/* 820D536Ch case   11:*/		return 0x820D5370;
		  /* 820D5370h */ case   12:  		/* cmplwi CR6, R11, 247 */
		/* 820D5370h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F7);
		/* 820D5370h case   12:*/		return 0x820D5374;
		  /* 820D5374h */ case   13:  		/* bc 12, CR6_EQ, 888 */
		/* 820D5374h case   13:*/		if ( regs.CR[6].eq ) { return 0x820D56EC;  }
		/* 820D5374h case   13:*/		return 0x820D5378;
		  /* 820D5378h */ case   14:  		/* cmplwi CR6, R11, 248 */
		/* 820D5378h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F8);
		/* 820D5378h case   14:*/		return 0x820D537C;
		  /* 820D537Ch */ case   15:  		/* bc 4, CR6_EQ, 1728 */
		/* 820D537Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x820D5A3C;  }
		/* 820D537Ch case   15:*/		return 0x820D5380;
		  /* 820D5380h */ case   16:  		/* lwz R11, <#[R4 + 88]> */
		/* 820D5380h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000058) );
		/* 820D5380h case   16:*/		return 0x820D5384;
		  /* 820D5384h */ case   17:  		/* cmpwi CR6, R11, 0 */
		/* 820D5384h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D5384h case   17:*/		return 0x820D5388;
		  /* 820D5388h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 820D5388h case   18:*/		if ( regs.CR[6].eq ) { return 0x820D5398;  }
		/* 820D5388h case   18:*/		return 0x820D538C;
		  /* 820D538Ch */ case   19:  		/* lis R11, -32255 */
		/* 820D538Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D538Ch case   19:*/		return 0x820D5390;
		  /* 820D5390h */ case   20:  		/* addi R4, R11, 30332 */
		/* 820D5390h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x767C);
		/* 820D5390h case   20:*/		return 0x820D5394;
		  /* 820D5394h */ case   21:  		/* bl -19116 */
		/* 820D5394h case   21:*/		regs.LR = 0x820D5398; return 0x820D08E8;
		/* 820D5394h case   21:*/		return 0x820D5398;
	}
	return 0x820D5398;
} // Block from 820D5340h-820D5398h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820D5398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5398);
		  /* 820D5398h */ case    0:  		/* lwz R27, <#[R30 + 92]> */
		/* 820D5398h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x0000005C) );
		/* 820D5398h case    0:*/		return 0x820D539C;
		  /* 820D539Ch */ case    1:  		/* lwz R11, <#[R30 + 76]> */
		/* 820D539Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 820D539Ch case    1:*/		return 0x820D53A0;
		  /* 820D53A0h */ case    2:  		/* lwz R10, <#[R30 + 84]> */
		/* 820D53A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000054) );
		/* 820D53A0h case    2:*/		return 0x820D53A4;
		  /* 820D53A4h */ case    3:  		/* rlwinm. R9, R11, 0, 8, 8 */
		/* 820D53A4h case    3:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R9,regs.R11);
		/* 820D53A4h case    3:*/		return 0x820D53A8;
		  /* 820D53A8h */ case    4:  		/* lwz R8, <#[R27 + 16]> */
		/* 820D53A8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000010) );
		/* 820D53A8h case    4:*/		return 0x820D53AC;
		  /* 820D53ACh */ case    5:  		/* rlwinm R24, R11, 10, 31, 31 */
		/* 820D53ACh case    5:*/		cpu::op::rlwinm<0,10,31,31>(regs,&regs.R24,regs.R11);
		/* 820D53ACh case    5:*/		return 0x820D53B0;
		  /* 820D53B0h */ case    6:  		/* rlwinm R23, R10, 0, 28, 31 */
		/* 820D53B0h case    6:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R23,regs.R10);
		/* 820D53B0h case    6:*/		return 0x820D53B4;
		  /* 820D53B4h */ case    7:  		/* cntlzw R11, R8 */
		/* 820D53B4h case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R8);
		/* 820D53B4h case    7:*/		return 0x820D53B8;
		  /* 820D53B8h */ case    8:  		/* rlwinm R29, R10, 16, 28, 31 */
		/* 820D53B8h case    8:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R29,regs.R10);
		/* 820D53B8h case    8:*/		return 0x820D53BC;
		  /* 820D53BCh */ case    9:  		/* rlwinm R22, R11, 27, 31, 31 */
		/* 820D53BCh case    9:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R22,regs.R11);
		/* 820D53BCh case    9:*/		return 0x820D53C0;
		  /* 820D53C0h */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 820D53C0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820D53C8;  }
		/* 820D53C0h case   10:*/		return 0x820D53C4;
		  /* 820D53C4h */ case   11:  		/* li R24, 2 */
		/* 820D53C4h case   11:*/		cpu::op::li<0>(regs,&regs.R24,0x2);
		/* 820D53C4h case   11:*/		return 0x820D53C8;
	}
	return 0x820D53C8;
} // Block from 820D5398h-820D53C8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D53C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D53C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D53C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D53C8);
		  /* 820D53C8h */ case    0:  		/* lis R11, -32255 */
		/* 820D53C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D53C8h case    0:*/		return 0x820D53CC;
		  /* 820D53CCh */ case    1:  		/* lwz R26, <#[R27 + 32]> */
		/* 820D53CCh case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R27 + 0x00000020) );
		/* 820D53CCh case    1:*/		return 0x820D53D0;
		  /* 820D53D0h */ case    2:  		/* mr R30, R28 */
		/* 820D53D0h case    2:*/		regs.R30 = regs.R28;
		/* 820D53D0h case    2:*/		return 0x820D53D4;
		  /* 820D53D4h */ case    3:  		/* addi R25, R11, 30312 */
		/* 820D53D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x7668);
		/* 820D53D4h case    3:*/		return 0x820D53D8;
		  /* 820D53D8h */ case    4:  		/* srw R11, R26, R30 */
		/* 820D53D8h case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R26,regs.R30);
		/* 820D53D8h case    4:*/		return 0x820D53DC;
		  /* 820D53DCh */ case    5:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 820D53DCh case    5:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 820D53DCh case    5:*/		return 0x820D53E0;
		  /* 820D53E0h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 820D53E0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820D53E0h case    6:*/		return 0x820D53E4;
		  /* 820D53E4h */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 820D53E4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820D5440;  }
		/* 820D53E4h case    7:*/		return 0x820D53E8;
		  /* 820D53E8h */ case    8:  		/* cmplwi CR6, R11, 2 */
		/* 820D53E8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820D53E8h case    8:*/		return 0x820D53EC;
		  /* 820D53ECh */ case    9:  		/* bc 12, CR6_EQ, 76 */
		/* 820D53ECh case    9:*/		if ( regs.CR[6].eq ) { return 0x820D5438;  }
		/* 820D53ECh case    9:*/		return 0x820D53F0;
		  /* 820D53F0h */ case   10:  		/* cmplwi CR6, R11, 3 */
		/* 820D53F0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820D53F0h case   10:*/		return 0x820D53F4;
		  /* 820D53F4h */ case   11:  		/* bc 12, CR6_EQ, 60 */
		/* 820D53F4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820D5430;  }
		/* 820D53F4h case   11:*/		return 0x820D53F8;
		  /* 820D53F8h */ case   12:  		/* cmplwi CR6, R11, 4 */
		/* 820D53F8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820D53F8h case   12:*/		return 0x820D53FC;
		  /* 820D53FCh */ case   13:  		/* bc 12, CR6_EQ, 44 */
		/* 820D53FCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820D5428;  }
		/* 820D53FCh case   13:*/		return 0x820D5400;
		  /* 820D5400h */ case   14:  		/* cmplwi CR6, R11, 5 */
		/* 820D5400h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 820D5400h case   14:*/		return 0x820D5404;
		  /* 820D5404h */ case   15:  		/* bc 12, CR6_EQ, 144 */
		/* 820D5404h case   15:*/		if ( regs.CR[6].eq ) { return 0x820D5494;  }
		/* 820D5404h case   15:*/		return 0x820D5408;
		  /* 820D5408h */ case   16:  		/* cmplwi CR6, R11, 6 */
		/* 820D5408h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 820D5408h case   16:*/		return 0x820D540C;
		  /* 820D540Ch */ case   17:  		/* bc 12, CR6_EQ, 124 */
		/* 820D540Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820D5488;  }
		/* 820D540Ch case   17:*/		return 0x820D5410;
		  /* 820D5410h */ case   18:  		/* cmplwi CR6, R11, 7 */
		/* 820D5410h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 820D5410h case   18:*/		return 0x820D5414;
		  /* 820D5414h */ case   19:  		/* bc 4, CR6_EQ, 48 */
		/* 820D5414h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820D5444;  }
		/* 820D5414h case   19:*/		return 0x820D5418;
		  /* 820D5418h */ case   20:  		/* mr R4, R25 */
		/* 820D5418h case   20:*/		regs.R4 = regs.R25;
		/* 820D5418h case   20:*/		return 0x820D541C;
		  /* 820D541Ch */ case   21:  		/* mr R3, R31 */
		/* 820D541Ch case   21:*/		regs.R3 = regs.R31;
		/* 820D541Ch case   21:*/		return 0x820D5420;
		  /* 820D5420h */ case   22:  		/* bl -19256 */
		/* 820D5420h case   22:*/		regs.LR = 0x820D5424; return 0x820D08E8;
		/* 820D5420h case   22:*/		return 0x820D5424;
		  /* 820D5424h */ case   23:  		/* b 32 */
		/* 820D5424h case   23:*/		return 0x820D5444;
		/* 820D5424h case   23:*/		return 0x820D5428;
	}
	return 0x820D5428;
} // Block from 820D53C8h-820D5428h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820D5428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5428);
		  /* 820D5428h */ case    0:  		/* ori R28, R28, 8 */
		/* 820D5428h case    0:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R28,0x8);
		/* 820D5428h case    0:*/		return 0x820D542C;
		  /* 820D542Ch */ case    1:  		/* b 24 */
		/* 820D542Ch case    1:*/		return 0x820D5444;
		/* 820D542Ch case    1:*/		return 0x820D5430;
	}
	return 0x820D5430;
} // Block from 820D5428h-820D5430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D5430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5430);
		  /* 820D5430h */ case    0:  		/* ori R28, R28, 4 */
		/* 820D5430h case    0:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820D5430h case    0:*/		return 0x820D5434;
		  /* 820D5434h */ case    1:  		/* b 16 */
		/* 820D5434h case    1:*/		return 0x820D5444;
		/* 820D5434h case    1:*/		return 0x820D5438;
	}
	return 0x820D5438;
} // Block from 820D5430h-820D5438h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D5438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5438);
		  /* 820D5438h */ case    0:  		/* ori R28, R28, 2 */
		/* 820D5438h case    0:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R28,0x2);
		/* 820D5438h case    0:*/		return 0x820D543C;
		  /* 820D543Ch */ case    1:  		/* b 8 */
		/* 820D543Ch case    1:*/		return 0x820D5444;
		/* 820D543Ch case    1:*/		return 0x820D5440;
	}
	return 0x820D5440;
} // Block from 820D5438h-820D5440h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D5440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5440);
		  /* 820D5440h */ case    0:  		/* ori R28, R28, 1 */
		/* 820D5440h case    0:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820D5440h case    0:*/		return 0x820D5444;
	}
	return 0x820D5444;
} // Block from 820D5440h-820D5444h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D5444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5444);
		  /* 820D5444h */ case    0:  		/* addi R30, R30, 3 */
		/* 820D5444h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x3);
		/* 820D5444h case    0:*/		return 0x820D5448;
		  /* 820D5448h */ case    1:  		/* cmpwi CR6, R30, 12 */
		/* 820D5448h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000000C);
		/* 820D5448h case    1:*/		return 0x820D544C;
		  /* 820D544Ch */ case    2:  		/* bc 12, CR6_LT, -116 */
		/* 820D544Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x820D53D8;  }
		/* 820D544Ch case    2:*/		return 0x820D5450;
		  /* 820D5450h */ case    3:  		/* lwz R11, <#[R31 + 72]> */
		/* 820D5450h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820D5450h case    3:*/		return 0x820D5454;
		  /* 820D5454h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820D5454h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D5454h case    4:*/		return 0x820D5458;
		  /* 820D5458h */ case    5:  		/* bc 4, CR6_EQ, 340 */
		/* 820D5458h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820D55AC;  }
		/* 820D5458h case    5:*/		return 0x820D545C;
		  /* 820D545Ch */ case    6:  		/* rlwinm. R11, R22, 0, 24, 31 */
		/* 820D545Ch case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R22);
		/* 820D545Ch case    6:*/		return 0x820D5460;
		  /* 820D5460h */ case    7:  		/* bc 12, CR0_EQ, 332 */
		/* 820D5460h case    7:*/		if ( regs.CR[0].eq ) { return 0x820D55AC;  }
		/* 820D5460h case    7:*/		return 0x820D5464;
		  /* 820D5464h */ case    8:  		/* cmplwi CR6, R23, 9 */
		/* 820D5464h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000009);
		/* 820D5464h case    8:*/		return 0x820D5468;
		  /* 820D5468h */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 820D5468h case    9:*/		if ( regs.CR[6].eq ) { return 0x820D54B0;  }
		/* 820D5468h case    9:*/		return 0x820D546C;
		  /* 820D546Ch */ case   10:  		/* cmplwi CR6, R23, 13 */
		/* 820D546Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x0000000D);
		/* 820D546Ch case   10:*/		return 0x820D5470;
		  /* 820D5470h */ case   11:  		/* bc 4, CR6_GT, 12 */
		/* 820D5470h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820D547C;  }
		/* 820D5470h case   11:*/		return 0x820D5474;
		  /* 820D5474h */ case   12:  		/* cmplwi CR6, R23, 15 */
		/* 820D5474h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x0000000F);
		/* 820D5474h case   12:*/		return 0x820D5478;
		  /* 820D5478h */ case   13:  		/* bc 4, CR6_GT, 56 */
		/* 820D5478h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820D54B0;  }
		/* 820D5478h case   13:*/		return 0x820D547C;
	}
	return 0x820D547C;
} // Block from 820D5444h-820D547Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820D547Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D547C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D547C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D547C);
		  /* 820D547Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D547Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D547Ch case    0:*/		return 0x820D5480;
		  /* 820D5480h */ case    1:  		/* addi R4, R11, 30208 */
		/* 820D5480h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x7600);
		/* 820D5480h case    1:*/		return 0x820D5484;
		  /* 820D5484h */ case    2:  		/* b 24 */
		/* 820D5484h case    2:*/		return 0x820D549C;
		/* 820D5484h case    2:*/		return 0x820D5488;
	}
	return 0x820D5488;
} // Block from 820D547Ch-820D5488h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D5488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5488);
		  /* 820D5488h */ case    0:  		/* lis R11, -32255 */
		/* 820D5488h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5488h case    0:*/		return 0x820D548C;
		  /* 820D548Ch */ case    1:  		/* addi R4, R11, 30188 */
		/* 820D548Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x75EC);
		/* 820D548Ch case    1:*/		return 0x820D5490;
		  /* 820D5490h */ case    2:  		/* b 12 */
		/* 820D5490h case    2:*/		return 0x820D549C;
		/* 820D5490h case    2:*/		return 0x820D5494;
	}
	return 0x820D5494;
} // Block from 820D5488h-820D5494h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820D5494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5494);
		  /* 820D5494h */ case    0:  		/* lis R11, -32255 */
		/* 820D5494h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5494h case    0:*/		return 0x820D5498;
	}
	return 0x820D5498;
} // Block from 820D5494h-820D5498h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D5498h
// Function '?CheckDeclarations@CUAssembler@D3DXShader@@IAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5498);
		  /* 820D5498h */ case    0:  		/* addi R4, R11, 30168 */
		/* 820D5498h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x75D8);
		/* 820D5498h case    0:*/		return 0x820D549C;
	}
	return 0x820D549C;
} // Block from 820D5498h-820D549Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D549Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D549C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D549C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D549C);
		  /* 820D549Ch */ case    0:  		/* mr R3, R31 */
		/* 820D549Ch case    0:*/		regs.R3 = regs.R31;
		/* 820D549Ch case    0:*/		return 0x820D54A0;
		  /* 820D54A0h */ case    1:  		/* bl -19384 */
		/* 820D54A0h case    1:*/		regs.LR = 0x820D54A4; return 0x820D08E8;
		/* 820D54A0h case    1:*/		return 0x820D54A4;
		  /* 820D54A4h */ case    2:  		/* lis R3, -32768 */
		/* 820D54A4h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820D54A4h case    2:*/		return 0x820D54A8;
		  /* 820D54A8h */ case    3:  		/* ori R3, R3, 16389 */
		/* 820D54A8h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820D54A8h case    3:*/		return 0x820D54AC;
		  /* 820D54ACh */ case    4:  		/* b 1428 */
		/* 820D54ACh case    4:*/		return 0x820D5A40;
		/* 820D54ACh case    4:*/		return 0x820D54B0;
	}
	return 0x820D54B0;
} // Block from 820D549Ch-820D54B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D54B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D54B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D54B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D54B0);
		  /* 820D54B0h */ case    0:  		/* rlwinm R11, R23, 4, 0, 27 */
		/* 820D54B0h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R23);
		/* 820D54B0h case    0:*/		return 0x820D54B4;
		  /* 820D54B4h */ case    1:  		/* li R9, 1 */
		/* 820D54B4h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820D54B4h case    1:*/		return 0x820D54B8;
		  /* 820D54B8h */ case    2:  		/* add R11, R11, R29 */
		/* 820D54B8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820D54B8h case    2:*/		return 0x820D54BC;
		  /* 820D54BCh */ case    3:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 820D54BCh case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 820D54BCh case    3:*/		return 0x820D54C0;
		  /* 820D54C0h */ case    4:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 820D54C0h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 820D54C0h case    4:*/		return 0x820D54C4;
		  /* 820D54C4h */ case    5:  		/* addi R8, R10, 47 */
		/* 820D54C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x2F);
		/* 820D54C4h case    5:*/		return 0x820D54C8;
		  /* 820D54C8h */ case    6:  		/* slw R9, R9, R11 */
		/* 820D54C8h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820D54C8h case    6:*/		return 0x820D54CC;
		  /* 820D54CCh */ case    7:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820D54CCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820D54CCh case    7:*/		return 0x820D54D0;
		  /* 820D54D0h */ case    8:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820D54D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820D54D0h case    8:*/		return 0x820D54D4;
		  /* 820D54D4h */ case    9:  		/* and. R11, R11, R9 */
		/* 820D54D4h case    9:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820D54D4h case    9:*/		return 0x820D54D8;
		  /* 820D54D8h */ case   10:  		/* bc 12, CR0_EQ, 76 */
		/* 820D54D8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820D5524;  }
		/* 820D54D8h case   10:*/		return 0x820D54DC;
		  /* 820D54DCh */ case   11:  		/* cmplwi CR6, R23, 9 */
		/* 820D54DCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000009);
		/* 820D54DCh case   11:*/		return 0x820D54E0;
		  /* 820D54E0h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 820D54E0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820D54F0;  }
		/* 820D54E0h case   12:*/		return 0x820D54E4;
		  /* 820D54E4h */ case   13:  		/* lis R11, -32255 */
		/* 820D54E4h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D54E4h case   13:*/		return 0x820D54E8;
		  /* 820D54E8h */ case   14:  		/* addi R5, R11, 23480 */
		/* 820D54E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5BB8);
		/* 820D54E8h case   14:*/		return 0x820D54EC;
		  /* 820D54ECh */ case   15:  		/* b 32 */
		/* 820D54ECh case   15:*/		return 0x820D550C;
		/* 820D54ECh case   15:*/		return 0x820D54F0;
	}
	return 0x820D54F0;
} // Block from 820D54B0h-820D54F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D54F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D54F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D54F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D54F0);
		  /* 820D54F0h */ case    0:  		/* cmplwi CR6, R23, 14 */
		/* 820D54F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x0000000E);
		/* 820D54F0h case    0:*/		return 0x820D54F4;
		  /* 820D54F4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D54F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D5504;  }
		/* 820D54F4h case    1:*/		return 0x820D54F8;
		  /* 820D54F8h */ case    2:  		/* lis R11, -32255 */
		/* 820D54F8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D54F8h case    2:*/		return 0x820D54FC;
		  /* 820D54FCh */ case    3:  		/* addi R5, R11, 23488 */
		/* 820D54FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5BC0);
		/* 820D54FCh case    3:*/		return 0x820D5500;
		  /* 820D5500h */ case    4:  		/* b 12 */
		/* 820D5500h case    4:*/		return 0x820D550C;
		/* 820D5500h case    4:*/		return 0x820D5504;
	}
	return 0x820D5504;
} // Block from 820D54F0h-820D5504h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D5504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5504);
		  /* 820D5504h */ case    0:  		/* lis R11, -32255 */
		/* 820D5504h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5504h case    0:*/		return 0x820D5508;
		  /* 820D5508h */ case    1:  		/* addi R5, R11, 23500 */
		/* 820D5508h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x5BCC);
		/* 820D5508h case    1:*/		return 0x820D550C;
	}
	return 0x820D550C;
} // Block from 820D5504h-820D550Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D550Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D550C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D550C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D550C);
		  /* 820D550Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D550Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D550Ch case    0:*/		return 0x820D5510;
		  /* 820D5510h */ case    1:  		/* mr R6, R29 */
		/* 820D5510h case    1:*/		regs.R6 = regs.R29;
		/* 820D5510h case    1:*/		return 0x820D5514;
		  /* 820D5514h */ case    2:  		/* addi R4, R11, 30128 */
		/* 820D5514h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x75B0);
		/* 820D5514h case    2:*/		return 0x820D5518;
		  /* 820D5518h */ case    3:  		/* mr R3, R31 */
		/* 820D5518h case    3:*/		regs.R3 = regs.R31;
		/* 820D5518h case    3:*/		return 0x820D551C;
		  /* 820D551Ch */ case    4:  		/* bl -19508 */
		/* 820D551Ch case    4:*/		regs.LR = 0x820D5520; return 0x820D08E8;
		/* 820D551Ch case    4:*/		return 0x820D5520;
		  /* 820D5520h */ case    5:  		/* b -124 */
		/* 820D5520h case    5:*/		return 0x820D54A4;
		/* 820D5520h case    5:*/		return 0x820D5524;
	}
	return 0x820D5524;
} // Block from 820D550Ch-820D5524h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820D5524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5524);
		  /* 820D5524h */ case    0:  		/* addi R11, R31, 188 */
		/* 820D5524h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xBC);
		/* 820D5524h case    0:*/		return 0x820D5528;
		  /* 820D5528h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820D5528h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820D5528h case    1:*/		return 0x820D552C;
		  /* 820D552Ch */ case    2:  		/* lwzx R8, <#[R10 + R11]> */
		/* 820D552Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820D552Ch case    2:*/		return 0x820D5530;
		  /* 820D5530h */ case    3:  		/* or R9, R9, R8 */
		/* 820D5530h case    3:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820D5530h case    3:*/		return 0x820D5534;
		  /* 820D5534h */ case    4:  		/* stwx R9, <#[R10 + R11]> */
		/* 820D5534h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820D5534h case    4:*/		return 0x820D5538;
		  /* 820D5538h */ case    5:  		/* lwz R30, <#[R27 + 24]> */
		/* 820D5538h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000018) );
		/* 820D5538h case    5:*/		return 0x820D553C;
		  /* 820D553Ch */ case    6:  		/* cmplwi CR6, R30, 2 */
		/* 820D553Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000002);
		/* 820D553Ch case    6:*/		return 0x820D5540;
		  /* 820D5540h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 820D5540h case    7:*/		if ( regs.CR[6].lt ) { return 0x820D5550;  }
		/* 820D5540h case    7:*/		return 0x820D5544;
		  /* 820D5544h */ case    8:  		/* lis R11, -32255 */
		/* 820D5544h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5544h case    8:*/		return 0x820D5548;
		  /* 820D5548h */ case    9:  		/* addi R4, R11, 30056 */
		/* 820D5548h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x7568);
		/* 820D5548h case    9:*/		return 0x820D554C;
		  /* 820D554Ch */ case   10:  		/* b -176 */
		/* 820D554Ch case   10:*/		return 0x820D549C;
		/* 820D554Ch case   10:*/		return 0x820D5550;
	}
	return 0x820D5550;
} // Block from 820D5524h-820D5550h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820D5550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5550);
		  /* 820D5550h */ case    0:  		/* add R11, R30, R31 */
		/* 820D5550h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 820D5550h case    0:*/		return 0x820D5554;
		  /* 820D5554h */ case    1:  		/* mr R3, R31 */
		/* 820D5554h case    1:*/		regs.R3 = regs.R31;
		/* 820D5554h case    1:*/		return 0x820D5558;
		  /* 820D5558h */ case    2:  		/* lbz R10, <#[R11 + 220]> */
		/* 820D5558h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000DC) );
		/* 820D5558h case    2:*/		return 0x820D555C;
		  /* 820D555Ch */ case    3:  		/* and. R9, R10, R28 */
		/* 820D555Ch case    3:*/		cpu::op::and<1>(regs,&regs.R9,regs.R10,regs.R28);
		/* 820D555Ch case    3:*/		return 0x820D5560;
		  /* 820D5560h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 820D5560h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D5584;  }
		/* 820D5560h case    4:*/		return 0x820D5564;
		  /* 820D5564h */ case    5:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 820D5564h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 820D5564h case    5:*/		return 0x820D5568;
		  /* 820D5568h */ case    6:  		/* lis R9, -32255 */
		/* 820D5568h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820D5568h case    6:*/		return 0x820D556C;
		  /* 820D556Ch */ case    7:  		/* addi R4, R9, 29984 */
		/* 820D556Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x7520);
		/* 820D556Ch case    7:*/		return 0x820D5570;
		  /* 820D5570h */ case    8:  		/* lis R11, -32217 */
		/* 820D5570h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 820D5570h case    8:*/		return 0x820D5574;
		  /* 820D5574h */ case    9:  		/* mr R5, R30 */
		/* 820D5574h case    9:*/		regs.R5 = regs.R30;
		/* 820D5574h case    9:*/		return 0x820D5578;
		  /* 820D5578h */ case   10:  		/* addi R11, R11, 11472 */
		/* 820D5578h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2CD0);
		/* 820D5578h case   10:*/		return 0x820D557C;
		  /* 820D557Ch */ case   11:  		/* lwzx R6, <#[R10 + R11]> */
		/* 820D557Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820D557Ch case   11:*/		return 0x820D5580;
	}
	return 0x820D5580;
} // Block from 820D5550h-820D5580h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D5580h
// Function '?Token@CUAssembler@D3DXShader@@IAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5580);
		  /* 820D5580h */ case    0:  		/* b -100 */
		/* 820D5580h case    0:*/		return 0x820D551C;
		/* 820D5580h case    0:*/		return 0x820D5584;
	}
	return 0x820D5584;
} // Block from 820D5580h-820D5584h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820D5584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5584);
		  /* 820D5584h */ case    0:  		/* or R10, R10, R28 */
		/* 820D5584h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 820D5584h case    0:*/		return 0x820D5588;
		  /* 820D5588h */ case    1:  		/* li R4, 1 */
		/* 820D5588h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820D5588h case    1:*/		return 0x820D558C;
		  /* 820D558Ch */ case    2:  		/* stb R10, <#[R11 + 220]> */
		/* 820D558Ch case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x000000DC) );
		/* 820D558Ch case    2:*/		return 0x820D5590;
		  /* 820D5590h */ case    3:  		/* bl -776 */
		/* 820D5590h case    3:*/		regs.LR = 0x820D5594; return 0x820D5288;
		/* 820D5590h case    3:*/		return 0x820D5594;
		  /* 820D5594h */ case    4:  		/* rlwimi R29, R23, 4, 24, 27 */
		/* 820D5594h case    4:*/		cpu::op::rlwimi<0,4,24,27>(regs,&regs.R29,regs.R23);
		/* 820D5594h case    4:*/		return 0x820D5598;
		  /* 820D5598h */ case    5:  		/* mr R5, R28 */
		/* 820D5598h case    5:*/		regs.R5 = regs.R28;
		/* 820D5598h case    5:*/		return 0x820D559C;
		  /* 820D559Ch */ case    6:  		/* mr R4, R30 */
		/* 820D559Ch case    6:*/		regs.R4 = regs.R30;
		/* 820D559Ch case    6:*/		return 0x820D55A0;
		  /* 820D55A0h */ case    7:  		/* rlwinm R6, R29, 0, 24, 31 */
		/* 820D55A0h case    7:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R6,regs.R29);
		/* 820D55A0h case    7:*/		return 0x820D55A4;
		  /* 820D55A4h */ case    8:  		/* bl -426036 */
		/* 820D55A4h case    8:*/		regs.LR = 0x820D55A8; return 0x8206D570;
		/* 820D55A4h case    8:*/		return 0x820D55A8;
		  /* 820D55A8h */ case    9:  		/* b 1172 */
		/* 820D55A8h case    9:*/		return 0x820D5A3C;
		/* 820D55A8h case    9:*/		return 0x820D55AC;
	}
	return 0x820D55AC;
} // Block from 820D5584h-820D55ACh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820D55ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D55AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D55AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D55AC);
		  /* 820D55ACh */ case    0:  		/* mr R11, R23 */
		/* 820D55ACh case    0:*/		regs.R11 = regs.R23;
		/* 820D55ACh case    0:*/		return 0x820D55B0;
		  /* 820D55B0h */ case    1:  		/* li R9, 1 */
		/* 820D55B0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820D55B0h case    1:*/		return 0x820D55B4;
		  /* 820D55B4h */ case    2:  		/* rlwimi R11, R24, 4, 26, 27 */
		/* 820D55B4h case    2:*/		cpu::op::rlwimi<0,4,26,27>(regs,&regs.R11,regs.R24);
		/* 820D55B4h case    2:*/		return 0x820D55B8;
		  /* 820D55B8h */ case    3:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 820D55B8h case    3:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 820D55B8h case    3:*/		return 0x820D55BC;
		  /* 820D55BCh */ case    4:  		/* rlwimi R29, R11, 4, 0, 27 */
		/* 820D55BCh case    4:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R29,regs.R11);
		/* 820D55BCh case    4:*/		return 0x820D55C0;
		  /* 820D55C0h */ case    5:  		/* rlwinm R10, R29, 27, 29, 31 */
		/* 820D55C0h case    5:*/		cpu::op::rlwinm<0,27,29,31>(regs,&regs.R10,regs.R29);
		/* 820D55C0h case    5:*/		return 0x820D55C4;
		  /* 820D55C4h */ case    6:  		/* rlwinm R11, R29, 0, 27, 31 */
		/* 820D55C4h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R29);
		/* 820D55C4h case    6:*/		return 0x820D55C8;
		  /* 820D55C8h */ case    7:  		/* addi R8, R10, 35 */
		/* 820D55C8h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x23);
		/* 820D55C8h case    7:*/		return 0x820D55CC;
		  /* 820D55CCh */ case    8:  		/* slw R9, R9, R11 */
		/* 820D55CCh case    8:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820D55CCh case    8:*/		return 0x820D55D0;
		  /* 820D55D0h */ case    9:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820D55D0h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820D55D0h case    9:*/		return 0x820D55D4;
		  /* 820D55D4h */ case   10:  		/* lwzx R11, <#[R11 + R31]> */
		/* 820D55D4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820D55D4h case   10:*/		return 0x820D55D8;
		  /* 820D55D8h */ case   11:  		/* and. R11, R11, R9 */
		/* 820D55D8h case   11:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820D55D8h case   11:*/		return 0x820D55DC;
		  /* 820D55DCh */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820D55DCh case   12:*/		if ( regs.CR[0].eq ) { return 0x820D55EC;  }
		/* 820D55DCh case   12:*/		return 0x820D55E0;
		  /* 820D55E0h */ case   13:  		/* lis R11, -32255 */
		/* 820D55E0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D55E0h case   13:*/		return 0x820D55E4;
		  /* 820D55E4h */ case   14:  		/* addi R4, R11, 29920 */
		/* 820D55E4h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x74E0);
		/* 820D55E4h case   14:*/		return 0x820D55E8;
		  /* 820D55E8h */ case   15:  		/* b -332 */
		/* 820D55E8h case   15:*/		return 0x820D549C;
		/* 820D55E8h case   15:*/		return 0x820D55EC;
	}
	return 0x820D55EC;
} // Block from 820D55ACh-820D55ECh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820D55ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D55EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D55EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D55EC);
		  /* 820D55ECh */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820D55ECh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820D55ECh case    0:*/		return 0x820D55F0;
		  /* 820D55F0h */ case    1:  		/* addi R11, R31, 140 */
		/* 820D55F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x8C);
		/* 820D55F0h case    1:*/		return 0x820D55F4;
		  /* 820D55F4h */ case    2:  		/* lwzx R8, <#[R10 + R11]> */
		/* 820D55F4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820D55F4h case    2:*/		return 0x820D55F8;
		  /* 820D55F8h */ case    3:  		/* or R9, R9, R8 */
		/* 820D55F8h case    3:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820D55F8h case    3:*/		return 0x820D55FC;
		  /* 820D55FCh */ case    4:  		/* stwx R9, <#[R10 + R11]> */
		/* 820D55FCh case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820D55FCh case    4:*/		return 0x820D5600;
		  /* 820D5600h */ case    5:  		/* lwz R30, <#[R27 + 24]> */
		/* 820D5600h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000018) );
		/* 820D5600h case    5:*/		return 0x820D5604;
		  /* 820D5604h */ case    6:  		/* lwz R11, <#[R31 + 76]> */
		/* 820D5604h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820D5604h case    6:*/		return 0x820D5608;
		  /* 820D5608h */ case    7:  		/* subfic R10, R11, 0 */
		/* 820D5608h case    7:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R11,0x0);
		/* 820D5608h case    7:*/		return 0x820D560C;
		  /* 820D560Ch */ case    8:  		/* subfe R10, R10, R10 */
		/* 820D560Ch case    8:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820D560Ch case    8:*/		return 0x820D5610;
		  /* 820D5610h */ case    9:  		/* cmplwi CR6, R30, 15 */
		/* 820D5610h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000F);
		/* 820D5610h case    9:*/		return 0x820D5614;
		  /* 820D5614h */ case   10:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 820D5614h case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 820D5614h case   10:*/		return 0x820D5618;
		  /* 820D5618h */ case   11:  		/* addi R10, R10, 111 */
		/* 820D5618h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6F);
		/* 820D5618h case   11:*/		return 0x820D561C;
		  /* 820D561Ch */ case   12:  		/* bc 4, CR6_GT, 24 */
		/* 820D561Ch case   12:*/		if ( !regs.CR[6].gt ) { return 0x820D5634;  }
		/* 820D561Ch case   12:*/		return 0x820D5620;
		  /* 820D5620h */ case   13:  		/* extsb R5, R10 */
		/* 820D5620h case   13:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R10);
		/* 820D5620h case   13:*/		return 0x820D5624;
		  /* 820D5624h */ case   14:  		/* lis R11, -32255 */
		/* 820D5624h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5624h case   14:*/		return 0x820D5628;
		  /* 820D5628h */ case   15:  		/* mr R6, R5 */
		/* 820D5628h case   15:*/		regs.R6 = regs.R5;
		/* 820D5628h case   15:*/		return 0x820D562C;
		  /* 820D562Ch */ case   16:  		/* addi R4, R11, 29876 */
		/* 820D562Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x74B4);
		/* 820D562Ch case   16:*/		return 0x820D5630;
		  /* 820D5630h */ case   17:  		/* b -280 */
		/* 820D5630h case   17:*/		return 0x820D5518;
		/* 820D5630h case   17:*/		return 0x820D5634;
	}
	return 0x820D5634;
} // Block from 820D55ECh-820D5634h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820D5634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5634);
		  /* 820D5634h */ case    0:  		/* cmplwi CR6, R23, 9 */
		/* 820D5634h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000009);
		/* 820D5634h case    0:*/		return 0x820D5638;
		  /* 820D5638h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D5638h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D5648;  }
		/* 820D5638h case    1:*/		return 0x820D563C;
		  /* 820D563Ch */ case    2:  		/* lis R11, -32255 */
		/* 820D563Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D563Ch case    2:*/		return 0x820D5640;
		  /* 820D5640h */ case    3:  		/* addi R4, R11, 29800 */
		/* 820D5640h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x7468);
		/* 820D5640h case    3:*/		return 0x820D5644;
		  /* 820D5644h */ case    4:  		/* b -424 */
		/* 820D5644h case    4:*/		return 0x820D549C;
		/* 820D5644h case    4:*/		return 0x820D5648;
	}
	return 0x820D5648;
} // Block from 820D5634h-820D5648h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D5648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5648);
		  /* 820D5648h */ case    0:  		/* cmplwi CR6, R23, 14 */
		/* 820D5648h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x0000000E);
		/* 820D5648h case    0:*/		return 0x820D564C;
		  /* 820D564Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820D564Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820D565C;  }
		/* 820D564Ch case    1:*/		return 0x820D5650;
		  /* 820D5650h */ case    2:  		/* lis R11, -32255 */
		/* 820D5650h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5650h case    2:*/		return 0x820D5654;
		  /* 820D5654h */ case    3:  		/* addi R4, R11, 29712 */
		/* 820D5654h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x7410);
		/* 820D5654h case    3:*/		return 0x820D5658;
		  /* 820D5658h */ case    4:  		/* b -444 */
		/* 820D5658h case    4:*/		return 0x820D549C;
		/* 820D5658h case    4:*/		return 0x820D565C;
	}
	return 0x820D565C;
} // Block from 820D5648h-820D565Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820D565Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D565C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D565C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D565C);
		  /* 820D565Ch */ case    0:  		/* addic R9, R11, -1 */
		/* 820D565Ch case    0:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 820D565Ch case    0:*/		return 0x820D5660;
		  /* 820D5660h */ case    1:  		/* lwz R8, <#[R27 + 16]> */
		/* 820D5660h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000010) );
		/* 820D5660h case    1:*/		return 0x820D5664;
		  /* 820D5664h */ case    2:  		/* li R7, 6 */
		/* 820D5664h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x6);
		/* 820D5664h case    2:*/		return 0x820D5668;
		  /* 820D5668h */ case    3:  		/* subfe R9, R9, R9 */
		/* 820D5668h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 820D5668h case    3:*/		return 0x820D566C;
		  /* 820D566Ch */ case    4:  		/* and R9, R9, R7 */
		/* 820D566Ch case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820D566Ch case    4:*/		return 0x820D5670;
		  /* 820D5670h */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 820D5670h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820D5670h case    5:*/		return 0x820D5674;
		  /* 820D5674h */ case    6:  		/* bc 12, CR6_EQ, 48 */
		/* 820D5674h case    6:*/		if ( regs.CR[6].eq ) { return 0x820D56A4;  }
		/* 820D5674h case    6:*/		return 0x820D5678;
		  /* 820D5678h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820D5678h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820D5678h case    7:*/		return 0x820D567C;
		  /* 820D567Ch */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 820D567Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820D568C;  }
		/* 820D567Ch case    8:*/		return 0x820D5680;
		  /* 820D5680h */ case    9:  		/* lis R11, -32255 */
		/* 820D5680h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5680h case    9:*/		return 0x820D5684;
		  /* 820D5684h */ case   10:  		/* addi R5, R11, 26488 */
		/* 820D5684h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6778);
		/* 820D5684h case   10:*/		return 0x820D5688;
		  /* 820D5688h */ case   11:  		/* b 12 */
		/* 820D5688h case   11:*/		return 0x820D5694;
		/* 820D5688h case   11:*/		return 0x820D568C;
	}
	return 0x820D568C;
} // Block from 820D565Ch-820D568Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820D568Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D568C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D568C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D568C);
		  /* 820D568Ch */ case    0:  		/* lis R11, -32255 */
		/* 820D568Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D568Ch case    0:*/		return 0x820D5690;
		  /* 820D5690h */ case    1:  		/* addi R5, R11, 26496 */
		/* 820D5690h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6780);
		/* 820D5690h case    1:*/		return 0x820D5694;
	}
	return 0x820D5694;
} // Block from 820D568Ch-820D5694h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820D5694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D5694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D5694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D5694);
		  /* 820D5694h */ case    0:  		/* lis R11, -32255 */
		/* 820D5694h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820D5694h case    0:*/		return 0x820D5698;
		  /* 820D5698h */ case    1:  		/* extsb R6, R10 */
		/* 820D5698h case    1:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R10);
		/* 820D5698h case    1:*/		return 0x820D569C;
		  /* 820D569Ch */ case    2:  		/* addi R4, R11, 29656 */
		/* 820D569Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x73D8);
		/* 820D569Ch case    2:*/		return 0x820D56A0;
		  /* 820D56A0h */ case    3:  		/* b -392 */
		/* 820D56A0h case    3:*/		return 0x820D5518;
		/* 820D56A0h case    3:*/		return 0x820D56A4;
	}
	return 0x820D56A4;
} // Block from 820D5694h-820D56A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820D56A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D56A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D56A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D56A4);
		  /* 820D56A4h */ case    0:  		/* add R11, R30, R31 */
		/* 820D56A4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 820D56A4h case    0:*/		return 0x820D56A8;
		  /* 820D56A8h */ case    1:  		/* mr R3, R31 */
		/* 820D56A8h case    1:*/		regs.R3 = regs.R31;
		/* 820D56A8h case    1:*/		return 0x820D56AC;
		  /* 820D56ACh */ case    2:  		/* lbz R10, <#[R11 + 172]> */
		/* 820D56ACh case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000AC) );
		/* 820D56ACh case    2:*/		return 0x820D56B0;
		  /* 820D56B0h */ case    3:  		/* and. R9, R10, R28 */
		/* 820D56B0h case    3:*/		cpu::op::and<1>(regs,&regs.R9,regs.R10,regs.R28);
		/* 820D56B0h case    3:*/		return 0x820D56B4;
		  /* 820D56B4h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 820D56B4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820D56C8;  }
		/* 820D56B4h case    4:*/		return 0x820D56B8;
		  /* 820D56B8h */ case    5:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 820D56B8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 820D56B8h case    5:*/		return 0x820D56BC;
		  /* 820D56BCh */ case    6:  		/* lis R9, -32255 */
		/* 820D56BCh case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820D56BCh case    6:*/		return 0x820D56C0;
		  /* 820D56C0h */ case    7:  		/* addi R4, R9, 29592 */
		/* 820D56C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x7398);
		/* 820D56C0h case    7:*/		return 0x820D56C4;
		  /* 820D56C4h */ case    8:  		/* b -340 */
		/* 820D56C4h case    8:*/		return 0x820D5570;
		/* 820D56C4h case    8:*/		return 0x820D56C8;
	}
	return 0x820D56C8;
} // Block from 820D56A4h-820D56C8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820D56C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820D56C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820D56C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820D56C8);
		  /* 820D56C8h */ case    0:  		/* or R10, R10, R28 */
		/* 820D56C8h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 820D56C8h case    0:*/		return 0x820D56CC;
		  /* 820D56CCh */ case    1:  		/* li R4, 1 */
		/* 820D56CCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820D56CCh case    1:*/		return 0x820D56D0;
		  /* 820D56D0h */ case    2:  		/* stb R10, <#[R11 + 172]> */
		/* 820D56D0h case    2:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x000000AC) );
		/* 820D56D0h case    2:*/		return 0x820D56D4;
		  /* 820D56D4h */ case    3:  		/* bl -1100 */
		/* 820D56D4h case    3:*/		regs.LR = 0x820D56D8; return 0x820D5288;
		/* 820D56D4h case    3:*/		return 0x820D56D8;
		  /* 820D56D8h */ case    4:  		/* mr R6, R29 */
		/* 820D56D8h case    4:*/		regs.R6 = regs.R29;
		/* 820D56D8h case    4:*/		return 0x820D56DC;
		  /* 820D56DCh */ case    5:  		/* mr R5, R28 */
		/* 820D56DCh case    5:*/		regs.R5 = regs.R28;
		/* 820D56DCh case    5:*/		return 0x820D56E0;
		  /* 820D56E0h */ case    6:  		/* mr R4, R30 */
		/* 820D56E0h case    6:*/		regs.R4 = regs.R30;
		/* 820D56E0h case    6:*/		return 0x820D56E4;
		  /* 820D56E4h */ case    7:  		/* bl -426380 */
		/* 820D56E4h case    7:*/		regs.LR = 0x820D56E8; return 0x8206D558;
		/* 820D56E4h case    7:*/		return 0x820D56E8;
		  /* 820D56E8h */ case    8:  		/* b 852 */
		/* 820D56E8h case    8:*/		return 0x820D5A3C;
		/* 820D56E8h case    8:*/		return 0x820D56EC;
	}
	return 0x820D56EC;
} // Block from 820D56C8h-820D56ECh (9 instructions)

