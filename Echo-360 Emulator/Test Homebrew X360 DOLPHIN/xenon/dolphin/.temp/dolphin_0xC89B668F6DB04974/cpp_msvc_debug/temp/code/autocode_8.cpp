#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 820AABD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AABD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AABD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AABD4);
		  /* 820AABD4h */ case    0:  		/* addi R11, R25, -1 */
		/* 820AABD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFFF);
		/* 820AABD4h case    0:*/		return 0x820AABD8;
		  /* 820AABD8h */ case    1:  		/* rlwinm R11, R11, 24, 0, 7 */
		/* 820AABD8h case    1:*/		cpu::op::rlwinm<0,24,0,7>(regs,&regs.R11,regs.R11);
		/* 820AABD8h case    1:*/		return 0x820AABDC;
		  /* 820AABDCh */ case    2:  		/* or R30, R11, R30 */
		/* 820AABDCh case    2:*/		cpu::op::or<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820AABDCh case    2:*/		return 0x820AABE0;
	}
	return 0x820AABE0;
} // Block from 820AABD4h-820AABE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AABE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AABE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AABE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AABE0);
		  /* 820AABE0h */ case    0:  		/* lwz R11, <#[R26 + 56]> */
		/* 820AABE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000038) );
		/* 820AABE0h case    0:*/		return 0x820AABE4;
		  /* 820AABE4h */ case    1:  		/* cmplwi CR6, R11, 41 */
		/* 820AABE4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000029);
		/* 820AABE4h case    1:*/		return 0x820AABE8;
		  /* 820AABE8h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820AABE8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AABFC;  }
		/* 820AABE8h case    2:*/		return 0x820AABEC;
		  /* 820AABECh */ case    3:  		/* cmplwi CR6, R11, 45 */
		/* 820AABECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 820AABECh case    3:*/		return 0x820AABF0;
		  /* 820AABF0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 820AABF0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820AABFC;  }
		/* 820AABF0h case    4:*/		return 0x820AABF4;
		  /* 820AABF4h */ case    5:  		/* cmplwi CR6, R11, 94 */
		/* 820AABF4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005E);
		/* 820AABF4h case    5:*/		return 0x820AABF8;
		  /* 820AABF8h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820AABF8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820AAC08;  }
		/* 820AABF8h case    6:*/		return 0x820AABFC;
	}
	return 0x820AABFC;
} // Block from 820AABE0h-820AABFCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AABFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AABFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AABFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AABFC);
		  /* 820AABFCh */ case    0:  		/* lwz R11, <#[R26 + 64]> */
		/* 820AABFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000040) );
		/* 820AABFCh case    0:*/		return 0x820AAC00;
		  /* 820AAC00h */ case    1:  		/* rlwinm R11, R11, 16, 13, 15 */
		/* 820AAC00h case    1:*/		cpu::op::rlwinm<0,16,13,15>(regs,&regs.R11,regs.R11);
		/* 820AAC00h case    1:*/		return 0x820AAC04;
		  /* 820AAC04h */ case    2:  		/* or R30, R11, R30 */
		/* 820AAC04h case    2:*/		cpu::op::or<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 820AAC04h case    2:*/		return 0x820AAC08;
	}
	return 0x820AAC08;
} // Block from 820AABFCh-820AAC08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AAC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAC08);
		  /* 820AAC08h */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAC08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAC08h case    0:*/		return 0x820AAC0C;
		  /* 820AAC0Ch */ case    1:  		/* lwz R10, <#[R31 + 100]> */
		/* 820AAC0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAC0Ch case    1:*/		return 0x820AAC10;
		  /* 820AAC10h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AAC10h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AAC10h case    2:*/		return 0x820AAC14;
		  /* 820AAC14h */ case    3:  		/* stwx R30, <#[R11 + R10]> */
		/* 820AAC14h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AAC14h case    3:*/		return 0x820AAC18;
		  /* 820AAC18h */ case    4:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAC18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAC18h case    4:*/		return 0x820AAC1C;
		  /* 820AAC1Ch */ case    5:  		/* addi R11, R11, 1 */
		/* 820AAC1Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AAC1Ch case    5:*/		return 0x820AAC20;
		  /* 820AAC20h */ case    6:  		/* stw R11, <#[R31 + 104]> */
		/* 820AAC20h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAC20h case    6:*/		return 0x820AAC24;
		  /* 820AAC24h */ case    7:  		/* lwz R10, <#[R26 + 56]> */
		/* 820AAC24h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000038) );
		/* 820AAC24h case    7:*/		return 0x820AAC28;
		  /* 820AAC28h */ case    8:  		/* cmplwi CR6, R10, 31 */
		/* 820AAC28h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001F);
		/* 820AAC28h case    8:*/		return 0x820AAC2C;
		  /* 820AAC2Ch */ case    9:  		/* bc 4, CR6_EQ, 36 */
		/* 820AAC2Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820AAC50;  }
		/* 820AAC2Ch case    9:*/		return 0x820AAC30;
		  /* 820AAC30h */ case   10:  		/* lwz R10, <#[R26 + 64]> */
		/* 820AAC30h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000040) );
		/* 820AAC30h case   10:*/		return 0x820AAC34;
		  /* 820AAC34h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AAC34h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AAC34h case   11:*/		return 0x820AAC38;
		  /* 820AAC38h */ case   12:  		/* lwz R9, <#[R31 + 100]> */
		/* 820AAC38h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAC38h case   12:*/		return 0x820AAC3C;
		  /* 820AAC3Ch */ case   13:  		/* oris R10, R10, 32768 */
		/* 820AAC3Ch case   13:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 820AAC3Ch case   13:*/		return 0x820AAC40;
		  /* 820AAC40h */ case   14:  		/* stwx R10, <#[R11 + R9]> */
		/* 820AAC40h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820AAC40h case   14:*/		return 0x820AAC44;
		  /* 820AAC44h */ case   15:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAC44h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAC44h case   15:*/		return 0x820AAC48;
		  /* 820AAC48h */ case   16:  		/* addi R11, R11, 1 */
		/* 820AAC48h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AAC48h case   16:*/		return 0x820AAC4C;
		  /* 820AAC4Ch */ case   17:  		/* stw R11, <#[R31 + 104]> */
		/* 820AAC4Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAC4Ch case   17:*/		return 0x820AAC50;
	}
	return 0x820AAC50;
} // Block from 820AAC08h-820AAC50h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820AAC50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAC50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAC50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAC50);
		  /* 820AAC50h */ case    0:  		/* lwz R10, <#[R26 + 68]> */
		/* 820AAC50h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000044) );
		/* 820AAC50h case    0:*/		return 0x820AAC54;
		  /* 820AAC54h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820AAC54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AAC54h case    1:*/		return 0x820AAC58;
		  /* 820AAC58h */ case    2:  		/* bc 12, CR6_EQ, 288 */
		/* 820AAC58h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AAD78;  }
		/* 820AAC58h case    2:*/		return 0x820AAC5C;
		  /* 820AAC5Ch */ case    3:  		/* lwz R9, <#[R10 + 4]> */
		/* 820AAC5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820AAC5Ch case    3:*/		return 0x820AAC60;
		  /* 820AAC60h */ case    4:  		/* cmpwi CR6, R9, 25 */
		/* 820AAC60h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000019);
		/* 820AAC60h case    4:*/		return 0x820AAC64;
		  /* 820AAC64h */ case    5:  		/* bc 4, CR6_EQ, 276 */
		/* 820AAC64h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AAD78;  }
		/* 820AAC64h case    5:*/		return 0x820AAC68;
		  /* 820AAC68h */ case    6:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AAC68h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AAC68h case    6:*/		return 0x820AAC6C;
		  /* 820AAC6Ch */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820AAC6Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AAC6Ch case    7:*/		return 0x820AAC70;
		  /* 820AAC70h */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 820AAC70h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820AACB0;  }
		/* 820AAC70h case    8:*/		return 0x820AAC74;
		  /* 820AAC74h */ case    9:  		/* lwz R11, <#[R10 + 32]> */
		/* 820AAC74h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000020) );
		/* 820AAC74h case    9:*/		return 0x820AAC78;
		  /* 820AAC78h */ case   10:  		/* lis R9, 15 */
		/* 820AAC78h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xF);
		/* 820AAC78h case   10:*/		return 0x820AAC7C;
		  /* 820AAC7Ch */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 820AAC7Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AAC7Ch case   11:*/		return 0x820AAC80;
		  /* 820AAC80h */ case   12:  		/* bc 4, CR6_EQ, 48 */
		/* 820AAC80h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820AACB0;  }
		/* 820AAC80h case   12:*/		return 0x820AAC84;
		  /* 820AAC84h */ case   13:  		/* lwz R11, <#[R26 + 56]> */
		/* 820AAC84h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000038) );
		/* 820AAC84h case   13:*/		return 0x820AAC88;
		  /* 820AAC88h */ case   14:  		/* cmplwi CR6, R11, 21 */
		/* 820AAC88h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 820AAC88h case   14:*/		return 0x820AAC8C;
		  /* 820AAC8Ch */ case   15:  		/* bc 12, CR6_EQ, 28 */
		/* 820AAC8Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820AACA8;  }
		/* 820AAC8Ch case   15:*/		return 0x820AAC90;
		  /* 820AAC90h */ case   16:  		/* cmplwi CR6, R11, 23 */
		/* 820AAC90h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000017);
		/* 820AAC90h case   16:*/		return 0x820AAC94;
		  /* 820AAC94h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 820AAC94h case   17:*/		if ( regs.CR[6].eq ) { return 0x820AACA8;  }
		/* 820AAC94h case   17:*/		return 0x820AAC98;
		  /* 820AAC98h */ case   18:  		/* cmplwi CR6, R11, 24 */
		/* 820AAC98h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 820AAC98h case   18:*/		return 0x820AAC9C;
		  /* 820AAC9Ch */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 820AAC9Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820AACB0;  }
		/* 820AAC9Ch case   19:*/		return 0x820AACA0;
		  /* 820AACA0h */ case   20:  		/* lis R11, 3 */
		/* 820AACA0h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0x3);
		/* 820AACA0h case   20:*/		return 0x820AACA4;
		  /* 820AACA4h */ case   21:  		/* b 8 */
		/* 820AACA4h case   21:*/		return 0x820AACAC;
		/* 820AACA4h case   21:*/		return 0x820AACA8;
	}
	return 0x820AACA8;
} // Block from 820AAC50h-820AACA8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820AACA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AACA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AACA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AACA8);
		  /* 820AACA8h */ case    0:  		/* lis R11, 7 */
		/* 820AACA8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7);
		/* 820AACA8h case    0:*/		return 0x820AACAC;
	}
	return 0x820AACAC;
} // Block from 820AACA8h-820AACACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AACACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AACAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AACAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AACAC);
		  /* 820AACACh */ case    0:  		/* stw R11, <#[R10 + 32]> */
		/* 820AACACh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000020) );
		/* 820AACACh case    0:*/		return 0x820AACB0;
	}
	return 0x820AACB0;
} // Block from 820AACACh-820AACB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AACB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AACB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AACB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AACB0);
		  /* 820AACB0h */ case    0:  		/* lwz R11, <#[R10 + 16]> */
		/* 820AACB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820AACB0h case    0:*/		return 0x820AACB4;
		  /* 820AACB4h */ case    1:  		/* lis R9, -128 */
		/* 820AACB4h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFF80);
		/* 820AACB4h case    1:*/		return 0x820AACB8;
		  /* 820AACB8h */ case    2:  		/* lwz R8, <#[R26 + 60]> */
		/* 820AACB8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x0000003C) );
		/* 820AACB8h case    2:*/		return 0x820AACBC;
		  /* 820AACBCh */ case    3:  		/* rlwimi R9, R11, 20, 9, 11 */
		/* 820AACBCh case    3:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R9,regs.R11);
		/* 820AACBCh case    3:*/		return 0x820AACC0;
		  /* 820AACC0h */ case    4:  		/* lwz R7, <#[R10 + 24]> */
		/* 820AACC0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000018) );
		/* 820AACC0h case    4:*/		return 0x820AACC4;
		  /* 820AACC4h */ case    5:  		/* rlwinm R11, R11, 0, 27, 28 */
		/* 820AACC4h case    5:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R11,regs.R11);
		/* 820AACC4h case    5:*/		return 0x820AACC8;
		  /* 820AACC8h */ case    6:  		/* lwz R6, <#[R10 + 32]> */
		/* 820AACC8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000020) );
		/* 820AACC8h case    6:*/		return 0x820AACCC;
		  /* 820AACCCh */ case    7:  		/* rlwinm R8, R8, 0, 4, 11 */
		/* 820AACCCh case    7:*/		cpu::op::rlwinm<0,0,4,11>(regs,&regs.R8,regs.R8);
		/* 820AACCCh case    7:*/		return 0x820AACD0;
		  /* 820AACD0h */ case    8:  		/* lwz R5, <#[R10 + 40]> */
		/* 820AACD0h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000028) );
		/* 820AACD0h case    8:*/		return 0x820AACD4;
		  /* 820AACD4h */ case    9:  		/* or R11, R9, R11 */
		/* 820AACD4h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820AACD4h case    9:*/		return 0x820AACD8;
		  /* 820AACD8h */ case   10:  		/* rlwinm R9, R7, 0, 21, 31 */
		/* 820AACD8h case   10:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R9,regs.R7);
		/* 820AACD8h case   10:*/		return 0x820AACDC;
		  /* 820AACDCh */ case   11:  		/* rlwinm R11, R11, 8, 0, 23 */
		/* 820AACDCh case   11:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R11,regs.R11);
		/* 820AACDCh case   11:*/		return 0x820AACE0;
		  /* 820AACE0h */ case   12:  		/* rlwinm R7, R6, 0, 12, 15 */
		/* 820AACE0h case   12:*/		cpu::op::rlwinm<0,0,12,15>(regs,&regs.R7,regs.R6);
		/* 820AACE0h case   12:*/		return 0x820AACE4;
		  /* 820AACE4h */ case   13:  		/* or R11, R11, R8 */
		/* 820AACE4h case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820AACE4h case   13:*/		return 0x820AACE8;
		  /* 820AACE8h */ case   14:  		/* cmplwi CR6, R5, 0 */
		/* 820AACE8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820AACE8h case   14:*/		return 0x820AACEC;
		  /* 820AACECh */ case   15:  		/* or R11, R11, R9 */
		/* 820AACECh case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820AACECh case   15:*/		return 0x820AACF0;
		  /* 820AACF0h */ case   16:  		/* or R11, R11, R7 */
		/* 820AACF0h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 820AACF0h case   16:*/		return 0x820AACF4;
		  /* 820AACF4h */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 820AACF4h case   17:*/		if ( regs.CR[6].eq ) { return 0x820AACFC;  }
		/* 820AACF4h case   17:*/		return 0x820AACF8;
		  /* 820AACF8h */ case   18:  		/* ori R11, R11, 8192 */
		/* 820AACF8h case   18:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 820AACF8h case   18:*/		return 0x820AACFC;
	}
	return 0x820AACFC;
} // Block from 820AACB0h-820AACFCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820AACFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AACFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AACFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AACFC);
		  /* 820AACFCh */ case    0:  		/* lwz R9, <#[R31 + 104]> */
		/* 820AACFCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000068) );
		/* 820AACFCh case    0:*/		return 0x820AAD00;
		  /* 820AAD00h */ case    1:  		/* lwz R8, <#[R31 + 100]> */
		/* 820AAD00h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAD00h case    1:*/		return 0x820AAD04;
		  /* 820AAD04h */ case    2:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820AAD04h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820AAD04h case    2:*/		return 0x820AAD08;
		  /* 820AAD08h */ case    3:  		/* stwx R11, <#[R9 + R8]> */
		/* 820AAD08h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820AAD08h case    3:*/		return 0x820AAD0C;
		  /* 820AAD0Ch */ case    4:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAD0Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAD0Ch case    4:*/		return 0x820AAD10;
		  /* 820AAD10h */ case    5:  		/* addi R11, R11, 1 */
		/* 820AAD10h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AAD10h case    5:*/		return 0x820AAD14;
		  /* 820AAD14h */ case    6:  		/* stw R11, <#[R31 + 104]> */
		/* 820AAD14h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAD14h case    6:*/		return 0x820AAD18;
		  /* 820AAD18h */ case    7:  		/* lwz R10, <#[R10 + 40]> */
		/* 820AAD18h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 820AAD18h case    7:*/		return 0x820AAD1C;
		  /* 820AAD1Ch */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820AAD1Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AAD1Ch case    8:*/		return 0x820AAD20;
		  /* 820AAD20h */ case    9:  		/* bc 12, CR6_EQ, 88 */
		/* 820AAD20h case    9:*/		if ( regs.CR[6].eq ) { return 0x820AAD78;  }
		/* 820AAD20h case    9:*/		return 0x820AAD24;
		  /* 820AAD24h */ case   10:  		/* lwz R9, <#[R10 + 16]> */
		/* 820AAD24h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820AAD24h case   10:*/		return 0x820AAD28;
		  /* 820AAD28h */ case   11:  		/* lis R8, -128 */
		/* 820AAD28h case   11:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFFF80);
		/* 820AAD28h case   11:*/		return 0x820AAD2C;
		  /* 820AAD2Ch */ case   12:  		/* lwz R7, <#[R10 + 20]> */
		/* 820AAD2Ch case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000014) );
		/* 820AAD2Ch case   12:*/		return 0x820AAD30;
		  /* 820AAD30h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AAD30h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AAD30h case   13:*/		return 0x820AAD34;
		  /* 820AAD34h */ case   14:  		/* rlwinm R6, R9, 0, 27, 28 */
		/* 820AAD34h case   14:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R6,regs.R9);
		/* 820AAD34h case   14:*/		return 0x820AAD38;
		  /* 820AAD38h */ case   15:  		/* lwz R5, <#[R10 + 24]> */
		/* 820AAD38h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000018) );
		/* 820AAD38h case   15:*/		return 0x820AAD3C;
		  /* 820AAD3Ch */ case   16:  		/* rlwimi R8, R9, 20, 9, 11 */
		/* 820AAD3Ch case   16:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R8,regs.R9);
		/* 820AAD3Ch case   16:*/		return 0x820AAD40;
		  /* 820AAD40h */ case   17:  		/* lwz R10, <#[R10 + 36]> */
		/* 820AAD40h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000024) );
		/* 820AAD40h case   17:*/		return 0x820AAD44;
		  /* 820AAD44h */ case   18:  		/* rlwinm R9, R7, 0, 4, 7 */
		/* 820AAD44h case   18:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R9,regs.R7);
		/* 820AAD44h case   18:*/		return 0x820AAD48;
		  /* 820AAD48h */ case   19:  		/* lwz R7, <#[R31 + 100]> */
		/* 820AAD48h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAD48h case   19:*/		return 0x820AAD4C;
		  /* 820AAD4Ch */ case   20:  		/* or R8, R8, R6 */
		/* 820AAD4Ch case   20:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 820AAD4Ch case   20:*/		return 0x820AAD50;
		  /* 820AAD50h */ case   21:  		/* rlwinm R6, R5, 0, 21, 31 */
		/* 820AAD50h case   21:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R6,regs.R5);
		/* 820AAD50h case   21:*/		return 0x820AAD54;
		  /* 820AAD54h */ case   22:  		/* rlwinm R8, R8, 8, 0, 23 */
		/* 820AAD54h case   22:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R8,regs.R8);
		/* 820AAD54h case   22:*/		return 0x820AAD58;
		  /* 820AAD58h */ case   23:  		/* rlwinm R10, R10, 0, 8, 15 */
		/* 820AAD58h case   23:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R10,regs.R10);
		/* 820AAD58h case   23:*/		return 0x820AAD5C;
		  /* 820AAD5Ch */ case   24:  		/* or R9, R8, R9 */
		/* 820AAD5Ch case   24:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AAD5Ch case   24:*/		return 0x820AAD60;
		  /* 820AAD60h */ case   25:  		/* or R9, R9, R6 */
		/* 820AAD60h case   25:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 820AAD60h case   25:*/		return 0x820AAD64;
		  /* 820AAD64h */ case   26:  		/* or R10, R9, R10 */
		/* 820AAD64h case   26:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820AAD64h case   26:*/		return 0x820AAD68;
		  /* 820AAD68h */ case   27:  		/* stwx R10, <#[R11 + R7]> */
		/* 820AAD68h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820AAD68h case   27:*/		return 0x820AAD6C;
		  /* 820AAD6Ch */ case   28:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAD6Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAD6Ch case   28:*/		return 0x820AAD70;
		  /* 820AAD70h */ case   29:  		/* addi R11, R11, 1 */
		/* 820AAD70h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AAD70h case   29:*/		return 0x820AAD74;
		  /* 820AAD74h */ case   30:  		/* stw R11, <#[R31 + 104]> */
		/* 820AAD74h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAD74h case   30:*/		return 0x820AAD78;
	}
	return 0x820AAD78;
} // Block from 820AACFCh-820AAD78h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820AAD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAD78);
		  /* 820AAD78h */ case    0:  		/* lwz R10, <#[R26 + 72]> */
		/* 820AAD78h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000048) );
		/* 820AAD78h case    0:*/		return 0x820AAD7C;
		  /* 820AAD7Ch */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820AAD7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AAD7Ch case    1:*/		return 0x820AAD80;
		  /* 820AAD80h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 820AAD80h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AADE4;  }
		/* 820AAD80h case    2:*/		return 0x820AAD84;
		  /* 820AAD84h */ case    3:  		/* lwz R9, <#[R10 + 4]> */
		/* 820AAD84h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820AAD84h case    3:*/		return 0x820AAD88;
		  /* 820AAD88h */ case    4:  		/* cmpwi CR6, R9, 25 */
		/* 820AAD88h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000019);
		/* 820AAD88h case    4:*/		return 0x820AAD8C;
		  /* 820AAD8Ch */ case    5:  		/* bc 4, CR6_EQ, 88 */
		/* 820AAD8Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AADE4;  }
		/* 820AAD8Ch case    5:*/		return 0x820AAD90;
		  /* 820AAD90h */ case    6:  		/* lwz R9, <#[R10 + 16]> */
		/* 820AAD90h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820AAD90h case    6:*/		return 0x820AAD94;
		  /* 820AAD94h */ case    7:  		/* lis R8, -128 */
		/* 820AAD94h case    7:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFFF80);
		/* 820AAD94h case    7:*/		return 0x820AAD98;
		  /* 820AAD98h */ case    8:  		/* lwz R7, <#[R10 + 20]> */
		/* 820AAD98h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000014) );
		/* 820AAD98h case    8:*/		return 0x820AAD9C;
		  /* 820AAD9Ch */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AAD9Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AAD9Ch case    9:*/		return 0x820AADA0;
		  /* 820AADA0h */ case   10:  		/* rlwinm R6, R9, 0, 27, 28 */
		/* 820AADA0h case   10:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R6,regs.R9);
		/* 820AADA0h case   10:*/		return 0x820AADA4;
		  /* 820AADA4h */ case   11:  		/* lwz R5, <#[R10 + 24]> */
		/* 820AADA4h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000018) );
		/* 820AADA4h case   11:*/		return 0x820AADA8;
		  /* 820AADA8h */ case   12:  		/* rlwimi R8, R9, 20, 9, 11 */
		/* 820AADA8h case   12:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R8,regs.R9);
		/* 820AADA8h case   12:*/		return 0x820AADAC;
		  /* 820AADACh */ case   13:  		/* lwz R10, <#[R10 + 36]> */
		/* 820AADACh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000024) );
		/* 820AADACh case   13:*/		return 0x820AADB0;
		  /* 820AADB0h */ case   14:  		/* rlwinm R9, R7, 0, 4, 7 */
		/* 820AADB0h case   14:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R9,regs.R7);
		/* 820AADB0h case   14:*/		return 0x820AADB4;
		  /* 820AADB4h */ case   15:  		/* lwz R7, <#[R31 + 100]> */
		/* 820AADB4h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000064) );
		/* 820AADB4h case   15:*/		return 0x820AADB8;
		  /* 820AADB8h */ case   16:  		/* or R8, R8, R6 */
		/* 820AADB8h case   16:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 820AADB8h case   16:*/		return 0x820AADBC;
		  /* 820AADBCh */ case   17:  		/* rlwinm R6, R5, 0, 21, 31 */
		/* 820AADBCh case   17:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R6,regs.R5);
		/* 820AADBCh case   17:*/		return 0x820AADC0;
		  /* 820AADC0h */ case   18:  		/* rlwinm R8, R8, 8, 0, 23 */
		/* 820AADC0h case   18:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R8,regs.R8);
		/* 820AADC0h case   18:*/		return 0x820AADC4;
		  /* 820AADC4h */ case   19:  		/* rlwinm R10, R10, 0, 8, 15 */
		/* 820AADC4h case   19:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R10,regs.R10);
		/* 820AADC4h case   19:*/		return 0x820AADC8;
		  /* 820AADC8h */ case   20:  		/* or R9, R8, R9 */
		/* 820AADC8h case   20:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AADC8h case   20:*/		return 0x820AADCC;
		  /* 820AADCCh */ case   21:  		/* or R9, R9, R6 */
		/* 820AADCCh case   21:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 820AADCCh case   21:*/		return 0x820AADD0;
		  /* 820AADD0h */ case   22:  		/* or R10, R9, R10 */
		/* 820AADD0h case   22:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820AADD0h case   22:*/		return 0x820AADD4;
		  /* 820AADD4h */ case   23:  		/* stwx R10, <#[R11 + R7]> */
		/* 820AADD4h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820AADD4h case   23:*/		return 0x820AADD8;
		  /* 820AADD8h */ case   24:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AADD8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AADD8h case   24:*/		return 0x820AADDC;
		  /* 820AADDCh */ case   25:  		/* addi R11, R11, 1 */
		/* 820AADDCh case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AADDCh case   25:*/		return 0x820AADE0;
		  /* 820AADE0h */ case   26:  		/* stw R11, <#[R31 + 104]> */
		/* 820AADE0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AADE0h case   26:*/		return 0x820AADE4;
	}
	return 0x820AADE4;
} // Block from 820AAD78h-820AADE4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820AADE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AADE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AADE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AADE4);
		  /* 820AADE4h */ case    0:  		/* lwz R10, <#[R26 + 56]> */
		/* 820AADE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000038) );
		/* 820AADE4h case    0:*/		return 0x820AADE8;
		  /* 820AADE8h */ case    1:  		/* cmplwi CR6, R10, 81 */
		/* 820AADE8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000051);
		/* 820AADE8h case    1:*/		return 0x820AADEC;
		  /* 820AADECh */ case    2:  		/* bc 4, CR6_EQ, 104 */
		/* 820AADECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AAE54;  }
		/* 820AADECh case    2:*/		return 0x820AADF0;
		  /* 820AADF0h */ case    3:  		/* li R10, 0 */
		/* 820AADF0h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820AADF0h case    3:*/		return 0x820AADF4;
		  /* 820AADF4h */ case    4:  		/* mr R9, R24 */
		/* 820AADF4h case    4:*/		regs.R9 = regs.R24;
		/* 820AADF4h case    4:*/		return 0x820AADF8;
		  /* 820AADF8h */ case    5:  		/* lwz R8, <#[R9]> */
		/* 820AADF8h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820AADF8h case    5:*/		return 0x820AADFC;
		  /* 820AADFCh */ case    6:  		/* cmplwi CR6, R8, 0 */
		/* 820AADFCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AADFCh case    6:*/		return 0x820AAE00;
		  /* 820AAE00h */ case    7:  		/* bc 12, CR6_EQ, 652 */
		/* 820AAE00h case    7:*/		if ( regs.CR[6].eq ) { return 0x820AB08C;  }
		/* 820AAE00h case    7:*/		return 0x820AAE04;
		  /* 820AAE04h */ case    8:  		/* lwz R7, <#[R8 + 16]> */
		/* 820AAE04h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000010) );
		/* 820AAE04h case    8:*/		return 0x820AAE08;
		  /* 820AAE08h */ case    9:  		/* cmpwi CR6, R7, 7 */
		/* 820AAE08h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000007);
		/* 820AAE08h case    9:*/		return 0x820AAE0C;
		  /* 820AAE0Ch */ case   10:  		/* bc 12, CR6_LT, 40 */
		/* 820AAE0Ch case   10:*/		if ( regs.CR[6].lt ) { return 0x820AAE34;  }
		/* 820AAE0Ch case   10:*/		return 0x820AAE10;
		  /* 820AAE10h */ case   11:  		/* cmpwi CR6, R7, 10 */
		/* 820AAE10h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x0000000A);
		/* 820AAE10h case   11:*/		return 0x820AAE14;
		  /* 820AAE14h */ case   12:  		/* bc 12, CR6_GT, 32 */
		/* 820AAE14h case   12:*/		if ( regs.CR[6].gt ) { return 0x820AAE34;  }
		/* 820AAE14h case   12:*/		return 0x820AAE18;
		  /* 820AAE18h */ case   13:  		/* lfd FR0, <#[R8 + 24]> */
		/* 820AAE18h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000018) );
		/* 820AAE18h case   13:*/		return 0x820AAE1C;
		  /* 820AAE1Ch */ case   14:  		/* lwz R8, <#[R31 + 100]> */
		/* 820AAE1Ch case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAE1Ch case   14:*/		return 0x820AAE20;
		  /* 820AAE20h */ case   15:  		/* frsp FR0, FR0 */
		/* 820AAE20h case   15:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820AAE20h case   15:*/		return 0x820AAE24;
		  /* 820AAE24h */ case   16:  		/* stfs FR0, <#[R1 + 80]> */
		/* 820AAE24h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AAE24h case   16:*/		return 0x820AAE28;
		  /* 820AAE28h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AAE28h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AAE28h case   17:*/		return 0x820AAE2C;
		  /* 820AAE2Ch */ case   18:  		/* lwz R7, <#[R1 + 80]> */
		/* 820AAE2Ch case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 820AAE2Ch case   18:*/		return 0x820AAE30;
		  /* 820AAE30h */ case   19:  		/* stwx R7, <#[R11 + R8]> */
		/* 820AAE30h case   19:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820AAE30h case   19:*/		return 0x820AAE34;
	}
	return 0x820AAE34;
} // Block from 820AADE4h-820AAE34h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AAE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAE34);
		  /* 820AAE34h */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAE34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAE34h case    0:*/		return 0x820AAE38;
		  /* 820AAE38h */ case    1:  		/* addi R10, R10, 1 */
		/* 820AAE38h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AAE38h case    1:*/		return 0x820AAE3C;
		  /* 820AAE3Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 820AAE3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820AAE3Ch case    2:*/		return 0x820AAE40;
		  /* 820AAE40h */ case    3:  		/* addi R11, R11, 1 */
		/* 820AAE40h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AAE40h case    3:*/		return 0x820AAE44;
		  /* 820AAE44h */ case    4:  		/* cmplwi CR6, R10, 4 */
		/* 820AAE44h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820AAE44h case    4:*/		return 0x820AAE48;
		  /* 820AAE48h */ case    5:  		/* stw R11, <#[R31 + 104]> */
		/* 820AAE48h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAE48h case    5:*/		return 0x820AAE4C;
		  /* 820AAE4Ch */ case    6:  		/* bc 12, CR6_LT, -84 */
		/* 820AAE4Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x820AADF8;  }
		/* 820AAE4Ch case    6:*/		return 0x820AAE50;
		  /* 820AAE50h */ case    7:  		/* b 572 */
		/* 820AAE50h case    7:*/		return 0x820AB08C;
		/* 820AAE50h case    7:*/		return 0x820AAE54;
	}
	return 0x820AAE54;
} // Block from 820AAE34h-820AAE54h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AAE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAE54);
		  /* 820AAE54h */ case    0:  		/* cmplwi CR6, R10, 48 */
		/* 820AAE54h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000030);
		/* 820AAE54h case    0:*/		return 0x820AAE58;
		  /* 820AAE58h */ case    1:  		/* bc 4, CR6_EQ, 92 */
		/* 820AAE58h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AAEB4;  }
		/* 820AAE58h case    1:*/		return 0x820AAE5C;
		  /* 820AAE5Ch */ case    2:  		/* li R10, 0 */
		/* 820AAE5Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820AAE5Ch case    2:*/		return 0x820AAE60;
		  /* 820AAE60h */ case    3:  		/* mr R9, R24 */
		/* 820AAE60h case    3:*/		regs.R9 = regs.R24;
		/* 820AAE60h case    3:*/		return 0x820AAE64;
		  /* 820AAE64h */ case    4:  		/* lwz R8, <#[R9]> */
		/* 820AAE64h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820AAE64h case    4:*/		return 0x820AAE68;
		  /* 820AAE68h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 820AAE68h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AAE68h case    5:*/		return 0x820AAE6C;
		  /* 820AAE6Ch */ case    6:  		/* bc 12, CR6_EQ, 544 */
		/* 820AAE6Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820AB08C;  }
		/* 820AAE6Ch case    6:*/		return 0x820AAE70;
		  /* 820AAE70h */ case    7:  		/* lwz R7, <#[R8 + 16]> */
		/* 820AAE70h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000010) );
		/* 820AAE70h case    7:*/		return 0x820AAE74;
		  /* 820AAE74h */ case    8:  		/* cmpwi CR6, R7, 2 */
		/* 820AAE74h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000002);
		/* 820AAE74h case    8:*/		return 0x820AAE78;
		  /* 820AAE78h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820AAE78h case    9:*/		if ( regs.CR[6].eq ) { return 0x820AAE84;  }
		/* 820AAE78h case    9:*/		return 0x820AAE7C;
		  /* 820AAE7Ch */ case   10:  		/* cmpwi CR6, R7, 4 */
		/* 820AAE7Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000004);
		/* 820AAE7Ch case   10:*/		return 0x820AAE80;
		  /* 820AAE80h */ case   11:  		/* bc 4, CR6_EQ, 20 */
		/* 820AAE80h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820AAE94;  }
		/* 820AAE80h case   11:*/		return 0x820AAE84;
	}
	return 0x820AAE84;
} // Block from 820AAE54h-820AAE84h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AAE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAE84);
		  /* 820AAE84h */ case    0:  		/* lwz R7, <#[R31 + 100]> */
		/* 820AAE84h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAE84h case    0:*/		return 0x820AAE88;
		  /* 820AAE88h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AAE88h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AAE88h case    1:*/		return 0x820AAE8C;
		  /* 820AAE8Ch */ case    2:  		/* lwz R8, <#[R8 + 24]> */
		/* 820AAE8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000018) );
		/* 820AAE8Ch case    2:*/		return 0x820AAE90;
		  /* 820AAE90h */ case    3:  		/* stwx R8, <#[R11 + R7]> */
		/* 820AAE90h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820AAE90h case    3:*/		return 0x820AAE94;
	}
	return 0x820AAE94;
} // Block from 820AAE84h-820AAE94h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AAE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAE94);
		  /* 820AAE94h */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAE94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAE94h case    0:*/		return 0x820AAE98;
		  /* 820AAE98h */ case    1:  		/* addi R10, R10, 1 */
		/* 820AAE98h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AAE98h case    1:*/		return 0x820AAE9C;
		  /* 820AAE9Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 820AAE9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820AAE9Ch case    2:*/		return 0x820AAEA0;
		  /* 820AAEA0h */ case    3:  		/* addi R11, R11, 1 */
		/* 820AAEA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AAEA0h case    3:*/		return 0x820AAEA4;
		  /* 820AAEA4h */ case    4:  		/* cmplwi CR6, R10, 4 */
		/* 820AAEA4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820AAEA4h case    4:*/		return 0x820AAEA8;
		  /* 820AAEA8h */ case    5:  		/* stw R11, <#[R31 + 104]> */
		/* 820AAEA8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAEA8h case    5:*/		return 0x820AAEAC;
		  /* 820AAEACh */ case    6:  		/* bc 12, CR6_LT, -72 */
		/* 820AAEACh case    6:*/		if ( regs.CR[6].lt ) { return 0x820AAE64;  }
		/* 820AAEACh case    6:*/		return 0x820AAEB0;
		  /* 820AAEB0h */ case    7:  		/* b 476 */
		/* 820AAEB0h case    7:*/		return 0x820AB08C;
		/* 820AAEB0h case    7:*/		return 0x820AAEB4;
	}
	return 0x820AAEB4;
} // Block from 820AAE94h-820AAEB4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AAEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAEB4);
		  /* 820AAEB4h */ case    0:  		/* cmplwi CR6, R10, 47 */
		/* 820AAEB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000002F);
		/* 820AAEB4h case    0:*/		return 0x820AAEB8;
		  /* 820AAEB8h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 820AAEB8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AAEE8;  }
		/* 820AAEB8h case    1:*/		return 0x820AAEBC;
		  /* 820AAEBCh */ case    2:  		/* lwz R10, <#[R24]> */
		/* 820AAEBCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 820AAEBCh case    2:*/		return 0x820AAEC0;
		  /* 820AAEC0h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AAEC0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AAEC0h case    3:*/		return 0x820AAEC4;
		  /* 820AAEC4h */ case    4:  		/* lwz R9, <#[R31 + 100]> */
		/* 820AAEC4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAEC4h case    4:*/		return 0x820AAEC8;
		  /* 820AAEC8h */ case    5:  		/* lwz R10, <#[R10 + 24]> */
		/* 820AAEC8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820AAEC8h case    5:*/		return 0x820AAECC;
		  /* 820AAECCh */ case    6:  		/* addic R8, R10, -1 */
		/* 820AAECCh case    6:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 820AAECCh case    6:*/		return 0x820AAED0;
		  /* 820AAED0h */ case    7:  		/* subfe R10, R8, R10 */
		/* 820AAED0h case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820AAED0h case    7:*/		return 0x820AAED4;
		  /* 820AAED4h */ case    8:  		/* stwx R10, <#[R11 + R9]> */
		/* 820AAED4h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820AAED4h case    8:*/		return 0x820AAED8;
		  /* 820AAED8h */ case    9:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AAED8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAED8h case    9:*/		return 0x820AAEDC;
		  /* 820AAEDCh */ case   10:  		/* addi R11, R11, 1 */
		/* 820AAEDCh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AAEDCh case   10:*/		return 0x820AAEE0;
		  /* 820AAEE0h */ case   11:  		/* stw R11, <#[R31 + 104]> */
		/* 820AAEE0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAEE0h case   11:*/		return 0x820AAEE4;
		  /* 820AAEE4h */ case   12:  		/* b 424 */
		/* 820AAEE4h case   12:*/		return 0x820AB08C;
		/* 820AAEE4h case   12:*/		return 0x820AAEE8;
	}
	return 0x820AAEE8;
} // Block from 820AAEB4h-820AAEE8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AAEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAEE8);
		  /* 820AAEE8h */ case    0:  		/* lis R11, -32255 */
		/* 820AAEE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AAEE8h case    0:*/		return 0x820AAEEC;
		  /* 820AAEECh */ case    1:  		/* li R29, 0 */
		/* 820AAEECh case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820AAEECh case    1:*/		return 0x820AAEF0;
		  /* 820AAEF0h */ case    2:  		/* mr R30, R24 */
		/* 820AAEF0h case    2:*/		regs.R30 = regs.R24;
		/* 820AAEF0h case    2:*/		return 0x820AAEF4;
		  /* 820AAEF4h */ case    3:  		/* addi R28, R11, 3508 */
		/* 820AAEF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xDB4);
		/* 820AAEF4h case    3:*/		return 0x820AAEF8;
		  /* 820AAEF8h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 820AAEF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820AAEF8h case    4:*/		return 0x820AAEFC;
		  /* 820AAEFCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820AAEFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AAEFCh case    5:*/		return 0x820AAF00;
		  /* 820AAF00h */ case    6:  		/* bc 12, CR6_EQ, 396 */
		/* 820AAF00h case    6:*/		if ( regs.CR[6].eq ) { return 0x820AB08C;  }
		/* 820AAF00h case    6:*/		return 0x820AAF04;
		  /* 820AAF04h */ case    7:  		/* lwz R10, <#[R31 + 64]> */
		/* 820AAF04h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000040) );
		/* 820AAF04h case    7:*/		return 0x820AAF08;
		  /* 820AAF08h */ case    8:  		/* cmpwi CR6, R10, 0 */
		/* 820AAF08h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820AAF08h case    8:*/		return 0x820AAF0C;
		  /* 820AAF0Ch */ case    9:  		/* bc 4, CR6_EQ, 80 */
		/* 820AAF0Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820AAF5C;  }
		/* 820AAF0Ch case    9:*/		return 0x820AAF10;
		  /* 820AAF10h */ case   10:  		/* lwz R10, <#[R11 + 36]> */
		/* 820AAF10h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 820AAF10h case   10:*/		return 0x820AAF14;
		  /* 820AAF14h */ case   11:  		/* lis R9, 228 */
		/* 820AAF14h case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xE4);
		/* 820AAF14h case   11:*/		return 0x820AAF18;
		  /* 820AAF18h */ case   12:  		/* cmplw CR6, R10, R9 */
		/* 820AAF18h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820AAF18h case   12:*/		return 0x820AAF1C;
		  /* 820AAF1Ch */ case   13:  		/* bc 4, CR6_EQ, 64 */
		/* 820AAF1Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820AAF5C;  }
		/* 820AAF1Ch case   13:*/		return 0x820AAF20;
		  /* 820AAF20h */ case   14:  		/* lwz R10, <#[R26 + 56]> */
		/* 820AAF20h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000038) );
		/* 820AAF20h case   14:*/		return 0x820AAF24;
		  /* 820AAF24h */ case   15:  		/* cmplwi CR6, R10, 6 */
		/* 820AAF24h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000006);
		/* 820AAF24h case   15:*/		return 0x820AAF28;
		  /* 820AAF28h */ case   16:  		/* bc 12, CR6_EQ, 44 */
		/* 820AAF28h case   16:*/		if ( regs.CR[6].eq ) { return 0x820AAF54;  }
		/* 820AAF28h case   16:*/		return 0x820AAF2C;
		  /* 820AAF2Ch */ case   17:  		/* cmplwi CR6, R10, 7 */
		/* 820AAF2Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 820AAF2Ch case   17:*/		return 0x820AAF30;
		  /* 820AAF30h */ case   18:  		/* bc 12, CR6_EQ, 36 */
		/* 820AAF30h case   18:*/		if ( regs.CR[6].eq ) { return 0x820AAF54;  }
		/* 820AAF30h case   18:*/		return 0x820AAF34;
		  /* 820AAF34h */ case   19:  		/* cmplwi CR6, R10, 14 */
		/* 820AAF34h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000E);
		/* 820AAF34h case   19:*/		return 0x820AAF38;
		  /* 820AAF38h */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 820AAF38h case   20:*/		if ( regs.CR[6].eq ) { return 0x820AAF54;  }
		/* 820AAF38h case   20:*/		return 0x820AAF3C;
		  /* 820AAF3Ch */ case   21:  		/* cmplwi CR6, R10, 78 */
		/* 820AAF3Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000004E);
		/* 820AAF3Ch case   21:*/		return 0x820AAF40;
		  /* 820AAF40h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 820AAF40h case   22:*/		if ( regs.CR[6].eq ) { return 0x820AAF54;  }
		/* 820AAF40h case   22:*/		return 0x820AAF44;
		  /* 820AAF44h */ case   23:  		/* cmplwi CR6, R10, 15 */
		/* 820AAF44h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000F);
		/* 820AAF44h case   23:*/		return 0x820AAF48;
		  /* 820AAF48h */ case   24:  		/* bc 12, CR6_EQ, 12 */
		/* 820AAF48h case   24:*/		if ( regs.CR[6].eq ) { return 0x820AAF54;  }
		/* 820AAF48h case   24:*/		return 0x820AAF4C;
		  /* 820AAF4Ch */ case   25:  		/* cmplwi CR6, R10, 79 */
		/* 820AAF4Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000004F);
		/* 820AAF4Ch case   25:*/		return 0x820AAF50;
		  /* 820AAF50h */ case   26:  		/* bc 4, CR6_EQ, 12 */
		/* 820AAF50h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820AAF5C;  }
		/* 820AAF50h case   26:*/		return 0x820AAF54;
	}
	return 0x820AAF54;
} // Block from 820AAEE8h-820AAF54h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820AAF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAF54);
		  /* 820AAF54h */ case    0:  		/* lis R10, 255 */
		/* 820AAF54h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFF);
		/* 820AAF54h case    0:*/		return 0x820AAF58;
		  /* 820AAF58h */ case    1:  		/* stw R10, <#[R11 + 36]> */
		/* 820AAF58h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 820AAF58h case    1:*/		return 0x820AAF5C;
	}
	return 0x820AAF5C;
} // Block from 820AAF54h-820AAF5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AAF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAF5C);
		  /* 820AAF5Ch */ case    0:  		/* lwz R10, <#[R11 + 16]> */
		/* 820AAF5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820AAF5Ch case    0:*/		return 0x820AAF60;
		  /* 820AAF60h */ case    1:  		/* lis R9, -128 */
		/* 820AAF60h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFF80);
		/* 820AAF60h case    1:*/		return 0x820AAF64;
		  /* 820AAF64h */ case    2:  		/* lwz R8, <#[R11 + 20]> */
		/* 820AAF64h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820AAF64h case    2:*/		return 0x820AAF68;
		  /* 820AAF68h */ case    3:  		/* rlwimi R9, R10, 20, 9, 11 */
		/* 820AAF68h case    3:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R9,regs.R10);
		/* 820AAF68h case    3:*/		return 0x820AAF6C;
		  /* 820AAF6Ch */ case    4:  		/* lwz R7, <#[R11 + 24]> */
		/* 820AAF6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000018) );
		/* 820AAF6Ch case    4:*/		return 0x820AAF70;
		  /* 820AAF70h */ case    5:  		/* rlwinm R10, R10, 0, 27, 28 */
		/* 820AAF70h case    5:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R10,regs.R10);
		/* 820AAF70h case    5:*/		return 0x820AAF74;
		  /* 820AAF74h */ case    6:  		/* lwz R6, <#[R11 + 36]> */
		/* 820AAF74h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000024) );
		/* 820AAF74h case    6:*/		return 0x820AAF78;
		  /* 820AAF78h */ case    7:  		/* rlwinm R8, R8, 0, 4, 7 */
		/* 820AAF78h case    7:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R8,regs.R8);
		/* 820AAF78h case    7:*/		return 0x820AAF7C;
		  /* 820AAF7Ch */ case    8:  		/* lwz R5, <#[R11 + 40]> */
		/* 820AAF7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000028) );
		/* 820AAF7Ch case    8:*/		return 0x820AAF80;
		  /* 820AAF80h */ case    9:  		/* or R10, R9, R10 */
		/* 820AAF80h case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820AAF80h case    9:*/		return 0x820AAF84;
		  /* 820AAF84h */ case   10:  		/* rlwinm R9, R7, 0, 21, 31 */
		/* 820AAF84h case   10:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R9,regs.R7);
		/* 820AAF84h case   10:*/		return 0x820AAF88;
		  /* 820AAF88h */ case   11:  		/* rlwinm R10, R10, 8, 0, 23 */
		/* 820AAF88h case   11:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R10,regs.R10);
		/* 820AAF88h case   11:*/		return 0x820AAF8C;
		  /* 820AAF8Ch */ case   12:  		/* rlwinm R7, R6, 0, 8, 15 */
		/* 820AAF8Ch case   12:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R7,regs.R6);
		/* 820AAF8Ch case   12:*/		return 0x820AAF90;
		  /* 820AAF90h */ case   13:  		/* or R10, R10, R8 */
		/* 820AAF90h case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820AAF90h case   13:*/		return 0x820AAF94;
		  /* 820AAF94h */ case   14:  		/* cmplwi CR6, R5, 0 */
		/* 820AAF94h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820AAF94h case   14:*/		return 0x820AAF98;
		  /* 820AAF98h */ case   15:  		/* or R10, R10, R9 */
		/* 820AAF98h case   15:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820AAF98h case   15:*/		return 0x820AAF9C;
		  /* 820AAF9Ch */ case   16:  		/* or R10, R10, R7 */
		/* 820AAF9Ch case   16:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820AAF9Ch case   16:*/		return 0x820AAFA0;
		  /* 820AAFA0h */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 820AAFA0h case   17:*/		if ( regs.CR[6].eq ) { return 0x820AAFA8;  }
		/* 820AAFA0h case   17:*/		return 0x820AAFA4;
		  /* 820AAFA4h */ case   18:  		/* ori R10, R10, 8192 */
		/* 820AAFA4h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2000);
		/* 820AAFA4h case   18:*/		return 0x820AAFA8;
	}
	return 0x820AAFA8;
} // Block from 820AAF5Ch-820AAFA8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820AAFA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AAFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AAFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AAFA8);
		  /* 820AAFA8h */ case    0:  		/* lwz R9, <#[R31 + 104]> */
		/* 820AAFA8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAFA8h case    0:*/		return 0x820AAFAC;
		  /* 820AAFACh */ case    1:  		/* lwz R8, <#[R31 + 100]> */
		/* 820AAFACh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000064) );
		/* 820AAFACh case    1:*/		return 0x820AAFB0;
		  /* 820AAFB0h */ case    2:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820AAFB0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820AAFB0h case    2:*/		return 0x820AAFB4;
		  /* 820AAFB4h */ case    3:  		/* stwx R10, <#[R9 + R8]> */
		/* 820AAFB4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820AAFB4h case    3:*/		return 0x820AAFB8;
		  /* 820AAFB8h */ case    4:  		/* lwz R10, <#[R31 + 104]> */
		/* 820AAFB8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAFB8h case    4:*/		return 0x820AAFBC;
		  /* 820AAFBCh */ case    5:  		/* addi R10, R10, 1 */
		/* 820AAFBCh case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AAFBCh case    5:*/		return 0x820AAFC0;
		  /* 820AAFC0h */ case    6:  		/* stw R10, <#[R31 + 104]> */
		/* 820AAFC0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000068) );
		/* 820AAFC0h case    6:*/		return 0x820AAFC4;
		  /* 820AAFC4h */ case    7:  		/* lwz R11, <#[R11 + 40]> */
		/* 820AAFC4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820AAFC4h case    7:*/		return 0x820AAFC8;
		  /* 820AAFC8h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820AAFC8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AAFC8h case    8:*/		return 0x820AAFCC;
		  /* 820AAFCCh */ case    9:  		/* bc 12, CR6_EQ, 176 */
		/* 820AAFCCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820AB07C;  }
		/* 820AAFCCh case    9:*/		return 0x820AAFD0;
		  /* 820AAFD0h */ case   10:  		/* lwz R9, <#[R31 + 64]> */
		/* 820AAFD0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000040) );
		/* 820AAFD0h case   10:*/		return 0x820AAFD4;
		  /* 820AAFD4h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820AAFD4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AAFD4h case   11:*/		return 0x820AAFD8;
		  /* 820AAFD8h */ case   12:  		/* bc 4, CR6_EQ, 80 */
		/* 820AAFD8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820AB028;  }
		/* 820AAFD8h case   12:*/		return 0x820AAFDC;
		  /* 820AAFDCh */ case   13:  		/* lwz R10, <#[R11 + 16]> */
		/* 820AAFDCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820AAFDCh case   13:*/		return 0x820AAFE0;
		  /* 820AAFE0h */ case   14:  		/* cmplwi CR6, R10, 3 */
		/* 820AAFE0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820AAFE0h case   14:*/		return 0x820AAFE4;
		  /* 820AAFE4h */ case   15:  		/* bc 4, CR6_EQ, 40 */
		/* 820AAFE4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820AB00C;  }
		/* 820AAFE4h case   15:*/		return 0x820AAFE8;
		  /* 820AAFE8h */ case   16:  		/* lwz R10, <#[R11 + 20]> */
		/* 820AAFE8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820AAFE8h case   16:*/		return 0x820AAFEC;
		  /* 820AAFECh */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 820AAFECh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AAFECh case   17:*/		return 0x820AAFF0;
		  /* 820AAFF0h */ case   18:  		/* bc 4, CR6_EQ, 28 */
		/* 820AAFF0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820AB00C;  }
		/* 820AAFF0h case   18:*/		return 0x820AAFF4;
		  /* 820AAFF4h */ case   19:  		/* lwz R10, <#[R11 + 24]> */
		/* 820AAFF4h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820AAFF4h case   19:*/		return 0x820AAFF8;
		  /* 820AAFF8h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 820AAFF8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AAFF8h case   20:*/		return 0x820AAFFC;
		  /* 820AAFFCh */ case   21:  		/* bc 4, CR6_EQ, 16 */
		/* 820AAFFCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x820AB00C;  }
		/* 820AAFFCh case   21:*/		return 0x820AB000;
		  /* 820AB000h */ case   22:  		/* lwz R11, <#[R11 + 36]> */
		/* 820AB000h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820AB000h case   22:*/		return 0x820AB004;
		  /* 820AB004h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 820AB004h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AB004h case   23:*/		return 0x820AB008;
		  /* 820AB008h */ case   24:  		/* bc 12, CR6_EQ, 116 */
		/* 820AB008h case   24:*/		if ( regs.CR[6].eq ) { return 0x820AB07C;  }
		/* 820AB008h case   24:*/		return 0x820AB00C;
	}
	return 0x820AB00C;
} // Block from 820AAFA8h-820AB00Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 820AB00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB00C);
		  /* 820AB00Ch */ case    0:  		/* mr R6, R28 */
		/* 820AB00Ch case    0:*/		regs.R6 = regs.R28;
		/* 820AB00Ch case    0:*/		return 0x820AB010;
		  /* 820AB010h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AB010h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AB010h case    1:*/		return 0x820AB014;
		  /* 820AB014h */ case    2:  		/* li R5, 2007 */
		/* 820AB014h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D7);
		/* 820AB014h case    2:*/		return 0x820AB018;
		  /* 820AB018h */ case    3:  		/* addi R4, R26, 16 */
		/* 820AB018h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AB018h case    3:*/		return 0x820AB01C;
		  /* 820AB01Ch */ case    4:  		/* bl -16012 */
		/* 820AB01Ch case    4:*/		regs.LR = 0x820AB020; return 0x820A7190;
		/* 820AB01Ch case    4:*/		return 0x820AB020;
		  /* 820AB020h */ case    5:  		/* stw R22, <#[R31 + 84]> */
		/* 820AB020h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AB020h case    5:*/		return 0x820AB024;
		  /* 820AB024h */ case    6:  		/* b 88 */
		/* 820AB024h case    6:*/		return 0x820AB07C;
		/* 820AB024h case    6:*/		return 0x820AB028;
	}
	return 0x820AB028;
} // Block from 820AB00Ch-820AB028h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AB028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB028);
		  /* 820AB028h */ case    0:  		/* lwz R9, <#[R11 + 16]> */
		/* 820AB028h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820AB028h case    0:*/		return 0x820AB02C;
		  /* 820AB02Ch */ case    1:  		/* lis R8, -128 */
		/* 820AB02Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFFF80);
		/* 820AB02Ch case    1:*/		return 0x820AB030;
	}
	return 0x820AB030;
} // Block from 820AB028h-820AB030h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AB030h
// Function '?Assure@CAssembler@D3DXShader@@IAAJI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB030);
		  /* 820AB030h */ case    0:  		/* lwz R7, <#[R11 + 20]> */
		/* 820AB030h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000014) );
		/* 820AB030h case    0:*/		return 0x820AB034;
		  /* 820AB034h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AB034h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AB034h case    1:*/		return 0x820AB038;
		  /* 820AB038h */ case    2:  		/* rlwimi R8, R9, 20, 9, 11 */
		/* 820AB038h case    2:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R8,regs.R9);
		/* 820AB038h case    2:*/		return 0x820AB03C;
		  /* 820AB03Ch */ case    3:  		/* lwz R6, <#[R11 + 24]> */
		/* 820AB03Ch case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000018) );
		/* 820AB03Ch case    3:*/		return 0x820AB040;
		  /* 820AB040h */ case    4:  		/* rlwinm R9, R9, 0, 27, 28 */
		/* 820AB040h case    4:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R9,regs.R9);
		/* 820AB040h case    4:*/		return 0x820AB044;
		  /* 820AB044h */ case    5:  		/* lwz R11, <#[R11 + 36]> */
		/* 820AB044h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820AB044h case    5:*/		return 0x820AB048;
		  /* 820AB048h */ case    6:  		/* rlwinm R7, R7, 0, 4, 7 */
		/* 820AB048h case    6:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R7,regs.R7);
		/* 820AB048h case    6:*/		return 0x820AB04C;
		  /* 820AB04Ch */ case    7:  		/* lwz R5, <#[R31 + 100]> */
		/* 820AB04Ch case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000064) );
		/* 820AB04Ch case    7:*/		return 0x820AB050;
		  /* 820AB050h */ case    8:  		/* or R9, R8, R9 */
		/* 820AB050h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AB050h case    8:*/		return 0x820AB054;
		  /* 820AB054h */ case    9:  		/* rlwinm R8, R6, 0, 21, 31 */
		/* 820AB054h case    9:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R8,regs.R6);
		/* 820AB054h case    9:*/		return 0x820AB058;
		  /* 820AB058h */ case   10:  		/* rlwinm R9, R9, 8, 0, 23 */
		/* 820AB058h case   10:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R9,regs.R9);
		/* 820AB058h case   10:*/		return 0x820AB05C;
		  /* 820AB05Ch */ case   11:  		/* rlwinm R11, R11, 0, 8, 15 */
		/* 820AB05Ch case   11:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R11,regs.R11);
		/* 820AB05Ch case   11:*/		return 0x820AB060;
		  /* 820AB060h */ case   12:  		/* or R9, R9, R7 */
		/* 820AB060h case   12:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820AB060h case   12:*/		return 0x820AB064;
		  /* 820AB064h */ case   13:  		/* or R9, R9, R8 */
		/* 820AB064h case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820AB064h case   13:*/		return 0x820AB068;
		  /* 820AB068h */ case   14:  		/* or R11, R9, R11 */
		/* 820AB068h case   14:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820AB068h case   14:*/		return 0x820AB06C;
		  /* 820AB06Ch */ case   15:  		/* stwx R11, <#[R10 + R5]> */
		/* 820AB06Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820AB06Ch case   15:*/		return 0x820AB070;
		  /* 820AB070h */ case   16:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AB070h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB070h case   16:*/		return 0x820AB074;
		  /* 820AB074h */ case   17:  		/* addi R11, R11, 1 */
		/* 820AB074h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AB074h case   17:*/		return 0x820AB078;
		  /* 820AB078h */ case   18:  		/* stw R11, <#[R31 + 104]> */
		/* 820AB078h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB078h case   18:*/		return 0x820AB07C;
	}
	return 0x820AB07C;
} // Block from 820AB030h-820AB07Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820AB07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB07C);
		  /* 820AB07Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 820AB07Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820AB07Ch case    0:*/		return 0x820AB080;
		  /* 820AB080h */ case    1:  		/* addi R30, R30, 4 */
		/* 820AB080h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820AB080h case    1:*/		return 0x820AB084;
		  /* 820AB084h */ case    2:  		/* cmplwi CR6, R29, 4 */
		/* 820AB084h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000004);
		/* 820AB084h case    2:*/		return 0x820AB088;
		  /* 820AB088h */ case    3:  		/* bc 12, CR6_LT, -400 */
		/* 820AB088h case    3:*/		if ( regs.CR[6].lt ) { return 0x820AAEF8;  }
		/* 820AB088h case    3:*/		return 0x820AB08C;
	}
	return 0x820AB08C;
} // Block from 820AB07Ch-820AB08Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AB08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB08C);
		  /* 820AB08Ch */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AB08Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB08Ch case    0:*/		return 0x820AB090;
		  /* 820AB090h */ case    1:  		/* cmplw CR6, R11, R23 */
		/* 820AB090h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 820AB090h case    1:*/		return 0x820AB094;
		  /* 820AB094h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820AB094h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AB0B4;  }
		/* 820AB094h case    2:*/		return 0x820AB098;
		  /* 820AB098h */ case    3:  		/* lis R11, -32255 */
		/* 820AB098h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AB098h case    3:*/		return 0x820AB09C;
		  /* 820AB09Ch */ case    4:  		/* lwz R3, <#[R31]> */
		/* 820AB09Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AB09Ch case    4:*/		return 0x820AB0A0;
		  /* 820AB0A0h */ case    5:  		/* li R5, 0 */
		/* 820AB0A0h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820AB0A0h case    5:*/		return 0x820AB0A4;
		  /* 820AB0A4h */ case    6:  		/* addi R6, R11, 3464 */
		/* 820AB0A4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xD88);
		/* 820AB0A4h case    6:*/		return 0x820AB0A8;
		  /* 820AB0A8h */ case    7:  		/* addi R4, R26, 16 */
		/* 820AB0A8h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AB0A8h case    7:*/		return 0x820AB0AC;
		  /* 820AB0ACh */ case    8:  		/* bl -16156 */
		/* 820AB0ACh case    8:*/		regs.LR = 0x820AB0B0; return 0x820A7190;
		/* 820AB0ACh case    8:*/		return 0x820AB0B0;
		  /* 820AB0B0h */ case    9:  		/* stw R22, <#[R31 + 84]> */
		/* 820AB0B0h case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000054) );
		/* 820AB0B0h case    9:*/		return 0x820AB0B4;
	}
	return 0x820AB0B4;
} // Block from 820AB08Ch-820AB0B4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AB0B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB0B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB0B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB0B4);
		  /* 820AB0B4h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 820AB0B4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 820AB0B4h case    0:*/		return 0x820AB0B8;
		  /* 820AB0B8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820AB0B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AB0C8;  }
		/* 820AB0B8h case    1:*/		return 0x820AB0BC;
		  /* 820AB0BCh */ case    2:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AB0BCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB0BCh case    2:*/		return 0x820AB0C0;
		  /* 820AB0C0h */ case    3:  		/* stw R11, <#[R31 + 112]> */
		/* 820AB0C0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820AB0C0h case    3:*/		return 0x820AB0C4;
		  /* 820AB0C4h */ case    4:  		/* b 28 */
		/* 820AB0C4h case    4:*/		return 0x820AB0E0;
		/* 820AB0C4h case    4:*/		return 0x820AB0C8;
	}
	return 0x820AB0C8;
} // Block from 820AB0B4h-820AB0C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AB0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB0C8);
		  /* 820AB0C8h */ case    0:  		/* addi R4, R26, 16 */
		/* 820AB0C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x10);
		/* 820AB0C8h case    0:*/		return 0x820AB0CC;
		  /* 820AB0CCh */ case    1:  		/* mr R3, R31 */
		/* 820AB0CCh case    1:*/		regs.R3 = regs.R31;
		/* 820AB0CCh case    1:*/		return 0x820AB0D0;
		  /* 820AB0D0h */ case    2:  		/* bl -8536 */
		/* 820AB0D0h case    2:*/		regs.LR = 0x820AB0D4; return 0x820A8F78;
		/* 820AB0D0h case    2:*/		return 0x820AB0D4;
		  /* 820AB0D4h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820AB0D4h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AB0D4h case    3:*/		return 0x820AB0D8;
	}
	return 0x820AB0D8;
} // Block from 820AB0C8h-820AB0D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AB0D8h
// Function '?Emit@CAssembler@D3DXShader@@IAAJK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB0D8);
		  /* 820AB0D8h */ case    0:  		/* bc 4, CR0_LT, 8 */
		/* 820AB0D8h case    0:*/		if ( !regs.CR[0].lt ) { return 0x820AB0E0;  }
		/* 820AB0D8h case    0:*/		return 0x820AB0DC;
		  /* 820AB0DCh */ case    1:  		/* stw R22, <#[R31 + 88]> */
		/* 820AB0DCh case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000058) );
		/* 820AB0DCh case    1:*/		return 0x820AB0E0;
	}
	return 0x820AB0E0;
} // Block from 820AB0D8h-820AB0E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AB0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB0E0);
		  /* 820AB0E0h */ case    0:  		/* li R3, 0 */
		/* 820AB0E0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AB0E0h case    0:*/		return 0x820AB0E4;
	}
	return 0x820AB0E4;
} // Block from 820AB0E0h-820AB0E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AB0E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB0E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB0E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB0E4);
		  /* 820AB0E4h */ case    0:  		/* addi R1, R1, 192 */
		/* 820AB0E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820AB0E4h case    0:*/		return 0x820AB0E8;
		  /* 820AB0E8h */ case    1:  		/* b -106076 */
		/* 820AB0E8h case    1:*/		return 0x8209128C;
		/* 820AB0E8h case    1:*/		return 0x820AB0EC;
		  /* 820AB0ECh */ case    2:  		/* nop */
		/* 820AB0ECh case    2:*/		cpu::op::nop();
		/* 820AB0ECh case    2:*/		return 0x820AB0F0;
	}
	return 0x820AB0F0;
} // Block from 820AB0E4h-820AB0F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AB0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB0F0);
		  /* 820AB0F0h */ case    0:  		/* mfspr R12, LR */
		/* 820AB0F0h case    0:*/		regs.R12 = regs.LR;
		/* 820AB0F0h case    0:*/		return 0x820AB0F4;
		  /* 820AB0F4h */ case    1:  		/* bl -106160 */
		/* 820AB0F4h case    1:*/		regs.LR = 0x820AB0F8; return 0x82091244;
		/* 820AB0F4h case    1:*/		return 0x820AB0F8;
		  /* 820AB0F8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820AB0F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820AB0F8h case    2:*/		return 0x820AB0FC;
		  /* 820AB0FCh */ case    3:  		/* lis R4, 17998 */
		/* 820AB0FCh case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x464E);
		/* 820AB0FCh case    3:*/		return 0x820AB100;
		  /* 820AB100h */ case    4:  		/* mr R31, R3 */
		/* 820AB100h case    4:*/		regs.R31 = regs.R3;
		/* 820AB100h case    4:*/		return 0x820AB104;
		  /* 820AB104h */ case    5:  		/* li R23, 0 */
		/* 820AB104h case    5:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820AB104h case    5:*/		return 0x820AB108;
		  /* 820AB108h */ case    6:  		/* ori R4, R4, 18758 */
		/* 820AB108h case    6:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x4946);
		/* 820AB108h case    6:*/		return 0x820AB10C;
		  /* 820AB10Ch */ case    7:  		/* addi R3, R1, 80 */
		/* 820AB10Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AB10Ch case    7:*/		return 0x820AB110;
		  /* 820AB110h */ case    8:  		/* mr R30, R23 */
		/* 820AB110h case    8:*/		regs.R30 = regs.R23;
		/* 820AB110h case    8:*/		return 0x820AB114;
		  /* 820AB114h */ case    9:  		/* bl 143532 */
		/* 820AB114h case    9:*/		regs.LR = 0x820AB118; return 0x820CE1C0;
		/* 820AB114h case    9:*/		return 0x820AB118;
		  /* 820AB118h */ case   10:  		/* lwz R8, <#[R31 + 132]> */
		/* 820AB118h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000084) );
		/* 820AB118h case   10:*/		return 0x820AB11C;
		  /* 820AB11Ch */ case   11:  		/* mr R24, R23 */
		/* 820AB11Ch case   11:*/		regs.R24 = regs.R23;
		/* 820AB11Ch case   11:*/		return 0x820AB120;
		  /* 820AB120h */ case   12:  		/* mr R25, R23 */
		/* 820AB120h case   12:*/		regs.R25 = regs.R23;
		/* 820AB120h case   12:*/		return 0x820AB124;
		  /* 820AB124h */ case   13:  		/* lwz R10, <#[R8 + 172]> */
		/* 820AB124h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x000000AC) );
		/* 820AB124h case   13:*/		return 0x820AB128;
		  /* 820AB128h */ case   14:  		/* lwz R11, <#[R8 + 168]> */
		/* 820AB128h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x000000A8) );
		/* 820AB128h case   14:*/		return 0x820AB12C;
		  /* 820AB12Ch */ case   15:  		/* lwz R9, <#[R8 + 164]> */
		/* 820AB12Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x000000A4) );
		/* 820AB12Ch case   15:*/		return 0x820AB130;
		  /* 820AB130h */ case   16:  		/* add R11, R10, R11 */
		/* 820AB130h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820AB130h case   16:*/		return 0x820AB134;
		  /* 820AB134h */ case   17:  		/* add R11, R11, R9 */
		/* 820AB134h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820AB134h case   17:*/		return 0x820AB138;
		  /* 820AB138h */ case   18:  		/* lwz R10, <#[R8 + 160]> */
		/* 820AB138h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x000000A0) );
		/* 820AB138h case   18:*/		return 0x820AB13C;
		  /* 820AB13Ch */ case   19:  		/* lwz R8, <#[R8 + 156]> */
		/* 820AB13Ch case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000009C) );
		/* 820AB13Ch case   19:*/		return 0x820AB140;
	}
	return 0x820AB140;
} // Block from 820AB0F0h-820AB140h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AB140h
// Function '?EmitInstruction@CAssembler@D3DXShader@@IAAJPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB140);
		  /* 820AB140h */ case    0:  		/* add R11, R11, R10 */
		/* 820AB140h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820AB140h case    0:*/		return 0x820AB144;
		  /* 820AB144h */ case    1:  		/* add. R11, R11, R8 */
		/* 820AB144h case    1:*/		cpu::op::add<1>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820AB144h case    1:*/		return 0x820AB148;
		  /* 820AB148h */ case    2:  		/* bc 12, CR0_EQ, 932 */
		/* 820AB148h case    2:*/		if ( regs.CR[0].eq ) { return 0x820AB4EC;  }
		/* 820AB148h case    2:*/		return 0x820AB14C;
		  /* 820AB14Ch */ case    3:  		/* lis R4, 9345 */
		/* 820AB14Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB14Ch case    3:*/		return 0x820AB150;
		  /* 820AB150h */ case    4:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820AB150h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820AB150h case    4:*/		return 0x820AB154;
		  /* 820AB154h */ case    5:  		/* bl -143188 */
		/* 820AB154h case    5:*/		regs.LR = 0x820AB158; return 0x82088200;
		/* 820AB154h case    5:*/		return 0x820AB158;
		  /* 820AB158h */ case    6:  		/* or. R24, R3, R3 */
		/* 820AB158h case    6:*/		cpu::op::or<1>(regs,&regs.R24,regs.R3,regs.R3);
		/* 820AB158h case    6:*/		return 0x820AB15C;
		  /* 820AB15Ch */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 820AB15Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x820AB16C;  }
		/* 820AB15Ch case    7:*/		return 0x820AB160;
		  /* 820AB160h */ case    8:  		/* lis R30, -32761 */
		/* 820AB160h case    8:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820AB160h case    8:*/		return 0x820AB164;
		  /* 820AB164h */ case    9:  		/* ori R30, R30, 14 */
		/* 820AB164h case    9:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820AB164h case    9:*/		return 0x820AB168;
		  /* 820AB168h */ case   10:  		/* b 900 */
		/* 820AB168h case   10:*/		return 0x820AB4EC;
		/* 820AB168h case   10:*/		return 0x820AB16C;
	}
	return 0x820AB16C;
} // Block from 820AB140h-820AB16Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AB16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB16C);
		  /* 820AB16Ch */ case    0:  		/* li R10, 7 */
		/* 820AB16Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 820AB16Ch case    0:*/		return 0x820AB170;
		  /* 820AB170h */ case    1:  		/* lwz R9, <#[R31 + 132]> */
		/* 820AB170h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000084) );
		/* 820AB170h case    1:*/		return 0x820AB174;
		  /* 820AB174h */ case    2:  		/* mr R11, R23 */
		/* 820AB174h case    2:*/		regs.R11 = regs.R23;
		/* 820AB174h case    2:*/		return 0x820AB178;
		  /* 820AB178h */ case    3:  		/* mtspr CTR, R10 */
		/* 820AB178h case    3:*/		regs.CTR = regs.R10;
		/* 820AB178h case    3:*/		return 0x820AB17C;
		  /* 820AB17Ch */ case    4:  		/* lwz R8, <#[R9]> */
		/* 820AB17Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820AB17Ch case    4:*/		return 0x820AB180;
		  /* 820AB180h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 820AB180h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AB180h case    5:*/		return 0x820AB184;
		  /* 820AB184h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 820AB184h case    6:*/		if ( regs.CR[6].eq ) { return 0x820AB1A8;  }
		/* 820AB184h case    6:*/		return 0x820AB188;
		  /* 820AB188h */ case    7:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820AB188h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820AB188h case    7:*/		return 0x820AB18C;
		  /* 820AB18Ch */ case    8:  		/* add R10, R10, R24 */
		/* 820AB18Ch case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R24);
		/* 820AB18Ch case    8:*/		return 0x820AB190;
		  /* 820AB190h */ case    9:  		/* addi R10, R10, -4 */
		/* 820AB190h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820AB190h case    9:*/		return 0x820AB194;
		  /* 820AB194h */ case   10:  		/* stwu R8, <#[R10 + 4]> */
		/* 820AB194h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820AB194h case   10:*/		return 0x820AB198;
		  /* 820AB198h */ case   11:  		/* addi R11, R11, 1 */
		/* 820AB198h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AB198h case   11:*/		return 0x820AB19C;
		  /* 820AB19Ch */ case   12:  		/* lwz R8, <#[R8 + 32]> */
		/* 820AB19Ch case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000020) );
		/* 820AB19Ch case   12:*/		return 0x820AB1A0;
		  /* 820AB1A0h */ case   13:  		/* cmplwi CR6, R8, 0 */
		/* 820AB1A0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AB1A0h case   13:*/		return 0x820AB1A4;
		  /* 820AB1A4h */ case   14:  		/* bc 4, CR6_EQ, -16 */
		/* 820AB1A4h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820AB194;  }
		/* 820AB1A4h case   14:*/		return 0x820AB1A8;
	}
	return 0x820AB1A8;
} // Block from 820AB16Ch-820AB1A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AB1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB1A8);
		  /* 820AB1A8h */ case    0:  		/* addi R9, R9, 4 */
		/* 820AB1A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820AB1A8h case    0:*/		return 0x820AB1AC;
		  /* 820AB1ACh */ case    1:  		/* bc 16, CR0_LT, -48 */
		/* 820AB1ACh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820AB17C;  }
		/* 820AB1ACh case    1:*/		return 0x820AB1B0;
		  /* 820AB1B0h */ case    2:  		/* lwz R11, <#[R31 + 132]> */
		/* 820AB1B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 820AB1B0h case    2:*/		return 0x820AB1B4;
		  /* 820AB1B4h */ case    3:  		/* li R8, 7 */
		/* 820AB1B4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x7);
		/* 820AB1B4h case    3:*/		return 0x820AB1B8;
		  /* 820AB1B8h */ case    4:  		/* mr R10, R23 */
		/* 820AB1B8h case    4:*/		regs.R10 = regs.R23;
		/* 820AB1B8h case    4:*/		return 0x820AB1BC;
		  /* 820AB1BCh */ case    5:  		/* addi R7, R11, 112 */
		/* 820AB1BCh case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x70);
		/* 820AB1BCh case    5:*/		return 0x820AB1C0;
		  /* 820AB1C0h */ case    6:  		/* lwz R9, <#[R11 + 172]> */
		/* 820AB1C0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x000000AC) );
		/* 820AB1C0h case    6:*/		return 0x820AB1C4;
		  /* 820AB1C4h */ case    7:  		/* mtspr CTR, R8 */
		/* 820AB1C4h case    7:*/		regs.CTR = regs.R8;
		/* 820AB1C4h case    7:*/		return 0x820AB1C8;
		  /* 820AB1C8h */ case    8:  		/* lwz R8, <#[R7]> */
		/* 820AB1C8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 820AB1C8h case    8:*/		return 0x820AB1CC;
		  /* 820AB1CCh */ case    9:  		/* cmplwi CR6, R8, 0 */
		/* 820AB1CCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AB1CCh case    9:*/		return 0x820AB1D0;
		  /* 820AB1D0h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820AB1D0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AB1F8;  }
		/* 820AB1D0h case   10:*/		return 0x820AB1D4;
		  /* 820AB1D4h */ case   11:  		/* add R11, R10, R9 */
		/* 820AB1D4h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 820AB1D4h case   11:*/		return 0x820AB1D8;
		  /* 820AB1D8h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AB1D8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AB1D8h case   12:*/		return 0x820AB1DC;
		  /* 820AB1DCh */ case   13:  		/* add R11, R11, R24 */
		/* 820AB1DCh case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 820AB1DCh case   13:*/		return 0x820AB1E0;
		  /* 820AB1E0h */ case   14:  		/* addi R11, R11, -4 */
		/* 820AB1E0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820AB1E0h case   14:*/		return 0x820AB1E4;
		  /* 820AB1E4h */ case   15:  		/* stwu R8, <#[R11 + 4]> */
		/* 820AB1E4h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820AB1E4h case   15:*/		return 0x820AB1E8;
		  /* 820AB1E8h */ case   16:  		/* addi R10, R10, 1 */
		/* 820AB1E8h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AB1E8h case   16:*/		return 0x820AB1EC;
		  /* 820AB1ECh */ case   17:  		/* lwz R8, <#[R8 + 32]> */
		/* 820AB1ECh case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000020) );
		/* 820AB1ECh case   17:*/		return 0x820AB1F0;
		  /* 820AB1F0h */ case   18:  		/* cmplwi CR6, R8, 0 */
		/* 820AB1F0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AB1F0h case   18:*/		return 0x820AB1F4;
		  /* 820AB1F4h */ case   19:  		/* bc 4, CR6_EQ, -16 */
		/* 820AB1F4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820AB1E4;  }
		/* 820AB1F4h case   19:*/		return 0x820AB1F8;
	}
	return 0x820AB1F8;
} // Block from 820AB1A8h-820AB1F8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AB1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB1F8);
		  /* 820AB1F8h */ case    0:  		/* addi R7, R7, 4 */
		/* 820AB1F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820AB1F8h case    0:*/		return 0x820AB1FC;
		  /* 820AB1FCh */ case    1:  		/* bc 16, CR0_LT, -52 */
		/* 820AB1FCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820AB1C8;  }
		/* 820AB1FCh case    1:*/		return 0x820AB200;
		  /* 820AB200h */ case    2:  		/* lwz R11, <#[R31 + 132]> */
		/* 820AB200h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 820AB200h case    2:*/		return 0x820AB204;
		  /* 820AB204h */ case    3:  		/* li R10, 7 */
		/* 820AB204h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 820AB204h case    3:*/		return 0x820AB208;
		  /* 820AB208h */ case    4:  		/* mr R8, R23 */
		/* 820AB208h case    4:*/		regs.R8 = regs.R23;
		/* 820AB208h case    4:*/		return 0x820AB20C;
		  /* 820AB20Ch */ case    5:  		/* addi R7, R11, 28 */
		/* 820AB20Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x1C);
		/* 820AB20Ch case    5:*/		return 0x820AB210;
		  /* 820AB210h */ case    6:  		/* lwz R11, <#[R11 + 168]> */
		/* 820AB210h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000A8) );
		/* 820AB210h case    6:*/		return 0x820AB214;
		  /* 820AB214h */ case    7:  		/* mtspr CTR, R10 */
		/* 820AB214h case    7:*/		regs.CTR = regs.R10;
		/* 820AB214h case    7:*/		return 0x820AB218;
		  /* 820AB218h */ case    8:  		/* add R9, R11, R9 */
		/* 820AB218h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820AB218h case    8:*/		return 0x820AB21C;
		  /* 820AB21Ch */ case    9:  		/* lwz R10, <#[R7]> */
		/* 820AB21Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820AB21Ch case    9:*/		return 0x820AB220;
		  /* 820AB220h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 820AB220h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AB220h case   10:*/		return 0x820AB224;
		  /* 820AB224h */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 820AB224h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AB24C;  }
		/* 820AB224h case   11:*/		return 0x820AB228;
		  /* 820AB228h */ case   12:  		/* add R11, R8, R9 */
		/* 820AB228h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 820AB228h case   12:*/		return 0x820AB22C;
		  /* 820AB22Ch */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AB22Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AB22Ch case   13:*/		return 0x820AB230;
		  /* 820AB230h */ case   14:  		/* add R11, R11, R24 */
		/* 820AB230h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 820AB230h case   14:*/		return 0x820AB234;
		  /* 820AB234h */ case   15:  		/* addi R11, R11, -4 */
		/* 820AB234h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820AB234h case   15:*/		return 0x820AB238;
		  /* 820AB238h */ case   16:  		/* stwu R10, <#[R11 + 4]> */
		/* 820AB238h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820AB238h case   16:*/		return 0x820AB23C;
		  /* 820AB23Ch */ case   17:  		/* addi R8, R8, 1 */
		/* 820AB23Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820AB23Ch case   17:*/		return 0x820AB240;
		  /* 820AB240h */ case   18:  		/* lwz R10, <#[R10 + 32]> */
		/* 820AB240h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000020) );
		/* 820AB240h case   18:*/		return 0x820AB244;
		  /* 820AB244h */ case   19:  		/* cmplwi CR6, R10, 0 */
		/* 820AB244h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AB244h case   19:*/		return 0x820AB248;
		  /* 820AB248h */ case   20:  		/* bc 4, CR6_EQ, -16 */
		/* 820AB248h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820AB238;  }
		/* 820AB248h case   20:*/		return 0x820AB24C;
	}
	return 0x820AB24C;
} // Block from 820AB1F8h-820AB24Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AB24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB24C);
		  /* 820AB24Ch */ case    0:  		/* addi R7, R7, 4 */
		/* 820AB24Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820AB24Ch case    0:*/		return 0x820AB250;
		  /* 820AB250h */ case    1:  		/* bc 16, CR0_LT, -52 */
		/* 820AB250h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820AB21C;  }
		/* 820AB250h case    1:*/		return 0x820AB254;
		  /* 820AB254h */ case    2:  		/* lwz R11, <#[R31 + 132]> */
		/* 820AB254h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 820AB254h case    2:*/		return 0x820AB258;
		  /* 820AB258h */ case    3:  		/* li R10, 7 */
		/* 820AB258h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 820AB258h case    3:*/		return 0x820AB25C;
		  /* 820AB25Ch */ case    4:  		/* mr R8, R23 */
		/* 820AB25Ch case    4:*/		regs.R8 = regs.R23;
		/* 820AB25Ch case    4:*/		return 0x820AB260;
		  /* 820AB260h */ case    5:  		/* addi R7, R11, 56 */
		/* 820AB260h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x38);
		/* 820AB260h case    5:*/		return 0x820AB264;
		  /* 820AB264h */ case    6:  		/* lwz R11, <#[R11 + 156]> */
		/* 820AB264h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000009C) );
		/* 820AB264h case    6:*/		return 0x820AB268;
		  /* 820AB268h */ case    7:  		/* mtspr CTR, R10 */
		/* 820AB268h case    7:*/		regs.CTR = regs.R10;
		/* 820AB268h case    7:*/		return 0x820AB26C;
		  /* 820AB26Ch */ case    8:  		/* add R9, R11, R9 */
		/* 820AB26Ch case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820AB26Ch case    8:*/		return 0x820AB270;
		  /* 820AB270h */ case    9:  		/* lwz R10, <#[R7]> */
		/* 820AB270h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820AB270h case    9:*/		return 0x820AB274;
		  /* 820AB274h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 820AB274h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AB274h case   10:*/		return 0x820AB278;
		  /* 820AB278h */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 820AB278h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AB2A0;  }
		/* 820AB278h case   11:*/		return 0x820AB27C;
		  /* 820AB27Ch */ case   12:  		/* add R11, R8, R9 */
		/* 820AB27Ch case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 820AB27Ch case   12:*/		return 0x820AB280;
		  /* 820AB280h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AB280h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AB280h case   13:*/		return 0x820AB284;
		  /* 820AB284h */ case   14:  		/* add R11, R11, R24 */
		/* 820AB284h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 820AB284h case   14:*/		return 0x820AB288;
		  /* 820AB288h */ case   15:  		/* addi R11, R11, -4 */
		/* 820AB288h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820AB288h case   15:*/		return 0x820AB28C;
		  /* 820AB28Ch */ case   16:  		/* stwu R10, <#[R11 + 4]> */
		/* 820AB28Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820AB28Ch case   16:*/		return 0x820AB290;
		  /* 820AB290h */ case   17:  		/* addi R8, R8, 1 */
		/* 820AB290h case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820AB290h case   17:*/		return 0x820AB294;
		  /* 820AB294h */ case   18:  		/* lwz R10, <#[R10 + 32]> */
		/* 820AB294h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000020) );
		/* 820AB294h case   18:*/		return 0x820AB298;
		  /* 820AB298h */ case   19:  		/* cmplwi CR6, R10, 0 */
		/* 820AB298h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AB298h case   19:*/		return 0x820AB29C;
		  /* 820AB29Ch */ case   20:  		/* bc 4, CR6_EQ, -16 */
		/* 820AB29Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x820AB28C;  }
		/* 820AB29Ch case   20:*/		return 0x820AB2A0;
	}
	return 0x820AB2A0;
} // Block from 820AB24Ch-820AB2A0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AB2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB2A0);
		  /* 820AB2A0h */ case    0:  		/* addi R7, R7, 4 */
		/* 820AB2A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820AB2A0h case    0:*/		return 0x820AB2A4;
		  /* 820AB2A4h */ case    1:  		/* bc 16, CR0_LT, -52 */
		/* 820AB2A4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820AB270;  }
		/* 820AB2A4h case    1:*/		return 0x820AB2A8;
		  /* 820AB2A8h */ case    2:  		/* lwz R11, <#[R31 + 132]> */
		/* 820AB2A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 820AB2A8h case    2:*/		return 0x820AB2AC;
		  /* 820AB2ACh */ case    3:  		/* li R10, 7 */
		/* 820AB2ACh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 820AB2ACh case    3:*/		return 0x820AB2B0;
		  /* 820AB2B0h */ case    4:  		/* mr R8, R23 */
		/* 820AB2B0h case    4:*/		regs.R8 = regs.R23;
		/* 820AB2B0h case    4:*/		return 0x820AB2B4;
		  /* 820AB2B4h */ case    5:  		/* addi R7, R11, 84 */
		/* 820AB2B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x54);
		/* 820AB2B4h case    5:*/		return 0x820AB2B8;
		  /* 820AB2B8h */ case    6:  		/* lwz R11, <#[R11 + 160]> */
		/* 820AB2B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000000A0) );
		/* 820AB2B8h case    6:*/		return 0x820AB2BC;
		  /* 820AB2BCh */ case    7:  		/* mtspr CTR, R10 */
		/* 820AB2BCh case    7:*/		regs.CTR = regs.R10;
		/* 820AB2BCh case    7:*/		return 0x820AB2C0;
		  /* 820AB2C0h */ case    8:  		/* add R11, R11, R9 */
		/* 820AB2C0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820AB2C0h case    8:*/		return 0x820AB2C4;
		  /* 820AB2C4h */ case    9:  		/* lwz R9, <#[R7]> */
		/* 820AB2C4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 820AB2C4h case    9:*/		return 0x820AB2C8;
		  /* 820AB2C8h */ case   10:  		/* cmplwi CR6, R9, 0 */
		/* 820AB2C8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820AB2C8h case   10:*/		return 0x820AB2CC;
		  /* 820AB2CCh */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 820AB2CCh case   11:*/		if ( regs.CR[6].eq ) { return 0x820AB2F4;  }
		/* 820AB2CCh case   11:*/		return 0x820AB2D0;
		  /* 820AB2D0h */ case   12:  		/* add R10, R8, R11 */
		/* 820AB2D0h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R11);
		/* 820AB2D0h case   12:*/		return 0x820AB2D4;
		  /* 820AB2D4h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AB2D4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AB2D4h case   13:*/		return 0x820AB2D8;
		  /* 820AB2D8h */ case   14:  		/* add R10, R10, R24 */
		/* 820AB2D8h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R24);
		/* 820AB2D8h case   14:*/		return 0x820AB2DC;
		  /* 820AB2DCh */ case   15:  		/* addi R10, R10, -4 */
		/* 820AB2DCh case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820AB2DCh case   15:*/		return 0x820AB2E0;
		  /* 820AB2E0h */ case   16:  		/* stwu R9, <#[R10 + 4]> */
		/* 820AB2E0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820AB2E0h case   16:*/		return 0x820AB2E4;
		  /* 820AB2E4h */ case   17:  		/* addi R8, R8, 1 */
		/* 820AB2E4h case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820AB2E4h case   17:*/		return 0x820AB2E8;
		  /* 820AB2E8h */ case   18:  		/* lwz R9, <#[R9 + 32]> */
		/* 820AB2E8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000020) );
		/* 820AB2E8h case   18:*/		return 0x820AB2EC;
		  /* 820AB2ECh */ case   19:  		/* cmplwi CR6, R9, 0 */
		/* 820AB2ECh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820AB2ECh case   19:*/		return 0x820AB2F0;
		  /* 820AB2F0h */ case   20:  		/* bc 4, CR6_EQ, -16 */
		/* 820AB2F0h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820AB2E0;  }
		/* 820AB2F0h case   20:*/		return 0x820AB2F4;
	}
	return 0x820AB2F4;
} // Block from 820AB2A0h-820AB2F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AB2F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB2F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB2F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB2F4);
		  /* 820AB2F4h */ case    0:  		/* addi R7, R7, 4 */
		/* 820AB2F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820AB2F4h case    0:*/		return 0x820AB2F8;
		  /* 820AB2F8h */ case    1:  		/* bc 16, CR0_LT, -52 */
		/* 820AB2F8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820AB2C4;  }
		/* 820AB2F8h case    1:*/		return 0x820AB2FC;
		  /* 820AB2FCh */ case    2:  		/* lwz R10, <#[R31 + 132]> */
		/* 820AB2FCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000084) );
		/* 820AB2FCh case    2:*/		return 0x820AB300;
		  /* 820AB300h */ case    3:  		/* lis R9, -32245 */
		/* 820AB300h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF820B);
		/* 820AB300h case    3:*/		return 0x820AB304;
		  /* 820AB304h */ case    4:  		/* li R5, 4 */
		/* 820AB304h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820AB304h case    4:*/		return 0x820AB308;
		  /* 820AB308h */ case    5:  		/* addi R6, R9, -28656 */
		/* 820AB308h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0xFFFF9010);
		/* 820AB308h case    5:*/		return 0x820AB30C;
		  /* 820AB30Ch */ case    6:  		/* mr R3, R24 */
		/* 820AB30Ch case    6:*/		regs.R3 = regs.R24;
		/* 820AB30Ch case    6:*/		return 0x820AB310;
		  /* 820AB310h */ case    7:  		/* lwz R10, <#[R10 + 164]> */
		/* 820AB310h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x000000A4) );
		/* 820AB310h case    7:*/		return 0x820AB314;
		  /* 820AB314h */ case    8:  		/* add R29, R10, R11 */
		/* 820AB314h case    8:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 820AB314h case    8:*/		return 0x820AB318;
		  /* 820AB318h */ case    9:  		/* mr R4, R29 */
		/* 820AB318h case    9:*/		regs.R4 = regs.R29;
		/* 820AB318h case    9:*/		return 0x820AB31C;
		  /* 820AB31Ch */ case   10:  		/* bl -103228 */
		/* 820AB31Ch case   10:*/		regs.LR = 0x820AB320; return 0x82091FE0;
		/* 820AB31Ch case   10:*/		return 0x820AB320;
		  /* 820AB320h */ case   11:  		/* mulli R28, R29, 20 */
		/* 820AB320h case   11:*/		cpu::op::mulli<0>(regs,&regs.R28,regs.R29,0x14);
		/* 820AB320h case   11:*/		return 0x820AB324;
		  /* 820AB324h */ case   12:  		/* lis R4, 9345 */
		/* 820AB324h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB324h case   12:*/		return 0x820AB328;
		  /* 820AB328h */ case   13:  		/* mr R3, R28 */
		/* 820AB328h case   13:*/		regs.R3 = regs.R28;
		/* 820AB328h case   13:*/		return 0x820AB32C;
		  /* 820AB32Ch */ case   14:  		/* bl -143660 */
		/* 820AB32Ch case   14:*/		regs.LR = 0x820AB330; return 0x82088200;
		/* 820AB32Ch case   14:*/		return 0x820AB330;
		  /* 820AB330h */ case   15:  		/* or. R25, R3, R3 */
		/* 820AB330h case   15:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820AB330h case   15:*/		return 0x820AB334;
		  /* 820AB334h */ case   16:  		/* bc 12, CR0_EQ, -468 */
		/* 820AB334h case   16:*/		if ( regs.CR[0].eq ) { return 0x820AB160;  }
		/* 820AB334h case   16:*/		return 0x820AB338;
		  /* 820AB338h */ case   17:  		/* addi R11, R1, 96 */
		/* 820AB338h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820AB338h case   17:*/		return 0x820AB33C;
		  /* 820AB33Ch */ case   18:  		/* lwz R10, <#[R31 + 68]> */
		/* 820AB33Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000044) );
		/* 820AB33Ch case   18:*/		return 0x820AB340;
		  /* 820AB340h */ case   19:  		/* li R9, 28 */
		/* 820AB340h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x1C);
		/* 820AB340h case   19:*/		return 0x820AB344;
		  /* 820AB344h */ case   20:  		/* ori R10, R10, 4 */
		/* 820AB344h case   20:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820AB344h case   20:*/		return 0x820AB348;
		  /* 820AB348h */ case   21:  		/* li R8, 3 */
		/* 820AB348h case   21:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 820AB348h case   21:*/		return 0x820AB34C;
		  /* 820AB34Ch */ case   22:  		/* li R7, 0 */
		/* 820AB34Ch case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820AB34Ch case   22:*/		return 0x820AB350;
		  /* 820AB350h */ case   23:  		/* std R23, <#[R11]> */
		/* 820AB350h case   23:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 820AB350h case   23:*/		return 0x820AB354;
		  /* 820AB354h */ case   24:  		/* li R6, 1 */
		/* 820AB354h case   24:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820AB354h case   24:*/		return 0x820AB358;
		  /* 820AB358h */ case   25:  		/* std R23, <#[R11 + 8]> */
		/* 820AB358h case   25:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 820AB358h case   25:*/		return 0x820AB35C;
		  /* 820AB35Ch */ case   26:  		/* li R5, 28 */
		/* 820AB35Ch case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 820AB35Ch case   26:*/		return 0x820AB360;
		  /* 820AB360h */ case   27:  		/* std R23, <#[R11 + 16]> */
		/* 820AB360h case   27:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000010) );
		/* 820AB360h case   27:*/		return 0x820AB364;
		  /* 820AB364h */ case   28:  		/* stw R23, <#[R11 + 24]> */
		/* 820AB364h case   28:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000018) );
		/* 820AB364h case   28:*/		return 0x820AB368;
		  /* 820AB368h */ case   29:  		/* addi R4, R1, 96 */
		/* 820AB368h case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820AB368h case   29:*/		return 0x820AB36C;
		  /* 820AB36Ch */ case   30:  		/* stw R9, <#[R1 + 96]> */
		/* 820AB36Ch case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 820AB36Ch case   30:*/		return 0x820AB370;
		  /* 820AB370h */ case   31:  		/* addi R3, R1, 80 */
		/* 820AB370h case   31:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AB370h case   31:*/		return 0x820AB374;
		  /* 820AB374h */ case   32:  		/* stw R23, <#[R1 + 104]> */
		/* 820AB374h case   32:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000068) );
		/* 820AB374h case   32:*/		return 0x820AB378;
		  /* 820AB378h */ case   33:  		/* stw R29, <#[R1 + 108]> */
		/* 820AB378h case   33:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000006C) );
		/* 820AB378h case   33:*/		return 0x820AB37C;
		  /* 820AB37Ch */ case   34:  		/* stw R10, <#[R1 + 116]> */
		/* 820AB37Ch case   34:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820AB37Ch case   34:*/		return 0x820AB380;
		  /* 820AB380h */ case   35:  		/* bl 143088 */
		/* 820AB380h case   35:*/		regs.LR = 0x820AB384; return 0x820CE270;
		/* 820AB380h case   35:*/		return 0x820AB384;
		  /* 820AB384h */ case   36:  		/* or. R30, R3, R3 */
		/* 820AB384h case   36:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AB384h case   36:*/		return 0x820AB388;
		  /* 820AB388h */ case   37:  		/* bc 12, CR0_LT, 356 */
		/* 820AB388h case   37:*/		if ( regs.CR[0].lt ) { return 0x820AB4EC;  }
		/* 820AB388h case   37:*/		return 0x820AB38C;
		  /* 820AB38Ch */ case   38:  		/* mr R5, R28 */
		/* 820AB38Ch case   38:*/		regs.R5 = regs.R28;
		/* 820AB38Ch case   38:*/		return 0x820AB390;
		  /* 820AB390h */ case   39:  		/* li R4, 0 */
		/* 820AB390h case   39:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AB390h case   39:*/		return 0x820AB394;
		  /* 820AB394h */ case   40:  		/* mr R3, R25 */
		/* 820AB394h case   40:*/		regs.R3 = regs.R25;
		/* 820AB394h case   40:*/		return 0x820AB398;
		  /* 820AB398h */ case   41:  		/* bl -106584 */
		/* 820AB398h case   41:*/		regs.LR = 0x820AB39C; return 0x82091340;
		/* 820AB398h case   41:*/		return 0x820AB39C;
		  /* 820AB39Ch */ case   42:  		/* li R8, 2 */
		/* 820AB39Ch case   42:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 820AB39Ch case   42:*/		return 0x820AB3A0;
		  /* 820AB3A0h */ case   43:  		/* addi R7, R1, 112 */
		/* 820AB3A0h case   43:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 820AB3A0h case   43:*/		return 0x820AB3A4;
		  /* 820AB3A4h */ case   44:  		/* li R6, 1 */
		/* 820AB3A4h case   44:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820AB3A4h case   44:*/		return 0x820AB3A8;
		  /* 820AB3A8h */ case   45:  		/* mr R5, R28 */
		/* 820AB3A8h case   45:*/		regs.R5 = regs.R28;
		/* 820AB3A8h case   45:*/		return 0x820AB3AC;
		  /* 820AB3ACh */ case   46:  		/* mr R4, R25 */
		/* 820AB3ACh case   46:*/		regs.R4 = regs.R25;
		/* 820AB3ACh case   46:*/		return 0x820AB3B0;
		  /* 820AB3B0h */ case   47:  		/* addi R3, R1, 80 */
		/* 820AB3B0h case   47:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AB3B0h case   47:*/		return 0x820AB3B4;
		  /* 820AB3B4h */ case   48:  		/* bl 143036 */
		/* 820AB3B4h case   48:*/		regs.LR = 0x820AB3B8; return 0x820CE270;
		/* 820AB3B4h case   48:*/		return 0x820AB3B8;
		  /* 820AB3B8h */ case   49:  		/* or. R30, R3, R3 */
		/* 820AB3B8h case   49:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AB3B8h case   49:*/		return 0x820AB3BC;
		  /* 820AB3BCh */ case   50:  		/* bc 12, CR0_LT, 304 */
		/* 820AB3BCh case   50:*/		if ( regs.CR[0].lt ) { return 0x820AB4EC;  }
		/* 820AB3BCh case   50:*/		return 0x820AB3C0;
		  /* 820AB3C0h */ case   51:  		/* mr R26, R23 */
		/* 820AB3C0h case   51:*/		regs.R26 = regs.R23;
		/* 820AB3C0h case   51:*/		return 0x820AB3C4;
		  /* 820AB3C4h */ case   52:  		/* cmplwi CR6, R29, 0 */
		/* 820AB3C4h case   52:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820AB3C4h case   52:*/		return 0x820AB3C8;
		  /* 820AB3C8h */ case   53:  		/* bc 12, CR6_EQ, 76 */
		/* 820AB3C8h case   53:*/		if ( regs.CR[6].eq ) { return 0x820AB414;  }
		/* 820AB3C8h case   53:*/		return 0x820AB3CC;
		  /* 820AB3CCh */ case   54:  		/* mr R27, R25 */
		/* 820AB3CCh case   54:*/		regs.R27 = regs.R25;
		/* 820AB3CCh case   54:*/		return 0x820AB3D0;
		  /* 820AB3D0h */ case   55:  		/* mr R28, R24 */
		/* 820AB3D0h case   55:*/		regs.R28 = regs.R24;
		/* 820AB3D0h case   55:*/		return 0x820AB3D4;
		  /* 820AB3D4h */ case   56:  		/* lwz R11, <#[R28]> */
		/* 820AB3D4h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820AB3D4h case   56:*/		return 0x820AB3D8;
		  /* 820AB3D8h */ case   57:  		/* mr R5, R27 */
		/* 820AB3D8h case   57:*/		regs.R5 = regs.R27;
		/* 820AB3D8h case   57:*/		return 0x820AB3DC;
		  /* 820AB3DCh */ case   58:  		/* lwz R10, <#[R31 + 100]> */
		/* 820AB3DCh case   58:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 820AB3DCh case   58:*/		return 0x820AB3E0;
		  /* 820AB3E0h */ case   59:  		/* addi R4, R1, 80 */
		/* 820AB3E0h case   59:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820AB3E0h case   59:*/		return 0x820AB3E4;
		  /* 820AB3E4h */ case   60:  		/* lwz R3, <#[R31 + 136]> */
		/* 820AB3E4h case   60:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000088) );
		/* 820AB3E4h case   60:*/		return 0x820AB3E8;
		  /* 820AB3E8h */ case   61:  		/* lwz R7, <#[R11 + 4]> */
		/* 820AB3E8h case   61:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820AB3E8h case   61:*/		return 0x820AB3EC;
		  /* 820AB3ECh */ case   62:  		/* lwz R8, <#[R10]> */
		/* 820AB3ECh case   62:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AB3ECh case   62:*/		return 0x820AB3F0;
		  /* 820AB3F0h */ case   63:  		/* lwz R6, <#[R11]> */
		/* 820AB3F0h case   63:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820AB3F0h case   63:*/		return 0x820AB3F4;
		  /* 820AB3F4h */ case   64:  		/* bl 140452 */
		/* 820AB3F4h case   64:*/		regs.LR = 0x820AB3F8; return 0x820CD898;
		/* 820AB3F4h case   64:*/		return 0x820AB3F8;
		  /* 820AB3F8h */ case   65:  		/* or. R30, R3, R3 */
		/* 820AB3F8h case   65:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AB3F8h case   65:*/		return 0x820AB3FC;
		  /* 820AB3FCh */ case   66:  		/* bc 12, CR0_LT, 240 */
		/* 820AB3FCh case   66:*/		if ( regs.CR[0].lt ) { return 0x820AB4EC;  }
		/* 820AB3FCh case   66:*/		return 0x820AB400;
		  /* 820AB400h */ case   67:  		/* addi R26, R26, 1 */
		/* 820AB400h case   67:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820AB400h case   67:*/		return 0x820AB404;
		  /* 820AB404h */ case   68:  		/* addi R28, R28, 4 */
		/* 820AB404h case   68:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820AB404h case   68:*/		return 0x820AB408;
		  /* 820AB408h */ case   69:  		/* addi R27, R27, 20 */
		/* 820AB408h case   69:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x14);
		/* 820AB408h case   69:*/		return 0x820AB40C;
		  /* 820AB40Ch */ case   70:  		/* cmplw CR6, R26, R29 */
		/* 820AB40Ch case   70:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R29);
		/* 820AB40Ch case   70:*/		return 0x820AB410;
		  /* 820AB410h */ case   71:  		/* bc 12, CR6_LT, -60 */
		/* 820AB410h case   71:*/		if ( regs.CR[6].lt ) { return 0x820AB3D4;  }
		/* 820AB410h case   71:*/		return 0x820AB414;
	}
	return 0x820AB414;
} // Block from 820AB2F4h-820AB414h (72 instructions)

//////////////////////////////////////////////////////
// Block at 820AB414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB414);
		  /* 820AB414h */ case    0:  		/* lis R11, -32255 */
		/* 820AB414h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AB414h case    0:*/		return 0x820AB418;
		  /* 820AB418h */ case    1:  		/* li R8, 1 */
		/* 820AB418h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820AB418h case    1:*/		return 0x820AB41C;
		  /* 820AB41Ch */ case    2:  		/* addi R4, R11, 4228 */
		/* 820AB41Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1084);
		/* 820AB41Ch case    2:*/		return 0x820AB420;
		  /* 820AB420h */ case    3:  		/* addi R7, R1, 100 */
		/* 820AB420h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x64);
		/* 820AB420h case    3:*/		return 0x820AB424;
		  /* 820AB424h */ case    4:  		/* li R6, 5 */
		/* 820AB424h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820AB424h case    4:*/		return 0x820AB428;
		  /* 820AB428h */ case    5:  		/* li R5, -1 */
		/* 820AB428h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 820AB428h case    5:*/		return 0x820AB42C;
		  /* 820AB42Ch */ case    6:  		/* addi R3, R1, 80 */
		/* 820AB42Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AB42Ch case    6:*/		return 0x820AB430;
		  /* 820AB430h */ case    7:  		/* bl 142912 */
		/* 820AB430h case    7:*/		regs.LR = 0x820AB434; return 0x820CE270;
		/* 820AB430h case    7:*/		return 0x820AB434;
		  /* 820AB434h */ case    8:  		/* or. R30, R3, R3 */
		/* 820AB434h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AB434h case    8:*/		return 0x820AB438;
		  /* 820AB438h */ case    9:  		/* bc 12, CR0_LT, 180 */
		/* 820AB438h case    9:*/		if ( regs.CR[0].lt ) { return 0x820AB4EC;  }
		/* 820AB438h case    9:*/		return 0x820AB43C;
		  /* 820AB43Ch */ case   10:  		/* addi R3, R1, 80 */
		/* 820AB43Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AB43Ch case   10:*/		return 0x820AB440;
		  /* 820AB440h */ case   11:  		/* bl 142752 */
		/* 820AB440h case   11:*/		regs.LR = 0x820AB444; return 0x820CE1E0;
		/* 820AB440h case   11:*/		return 0x820AB444;
		  /* 820AB444h */ case   12:  		/* mr R29, R3 */
		/* 820AB444h case   12:*/		regs.R29 = regs.R3;
		/* 820AB444h case   12:*/		return 0x820AB448;
		  /* 820AB448h */ case   13:  		/* cmplwi CR6, R3, 32768 */
		/* 820AB448h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00008000);
		/* 820AB448h case   13:*/		return 0x820AB44C;
		  /* 820AB44Ch */ case   14:  		/* bc 12, CR6_GT, 128 */
		/* 820AB44Ch case   14:*/		if ( regs.CR[6].gt ) { return 0x820AB4CC;  }
		/* 820AB44Ch case   14:*/		return 0x820AB450;
		  /* 820AB450h */ case   15:  		/* mr R4, R3 */
		/* 820AB450h case   15:*/		regs.R4 = regs.R3;
		/* 820AB450h case   15:*/		return 0x820AB454;
		  /* 820AB454h */ case   16:  		/* mr R3, R31 */
		/* 820AB454h case   16:*/		regs.R3 = regs.R31;
		/* 820AB454h case   16:*/		return 0x820AB458;
		  /* 820AB458h */ case   17:  		/* bl -3664 */
		/* 820AB458h case   17:*/		regs.LR = 0x820AB45C; return 0x820AA608;
		/* 820AB458h case   17:*/		return 0x820AB45C;
		  /* 820AB45Ch */ case   18:  		/* or. R30, R3, R3 */
		/* 820AB45Ch case   18:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AB45Ch case   18:*/		return 0x820AB460;
		  /* 820AB460h */ case   19:  		/* bc 12, CR0_LT, 140 */
		/* 820AB460h case   19:*/		if ( regs.CR[0].lt ) { return 0x820AB4EC;  }
		/* 820AB460h case   19:*/		return 0x820AB464;
		  /* 820AB464h */ case   20:  		/* lwz R9, <#[R31 + 104]> */
		/* 820AB464h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB464h case   20:*/		return 0x820AB468;
		  /* 820AB468h */ case   21:  		/* addi R10, R29, 1 */
		/* 820AB468h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x1);
		/* 820AB468h case   21:*/		return 0x820AB46C;
		  /* 820AB46Ch */ case   22:  		/* lwz R11, <#[R31 + 100]> */
		/* 820AB46Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 820AB46Ch case   22:*/		return 0x820AB470;
		  /* 820AB470h */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AB470h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AB470h case   23:*/		return 0x820AB474;
		  /* 820AB474h */ case   24:  		/* addi R9, R9, -1 */
		/* 820AB474h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820AB474h case   24:*/		return 0x820AB478;
		  /* 820AB478h */ case   25:  		/* addi R4, R11, 4 */
		/* 820AB478h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820AB478h case   25:*/		return 0x820AB47C;
		  /* 820AB47Ch */ case   26:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 820AB47Ch case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 820AB47Ch case   26:*/		return 0x820AB480;
		  /* 820AB480h */ case   27:  		/* add R3, R10, R11 */
		/* 820AB480h case   27:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 820AB480h case   27:*/		return 0x820AB484;
		  /* 820AB484h */ case   28:  		/* bl -103780 */
		/* 820AB484h case   28:*/		regs.LR = 0x820AB488; return 0x82091F20;
		/* 820AB484h case   28:*/		return 0x820AB488;
		  /* 820AB488h */ case   29:  		/* lwz R11, <#[R31 + 100]> */
		/* 820AB488h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 820AB488h case   29:*/		return 0x820AB48C;
		  /* 820AB48Ch */ case   30:  		/* mr R5, R29 */
		/* 820AB48Ch case   30:*/		regs.R5 = regs.R29;
		/* 820AB48Ch case   30:*/		return 0x820AB490;
		  /* 820AB490h */ case   31:  		/* lwz R6, <#[R31 + 92]> */
		/* 820AB490h case   31:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000005C) );
		/* 820AB490h case   31:*/		return 0x820AB494;
		  /* 820AB494h */ case   32:  		/* addi R3, R1, 80 */
		/* 820AB494h case   32:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AB494h case   32:*/		return 0x820AB498;
		  /* 820AB498h */ case   33:  		/* addi R4, R11, 4 */
		/* 820AB498h case   33:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820AB498h case   33:*/		return 0x820AB49C;
		  /* 820AB49Ch */ case   34:  		/* bl 143540 */
		/* 820AB49Ch case   34:*/		regs.LR = 0x820AB4A0; return 0x820CE550;
		/* 820AB49Ch case   34:*/		return 0x820AB4A0;
		  /* 820AB4A0h */ case   35:  		/* or. R30, R3, R3 */
		/* 820AB4A0h case   35:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AB4A0h case   35:*/		return 0x820AB4A4;
		  /* 820AB4A4h */ case   36:  		/* bc 12, CR0_LT, 72 */
		/* 820AB4A4h case   36:*/		if ( regs.CR[0].lt ) { return 0x820AB4EC;  }
		/* 820AB4A4h case   36:*/		return 0x820AB4A8;
		  /* 820AB4A8h */ case   37:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AB4A8h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB4A8h case   37:*/		return 0x820AB4AC;
		  /* 820AB4ACh */ case   38:  		/* mr R30, R23 */
		/* 820AB4ACh case   38:*/		regs.R30 = regs.R23;
		/* 820AB4ACh case   38:*/		return 0x820AB4B0;
		  /* 820AB4B0h */ case   39:  		/* lwz R10, <#[R31 + 116]> */
		/* 820AB4B0h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000074) );
		/* 820AB4B0h case   39:*/		return 0x820AB4B4;
		  /* 820AB4B4h */ case   40:  		/* add R11, R11, R29 */
		/* 820AB4B4h case   40:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820AB4B4h case   40:*/		return 0x820AB4B8;
		  /* 820AB4B8h */ case   41:  		/* add R10, R10, R29 */
		/* 820AB4B8h case   41:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 820AB4B8h case   41:*/		return 0x820AB4BC;
		  /* 820AB4BCh */ case   42:  		/* stw R11, <#[R31 + 104]> */
		/* 820AB4BCh case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB4BCh case   42:*/		return 0x820AB4C0;
		  /* 820AB4C0h */ case   43:  		/* stw R10, <#[R31 + 116]> */
		/* 820AB4C0h case   43:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000074) );
		/* 820AB4C0h case   43:*/		return 0x820AB4C4;
		  /* 820AB4C4h */ case   44:  		/* stw R11, <#[R31 + 112]> */
		/* 820AB4C4h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 820AB4C4h case   44:*/		return 0x820AB4C8;
		  /* 820AB4C8h */ case   45:  		/* b 36 */
		/* 820AB4C8h case   45:*/		return 0x820AB4EC;
		/* 820AB4C8h case   45:*/		return 0x820AB4CC;
	}
	return 0x820AB4CC;
} // Block from 820AB414h-820AB4CCh (46 instructions)

//////////////////////////////////////////////////////
// Block at 820AB4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB4CC);
		  /* 820AB4CCh */ case    0:  		/* lis R11, -32255 */
		/* 820AB4CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AB4CCh case    0:*/		return 0x820AB4D0;
		  /* 820AB4D0h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AB4D0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AB4D0h case    1:*/		return 0x820AB4D4;
		  /* 820AB4D4h */ case    2:  		/* li R5, 2031 */
		/* 820AB4D4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7EF);
		/* 820AB4D4h case    2:*/		return 0x820AB4D8;
		  /* 820AB4D8h */ case    3:  		/* addi R6, R11, 4184 */
		/* 820AB4D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1058);
		/* 820AB4D8h case    3:*/		return 0x820AB4DC;
		  /* 820AB4DCh */ case    4:  		/* addi R4, R31, 16 */
		/* 820AB4DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820AB4DCh case    4:*/		return 0x820AB4E0;
		  /* 820AB4E0h */ case    5:  		/* bl -17232 */
		/* 820AB4E0h case    5:*/		regs.LR = 0x820AB4E4; return 0x820A7190;
		/* 820AB4E0h case    5:*/		return 0x820AB4E4;
		  /* 820AB4E4h */ case    6:  		/* lis R30, -32768 */
		/* 820AB4E4h case    6:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8000);
		/* 820AB4E4h case    6:*/		return 0x820AB4E8;
		  /* 820AB4E8h */ case    7:  		/* ori R30, R30, 16389 */
		/* 820AB4E8h case    7:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x4005);
		/* 820AB4E8h case    7:*/		return 0x820AB4EC;
	}
	return 0x820AB4EC;
} // Block from 820AB4CCh-820AB4ECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AB4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB4EC);
		  /* 820AB4ECh */ case    0:  		/* lis R4, 9345 */
		/* 820AB4ECh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB4ECh case    0:*/		return 0x820AB4F0;
		  /* 820AB4F0h */ case    1:  		/* mr R3, R24 */
		/* 820AB4F0h case    1:*/		regs.R3 = regs.R24;
		/* 820AB4F0h case    1:*/		return 0x820AB4F4;
		  /* 820AB4F4h */ case    2:  		/* bl -143804 */
		/* 820AB4F4h case    2:*/		regs.LR = 0x820AB4F8; return 0x82088338;
		/* 820AB4F4h case    2:*/		return 0x820AB4F8;
		  /* 820AB4F8h */ case    3:  		/* lis R4, 9345 */
		/* 820AB4F8h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB4F8h case    3:*/		return 0x820AB4FC;
		  /* 820AB4FCh */ case    4:  		/* mr R3, R25 */
		/* 820AB4FCh case    4:*/		regs.R3 = regs.R25;
		/* 820AB4FCh case    4:*/		return 0x820AB500;
		  /* 820AB500h */ case    5:  		/* bl -143816 */
		/* 820AB500h case    5:*/		regs.LR = 0x820AB504; return 0x82088338;
		/* 820AB500h case    5:*/		return 0x820AB504;
		  /* 820AB504h */ case    6:  		/* addi R3, R1, 80 */
		/* 820AB504h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AB504h case    6:*/		return 0x820AB508;
		  /* 820AB508h */ case    7:  		/* bl 142576 */
		/* 820AB508h case    7:*/		regs.LR = 0x820AB50C; return 0x820CE1F8;
		/* 820AB508h case    7:*/		return 0x820AB50C;
		  /* 820AB50Ch */ case    8:  		/* mr R3, R30 */
		/* 820AB50Ch case    8:*/		regs.R3 = regs.R30;
		/* 820AB50Ch case    8:*/		return 0x820AB510;
		  /* 820AB510h */ case    9:  		/* addi R1, R1, 208 */
		/* 820AB510h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820AB510h case    9:*/		return 0x820AB514;
		  /* 820AB514h */ case   10:  		/* b -107136 */
		/* 820AB514h case   10:*/		return 0x82091294;
		/* 820AB514h case   10:*/		return 0x820AB518;
	}
	return 0x820AB518;
} // Block from 820AB4ECh-820AB518h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AB518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB518);
		  /* 820AB518h */ case    0:  		/* mfspr R12, LR */
		/* 820AB518h case    0:*/		regs.R12 = regs.LR;
		/* 820AB518h case    0:*/		return 0x820AB51C;
		  /* 820AB51Ch */ case    1:  		/* bl -107224 */
		/* 820AB51Ch case    1:*/		regs.LR = 0x820AB520; return 0x82091244;
		/* 820AB51Ch case    1:*/		return 0x820AB520;
		  /* 820AB520h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820AB520h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820AB520h case    2:*/		return 0x820AB524;
		  /* 820AB524h */ case    3:  		/* lis R4, 18261 */
		/* 820AB524h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x4755);
		/* 820AB524h case    3:*/		return 0x820AB528;
		  /* 820AB528h */ case    4:  		/* mr R30, R3 */
		/* 820AB528h case    4:*/		regs.R30 = regs.R3;
		/* 820AB528h case    4:*/		return 0x820AB52C;
		  /* 820AB52Ch */ case    5:  		/* addi R3, R1, 96 */
		/* 820AB52Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB52Ch case    5:*/		return 0x820AB530;
		  /* 820AB530h */ case    6:  		/* ori R4, R4, 16964 */
		/* 820AB530h case    6:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x4244);
		/* 820AB530h case    6:*/		return 0x820AB534;
		  /* 820AB534h */ case    7:  		/* bl 142476 */
		/* 820AB534h case    7:*/		regs.LR = 0x820AB538; return 0x820CE1C0;
		/* 820AB534h case    7:*/		return 0x820AB538;
		  /* 820AB538h */ case    8:  		/* addi R11, R1, 112 */
		/* 820AB538h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AB538h case    8:*/		return 0x820AB53C;
		  /* 820AB53Ch */ case    9:  		/* li R24, 0 */
		/* 820AB53Ch case    9:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820AB53Ch case    9:*/		return 0x820AB540;
		  /* 820AB540h */ case   10:  		/* li R10, 40 */
		/* 820AB540h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x28);
		/* 820AB540h case   10:*/		return 0x820AB544;
		  /* 820AB544h */ case   11:  		/* li R8, 0 */
		/* 820AB544h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820AB544h case   11:*/		return 0x820AB548;
		  /* 820AB548h */ case   12:  		/* li R7, 0 */
		/* 820AB548h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820AB548h case   12:*/		return 0x820AB54C;
		  /* 820AB54Ch */ case   13:  		/* std R24, <#[R11]> */
		/* 820AB54Ch case   13:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 820AB54Ch case   13:*/		return 0x820AB550;
		  /* 820AB550h */ case   14:  		/* li R6, 1 */
		/* 820AB550h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820AB550h case   14:*/		return 0x820AB554;
		  /* 820AB554h */ case   15:  		/* std R24, <#[R11 + 8]> */
		/* 820AB554h case   15:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R11 + 0x00000008) );
		/* 820AB554h case   15:*/		return 0x820AB558;
		  /* 820AB558h */ case   16:  		/* li R5, 40 */
		/* 820AB558h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x28);
		/* 820AB558h case   16:*/		return 0x820AB55C;
		  /* 820AB55Ch */ case   17:  		/* std R24, <#[R11 + 16]> */
		/* 820AB55Ch case   17:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R11 + 0x00000010) );
		/* 820AB55Ch case   17:*/		return 0x820AB560;
		  /* 820AB560h */ case   18:  		/* addi R4, R1, 112 */
		/* 820AB560h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820AB560h case   18:*/		return 0x820AB564;
		  /* 820AB564h */ case   19:  		/* std R24, <#[R11 + 24]> */
		/* 820AB564h case   19:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R11 + 0x00000018) );
		/* 820AB564h case   19:*/		return 0x820AB568;
		  /* 820AB568h */ case   20:  		/* addi R3, R1, 96 */
		/* 820AB568h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB568h case   20:*/		return 0x820AB56C;
		  /* 820AB56Ch */ case   21:  		/* std R24, <#[R11 + 32]> */
		/* 820AB56Ch case   21:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R11 + 0x00000020) );
		/* 820AB56Ch case   21:*/		return 0x820AB570;
		  /* 820AB570h */ case   22:  		/* stw R10, <#[R1 + 112]> */
		/* 820AB570h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820AB570h case   22:*/		return 0x820AB574;
		  /* 820AB574h */ case   23:  		/* mr R23, R24 */
		/* 820AB574h case   23:*/		regs.R23 = regs.R24;
		/* 820AB574h case   23:*/		return 0x820AB578;
		  /* 820AB578h */ case   24:  		/* mr R25, R24 */
		/* 820AB578h case   24:*/		regs.R25 = regs.R24;
		/* 820AB578h case   24:*/		return 0x820AB57C;
		  /* 820AB57Ch */ case   25:  		/* bl 142580 */
		/* 820AB57Ch case   25:*/		regs.LR = 0x820AB580; return 0x820CE270;
		/* 820AB57Ch case   25:*/		return 0x820AB580;
		  /* 820AB580h */ case   26:  		/* or. R28, R3, R3 */
		/* 820AB580h case   26:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820AB580h case   26:*/		return 0x820AB584;
		  /* 820AB584h */ case   27:  		/* bc 12, CR0_LT, 888 */
		/* 820AB584h case   27:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB584h case   27:*/		return 0x820AB588;
		  /* 820AB588h */ case   28:  		/* lwz R11, <#[R30 + 60]> */
		/* 820AB588h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 820AB588h case   28:*/		return 0x820AB58C;
		  /* 820AB58Ch */ case   29:  		/* mr R31, R24 */
		/* 820AB58Ch case   29:*/		regs.R31 = regs.R24;
		/* 820AB58Ch case   29:*/		return 0x820AB590;
		  /* 820AB590h */ case   30:  		/* b 32 */
		/* 820AB590h case   30:*/		return 0x820AB5B0;
		/* 820AB590h case   30:*/		return 0x820AB594;
		  /* 820AB594h */ case   31:  		/* lwz R10, <#[R11 + 8]> */
		/* 820AB594h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820AB594h case   31:*/		return 0x820AB598;
		  /* 820AB598h */ case   32:  		/* cmplwi CR6, R10, 0 */
		/* 820AB598h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AB598h case   32:*/		return 0x820AB59C;
		  /* 820AB59Ch */ case   33:  		/* bc 12, CR6_EQ, 16 */
		/* 820AB59Ch case   33:*/		if ( regs.CR[6].eq ) { return 0x820AB5AC;  }
		/* 820AB59Ch case   33:*/		return 0x820AB5A0;
		  /* 820AB5A0h */ case   34:  		/* lwz R9, <#[R10 + 4]> */
		/* 820AB5A0h case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820AB5A0h case   34:*/		return 0x820AB5A4;
		  /* 820AB5A4h */ case   35:  		/* cmpwi CR6, R9, 24 */
		/* 820AB5A4h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000018);
		/* 820AB5A4h case   35:*/		return 0x820AB5A8;
		  /* 820AB5A8h */ case   36:  		/* bc 12, CR6_EQ, 20 */
		/* 820AB5A8h case   36:*/		if ( regs.CR[6].eq ) { return 0x820AB5BC;  }
		/* 820AB5A8h case   36:*/		return 0x820AB5AC;
	}
	return 0x820AB5AC;
} // Block from 820AB518h-820AB5ACh (37 instructions)

//////////////////////////////////////////////////////
// Block at 820AB5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB5AC);
		  /* 820AB5ACh */ case    0:  		/* lwz R11, <#[R11 + 12]> */
		/* 820AB5ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820AB5ACh case    0:*/		return 0x820AB5B0;
	}
	return 0x820AB5B0;
} // Block from 820AB5ACh-820AB5B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AB5B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB5B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB5B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB5B0);
		  /* 820AB5B0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820AB5B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AB5B0h case    0:*/		return 0x820AB5B4;
		  /* 820AB5B4h */ case    1:  		/* bc 4, CR6_EQ, -32 */
		/* 820AB5B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AB594;  }
		/* 820AB5B4h case    1:*/		return 0x820AB5B8;
		  /* 820AB5B8h */ case    2:  		/* b 8 */
		/* 820AB5B8h case    2:*/		return 0x820AB5C0;
		/* 820AB5B8h case    2:*/		return 0x820AB5BC;
	}
	return 0x820AB5BC;
} // Block from 820AB5B0h-820AB5BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AB5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB5BC);
		  /* 820AB5BCh */ case    0:  		/* mr R31, R10 */
		/* 820AB5BCh case    0:*/		regs.R31 = regs.R10;
		/* 820AB5BCh case    0:*/		return 0x820AB5C0;
	}
	return 0x820AB5C0;
} // Block from 820AB5BCh-820AB5C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AB5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB5C0);
		  /* 820AB5C0h */ case    0:  		/* lwz R11, <#[R1 + 132]> */
		/* 820AB5C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB5C0h case    0:*/		return 0x820AB5C4;
		  /* 820AB5C4h */ case    1:  		/* mr R10, R31 */
		/* 820AB5C4h case    1:*/		regs.R10 = regs.R31;
		/* 820AB5C4h case    1:*/		return 0x820AB5C8;
		  /* 820AB5C8h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820AB5C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AB5C8h case    2:*/		return 0x820AB5CC;
		  /* 820AB5CCh */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820AB5CCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820AB5E4;  }
		/* 820AB5CCh case    3:*/		return 0x820AB5D0;
		  /* 820AB5D0h */ case    4:  		/* addi R11, R11, 1 */
		/* 820AB5D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AB5D0h case    4:*/		return 0x820AB5D4;
		  /* 820AB5D4h */ case    5:  		/* stw R11, <#[R1 + 132]> */
		/* 820AB5D4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB5D4h case    5:*/		return 0x820AB5D8;
		  /* 820AB5D8h */ case    6:  		/* lwz R10, <#[R10 + 12]> */
		/* 820AB5D8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820AB5D8h case    6:*/		return 0x820AB5DC;
		  /* 820AB5DCh */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820AB5DCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AB5DCh case    7:*/		return 0x820AB5E0;
		  /* 820AB5E0h */ case    8:  		/* bc 4, CR6_EQ, -16 */
		/* 820AB5E0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820AB5D0;  }
		/* 820AB5E0h case    8:*/		return 0x820AB5E4;
	}
	return 0x820AB5E4;
} // Block from 820AB5C0h-820AB5E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AB5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB5E4);
		  /* 820AB5E4h */ case    0:  		/* li R26, -1 */
		/* 820AB5E4h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 820AB5E4h case    0:*/		return 0x820AB5E8;
		  /* 820AB5E8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AB5E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AB5E8h case    1:*/		return 0x820AB5EC;
		  /* 820AB5ECh */ case    2:  		/* bc 12, CR6_EQ, 388 */
		/* 820AB5ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x820AB770;  }
		/* 820AB5ECh case    2:*/		return 0x820AB5F0;
		  /* 820AB5F0h */ case    3:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820AB5F0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820AB5F0h case    3:*/		return 0x820AB5F4;
		  /* 820AB5F4h */ case    4:  		/* lis R4, 9345 */
		/* 820AB5F4h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB5F4h case    4:*/		return 0x820AB5F8;
		  /* 820AB5F8h */ case    5:  		/* bl -144376 */
		/* 820AB5F8h case    5:*/		regs.LR = 0x820AB5FC; return 0x82088200;
		/* 820AB5F8h case    5:*/		return 0x820AB5FC;
		  /* 820AB5FCh */ case    6:  		/* or. R23, R3, R3 */
		/* 820AB5FCh case    6:*/		cpu::op::or<1>(regs,&regs.R23,regs.R3,regs.R3);
		/* 820AB5FCh case    6:*/		return 0x820AB600;
		  /* 820AB600h */ case    7:  		/* bc 12, CR0_EQ, 48 */
		/* 820AB600h case    7:*/		if ( regs.CR[0].eq ) { return 0x820AB630;  }
		/* 820AB600h case    7:*/		return 0x820AB604;
		  /* 820AB604h */ case    8:  		/* lwz R11, <#[R1 + 132]> */
		/* 820AB604h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB604h case    8:*/		return 0x820AB608;
		  /* 820AB608h */ case    9:  		/* li R4, 0 */
		/* 820AB608h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AB608h case    9:*/		return 0x820AB60C;
		  /* 820AB60Ch */ case   10:  		/* mr R3, R23 */
		/* 820AB60Ch case   10:*/		regs.R3 = regs.R23;
		/* 820AB60Ch case   10:*/		return 0x820AB610;
		  /* 820AB610h */ case   11:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820AB610h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820AB610h case   11:*/		return 0x820AB614;
		  /* 820AB614h */ case   12:  		/* bl -107220 */
		/* 820AB614h case   12:*/		regs.LR = 0x820AB618; return 0x82091340;
		/* 820AB614h case   12:*/		return 0x820AB618;
		  /* 820AB618h */ case   13:  		/* lwz R11, <#[R1 + 132]> */
		/* 820AB618h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB618h case   13:*/		return 0x820AB61C;
		  /* 820AB61Ch */ case   14:  		/* lis R4, 9345 */
		/* 820AB61Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB61Ch case   14:*/		return 0x820AB620;
		  /* 820AB620h */ case   15:  		/* rlwinm R3, R11, 3, 0, 28 */
		/* 820AB620h case   15:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R11);
		/* 820AB620h case   15:*/		return 0x820AB624;
		  /* 820AB624h */ case   16:  		/* bl -144420 */
		/* 820AB624h case   16:*/		regs.LR = 0x820AB628; return 0x82088200;
		/* 820AB624h case   16:*/		return 0x820AB628;
		  /* 820AB628h */ case   17:  		/* or. R25, R3, R3 */
		/* 820AB628h case   17:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820AB628h case   17:*/		return 0x820AB62C;
		  /* 820AB62Ch */ case   18:  		/* bc 4, CR0_EQ, 16 */
		/* 820AB62Ch case   18:*/		if ( !regs.CR[0].eq ) { return 0x820AB63C;  }
		/* 820AB62Ch case   18:*/		return 0x820AB630;
	}
	return 0x820AB630;
} // Block from 820AB5E4h-820AB630h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820AB630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB630);
		  /* 820AB630h */ case    0:  		/* lis R28, -32761 */
		/* 820AB630h case    0:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8007);
		/* 820AB630h case    0:*/		return 0x820AB634;
		  /* 820AB634h */ case    1:  		/* ori R28, R28, 14 */
		/* 820AB634h case    1:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R28,0xE);
		/* 820AB634h case    1:*/		return 0x820AB638;
		  /* 820AB638h */ case    2:  		/* b 708 */
		/* 820AB638h case    2:*/		return 0x820AB8FC;
		/* 820AB638h case    2:*/		return 0x820AB63C;
	}
	return 0x820AB63C;
} // Block from 820AB630h-820AB63Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AB63Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB63C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB63C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB63C);
		  /* 820AB63Ch */ case    0:  		/* lwz R11, <#[R1 + 132]> */
		/* 820AB63Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB63Ch case    0:*/		return 0x820AB640;
		  /* 820AB640h */ case    1:  		/* li R4, 0 */
		/* 820AB640h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AB640h case    1:*/		return 0x820AB644;
		  /* 820AB644h */ case    2:  		/* mr R3, R25 */
		/* 820AB644h case    2:*/		regs.R3 = regs.R25;
		/* 820AB644h case    2:*/		return 0x820AB648;
		  /* 820AB648h */ case    3:  		/* rlwinm R27, R11, 3, 0, 28 */
		/* 820AB648h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R27,regs.R11);
		/* 820AB648h case    3:*/		return 0x820AB64C;
		  /* 820AB64Ch */ case    4:  		/* mr R5, R27 */
		/* 820AB64Ch case    4:*/		regs.R5 = regs.R27;
		/* 820AB64Ch case    4:*/		return 0x820AB650;
		  /* 820AB650h */ case    5:  		/* bl -107280 */
		/* 820AB650h case    5:*/		regs.LR = 0x820AB654; return 0x82091340;
		/* 820AB650h case    5:*/		return 0x820AB654;
		  /* 820AB654h */ case    6:  		/* lwz R11, <#[R1 + 132]> */
		/* 820AB654h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB654h case    6:*/		return 0x820AB658;
		  /* 820AB658h */ case    7:  		/* mr R29, R31 */
		/* 820AB658h case    7:*/		regs.R29 = regs.R31;
		/* 820AB658h case    7:*/		return 0x820AB65C;
		  /* 820AB65Ch */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 820AB65Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820AB65Ch case    8:*/		return 0x820AB660;
		  /* 820AB660h */ case    9:  		/* addi R11, R11, -1 */
		/* 820AB660h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820AB660h case    9:*/		return 0x820AB664;
		  /* 820AB664h */ case   10:  		/* bc 12, CR6_EQ, 184 */
		/* 820AB664h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AB71C;  }
		/* 820AB664h case   10:*/		return 0x820AB668;
		  /* 820AB668h */ case   11:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 820AB668h case   11:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 820AB668h case   11:*/		return 0x820AB66C;
		  /* 820AB66Ch */ case   12:  		/* add R11, R11, R25 */
		/* 820AB66Ch case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 820AB66Ch case   12:*/		return 0x820AB670;
		  /* 820AB670h */ case   13:  		/* addi R31, R11, 2 */
		/* 820AB670h case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x2);
		/* 820AB670h case   13:*/		return 0x820AB674;
		  /* 820AB674h */ case   14:  		/* li R11, -1 */
		/* 820AB674h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820AB674h case   14:*/		return 0x820AB678;
		  /* 820AB678h */ case   15:  		/* sth R11, <#[R31]> */
		/* 820AB678h case   15:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AB678h case   15:*/		return 0x820AB67C;
		  /* 820AB67Ch */ case   16:  		/* lwz R11, <#[R29 + 40]> */
		/* 820AB67Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000028) );
		/* 820AB67Ch case   16:*/		return 0x820AB680;
		  /* 820AB680h */ case   17:  		/* sth R11, <#[R31 - 2]> */
		/* 820AB680h case   17:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFFE) );
		/* 820AB680h case   17:*/		return 0x820AB684;
		  /* 820AB684h */ case   18:  		/* lwz R11, <#[R29 + 96]> */
		/* 820AB684h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000060) );
		/* 820AB684h case   18:*/		return 0x820AB688;
		  /* 820AB688h */ case   19:  		/* stw R11, <#[R31 + 2]> */
		/* 820AB688h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 820AB688h case   19:*/		return 0x820AB68C;
		  /* 820AB68Ch */ case   20:  		/* lwz R4, <#[R29 + 32]> */
		/* 820AB68Ch case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000020) );
		/* 820AB68Ch case   20:*/		return 0x820AB690;
		  /* 820AB690h */ case   21:  		/* cmplwi CR6, R4, 0 */
		/* 820AB690h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820AB690h case   21:*/		return 0x820AB694;
		  /* 820AB694h */ case   22:  		/* bc 12, CR6_EQ, 120 */
		/* 820AB694h case   22:*/		if ( regs.CR[6].eq ) { return 0x820AB70C;  }
		/* 820AB694h case   22:*/		return 0x820AB698;
		  /* 820AB698h */ case   23:  		/* li R8, 1 */
		/* 820AB698h case   23:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820AB698h case   23:*/		return 0x820AB69C;
		  /* 820AB69Ch */ case   24:  		/* addi R7, R1, 80 */
		/* 820AB69Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820AB69Ch case   24:*/		return 0x820AB6A0;
		  /* 820AB6A0h */ case   25:  		/* li R6, 7 */
		/* 820AB6A0h case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820AB6A0h case   25:*/		return 0x820AB6A4;
		  /* 820AB6A4h */ case   26:  		/* mr R5, R26 */
		/* 820AB6A4h case   26:*/		regs.R5 = regs.R26;
		/* 820AB6A4h case   26:*/		return 0x820AB6A8;
		  /* 820AB6A8h */ case   27:  		/* addi R3, R1, 96 */
		/* 820AB6A8h case   27:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB6A8h case   27:*/		return 0x820AB6AC;
		  /* 820AB6ACh */ case   28:  		/* bl 142276 */
		/* 820AB6ACh case   28:*/		regs.LR = 0x820AB6B0; return 0x820CE270;
		/* 820AB6ACh case   28:*/		return 0x820AB6B0;
		  /* 820AB6B0h */ case   29:  		/* cmpwi CR0, R3, 0 */
		/* 820AB6B0h case   29:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AB6B0h case   29:*/		return 0x820AB6B4;
		  /* 820AB6B4h */ case   30:  		/* bc 12, CR0_LT, 584 */
		/* 820AB6B4h case   30:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB6B4h case   30:*/		return 0x820AB6B8;
		  /* 820AB6B8h */ case   31:  		/* lwz R9, <#[R1 + 124]> */
		/* 820AB6B8h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 820AB6B8h case   31:*/		return 0x820AB6BC;
		  /* 820AB6BCh */ case   32:  		/* mr R10, R24 */
		/* 820AB6BCh case   32:*/		regs.R10 = regs.R24;
		/* 820AB6BCh case   32:*/		return 0x820AB6C0;
		  /* 820AB6C0h */ case   33:  		/* lwz R8, <#[R1 + 80]> */
		/* 820AB6C0h case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820AB6C0h case   33:*/		return 0x820AB6C4;
		  /* 820AB6C4h */ case   34:  		/* cmplwi CR6, R9, 0 */
		/* 820AB6C4h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820AB6C4h case   34:*/		return 0x820AB6C8;
		  /* 820AB6C8h */ case   35:  		/* bc 12, CR6_EQ, 36 */
		/* 820AB6C8h case   35:*/		if ( regs.CR[6].eq ) { return 0x820AB6EC;  }
		/* 820AB6C8h case   35:*/		return 0x820AB6CC;
		  /* 820AB6CCh */ case   36:  		/* mr R11, R23 */
		/* 820AB6CCh case   36:*/		regs.R11 = regs.R23;
		/* 820AB6CCh case   36:*/		return 0x820AB6D0;
		  /* 820AB6D0h */ case   37:  		/* lwz R7, <#[R11]> */
		/* 820AB6D0h case   37:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820AB6D0h case   37:*/		return 0x820AB6D4;
		  /* 820AB6D4h */ case   38:  		/* cmplw CR6, R7, R8 */
		/* 820AB6D4h case   38:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820AB6D4h case   38:*/		return 0x820AB6D8;
		  /* 820AB6D8h */ case   39:  		/* bc 12, CR6_EQ, 20 */
		/* 820AB6D8h case   39:*/		if ( regs.CR[6].eq ) { return 0x820AB6EC;  }
		/* 820AB6D8h case   39:*/		return 0x820AB6DC;
		  /* 820AB6DCh */ case   40:  		/* addi R10, R10, 1 */
		/* 820AB6DCh case   40:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AB6DCh case   40:*/		return 0x820AB6E0;
		  /* 820AB6E0h */ case   41:  		/* addi R11, R11, 4 */
		/* 820AB6E0h case   41:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820AB6E0h case   41:*/		return 0x820AB6E4;
		  /* 820AB6E4h */ case   42:  		/* cmplw CR6, R10, R9 */
		/* 820AB6E4h case   42:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820AB6E4h case   42:*/		return 0x820AB6E8;
		  /* 820AB6E8h */ case   43:  		/* bc 12, CR6_LT, -24 */
		/* 820AB6E8h case   43:*/		if ( regs.CR[6].lt ) { return 0x820AB6D0;  }
		/* 820AB6E8h case   43:*/		return 0x820AB6EC;
	}
	return 0x820AB6EC;
} // Block from 820AB63Ch-820AB6ECh (44 instructions)

//////////////////////////////////////////////////////
// Block at 820AB6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB6EC);
		  /* 820AB6ECh */ case    0:  		/* cmplw CR6, R10, R9 */
		/* 820AB6ECh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820AB6ECh case    0:*/		return 0x820AB6F0;
		  /* 820AB6F0h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 820AB6F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AB708;  }
		/* 820AB6F0h case    1:*/		return 0x820AB6F4;
		  /* 820AB6F4h */ case    2:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 820AB6F4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 820AB6F4h case    2:*/		return 0x820AB6F8;
		  /* 820AB6F8h */ case    3:  		/* stwx R8, <#[R11 + R23]> */
		/* 820AB6F8h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 820AB6F8h case    3:*/		return 0x820AB6FC;
		  /* 820AB6FCh */ case    4:  		/* lwz R11, <#[R1 + 124]> */
		/* 820AB6FCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820AB6FCh case    4:*/		return 0x820AB700;
		  /* 820AB700h */ case    5:  		/* addi R11, R11, 1 */
		/* 820AB700h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AB700h case    5:*/		return 0x820AB704;
		  /* 820AB704h */ case    6:  		/* stw R11, <#[R1 + 124]> */
		/* 820AB704h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820AB704h case    6:*/		return 0x820AB708;
	}
	return 0x820AB708;
} // Block from 820AB6ECh-820AB708h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AB708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB708);
		  /* 820AB708h */ case    0:  		/* sth R10, <#[R31]> */
		/* 820AB708h case    0:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820AB708h case    0:*/		return 0x820AB70C;
	}
	return 0x820AB70C;
} // Block from 820AB708h-820AB70Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AB70Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB70C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB70C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB70C);
		  /* 820AB70Ch */ case    0:  		/* lwz R29, <#[R29 + 12]> */
		/* 820AB70Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000000C) );
		/* 820AB70Ch case    0:*/		return 0x820AB710;
		  /* 820AB710h */ case    1:  		/* addi R31, R31, -8 */
		/* 820AB710h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFF8);
		/* 820AB710h case    1:*/		return 0x820AB714;
		  /* 820AB714h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 820AB714h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820AB714h case    2:*/		return 0x820AB718;
		  /* 820AB718h */ case    3:  		/* bc 4, CR6_EQ, -164 */
		/* 820AB718h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AB674;  }
		/* 820AB718h case    3:*/		return 0x820AB71C;
	}
	return 0x820AB71C;
} // Block from 820AB70Ch-820AB71Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AB71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB71C);
		  /* 820AB71Ch */ case    0:  		/* lwz R11, <#[R1 + 124]> */
		/* 820AB71Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820AB71Ch case    0:*/		return 0x820AB720;
		  /* 820AB720h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AB720h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AB720h case    1:*/		return 0x820AB724;
		  /* 820AB724h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820AB724h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AB74C;  }
		/* 820AB724h case    2:*/		return 0x820AB728;
		  /* 820AB728h */ case    3:  		/* li R8, 10 */
		/* 820AB728h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0xA);
		/* 820AB728h case    3:*/		return 0x820AB72C;
		  /* 820AB72Ch */ case    4:  		/* addi R7, R1, 128 */
		/* 820AB72Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 820AB72Ch case    4:*/		return 0x820AB730;
		  /* 820AB730h */ case    5:  		/* li R6, 1 */
		/* 820AB730h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820AB730h case    5:*/		return 0x820AB734;
		  /* 820AB734h */ case    6:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820AB734h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820AB734h case    6:*/		return 0x820AB738;
		  /* 820AB738h */ case    7:  		/* mr R4, R23 */
		/* 820AB738h case    7:*/		regs.R4 = regs.R23;
		/* 820AB738h case    7:*/		return 0x820AB73C;
		  /* 820AB73Ch */ case    8:  		/* addi R3, R1, 96 */
		/* 820AB73Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB73Ch case    8:*/		return 0x820AB740;
		  /* 820AB740h */ case    9:  		/* bl 142128 */
		/* 820AB740h case    9:*/		regs.LR = 0x820AB744; return 0x820CE270;
		/* 820AB740h case    9:*/		return 0x820AB744;
		  /* 820AB744h */ case   10:  		/* or. R28, R3, R3 */
		/* 820AB744h case   10:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820AB744h case   10:*/		return 0x820AB748;
		  /* 820AB748h */ case   11:  		/* bc 12, CR0_LT, 436 */
		/* 820AB748h case   11:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB748h case   11:*/		return 0x820AB74C;
	}
	return 0x820AB74C;
} // Block from 820AB71Ch-820AB74Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AB74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB74C);
		  /* 820AB74Ch */ case    0:  		/* li R8, 5 */
		/* 820AB74Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x5);
		/* 820AB74Ch case    0:*/		return 0x820AB750;
		  /* 820AB750h */ case    1:  		/* addi R7, R1, 136 */
		/* 820AB750h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x88);
		/* 820AB750h case    1:*/		return 0x820AB754;
		  /* 820AB754h */ case    2:  		/* li R6, 1 */
		/* 820AB754h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820AB754h case    2:*/		return 0x820AB758;
		  /* 820AB758h */ case    3:  		/* mr R5, R27 */
		/* 820AB758h case    3:*/		regs.R5 = regs.R27;
		/* 820AB758h case    3:*/		return 0x820AB75C;
		  /* 820AB75Ch */ case    4:  		/* mr R4, R25 */
		/* 820AB75Ch case    4:*/		regs.R4 = regs.R25;
		/* 820AB75Ch case    4:*/		return 0x820AB760;
		  /* 820AB760h */ case    5:  		/* addi R3, R1, 96 */
		/* 820AB760h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB760h case    5:*/		return 0x820AB764;
		  /* 820AB764h */ case    6:  		/* bl 142092 */
		/* 820AB764h case    6:*/		regs.LR = 0x820AB768; return 0x820CE270;
		/* 820AB764h case    6:*/		return 0x820AB768;
		  /* 820AB768h */ case    7:  		/* or. R28, R3, R3 */
		/* 820AB768h case    7:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820AB768h case    7:*/		return 0x820AB76C;
		  /* 820AB76Ch */ case    8:  		/* bc 12, CR0_LT, 400 */
		/* 820AB76Ch case    8:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB76Ch case    8:*/		return 0x820AB770;
	}
	return 0x820AB770;
} // Block from 820AB74Ch-820AB770h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AB770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB770);
		  /* 820AB770h */ case    0:  		/* lwz R4, <#[R30 + 128]> */
		/* 820AB770h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000080) );
		/* 820AB770h case    0:*/		return 0x820AB774;
		  /* 820AB774h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820AB774h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820AB774h case    1:*/		return 0x820AB778;
		  /* 820AB778h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820AB778h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AB79C;  }
		/* 820AB778h case    2:*/		return 0x820AB77C;
		  /* 820AB77Ch */ case    3:  		/* li R8, 1 */
		/* 820AB77Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820AB77Ch case    3:*/		return 0x820AB780;
		  /* 820AB780h */ case    4:  		/* addi R7, R1, 148 */
		/* 820AB780h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x94);
		/* 820AB780h case    4:*/		return 0x820AB784;
		  /* 820AB784h */ case    5:  		/* li R6, 7 */
		/* 820AB784h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 820AB784h case    5:*/		return 0x820AB788;
		  /* 820AB788h */ case    6:  		/* mr R5, R26 */
		/* 820AB788h case    6:*/		regs.R5 = regs.R26;
		/* 820AB788h case    6:*/		return 0x820AB78C;
		  /* 820AB78Ch */ case    7:  		/* addi R3, R1, 96 */
		/* 820AB78Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB78Ch case    7:*/		return 0x820AB790;
		  /* 820AB790h */ case    8:  		/* bl 142048 */
		/* 820AB790h case    8:*/		regs.LR = 0x820AB794; return 0x820CE270;
		/* 820AB790h case    8:*/		return 0x820AB794;
		  /* 820AB794h */ case    9:  		/* or. R28, R3, R3 */
		/* 820AB794h case    9:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820AB794h case    9:*/		return 0x820AB798;
		  /* 820AB798h */ case   10:  		/* bc 12, CR0_LT, 356 */
		/* 820AB798h case   10:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB798h case   10:*/		return 0x820AB79C;
	}
	return 0x820AB79C;
} // Block from 820AB770h-820AB79Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AB79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB79C);
		  /* 820AB79Ch */ case    0:  		/* lwz R4, <#[R30 + 120]> */
		/* 820AB79Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000078) );
		/* 820AB79Ch case    0:*/		return 0x820AB7A0;
		  /* 820AB7A0h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820AB7A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820AB7A0h case    1:*/		return 0x820AB7A4;
		  /* 820AB7A4h */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 820AB7A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AB7F0;  }
		/* 820AB7A4h case    2:*/		return 0x820AB7A8;
		  /* 820AB7A8h */ case    3:  		/* li R8, 1 */
		/* 820AB7A8h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820AB7A8h case    3:*/		return 0x820AB7AC;
		  /* 820AB7ACh */ case    4:  		/* lwz R5, <#[R30 + 124]> */
		/* 820AB7ACh case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000007C) );
		/* 820AB7ACh case    4:*/		return 0x820AB7B0;
		  /* 820AB7B0h */ case    5:  		/* addi R7, R1, 120 */
		/* 820AB7B0h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 820AB7B0h case    5:*/		return 0x820AB7B4;
		  /* 820AB7B4h */ case    6:  		/* li R6, 5 */
		/* 820AB7B4h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820AB7B4h case    6:*/		return 0x820AB7B8;
		  /* 820AB7B8h */ case    7:  		/* addi R3, R1, 96 */
		/* 820AB7B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB7B8h case    7:*/		return 0x820AB7BC;
		  /* 820AB7BCh */ case    8:  		/* bl 142004 */
		/* 820AB7BCh case    8:*/		regs.LR = 0x820AB7C0; return 0x820CE270;
		/* 820AB7BCh case    8:*/		return 0x820AB7C0;
		  /* 820AB7C0h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820AB7C0h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AB7C0h case    9:*/		return 0x820AB7C4;
		  /* 820AB7C4h */ case   10:  		/* bc 12, CR0_LT, 312 */
		/* 820AB7C4h case   10:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB7C4h case   10:*/		return 0x820AB7C8;
		  /* 820AB7C8h */ case   11:  		/* lis R11, -32256 */
		/* 820AB7C8h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820AB7C8h case   11:*/		return 0x820AB7CC;
		  /* 820AB7CCh */ case   12:  		/* li R8, 1 */
		/* 820AB7CCh case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820AB7CCh case   12:*/		return 0x820AB7D0;
		  /* 820AB7D0h */ case   13:  		/* addi R4, R11, 4485 */
		/* 820AB7D0h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1185);
		/* 820AB7D0h case   13:*/		return 0x820AB7D4;
		  /* 820AB7D4h */ case   14:  		/* li R7, 0 */
		/* 820AB7D4h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820AB7D4h case   14:*/		return 0x820AB7D8;
		  /* 820AB7D8h */ case   15:  		/* li R6, 5 */
		/* 820AB7D8h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820AB7D8h case   15:*/		return 0x820AB7DC;
		  /* 820AB7DCh */ case   16:  		/* li R5, 1 */
		/* 820AB7DCh case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AB7DCh case   16:*/		return 0x820AB7E0;
		  /* 820AB7E0h */ case   17:  		/* addi R3, R1, 96 */
		/* 820AB7E0h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB7E0h case   17:*/		return 0x820AB7E4;
		  /* 820AB7E4h */ case   18:  		/* bl 141964 */
		/* 820AB7E4h case   18:*/		regs.LR = 0x820AB7E8; return 0x820CE270;
		/* 820AB7E4h case   18:*/		return 0x820AB7E8;
		  /* 820AB7E8h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820AB7E8h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AB7E8h case   19:*/		return 0x820AB7EC;
		  /* 820AB7ECh */ case   20:  		/* bc 12, CR0_LT, 272 */
		/* 820AB7ECh case   20:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB7ECh case   20:*/		return 0x820AB7F0;
	}
	return 0x820AB7F0;
} // Block from 820AB79Ch-820AB7F0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AB7F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB7F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB7F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB7F0);
		  /* 820AB7F0h */ case    0:  		/* lis R11, -32255 */
		/* 820AB7F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AB7F0h case    0:*/		return 0x820AB7F4;
		  /* 820AB7F4h */ case    1:  		/* li R8, 1 */
		/* 820AB7F4h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820AB7F4h case    1:*/		return 0x820AB7F8;
		  /* 820AB7F8h */ case    2:  		/* addi R4, R11, 4228 */
		/* 820AB7F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1084);
		/* 820AB7F8h case    2:*/		return 0x820AB7FC;
		  /* 820AB7FCh */ case    3:  		/* addi R7, R1, 116 */
		/* 820AB7FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 820AB7FCh case    3:*/		return 0x820AB800;
		  /* 820AB800h */ case    4:  		/* li R6, 5 */
		/* 820AB800h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 820AB800h case    4:*/		return 0x820AB804;
		  /* 820AB804h */ case    5:  		/* mr R5, R26 */
		/* 820AB804h case    5:*/		regs.R5 = regs.R26;
		/* 820AB804h case    5:*/		return 0x820AB808;
		  /* 820AB808h */ case    6:  		/* addi R3, R1, 96 */
		/* 820AB808h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB808h case    6:*/		return 0x820AB80C;
		  /* 820AB80Ch */ case    7:  		/* bl 141924 */
		/* 820AB80Ch case    7:*/		regs.LR = 0x820AB810; return 0x820CE270;
		/* 820AB80Ch case    7:*/		return 0x820AB810;
		  /* 820AB810h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820AB810h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AB810h case    8:*/		return 0x820AB814;
		  /* 820AB814h */ case    9:  		/* bc 12, CR0_LT, 232 */
		/* 820AB814h case    9:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB814h case    9:*/		return 0x820AB818;
		  /* 820AB818h */ case   10:  		/* addi R3, R1, 96 */
		/* 820AB818h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB818h case   10:*/		return 0x820AB81C;
		  /* 820AB81Ch */ case   11:  		/* bl 141764 */
		/* 820AB81Ch case   11:*/		regs.LR = 0x820AB820; return 0x820CE1E0;
		/* 820AB81Ch case   11:*/		return 0x820AB820;
		  /* 820AB820h */ case   12:  		/* mr R31, R3 */
		/* 820AB820h case   12:*/		regs.R31 = regs.R3;
		/* 820AB820h case   12:*/		return 0x820AB824;
		  /* 820AB824h */ case   13:  		/* cmplwi CR6, R3, 32768 */
		/* 820AB824h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00008000);
		/* 820AB824h case   13:*/		return 0x820AB828;
		  /* 820AB828h */ case   14:  		/* bc 12, CR6_GT, 184 */
		/* 820AB828h case   14:*/		if ( regs.CR[6].gt ) { return 0x820AB8E0;  }
		/* 820AB828h case   14:*/		return 0x820AB82C;
		  /* 820AB82Ch */ case   15:  		/* mr R4, R3 */
		/* 820AB82Ch case   15:*/		regs.R4 = regs.R3;
		/* 820AB82Ch case   15:*/		return 0x820AB830;
		  /* 820AB830h */ case   16:  		/* mr R3, R30 */
		/* 820AB830h case   16:*/		regs.R3 = regs.R30;
		/* 820AB830h case   16:*/		return 0x820AB834;
		  /* 820AB834h */ case   17:  		/* bl -4652 */
		/* 820AB834h case   17:*/		regs.LR = 0x820AB838; return 0x820AA608;
		/* 820AB834h case   17:*/		return 0x820AB838;
		  /* 820AB838h */ case   18:  		/* or. R28, R3, R3 */
		/* 820AB838h case   18:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820AB838h case   18:*/		return 0x820AB83C;
		  /* 820AB83Ch */ case   19:  		/* bc 12, CR0_LT, 192 */
		/* 820AB83Ch case   19:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB83Ch case   19:*/		return 0x820AB840;
		  /* 820AB840h */ case   20:  		/* lwz R10, <#[R30 + 104]> */
		/* 820AB840h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000068) );
		/* 820AB840h case   20:*/		return 0x820AB844;
		  /* 820AB844h */ case   21:  		/* addi R9, R31, 1 */
		/* 820AB844h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x1);
		/* 820AB844h case   21:*/		return 0x820AB848;
		  /* 820AB848h */ case   22:  		/* lwz R11, <#[R30 + 100]> */
		/* 820AB848h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000064) );
		/* 820AB848h case   22:*/		return 0x820AB84C;
		  /* 820AB84Ch */ case   23:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820AB84Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820AB84Ch case   23:*/		return 0x820AB850;
		  /* 820AB850h */ case   24:  		/* addi R10, R10, -1 */
		/* 820AB850h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820AB850h case   24:*/		return 0x820AB854;
		  /* 820AB854h */ case   25:  		/* addi R4, R11, 4 */
		/* 820AB854h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820AB854h case   25:*/		return 0x820AB858;
		  /* 820AB858h */ case   26:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820AB858h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820AB858h case   26:*/		return 0x820AB85C;
		  /* 820AB85Ch */ case   27:  		/* add R3, R9, R11 */
		/* 820AB85Ch case   27:*/		cpu::op::add<0>(regs,&regs.R3,regs.R9,regs.R11);
		/* 820AB85Ch case   27:*/		return 0x820AB860;
		  /* 820AB860h */ case   28:  		/* bl -104768 */
		/* 820AB860h case   28:*/		regs.LR = 0x820AB864; return 0x82091F20;
		/* 820AB860h case   28:*/		return 0x820AB864;
		  /* 820AB864h */ case   29:  		/* lwz R10, <#[R1 + 132]> */
		/* 820AB864h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB864h case   29:*/		return 0x820AB868;
		  /* 820AB868h */ case   30:  		/* mr R11, R24 */
		/* 820AB868h case   30:*/		regs.R11 = regs.R24;
		/* 820AB868h case   30:*/		return 0x820AB86C;
		  /* 820AB86Ch */ case   31:  		/* cmplwi CR6, R10, 0 */
		/* 820AB86Ch case   31:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AB86Ch case   31:*/		return 0x820AB870;
		  /* 820AB870h */ case   32:  		/* bc 12, CR6_EQ, 48 */
		/* 820AB870h case   32:*/		if ( regs.CR[6].eq ) { return 0x820AB8A0;  }
		/* 820AB870h case   32:*/		return 0x820AB874;
		  /* 820AB874h */ case   33:  		/* addi R10, R25, -4 */
		/* 820AB874h case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0xFFFFFFFC);
		/* 820AB874h case   33:*/		return 0x820AB878;
		  /* 820AB878h */ case   34:  		/* lwz R9, <#[R30 + 116]> */
		/* 820AB878h case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000074) );
		/* 820AB878h case   34:*/		return 0x820AB87C;
		  /* 820AB87Ch */ case   35:  		/* addi R11, R11, 1 */
		/* 820AB87Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AB87Ch case   35:*/		return 0x820AB880;
		  /* 820AB880h */ case   36:  		/* lwz R8, <#[R10 + 8]> */
		/* 820AB880h case   36:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820AB880h case   36:*/		return 0x820AB884;
		  /* 820AB884h */ case   37:  		/* add R9, R9, R31 */
		/* 820AB884h case   37:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R31);
		/* 820AB884h case   37:*/		return 0x820AB888;
		  /* 820AB888h */ case   38:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820AB888h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820AB888h case   38:*/		return 0x820AB88C;
		  /* 820AB88Ch */ case   39:  		/* add R9, R9, R8 */
		/* 820AB88Ch case   39:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820AB88Ch case   39:*/		return 0x820AB890;
		  /* 820AB890h */ case   40:  		/* stwu R9, <#[R10 + 8]> */
		/* 820AB890h case   40:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820AB890h case   40:*/		return 0x820AB894;
		  /* 820AB894h */ case   41:  		/* lwz R9, <#[R1 + 132]> */
		/* 820AB894h case   41:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000084) );
		/* 820AB894h case   41:*/		return 0x820AB898;
		  /* 820AB898h */ case   42:  		/* cmplw CR6, R11, R9 */
		/* 820AB898h case   42:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AB898h case   42:*/		return 0x820AB89C;
		  /* 820AB89Ch */ case   43:  		/* bc 12, CR6_LT, -36 */
		/* 820AB89Ch case   43:*/		if ( regs.CR[6].lt ) { return 0x820AB878;  }
		/* 820AB89Ch case   43:*/		return 0x820AB8A0;
	}
	return 0x820AB8A0;
} // Block from 820AB7F0h-820AB8A0h (44 instructions)

//////////////////////////////////////////////////////
// Block at 820AB8A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB8A0);
		  /* 820AB8A0h */ case    0:  		/* lwz R11, <#[R30 + 100]> */
		/* 820AB8A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000064) );
		/* 820AB8A0h case    0:*/		return 0x820AB8A4;
		  /* 820AB8A4h */ case    1:  		/* mr R5, R31 */
		/* 820AB8A4h case    1:*/		regs.R5 = regs.R31;
		/* 820AB8A4h case    1:*/		return 0x820AB8A8;
		  /* 820AB8A8h */ case    2:  		/* addi R3, R1, 96 */
		/* 820AB8A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB8A8h case    2:*/		return 0x820AB8AC;
		  /* 820AB8ACh */ case    3:  		/* lwz R6, <#[R30 + 92]> */
		/* 820AB8ACh case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000005C) );
		/* 820AB8ACh case    3:*/		return 0x820AB8B0;
		  /* 820AB8B0h */ case    4:  		/* addi R4, R11, 4 */
		/* 820AB8B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4);
		/* 820AB8B0h case    4:*/		return 0x820AB8B4;
		  /* 820AB8B4h */ case    5:  		/* bl 142492 */
		/* 820AB8B4h case    5:*/		regs.LR = 0x820AB8B8; return 0x820CE550;
		/* 820AB8B4h case    5:*/		return 0x820AB8B8;
		  /* 820AB8B8h */ case    6:  		/* or. R28, R3, R3 */
		/* 820AB8B8h case    6:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820AB8B8h case    6:*/		return 0x820AB8BC;
		  /* 820AB8BCh */ case    7:  		/* bc 12, CR0_LT, 64 */
		/* 820AB8BCh case    7:*/		if ( regs.CR[0].lt ) { return 0x820AB8FC;  }
		/* 820AB8BCh case    7:*/		return 0x820AB8C0;
		  /* 820AB8C0h */ case    8:  		/* lwz R11, <#[R30 + 104]> */
		/* 820AB8C0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000068) );
		/* 820AB8C0h case    8:*/		return 0x820AB8C4;
		  /* 820AB8C4h */ case    9:  		/* lwz R10, <#[R30 + 116]> */
		/* 820AB8C4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000074) );
		/* 820AB8C4h case    9:*/		return 0x820AB8C8;
		  /* 820AB8C8h */ case   10:  		/* add R11, R31, R11 */
		/* 820AB8C8h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820AB8C8h case   10:*/		return 0x820AB8CC;
		  /* 820AB8CCh */ case   11:  		/* add R10, R10, R31 */
		/* 820AB8CCh case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 820AB8CCh case   11:*/		return 0x820AB8D0;
		  /* 820AB8D0h */ case   12:  		/* stw R11, <#[R30 + 104]> */
		/* 820AB8D0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000068) );
		/* 820AB8D0h case   12:*/		return 0x820AB8D4;
		  /* 820AB8D4h */ case   13:  		/* stw R11, <#[R30 + 112]> */
		/* 820AB8D4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000070) );
		/* 820AB8D4h case   13:*/		return 0x820AB8D8;
		  /* 820AB8D8h */ case   14:  		/* stw R10, <#[R30 + 116]> */
		/* 820AB8D8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000074) );
		/* 820AB8D8h case   14:*/		return 0x820AB8DC;
		  /* 820AB8DCh */ case   15:  		/* b 28 */
		/* 820AB8DCh case   15:*/		return 0x820AB8F8;
		/* 820AB8DCh case   15:*/		return 0x820AB8E0;
	}
	return 0x820AB8E0;
} // Block from 820AB8A0h-820AB8E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820AB8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB8E0);
		  /* 820AB8E0h */ case    0:  		/* lis R11, -32255 */
		/* 820AB8E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AB8E0h case    0:*/		return 0x820AB8E4;
		  /* 820AB8E4h */ case    1:  		/* lwz R3, <#[R30]> */
		/* 820AB8E4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820AB8E4h case    1:*/		return 0x820AB8E8;
		  /* 820AB8E8h */ case    2:  		/* li R5, 2030 */
		/* 820AB8E8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7EE);
		/* 820AB8E8h case    2:*/		return 0x820AB8EC;
		  /* 820AB8ECh */ case    3:  		/* addi R6, R11, 4280 */
		/* 820AB8ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x10B8);
		/* 820AB8ECh case    3:*/		return 0x820AB8F0;
		  /* 820AB8F0h */ case    4:  		/* addi R4, R30, 16 */
		/* 820AB8F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820AB8F0h case    4:*/		return 0x820AB8F4;
		  /* 820AB8F4h */ case    5:  		/* bl -17820 */
		/* 820AB8F4h case    5:*/		regs.LR = 0x820AB8F8; return 0x820A7358;
		/* 820AB8F4h case    5:*/		return 0x820AB8F8;
	}
	return 0x820AB8F8;
} // Block from 820AB8E0h-820AB8F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AB8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB8F8);
		  /* 820AB8F8h */ case    0:  		/* mr R28, R24 */
		/* 820AB8F8h case    0:*/		regs.R28 = regs.R24;
		/* 820AB8F8h case    0:*/		return 0x820AB8FC;
	}
	return 0x820AB8FC;
} // Block from 820AB8F8h-820AB8FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AB8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB8FC);
		  /* 820AB8FCh */ case    0:  		/* lis R4, 9345 */
		/* 820AB8FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB8FCh case    0:*/		return 0x820AB900;
		  /* 820AB900h */ case    1:  		/* mr R3, R23 */
		/* 820AB900h case    1:*/		regs.R3 = regs.R23;
		/* 820AB900h case    1:*/		return 0x820AB904;
		  /* 820AB904h */ case    2:  		/* bl -144844 */
		/* 820AB904h case    2:*/		regs.LR = 0x820AB908; return 0x82088338;
		/* 820AB904h case    2:*/		return 0x820AB908;
		  /* 820AB908h */ case    3:  		/* lis R4, 9345 */
		/* 820AB908h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AB908h case    3:*/		return 0x820AB90C;
		  /* 820AB90Ch */ case    4:  		/* mr R3, R25 */
		/* 820AB90Ch case    4:*/		regs.R3 = regs.R25;
		/* 820AB90Ch case    4:*/		return 0x820AB910;
		  /* 820AB910h */ case    5:  		/* bl -144856 */
		/* 820AB910h case    5:*/		regs.LR = 0x820AB914; return 0x82088338;
		/* 820AB910h case    5:*/		return 0x820AB914;
		  /* 820AB914h */ case    6:  		/* addi R3, R1, 96 */
		/* 820AB914h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820AB914h case    6:*/		return 0x820AB918;
		  /* 820AB918h */ case    7:  		/* bl 141536 */
		/* 820AB918h case    7:*/		regs.LR = 0x820AB91C; return 0x820CE1F8;
		/* 820AB918h case    7:*/		return 0x820AB91C;
		  /* 820AB91Ch */ case    8:  		/* mr R3, R28 */
		/* 820AB91Ch case    8:*/		regs.R3 = regs.R28;
		/* 820AB91Ch case    8:*/		return 0x820AB920;
		  /* 820AB920h */ case    9:  		/* addi R1, R1, 240 */
		/* 820AB920h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820AB920h case    9:*/		return 0x820AB924;
		  /* 820AB924h */ case   10:  		/* b -108176 */
		/* 820AB924h case   10:*/		return 0x82091294;
		/* 820AB924h case   10:*/		return 0x820AB928;
		  /* 820AB928h */ case   11:  		/* b -9312 */
		/* 820AB928h case   11:*/		return 0x820A94C8;
		/* 820AB928h case   11:*/		return 0x820AB92C;
		  /* 820AB92Ch */ case   12:  		/* nop */
		/* 820AB92Ch case   12:*/		cpu::op::nop();
		/* 820AB92Ch case   12:*/		return 0x820AB930;
	}
	return 0x820AB930;
} // Block from 820AB8FCh-820AB930h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AB930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB930);
		  /* 820AB930h */ case    0:  		/* mfspr R12, LR */
		/* 820AB930h case    0:*/		regs.R12 = regs.LR;
		/* 820AB930h case    0:*/		return 0x820AB934;
		  /* 820AB934h */ case    1:  		/* bl -108248 */
		/* 820AB934h case    1:*/		regs.LR = 0x820AB938; return 0x8209125C;
		/* 820AB934h case    1:*/		return 0x820AB938;
		  /* 820AB938h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820AB938h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820AB938h case    2:*/		return 0x820AB93C;
		  /* 820AB93Ch */ case    3:  		/* mr R31, R3 */
		/* 820AB93Ch case    3:*/		regs.R31 = regs.R3;
		/* 820AB93Ch case    3:*/		return 0x820AB940;
		  /* 820AB940h */ case    4:  		/* lwz R3, <#[R3 + 68]> */
		/* 820AB940h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000044) );
		/* 820AB940h case    4:*/		return 0x820AB944;
		  /* 820AB944h */ case    5:  		/* mr R30, R4 */
		/* 820AB944h case    5:*/		regs.R30 = regs.R4;
		/* 820AB944h case    5:*/		return 0x820AB948;
		  /* 820AB948h */ case    6:  		/* rlwinm. R11, R3, 0, 11, 11 */
		/* 820AB948h case    6:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R3);
		/* 820AB948h case    6:*/		return 0x820AB94C;
		  /* 820AB94Ch */ case    7:  		/* lwz R11, <#[R31 + 104]> */
		/* 820AB94Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 820AB94Ch case    7:*/		return 0x820AB950;
		  /* 820AB950h */ case    8:  		/* mr R9, R5 */
		/* 820AB950h case    8:*/		regs.R9 = regs.R5;
		/* 820AB950h case    8:*/		return 0x820AB954;
		  /* 820AB954h */ case    9:  		/* bc 12, CR0_EQ, 104 */
		/* 820AB954h case    9:*/		if ( regs.CR[0].eq ) { return 0x820AB9BC;  }
		/* 820AB954h case    9:*/		return 0x820AB958;
		  /* 820AB958h */ case   10:  		/* addi R4, R1, 80 */
		/* 820AB958h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820AB958h case   10:*/		return 0x820AB95C;
		  /* 820AB95Ch */ case   11:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820AB95Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820AB95Ch case   11:*/		return 0x820AB960;
		  /* 820AB960h */ case   12:  		/* bl -24400 */
		/* 820AB960h case   12:*/		regs.LR = 0x820AB964; return 0x820A5A10;
		/* 820AB960h case   12:*/		return 0x820AB964;
		  /* 820AB964h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820AB964h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AB964h case   13:*/		return 0x820AB968;
		  /* 820AB968h */ case   14:  		/* bc 12, CR0_LT, 112 */
		/* 820AB968h case   14:*/		if ( regs.CR[0].lt ) { return 0x820AB9D8;  }
		/* 820AB968h case   14:*/		return 0x820AB96C;
		  /* 820AB96Ch */ case   15:  		/* lwz R3, <#[R1 + 80]> */
		/* 820AB96Ch case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820AB96Ch case   15:*/		return 0x820AB970;
		  /* 820AB970h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 820AB970h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820AB970h case   16:*/		return 0x820AB974;
		  /* 820AB974h */ case   17:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AB974h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AB974h case   17:*/		return 0x820AB978;
		  /* 820AB978h */ case   18:  		/* mtspr CTR, R11 */
		/* 820AB978h case   18:*/		regs.CTR = regs.R11;
		/* 820AB978h case   18:*/		return 0x820AB97C;
		  /* 820AB97Ch */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820AB97Ch case   19:*/		if ( 1 ) { regs.LR = 0x820AB980; return (uint32)regs.CTR; }
		/* 820AB97Ch case   19:*/		return 0x820AB980;
		  /* 820AB980h */ case   20:  		/* lwz R11, <#[R1 + 80]> */
		/* 820AB980h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820AB980h case   20:*/		return 0x820AB984;
		  /* 820AB984h */ case   21:  		/* mr R29, R3 */
		/* 820AB984h case   21:*/		regs.R29 = regs.R3;
		/* 820AB984h case   21:*/		return 0x820AB988;
		  /* 820AB988h */ case   22:  		/* lwz R31, <#[R31 + 100]> */
		/* 820AB988h case   22:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000064) );
		/* 820AB988h case   22:*/		return 0x820AB98C;
		  /* 820AB98Ch */ case   23:  		/* mr R3, R11 */
		/* 820AB98Ch case   23:*/		regs.R3 = regs.R11;
		/* 820AB98Ch case   23:*/		return 0x820AB990;
		  /* 820AB990h */ case   24:  		/* lwz R10, <#[R11]> */
		/* 820AB990h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820AB990h case   24:*/		return 0x820AB994;
		  /* 820AB994h */ case   25:  		/* lwz R11, <#[R10 + 12]> */
		/* 820AB994h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820AB994h case   25:*/		return 0x820AB998;
		  /* 820AB998h */ case   26:  		/* mtspr CTR, R11 */
		/* 820AB998h case   26:*/		regs.CTR = regs.R11;
		/* 820AB998h case   26:*/		return 0x820AB99C;
		  /* 820AB99Ch */ case   27:  		/* bcctrl 20, CR0_LT */
		/* 820AB99Ch case   27:*/		if ( 1 ) { regs.LR = 0x820AB9A0; return (uint32)regs.CTR; }
		/* 820AB99Ch case   27:*/		return 0x820AB9A0;
		  /* 820AB9A0h */ case   28:  		/* mr R4, R31 */
		/* 820AB9A0h case   28:*/		regs.R4 = regs.R31;
		/* 820AB9A0h case   28:*/		return 0x820AB9A4;
		  /* 820AB9A4h */ case   29:  		/* mr R5, R29 */
		/* 820AB9A4h case   29:*/		regs.R5 = regs.R29;
		/* 820AB9A4h case   29:*/		return 0x820AB9A8;
		  /* 820AB9A8h */ case   30:  		/* bl -106488 */
		/* 820AB9A8h case   30:*/		regs.LR = 0x820AB9AC; return 0x820919B0;
		/* 820AB9A8h case   30:*/		return 0x820AB9AC;
		  /* 820AB9ACh */ case   31:  		/* lwz R11, <#[R1 + 80]> */
		/* 820AB9ACh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820AB9ACh case   31:*/		return 0x820AB9B0;
		  /* 820AB9B0h */ case   32:  		/* li R3, 0 */
		/* 820AB9B0h case   32:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AB9B0h case   32:*/		return 0x820AB9B4;
		  /* 820AB9B4h */ case   33:  		/* stw R11, <#[R30]> */
		/* 820AB9B4h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820AB9B4h case   33:*/		return 0x820AB9B8;
		  /* 820AB9B8h */ case   34:  		/* b 32 */
		/* 820AB9B8h case   34:*/		return 0x820AB9D8;
		/* 820AB9B8h case   34:*/		return 0x820AB9BC;
	}
	return 0x820AB9BC;
} // Block from 820AB930h-820AB9BCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 820AB9BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB9BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB9BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB9BC);
		  /* 820AB9BCh */ case    0:  		/* lis R10, -32245 */
		/* 820AB9BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF820B);
		/* 820AB9BCh case    0:*/		return 0x820AB9C0;
		  /* 820AB9C0h */ case    1:  		/* lwz R4, <#[R31 + 100]> */
		/* 820AB9C0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000064) );
		/* 820AB9C0h case    1:*/		return 0x820AB9C4;
		  /* 820AB9C4h */ case    2:  		/* mr R7, R31 */
		/* 820AB9C4h case    2:*/		regs.R7 = regs.R31;
		/* 820AB9C4h case    2:*/		return 0x820AB9C8;
		  /* 820AB9C8h */ case    3:  		/* addi R8, R10, -18136 */
		/* 820AB9C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFB928);
		/* 820AB9C8h case    3:*/		return 0x820AB9CC;
		  /* 820AB9CCh */ case    4:  		/* mr R6, R30 */
		/* 820AB9CCh case    4:*/		regs.R6 = regs.R30;
		/* 820AB9CCh case    4:*/		return 0x820AB9D0;
		  /* 820AB9D0h */ case    5:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820AB9D0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820AB9D0h case    5:*/		return 0x820AB9D4;
		  /* 820AB9D4h */ case    6:  		/* bl -10100 */
		/* 820AB9D4h case    6:*/		regs.LR = 0x820AB9D8; return 0x820A9260;
		/* 820AB9D4h case    6:*/		return 0x820AB9D8;
	}
	return 0x820AB9D8;
} // Block from 820AB9BCh-820AB9D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AB9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB9D8);
		  /* 820AB9D8h */ case    0:  		/* addi R1, R1, 128 */
		/* 820AB9D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820AB9D8h case    0:*/		return 0x820AB9DC;
		  /* 820AB9DCh */ case    1:  		/* b -108336 */
		/* 820AB9DCh case    1:*/		return 0x820912AC;
		/* 820AB9DCh case    1:*/		return 0x820AB9E0;
	}
	return 0x820AB9E0;
} // Block from 820AB9D8h-820AB9E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AB9E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AB9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AB9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AB9E0);
		  /* 820AB9E0h */ case    0:  		/* mfspr R12, LR */
		/* 820AB9E0h case    0:*/		regs.R12 = regs.LR;
		/* 820AB9E0h case    0:*/		return 0x820AB9E4;
		  /* 820AB9E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AB9E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AB9E4h case    1:*/		return 0x820AB9E8;
		  /* 820AB9E8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820AB9E8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AB9E8h case    2:*/		return 0x820AB9EC;
		  /* 820AB9ECh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820AB9ECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820AB9ECh case    3:*/		return 0x820AB9F0;
		  /* 820AB9F0h */ case    4:  		/* mr R31, R3 */
		/* 820AB9F0h case    4:*/		regs.R31 = regs.R3;
		/* 820AB9F0h case    4:*/		return 0x820AB9F4;
		  /* 820AB9F4h */ case    5:  		/* lwz R3, <#[R3 + 8]> */
		/* 820AB9F4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 820AB9F4h case    5:*/		return 0x820AB9F8;
		  /* 820AB9F8h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820AB9F8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AB9F8h case    6:*/		return 0x820AB9FC;
		  /* 820AB9FCh */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 820AB9FCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820ABA18;  }
		/* 820AB9FCh case    7:*/		return 0x820ABA00;
		  /* 820ABA00h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820ABA00h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820ABA00h case    8:*/		return 0x820ABA04;
		  /* 820ABA04h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 820ABA04h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820ABA04h case    9:*/		return 0x820ABA08;
		  /* 820ABA08h */ case   10:  		/* mtspr CTR, R11 */
		/* 820ABA08h case   10:*/		regs.CTR = regs.R11;
		/* 820ABA08h case   10:*/		return 0x820ABA0C;
		  /* 820ABA0Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820ABA0Ch case   11:*/		if ( 1 ) { regs.LR = 0x820ABA10; return (uint32)regs.CTR; }
		/* 820ABA0Ch case   11:*/		return 0x820ABA10;
		  /* 820ABA10h */ case   12:  		/* li R11, 0 */
		/* 820ABA10h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820ABA10h case   12:*/		return 0x820ABA14;
		  /* 820ABA14h */ case   13:  		/* stw R11, <#[R31 + 8]> */
		/* 820ABA14h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820ABA14h case   13:*/		return 0x820ABA18;
	}
	return 0x820ABA18;
} // Block from 820AB9E0h-820ABA18h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ABA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABA18);
		  /* 820ABA18h */ case    0:  		/* lis R4, 9345 */
		/* 820ABA18h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820ABA18h case    0:*/		return 0x820ABA1C;
		  /* 820ABA1Ch */ case    1:  		/* lwz R3, <#[R31 + 100]> */
		/* 820ABA1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 820ABA1Ch case    1:*/		return 0x820ABA20;
		  /* 820ABA20h */ case    2:  		/* bl -145128 */
		/* 820ABA20h case    2:*/		regs.LR = 0x820ABA24; return 0x82088338;
		/* 820ABA20h case    2:*/		return 0x820ABA24;
		  /* 820ABA24h */ case    3:  		/* lwz R31, <#[R31 + 132]> */
		/* 820ABA24h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000084) );
		/* 820ABA24h case    3:*/		return 0x820ABA28;
		  /* 820ABA28h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 820ABA28h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820ABA28h case    4:*/		return 0x820ABA2C;
		  /* 820ABA2Ch */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820ABA2Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820ABA44;  }
		/* 820ABA2Ch case    5:*/		return 0x820ABA30;
		  /* 820ABA30h */ case    6:  		/* mr R3, R31 */
		/* 820ABA30h case    6:*/		regs.R3 = regs.R31;
		/* 820ABA30h case    6:*/		return 0x820ABA34;
		  /* 820ABA34h */ case    7:  		/* bl -8980 */
		/* 820ABA34h case    7:*/		regs.LR = 0x820ABA38; return 0x820A9720;
		/* 820ABA34h case    7:*/		return 0x820ABA38;
		  /* 820ABA38h */ case    8:  		/* lis R4, 9345 */
		/* 820ABA38h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820ABA38h case    8:*/		return 0x820ABA3C;
		  /* 820ABA3Ch */ case    9:  		/* mr R3, R31 */
		/* 820ABA3Ch case    9:*/		regs.R3 = regs.R31;
		/* 820ABA3Ch case    9:*/		return 0x820ABA40;
		  /* 820ABA40h */ case   10:  		/* bl -145160 */
		/* 820ABA40h case   10:*/		regs.LR = 0x820ABA44; return 0x82088338;
		/* 820ABA40h case   10:*/		return 0x820ABA44;
	}
	return 0x820ABA44;
} // Block from 820ABA18h-820ABA44h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ABA44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABA44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABA44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABA44);
		  /* 820ABA44h */ case    0:  		/* addi R1, R1, 96 */
		/* 820ABA44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820ABA44h case    0:*/		return 0x820ABA48;
		  /* 820ABA48h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820ABA48h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820ABA48h case    1:*/		return 0x820ABA4C;
		  /* 820ABA4Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820ABA4Ch case    2:*/		regs.LR = regs.R12;
		/* 820ABA4Ch case    2:*/		return 0x820ABA50;
		  /* 820ABA50h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820ABA50h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820ABA50h case    3:*/		return 0x820ABA54;
		  /* 820ABA54h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820ABA54h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820ABA54h case    4:*/		return 0x820ABA58;
	}
	return 0x820ABA58;
} // Block from 820ABA44h-820ABA58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ABA58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABA58);
		  /* 820ABA58h */ case    0:  		/* mfspr R12, LR */
		/* 820ABA58h case    0:*/		regs.R12 = regs.LR;
		/* 820ABA58h case    0:*/		return 0x820ABA5C;
		  /* 820ABA5Ch */ case    1:  		/* bl -108548 */
		/* 820ABA5Ch case    1:*/		regs.LR = 0x820ABA60; return 0x82091258;
		/* 820ABA5Ch case    1:*/		return 0x820ABA60;
		  /* 820ABA60h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820ABA60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820ABA60h case    2:*/		return 0x820ABA64;
		  /* 820ABA64h */ case    3:  		/* lwz R11, <#[R3 + 88]> */
		/* 820ABA64h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000058) );
		/* 820ABA64h case    3:*/		return 0x820ABA68;
		  /* 820ABA68h */ case    4:  		/* mr R30, R3 */
		/* 820ABA68h case    4:*/		regs.R30 = regs.R3;
		/* 820ABA68h case    4:*/		return 0x820ABA6C;
		  /* 820ABA6Ch */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820ABA6Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ABA6Ch case    5:*/		return 0x820ABA70;
		  /* 820ABA70h */ case    6:  		/* bc 4, CR6_EQ, 1592 */
		/* 820ABA70h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820AC0A8;  }
		/* 820ABA70h case    6:*/		return 0x820ABA74;
		  /* 820ABA74h */ case    7:  		/* li R29, 0 */
		/* 820ABA74h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820ABA74h case    7:*/		return 0x820ABA78;
		  /* 820ABA78h */ case    8:  		/* mr R9, R5 */
		/* 820ABA78h case    8:*/		regs.R9 = regs.R5;
		/* 820ABA78h case    8:*/		return 0x820ABA7C;
		  /* 820ABA7Ch */ case    9:  		/* mr R31, R29 */
		/* 820ABA7Ch case    9:*/		regs.R31 = regs.R29;
		/* 820ABA7Ch case    9:*/		return 0x820ABA80;
		  /* 820ABA80h */ case   10:  		/* cmplwi CR6, R5, 0 */
		/* 820ABA80h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820ABA80h case   10:*/		return 0x820ABA84;
		  /* 820ABA84h */ case   11:  		/* bc 12, CR6_EQ, 68 */
		/* 820ABA84h case   11:*/		if ( regs.CR[6].eq ) { return 0x820ABAC8;  }
		/* 820ABA84h case   11:*/		return 0x820ABA88;
		  /* 820ABA88h */ case   12:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 820ABA88h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 820ABA88h case   12:*/		return 0x820ABA8C;
		  /* 820ABA8Ch */ case   13:  		/* addi R11, R1, 96 */
		/* 820ABA8Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820ABA8Ch case   13:*/		return 0x820ABA90;
		  /* 820ABA90h */ case   14:  		/* add R10, R10, R11 */
		/* 820ABA90h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820ABA90h case   14:*/		return 0x820ABA94;
		  /* 820ABA94h */ case   15:  		/* lwz R11, <#[R30 + 60]> */
		/* 820ABA94h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 820ABA94h case   15:*/		return 0x820ABA98;
		  /* 820ABA98h */ case   16:  		/* addi R9, R9, -1 */
		/* 820ABA98h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820ABA98h case   16:*/		return 0x820ABA9C;
		  /* 820ABA9Ch */ case   17:  		/* addi R10, R10, -4 */
		/* 820ABA9Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820ABA9Ch case   17:*/		return 0x820ABAA0;
		  /* 820ABAA0h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820ABAA0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ABAA0h case   18:*/		return 0x820ABAA4;
		  /* 820ABAA4h */ case   19:  		/* bc 12, CR6_EQ, 88 */
		/* 820ABAA4h case   19:*/		if ( regs.CR[6].eq ) { return 0x820ABAFC;  }
		/* 820ABAA4h case   19:*/		return 0x820ABAA8;
		  /* 820ABAA8h */ case   20:  		/* lwz R8, <#[R11 + 12]> */
		/* 820ABAA8h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 820ABAA8h case   20:*/		return 0x820ABAAC;
		  /* 820ABAACh */ case   21:  		/* cmplwi CR6, R9, 0 */
		/* 820ABAACh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820ABAACh case   21:*/		return 0x820ABAB0;
		  /* 820ABAB0h */ case   22:  		/* lwz R7, <#[R11 + 8]> */
		/* 820ABAB0h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 820ABAB0h case   22:*/		return 0x820ABAB4;
		  /* 820ABAB4h */ case   23:  		/* stw R8, <#[R30 + 60]> */
		/* 820ABAB4h case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x0000003C) );
		/* 820ABAB4h case   23:*/		return 0x820ABAB8;
		  /* 820ABAB8h */ case   24:  		/* stw R7, <#[R10]> */
		/* 820ABAB8h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820ABAB8h case   24:*/		return 0x820ABABC;
		  /* 820ABABCh */ case   25:  		/* stw R29, <#[R11 + 8]> */
		/* 820ABABCh case   25:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 820ABABCh case   25:*/		return 0x820ABAC0;
		  /* 820ABAC0h */ case   26:  		/* stw R29, <#[R11 + 12]> */
		/* 820ABAC0h case   26:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x0000000C) );
		/* 820ABAC0h case   26:*/		return 0x820ABAC4;
		  /* 820ABAC4h */ case   27:  		/* bc 4, CR6_EQ, -48 */
		/* 820ABAC4h case   27:*/		if ( !regs.CR[6].eq ) { return 0x820ABA94;  }
		/* 820ABAC4h case   27:*/		return 0x820ABAC8;
	}
	return 0x820ABAC8;
} // Block from 820ABA58h-820ABAC8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820ABAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABAC8);
		  /* 820ABAC8h */ case    0:  		/* li R28, 1 */
		/* 820ABAC8h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820ABAC8h case    0:*/		return 0x820ABACC;
		  /* 820ABACCh */ case    1:  		/* cmplwi CR6, R4, 63 */
		/* 820ABACCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000003F);
		/* 820ABACCh case    1:*/		return 0x820ABAD0;
		  /* 820ABAD0h */ case    2:  		/* bc 12, CR6_GT, 1392 */
		/* 820ABAD0h case    2:*/		if ( regs.CR[6].gt ) { return 0x820AC040;  }
		/* 820ABAD0h case    2:*/		return 0x820ABAD4;
		  /* 820ABAD4h */ case    3:  		/* lis R12, -32255 */
		/* 820ABAD4h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820ABAD4h case    3:*/		return 0x820ABAD8;
		  /* 820ABAD8h */ case    4:  		/* rlwinm R0, R4, 1, 0, 30 */
		/* 820ABAD8h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R4);
		/* 820ABAD8h case    4:*/		return 0x820ABADC;
		  /* 820ABADCh */ case    5:  		/* addi R12, R12, 2016 */
		/* 820ABADCh case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x7E0);
		/* 820ABADCh case    5:*/		return 0x820ABAE0;
		  /* 820ABAE0h */ case    6:  		/* lhzx R0, <#[R12 + R0]> */
		/* 820ABAE0h case    6:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 820ABAE0h case    6:*/		return 0x820ABAE4;
		  /* 820ABAE4h */ case    7:  		/* lis R12, -32245 */
		/* 820ABAE4h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820B);
		/* 820ABAE4h case    7:*/		return 0x820ABAE8;
		  /* 820ABAE8h */ case    8:  		/* addi R12, R12, -17668 */
		/* 820ABAE8h case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBAFC);
		/* 820ABAE8h case    8:*/		return 0x820ABAEC;
		  /* 820ABAECh */ case    9:  		/* ori R0, R0, 0 */
		/* 820ABAECh case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820ABAECh case    9:*/		return 0x820ABAF0;
		  /* 820ABAF0h */ case   10:  		/* add R12, R12, R0 */
		/* 820ABAF0h case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820ABAF0h case   10:*/		return 0x820ABAF4;
		  /* 820ABAF4h */ case   11:  		/* mtspr CTR, R12 */
		/* 820ABAF4h case   11:*/		regs.CTR = regs.R12;
		/* 820ABAF4h case   11:*/		return 0x820ABAF8;
		  /* 820ABAF8h */ case   12:  		/* bcctr 20, CR0_LT */
		/* 820ABAF8h case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820ABAF8h case   12:*/		return 0x820ABAFC;
	}
	return 0x820ABAFC;
} // Block from 820ABAC8h-820ABAFCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820ABAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABAFC);
		  /* 820ABAFCh */ case    0:  		/* lis R11, -32255 */
		/* 820ABAFCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABAFCh case    0:*/		return 0x820ABB00;
		  /* 820ABB00h */ case    1:  		/* lwz R3, <#[R30]> */
		/* 820ABB00h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820ABB00h case    1:*/		return 0x820ABB04;
		  /* 820ABB04h */ case    2:  		/* li R5, 0 */
		/* 820ABB04h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ABB04h case    2:*/		return 0x820ABB08;
		  /* 820ABB08h */ case    3:  		/* addi R6, R11, -9956 */
		/* 820ABB08h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD91C);
		/* 820ABB08h case    3:*/		return 0x820ABB0C;
		  /* 820ABB0Ch */ case    4:  		/* addi R4, R30, 16 */
		/* 820ABB0Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820ABB0Ch case    4:*/		return 0x820ABB10;
		  /* 820ABB10h */ case    5:  		/* bl -18816 */
		/* 820ABB10h case    5:*/		regs.LR = 0x820ABB14; return 0x820A7190;
		/* 820ABB10h case    5:*/		return 0x820ABB14;
		  /* 820ABB14h */ case    6:  		/* li R11, 1 */
		/* 820ABB14h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820ABB14h case    6:*/		return 0x820ABB18;
	}
	return 0x820ABB18;
} // Block from 820ABAFCh-820ABB18h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ABB18h
// Function '?EmitFragmentInfo@CAssembler@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABB18);
		  /* 820ABB18h */ case    0:  		/* stw R11, <#[R30 + 84]> */
		/* 820ABB18h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000054) );
		/* 820ABB18h case    0:*/		return 0x820ABB1C;
		  /* 820ABB1Ch */ case    1:  		/* b 1420 */
		/* 820ABB1Ch case    1:*/		return 0x820AC0A8;
		/* 820ABB1Ch case    1:*/		return 0x820ABB20;
		  /* 820ABB20h */ case    2:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABB20h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABB20h case    2:*/		return 0x820ABB24;
		  /* 820ABB24h */ case    3:  		/* b 1308 */
		/* 820ABB24h case    3:*/		return 0x820AC040;
		/* 820ABB24h case    3:*/		return 0x820ABB28;
		  /* 820ABB28h */ case    4:  		/* lwz R4, <#[R1 + 96]> */
		/* 820ABB28h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABB28h case    4:*/		return 0x820ABB2C;
		  /* 820ABB2Ch */ case    5:  		/* lwz R3, <#[R1 + 100]> */
		/* 820ABB2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABB2Ch case    5:*/		return 0x820ABB30;
		  /* 820ABB30h */ case    6:  		/* bl 120920 */
		/* 820ABB30h case    6:*/		regs.LR = 0x820ABB34; return 0x820C9388;
		/* 820ABB30h case    6:*/		return 0x820ABB34;
		  /* 820ABB34h */ case    7:  		/* mr R31, R3 */
		/* 820ABB34h case    7:*/		regs.R31 = regs.R3;
		/* 820ABB34h case    7:*/		return 0x820ABB38;
		  /* 820ABB38h */ case    8:  		/* b 1288 */
		/* 820ABB38h case    8:*/		return 0x820AC040;
		/* 820ABB38h case    8:*/		return 0x820ABB3C;
		  /* 820ABB3Ch */ case    9:  		/* lwz R11, <#[R30 + 128]> */
		/* 820ABB3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 820ABB3Ch case    9:*/		return 0x820ABB40;
		  /* 820ABB40h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820ABB40h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ABB40h case   10:*/		return 0x820ABB44;
		  /* 820ABB44h */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 820ABB44h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820ABB54;  }
		/* 820ABB44h case   11:*/		return 0x820ABB48;
		  /* 820ABB48h */ case   12:  		/* lwz R11, <#[R1 + 96]> */
		/* 820ABB48h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABB48h case   12:*/		return 0x820ABB4C;
		  /* 820ABB4Ch */ case   13:  		/* lwz R11, <#[R11 + 24]> */
		/* 820ABB4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820ABB4Ch case   13:*/		return 0x820ABB50;
		  /* 820ABB50h */ case   14:  		/* stw R11, <#[R30 + 128]> */
		/* 820ABB50h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 820ABB50h case   14:*/		return 0x820ABB54;
	}
	return 0x820ABB54;
} // Block from 820ABB18h-820ABB54h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820ABB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABB54);
		  /* 820ABB54h */ case    0:  		/* mr R31, R29 */
		/* 820ABB54h case    0:*/		regs.R31 = regs.R29;
		/* 820ABB54h case    0:*/		return 0x820ABB58;
		  /* 820ABB58h */ case    1:  		/* b 1256 */
		/* 820ABB58h case    1:*/		return 0x820AC040;
		/* 820ABB58h case    1:*/		return 0x820ABB5C;
		  /* 820ABB5Ch */ case    2:  		/* lwz R4, <#[R1 + 96]> */
		/* 820ABB5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABB5Ch case    2:*/		return 0x820ABB60;
		  /* 820ABB60h */ case    3:  		/* mr R31, R4 */
		/* 820ABB60h case    3:*/		regs.R31 = regs.R4;
		/* 820ABB60h case    3:*/		return 0x820ABB64;
		  /* 820ABB64h */ case    4:  		/* mr R3, R30 */
		/* 820ABB64h case    4:*/		regs.R3 = regs.R30;
		/* 820ABB64h case    4:*/		return 0x820ABB68;
		  /* 820ABB68h */ case    5:  		/* bl -5200 */
		/* 820ABB68h case    5:*/		regs.LR = 0x820ABB6C; return 0x820AA718;
		/* 820ABB68h case    5:*/		return 0x820ABB6C;
		  /* 820ABB6Ch */ case    6:  		/* b 1236 */
		/* 820ABB6Ch case    6:*/		return 0x820AC040;
		/* 820ABB6Ch case    6:*/		return 0x820ABB70;
		  /* 820ABB70h */ case    7:  		/* lwz R11, <#[R30 + 64]> */
		/* 820ABB70h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000040) );
		/* 820ABB70h case    7:*/		return 0x820ABB74;
		  /* 820ABB74h */ case    8:  		/* lwz R4, <#[R1 + 96]> */
		/* 820ABB74h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABB74h case    8:*/		return 0x820ABB78;
		  /* 820ABB78h */ case    9:  		/* cmpwi CR6, R11, 6 */
		/* 820ABB78h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820ABB78h case    9:*/		return 0x820ABB7C;
		  /* 820ABB7Ch */ case   10:  		/* mr R31, R4 */
		/* 820ABB7Ch case   10:*/		regs.R31 = regs.R4;
		/* 820ABB7Ch case   10:*/		return 0x820ABB80;
		  /* 820ABB80h */ case   11:  		/* bc 12, CR6_LT, 20 */
		/* 820ABB80h case   11:*/		if ( regs.CR[6].lt ) { return 0x820ABB94;  }
		/* 820ABB80h case   11:*/		return 0x820ABB84;
		  /* 820ABB84h */ case   12:  		/* cmpwi CR6, R11, 9 */
		/* 820ABB84h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 820ABB84h case   12:*/		return 0x820ABB88;
		  /* 820ABB88h */ case   13:  		/* bc 12, CR6_GT, 12 */
		/* 820ABB88h case   13:*/		if ( regs.CR[6].gt ) { return 0x820ABB94;  }
		/* 820ABB88h case   13:*/		return 0x820ABB8C;
		  /* 820ABB8Ch */ case   14:  		/* stw R28, <#[R4 + 92]> */
		/* 820ABB8Ch case   14:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R4 + 0x0000005C) );
		/* 820ABB8Ch case   14:*/		return 0x820ABB90;
		  /* 820ABB90h */ case   15:  		/* b -44 */
		/* 820ABB90h case   15:*/		return 0x820ABB64;
		/* 820ABB90h case   15:*/		return 0x820ABB94;
	}
	return 0x820ABB94;
} // Block from 820ABB54h-820ABB94h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820ABB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABB94);
		  /* 820ABB94h */ case    0:  		/* lis R11, -32255 */
		/* 820ABB94h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABB94h case    0:*/		return 0x820ABB98;
		  /* 820ABB98h */ case    1:  		/* li R5, 2027 */
		/* 820ABB98h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7EB);
		/* 820ABB98h case    1:*/		return 0x820ABB9C;
		  /* 820ABB9Ch */ case    2:  		/* addi R6, R11, 4784 */
		/* 820ABB9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x12B0);
		/* 820ABB9Ch case    2:*/		return 0x820ABBA0;
		  /* 820ABBA0h */ case    3:  		/* addi R4, R4, 16 */
		/* 820ABBA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x10);
		/* 820ABBA0h case    3:*/		return 0x820ABBA4;
		  /* 820ABBA4h */ case    4:  		/* lwz R3, <#[R30]> */
		/* 820ABBA4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820ABBA4h case    4:*/		return 0x820ABBA8;
		  /* 820ABBA8h */ case    5:  		/* bl -18968 */
		/* 820ABBA8h case    5:*/		regs.LR = 0x820ABBAC; return 0x820A7190;
		/* 820ABBA8h case    5:*/		return 0x820ABBAC;
		  /* 820ABBACh */ case    6:  		/* stw R28, <#[R30 + 84]> */
		/* 820ABBACh case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000054) );
		/* 820ABBACh case    6:*/		return 0x820ABBB0;
		  /* 820ABBB0h */ case    7:  		/* b 1168 */
		/* 820ABBB0h case    7:*/		return 0x820AC040;
		/* 820ABBB0h case    7:*/		return 0x820ABBB4;
		  /* 820ABBB4h */ case    8:  		/* lwz R11, <#[R30 + 64]> */
		/* 820ABBB4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000040) );
		/* 820ABBB4h case    8:*/		return 0x820ABBB8;
		  /* 820ABBB8h */ case    9:  		/* lwz R31, <#[R1 + 100]> */
		/* 820ABBB8h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABBB8h case    9:*/		return 0x820ABBBC;
		  /* 820ABBBCh */ case   10:  		/* cmpwi CR6, R11, 2 */
		/* 820ABBBCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820ABBBCh case   10:*/		return 0x820ABBC0;
		  /* 820ABBC0h */ case   11:  		/* bc 12, CR6_LT, 12 */
		/* 820ABBC0h case   11:*/		if ( regs.CR[6].lt ) { return 0x820ABBCC;  }
		/* 820ABBC0h case   11:*/		return 0x820ABBC4;
		  /* 820ABBC4h */ case   12:  		/* cmpwi CR6, R11, 5 */
		/* 820ABBC4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 820ABBC4h case   12:*/		return 0x820ABBC8;
		  /* 820ABBC8h */ case   13:  		/* bc 4, CR6_GT, 20 */
		/* 820ABBC8h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820ABBDC;  }
		/* 820ABBC8h case   13:*/		return 0x820ABBCC;
	}
	return 0x820ABBCC;
} // Block from 820ABB94h-820ABBCCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ABBCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABBCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABBCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABBCC);
		  /* 820ABBCCh */ case    0:  		/* cmpwi CR6, R11, 12 */
		/* 820ABBCCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 820ABBCCh case    0:*/		return 0x820ABBD0;
		  /* 820ABBD0h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 820ABBD0h case    1:*/		if ( regs.CR[6].lt ) { return 0x820ABBE8;  }
		/* 820ABBD0h case    1:*/		return 0x820ABBD4;
		  /* 820ABBD4h */ case    2:  		/* cmpwi CR6, R11, 15 */
		/* 820ABBD4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 820ABBD4h case    2:*/		return 0x820ABBD8;
		  /* 820ABBD8h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820ABBD8h case    3:*/		if ( regs.CR[6].gt ) { return 0x820ABBE8;  }
		/* 820ABBD8h case    3:*/		return 0x820ABBDC;
	}
	return 0x820ABBDC;
} // Block from 820ABBCCh-820ABBDCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ABBDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABBDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABBDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABBDC);
		  /* 820ABBDCh */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 820ABBDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABBDCh case    0:*/		return 0x820ABBE0;
		  /* 820ABBE0h */ case    1:  		/* stw R11, <#[R31 + 72]> */
		/* 820ABBE0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 820ABBE0h case    1:*/		return 0x820ABBE4;
		  /* 820ABBE4h */ case    2:  		/* b 1116 */
		/* 820ABBE4h case    2:*/		return 0x820AC040;
		/* 820ABBE4h case    2:*/		return 0x820ABBE8;
	}
	return 0x820ABBE8;
} // Block from 820ABBDCh-820ABBE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ABBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABBE8);
		  /* 820ABBE8h */ case    0:  		/* lis R11, -32255 */
		/* 820ABBE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABBE8h case    0:*/		return 0x820ABBEC;
		  /* 820ABBECh */ case    1:  		/* li R5, 2028 */
		/* 820ABBECh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7EC);
		/* 820ABBECh case    1:*/		return 0x820ABBF0;
		  /* 820ABBF0h */ case    2:  		/* addi R6, R11, 4720 */
		/* 820ABBF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1270);
		/* 820ABBF0h case    2:*/		return 0x820ABBF4;
		  /* 820ABBF4h */ case    3:  		/* addi R4, R31, 16 */
		/* 820ABBF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820ABBF4h case    3:*/		return 0x820ABBF8;
		  /* 820ABBF8h */ case    4:  		/* b -84 */
		/* 820ABBF8h case    4:*/		return 0x820ABBA4;
		/* 820ABBF8h case    4:*/		return 0x820ABBFC;
		  /* 820ABBFCh */ case    5:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABBFCh case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABBFCh case    5:*/		return 0x820ABC00;
		  /* 820ABC00h */ case    6:  		/* cmplwi CR6, R5, 1 */
		/* 820ABC00h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 820ABC00h case    6:*/		return 0x820ABC04;
		  /* 820ABC04h */ case    7:  		/* stw R29, <#[R1 + 96]> */
		/* 820ABC04h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABC04h case    7:*/		return 0x820ABC08;
		  /* 820ABC08h */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 820ABC08h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820ABC18;  }
		/* 820ABC08h case    8:*/		return 0x820ABC0C;
		  /* 820ABC0Ch */ case    9:  		/* lwz R11, <#[R1 + 100]> */
		/* 820ABC0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABC0Ch case    9:*/		return 0x820ABC10;
		  /* 820ABC10h */ case   10:  		/* stw R29, <#[R1 + 100]> */
		/* 820ABC10h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABC10h case   10:*/		return 0x820ABC14;
		  /* 820ABC14h */ case   11:  		/* stw R11, <#[R31 + 68]> */
		/* 820ABC14h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820ABC14h case   11:*/		return 0x820ABC18;
	}
	return 0x820ABC18;
} // Block from 820ABBE8h-820ABC18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820ABC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABC18);
		  /* 820ABC18h */ case    0:  		/* cmplwi CR6, R5, 2 */
		/* 820ABC18h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000002);
		/* 820ABC18h case    0:*/		return 0x820ABC1C;
		  /* 820ABC1Ch */ case    1:  		/* bc 4, CR6_GT, 1060 */
		/* 820ABC1Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x820AC040;  }
		/* 820ABC1Ch case    1:*/		return 0x820ABC20;
		  /* 820ABC20h */ case    2:  		/* addi R9, R5, -2 */
		/* 820ABC20h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0xFFFFFFFE);
		/* 820ABC20h case    2:*/		return 0x820ABC24;
		  /* 820ABC24h */ case    3:  		/* addi R11, R1, 100 */
		/* 820ABC24h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x64);
		/* 820ABC24h case    3:*/		return 0x820ABC28;
		  /* 820ABC28h */ case    4:  		/* addi R10, R31, 72 */
		/* 820ABC28h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x48);
		/* 820ABC28h case    4:*/		return 0x820ABC2C;
		  /* 820ABC2Ch */ case    5:  		/* mtspr CTR, R9 */
		/* 820ABC2Ch case    5:*/		regs.CTR = regs.R9;
		/* 820ABC2Ch case    5:*/		return 0x820ABC30;
		  /* 820ABC30h */ case    6:  		/* lwz R9, <#[R11 + 4]> */
		/* 820ABC30h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820ABC30h case    6:*/		return 0x820ABC34;
		  /* 820ABC34h */ case    7:  		/* stwu R29, <#[R11 + 4]> */
		/* 820ABC34h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820ABC34h case    7:*/		return 0x820ABC38;
		  /* 820ABC38h */ case    8:  		/* stwu R9, <#[R10 + 4]> */
		/* 820ABC38h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820ABC38h case    8:*/		return 0x820ABC3C;
		  /* 820ABC3Ch */ case    9:  		/* bc 16, CR0_LT, -12 */
		/* 820ABC3Ch case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ABC30;  }
		/* 820ABC3Ch case    9:*/		return 0x820ABC40;
		  /* 820ABC40h */ case   10:  		/* b 1024 */
		/* 820ABC40h case   10:*/		return 0x820AC040;
		/* 820ABC40h case   10:*/		return 0x820ABC44;
		  /* 820ABC44h */ case   11:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABC44h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABC44h case   11:*/		return 0x820ABC48;
		  /* 820ABC48h */ case   12:  		/* cmplwi CR6, R5, 1 */
		/* 820ABC48h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 820ABC48h case   12:*/		return 0x820ABC4C;
		  /* 820ABC4Ch */ case   13:  		/* stw R29, <#[R1 + 96]> */
		/* 820ABC4Ch case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABC4Ch case   13:*/		return 0x820ABC50;
		  /* 820ABC50h */ case   14:  		/* bc 4, CR6_GT, 1008 */
		/* 820ABC50h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820AC040;  }
		/* 820ABC50h case   14:*/		return 0x820ABC54;
		  /* 820ABC54h */ case   15:  		/* addi R9, R5, -1 */
		/* 820ABC54h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0xFFFFFFFF);
		/* 820ABC54h case   15:*/		return 0x820ABC58;
		  /* 820ABC58h */ case   16:  		/* addi R11, R1, 96 */
		/* 820ABC58h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820ABC58h case   16:*/		return 0x820ABC5C;
		  /* 820ABC5Ch */ case   17:  		/* addi R10, R31, 72 */
		/* 820ABC5Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x48);
		/* 820ABC5Ch case   17:*/		return 0x820ABC60;
		  /* 820ABC60h */ case   18:  		/* mtspr CTR, R9 */
		/* 820ABC60h case   18:*/		regs.CTR = regs.R9;
		/* 820ABC60h case   18:*/		return 0x820ABC64;
		  /* 820ABC64h */ case   19:  		/* lwz R9, <#[R11 + 4]> */
		/* 820ABC64h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820ABC64h case   19:*/		return 0x820ABC68;
		  /* 820ABC68h */ case   20:  		/* stwu R29, <#[R11 + 4]> */
		/* 820ABC68h case   20:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820ABC68h case   20:*/		return 0x820ABC6C;
		  /* 820ABC6Ch */ case   21:  		/* stwu R9, <#[R10 + 4]> */
		/* 820ABC6Ch case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820ABC6Ch case   21:*/		return 0x820ABC70;
		  /* 820ABC70h */ case   22:  		/* bc 16, CR0_LT, -12 */
		/* 820ABC70h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820ABC64;  }
		/* 820ABC70h case   22:*/		return 0x820ABC74;
		  /* 820ABC74h */ case   23:  		/* b 972 */
		/* 820ABC74h case   23:*/		return 0x820AC040;
		/* 820ABC74h case   23:*/		return 0x820ABC78;
		  /* 820ABC78h */ case   24:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABC78h case   24:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABC78h case   24:*/		return 0x820ABC7C;
		  /* 820ABC7Ch */ case   25:  		/* lwz R11, <#[R31 + 28]> */
		/* 820ABC7Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820ABC7Ch case   25:*/		return 0x820ABC80;
		  /* 820ABC80h */ case   26:  		/* cmpwi CR6, R11, 0 */
		/* 820ABC80h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ABC80h case   26:*/		return 0x820ABC84;
		  /* 820ABC84h */ case   27:  		/* bc 12, CR6_EQ, 44 */
		/* 820ABC84h case   27:*/		if ( regs.CR[6].eq ) { return 0x820ABCB0;  }
		/* 820ABC84h case   27:*/		return 0x820ABC88;
		  /* 820ABC88h */ case   28:  		/* lis R11, -32255 */
		/* 820ABC88h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABC88h case   28:*/		return 0x820ABC8C;
		  /* 820ABC8Ch */ case   29:  		/* lwz R3, <#[R30]> */
		/* 820ABC8Ch case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820ABC8Ch case   29:*/		return 0x820ABC90;
		  /* 820ABC90h */ case   30:  		/* li R5, 2022 */
		/* 820ABC90h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x7E6);
		/* 820ABC90h case   30:*/		return 0x820ABC94;
		  /* 820ABC94h */ case   31:  		/* addi R6, R11, 4680 */
		/* 820ABC94h case   31:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1248);
		/* 820ABC94h case   31:*/		return 0x820ABC98;
		  /* 820ABC98h */ case   32:  		/* addi R4, R30, 16 */
		/* 820ABC98h case   32:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820ABC98h case   32:*/		return 0x820ABC9C;
		  /* 820ABC9Ch */ case   33:  		/* bl -19212 */
		/* 820ABC9Ch case   33:*/		regs.LR = 0x820ABCA0; return 0x820A7190;
		/* 820ABC9Ch case   33:*/		return 0x820ABCA0;
		  /* 820ABCA0h */ case   34:  		/* lis R11, 15 */
		/* 820ABCA0h case   34:*/		cpu::op::lis<0>(regs,&regs.R11,0xF);
		/* 820ABCA0h case   34:*/		return 0x820ABCA4;
		  /* 820ABCA4h */ case   35:  		/* stw R28, <#[R30 + 84]> */
		/* 820ABCA4h case   35:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000054) );
		/* 820ABCA4h case   35:*/		return 0x820ABCA8;
		  /* 820ABCA8h */ case   36:  		/* stw R11, <#[R31 + 32]> */
		/* 820ABCA8h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820ABCA8h case   36:*/		return 0x820ABCAC;
		  /* 820ABCACh */ case   37:  		/* b 916 */
		/* 820ABCACh case   37:*/		return 0x820AC040;
		/* 820ABCACh case   37:*/		return 0x820ABCB0;
	}
	return 0x820ABCB0;
} // Block from 820ABC18h-820ABCB0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820ABCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABCB0);
		  /* 820ABCB0h */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 820ABCB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABCB0h case    0:*/		return 0x820ABCB4;
		  /* 820ABCB4h */ case    1:  		/* mr R3, R30 */
		/* 820ABCB4h case    1:*/		regs.R3 = regs.R30;
		/* 820ABCB4h case    1:*/		return 0x820ABCB8;
		  /* 820ABCB8h */ case    2:  		/* addi R4, R11, 16 */
		/* 820ABCB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 820ABCB8h case    2:*/		return 0x820ABCBC;
		  /* 820ABCBCh */ case    3:  		/* bl -12132 */
		/* 820ABCBCh case    3:*/		regs.LR = 0x820ABCC0; return 0x820A8D58;
		/* 820ABCBCh case    3:*/		return 0x820ABCC0;
		  /* 820ABCC0h */ case    4:  		/* stw R3, <#[R31 + 32]> */
		/* 820ABCC0h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 820ABCC0h case    4:*/		return 0x820ABCC4;
		  /* 820ABCC4h */ case    5:  		/* b 892 */
		/* 820ABCC4h case    5:*/		return 0x820AC040;
		/* 820ABCC4h case    5:*/		return 0x820ABCC8;
		  /* 820ABCC8h */ case    6:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABCC8h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABCC8h case    6:*/		return 0x820ABCCC;
		  /* 820ABCCCh */ case    7:  		/* lwz R11, <#[R31 + 20]> */
		/* 820ABCCCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ABCCCh case    7:*/		return 0x820ABCD0;
		  /* 820ABCD0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820ABCD0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ABCD0h case    8:*/		return 0x820ABCD4;
		  /* 820ABCD4h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 820ABCD4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820ABCE8;  }
		/* 820ABCD4h case    9:*/		return 0x820ABCD8;
		  /* 820ABCD8h */ case   10:  		/* lis R11, -32255 */
		/* 820ABCD8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABCD8h case   10:*/		return 0x820ABCDC;
		  /* 820ABCDCh */ case   11:  		/* li R5, 2018 */
		/* 820ABCDCh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x7E2);
		/* 820ABCDCh case   11:*/		return 0x820ABCE0;
		  /* 820ABCE0h */ case   12:  		/* addi R6, R11, 4640 */
		/* 820ABCE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1220);
		/* 820ABCE0h case   12:*/		return 0x820ABCE4;
		  /* 820ABCE4h */ case   13:  		/* b 264 */
		/* 820ABCE4h case   13:*/		return 0x820ABDEC;
		/* 820ABCE4h case   13:*/		return 0x820ABCE8;
	}
	return 0x820ABCE8;
} // Block from 820ABCB0h-820ABCE8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ABCE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABCE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABCE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABCE8);
		  /* 820ABCE8h */ case    0:  		/* lis R11, 3328 */
		/* 820ABCE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xD00);
		/* 820ABCE8h case    0:*/		return 0x820ABCEC;
		  /* 820ABCECh */ case    1:  		/* stw R11, <#[R31 + 20]> */
		/* 820ABCECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ABCECh case    1:*/		return 0x820ABCF0;
		  /* 820ABCF0h */ case    2:  		/* b 848 */
		/* 820ABCF0h case    2:*/		return 0x820AC040;
		/* 820ABCF0h case    2:*/		return 0x820ABCF4;
		  /* 820ABCF4h */ case    3:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABCF4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABCF4h case    3:*/		return 0x820ABCF8;
		  /* 820ABCF8h */ case    4:  		/* lwz R11, <#[R31 + 20]> */
		/* 820ABCF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ABCF8h case    4:*/		return 0x820ABCFC;
		  /* 820ABCFCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820ABCFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ABCFCh case    5:*/		return 0x820ABD00;
		  /* 820ABD00h */ case    6:  		/* bc 12, CR6_EQ, 124 */
		/* 820ABD00h case    6:*/		if ( regs.CR[6].eq ) { return 0x820ABD7C;  }
		/* 820ABD00h case    6:*/		return 0x820ABD04;
		  /* 820ABD04h */ case    7:  		/* lis R10, 512 */
		/* 820ABD04h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 820ABD04h case    7:*/		return 0x820ABD08;
		  /* 820ABD08h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820ABD08h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ABD08h case    8:*/		return 0x820ABD0C;
		  /* 820ABD0Ch */ case    9:  		/* bc 12, CR6_EQ, 104 */
		/* 820ABD0Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820ABD74;  }
		/* 820ABD0Ch case    9:*/		return 0x820ABD10;
		  /* 820ABD10h */ case   10:  		/* lis R10, 1024 */
		/* 820ABD10h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x400);
		/* 820ABD10h case   10:*/		return 0x820ABD14;
		  /* 820ABD14h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820ABD14h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ABD14h case   11:*/		return 0x820ABD18;
		  /* 820ABD18h */ case   12:  		/* bc 12, CR6_EQ, 84 */
		/* 820ABD18h case   12:*/		if ( regs.CR[6].eq ) { return 0x820ABD6C;  }
		/* 820ABD18h case   12:*/		return 0x820ABD1C;
		  /* 820ABD1Ch */ case   13:  		/* lis R10, 1792 */
		/* 820ABD1Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x700);
		/* 820ABD1Ch case   13:*/		return 0x820ABD20;
		  /* 820ABD20h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820ABD20h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ABD20h case   14:*/		return 0x820ABD24;
		  /* 820ABD24h */ case   15:  		/* bc 12, CR6_EQ, 64 */
		/* 820ABD24h case   15:*/		if ( regs.CR[6].eq ) { return 0x820ABD64;  }
		/* 820ABD24h case   15:*/		return 0x820ABD28;
		  /* 820ABD28h */ case   16:  		/* lis R10, 2304 */
		/* 820ABD28h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0x900);
		/* 820ABD28h case   16:*/		return 0x820ABD2C;
		  /* 820ABD2Ch */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 820ABD2Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ABD2Ch case   17:*/		return 0x820ABD30;
		  /* 820ABD30h */ case   18:  		/* bc 12, CR6_EQ, 36 */
		/* 820ABD30h case   18:*/		if ( regs.CR[6].eq ) { return 0x820ABD54;  }
		/* 820ABD30h case   18:*/		return 0x820ABD34;
		  /* 820ABD34h */ case   19:  		/* lis R10, 2560 */
		/* 820ABD34h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xA00);
		/* 820ABD34h case   19:*/		return 0x820ABD38;
		  /* 820ABD38h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 820ABD38h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ABD38h case   20:*/		return 0x820ABD3C;
		  /* 820ABD3Ch */ case   21:  		/* bc 12, CR6_EQ, 24 */
		/* 820ABD3Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x820ABD54;  }
		/* 820ABD3Ch case   21:*/		return 0x820ABD40;
		  /* 820ABD40h */ case   22:  		/* lis R10, 2816 */
		/* 820ABD40h case   22:*/		cpu::op::lis<0>(regs,&regs.R10,0xB00);
		/* 820ABD40h case   22:*/		return 0x820ABD44;
		  /* 820ABD44h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820ABD44h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ABD44h case   23:*/		return 0x820ABD48;
		  /* 820ABD48h */ case   24:  		/* bc 4, CR6_EQ, 760 */
		/* 820ABD48h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820AC040;  }
		/* 820ABD48h case   24:*/		return 0x820ABD4C;
		  /* 820ABD4Ch */ case   25:  		/* lis R11, 3072 */
		/* 820ABD4Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xC00);
		/* 820ABD4Ch case   25:*/		return 0x820ABD50;
		  /* 820ABD50h */ case   26:  		/* b -100 */
		/* 820ABD50h case   26:*/		return 0x820ABCEC;
		/* 820ABD50h case   26:*/		return 0x820ABD54;
	}
	return 0x820ABD54;
} // Block from 820ABCE8h-820ABD54h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820ABD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABD54);
		  /* 820ABD54h */ case    0:  		/* lis R11, -32255 */
		/* 820ABD54h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABD54h case    0:*/		return 0x820ABD58;
		  /* 820ABD58h */ case    1:  		/* li R5, 2011 */
		/* 820ABD58h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7DB);
		/* 820ABD58h case    1:*/		return 0x820ABD5C;
		  /* 820ABD5Ch */ case    2:  		/* addi R6, R11, 4592 */
		/* 820ABD5Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x11F0);
		/* 820ABD5Ch case    2:*/		return 0x820ABD60;
		  /* 820ABD60h */ case    3:  		/* b 140 */
		/* 820ABD60h case    3:*/		return 0x820ABDEC;
		/* 820ABD60h case    3:*/		return 0x820ABD64;
	}
	return 0x820ABD64;
} // Block from 820ABD54h-820ABD64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ABD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABD64);
		  /* 820ABD64h */ case    0:  		/* lis R11, 2048 */
		/* 820ABD64h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 820ABD64h case    0:*/		return 0x820ABD68;
		  /* 820ABD68h */ case    1:  		/* b -124 */
		/* 820ABD68h case    1:*/		return 0x820ABCEC;
		/* 820ABD68h case    1:*/		return 0x820ABD6C;
	}
	return 0x820ABD6C;
} // Block from 820ABD64h-820ABD6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ABD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABD6C);
		  /* 820ABD6Ch */ case    0:  		/* lis R11, 1280 */
		/* 820ABD6Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x500);
		/* 820ABD6Ch case    0:*/		return 0x820ABD70;
		  /* 820ABD70h */ case    1:  		/* b -132 */
		/* 820ABD70h case    1:*/		return 0x820ABCEC;
		/* 820ABD70h case    1:*/		return 0x820ABD74;
	}
	return 0x820ABD74;
} // Block from 820ABD6Ch-820ABD74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ABD74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABD74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABD74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABD74);
		  /* 820ABD74h */ case    0:  		/* lis R11, 768 */
		/* 820ABD74h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x300);
		/* 820ABD74h case    0:*/		return 0x820ABD78;
		  /* 820ABD78h */ case    1:  		/* b -140 */
		/* 820ABD78h case    1:*/		return 0x820ABCEC;
		/* 820ABD78h case    1:*/		return 0x820ABD7C;
	}
	return 0x820ABD7C;
} // Block from 820ABD74h-820ABD7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ABD7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABD7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABD7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABD7C);
		  /* 820ABD7Ch */ case    0:  		/* lis R11, 256 */
		/* 820ABD7Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x100);
		/* 820ABD7Ch case    0:*/		return 0x820ABD80;
		  /* 820ABD80h */ case    1:  		/* b -148 */
		/* 820ABD80h case    1:*/		return 0x820ABCEC;
		/* 820ABD80h case    1:*/		return 0x820ABD84;
		  /* 820ABD84h */ case    2:  		/* lwz R11, <#[R1 + 96]> */
		/* 820ABD84h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABD84h case    2:*/		return 0x820ABD88;
		  /* 820ABD88h */ case    3:  		/* lwz R31, <#[R1 + 100]> */
		/* 820ABD88h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABD88h case    3:*/		return 0x820ABD8C;
		  /* 820ABD8Ch */ case    4:  		/* lwz R11, <#[R11 + 24]> */
		/* 820ABD8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820ABD8Ch case    4:*/		return 0x820ABD90;
		  /* 820ABD90h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 820ABD90h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820ABD90h case    5:*/		return 0x820ABD94;
		  /* 820ABD94h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820ABD94h case    6:*/		if ( regs.CR[6].eq ) { return 0x820ABDA8;  }
		/* 820ABD94h case    6:*/		return 0x820ABD98;
		  /* 820ABD98h */ case    7:  		/* lis R11, -32255 */
		/* 820ABD98h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABD98h case    7:*/		return 0x820ABD9C;
		  /* 820ABD9Ch */ case    8:  		/* li R5, 2010 */
		/* 820ABD9Ch case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x7DA);
		/* 820ABD9Ch case    8:*/		return 0x820ABDA0;
		  /* 820ABDA0h */ case    9:  		/* addi R6, R11, 4560 */
		/* 820ABDA0h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x11D0);
		/* 820ABDA0h case    9:*/		return 0x820ABDA4;
		  /* 820ABDA4h */ case   10:  		/* b 72 */
		/* 820ABDA4h case   10:*/		return 0x820ABDEC;
		/* 820ABDA4h case   10:*/		return 0x820ABDA8;
	}
	return 0x820ABDA8;
} // Block from 820ABD7Ch-820ABDA8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ABDA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABDA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABDA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABDA8);
		  /* 820ABDA8h */ case    0:  		/* lwz R11, <#[R30 + 64]> */
		/* 820ABDA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000040) );
		/* 820ABDA8h case    0:*/		return 0x820ABDAC;
		  /* 820ABDACh */ case    1:  		/* cmpwi CR6, R11, 6 */
		/* 820ABDACh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820ABDACh case    1:*/		return 0x820ABDB0;
		  /* 820ABDB0h */ case    2:  		/* bc 12, CR6_LT, 48 */
		/* 820ABDB0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820ABDE0;  }
		/* 820ABDB0h case    2:*/		return 0x820ABDB4;
		  /* 820ABDB4h */ case    3:  		/* cmpwi CR6, R11, 9 */
		/* 820ABDB4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 820ABDB4h case    3:*/		return 0x820ABDB8;
		  /* 820ABDB8h */ case    4:  		/* bc 12, CR6_GT, 40 */
		/* 820ABDB8h case    4:*/		if ( regs.CR[6].gt ) { return 0x820ABDE0;  }
		/* 820ABDB8h case    4:*/		return 0x820ABDBC;
		  /* 820ABDBCh */ case    5:  		/* lwz R11, <#[R31 + 20]> */
		/* 820ABDBCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ABDBCh case    5:*/		return 0x820ABDC0;
		  /* 820ABDC0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820ABDC0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ABDC0h case    6:*/		return 0x820ABDC4;
		  /* 820ABDC4h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820ABDC4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820ABDD8;  }
		/* 820ABDC4h case    7:*/		return 0x820ABDC8;
		  /* 820ABDC8h */ case    8:  		/* lis R11, -32255 */
		/* 820ABDC8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABDC8h case    8:*/		return 0x820ABDCC;
		  /* 820ABDCCh */ case    9:  		/* li R5, 2012 */
		/* 820ABDCCh case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x7DC);
		/* 820ABDCCh case    9:*/		return 0x820ABDD0;
		  /* 820ABDD0h */ case   10:  		/* addi R6, R11, 4512 */
		/* 820ABDD0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x11A0);
		/* 820ABDD0h case   10:*/		return 0x820ABDD4;
		  /* 820ABDD4h */ case   11:  		/* b 24 */
		/* 820ABDD4h case   11:*/		return 0x820ABDEC;
		/* 820ABDD4h case   11:*/		return 0x820ABDD8;
	}
	return 0x820ABDD8;
} // Block from 820ABDA8h-820ABDD8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820ABDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABDD8);
		  /* 820ABDD8h */ case    0:  		/* lis R11, 1536 */
		/* 820ABDD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x600);
		/* 820ABDD8h case    0:*/		return 0x820ABDDC;
		  /* 820ABDDCh */ case    1:  		/* b -240 */
		/* 820ABDDCh case    1:*/		return 0x820ABCEC;
		/* 820ABDDCh case    1:*/		return 0x820ABDE0;
	}
	return 0x820ABDE0;
} // Block from 820ABDD8h-820ABDE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ABDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABDE0);
		  /* 820ABDE0h */ case    0:  		/* lis R11, -32255 */
		/* 820ABDE0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABDE0h case    0:*/		return 0x820ABDE4;
		  /* 820ABDE4h */ case    1:  		/* li R5, 2029 */
		/* 820ABDE4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7ED);
		/* 820ABDE4h case    1:*/		return 0x820ABDE8;
		  /* 820ABDE8h */ case    2:  		/* addi R6, R11, 4460 */
		/* 820ABDE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x116C);
		/* 820ABDE8h case    2:*/		return 0x820ABDEC;
	}
	return 0x820ABDEC;
} // Block from 820ABDE0h-820ABDECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ABDECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABDEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABDEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABDEC);
		  /* 820ABDECh */ case    0:  		/* addi R4, R30, 16 */
		/* 820ABDECh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820ABDECh case    0:*/		return 0x820ABDF0;
		  /* 820ABDF0h */ case    1:  		/* b -588 */
		/* 820ABDF0h case    1:*/		return 0x820ABBA4;
		/* 820ABDF0h case    1:*/		return 0x820ABDF4;
		  /* 820ABDF4h */ case    2:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABDF4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABDF4h case    2:*/		return 0x820ABDF8;
		  /* 820ABDF8h */ case    3:  		/* lwz R11, <#[R31 + 28]> */
		/* 820ABDF8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820ABDF8h case    3:*/		return 0x820ABDFC;
		  /* 820ABDFCh */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820ABDFCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ABDFCh case    4:*/		return 0x820ABE00;
		  /* 820ABE00h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 820ABE00h case    5:*/		if ( regs.CR[6].eq ) { return 0x820ABE2C;  }
		/* 820ABE00h case    5:*/		return 0x820ABE04;
		  /* 820ABE04h */ case    6:  		/* lis R11, -32255 */
		/* 820ABE04h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABE04h case    6:*/		return 0x820ABE08;
		  /* 820ABE08h */ case    7:  		/* lwz R3, <#[R30]> */
		/* 820ABE08h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820ABE08h case    7:*/		return 0x820ABE0C;
		  /* 820ABE0Ch */ case    8:  		/* li R5, 2022 */
		/* 820ABE0Ch case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x7E6);
		/* 820ABE0Ch case    8:*/		return 0x820ABE10;
		  /* 820ABE10h */ case    9:  		/* addi R6, R11, 4424 */
		/* 820ABE10h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1148);
		/* 820ABE10h case    9:*/		return 0x820ABE14;
		  /* 820ABE14h */ case   10:  		/* addi R4, R30, 16 */
		/* 820ABE14h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820ABE14h case   10:*/		return 0x820ABE18;
		  /* 820ABE18h */ case   11:  		/* bl -19592 */
		/* 820ABE18h case   11:*/		regs.LR = 0x820ABE1C; return 0x820A7190;
		/* 820ABE18h case   11:*/		return 0x820ABE1C;
		  /* 820ABE1Ch */ case   12:  		/* lis R11, 228 */
		/* 820ABE1Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xE4);
		/* 820ABE1Ch case   12:*/		return 0x820ABE20;
		  /* 820ABE20h */ case   13:  		/* stw R28, <#[R30 + 84]> */
		/* 820ABE20h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000054) );
		/* 820ABE20h case   13:*/		return 0x820ABE24;
		  /* 820ABE24h */ case   14:  		/* stw R11, <#[R31 + 36]> */
		/* 820ABE24h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820ABE24h case   14:*/		return 0x820ABE28;
		  /* 820ABE28h */ case   15:  		/* b 536 */
		/* 820ABE28h case   15:*/		return 0x820AC040;
		/* 820ABE28h case   15:*/		return 0x820ABE2C;
	}
	return 0x820ABE2C;
} // Block from 820ABDECh-820ABE2Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 820ABE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABE2C);
		  /* 820ABE2Ch */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 820ABE2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABE2Ch case    0:*/		return 0x820ABE30;
		  /* 820ABE30h */ case    1:  		/* mr R3, R30 */
		/* 820ABE30h case    1:*/		regs.R3 = regs.R30;
		/* 820ABE30h case    1:*/		return 0x820ABE34;
		  /* 820ABE34h */ case    2:  		/* addi R4, R11, 16 */
		/* 820ABE34h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 820ABE34h case    2:*/		return 0x820ABE38;
		  /* 820ABE38h */ case    3:  		/* bl -12240 */
		/* 820ABE38h case    3:*/		regs.LR = 0x820ABE3C; return 0x820A8E68;
		/* 820ABE38h case    3:*/		return 0x820ABE3C;
		  /* 820ABE3Ch */ case    4:  		/* stw R3, <#[R31 + 36]> */
		/* 820ABE3Ch case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000024) );
		/* 820ABE3Ch case    4:*/		return 0x820ABE40;
		  /* 820ABE40h */ case    5:  		/* b 512 */
		/* 820ABE40h case    5:*/		return 0x820AC040;
		/* 820ABE40h case    5:*/		return 0x820ABE44;
		  /* 820ABE44h */ case    6:  		/* li R5, 0 */
		/* 820ABE44h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ABE44h case    6:*/		return 0x820ABE48;
		  /* 820ABE48h */ case    7:  		/* lwz R11, <#[R1 + 96]> */
		/* 820ABE48h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABE48h case    7:*/		return 0x820ABE4C;
		  /* 820ABE4Ch */ case    8:  		/* mr R3, R30 */
		/* 820ABE4Ch case    8:*/		regs.R3 = regs.R30;
		/* 820ABE4Ch case    8:*/		return 0x820ABE50;
		  /* 820ABE50h */ case    9:  		/* addi R4, R11, 16 */
		/* 820ABE50h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 820ABE50h case    9:*/		return 0x820ABE54;
		  /* 820ABE54h */ case   10:  		/* bl -8260 */
		/* 820ABE54h case   10:*/		regs.LR = 0x820ABE58; return 0x820A9E10;
		/* 820ABE54h case   10:*/		return 0x820ABE58;
		  /* 820ABE58h */ case   11:  		/* b 464 */
		/* 820ABE58h case   11:*/		return 0x820AC028;
		/* 820ABE58h case   11:*/		return 0x820ABE5C;
		  /* 820ABE5Ch */ case   12:  		/* lwz R5, <#[R1 + 100]> */
		/* 820ABE5Ch case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABE5Ch case   12:*/		return 0x820ABE60;
		  /* 820ABE60h */ case   13:  		/* b -24 */
		/* 820ABE60h case   13:*/		return 0x820ABE48;
		/* 820ABE60h case   13:*/		return 0x820ABE64;
		  /* 820ABE64h */ case   14:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABE64h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABE64h case   14:*/		return 0x820ABE68;
		  /* 820ABE68h */ case   15:  		/* lwz R11, <#[R1 + 100]> */
		/* 820ABE68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820ABE68h case   15:*/		return 0x820ABE6C;
		  /* 820ABE6Ch */ case   16:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ABE6Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABE6Ch case   16:*/		return 0x820ABE70;
		  /* 820ABE70h */ case   17:  		/* lwz R9, <#[R11 + 24]> */
		/* 820ABE70h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 820ABE70h case   17:*/		return 0x820ABE74;
		  /* 820ABE74h */ case   18:  		/* lwz R8, <#[R31 + 40]> */
		/* 820ABE74h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000028) );
		/* 820ABE74h case   18:*/		return 0x820ABE78;
		  /* 820ABE78h */ case   19:  		/* add R10, R9, R10 */
		/* 820ABE78h case   19:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820ABE78h case   19:*/		return 0x820ABE7C;
		  /* 820ABE7Ch */ case   20:  		/* cmplwi CR6, R8, 0 */
		/* 820ABE7Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820ABE7Ch case   20:*/		return 0x820ABE80;
		  /* 820ABE80h */ case   21:  		/* stw R10, <#[R31 + 24]> */
		/* 820ABE80h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABE80h case   21:*/		return 0x820ABE84;
		  /* 820ABE84h */ case   22:  		/* bc 4, CR6_EQ, 20 */
		/* 820ABE84h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820ABE98;  }
		/* 820ABE84h case   22:*/		return 0x820ABE88;
		  /* 820ABE88h */ case   23:  		/* lwz R10, <#[R11 + 40]> */
		/* 820ABE88h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 820ABE88h case   23:*/		return 0x820ABE8C;
		  /* 820ABE8Ch */ case   24:  		/* stw R10, <#[R31 + 40]> */
		/* 820ABE8Ch case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820ABE8Ch case   24:*/		return 0x820ABE90;
		  /* 820ABE90h */ case   25:  		/* stw R29, <#[R11 + 40]> */
		/* 820ABE90h case   25:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000028) );
		/* 820ABE90h case   25:*/		return 0x820ABE94;
		  /* 820ABE94h */ case   26:  		/* b 428 */
		/* 820ABE94h case   26:*/		return 0x820AC040;
		/* 820ABE94h case   26:*/		return 0x820ABE98;
	}
	return 0x820ABE98;
} // Block from 820ABE2Ch-820ABE98h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820ABE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABE98);
		  /* 820ABE98h */ case    0:  		/* lwz R11, <#[R11 + 40]> */
		/* 820ABE98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 820ABE98h case    0:*/		return 0x820ABE9C;
		  /* 820ABE9Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820ABE9Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ABE9Ch case    1:*/		return 0x820ABEA0;
		  /* 820ABEA0h */ case    2:  		/* bc 12, CR6_EQ, 416 */
		/* 820ABEA0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AC040;  }
		/* 820ABEA0h case    2:*/		return 0x820ABEA4;
		  /* 820ABEA4h */ case    3:  		/* lis R11, -32255 */
		/* 820ABEA4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ABEA4h case    3:*/		return 0x820ABEA8;
		  /* 820ABEA8h */ case    4:  		/* li R5, 2009 */
		/* 820ABEA8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x7D9);
		/* 820ABEA8h case    4:*/		return 0x820ABEAC;
		  /* 820ABEACh */ case    5:  		/* addi R6, R11, 4344 */
		/* 820ABEACh case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x10F8);
		/* 820ABEACh case    5:*/		return 0x820ABEB0;
		  /* 820ABEB0h */ case    6:  		/* b -196 */
		/* 820ABEB0h case    6:*/		return 0x820ABDEC;
		/* 820ABEB0h case    6:*/		return 0x820ABEB4;
		  /* 820ABEB4h */ case    7:  		/* li R3, 44 */
		/* 820ABEB4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x2C);
		/* 820ABEB4h case    7:*/		return 0x820ABEB8;
		  /* 820ABEB8h */ case    8:  		/* bl 119664 */
		/* 820ABEB8h case    8:*/		regs.LR = 0x820ABEBC; return 0x820C9228;
		/* 820ABEB8h case    8:*/		return 0x820ABEBC;
		  /* 820ABEBCh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820ABEBCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820ABEBCh case    9:*/		return 0x820ABEC0;
		  /* 820ABEC0h */ case   10:  		/* bc 12, CR0_EQ, 368 */
		/* 820ABEC0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820AC030;  }
		/* 820ABEC0h case   10:*/		return 0x820ABEC4;
		  /* 820ABEC4h */ case   11:  		/* lwz R8, <#[R1 + 96]> */
		/* 820ABEC4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABEC4h case   11:*/		return 0x820ABEC8;
		  /* 820ABEC8h */ case   12:  		/* li R6, 0 */
		/* 820ABEC8h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820ABEC8h case   12:*/		return 0x820ABECC;
		  /* 820ABECCh */ case   13:  		/* li R4, 0 */
		/* 820ABECCh case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820ABECCh case   13:*/		return 0x820ABED0;
		  /* 820ABED0h */ case   14:  		/* li R5, 0 */
		/* 820ABED0h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ABED0h case   14:*/		return 0x820ABED4;
		  /* 820ABED4h */ case   15:  		/* li R7, 0 */
		/* 820ABED4h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820ABED4h case   15:*/		return 0x820ABED8;
		  /* 820ABED8h */ case   16:  		/* bl 139704 */
		/* 820ABED8h case   16:*/		regs.LR = 0x820ABEDC; return 0x820CE090;
		/* 820ABED8h case   16:*/		return 0x820ABEDC;
		  /* 820ABEDCh */ case   17:  		/* b 332 */
		/* 820ABEDCh case   17:*/		return 0x820AC028;
		/* 820ABEDCh case   17:*/		return 0x820ABEE0;
		  /* 820ABEE0h */ case   18:  		/* li R3, 44 */
		/* 820ABEE0h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x2C);
		/* 820ABEE0h case   18:*/		return 0x820ABEE4;
		  /* 820ABEE4h */ case   19:  		/* bl 119620 */
		/* 820ABEE4h case   19:*/		regs.LR = 0x820ABEE8; return 0x820C9228;
		/* 820ABEE4h case   19:*/		return 0x820ABEE8;
		  /* 820ABEE8h */ case   20:  		/* cmplwi CR0, R3, 0 */
		/* 820ABEE8h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820ABEE8h case   20:*/		return 0x820ABEEC;
		  /* 820ABEECh */ case   21:  		/* bc 12, CR0_EQ, 324 */
		/* 820ABEECh case   21:*/		if ( regs.CR[0].eq ) { return 0x820AC030;  }
		/* 820ABEECh case   21:*/		return 0x820ABEF0;
		  /* 820ABEF0h */ case   22:  		/* lwz R11, <#[R1 + 96]> */
		/* 820ABEF0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABEF0h case   22:*/		return 0x820ABEF4;
		  /* 820ABEF4h */ case   23:  		/* li R8, 0 */
		/* 820ABEF4h case   23:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820ABEF4h case   23:*/		return 0x820ABEF8;
		  /* 820ABEF8h */ case   24:  		/* lwz R6, <#[R11 + 24]> */
		/* 820ABEF8h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000018) );
		/* 820ABEF8h case   24:*/		return 0x820ABEFC;
		  /* 820ABEFCh */ case   25:  		/* b -48 */
		/* 820ABEFCh case   25:*/		return 0x820ABECC;
		/* 820ABEFCh case   25:*/		return 0x820ABF00;
		  /* 820ABF00h */ case   26:  		/* li R3, 56 */
		/* 820ABF00h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820ABF00h case   26:*/		return 0x820ABF04;
		  /* 820ABF04h */ case   27:  		/* bl 119588 */
		/* 820ABF04h case   27:*/		regs.LR = 0x820ABF08; return 0x820C9228;
		/* 820ABF04h case   27:*/		return 0x820ABF08;
		  /* 820ABF08h */ case   28:  		/* cmplwi CR0, R3, 0 */
		/* 820ABF08h case   28:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820ABF08h case   28:*/		return 0x820ABF0C;
		  /* 820ABF0Ch */ case   29:  		/* bc 12, CR0_EQ, 20 */
		/* 820ABF0Ch case   29:*/		if ( regs.CR[0].eq ) { return 0x820ABF20;  }
		/* 820ABF0Ch case   29:*/		return 0x820ABF10;
		  /* 820ABF10h */ case   30:  		/* addi R4, R30, 16 */
		/* 820ABF10h case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820ABF10h case   30:*/		return 0x820ABF14;
		  /* 820ABF14h */ case   31:  		/* bl 121148 */
		/* 820ABF14h case   31:*/		regs.LR = 0x820ABF18; return 0x820C9850;
		/* 820ABF14h case   31:*/		return 0x820ABF18;
		  /* 820ABF18h */ case   32:  		/* mr R31, R3 */
		/* 820ABF18h case   32:*/		regs.R31 = regs.R3;
		/* 820ABF18h case   32:*/		return 0x820ABF1C;
		  /* 820ABF1Ch */ case   33:  		/* b 8 */
		/* 820ABF1Ch case   33:*/		return 0x820ABF24;
		/* 820ABF1Ch case   33:*/		return 0x820ABF20;
	}
	return 0x820ABF20;
} // Block from 820ABE98h-820ABF20h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820ABF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABF20);
		  /* 820ABF20h */ case    0:  		/* mr R31, R29 */
		/* 820ABF20h case    0:*/		regs.R31 = regs.R29;
		/* 820ABF20h case    0:*/		return 0x820ABF24;
	}
	return 0x820ABF24;
} // Block from 820ABF20h-820ABF24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ABF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABF24);
		  /* 820ABF24h */ case    0:  		/* mr R4, R31 */
		/* 820ABF24h case    0:*/		regs.R4 = regs.R31;
		/* 820ABF24h case    0:*/		return 0x820ABF28;
		  /* 820ABF28h */ case    1:  		/* mr R3, R30 */
		/* 820ABF28h case    1:*/		regs.R3 = regs.R30;
		/* 820ABF28h case    1:*/		return 0x820ABF2C;
		  /* 820ABF2Ch */ case    2:  		/* bl -12876 */
		/* 820ABF2Ch case    2:*/		regs.LR = 0x820ABF30; return 0x820A8CE0;
		/* 820ABF2Ch case    2:*/		return 0x820ABF30;
		  /* 820ABF30h */ case    3:  		/* stw R28, <#[R31 + 24]> */
		/* 820ABF30h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABF30h case    3:*/		return 0x820ABF34;
		  /* 820ABF34h */ case    4:  		/* li R11, 2 */
		/* 820ABF34h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820ABF34h case    4:*/		return 0x820ABF38;
		  /* 820ABF38h */ case    5:  		/* stw R11, <#[R31 + 16]> */
		/* 820ABF38h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ABF38h case    5:*/		return 0x820ABF3C;
		  /* 820ABF3Ch */ case    6:  		/* b 260 */
		/* 820ABF3Ch case    6:*/		return 0x820AC040;
		/* 820ABF3Ch case    6:*/		return 0x820ABF40;
	}
	return 0x820ABF40;
} // Block from 820ABF24h-820ABF40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ABF40h
// Function '?EmitDebugInfo@CAssembler@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABF40);
		  /* 820ABF40h */ case    0:  		/* li R3, 56 */
		/* 820ABF40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820ABF40h case    0:*/		return 0x820ABF44;
		  /* 820ABF44h */ case    1:  		/* bl 119524 */
		/* 820ABF44h case    1:*/		regs.LR = 0x820ABF48; return 0x820C9228;
		/* 820ABF44h case    1:*/		return 0x820ABF48;
		  /* 820ABF48h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820ABF48h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820ABF48h case    2:*/		return 0x820ABF4C;
		  /* 820ABF4Ch */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 820ABF4Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820ABF60;  }
		/* 820ABF4Ch case    3:*/		return 0x820ABF50;
		  /* 820ABF50h */ case    4:  		/* addi R4, R30, 16 */
		/* 820ABF50h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820ABF50h case    4:*/		return 0x820ABF54;
		  /* 820ABF54h */ case    5:  		/* bl 121084 */
		/* 820ABF54h case    5:*/		regs.LR = 0x820ABF58; return 0x820C9850;
		/* 820ABF54h case    5:*/		return 0x820ABF58;
		  /* 820ABF58h */ case    6:  		/* mr R31, R3 */
		/* 820ABF58h case    6:*/		regs.R31 = regs.R3;
		/* 820ABF58h case    6:*/		return 0x820ABF5C;
		  /* 820ABF5Ch */ case    7:  		/* b 8 */
		/* 820ABF5Ch case    7:*/		return 0x820ABF64;
		/* 820ABF5Ch case    7:*/		return 0x820ABF60;
	}
	return 0x820ABF60;
} // Block from 820ABF40h-820ABF60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820ABF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABF60);
		  /* 820ABF60h */ case    0:  		/* mr R31, R29 */
		/* 820ABF60h case    0:*/		regs.R31 = regs.R29;
		/* 820ABF60h case    0:*/		return 0x820ABF64;
	}
	return 0x820ABF64;
} // Block from 820ABF60h-820ABF64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ABF64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ABF64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ABF64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ABF64);
		  /* 820ABF64h */ case    0:  		/* mr R4, R31 */
		/* 820ABF64h case    0:*/		regs.R4 = regs.R31;
		/* 820ABF64h case    0:*/		return 0x820ABF68;
		  /* 820ABF68h */ case    1:  		/* mr R3, R30 */
		/* 820ABF68h case    1:*/		regs.R3 = regs.R30;
		/* 820ABF68h case    1:*/		return 0x820ABF6C;
		  /* 820ABF6Ch */ case    2:  		/* bl -12940 */
		/* 820ABF6Ch case    2:*/		regs.LR = 0x820ABF70; return 0x820A8CE0;
		/* 820ABF6Ch case    2:*/		return 0x820ABF70;
		  /* 820ABF70h */ case    3:  		/* stw R29, <#[R31 + 24]> */
		/* 820ABF70h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABF70h case    3:*/		return 0x820ABF74;
		  /* 820ABF74h */ case    4:  		/* b -64 */
		/* 820ABF74h case    4:*/		return 0x820ABF34;
		/* 820ABF74h case    4:*/		return 0x820ABF78;
		  /* 820ABF78h */ case    5:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABF78h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABF78h case    5:*/		return 0x820ABF7C;
		  /* 820ABF7Ch */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820ABF7Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABF7Ch case    6:*/		return 0x820ABF80;
		  /* 820ABF80h */ case    7:  		/* neg R11, R11 */
		/* 820ABF80h case    7:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 820ABF80h case    7:*/		return 0x820ABF84;
		  /* 820ABF84h */ case    8:  		/* stw R11, <#[R31 + 24]> */
		/* 820ABF84h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABF84h case    8:*/		return 0x820ABF88;
		  /* 820ABF88h */ case    9:  		/* b 184 */
		/* 820ABF88h case    9:*/		return 0x820AC040;
		/* 820ABF88h case    9:*/		return 0x820ABF8C;
		  /* 820ABF8Ch */ case   10:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABF8Ch case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABF8Ch case   10:*/		return 0x820ABF90;
		  /* 820ABF90h */ case   11:  		/* li R11, 7 */
		/* 820ABF90h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820ABF90h case   11:*/		return 0x820ABF94;
		  /* 820ABF94h */ case   12:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ABF94h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABF94h case   12:*/		return 0x820ABF98;
		  /* 820ABF98h */ case   13:  		/* stw R11, <#[R31 + 16]> */
		/* 820ABF98h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ABF98h case   13:*/		return 0x820ABF9C;
		  /* 820ABF9Ch */ case   14:  		/* mr R11, R10 */
		/* 820ABF9Ch case   14:*/		regs.R11 = regs.R10;
		/* 820ABF9Ch case   14:*/		return 0x820ABFA0;
		  /* 820ABFA0h */ case   15:  		/* std R10, <#[R1 + 80]> */
		/* 820ABFA0h case   15:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ABFA0h case   15:*/		return 0x820ABFA4;
		  /* 820ABFA4h */ case   16:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820ABFA4h case   16:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820ABFA4h case   16:*/		return 0x820ABFA8;
		  /* 820ABFA8h */ case   17:  		/* fcfid FR0, FR0 */
		/* 820ABFA8h case   17:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820ABFA8h case   17:*/		return 0x820ABFAC;
		  /* 820ABFACh */ case   18:  		/* stfd FR0, <#[R31 + 24]> */
		/* 820ABFACh case   18:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABFACh case   18:*/		return 0x820ABFB0;
		  /* 820ABFB0h */ case   19:  		/* b 144 */
		/* 820ABFB0h case   19:*/		return 0x820AC040;
		/* 820ABFB0h case   19:*/		return 0x820ABFB4;
		  /* 820ABFB4h */ case   20:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABFB4h case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABFB4h case   20:*/		return 0x820ABFB8;
		  /* 820ABFB8h */ case   21:  		/* li R11, 7 */
		/* 820ABFB8h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820ABFB8h case   21:*/		return 0x820ABFBC;
		  /* 820ABFBCh */ case   22:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ABFBCh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABFBCh case   22:*/		return 0x820ABFC0;
		  /* 820ABFC0h */ case   23:  		/* stw R11, <#[R31 + 16]> */
		/* 820ABFC0h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ABFC0h case   23:*/		return 0x820ABFC4;
		  /* 820ABFC4h */ case   24:  		/* mr R11, R10 */
		/* 820ABFC4h case   24:*/		regs.R11 = regs.R10;
		/* 820ABFC4h case   24:*/		return 0x820ABFC8;
		  /* 820ABFC8h */ case   25:  		/* std R10, <#[R1 + 80]> */
		/* 820ABFC8h case   25:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820ABFC8h case   25:*/		return 0x820ABFCC;
		  /* 820ABFCCh */ case   26:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820ABFCCh case   26:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820ABFCCh case   26:*/		return 0x820ABFD0;
		  /* 820ABFD0h */ case   27:  		/* fcfid FR0, FR0 */
		/* 820ABFD0h case   27:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820ABFD0h case   27:*/		return 0x820ABFD4;
		  /* 820ABFD4h */ case   28:  		/* fneg FR0, FR0 */
		/* 820ABFD4h case   28:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 820ABFD4h case   28:*/		return 0x820ABFD8;
		  /* 820ABFD8h */ case   29:  		/* b -44 */
		/* 820ABFD8h case   29:*/		return 0x820ABFAC;
		/* 820ABFD8h case   29:*/		return 0x820ABFDC;
		  /* 820ABFDCh */ case   30:  		/* lwz R31, <#[R1 + 96]> */
		/* 820ABFDCh case   30:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 820ABFDCh case   30:*/		return 0x820ABFE0;
		  /* 820ABFE0h */ case   31:  		/* lfd FR0, <#[R31 + 24]> */
		/* 820ABFE0h case   31:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000018) );
		/* 820ABFE0h case   31:*/		return 0x820ABFE4;
		  /* 820ABFE4h */ case   32:  		/* b -16 */
		/* 820ABFE4h case   32:*/		return 0x820ABFD4;
		/* 820ABFE4h case   32:*/		return 0x820ABFE8;
		  /* 820ABFE8h */ case   33:  		/* li R3, 104 */
		/* 820ABFE8h case   33:*/		cpu::op::li<0>(regs,&regs.R3,0x68);
		/* 820ABFE8h case   33:*/		return 0x820ABFEC;
		  /* 820ABFECh */ case   34:  		/* bl 119356 */
		/* 820ABFECh case   34:*/		regs.LR = 0x820ABFF0; return 0x820C9228;
		/* 820ABFECh case   34:*/		return 0x820ABFF0;
		  /* 820ABFF0h */ case   35:  		/* cmplwi CR0, R3, 0 */
		/* 820ABFF0h case   35:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820ABFF0h case   35:*/		return 0x820ABFF4;
		  /* 820ABFF4h */ case   36:  		/* bc 12, CR0_EQ, 60 */
		/* 820ABFF4h case   36:*/		if ( regs.CR[0].eq ) { return 0x820AC030;  }
		/* 820ABFF4h case   36:*/		return 0x820ABFF8;
		  /* 820ABFF8h */ case   37:  		/* addi R4, R30, 16 */
		/* 820ABFF8h case   37:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820ABFF8h case   37:*/		return 0x820ABFFC;
		  /* 820ABFFCh */ case   38:  		/* lwz R7, <#[R30 + 80]> */
		/* 820ABFFCh case   38:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000050) );
		/* 820ABFFCh case   38:*/		return 0x820AC000;
		  /* 820AC000h */ case   39:  		/* lwz R6, <#[R30 + 76]> */
		/* 820AC000h case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000004C) );
		/* 820AC000h case   39:*/		return 0x820AC004;
		  /* 820AC004h */ case   40:  		/* lwz R5, <#[R30 + 72]> */
		/* 820AC004h case   40:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000048) );
		/* 820AC004h case   40:*/		return 0x820AC008;
		  /* 820AC008h */ case   41:  		/* bl 138848 */
		/* 820AC008h case   41:*/		regs.LR = 0x820AC00C; return 0x820CDE68;
		/* 820AC008h case   41:*/		return 0x820AC00C;
		  /* 820AC00Ch */ case   42:  		/* b 28 */
		/* 820AC00Ch case   42:*/		return 0x820AC028;
		/* 820AC00Ch case   42:*/		return 0x820AC010;
		  /* 820AC010h */ case   43:  		/* li R3, 56 */
		/* 820AC010h case   43:*/		cpu::op::li<0>(regs,&regs.R3,0x38);
		/* 820AC010h case   43:*/		return 0x820AC014;
		  /* 820AC014h */ case   44:  		/* bl 119316 */
		/* 820AC014h case   44:*/		regs.LR = 0x820AC018; return 0x820C9228;
		/* 820AC014h case   44:*/		return 0x820AC018;
		  /* 820AC018h */ case   45:  		/* cmplwi CR0, R3, 0 */
		/* 820AC018h case   45:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AC018h case   45:*/		return 0x820AC01C;
		  /* 820AC01Ch */ case   46:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC01Ch case   46:*/		if ( regs.CR[0].eq ) { return 0x820AC030;  }
		/* 820AC01Ch case   46:*/		return 0x820AC020;
		  /* 820AC020h */ case   47:  		/* addi R4, R30, 16 */
		/* 820AC020h case   47:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820AC020h case   47:*/		return 0x820AC024;
		  /* 820AC024h */ case   48:  		/* bl 120876 */
		/* 820AC024h case   48:*/		regs.LR = 0x820AC028; return 0x820C9850;
		/* 820AC024h case   48:*/		return 0x820AC028;
	}
	return 0x820AC028;
} // Block from 820ABF64h-820AC028h (49 instructions)

//////////////////////////////////////////////////////
// Block at 820AC028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC028);
		  /* 820AC028h */ case    0:  		/* mr R31, R3 */
		/* 820AC028h case    0:*/		regs.R31 = regs.R3;
		/* 820AC028h case    0:*/		return 0x820AC02C;
		  /* 820AC02Ch */ case    1:  		/* b 8 */
		/* 820AC02Ch case    1:*/		return 0x820AC034;
		/* 820AC02Ch case    1:*/		return 0x820AC030;
	}
	return 0x820AC030;
} // Block from 820AC028h-820AC030h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC030);
		  /* 820AC030h */ case    0:  		/* mr R31, R29 */
		/* 820AC030h case    0:*/		regs.R31 = regs.R29;
		/* 820AC030h case    0:*/		return 0x820AC034;
	}
	return 0x820AC034;
} // Block from 820AC030h-820AC034h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AC034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC034);
		  /* 820AC034h */ case    0:  		/* mr R4, R31 */
		/* 820AC034h case    0:*/		regs.R4 = regs.R31;
		/* 820AC034h case    0:*/		return 0x820AC038;
		  /* 820AC038h */ case    1:  		/* mr R3, R30 */
		/* 820AC038h case    1:*/		regs.R3 = regs.R30;
		/* 820AC038h case    1:*/		return 0x820AC03C;
		  /* 820AC03Ch */ case    2:  		/* bl -13148 */
		/* 820AC03Ch case    2:*/		regs.LR = 0x820AC040; return 0x820A8CE0;
		/* 820AC03Ch case    2:*/		return 0x820AC040;
	}
	return 0x820AC040;
} // Block from 820AC034h-820AC040h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AC040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC040);
		  /* 820AC040h */ case    0:  		/* lwz R11, <#[R30 + 88]> */
		/* 820AC040h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000058) );
		/* 820AC040h case    0:*/		return 0x820AC044;
		  /* 820AC044h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AC044h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AC044h case    1:*/		return 0x820AC048;
		  /* 820AC048h */ case    2:  		/* bc 4, CR6_EQ, 96 */
		/* 820AC048h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AC0A8;  }
		/* 820AC048h case    2:*/		return 0x820AC04C;
		  /* 820AC04Ch */ case    3:  		/* li R3, 20 */
		/* 820AC04Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 820AC04Ch case    3:*/		return 0x820AC050;
		  /* 820AC050h */ case    4:  		/* bl 119256 */
		/* 820AC050h case    4:*/		regs.LR = 0x820AC054; return 0x820C9228;
		/* 820AC050h case    4:*/		return 0x820AC054;
		  /* 820AC054h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820AC054h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AC054h case    5:*/		return 0x820AC058;
		  /* 820AC058h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 820AC058h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AC074;  }
		/* 820AC058h case    6:*/		return 0x820AC05C;
		  /* 820AC05Ch */ case    7:  		/* lis R11, -32255 */
		/* 820AC05Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC05Ch case    7:*/		return 0x820AC060;
		  /* 820AC060h */ case    8:  		/* lwz R5, <#[R30 + 60]> */
		/* 820AC060h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000003C) );
		/* 820AC060h case    8:*/		return 0x820AC064;
		  /* 820AC064h */ case    9:  		/* mr R4, R31 */
		/* 820AC064h case    9:*/		regs.R4 = regs.R31;
		/* 820AC064h case    9:*/		return 0x820AC068;
		  /* 820AC068h */ case   10:  		/* addi R6, R11, -10008 */
		/* 820AC068h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD8E8);
		/* 820AC068h case   10:*/		return 0x820AC06C;
		  /* 820AC06Ch */ case   11:  		/* bl 119684 */
		/* 820AC06Ch case   11:*/		regs.LR = 0x820AC070; return 0x820C93F0;
		/* 820AC06Ch case   11:*/		return 0x820AC070;
		  /* 820AC070h */ case   12:  		/* b 8 */
		/* 820AC070h case   12:*/		return 0x820AC078;
		/* 820AC070h case   12:*/		return 0x820AC074;
	}
	return 0x820AC074;
} // Block from 820AC040h-820AC074h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AC074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC074);
		  /* 820AC074h */ case    0:  		/* mr R3, R29 */
		/* 820AC074h case    0:*/		regs.R3 = regs.R29;
		/* 820AC074h case    0:*/		return 0x820AC078;
	}
	return 0x820AC078;
} // Block from 820AC074h-820AC078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AC078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC078);
		  /* 820AC078h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820AC078h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AC078h case    0:*/		return 0x820AC07C;
		  /* 820AC07Ch */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 820AC07Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AC0A4;  }
		/* 820AC07Ch case    1:*/		return 0x820AC080;
		  /* 820AC080h */ case    2:  		/* lis R11, -32255 */
		/* 820AC080h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC080h case    2:*/		return 0x820AC084;
		  /* 820AC084h */ case    3:  		/* lwz R3, <#[R30]> */
		/* 820AC084h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820AC084h case    3:*/		return 0x820AC088;
		  /* 820AC088h */ case    4:  		/* li R5, 0 */
		/* 820AC088h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820AC088h case    4:*/		return 0x820AC08C;
		  /* 820AC08Ch */ case    5:  		/* addi R6, R11, -10040 */
		/* 820AC08Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD8C8);
		/* 820AC08Ch case    5:*/		return 0x820AC090;
		  /* 820AC090h */ case    6:  		/* addi R4, R30, 16 */
		/* 820AC090h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x10);
		/* 820AC090h case    6:*/		return 0x820AC094;
		  /* 820AC094h */ case    7:  		/* bl -20228 */
		/* 820AC094h case    7:*/		regs.LR = 0x820AC098; return 0x820A7190;
		/* 820AC094h case    7:*/		return 0x820AC098;
		  /* 820AC098h */ case    8:  		/* stw R28, <#[R30 + 88]> */
		/* 820AC098h case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000058) );
		/* 820AC098h case    8:*/		return 0x820AC09C;
		  /* 820AC09Ch */ case    9:  		/* stw R28, <#[R30 + 84]> */
		/* 820AC09Ch case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000054) );
		/* 820AC09Ch case    9:*/		return 0x820AC0A0;
		  /* 820AC0A0h */ case   10:  		/* b 8 */
		/* 820AC0A0h case   10:*/		return 0x820AC0A8;
		/* 820AC0A0h case   10:*/		return 0x820AC0A4;
	}
	return 0x820AC0A4;
} // Block from 820AC078h-820AC0A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AC0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC0A4);
		  /* 820AC0A4h */ case    0:  		/* stw R3, <#[R30 + 60]> */
		/* 820AC0A4h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000003C) );
		/* 820AC0A4h case    0:*/		return 0x820AC0A8;
	}
	return 0x820AC0A8;
} // Block from 820AC0A4h-820AC0A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AC0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC0A8);
		  /* 820AC0A8h */ case    0:  		/* addi R1, R1, 208 */
		/* 820AC0A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820AC0A8h case    0:*/		return 0x820AC0AC;
		  /* 820AC0ACh */ case    1:  		/* b -110084 */
		/* 820AC0ACh case    1:*/		return 0x820912A8;
		/* 820AC0ACh case    1:*/		return 0x820AC0B0;
	}
	return 0x820AC0B0;
} // Block from 820AC0A8h-820AC0B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC0B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC0B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC0B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC0B0);
		  /* 820AC0B0h */ case    0:  		/* mfspr R12, LR */
		/* 820AC0B0h case    0:*/		regs.R12 = regs.LR;
		/* 820AC0B0h case    0:*/		return 0x820AC0B4;
		  /* 820AC0B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AC0B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AC0B4h case    1:*/		return 0x820AC0B8;
		  /* 820AC0B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820AC0B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AC0B8h case    2:*/		return 0x820AC0BC;
		  /* 820AC0BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820AC0BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AC0BCh case    3:*/		return 0x820AC0C0;
		  /* 820AC0C0h */ case    4:  		/* ld R12, <#[R1 - 4096]> */
		/* 820AC0C0h case    4:*/		cpu::mem::load64( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFF000) );
		/* 820AC0C0h case    4:*/		return 0x820AC0C4;
		  /* 820AC0C4h */ case    5:  		/* stwu R1, <#[R1 - 4208]> */
		/* 820AC0C4h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFEF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFEF90);
		/* 820AC0C4h case    5:*/		return 0x820AC0C8;
		  /* 820AC0C8h */ case    6:  		/* li R11, 1 */
		/* 820AC0C8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820AC0C8h case    6:*/		return 0x820AC0CC;
		  /* 820AC0CCh */ case    7:  		/* lis R10, -32255 */
		/* 820AC0CCh case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AC0CCh case    7:*/		return 0x820AC0D0;
		  /* 820AC0D0h */ case    8:  		/* stw R11, <#[R3 + 84]> */
		/* 820AC0D0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 820AC0D0h case    8:*/		return 0x820AC0D4;
		  /* 820AC0D4h */ case    9:  		/* mr R31, R3 */
		/* 820AC0D4h case    9:*/		regs.R31 = regs.R3;
		/* 820AC0D4h case    9:*/		return 0x820AC0D8;
		  /* 820AC0D8h */ case   10:  		/* mr R6, R5 */
		/* 820AC0D8h case   10:*/		regs.R6 = regs.R5;
		/* 820AC0D8h case   10:*/		return 0x820AC0DC;
		  /* 820AC0DCh */ case   11:  		/* mr R11, R4 */
		/* 820AC0DCh case   11:*/		regs.R11 = regs.R4;
		/* 820AC0DCh case   11:*/		return 0x820AC0E0;
		  /* 820AC0E0h */ case   12:  		/* addi R10, R10, -10392 */
		/* 820AC0E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFD768);
		/* 820AC0E0h case   12:*/		return 0x820AC0E4;
		  /* 820AC0E4h */ case   13:  		/* lbz R9, <#[R11]> */
		/* 820AC0E4h case   13:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC0E4h case   13:*/		return 0x820AC0E8;
		  /* 820AC0E8h */ case   14:  		/* lbz R8, <#[R10]> */
		/* 820AC0E8h case   14:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC0E8h case   14:*/		return 0x820AC0EC;
		  /* 820AC0ECh */ case   15:  		/* cmpwi CR0, R9, 0 */
		/* 820AC0ECh case   15:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC0ECh case   15:*/		return 0x820AC0F0;
		  /* 820AC0F0h */ case   16:  		/* subf R9, R8, R9 */
		/* 820AC0F0h case   16:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC0F0h case   16:*/		return 0x820AC0F4;
		  /* 820AC0F4h */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC0F4h case   17:*/		if ( regs.CR[0].eq ) { return 0x820AC108;  }
		/* 820AC0F4h case   17:*/		return 0x820AC0F8;
		  /* 820AC0F8h */ case   18:  		/* addi R11, R11, 1 */
		/* 820AC0F8h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC0F8h case   18:*/		return 0x820AC0FC;
		  /* 820AC0FCh */ case   19:  		/* addi R10, R10, 1 */
		/* 820AC0FCh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC0FCh case   19:*/		return 0x820AC100;
		  /* 820AC100h */ case   20:  		/* cmpwi CR6, R9, 0 */
		/* 820AC100h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC100h case   20:*/		return 0x820AC104;
		  /* 820AC104h */ case   21:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC104h case   21:*/		if ( regs.CR[6].eq ) { return 0x820AC0E4;  }
		/* 820AC104h case   21:*/		return 0x820AC108;
	}
	return 0x820AC108;
} // Block from 820AC0B0h-820AC108h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820AC108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC108);
		  /* 820AC108h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC108h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC108h case    0:*/		return 0x820AC10C;
		  /* 820AC10Ch */ case    1:  		/* bc 4, CR0_EQ, 112 */
		/* 820AC10Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC17C;  }
		/* 820AC10Ch case    1:*/		return 0x820AC110;
		  /* 820AC110h */ case    2:  		/* addi R30, R31, 16 */
		/* 820AC110h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x10);
		/* 820AC110h case    2:*/		return 0x820AC114;
		  /* 820AC114h */ case    3:  		/* lwz R3, <#[R31]> */
		/* 820AC114h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AC114h case    3:*/		return 0x820AC118;
		  /* 820AC118h */ case    4:  		/* li R4, 2000 */
		/* 820AC118h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x7D0);
		/* 820AC118h case    4:*/		return 0x820AC11C;
		  /* 820AC11Ch */ case    5:  		/* mr R5, R30 */
		/* 820AC11Ch case    5:*/		regs.R5 = regs.R30;
		/* 820AC11Ch case    5:*/		return 0x820AC120;
		  /* 820AC120h */ case    6:  		/* bl -19840 */
		/* 820AC120h case    6:*/		regs.LR = 0x820AC124; return 0x820A73A0;
		/* 820AC120h case    6:*/		return 0x820AC124;
		  /* 820AC124h */ case    7:  		/* lwz R11, <#[R31 + 16]> */
		/* 820AC124h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820AC124h case    7:*/		return 0x820AC128;
		  /* 820AC128h */ case    8:  		/* cmpwi CR6, R11, 11 */
		/* 820AC128h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820AC128h case    8:*/		return 0x820AC12C;
		  /* 820AC12Ch */ case    9:  		/* bc 4, CR6_EQ, 132 */
		/* 820AC12Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820AC1B0;  }
		/* 820AC12Ch case    9:*/		return 0x820AC130;
		  /* 820AC130h */ case   10:  		/* lwz R11, <#[R31 + 96]> */
		/* 820AC130h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820AC130h case   10:*/		return 0x820AC134;
		  /* 820AC134h */ case   11:  		/* cmplwi CR6, R11, 2023 */
		/* 820AC134h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000007E7);
		/* 820AC134h case   11:*/		return 0x820AC138;
		  /* 820AC138h */ case   12:  		/* bc 4, CR6_EQ, 32 */
		/* 820AC138h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820AC158;  }
		/* 820AC138h case   12:*/		return 0x820AC13C;
		  /* 820AC13Ch */ case   13:  		/* lis R11, -32255 */
		/* 820AC13Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC13Ch case   13:*/		return 0x820AC140;
		  /* 820AC140h */ case   14:  		/* lwz R7, <#[R31 + 24]> */
		/* 820AC140h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 820AC140h case   14:*/		return 0x820AC144;
		  /* 820AC144h */ case   15:  		/* li R5, 2023 */
		/* 820AC144h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x7E7);
		/* 820AC144h case   15:*/		return 0x820AC148;
		  /* 820AC148h */ case   16:  		/* lwz R3, <#[R31]> */
		/* 820AC148h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AC148h case   16:*/		return 0x820AC14C;
		  /* 820AC14Ch */ case   17:  		/* addi R6, R11, 4880 */
		/* 820AC14Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1310);
		/* 820AC14Ch case   17:*/		return 0x820AC150;
		  /* 820AC150h */ case   18:  		/* mr R4, R30 */
		/* 820AC150h case   18:*/		regs.R4 = regs.R30;
		/* 820AC150h case   18:*/		return 0x820AC154;
		  /* 820AC154h */ case   19:  		/* bl -20420 */
		/* 820AC154h case   19:*/		regs.LR = 0x820AC158; return 0x820A7190;
		/* 820AC154h case   19:*/		return 0x820AC158;
	}
	return 0x820AC158;
} // Block from 820AC108h-820AC158h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AC158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC158);
		  /* 820AC158h */ case    0:  		/* lwz R11, <#[R31 + 96]> */
		/* 820AC158h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 820AC158h case    0:*/		return 0x820AC15C;
		  /* 820AC15Ch */ case    1:  		/* cmplwi CR6, R11, 2024 */
		/* 820AC15Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000007E8);
		/* 820AC15Ch case    1:*/		return 0x820AC160;
		  /* 820AC160h */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 820AC160h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AC1B0;  }
		/* 820AC160h case    2:*/		return 0x820AC164;
		  /* 820AC164h */ case    3:  		/* lis R11, -32255 */
		/* 820AC164h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC164h case    3:*/		return 0x820AC168;
		  /* 820AC168h */ case    4:  		/* lwz R7, <#[R31 + 24]> */
		/* 820AC168h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 820AC168h case    4:*/		return 0x820AC16C;
		  /* 820AC16Ch */ case    5:  		/* li R5, 2024 */
		/* 820AC16Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x7E8);
		/* 820AC16Ch case    5:*/		return 0x820AC170;
		  /* 820AC170h */ case    6:  		/* addi R6, R11, 4844 */
		/* 820AC170h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x12EC);
		/* 820AC170h case    6:*/		return 0x820AC174;
		  /* 820AC174h */ case    7:  		/* mr R4, R30 */
		/* 820AC174h case    7:*/		regs.R4 = regs.R30;
		/* 820AC174h case    7:*/		return 0x820AC178;
		  /* 820AC178h */ case    8:  		/* b 48 */
		/* 820AC178h case    8:*/		return 0x820AC1A8;
		/* 820AC178h case    8:*/		return 0x820AC17C;
	}
	return 0x820AC17C;
} // Block from 820AC158h-820AC17Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AC17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC17C);
		  /* 820AC17Ch */ case    0:  		/* mr R5, R4 */
		/* 820AC17Ch case    0:*/		regs.R5 = regs.R4;
		/* 820AC17Ch case    0:*/		return 0x820AC180;
		  /* 820AC180h */ case    1:  		/* li R4, 4096 */
		/* 820AC180h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1000);
		/* 820AC180h case    1:*/		return 0x820AC184;
		  /* 820AC184h */ case    2:  		/* addi R3, R1, 80 */
		/* 820AC184h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820AC184h case    2:*/		return 0x820AC188;
		  /* 820AC188h */ case    3:  		/* bl -53920 */
		/* 820AC188h case    3:*/		regs.LR = 0x820AC18C; return 0x8209EEE8;
		/* 820AC188h case    3:*/		return 0x820AC18C;
		  /* 820AC18Ch */ case    4:  		/* li R11, 0 */
		/* 820AC18Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AC18Ch case    4:*/		return 0x820AC190;
		  /* 820AC190h */ case    5:  		/* lis R10, -32255 */
		/* 820AC190h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AC190h case    5:*/		return 0x820AC194;
		  /* 820AC194h */ case    6:  		/* stb R11, <#[R1 + 4175]> */
		/* 820AC194h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000104F) );
		/* 820AC194h case    6:*/		return 0x820AC198;
		  /* 820AC198h */ case    7:  		/* addi R7, R1, 80 */
		/* 820AC198h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820AC198h case    7:*/		return 0x820AC19C;
		  /* 820AC19Ch */ case    8:  		/* addi R6, R10, -10432 */
		/* 820AC19Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFD740);
		/* 820AC19Ch case    8:*/		return 0x820AC1A0;
		  /* 820AC1A0h */ case    9:  		/* li R5, 0 */
		/* 820AC1A0h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820AC1A0h case    9:*/		return 0x820AC1A4;
		  /* 820AC1A4h */ case   10:  		/* addi R4, R31, 16 */
		/* 820AC1A4h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 820AC1A4h case   10:*/		return 0x820AC1A8;
	}
	return 0x820AC1A8;
} // Block from 820AC17Ch-820AC1A8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AC1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC1A8);
		  /* 820AC1A8h */ case    0:  		/* lwz R3, <#[R31]> */
		/* 820AC1A8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AC1A8h case    0:*/		return 0x820AC1AC;
		  /* 820AC1ACh */ case    1:  		/* bl -20508 */
		/* 820AC1ACh case    1:*/		regs.LR = 0x820AC1B0; return 0x820A7190;
		/* 820AC1ACh case    1:*/		return 0x820AC1B0;
	}
	return 0x820AC1B0;
} // Block from 820AC1A8h-820AC1B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC1B0);
		  /* 820AC1B0h */ case    0:  		/* addi R1, R1, 4208 */
		/* 820AC1B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1070);
		/* 820AC1B0h case    0:*/		return 0x820AC1B4;
		  /* 820AC1B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AC1B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AC1B4h case    1:*/		return 0x820AC1B8;
		  /* 820AC1B8h */ case    2:  		/* mtspr LR, R12 */
		/* 820AC1B8h case    2:*/		regs.LR = regs.R12;
		/* 820AC1B8h case    2:*/		return 0x820AC1BC;
		  /* 820AC1BCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820AC1BCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AC1BCh case    3:*/		return 0x820AC1C0;
		  /* 820AC1C0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820AC1C0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AC1C0h case    4:*/		return 0x820AC1C4;
		  /* 820AC1C4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820AC1C4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AC1C4h case    5:*/		return 0x820AC1C8;
	}
	return 0x820AC1C8;
} // Block from 820AC1B0h-820AC1C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AC1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC1C8);
		  /* 820AC1C8h */ case    0:  		/* mfspr R12, LR */
		/* 820AC1C8h case    0:*/		regs.R12 = regs.LR;
		/* 820AC1C8h case    0:*/		return 0x820AC1CC;
		  /* 820AC1CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AC1CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AC1CCh case    1:*/		return 0x820AC1D0;
		  /* 820AC1D0h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 820AC1D0h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820AC1D0h case    2:*/		return 0x820AC1D4;
		  /* 820AC1D4h */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 820AC1D4h case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820AC1D4h case    3:*/		return 0x820AC1D8;
		  /* 820AC1D8h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 820AC1D8h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820AC1D8h case    4:*/		return 0x820AC1DC;
		  /* 820AC1DCh */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 820AC1DCh case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820AC1DCh case    5:*/		return 0x820AC1E0;
		  /* 820AC1E0h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 820AC1E0h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820AC1E0h case    6:*/		return 0x820AC1E4;
		  /* 820AC1E4h */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 820AC1E4h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820AC1E4h case    7:*/		return 0x820AC1E8;
		  /* 820AC1E8h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 820AC1E8h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820AC1E8h case    8:*/		return 0x820AC1EC;
		  /* 820AC1ECh */ case    9:  		/* stw R4, <#[R1 + 124]> */
		/* 820AC1ECh case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820AC1ECh case    9:*/		return 0x820AC1F0;
		  /* 820AC1F0h */ case   10:  		/* addi R11, R1, 80 */
		/* 820AC1F0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820AC1F0h case   10:*/		return 0x820AC1F4;
		  /* 820AC1F4h */ case   11:  		/* addi R10, R1, 128 */
		/* 820AC1F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820AC1F4h case   11:*/		return 0x820AC1F8;
		  /* 820AC1F8h */ case   12:  		/* lwz R3, <#[R3 + 3032]> */
		/* 820AC1F8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000BD8) );
		/* 820AC1F8h case   12:*/		return 0x820AC1FC;
		  /* 820AC1FCh */ case   13:  		/* stw R10, <#[R11]> */
		/* 820AC1FCh case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC1FCh case   13:*/		return 0x820AC200;
		  /* 820AC200h */ case   14:  		/* lwz R5, <#[R1 + 80]> */
		/* 820AC200h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820AC200h case   14:*/		return 0x820AC204;
		  /* 820AC204h */ case   15:  		/* bl -340 */
		/* 820AC204h case   15:*/		regs.LR = 0x820AC208; return 0x820AC0B0;
		/* 820AC204h case   15:*/		return 0x820AC208;
		  /* 820AC208h */ case   16:  		/* addi R1, R1, 96 */
		/* 820AC208h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820AC208h case   16:*/		return 0x820AC20C;
		  /* 820AC20Ch */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AC20Ch case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AC20Ch case   17:*/		return 0x820AC210;
		  /* 820AC210h */ case   18:  		/* mtspr LR, R12 */
		/* 820AC210h case   18:*/		regs.LR = regs.R12;
		/* 820AC210h case   18:*/		return 0x820AC214;
		  /* 820AC214h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820AC214h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AC214h case   19:*/		return 0x820AC218;
	}
	return 0x820AC218;
} // Block from 820AC1C8h-820AC218h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AC218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC218);
		  /* 820AC218h */ case    0:  		/* mfspr R12, LR */
		/* 820AC218h case    0:*/		regs.R12 = regs.LR;
		/* 820AC218h case    0:*/		return 0x820AC21C;
		  /* 820AC21Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AC21Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AC21Ch case    1:*/		return 0x820AC220;
		  /* 820AC220h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 820AC220h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820AC220h case    2:*/		return 0x820AC224;
		  /* 820AC224h */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 820AC224h case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820AC224h case    3:*/		return 0x820AC228;
		  /* 820AC228h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 820AC228h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820AC228h case    4:*/		return 0x820AC22C;
		  /* 820AC22Ch */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 820AC22Ch case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820AC22Ch case    5:*/		return 0x820AC230;
		  /* 820AC230h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 820AC230h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820AC230h case    6:*/		return 0x820AC234;
		  /* 820AC234h */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 820AC234h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820AC234h case    7:*/		return 0x820AC238;
		  /* 820AC238h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 820AC238h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820AC238h case    8:*/		return 0x820AC23C;
		  /* 820AC23Ch */ case    9:  		/* stw R4, <#[R1 + 124]> */
		/* 820AC23Ch case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820AC23Ch case    9:*/		return 0x820AC240;
		  /* 820AC240h */ case   10:  		/* addi R11, R1, 80 */
		/* 820AC240h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820AC240h case   10:*/		return 0x820AC244;
		  /* 820AC244h */ case   11:  		/* addi R10, R1, 128 */
		/* 820AC244h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820AC244h case   11:*/		return 0x820AC248;
		  /* 820AC248h */ case   12:  		/* stw R10, <#[R11]> */
		/* 820AC248h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC248h case   12:*/		return 0x820AC24C;
		  /* 820AC24Ch */ case   13:  		/* lwz R5, <#[R1 + 80]> */
		/* 820AC24Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820AC24Ch case   13:*/		return 0x820AC250;
		  /* 820AC250h */ case   14:  		/* bl -416 */
		/* 820AC250h case   14:*/		regs.LR = 0x820AC254; return 0x820AC0B0;
		/* 820AC250h case   14:*/		return 0x820AC254;
		  /* 820AC254h */ case   15:  		/* addi R1, R1, 96 */
		/* 820AC254h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820AC254h case   15:*/		return 0x820AC258;
		  /* 820AC258h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AC258h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AC258h case   16:*/		return 0x820AC25C;
		  /* 820AC25Ch */ case   17:  		/* mtspr LR, R12 */
		/* 820AC25Ch case   17:*/		regs.LR = regs.R12;
		/* 820AC25Ch case   17:*/		return 0x820AC260;
		  /* 820AC260h */ case   18:  		/* bclr 20, CR0_LT */
		/* 820AC260h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AC260h case   18:*/		return 0x820AC264;
	}
	return 0x820AC264;
} // Block from 820AC218h-820AC264h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820AC264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC264);
		  /* 820AC264h */ case    0:  		/* nop */
		/* 820AC264h case    0:*/		cpu::op::nop();
		/* 820AC264h case    0:*/		return 0x820AC268;
	}
	return 0x820AC268;
} // Block from 820AC264h-820AC268h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AC268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC268);
		  /* 820AC268h */ case    0:  		/* mfspr R12, LR */
		/* 820AC268h case    0:*/		regs.R12 = regs.LR;
		/* 820AC268h case    0:*/		return 0x820AC26C;
		  /* 820AC26Ch */ case    1:  		/* bl -110668 */
		/* 820AC26Ch case    1:*/		regs.LR = 0x820AC270; return 0x82091220;
		/* 820AC26Ch case    1:*/		return 0x820AC270;
		  /* 820AC270h */ case    2:  		/* stwu R1, <#[R1 - 432]> */
		/* 820AC270h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE50);
		/* 820AC270h case    2:*/		return 0x820AC274;
		  /* 820AC274h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 820AC274h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 820AC274h case    3:*/		return 0x820AC278;
		  /* 820AC278h */ case    4:  		/* li R10, 269 */
		/* 820AC278h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x10D);
		/* 820AC278h case    4:*/		return 0x820AC27C;
		  /* 820AC27Ch */ case    5:  		/* li R23, 0 */
		/* 820AC27Ch case    5:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820AC27Ch case    5:*/		return 0x820AC280;
		  /* 820AC280h */ case    6:  		/* stw R3, <#[R1 + 452]> */
		/* 820AC280h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000001C4) );
		/* 820AC280h case    6:*/		return 0x820AC284;
		  /* 820AC284h */ case    7:  		/* stw R10, <#[R1 + 96]> */
		/* 820AC284h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820AC284h case    7:*/		return 0x820AC288;
		  /* 820AC288h */ case    8:  		/* li R10, 1 */
		/* 820AC288h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820AC288h case    8:*/		return 0x820AC28C;
		  /* 820AC28Ch */ case    9:  		/* stw R23, <#[R3 + 96]> */
		/* 820AC28Ch case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000060) );
		/* 820AC28Ch case    9:*/		return 0x820AC290;
		  /* 820AC290h */ case   10:  		/* mr R22, R23 */
		/* 820AC290h case   10:*/		regs.R22 = regs.R23;
		/* 820AC290h case   10:*/		return 0x820AC294;
		  /* 820AC294h */ case   11:  		/* mr R21, R23 */
		/* 820AC294h case   11:*/		regs.R21 = regs.R23;
		/* 820AC294h case   11:*/		return 0x820AC298;
		  /* 820AC298h */ case   12:  		/* stw R23, <#[R1 + 172]> */
		/* 820AC298h case   12:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000AC) );
		/* 820AC298h case   12:*/		return 0x820AC29C;
		  /* 820AC29Ch */ case   13:  		/* lbz R9, <#[R11]> */
		/* 820AC29Ch case   13:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC29Ch case   13:*/		return 0x820AC2A0;
		  /* 820AC2A0h */ case   14:  		/* mr R26, R23 */
		/* 820AC2A0h case   14:*/		regs.R26 = regs.R23;
		/* 820AC2A0h case   14:*/		return 0x820AC2A4;
		  /* 820AC2A4h */ case   15:  		/* stw R23, <#[R1 + 180]> */
		/* 820AC2A4h case   15:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000B4) );
		/* 820AC2A4h case   15:*/		return 0x820AC2A8;
		  /* 820AC2A8h */ case   16:  		/* cmplwi CR0, R9, 0 */
		/* 820AC2A8h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820AC2A8h case   16:*/		return 0x820AC2AC;
		  /* 820AC2ACh */ case   17:  		/* stw R23, <#[R1 + 164]> */
		/* 820AC2ACh case   17:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000A4) );
		/* 820AC2ACh case   17:*/		return 0x820AC2B0;
		  /* 820AC2B0h */ case   18:  		/* stw R10, <#[R1 + 196]> */
		/* 820AC2B0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000C4) );
		/* 820AC2B0h case   18:*/		return 0x820AC2B4;
		  /* 820AC2B4h */ case   19:  		/* stw R23, <#[R1 + 136]> */
		/* 820AC2B4h case   19:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000088) );
		/* 820AC2B4h case   19:*/		return 0x820AC2B8;
		  /* 820AC2B8h */ case   20:  		/* stw R23, <#[R1 + 148]> */
		/* 820AC2B8h case   20:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000094) );
		/* 820AC2B8h case   20:*/		return 0x820AC2BC;
		  /* 820AC2BCh */ case   21:  		/* stw R23, <#[R1 + 168]> */
		/* 820AC2BCh case   21:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000A8) );
		/* 820AC2BCh case   21:*/		return 0x820AC2C0;
		  /* 820AC2C0h */ case   22:  		/* stw R23, <#[R1 + 156]> */
		/* 820AC2C0h case   22:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x0000009C) );
		/* 820AC2C0h case   22:*/		return 0x820AC2C4;
		  /* 820AC2C4h */ case   23:  		/* stw R23, <#[R1 + 144]> */
		/* 820AC2C4h case   23:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000090) );
		/* 820AC2C4h case   23:*/		return 0x820AC2C8;
		  /* 820AC2C8h */ case   24:  		/* stw R23, <#[R1 + 152]> */
		/* 820AC2C8h case   24:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000098) );
		/* 820AC2C8h case   24:*/		return 0x820AC2CC;
		  /* 820AC2CCh */ case   25:  		/* stw R23, <#[R1 + 132]> */
		/* 820AC2CCh case   25:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000084) );
		/* 820AC2CCh case   25:*/		return 0x820AC2D0;
		  /* 820AC2D0h */ case   26:  		/* stw R23, <#[R1 + 160]> */
		/* 820AC2D0h case   26:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000A0) );
		/* 820AC2D0h case   26:*/		return 0x820AC2D4;
		  /* 820AC2D4h */ case   27:  		/* stw R11, <#[R1 + 176]> */
		/* 820AC2D4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 820AC2D4h case   27:*/		return 0x820AC2D8;
		  /* 820AC2D8h */ case   28:  		/* stw R11, <#[R1 + 128]> */
		/* 820AC2D8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820AC2D8h case   28:*/		return 0x820AC2DC;
		  /* 820AC2DCh */ case   29:  		/* bc 12, CR0_EQ, 4600 */
		/* 820AC2DCh case   29:*/		if ( regs.CR[0].eq ) { return 0x820AD4D4;  }
		/* 820AC2DCh case   29:*/		return 0x820AC2E0;
		  /* 820AC2E0h */ case   30:  		/* lis R11, -32255 */
		/* 820AC2E0h case   30:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC2E0h case   30:*/		return 0x820AC2E4;
		  /* 820AC2E4h */ case   31:  		/* lis R17, -32255 */
		/* 820AC2E4h case   31:*/		cpu::op::lis<0>(regs,&regs.R17,0xFFFF8201);
		/* 820AC2E4h case   31:*/		return 0x820AC2E8;
		  /* 820AC2E8h */ case   32:  		/* addi R10, R11, 328 */
		/* 820AC2E8h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x148);
		/* 820AC2E8h case   32:*/		return 0x820AC2EC;
		  /* 820AC2ECh */ case   33:  		/* lis R15, -32255 */
		/* 820AC2ECh case   33:*/		cpu::op::lis<0>(regs,&regs.R15,0xFFFF8201);
		/* 820AC2ECh case   33:*/		return 0x820AC2F0;
		  /* 820AC2F0h */ case   34:  		/* stw R10, <#[R1 + 140]> */
		/* 820AC2F0h case   34:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 820AC2F0h case   34:*/		return 0x820AC2F4;
		  /* 820AC2F4h */ case   35:  		/* lis R11, -32255 */
		/* 820AC2F4h case   35:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC2F4h case   35:*/		return 0x820AC2F8;
		  /* 820AC2F8h */ case   36:  		/* addi R10, R17, 5208 */
		/* 820AC2F8h case   36:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R17,0x1458);
		/* 820AC2F8h case   36:*/		return 0x820AC2FC;
		  /* 820AC2FCh */ case   37:  		/* addi R17, R15, 5204 */
		/* 820AC2FCh case   37:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R15,0x1454);
		/* 820AC2FCh case   37:*/		return 0x820AC300;
		  /* 820AC300h */ case   38:  		/* addi R15, R11, 5200 */
		/* 820AC300h case   38:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R11,0x1450);
		/* 820AC300h case   38:*/		return 0x820AC304;
		  /* 820AC304h */ case   39:  		/* stw R10, <#[R1 + 264]> */
		/* 820AC304h case   39:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000108) );
		/* 820AC304h case   39:*/		return 0x820AC308;
		  /* 820AC308h */ case   40:  		/* lis R11, -32255 */
		/* 820AC308h case   40:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC308h case   40:*/		return 0x820AC30C;
		  /* 820AC30Ch */ case   41:  		/* lis R10, -32255 */
		/* 820AC30Ch case   41:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AC30Ch case   41:*/		return 0x820AC310;
		  /* 820AC310h */ case   42:  		/* addi R11, R11, 5196 */
		/* 820AC310h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x144C);
		/* 820AC310h case   42:*/		return 0x820AC314;
		  /* 820AC314h */ case   43:  		/* lis R9, -32255 */
		/* 820AC314h case   43:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820AC314h case   43:*/		return 0x820AC318;
		  /* 820AC318h */ case   44:  		/* stw R11, <#[R1 + 236]> */
		/* 820AC318h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000EC) );
		/* 820AC318h case   44:*/		return 0x820AC31C;
		  /* 820AC31Ch */ case   45:  		/* addi R11, R10, 5192 */
		/* 820AC31Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1448);
		/* 820AC31Ch case   45:*/		return 0x820AC320;
		  /* 820AC320h */ case   46:  		/* lis R7, -32255 */
		/* 820AC320h case   46:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8201);
		/* 820AC320h case   46:*/		return 0x820AC324;
		  /* 820AC324h */ case   47:  		/* lis R8, -32255 */
		/* 820AC324h case   47:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8201);
		/* 820AC324h case   47:*/		return 0x820AC328;
		  /* 820AC328h */ case   48:  		/* stw R11, <#[R1 + 256]> */
		/* 820AC328h case   48:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000100) );
		/* 820AC328h case   48:*/		return 0x820AC32C;
		  /* 820AC32Ch */ case   49:  		/* addi R10, R9, 5188 */
		/* 820AC32Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x1444);
		/* 820AC32Ch case   49:*/		return 0x820AC330;
		  /* 820AC330h */ case   50:  		/* addi R11, R7, 5184 */
		/* 820AC330h case   50:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0x1440);
		/* 820AC330h case   50:*/		return 0x820AC334;
		  /* 820AC334h */ case   51:  		/* lis R6, -32255 */
		/* 820AC334h case   51:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8201);
		/* 820AC334h case   51:*/		return 0x820AC338;
		  /* 820AC338h */ case   52:  		/* stw R10, <#[R1 + 248]> */
		/* 820AC338h case   52:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000F8) );
		/* 820AC338h case   52:*/		return 0x820AC33C;
		  /* 820AC33Ch */ case   53:  		/* addi R9, R8, 5180 */
		/* 820AC33Ch case   53:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x143C);
		/* 820AC33Ch case   53:*/		return 0x820AC340;
		  /* 820AC340h */ case   54:  		/* stw R11, <#[R1 + 252]> */
		/* 820AC340h case   54:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000FC) );
		/* 820AC340h case   54:*/		return 0x820AC344;
		  /* 820AC344h */ case   55:  		/* lis R4, -32255 */
		/* 820AC344h case   55:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 820AC344h case   55:*/		return 0x820AC348;
		  /* 820AC348h */ case   56:  		/* lis R5, -32255 */
		/* 820AC348h case   56:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8201);
		/* 820AC348h case   56:*/		return 0x820AC34C;
		  /* 820AC34Ch */ case   57:  		/* stw R9, <#[R1 + 240]> */
		/* 820AC34Ch case   57:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000F0) );
		/* 820AC34Ch case   57:*/		return 0x820AC350;
	}
	return 0x820AC350;
} // Block from 820AC268h-820AC350h (58 instructions)

//////////////////////////////////////////////////////
// Block at 820AC350h
// Function '?StaticMicrocodeErrorCallback@D3DXShader@@YAXPAXHKPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC350);
		  /* 820AC350h */ case    0:  		/* addi R10, R6, 5176 */
		/* 820AC350h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0x1438);
		/* 820AC350h case    0:*/		return 0x820AC354;
		  /* 820AC354h */ case    1:  		/* addi R11, R4, 5168 */
		/* 820AC354h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1430);
		/* 820AC354h case    1:*/		return 0x820AC358;
	}
	return 0x820AC358;
} // Block from 820AC350h-820AC358h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC358h
// Function '?GetShaderCode@CAssembler@D3DXShader@@IAAJPAPAUID3DXBuffer@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC358);
		  /* 820AC358h */ case    0:  		/* lis R3, -32255 */
		/* 820AC358h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8201);
		/* 820AC358h case    0:*/		return 0x820AC35C;
		  /* 820AC35Ch */ case    1:  		/* stw R10, <#[R1 + 260]> */
		/* 820AC35Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000104) );
		/* 820AC35Ch case    1:*/		return 0x820AC360;
		  /* 820AC360h */ case    2:  		/* addi R9, R5, 5164 */
		/* 820AC360h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0x142C);
		/* 820AC360h case    2:*/		return 0x820AC364;
		  /* 820AC364h */ case    3:  		/* stw R11, <#[R1 + 220]> */
		/* 820AC364h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000DC) );
		/* 820AC364h case    3:*/		return 0x820AC368;
		  /* 820AC368h */ case    4:  		/* lis R29, -32255 */
		/* 820AC368h case    4:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8201);
		/* 820AC368h case    4:*/		return 0x820AC36C;
		  /* 820AC36Ch */ case    5:  		/* lis R30, -32255 */
		/* 820AC36Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8201);
		/* 820AC36Ch case    5:*/		return 0x820AC370;
		  /* 820AC370h */ case    6:  		/* stw R9, <#[R1 + 244]> */
		/* 820AC370h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000F4) );
		/* 820AC370h case    6:*/		return 0x820AC374;
		  /* 820AC374h */ case    7:  		/* addi R10, R3, 5156 */
		/* 820AC374h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x1424);
		/* 820AC374h case    7:*/		return 0x820AC378;
		  /* 820AC378h */ case    8:  		/* addi R11, R29, 5088 */
		/* 820AC378h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x13E0);
		/* 820AC378h case    8:*/		return 0x820AC37C;
		  /* 820AC37Ch */ case    9:  		/* lis R28, -32255 */
		/* 820AC37Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8201);
		/* 820AC37Ch case    9:*/		return 0x820AC380;
		  /* 820AC380h */ case   10:  		/* stw R10, <#[R1 + 232]> */
		/* 820AC380h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000E8) );
		/* 820AC380h case   10:*/		return 0x820AC384;
		  /* 820AC384h */ case   11:  		/* addi R9, R30, 5080 */
		/* 820AC384h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x13D8);
		/* 820AC384h case   11:*/		return 0x820AC388;
		  /* 820AC388h */ case   12:  		/* stw R11, <#[R1 + 212]> */
		/* 820AC388h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000D4) );
		/* 820AC388h case   12:*/		return 0x820AC38C;
		  /* 820AC38Ch */ case   13:  		/* lis R26, -32255 */
		/* 820AC38Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8201);
		/* 820AC38Ch case   13:*/		return 0x820AC390;
		  /* 820AC390h */ case   14:  		/* lis R27, -32255 */
		/* 820AC390h case   14:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8201);
		/* 820AC390h case   14:*/		return 0x820AC394;
		  /* 820AC394h */ case   15:  		/* stw R9, <#[R1 + 224]> */
		/* 820AC394h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000E0) );
		/* 820AC394h case   15:*/		return 0x820AC398;
		  /* 820AC398h */ case   16:  		/* addi R10, R28, 5068 */
		/* 820AC398h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x13CC);
		/* 820AC398h case   16:*/		return 0x820AC39C;
		  /* 820AC39Ch */ case   17:  		/* addi R11, R26, 5056 */
		/* 820AC39Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x13C0);
		/* 820AC39Ch case   17:*/		return 0x820AC3A0;
		  /* 820AC3A0h */ case   18:  		/* lis R25, -32255 */
		/* 820AC3A0h case   18:*/		cpu::op::lis<0>(regs,&regs.R25,0xFFFF8201);
		/* 820AC3A0h case   18:*/		return 0x820AC3A4;
		  /* 820AC3A4h */ case   19:  		/* stw R10, <#[R1 + 184]> */
		/* 820AC3A4h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 820AC3A4h case   19:*/		return 0x820AC3A8;
		  /* 820AC3A8h */ case   20:  		/* addi R9, R27, 5044 */
		/* 820AC3A8h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x13B4);
		/* 820AC3A8h case   20:*/		return 0x820AC3AC;
		  /* 820AC3ACh */ case   21:  		/* stw R11, <#[R1 + 204]> */
		/* 820AC3ACh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000CC) );
		/* 820AC3ACh case   21:*/		return 0x820AC3B0;
		  /* 820AC3B0h */ case   22:  		/* lis R23, -32255 */
		/* 820AC3B0h case   22:*/		cpu::op::lis<0>(regs,&regs.R23,0xFFFF8201);
		/* 820AC3B0h case   22:*/		return 0x820AC3B4;
		  /* 820AC3B4h */ case   23:  		/* lis R24, -32255 */
		/* 820AC3B4h case   23:*/		cpu::op::lis<0>(regs,&regs.R24,0xFFFF8201);
		/* 820AC3B4h case   23:*/		return 0x820AC3B8;
		  /* 820AC3B8h */ case   24:  		/* stw R9, <#[R1 + 216]> */
		/* 820AC3B8h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000D8) );
		/* 820AC3B8h case   24:*/		return 0x820AC3BC;
		  /* 820AC3BCh */ case   25:  		/* addi R10, R25, 5036 */
		/* 820AC3BCh case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0x13AC);
		/* 820AC3BCh case   25:*/		return 0x820AC3C0;
		  /* 820AC3C0h */ case   26:  		/* addi R11, R23, 5028 */
		/* 820AC3C0h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x13A4);
		/* 820AC3C0h case   26:*/		return 0x820AC3C4;
		  /* 820AC3C4h */ case   27:  		/* lis R22, -32255 */
		/* 820AC3C4h case   27:*/		cpu::op::lis<0>(regs,&regs.R22,0xFFFF8201);
		/* 820AC3C4h case   27:*/		return 0x820AC3C8;
		  /* 820AC3C8h */ case   28:  		/* stw R10, <#[R1 + 192]> */
		/* 820AC3C8h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000C0) );
		/* 820AC3C8h case   28:*/		return 0x820AC3CC;
		  /* 820AC3CCh */ case   29:  		/* addi R9, R24, -8388 */
		/* 820AC3CCh case   29:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R24,0xFFFFDF3C);
		/* 820AC3CCh case   29:*/		return 0x820AC3D0;
		  /* 820AC3D0h */ case   30:  		/* stw R11, <#[R1 + 208]> */
		/* 820AC3D0h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000D0) );
		/* 820AC3D0h case   30:*/		return 0x820AC3D4;
		  /* 820AC3D4h */ case   31:  		/* lis R21, -32255 */
		/* 820AC3D4h case   31:*/		cpu::op::lis<0>(regs,&regs.R21,0xFFFF8201);
		/* 820AC3D4h case   31:*/		return 0x820AC3D8;
		  /* 820AC3D8h */ case   32:  		/* addi R10, R22, 5020 */
		/* 820AC3D8h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0x139C);
		/* 820AC3D8h case   32:*/		return 0x820AC3DC;
		  /* 820AC3DCh */ case   33:  		/* stw R9, <#[R1 + 188]> */
		/* 820AC3DCh case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000BC) );
		/* 820AC3DCh case   33:*/		return 0x820AC3E0;
		  /* 820AC3E0h */ case   34:  		/* lis R11, -32255 */
		/* 820AC3E0h case   34:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC3E0h case   34:*/		return 0x820AC3E4;
		  /* 820AC3E4h */ case   35:  		/* lis R31, -32255 */
		/* 820AC3E4h case   35:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820AC3E4h case   35:*/		return 0x820AC3E8;
		  /* 820AC3E8h */ case   36:  		/* stw R10, <#[R1 + 200]> */
		/* 820AC3E8h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000C8) );
		/* 820AC3E8h case   36:*/		return 0x820AC3EC;
		  /* 820AC3ECh */ case   37:  		/* lis R20, -32255 */
		/* 820AC3ECh case   37:*/		cpu::op::lis<0>(regs,&regs.R20,0xFFFF8201);
		/* 820AC3ECh case   37:*/		return 0x820AC3F0;
		  /* 820AC3F0h */ case   38:  		/* lis R19, -32255 */
		/* 820AC3F0h case   38:*/		cpu::op::lis<0>(regs,&regs.R19,0xFFFF8201);
		/* 820AC3F0h case   38:*/		return 0x820AC3F4;
		  /* 820AC3F4h */ case   39:  		/* lis R18, -32255 */
		/* 820AC3F4h case   39:*/		cpu::op::lis<0>(regs,&regs.R18,0xFFFF8201);
		/* 820AC3F4h case   39:*/		return 0x820AC3F8;
		  /* 820AC3F8h */ case   40:  		/* lis R16, -32255 */
		/* 820AC3F8h case   40:*/		cpu::op::lis<0>(regs,&regs.R16,0xFFFF8201);
		/* 820AC3F8h case   40:*/		return 0x820AC3FC;
		  /* 820AC3FCh */ case   41:  		/* addi R9, R21, 5004 */
		/* 820AC3FCh case   41:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R21,0x138C);
		/* 820AC3FCh case   41:*/		return 0x820AC400;
		  /* 820AC400h */ case   42:  		/* addi R10, R11, 5000 */
		/* 820AC400h case   42:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1388);
		/* 820AC400h case   42:*/		return 0x820AC404;
		  /* 820AC404h */ case   43:  		/* lis R14, -32255 */
		/* 820AC404h case   43:*/		cpu::op::lis<0>(regs,&regs.R14,0xFFFF8201);
		/* 820AC404h case   43:*/		return 0x820AC408;
	}
	return 0x820AC408;
} // Block from 820AC358h-820AC408h (44 instructions)

//////////////////////////////////////////////////////
// Block at 820AC408h
// Function '??1CAssembler@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC408);
		  /* 820AC408h */ case    0:  		/* stw R9, <#[R1 + 228]> */
		/* 820AC408h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 820AC408h case    0:*/		return 0x820AC40C;
		  /* 820AC40Ch */ case    1:  		/* addi R31, R31, 4996 */
		/* 820AC40Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1384);
		/* 820AC40Ch case    1:*/		return 0x820AC410;
		  /* 820AC410h */ case    2:  		/* addi R20, R20, 4984 */
		/* 820AC410h case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1378);
		/* 820AC410h case    2:*/		return 0x820AC414;
		  /* 820AC414h */ case    3:  		/* addi R19, R19, 4972 */
		/* 820AC414h case    3:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x136C);
		/* 820AC414h case    3:*/		return 0x820AC418;
		  /* 820AC418h */ case    4:  		/* addi R18, R18, 4968 */
		/* 820AC418h case    4:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1368);
		/* 820AC418h case    4:*/		return 0x820AC41C;
		  /* 820AC41Ch */ case    5:  		/* addi R16, R16, 4960 */
		/* 820AC41Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1360);
		/* 820AC41Ch case    5:*/		return 0x820AC420;
		  /* 820AC420h */ case    6:  		/* lis R11, -32255 */
		/* 820AC420h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC420h case    6:*/		return 0x820AC424;
		  /* 820AC424h */ case    7:  		/* addi R9, R11, 3444 */
		/* 820AC424h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xD74);
		/* 820AC424h case    7:*/		return 0x820AC428;
		  /* 820AC428h */ case    8:  		/* lwz R24, <#[R1 + 152]> */
		/* 820AC428h case    8:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000098) );
		/* 820AC428h case    8:*/		return 0x820AC42C;
		  /* 820AC42Ch */ case    9:  		/* lis R11, -32255 */
		/* 820AC42Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC42Ch case    9:*/		return 0x820AC430;
		  /* 820AC430h */ case   10:  		/* stw R10, <#[R1 + 152]> */
		/* 820AC430h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 820AC430h case   10:*/		return 0x820AC434;
		  /* 820AC434h */ case   11:  		/* lwz R25, <#[R1 + 156]> */
		/* 820AC434h case   11:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000009C) );
		/* 820AC434h case   11:*/		return 0x820AC438;
		  /* 820AC438h */ case   12:  		/* addi R14, R14, 4956 */
		/* 820AC438h case   12:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R14,0x135C);
		/* 820AC438h case   12:*/		return 0x820AC43C;
		  /* 820AC43Ch */ case   13:  		/* addi R8, R11, 4952 */
		/* 820AC43Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1358);
		/* 820AC43Ch case   13:*/		return 0x820AC440;
		  /* 820AC440h */ case   14:  		/* lwz R26, <#[R1 + 164]> */
		/* 820AC440h case   14:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000A4) );
		/* 820AC440h case   14:*/		return 0x820AC444;
		  /* 820AC444h */ case   15:  		/* lis R11, -32255 */
		/* 820AC444h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC444h case   15:*/		return 0x820AC448;
		  /* 820AC448h */ case   16:  		/* lwz R22, <#[R1 + 172]> */
		/* 820AC448h case   16:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x000000AC) );
		/* 820AC448h case   16:*/		return 0x820AC44C;
		  /* 820AC44Ch */ case   17:  		/* lwz R21, <#[R1 + 180]> */
		/* 820AC44Ch case   17:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000B4) );
		/* 820AC44Ch case   17:*/		return 0x820AC450;
		  /* 820AC450h */ case   18:  		/* li R23, 0 */
		/* 820AC450h case   18:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820AC450h case   18:*/		return 0x820AC454;
		  /* 820AC454h */ case   19:  		/* addi R10, R11, 4948 */
		/* 820AC454h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1354);
		/* 820AC454h case   19:*/		return 0x820AC458;
		  /* 820AC458h */ case   20:  		/* lwz R28, <#[R1 + 132]> */
		/* 820AC458h case   20:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000084) );
		/* 820AC458h case   20:*/		return 0x820AC45C;
		  /* 820AC45Ch */ case   21:  		/* lis R11, -32255 */
		/* 820AC45Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AC45Ch case   21:*/		return 0x820AC460;
		  /* 820AC460h */ case   22:  		/* lwz R27, <#[R1 + 140]> */
		/* 820AC460h case   22:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000008C) );
		/* 820AC460h case   22:*/		return 0x820AC464;
		  /* 820AC464h */ case   23:  		/* stw R9, <#[R1 + 156]> */
		/* 820AC464h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000009C) );
		/* 820AC464h case   23:*/		return 0x820AC468;
		  /* 820AC468h */ case   24:  		/* addi R11, R11, 4936 */
		/* 820AC468h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1348);
		/* 820AC468h case   24:*/		return 0x820AC46C;
		  /* 820AC46Ch */ case   25:  		/* stw R8, <#[R1 + 164]> */
		/* 820AC46Ch case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000A4) );
		/* 820AC46Ch case   25:*/		return 0x820AC470;
		  /* 820AC470h */ case   26:  		/* stw R10, <#[R1 + 172]> */
		/* 820AC470h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000AC) );
		/* 820AC470h case   26:*/		return 0x820AC474;
		  /* 820AC474h */ case   27:  		/* stw R11, <#[R1 + 180]> */
		/* 820AC474h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 820AC474h case   27:*/		return 0x820AC478;
		  /* 820AC478h */ case   28:  		/* lwz R11, <#[R1 + 128]> */
		/* 820AC478h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820AC478h case   28:*/		return 0x820AC47C;
		  /* 820AC47Ch */ case   29:  		/* lbz R10, <#[R11]> */
		/* 820AC47Ch case   29:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC47Ch case   29:*/		return 0x820AC480;
	}
	return 0x820AC480;
} // Block from 820AC408h-820AC480h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820AC480h
// Function '?Production@CAssembler@D3DXShader@@IAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC480);
		  /* 820AC480h */ case    0:  		/* b 20 */
		/* 820AC480h case    0:*/		return 0x820AC494;
		/* 820AC480h case    0:*/		return 0x820AC484;
		  /* 820AC484h */ case    1:  		/* cmpwi CR6, R29, 95 */
		/* 820AC484h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x0000005F);
		/* 820AC484h case    1:*/		return 0x820AC488;
		  /* 820AC488h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820AC488h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AC49C;  }
		/* 820AC488h case    2:*/		return 0x820AC48C;
		  /* 820AC48Ch */ case    3:  		/* lbzu R10, <#[R11 + 1]> */
		/* 820AC48Ch case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 820AC48Ch case    3:*/		return 0x820AC490;
		  /* 820AC490h */ case    4:  		/* stw R11, <#[R1 + 128]> */
		/* 820AC490h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820AC490h case    4:*/		return 0x820AC494;
	}
	return 0x820AC494;
} // Block from 820AC480h-820AC494h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AC494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC494);
		  /* 820AC494h */ case    0:  		/* extsb. R29, R10 */
		/* 820AC494h case    0:*/		cpu::op::extsb<1>(regs,&regs.R29,regs.R10);
		/* 820AC494h case    0:*/		return 0x820AC498;
		  /* 820AC498h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820AC498h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC484;  }
		/* 820AC498h case    1:*/		return 0x820AC49C;
	}
	return 0x820AC49C;
} // Block from 820AC494h-820AC49Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC49C);
		  /* 820AC49Ch */ case    0:  		/* lwz R10, <#[R1 + 176]> */
		/* 820AC49Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B0) );
		/* 820AC49Ch case    0:*/		return 0x820AC4A0;
		  /* 820AC4A0h */ case    1:  		/* subf R30, R10, R11 */
		/* 820AC4A0h case    1:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 820AC4A0h case    1:*/		return 0x820AC4A4;
		  /* 820AC4A4h */ case    2:  		/* cmplwi CR6, R30, 15 */
		/* 820AC4A4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000F);
		/* 820AC4A4h case    2:*/		return 0x820AC4A8;
		  /* 820AC4A8h */ case    3:  		/* bc 12, CR6_GT, 4172 */
		/* 820AC4A8h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AD4F4;  }
		/* 820AC4A8h case    3:*/		return 0x820AC4AC;
		  /* 820AC4ACh */ case    4:  		/* mr R5, R30 */
		/* 820AC4ACh case    4:*/		regs.R5 = regs.R30;
		/* 820AC4ACh case    4:*/		return 0x820AC4B0;
		  /* 820AC4B0h */ case    5:  		/* rlwinm R4, R10, 0, 0, 31 */
		/* 820AC4B0h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R4,regs.R10);
		/* 820AC4B0h case    5:*/		return 0x820AC4B4;
		  /* 820AC4B4h */ case    6:  		/* addi R3, R1, 112 */
		/* 820AC4B4h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 820AC4B4h case    6:*/		return 0x820AC4B8;
		  /* 820AC4B8h */ case    7:  		/* bl -109320 */
		/* 820AC4B8h case    7:*/		regs.LR = 0x820AC4BC; return 0x820919B0;
		/* 820AC4B8h case    7:*/		return 0x820AC4BC;
		  /* 820AC4BCh */ case    8:  		/* addi R11, R1, 112 */
		/* 820AC4BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC4BCh case    8:*/		return 0x820AC4C0;
		  /* 820AC4C0h */ case    9:  		/* cmpwi CR6, R29, 0 */
		/* 820AC4C0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820AC4C0h case    9:*/		return 0x820AC4C4;
		  /* 820AC4C4h */ case   10:  		/* stbx R23, <#[R30 + R11]> */
		/* 820AC4C4h case   10:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820AC4C4h case   10:*/		return 0x820AC4C8;
		  /* 820AC4C8h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 820AC4C8h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AC4D8;  }
		/* 820AC4C8h case   11:*/		return 0x820AC4CC;
		  /* 820AC4CCh */ case   12:  		/* lwz R11, <#[R1 + 128]> */
		/* 820AC4CCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820AC4CCh case   12:*/		return 0x820AC4D0;
		  /* 820AC4D0h */ case   13:  		/* addi R11, R11, 1 */
		/* 820AC4D0h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC4D0h case   13:*/		return 0x820AC4D4;
		  /* 820AC4D4h */ case   14:  		/* stw R11, <#[R1 + 128]> */
		/* 820AC4D4h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820AC4D4h case   14:*/		return 0x820AC4D8;
	}
	return 0x820AC4D8;
} // Block from 820AC49Ch-820AC4D8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AC4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC4D8);
		  /* 820AC4D8h */ case    0:  		/* lwz R11, <#[R1 + 128]> */
		/* 820AC4D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820AC4D8h case    0:*/		return 0x820AC4DC;
		  /* 820AC4DCh */ case    1:  		/* lwz R10, <#[R1 + 196]> */
		/* 820AC4DCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000C4) );
		/* 820AC4DCh case    1:*/		return 0x820AC4E0;
		  /* 820AC4E0h */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 820AC4E0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820AC4E0h case    2:*/		return 0x820AC4E4;
		  /* 820AC4E4h */ case    3:  		/* stw R11, <#[R1 + 176]> */
		/* 820AC4E4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 820AC4E4h case    3:*/		return 0x820AC4E8;
		  /* 820AC4E8h */ case    4:  		/* bc 12, CR6_EQ, 656 */
		/* 820AC4E8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820AC778;  }
		/* 820AC4E8h case    4:*/		return 0x820AC4EC;
		  /* 820AC4ECh */ case    5:  		/* addi R9, R27, -6120 */
		/* 820AC4ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0xFFFFE818);
		/* 820AC4ECh case    5:*/		return 0x820AC4F0;
		  /* 820AC4F0h */ case    6:  		/* mr R6, R23 */
		/* 820AC4F0h case    6:*/		regs.R6 = regs.R23;
		/* 820AC4F0h case    6:*/		return 0x820AC4F4;
		  /* 820AC4F4h */ case    7:  		/* mr R7, R23 */
		/* 820AC4F4h case    7:*/		regs.R7 = regs.R23;
		/* 820AC4F4h case    7:*/		return 0x820AC4F8;
		  /* 820AC4F8h */ case    8:  		/* lwz R10, <#[R9]> */
		/* 820AC4F8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820AC4F8h case    8:*/		return 0x820AC4FC;
		  /* 820AC4FCh */ case    9:  		/* addi R11, R1, 112 */
		/* 820AC4FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC4FCh case    9:*/		return 0x820AC500;
		  /* 820AC500h */ case   10:  		/* lbz R8, <#[R11]> */
		/* 820AC500h case   10:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC500h case   10:*/		return 0x820AC504;
		  /* 820AC504h */ case   11:  		/* lbz R5, <#[R10]> */
		/* 820AC504h case   11:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC504h case   11:*/		return 0x820AC508;
		  /* 820AC508h */ case   12:  		/* cmpwi CR0, R8, 0 */
		/* 820AC508h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820AC508h case   12:*/		return 0x820AC50C;
		  /* 820AC50Ch */ case   13:  		/* subf R8, R5, R8 */
		/* 820AC50Ch case   13:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820AC50Ch case   13:*/		return 0x820AC510;
		  /* 820AC510h */ case   14:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC510h case   14:*/		if ( regs.CR[0].eq ) { return 0x820AC524;  }
		/* 820AC510h case   14:*/		return 0x820AC514;
		  /* 820AC514h */ case   15:  		/* addi R11, R11, 1 */
		/* 820AC514h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC514h case   15:*/		return 0x820AC518;
		  /* 820AC518h */ case   16:  		/* addi R10, R10, 1 */
		/* 820AC518h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC518h case   16:*/		return 0x820AC51C;
		  /* 820AC51Ch */ case   17:  		/* cmpwi CR6, R8, 0 */
		/* 820AC51Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820AC51Ch case   17:*/		return 0x820AC520;
		  /* 820AC520h */ case   18:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC520h case   18:*/		if ( regs.CR[6].eq ) { return 0x820AC500;  }
		/* 820AC520h case   18:*/		return 0x820AC524;
	}
	return 0x820AC524;
} // Block from 820AC4D8h-820AC524h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820AC524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC524);
		  /* 820AC524h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820AC524h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820AC524h case    0:*/		return 0x820AC528;
		  /* 820AC528h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820AC528h case    1:*/		if ( regs.CR[0].eq ) { return 0x820AC540;  }
		/* 820AC528h case    1:*/		return 0x820AC52C;
		  /* 820AC52Ch */ case    2:  		/* addi R7, R7, 72 */
		/* 820AC52Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x48);
		/* 820AC52Ch case    2:*/		return 0x820AC530;
		  /* 820AC530h */ case    3:  		/* addi R6, R6, 1 */
		/* 820AC530h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820AC530h case    3:*/		return 0x820AC534;
		  /* 820AC534h */ case    4:  		/* addi R9, R9, 72 */
		/* 820AC534h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x48);
		/* 820AC534h case    4:*/		return 0x820AC538;
		  /* 820AC538h */ case    5:  		/* cmplwi CR6, R7, 6048 */
		/* 820AC538h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x000017A0);
		/* 820AC538h case    5:*/		return 0x820AC53C;
		  /* 820AC53Ch */ case    6:  		/* bc 12, CR6_LT, -68 */
		/* 820AC53Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x820AC4F8;  }
		/* 820AC53Ch case    6:*/		return 0x820AC540;
	}
	return 0x820AC540;
} // Block from 820AC524h-820AC540h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AC540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC540);
		  /* 820AC540h */ case    0:  		/* cmplwi CR6, R6, 84 */
		/* 820AC540h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000054);
		/* 820AC540h case    0:*/		return 0x820AC544;
		  /* 820AC544h */ case    1:  		/* bc 12, CR6_EQ, 4016 */
		/* 820AC544h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AD4F4;  }
		/* 820AC544h case    1:*/		return 0x820AC548;
		  /* 820AC548h */ case    2:  		/* lwz R8, <#[R1 + 452]> */
		/* 820AC548h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000001C4) );
		/* 820AC548h case    2:*/		return 0x820AC54C;
		  /* 820AC54Ch */ case    3:  		/* mulli R11, R6, 18 */
		/* 820AC54Ch case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R6,0x12);
		/* 820AC54Ch case    3:*/		return 0x820AC550;
		  /* 820AC550h */ case    4:  		/* lwz R9, <#[R8 + 64]> */
		/* 820AC550h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000040) );
		/* 820AC550h case    4:*/		return 0x820AC554;
		  /* 820AC554h */ case    5:  		/* add R11, R11, R9 */
		/* 820AC554h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820AC554h case    5:*/		return 0x820AC558;
		  /* 820AC558h */ case    6:  		/* addi R10, R27, -6120 */
		/* 820AC558h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFE818);
		/* 820AC558h case    6:*/		return 0x820AC55C;
		  /* 820AC55Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AC55Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AC55Ch case    7:*/		return 0x820AC560;
		  /* 820AC560h */ case    8:  		/* addi R10, R10, 8 */
		/* 820AC560h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 820AC560h case    8:*/		return 0x820AC564;
		  /* 820AC564h */ case    9:  		/* li R7, -6 */
		/* 820AC564h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFA);
		/* 820AC564h case    9:*/		return 0x820AC568;
		  /* 820AC568h */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820AC568h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AC568h case   10:*/		return 0x820AC56C;
		  /* 820AC56Ch */ case   11:  		/* cmplw CR6, R11, R7 */
		/* 820AC56Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820AC56Ch case   11:*/		return 0x820AC570;
		  /* 820AC570h */ case   12:  		/* bc 12, CR6_GT, 108 */
		/* 820AC570h case   12:*/		if ( regs.CR[6].gt ) { return 0x820AC5DC;  }
		/* 820AC570h case   12:*/		return 0x820AC574;
		  /* 820AC574h */ case   13:  		/* cmpwi CR6, R11, -6 */
		/* 820AC574h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFA);
		/* 820AC574h case   13:*/		return 0x820AC578;
		  /* 820AC578h */ case   14:  		/* bc 12, CR6_EQ, 92 */
		/* 820AC578h case   14:*/		if ( regs.CR[6].eq ) { return 0x820AC5D4;  }
		/* 820AC578h case   14:*/		return 0x820AC57C;
		  /* 820AC57Ch */ case   15:  		/* cmplwi CR6, R11, 1 */
		/* 820AC57Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820AC57Ch case   15:*/		return 0x820AC580;
		  /* 820AC580h */ case   16:  		/* bc 12, CR6_LT, 72 */
		/* 820AC580h case   16:*/		if ( regs.CR[6].lt ) { return 0x820AC5C8;  }
		/* 820AC580h case   16:*/		return 0x820AC584;
		  /* 820AC584h */ case   17:  		/* bc 12, CR6_EQ, 60 */
		/* 820AC584h case   17:*/		if ( regs.CR[6].eq ) { return 0x820AC5C0;  }
		/* 820AC584h case   17:*/		return 0x820AC588;
		  /* 820AC588h */ case   18:  		/* cmplwi CR6, R11, 3 */
		/* 820AC588h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820AC588h case   18:*/		return 0x820AC58C;
		  /* 820AC58Ch */ case   19:  		/* bc 12, CR6_LT, 44 */
		/* 820AC58Ch case   19:*/		if ( regs.CR[6].lt ) { return 0x820AC5B8;  }
		/* 820AC58Ch case   19:*/		return 0x820AC590;
		  /* 820AC590h */ case   20:  		/* bc 12, CR6_EQ, 32 */
		/* 820AC590h case   20:*/		if ( regs.CR[6].eq ) { return 0x820AC5B0;  }
		/* 820AC590h case   20:*/		return 0x820AC594;
		  /* 820AC594h */ case   21:  		/* cmplwi CR6, R11, 5 */
		/* 820AC594h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 820AC594h case   21:*/		return 0x820AC598;
		  /* 820AC598h */ case   22:  		/* bc 12, CR6_LT, 16 */
		/* 820AC598h case   22:*/		if ( regs.CR[6].lt ) { return 0x820AC5A8;  }
		/* 820AC598h case   22:*/		return 0x820AC59C;
		  /* 820AC59Ch */ case   23:  		/* bc 4, CR6_EQ, 104 */
		/* 820AC59Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x820AC604;  }
		/* 820AC59Ch case   23:*/		return 0x820AC5A0;
		  /* 820AC5A0h */ case   24:  		/* li R10, 263 */
		/* 820AC5A0h case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x107);
		/* 820AC5A0h case   24:*/		return 0x820AC5A4;
		  /* 820AC5A4h */ case   25:  		/* b 40 */
		/* 820AC5A4h case   25:*/		return 0x820AC5CC;
		/* 820AC5A4h case   25:*/		return 0x820AC5A8;
	}
	return 0x820AC5A8;
} // Block from 820AC540h-820AC5A8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5A8);
		  /* 820AC5A8h */ case    0:  		/* li R10, 262 */
		/* 820AC5A8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x106);
		/* 820AC5A8h case    0:*/		return 0x820AC5AC;
		  /* 820AC5ACh */ case    1:  		/* b 32 */
		/* 820AC5ACh case    1:*/		return 0x820AC5CC;
		/* 820AC5ACh case    1:*/		return 0x820AC5B0;
	}
	return 0x820AC5B0;
} // Block from 820AC5A8h-820AC5B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5B0);
		  /* 820AC5B0h */ case    0:  		/* li R10, 261 */
		/* 820AC5B0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x105);
		/* 820AC5B0h case    0:*/		return 0x820AC5B4;
		  /* 820AC5B4h */ case    1:  		/* b 24 */
		/* 820AC5B4h case    1:*/		return 0x820AC5CC;
		/* 820AC5B4h case    1:*/		return 0x820AC5B8;
	}
	return 0x820AC5B8;
} // Block from 820AC5B0h-820AC5B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5B8);
		  /* 820AC5B8h */ case    0:  		/* li R10, 260 */
		/* 820AC5B8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x104);
		/* 820AC5B8h case    0:*/		return 0x820AC5BC;
		  /* 820AC5BCh */ case    1:  		/* b 16 */
		/* 820AC5BCh case    1:*/		return 0x820AC5CC;
		/* 820AC5BCh case    1:*/		return 0x820AC5C0;
	}
	return 0x820AC5C0;
} // Block from 820AC5B8h-820AC5C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5C0);
		  /* 820AC5C0h */ case    0:  		/* li R10, 259 */
		/* 820AC5C0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x103);
		/* 820AC5C0h case    0:*/		return 0x820AC5C4;
		  /* 820AC5C4h */ case    1:  		/* b 8 */
		/* 820AC5C4h case    1:*/		return 0x820AC5CC;
		/* 820AC5C4h case    1:*/		return 0x820AC5C8;
	}
	return 0x820AC5C8;
} // Block from 820AC5C0h-820AC5C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5C8);
		  /* 820AC5C8h */ case    0:  		/* li R10, 258 */
		/* 820AC5C8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x102);
		/* 820AC5C8h case    0:*/		return 0x820AC5CC;
	}
	return 0x820AC5CC;
} // Block from 820AC5C8h-820AC5CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5CC);
		  /* 820AC5CCh */ case    0:  		/* stw R10, <#[R1 + 96]> */
		/* 820AC5CCh case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820AC5CCh case    0:*/		return 0x820AC5D0;
		  /* 820AC5D0h */ case    1:  		/* b 56 */
		/* 820AC5D0h case    1:*/		return 0x820AC608;
		/* 820AC5D0h case    1:*/		return 0x820AC5D4;
	}
	return 0x820AC5D4;
} // Block from 820AC5CCh-820AC5D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5D4);
		  /* 820AC5D4h */ case    0:  		/* li R10, 268 */
		/* 820AC5D4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x10C);
		/* 820AC5D4h case    0:*/		return 0x820AC5D8;
		  /* 820AC5D8h */ case    1:  		/* b -12 */
		/* 820AC5D8h case    1:*/		return 0x820AC5CC;
		/* 820AC5D8h case    1:*/		return 0x820AC5DC;
	}
	return 0x820AC5DC;
} // Block from 820AC5D4h-820AC5DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC5DC);
		  /* 820AC5DCh */ case    0:  		/* cmpwi CR6, R11, -5 */
		/* 820AC5DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFB);
		/* 820AC5DCh case    0:*/		return 0x820AC5E0;
		  /* 820AC5E0h */ case    1:  		/* bc 12, CR6_EQ, 128 */
		/* 820AC5E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AC660;  }
		/* 820AC5E0h case    1:*/		return 0x820AC5E4;
		  /* 820AC5E4h */ case    2:  		/* cmpwi CR6, R11, -4 */
		/* 820AC5E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFC);
		/* 820AC5E4h case    2:*/		return 0x820AC5E8;
		  /* 820AC5E8h */ case    3:  		/* bc 12, CR6_EQ, 112 */
		/* 820AC5E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AC658;  }
		/* 820AC5E8h case    3:*/		return 0x820AC5EC;
		  /* 820AC5ECh */ case    4:  		/* cmpwi CR6, R11, -3 */
		/* 820AC5ECh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFD);
		/* 820AC5ECh case    4:*/		return 0x820AC5F0;
		  /* 820AC5F0h */ case    5:  		/* bc 12, CR6_EQ, 96 */
		/* 820AC5F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AC650;  }
		/* 820AC5F0h case    5:*/		return 0x820AC5F4;
		  /* 820AC5F4h */ case    6:  		/* cmpwi CR6, R11, -2 */
		/* 820AC5F4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFE);
		/* 820AC5F4h case    6:*/		return 0x820AC5F8;
		  /* 820AC5F8h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 820AC5F8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820AC648;  }
		/* 820AC5F8h case    7:*/		return 0x820AC5FC;
		  /* 820AC5FCh */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 820AC5FCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AC5FCh case    8:*/		return 0x820AC600;
		  /* 820AC600h */ case    9:  		/* bc 12, CR6_EQ, 3836 */
		/* 820AC600h case    9:*/		if ( regs.CR[6].eq ) { return 0x820AD4FC;  }
		/* 820AC600h case    9:*/		return 0x820AC604;
	}
	return 0x820AC604;
} // Block from 820AC5DCh-820AC604h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AC604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC604);
		  /* 820AC604h */ case    0:  		/* lwz R10, <#[R1 + 96]> */
		/* 820AC604h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820AC604h case    0:*/		return 0x820AC608;
	}
	return 0x820AC608;
} // Block from 820AC604h-820AC608h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AC608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC608);
		  /* 820AC608h */ case    0:  		/* addi R11, R27, -6120 */
		/* 820AC608h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFE818);
		/* 820AC608h case    0:*/		return 0x820AC60C;
		  /* 820AC60Ch */ case    1:  		/* stw R23, <#[R1 + 196]> */
		/* 820AC60Ch case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000C4) );
		/* 820AC60Ch case    1:*/		return 0x820AC610;
		  /* 820AC610h */ case    2:  		/* mulli R7, R6, 72 */
		/* 820AC610h case    2:*/		cpu::op::mulli<0>(regs,&regs.R7,regs.R6,0x48);
		/* 820AC610h case    2:*/		return 0x820AC614;
		  /* 820AC614h */ case    3:  		/* addi R11, R11, 4 */
		/* 820AC614h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820AC614h case    3:*/		return 0x820AC618;
		  /* 820AC618h */ case    4:  		/* cmpwi CR6, R9, 6 */
		/* 820AC618h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000006);
		/* 820AC618h case    4:*/		return 0x820AC61C;
		  /* 820AC61Ch */ case    5:  		/* lwzx R22, <#[R7 + R11]> */
		/* 820AC61Ch case    5:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820AC61Ch case    5:*/		return 0x820AC620;
		  /* 820AC620h */ case    6:  		/* bc 12, CR6_LT, 72 */
		/* 820AC620h case    6:*/		if ( regs.CR[6].lt ) { return 0x820AC668;  }
		/* 820AC620h case    6:*/		return 0x820AC624;
		  /* 820AC624h */ case    7:  		/* cmpwi CR6, R9, 9 */
		/* 820AC624h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000009);
		/* 820AC624h case    7:*/		return 0x820AC628;
		  /* 820AC628h */ case    8:  		/* bc 12, CR6_GT, 64 */
		/* 820AC628h case    8:*/		if ( regs.CR[6].gt ) { return 0x820AC668;  }
		/* 820AC628h case    8:*/		return 0x820AC62C;
		  /* 820AC62Ch */ case    9:  		/* cmpwi CR6, R10, 259 */
		/* 820AC62Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000103);
		/* 820AC62Ch case    9:*/		return 0x820AC630;
		  /* 820AC630h */ case   10:  		/* bc 12, CR6_LT, 56 */
		/* 820AC630h case   10:*/		if ( regs.CR[6].lt ) { return 0x820AC668;  }
		/* 820AC630h case   10:*/		return 0x820AC634;
		  /* 820AC634h */ case   11:  		/* cmpwi CR6, R10, 263 */
		/* 820AC634h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000107);
		/* 820AC634h case   11:*/		return 0x820AC638;
		  /* 820AC638h */ case   12:  		/* bc 12, CR6_GT, 48 */
		/* 820AC638h case   12:*/		if ( regs.CR[6].gt ) { return 0x820AC668;  }
		/* 820AC638h case   12:*/		return 0x820AC63C;
		  /* 820AC63Ch */ case   13:  		/* li R11, 1 */
		/* 820AC63Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820AC63Ch case   13:*/		return 0x820AC640;
		  /* 820AC640h */ case   14:  		/* stw R11, <#[R1 + 136]> */
		/* 820AC640h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 820AC640h case   14:*/		return 0x820AC644;
		  /* 820AC644h */ case   15:  		/* b 40 */
		/* 820AC644h case   15:*/		return 0x820AC66C;
		/* 820AC644h case   15:*/		return 0x820AC648;
	}
	return 0x820AC648;
} // Block from 820AC608h-820AC648h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820AC648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC648);
		  /* 820AC648h */ case    0:  		/* li R10, 265 */
		/* 820AC648h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x109);
		/* 820AC648h case    0:*/		return 0x820AC64C;
		  /* 820AC64Ch */ case    1:  		/* b -128 */
		/* 820AC64Ch case    1:*/		return 0x820AC5CC;
		/* 820AC64Ch case    1:*/		return 0x820AC650;
	}
	return 0x820AC650;
} // Block from 820AC648h-820AC650h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC650);
		  /* 820AC650h */ case    0:  		/* li R10, 264 */
		/* 820AC650h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x108);
		/* 820AC650h case    0:*/		return 0x820AC654;
		  /* 820AC654h */ case    1:  		/* b -136 */
		/* 820AC654h case    1:*/		return 0x820AC5CC;
		/* 820AC654h case    1:*/		return 0x820AC658;
	}
	return 0x820AC658;
} // Block from 820AC650h-820AC658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC658);
		  /* 820AC658h */ case    0:  		/* li R10, 266 */
		/* 820AC658h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x10A);
		/* 820AC658h case    0:*/		return 0x820AC65C;
		  /* 820AC65Ch */ case    1:  		/* b -144 */
		/* 820AC65Ch case    1:*/		return 0x820AC5CC;
		/* 820AC65Ch case    1:*/		return 0x820AC660;
	}
	return 0x820AC660;
} // Block from 820AC658h-820AC660h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC660);
		  /* 820AC660h */ case    0:  		/* li R10, 267 */
		/* 820AC660h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x10B);
		/* 820AC660h case    0:*/		return 0x820AC664;
		  /* 820AC664h */ case    1:  		/* b -152 */
		/* 820AC664h case    1:*/		return 0x820AC5CC;
		/* 820AC664h case    1:*/		return 0x820AC668;
	}
	return 0x820AC668;
} // Block from 820AC660h-820AC668h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC668);
		  /* 820AC668h */ case    0:  		/* li R11, 1 */
		/* 820AC668h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820AC668h case    0:*/		return 0x820AC66C;
	}
	return 0x820AC66C;
} // Block from 820AC668h-820AC66Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AC66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC66C);
		  /* 820AC66Ch */ case    0:  		/* cmpwi CR6, R9, 4 */
		/* 820AC66Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000004);
		/* 820AC66Ch case    0:*/		return 0x820AC670;
		  /* 820AC670h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 820AC670h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC67C;  }
		/* 820AC670h case    1:*/		return 0x820AC674;
		  /* 820AC674h */ case    2:  		/* cmpwi CR6, R9, 5 */
		/* 820AC674h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000005);
		/* 820AC674h case    2:*/		return 0x820AC678;
		  /* 820AC678h */ case    3:  		/* bc 4, CR6_GT, 20 */
		/* 820AC678h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820AC68C;  }
		/* 820AC678h case    3:*/		return 0x820AC67C;
	}
	return 0x820AC67C;
} // Block from 820AC66Ch-820AC67Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC67Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC67C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC67C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC67C);
		  /* 820AC67Ch */ case    0:  		/* cmpwi CR6, R9, 6 */
		/* 820AC67Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000006);
		/* 820AC67Ch case    0:*/		return 0x820AC680;
		  /* 820AC680h */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 820AC680h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC6A8;  }
		/* 820AC680h case    1:*/		return 0x820AC684;
		  /* 820AC684h */ case    2:  		/* cmpwi CR6, R9, 15 */
		/* 820AC684h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000F);
		/* 820AC684h case    2:*/		return 0x820AC688;
		  /* 820AC688h */ case    3:  		/* bc 12, CR6_GT, 32 */
		/* 820AC688h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AC6A8;  }
		/* 820AC688h case    3:*/		return 0x820AC68C;
	}
	return 0x820AC68C;
} // Block from 820AC67Ch-820AC68Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC68C);
		  /* 820AC68Ch */ case    0:  		/* cmpwi CR6, R10, 259 */
		/* 820AC68Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000103);
		/* 820AC68Ch case    0:*/		return 0x820AC690;
		  /* 820AC690h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 820AC690h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC6A8;  }
		/* 820AC690h case    1:*/		return 0x820AC694;
		  /* 820AC694h */ case    2:  		/* cmpwi CR6, R10, 263 */
		/* 820AC694h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000107);
		/* 820AC694h case    2:*/		return 0x820AC698;
		  /* 820AC698h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820AC698h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AC6A8;  }
		/* 820AC698h case    3:*/		return 0x820AC69C;
		  /* 820AC69Ch */ case    4:  		/* cmplwi CR6, R22, 31 */
		/* 820AC69Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000001F);
		/* 820AC69Ch case    4:*/		return 0x820AC6A0;
		  /* 820AC6A0h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 820AC6A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AC6A8;  }
		/* 820AC6A0h case    5:*/		return 0x820AC6A4;
		  /* 820AC6A4h */ case    6:  		/* stw R11, <#[R1 + 148]> */
		/* 820AC6A4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 820AC6A4h case    6:*/		return 0x820AC6A8;
	}
	return 0x820AC6A8;
} // Block from 820AC68Ch-820AC6A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AC6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC6A8);
		  /* 820AC6A8h */ case    0:  		/* cmpwi CR6, R9, 10 */
		/* 820AC6A8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000A);
		/* 820AC6A8h case    0:*/		return 0x820AC6AC;
		  /* 820AC6ACh */ case    1:  		/* bc 12, CR6_LT, 60 */
		/* 820AC6ACh case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC6E8;  }
		/* 820AC6ACh case    1:*/		return 0x820AC6B0;
		  /* 820AC6B0h */ case    2:  		/* cmpwi CR6, R9, 15 */
		/* 820AC6B0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000F);
		/* 820AC6B0h case    2:*/		return 0x820AC6B4;
		  /* 820AC6B4h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820AC6B4h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AC6C4;  }
		/* 820AC6B4h case    3:*/		return 0x820AC6B8;
		  /* 820AC6B8h */ case    4:  		/* cmplwi CR6, R22, 31 */
		/* 820AC6B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000001F);
		/* 820AC6B8h case    4:*/		return 0x820AC6BC;
		  /* 820AC6BCh */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820AC6BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AC6C4;  }
		/* 820AC6BCh case    5:*/		return 0x820AC6C0;
		  /* 820AC6C0h */ case    6:  		/* stw R11, <#[R1 + 168]> */
		/* 820AC6C0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 820AC6C0h case    6:*/		return 0x820AC6C4;
	}
	return 0x820AC6C4;
} // Block from 820AC6A8h-820AC6C4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AC6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC6C4);
		  /* 820AC6C4h */ case    0:  		/* cmpwi CR6, R9, 10 */
		/* 820AC6C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000A);
		/* 820AC6C4h case    0:*/		return 0x820AC6C8;
		  /* 820AC6C8h */ case    1:  		/* bc 12, CR6_LT, 32 */
		/* 820AC6C8h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC6E8;  }
		/* 820AC6C8h case    1:*/		return 0x820AC6CC;
		  /* 820AC6CCh */ case    2:  		/* cmpwi CR6, R9, 15 */
		/* 820AC6CCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000F);
		/* 820AC6CCh case    2:*/		return 0x820AC6D0;
		  /* 820AC6D0h */ case    3:  		/* bc 12, CR6_GT, 24 */
		/* 820AC6D0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AC6E8;  }
		/* 820AC6D0h case    3:*/		return 0x820AC6D4;
		  /* 820AC6D4h */ case    4:  		/* cmpwi CR6, R10, 259 */
		/* 820AC6D4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000103);
		/* 820AC6D4h case    4:*/		return 0x820AC6D8;
		  /* 820AC6D8h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 820AC6D8h case    5:*/		if ( regs.CR[6].lt ) { return 0x820AC6E8;  }
		/* 820AC6D8h case    5:*/		return 0x820AC6DC;
		  /* 820AC6DCh */ case    6:  		/* cmpwi CR6, R10, 263 */
		/* 820AC6DCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000107);
		/* 820AC6DCh case    6:*/		return 0x820AC6E0;
		  /* 820AC6E0h */ case    7:  		/* bc 12, CR6_GT, 8 */
		/* 820AC6E0h case    7:*/		if ( regs.CR[6].gt ) { return 0x820AC6E8;  }
		/* 820AC6E0h case    7:*/		return 0x820AC6E4;
		  /* 820AC6E4h */ case    8:  		/* stw R11, <#[R1 + 160]> */
		/* 820AC6E4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 820AC6E4h case    8:*/		return 0x820AC6E8;
	}
	return 0x820AC6E8;
} // Block from 820AC6C4h-820AC6E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AC6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC6E8);
		  /* 820AC6E8h */ case    0:  		/* cmpwi CR6, R9, 4 */
		/* 820AC6E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000004);
		/* 820AC6E8h case    0:*/		return 0x820AC6EC;
		  /* 820AC6ECh */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 820AC6ECh case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC6F8;  }
		/* 820AC6ECh case    1:*/		return 0x820AC6F0;
		  /* 820AC6F0h */ case    2:  		/* cmpwi CR6, R9, 5 */
		/* 820AC6F0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000005);
		/* 820AC6F0h case    2:*/		return 0x820AC6F4;
		  /* 820AC6F4h */ case    3:  		/* bc 4, CR6_GT, 20 */
		/* 820AC6F4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820AC708;  }
		/* 820AC6F4h case    3:*/		return 0x820AC6F8;
	}
	return 0x820AC6F8;
} // Block from 820AC6E8h-820AC6F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC6F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC6F8);
		  /* 820AC6F8h */ case    0:  		/* cmpwi CR6, R9, 10 */
		/* 820AC6F8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000A);
		/* 820AC6F8h case    0:*/		return 0x820AC6FC;
		  /* 820AC6FCh */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 820AC6FCh case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC714;  }
		/* 820AC6FCh case    1:*/		return 0x820AC700;
		  /* 820AC700h */ case    2:  		/* cmpwi CR6, R9, 15 */
		/* 820AC700h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000F);
		/* 820AC700h case    2:*/		return 0x820AC704;
		  /* 820AC704h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820AC704h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AC714;  }
		/* 820AC704h case    3:*/		return 0x820AC708;
	}
	return 0x820AC708;
} // Block from 820AC6F8h-820AC708h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC708);
		  /* 820AC708h */ case    0:  		/* cmplwi CR6, R22, 31 */
		/* 820AC708h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000001F);
		/* 820AC708h case    0:*/		return 0x820AC70C;
		  /* 820AC70Ch */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 820AC70Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AC714;  }
		/* 820AC70Ch case    1:*/		return 0x820AC710;
		  /* 820AC710h */ case    2:  		/* mr R25, R11 */
		/* 820AC710h case    2:*/		regs.R25 = regs.R11;
		/* 820AC710h case    2:*/		return 0x820AC714;
	}
	return 0x820AC714;
} // Block from 820AC708h-820AC714h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AC714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC714);
		  /* 820AC714h */ case    0:  		/* cmpwi CR6, R9, 14 */
		/* 820AC714h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000E);
		/* 820AC714h case    0:*/		return 0x820AC718;
		  /* 820AC718h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 820AC718h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC730;  }
		/* 820AC718h case    1:*/		return 0x820AC71C;
		  /* 820AC71Ch */ case    2:  		/* cmpwi CR6, R9, 15 */
		/* 820AC71Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000F);
		/* 820AC71Ch case    2:*/		return 0x820AC720;
		  /* 820AC720h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820AC720h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AC730;  }
		/* 820AC720h case    3:*/		return 0x820AC724;
		  /* 820AC724h */ case    4:  		/* cmplwi CR6, R22, 31 */
		/* 820AC724h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000001F);
		/* 820AC724h case    4:*/		return 0x820AC728;
		  /* 820AC728h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820AC728h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AC730;  }
		/* 820AC728h case    5:*/		return 0x820AC72C;
		  /* 820AC72Ch */ case    6:  		/* stw R11, <#[R1 + 144]> */
		/* 820AC72Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 820AC72Ch case    6:*/		return 0x820AC730;
	}
	return 0x820AC730;
} // Block from 820AC714h-820AC730h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AC730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC730);
		  /* 820AC730h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 820AC730h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC730h case    0:*/		return 0x820AC734;
		  /* 820AC734h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 820AC734h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AC74C;  }
		/* 820AC734h case    1:*/		return 0x820AC738;
		  /* 820AC738h */ case    2:  		/* cmpwi CR6, R9, 5 */
		/* 820AC738h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000005);
		/* 820AC738h case    2:*/		return 0x820AC73C;
		  /* 820AC73Ch */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 820AC73Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x820AC74C;  }
		/* 820AC73Ch case    3:*/		return 0x820AC740;
		  /* 820AC740h */ case    4:  		/* cmplwi CR6, R22, 31 */
		/* 820AC740h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000001F);
		/* 820AC740h case    4:*/		return 0x820AC744;
		  /* 820AC744h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820AC744h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AC74C;  }
		/* 820AC744h case    5:*/		return 0x820AC748;
		  /* 820AC748h */ case    6:  		/* mr R24, R11 */
		/* 820AC748h case    6:*/		regs.R24 = regs.R11;
		/* 820AC748h case    6:*/		return 0x820AC74C;
	}
	return 0x820AC74C;
} // Block from 820AC730h-820AC74Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AC74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC74C);
		  /* 820AC74Ch */ case    0:  		/* cmplwi CR6, R22, 40 */
		/* 820AC74Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000028);
		/* 820AC74Ch case    0:*/		return 0x820AC750;
		  /* 820AC750h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820AC750h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AC764;  }
		/* 820AC750h case    1:*/		return 0x820AC754;
		  /* 820AC754h */ case    2:  		/* cmplwi CR6, R22, 44 */
		/* 820AC754h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000002C);
		/* 820AC754h case    2:*/		return 0x820AC758;
		  /* 820AC758h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820AC758h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AC764;  }
		/* 820AC758h case    3:*/		return 0x820AC75C;
		  /* 820AC75Ch */ case    4:  		/* cmplwi CR6, R22, 94 */
		/* 820AC75Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000005E);
		/* 820AC75Ch case    4:*/		return 0x820AC760;
		  /* 820AC760h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820AC760h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AC76C;  }
		/* 820AC760h case    5:*/		return 0x820AC764;
	}
	return 0x820AC764;
} // Block from 820AC74Ch-820AC764h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AC764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC764);
		  /* 820AC764h */ case    0:  		/* mr R28, R11 */
		/* 820AC764h case    0:*/		regs.R28 = regs.R11;
		/* 820AC764h case    0:*/		return 0x820AC768;
		  /* 820AC768h */ case    1:  		/* stw R11, <#[R1 + 132]> */
		/* 820AC768h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820AC768h case    1:*/		return 0x820AC76C;
	}
	return 0x820AC76C;
} // Block from 820AC764h-820AC76Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC76C);
		  /* 820AC76Ch */ case    0:  		/* li R11, 2024 */
		/* 820AC76Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7E8);
		/* 820AC76Ch case    0:*/		return 0x820AC770;
		  /* 820AC770h */ case    1:  		/* stw R11, <#[R8 + 96]> */
		/* 820AC770h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000060) );
		/* 820AC770h case    1:*/		return 0x820AC774;
		  /* 820AC774h */ case    2:  		/* b 3276 */
		/* 820AC774h case    2:*/		return 0x820AD440;
		/* 820AC774h case    2:*/		return 0x820AC778;
	}
	return 0x820AC778;
} // Block from 820AC76Ch-820AC778h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AC778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC778);
		  /* 820AC778h */ case    0:  		/* lwz R11, <#[R1 + 148]> */
		/* 820AC778h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 820AC778h case    0:*/		return 0x820AC77C;
		  /* 820AC77Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AC77Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AC77Ch case    1:*/		return 0x820AC780;
		  /* 820AC780h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 820AC780h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AC7C8;  }
		/* 820AC780h case    2:*/		return 0x820AC784;
		  /* 820AC784h */ case    3:  		/* mr R10, R14 */
		/* 820AC784h case    3:*/		regs.R10 = regs.R14;
		/* 820AC784h case    3:*/		return 0x820AC788;
		  /* 820AC788h */ case    4:  		/* addi R11, R1, 112 */
		/* 820AC788h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC788h case    4:*/		return 0x820AC78C;
		  /* 820AC78Ch */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820AC78Ch case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC78Ch case    5:*/		return 0x820AC790;
		  /* 820AC790h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820AC790h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC790h case    6:*/		return 0x820AC794;
		  /* 820AC794h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820AC794h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC794h case    7:*/		return 0x820AC798;
		  /* 820AC798h */ case    8:  		/* subf R9, R8, R9 */
		/* 820AC798h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC798h case    8:*/		return 0x820AC79C;
		  /* 820AC79Ch */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC79Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820AC7B0;  }
		/* 820AC79Ch case    9:*/		return 0x820AC7A0;
		  /* 820AC7A0h */ case   10:  		/* addi R11, R11, 1 */
		/* 820AC7A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC7A0h case   10:*/		return 0x820AC7A4;
		  /* 820AC7A4h */ case   11:  		/* addi R10, R10, 1 */
		/* 820AC7A4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC7A4h case   11:*/		return 0x820AC7A8;
		  /* 820AC7A8h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820AC7A8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC7A8h case   12:*/		return 0x820AC7AC;
		  /* 820AC7ACh */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC7ACh case   13:*/		if ( regs.CR[6].eq ) { return 0x820AC78C;  }
		/* 820AC7ACh case   13:*/		return 0x820AC7B0;
	}
	return 0x820AC7B0;
} // Block from 820AC778h-820AC7B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AC7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC7B0);
		  /* 820AC7B0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC7B0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC7B0h case    0:*/		return 0x820AC7B4;
		  /* 820AC7B4h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 820AC7B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC7C8;  }
		/* 820AC7B4h case    1:*/		return 0x820AC7B8;
		  /* 820AC7B8h */ case    2:  		/* oris R21, R21, 16 */
		/* 820AC7B8h case    2:*/		cpu::op::oris<0>(regs,&regs.R21,regs.R21,0x10);
		/* 820AC7B8h case    2:*/		return 0x820AC7BC;
		  /* 820AC7BCh */ case    3:  		/* stw R23, <#[R1 + 136]> */
		/* 820AC7BCh case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000088) );
		/* 820AC7BCh case    3:*/		return 0x820AC7C0;
		  /* 820AC7C0h */ case    4:  		/* stw R23, <#[R1 + 148]> */
		/* 820AC7C0h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000094) );
		/* 820AC7C0h case    4:*/		return 0x820AC7C4;
		  /* 820AC7C4h */ case    5:  		/* b 3192 */
		/* 820AC7C4h case    5:*/		return 0x820AD43C;
		/* 820AC7C4h case    5:*/		return 0x820AC7C8;
	}
	return 0x820AC7C8;
} // Block from 820AC7B0h-820AC7C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AC7C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC7C8);
		  /* 820AC7C8h */ case    0:  		/* lwz R11, <#[R1 + 168]> */
		/* 820AC7C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 820AC7C8h case    0:*/		return 0x820AC7CC;
		  /* 820AC7CCh */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AC7CCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AC7CCh case    1:*/		return 0x820AC7D0;
		  /* 820AC7D0h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820AC7D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AC814;  }
		/* 820AC7D0h case    2:*/		return 0x820AC7D4;
		  /* 820AC7D4h */ case    3:  		/* lwz R10, <#[R1 + 180]> */
		/* 820AC7D4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B4) );
		/* 820AC7D4h case    3:*/		return 0x820AC7D8;
		  /* 820AC7D8h */ case    4:  		/* addi R11, R1, 112 */
		/* 820AC7D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC7D8h case    4:*/		return 0x820AC7DC;
		  /* 820AC7DCh */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820AC7DCh case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC7DCh case    5:*/		return 0x820AC7E0;
		  /* 820AC7E0h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820AC7E0h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC7E0h case    6:*/		return 0x820AC7E4;
		  /* 820AC7E4h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820AC7E4h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC7E4h case    7:*/		return 0x820AC7E8;
		  /* 820AC7E8h */ case    8:  		/* subf R9, R8, R9 */
		/* 820AC7E8h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC7E8h case    8:*/		return 0x820AC7EC;
		  /* 820AC7ECh */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC7ECh case    9:*/		if ( regs.CR[0].eq ) { return 0x820AC800;  }
		/* 820AC7ECh case    9:*/		return 0x820AC7F0;
		  /* 820AC7F0h */ case   10:  		/* addi R11, R11, 1 */
		/* 820AC7F0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC7F0h case   10:*/		return 0x820AC7F4;
		  /* 820AC7F4h */ case   11:  		/* addi R10, R10, 1 */
		/* 820AC7F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC7F4h case   11:*/		return 0x820AC7F8;
		  /* 820AC7F8h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820AC7F8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC7F8h case   12:*/		return 0x820AC7FC;
		  /* 820AC7FCh */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC7FCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820AC7DC;  }
		/* 820AC7FCh case   13:*/		return 0x820AC800;
	}
	return 0x820AC800;
} // Block from 820AC7C8h-820AC800h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AC800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC800);
		  /* 820AC800h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC800h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC800h case    0:*/		return 0x820AC804;
		  /* 820AC804h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820AC804h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC814;  }
		/* 820AC804h case    1:*/		return 0x820AC808;
		  /* 820AC808h */ case    2:  		/* oris R21, R21, 64 */
		/* 820AC808h case    2:*/		cpu::op::oris<0>(regs,&regs.R21,regs.R21,0x40);
		/* 820AC808h case    2:*/		return 0x820AC80C;
		  /* 820AC80Ch */ case    3:  		/* stw R23, <#[R1 + 168]> */
		/* 820AC80Ch case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000A8) );
		/* 820AC80Ch case    3:*/		return 0x820AC810;
		  /* 820AC810h */ case    4:  		/* b 3116 */
		/* 820AC810h case    4:*/		return 0x820AD43C;
		/* 820AC810h case    4:*/		return 0x820AC814;
	}
	return 0x820AC814;
} // Block from 820AC800h-820AC814h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AC814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC814);
		  /* 820AC814h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 820AC814h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 820AC814h case    0:*/		return 0x820AC818;
		  /* 820AC818h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AC818h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AC818h case    1:*/		return 0x820AC81C;
		  /* 820AC81Ch */ case    2:  		/* bc 12, CR6_EQ, 368 */
		/* 820AC81Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820AC98C;  }
		/* 820AC81Ch case    2:*/		return 0x820AC820;
		  /* 820AC820h */ case    3:  		/* lwz R10, <#[R1 + 172]> */
		/* 820AC820h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000AC) );
		/* 820AC820h case    3:*/		return 0x820AC824;
		  /* 820AC824h */ case    4:  		/* addi R11, R1, 112 */
		/* 820AC824h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC824h case    4:*/		return 0x820AC828;
		  /* 820AC828h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820AC828h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC828h case    5:*/		return 0x820AC82C;
		  /* 820AC82Ch */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820AC82Ch case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC82Ch case    6:*/		return 0x820AC830;
		  /* 820AC830h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820AC830h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC830h case    7:*/		return 0x820AC834;
		  /* 820AC834h */ case    8:  		/* subf R9, R8, R9 */
		/* 820AC834h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC834h case    8:*/		return 0x820AC838;
		  /* 820AC838h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC838h case    9:*/		if ( regs.CR[0].eq ) { return 0x820AC84C;  }
		/* 820AC838h case    9:*/		return 0x820AC83C;
		  /* 820AC83Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 820AC83Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC83Ch case   10:*/		return 0x820AC840;
		  /* 820AC840h */ case   11:  		/* addi R10, R10, 1 */
		/* 820AC840h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC840h case   11:*/		return 0x820AC844;
		  /* 820AC844h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820AC844h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC844h case   12:*/		return 0x820AC848;
		  /* 820AC848h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC848h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AC828;  }
		/* 820AC848h case   13:*/		return 0x820AC84C;
	}
	return 0x820AC84C;
} // Block from 820AC814h-820AC84Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AC84Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC84C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC84C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC84C);
		  /* 820AC84Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC84Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC84Ch case    0:*/		return 0x820AC850;
		  /* 820AC850h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AC850h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC85C;  }
		/* 820AC850h case    1:*/		return 0x820AC854;
		  /* 820AC854h */ case    2:  		/* lis R21, 768 */
		/* 820AC854h case    2:*/		cpu::op::lis<0>(regs,&regs.R21,0x300);
		/* 820AC854h case    2:*/		return 0x820AC858;
		  /* 820AC858h */ case    3:  		/* b 300 */
		/* 820AC858h case    3:*/		return 0x820AC984;
		/* 820AC858h case    3:*/		return 0x820AC85C;
	}
	return 0x820AC85C;
} // Block from 820AC84Ch-820AC85Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC85C);
		  /* 820AC85Ch */ case    0:  		/* lwz R10, <#[R1 + 164]> */
		/* 820AC85Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A4) );
		/* 820AC85Ch case    0:*/		return 0x820AC860;
		  /* 820AC860h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AC860h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC860h case    1:*/		return 0x820AC864;
		  /* 820AC864h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AC864h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC864h case    2:*/		return 0x820AC868;
		  /* 820AC868h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AC868h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC868h case    3:*/		return 0x820AC86C;
		  /* 820AC86Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AC86Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC86Ch case    4:*/		return 0x820AC870;
		  /* 820AC870h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AC870h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC870h case    5:*/		return 0x820AC874;
		  /* 820AC874h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC874h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AC888;  }
		/* 820AC874h case    6:*/		return 0x820AC878;
		  /* 820AC878h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AC878h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC878h case    7:*/		return 0x820AC87C;
		  /* 820AC87Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820AC87Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC87Ch case    8:*/		return 0x820AC880;
		  /* 820AC880h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AC880h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC880h case    9:*/		return 0x820AC884;
		  /* 820AC884h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC884h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AC864;  }
		/* 820AC884h case   10:*/		return 0x820AC888;
	}
	return 0x820AC888;
} // Block from 820AC85Ch-820AC888h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AC888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC888);
		  /* 820AC888h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC888h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC888h case    0:*/		return 0x820AC88C;
		  /* 820AC88Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AC88Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC898;  }
		/* 820AC88Ch case    1:*/		return 0x820AC890;
		  /* 820AC890h */ case    2:  		/* lis R21, 512 */
		/* 820AC890h case    2:*/		cpu::op::lis<0>(regs,&regs.R21,0x200);
		/* 820AC890h case    2:*/		return 0x820AC894;
		  /* 820AC894h */ case    3:  		/* b 240 */
		/* 820AC894h case    3:*/		return 0x820AC984;
		/* 820AC894h case    3:*/		return 0x820AC898;
	}
	return 0x820AC898;
} // Block from 820AC888h-820AC898h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC898);
		  /* 820AC898h */ case    0:  		/* lwz R10, <#[R1 + 156]> */
		/* 820AC898h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000009C) );
		/* 820AC898h case    0:*/		return 0x820AC89C;
		  /* 820AC89Ch */ case    1:  		/* addi R11, R1, 112 */
		/* 820AC89Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC89Ch case    1:*/		return 0x820AC8A0;
		  /* 820AC8A0h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AC8A0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC8A0h case    2:*/		return 0x820AC8A4;
		  /* 820AC8A4h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AC8A4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC8A4h case    3:*/		return 0x820AC8A8;
		  /* 820AC8A8h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AC8A8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC8A8h case    4:*/		return 0x820AC8AC;
		  /* 820AC8ACh */ case    5:  		/* subf R9, R8, R9 */
		/* 820AC8ACh case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC8ACh case    5:*/		return 0x820AC8B0;
		  /* 820AC8B0h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC8B0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AC8C4;  }
		/* 820AC8B0h case    6:*/		return 0x820AC8B4;
		  /* 820AC8B4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AC8B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC8B4h case    7:*/		return 0x820AC8B8;
		  /* 820AC8B8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AC8B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC8B8h case    8:*/		return 0x820AC8BC;
		  /* 820AC8BCh */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AC8BCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC8BCh case    9:*/		return 0x820AC8C0;
		  /* 820AC8C0h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC8C0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AC8A0;  }
		/* 820AC8C0h case   10:*/		return 0x820AC8C4;
	}
	return 0x820AC8C4;
} // Block from 820AC898h-820AC8C4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AC8C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC8C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC8C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC8C4);
		  /* 820AC8C4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC8C4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC8C4h case    0:*/		return 0x820AC8C8;
		  /* 820AC8C8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AC8C8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC8D4;  }
		/* 820AC8C8h case    1:*/		return 0x820AC8CC;
		  /* 820AC8CCh */ case    2:  		/* lis R21, 256 */
		/* 820AC8CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R21,0x100);
		/* 820AC8CCh case    2:*/		return 0x820AC8D0;
		  /* 820AC8D0h */ case    3:  		/* b 180 */
		/* 820AC8D0h case    3:*/		return 0x820AC984;
		/* 820AC8D0h case    3:*/		return 0x820AC8D4;
	}
	return 0x820AC8D4;
} // Block from 820AC8C4h-820AC8D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC8D4);
		  /* 820AC8D4h */ case    0:  		/* lwz R10, <#[R1 + 152]> */
		/* 820AC8D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 820AC8D4h case    0:*/		return 0x820AC8D8;
		  /* 820AC8D8h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AC8D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC8D8h case    1:*/		return 0x820AC8DC;
		  /* 820AC8DCh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AC8DCh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC8DCh case    2:*/		return 0x820AC8E0;
		  /* 820AC8E0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AC8E0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC8E0h case    3:*/		return 0x820AC8E4;
		  /* 820AC8E4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AC8E4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC8E4h case    4:*/		return 0x820AC8E8;
		  /* 820AC8E8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AC8E8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC8E8h case    5:*/		return 0x820AC8EC;
		  /* 820AC8ECh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC8ECh case    6:*/		if ( regs.CR[0].eq ) { return 0x820AC900;  }
		/* 820AC8ECh case    6:*/		return 0x820AC8F0;
		  /* 820AC8F0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AC8F0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC8F0h case    7:*/		return 0x820AC8F4;
		  /* 820AC8F4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AC8F4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC8F4h case    8:*/		return 0x820AC8F8;
		  /* 820AC8F8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AC8F8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC8F8h case    9:*/		return 0x820AC8FC;
		  /* 820AC8FCh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC8FCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820AC8DC;  }
		/* 820AC8FCh case   10:*/		return 0x820AC900;
	}
	return 0x820AC900;
} // Block from 820AC8D4h-820AC900h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AC900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC900);
		  /* 820AC900h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC900h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC900h case    0:*/		return 0x820AC904;
		  /* 820AC904h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AC904h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC910;  }
		/* 820AC904h case    1:*/		return 0x820AC908;
		  /* 820AC908h */ case    2:  		/* lis R21, 3840 */
		/* 820AC908h case    2:*/		cpu::op::lis<0>(regs,&regs.R21,0xF00);
		/* 820AC908h case    2:*/		return 0x820AC90C;
		  /* 820AC90Ch */ case    3:  		/* b 120 */
		/* 820AC90Ch case    3:*/		return 0x820AC984;
		/* 820AC90Ch case    3:*/		return 0x820AC910;
	}
	return 0x820AC910;
} // Block from 820AC900h-820AC910h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC910);
		  /* 820AC910h */ case    0:  		/* lwz R10, <#[R1 + 236]> */
		/* 820AC910h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000EC) );
		/* 820AC910h case    0:*/		return 0x820AC914;
		  /* 820AC914h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AC914h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC914h case    1:*/		return 0x820AC918;
		  /* 820AC918h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AC918h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC918h case    2:*/		return 0x820AC91C;
		  /* 820AC91Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AC91Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC91Ch case    3:*/		return 0x820AC920;
		  /* 820AC920h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AC920h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC920h case    4:*/		return 0x820AC924;
		  /* 820AC924h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AC924h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC924h case    5:*/		return 0x820AC928;
		  /* 820AC928h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC928h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AC93C;  }
		/* 820AC928h case    6:*/		return 0x820AC92C;
		  /* 820AC92Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820AC92Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC92Ch case    7:*/		return 0x820AC930;
		  /* 820AC930h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AC930h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC930h case    8:*/		return 0x820AC934;
		  /* 820AC934h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AC934h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC934h case    9:*/		return 0x820AC938;
		  /* 820AC938h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC938h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AC918;  }
		/* 820AC938h case   10:*/		return 0x820AC93C;
	}
	return 0x820AC93C;
} // Block from 820AC910h-820AC93Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AC93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC93C);
		  /* 820AC93Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC93Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC93Ch case    0:*/		return 0x820AC940;
		  /* 820AC940h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AC940h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC94C;  }
		/* 820AC940h case    1:*/		return 0x820AC944;
		  /* 820AC944h */ case    2:  		/* lis R21, 3584 */
		/* 820AC944h case    2:*/		cpu::op::lis<0>(regs,&regs.R21,0xE00);
		/* 820AC944h case    2:*/		return 0x820AC948;
		  /* 820AC948h */ case    3:  		/* b 60 */
		/* 820AC948h case    3:*/		return 0x820AC984;
		/* 820AC948h case    3:*/		return 0x820AC94C;
	}
	return 0x820AC94C;
} // Block from 820AC93Ch-820AC94Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC94C);
		  /* 820AC94Ch */ case    0:  		/* mr R10, R15 */
		/* 820AC94Ch case    0:*/		regs.R10 = regs.R15;
		/* 820AC94Ch case    0:*/		return 0x820AC950;
		  /* 820AC950h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AC950h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC950h case    1:*/		return 0x820AC954;
		  /* 820AC954h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AC954h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC954h case    2:*/		return 0x820AC958;
		  /* 820AC958h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AC958h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC958h case    3:*/		return 0x820AC95C;
		  /* 820AC95Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AC95Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC95Ch case    4:*/		return 0x820AC960;
		  /* 820AC960h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AC960h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AC960h case    5:*/		return 0x820AC964;
		  /* 820AC964h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC964h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AC978;  }
		/* 820AC964h case    6:*/		return 0x820AC968;
		  /* 820AC968h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AC968h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC968h case    7:*/		return 0x820AC96C;
		  /* 820AC96Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820AC96Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC96Ch case    8:*/		return 0x820AC970;
		  /* 820AC970h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AC970h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC970h case    9:*/		return 0x820AC974;
		  /* 820AC974h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC974h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AC954;  }
		/* 820AC974h case   10:*/		return 0x820AC978;
	}
	return 0x820AC978;
} // Block from 820AC94Ch-820AC978h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AC978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC978);
		  /* 820AC978h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC978h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC978h case    0:*/		return 0x820AC97C;
		  /* 820AC97Ch */ case    1:  		/* bc 4, CR0_EQ, 2936 */
		/* 820AC97Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD4F4;  }
		/* 820AC97Ch case    1:*/		return 0x820AC980;
		  /* 820AC980h */ case    2:  		/* lis R21, 3328 */
		/* 820AC980h case    2:*/		cpu::op::lis<0>(regs,&regs.R21,0xD00);
		/* 820AC980h case    2:*/		return 0x820AC984;
	}
	return 0x820AC984;
} // Block from 820AC978h-820AC984h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AC984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC984);
		  /* 820AC984h */ case    0:  		/* stw R23, <#[R1 + 136]> */
		/* 820AC984h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000088) );
		/* 820AC984h case    0:*/		return 0x820AC988;
		  /* 820AC988h */ case    1:  		/* b 2740 */
		/* 820AC988h case    1:*/		return 0x820AD43C;
		/* 820AC988h case    1:*/		return 0x820AC98C;
	}
	return 0x820AC98C;
} // Block from 820AC984h-820AC98Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AC98Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC98C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC98C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC98C);
		  /* 820AC98Ch */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 820AC98Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820AC98Ch case    0:*/		return 0x820AC990;
		  /* 820AC990h */ case    1:  		/* bc 12, CR6_EQ, 212 */
		/* 820AC990h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ACA64;  }
		/* 820AC990h case    1:*/		return 0x820AC994;
		  /* 820AC994h */ case    2:  		/* mr R10, R17 */
		/* 820AC994h case    2:*/		regs.R10 = regs.R17;
		/* 820AC994h case    2:*/		return 0x820AC998;
		  /* 820AC998h */ case    3:  		/* mr R8, R23 */
		/* 820AC998h case    3:*/		regs.R8 = regs.R23;
		/* 820AC998h case    3:*/		return 0x820AC99C;
		  /* 820AC99Ch */ case    4:  		/* addi R11, R1, 112 */
		/* 820AC99Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC99Ch case    4:*/		return 0x820AC9A0;
		  /* 820AC9A0h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820AC9A0h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC9A0h case    5:*/		return 0x820AC9A4;
		  /* 820AC9A4h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820AC9A4h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC9A4h case    6:*/		return 0x820AC9A8;
		  /* 820AC9A8h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820AC9A8h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC9A8h case    7:*/		return 0x820AC9AC;
		  /* 820AC9ACh */ case    8:  		/* subf R9, R7, R9 */
		/* 820AC9ACh case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820AC9ACh case    8:*/		return 0x820AC9B0;
		  /* 820AC9B0h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC9B0h case    9:*/		if ( regs.CR[0].eq ) { return 0x820AC9C4;  }
		/* 820AC9B0h case    9:*/		return 0x820AC9B4;
		  /* 820AC9B4h */ case   10:  		/* addi R11, R11, 1 */
		/* 820AC9B4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC9B4h case   10:*/		return 0x820AC9B8;
		  /* 820AC9B8h */ case   11:  		/* addi R10, R10, 1 */
		/* 820AC9B8h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC9B8h case   11:*/		return 0x820AC9BC;
		  /* 820AC9BCh */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820AC9BCh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC9BCh case   12:*/		return 0x820AC9C0;
		  /* 820AC9C0h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC9C0h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AC9A0;  }
		/* 820AC9C0h case   13:*/		return 0x820AC9C4;
	}
	return 0x820AC9C4;
} // Block from 820AC98Ch-820AC9C4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AC9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC9C4);
		  /* 820AC9C4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AC9C4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC9C4h case    0:*/		return 0x820AC9C8;
		  /* 820AC9C8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AC9C8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AC9D4;  }
		/* 820AC9C8h case    1:*/		return 0x820AC9CC;
		  /* 820AC9CCh */ case    2:  		/* lis R8, 4096 */
		/* 820AC9CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x1000);
		/* 820AC9CCh case    2:*/		return 0x820AC9D0;
		  /* 820AC9D0h */ case    3:  		/* b 120 */
		/* 820AC9D0h case    3:*/		return 0x820ACA48;
		/* 820AC9D0h case    3:*/		return 0x820AC9D4;
	}
	return 0x820AC9D4;
} // Block from 820AC9C4h-820AC9D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AC9D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AC9D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AC9D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AC9D4);
		  /* 820AC9D4h */ case    0:  		/* mr R10, R16 */
		/* 820AC9D4h case    0:*/		regs.R10 = regs.R16;
		/* 820AC9D4h case    0:*/		return 0x820AC9D8;
		  /* 820AC9D8h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AC9D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AC9D8h case    1:*/		return 0x820AC9DC;
		  /* 820AC9DCh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AC9DCh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AC9DCh case    2:*/		return 0x820AC9E0;
		  /* 820AC9E0h */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820AC9E0h case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820AC9E0h case    3:*/		return 0x820AC9E4;
		  /* 820AC9E4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AC9E4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AC9E4h case    4:*/		return 0x820AC9E8;
		  /* 820AC9E8h */ case    5:  		/* subf R9, R7, R9 */
		/* 820AC9E8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820AC9E8h case    5:*/		return 0x820AC9EC;
		  /* 820AC9ECh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AC9ECh case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACA00;  }
		/* 820AC9ECh case    6:*/		return 0x820AC9F0;
		  /* 820AC9F0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AC9F0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AC9F0h case    7:*/		return 0x820AC9F4;
		  /* 820AC9F4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AC9F4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AC9F4h case    8:*/		return 0x820AC9F8;
		  /* 820AC9F8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AC9F8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AC9F8h case    9:*/		return 0x820AC9FC;
		  /* 820AC9FCh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AC9FCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820AC9DC;  }
		/* 820AC9FCh case   10:*/		return 0x820ACA00;
	}
	return 0x820ACA00;
} // Block from 820AC9D4h-820ACA00h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACA00);
		  /* 820ACA00h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACA00h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACA00h case    0:*/		return 0x820ACA04;
		  /* 820ACA04h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACA04h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACA10;  }
		/* 820ACA04h case    1:*/		return 0x820ACA08;
		  /* 820ACA08h */ case    2:  		/* lis R8, 6144 */
		/* 820ACA08h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x1800);
		/* 820ACA08h case    2:*/		return 0x820ACA0C;
		  /* 820ACA0Ch */ case    3:  		/* b 60 */
		/* 820ACA0Ch case    3:*/		return 0x820ACA48;
		/* 820ACA0Ch case    3:*/		return 0x820ACA10;
	}
	return 0x820ACA10;
} // Block from 820ACA00h-820ACA10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACA10);
		  /* 820ACA10h */ case    0:  		/* lwz R10, <#[R1 + 264]> */
		/* 820ACA10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000108) );
		/* 820ACA10h case    0:*/		return 0x820ACA14;
		  /* 820ACA14h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACA14h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACA14h case    1:*/		return 0x820ACA18;
		  /* 820ACA18h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACA18h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACA18h case    2:*/		return 0x820ACA1C;
		  /* 820ACA1Ch */ case    3:  		/* lbz R7, <#[R10]> */
		/* 820ACA1Ch case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACA1Ch case    3:*/		return 0x820ACA20;
		  /* 820ACA20h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACA20h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACA20h case    4:*/		return 0x820ACA24;
		  /* 820ACA24h */ case    5:  		/* subf R9, R7, R9 */
		/* 820ACA24h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820ACA24h case    5:*/		return 0x820ACA28;
		  /* 820ACA28h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACA28h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACA3C;  }
		/* 820ACA28h case    6:*/		return 0x820ACA2C;
		  /* 820ACA2Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACA2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACA2Ch case    7:*/		return 0x820ACA30;
		  /* 820ACA30h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACA30h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACA30h case    8:*/		return 0x820ACA34;
		  /* 820ACA34h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACA34h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACA34h case    9:*/		return 0x820ACA38;
		  /* 820ACA38h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACA38h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACA18;  }
		/* 820ACA38h case   10:*/		return 0x820ACA3C;
	}
	return 0x820ACA3C;
} // Block from 820ACA10h-820ACA3Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACA3C);
		  /* 820ACA3Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACA3Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACA3Ch case    0:*/		return 0x820ACA40;
		  /* 820ACA40h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 820ACA40h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACA48;  }
		/* 820ACA40h case    1:*/		return 0x820ACA44;
		  /* 820ACA44h */ case    2:  		/* lis R8, 8192 */
		/* 820ACA44h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x2000);
		/* 820ACA44h case    2:*/		return 0x820ACA48;
	}
	return 0x820ACA48;
} // Block from 820ACA3Ch-820ACA48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ACA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACA48);
		  /* 820ACA48h */ case    0:  		/* mr R25, R23 */
		/* 820ACA48h case    0:*/		regs.R25 = regs.R23;
		/* 820ACA48h case    0:*/		return 0x820ACA4C;
		  /* 820ACA4Ch */ case    1:  		/* or R26, R8, R26 */
		/* 820ACA4Ch case    1:*/		cpu::op::or<0>(regs,&regs.R26,regs.R8,regs.R26);
		/* 820ACA4Ch case    1:*/		return 0x820ACA50;
		  /* 820ACA50h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 820ACA50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820ACA50h case    2:*/		return 0x820ACA54;
		  /* 820ACA54h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 820ACA54h case    3:*/		if ( regs.CR[6].eq ) { return 0x820ACA64;  }
		/* 820ACA54h case    3:*/		return 0x820ACA58;
		  /* 820ACA58h */ case    4:  		/* mr R24, R23 */
		/* 820ACA58h case    4:*/		regs.R24 = regs.R23;
		/* 820ACA58h case    4:*/		return 0x820ACA5C;
		  /* 820ACA5Ch */ case    5:  		/* stw R23, <#[R1 + 144]> */
		/* 820ACA5Ch case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000090) );
		/* 820ACA5Ch case    5:*/		return 0x820ACA60;
		  /* 820ACA60h */ case    6:  		/* b 2524 */
		/* 820ACA60h case    6:*/		return 0x820AD43C;
		/* 820ACA60h case    6:*/		return 0x820ACA64;
	}
	return 0x820ACA64;
} // Block from 820ACA48h-820ACA64h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ACA64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACA64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACA64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACA64);
		  /* 820ACA64h */ case    0:  		/* lwz R11, <#[R1 + 160]> */
		/* 820ACA64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 820ACA64h case    0:*/		return 0x820ACA68;
		  /* 820ACA68h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820ACA68h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ACA68h case    1:*/		return 0x820ACA6C;
		  /* 820ACA6Ch */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820ACA6Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820ACAB0;  }
		/* 820ACA6Ch case    2:*/		return 0x820ACA70;
		  /* 820ACA70h */ case    3:  		/* mr R10, R18 */
		/* 820ACA70h case    3:*/		regs.R10 = regs.R18;
		/* 820ACA70h case    3:*/		return 0x820ACA74;
		  /* 820ACA74h */ case    4:  		/* addi R11, R1, 112 */
		/* 820ACA74h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACA74h case    4:*/		return 0x820ACA78;
		  /* 820ACA78h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820ACA78h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACA78h case    5:*/		return 0x820ACA7C;
		  /* 820ACA7Ch */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820ACA7Ch case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACA7Ch case    6:*/		return 0x820ACA80;
		  /* 820ACA80h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820ACA80h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACA80h case    7:*/		return 0x820ACA84;
		  /* 820ACA84h */ case    8:  		/* subf R9, R8, R9 */
		/* 820ACA84h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACA84h case    8:*/		return 0x820ACA88;
		  /* 820ACA88h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACA88h case    9:*/		if ( regs.CR[0].eq ) { return 0x820ACA9C;  }
		/* 820ACA88h case    9:*/		return 0x820ACA8C;
		  /* 820ACA8Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 820ACA8Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACA8Ch case   10:*/		return 0x820ACA90;
		  /* 820ACA90h */ case   11:  		/* addi R10, R10, 1 */
		/* 820ACA90h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACA90h case   11:*/		return 0x820ACA94;
		  /* 820ACA94h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820ACA94h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACA94h case   12:*/		return 0x820ACA98;
		  /* 820ACA98h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACA98h case   13:*/		if ( regs.CR[6].eq ) { return 0x820ACA78;  }
		/* 820ACA98h case   13:*/		return 0x820ACA9C;
	}
	return 0x820ACA9C;
} // Block from 820ACA64h-820ACA9Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ACA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACA9C);
		  /* 820ACA9Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACA9Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACA9Ch case    0:*/		return 0x820ACAA0;
		  /* 820ACAA0h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820ACAA0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACAB0;  }
		/* 820ACAA0h case    1:*/		return 0x820ACAA4;
		  /* 820ACAA4h */ case    2:  		/* oris R21, R21, 32 */
		/* 820ACAA4h case    2:*/		cpu::op::oris<0>(regs,&regs.R21,regs.R21,0x20);
		/* 820ACAA4h case    2:*/		return 0x820ACAA8;
		  /* 820ACAA8h */ case    3:  		/* stw R23, <#[R1 + 160]> */
		/* 820ACAA8h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000A0) );
		/* 820ACAA8h case    3:*/		return 0x820ACAAC;
		  /* 820ACAACh */ case    4:  		/* b 2448 */
		/* 820ACAACh case    4:*/		return 0x820AD43C;
		/* 820ACAACh case    4:*/		return 0x820ACAB0;
	}
	return 0x820ACAB0;
} // Block from 820ACA9Ch-820ACAB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ACAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACAB0);
		  /* 820ACAB0h */ case    0:  		/* lwz R11, <#[R1 + 144]> */
		/* 820ACAB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 820ACAB0h case    0:*/		return 0x820ACAB4;
		  /* 820ACAB4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820ACAB4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ACAB4h case    1:*/		return 0x820ACAB8;
		  /* 820ACAB8h */ case    2:  		/* bc 12, CR6_EQ, 1056 */
		/* 820ACAB8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820ACED8;  }
		/* 820ACAB8h case    2:*/		return 0x820ACABC;
		  /* 820ACABCh */ case    3:  		/* lbz R11, <#[R1 + 112]> */
		/* 820ACABCh case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820ACABCh case    3:*/		return 0x820ACAC0;
		  /* 820ACAC0h */ case    4:  		/* addi R30, R1, 112 */
		/* 820ACAC0h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x70);
		/* 820ACAC0h case    4:*/		return 0x820ACAC4;
		  /* 820ACAC4h */ case    5:  		/* b 28 */
		/* 820ACAC4h case    5:*/		return 0x820ACAE0;
		/* 820ACAC4h case    5:*/		return 0x820ACAC8;
		  /* 820ACAC8h */ case    6:  		/* lbz R11, <#[R30]> */
		/* 820ACAC8h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACAC8h case    6:*/		return 0x820ACACC;
		  /* 820ACACCh */ case    7:  		/* extsb R3, R11 */
		/* 820ACACCh case    7:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820ACACCh case    7:*/		return 0x820ACAD0;
		  /* 820ACAD0h */ case    8:  		/* bl -78816 */
		/* 820ACAD0h case    8:*/		regs.LR = 0x820ACAD4; return 0x820996F0;
		/* 820ACAD0h case    8:*/		return 0x820ACAD4;
		  /* 820ACAD4h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820ACAD4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ACAD4h case    9:*/		return 0x820ACAD8;
	}
	return 0x820ACAD8;
} // Block from 820ACAB0h-820ACAD8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ACAD8h
// Function '?VError@CAssembler@D3DXShader@@IAAXPBDPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACAD8);
		  /* 820ACAD8h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 820ACAD8h case    0:*/		if ( regs.CR[0].eq ) { return 0x820ACAE8;  }
		/* 820ACAD8h case    0:*/		return 0x820ACADC;
		  /* 820ACADCh */ case    1:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820ACADCh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820ACADCh case    1:*/		return 0x820ACAE0;
	}
	return 0x820ACAE0;
} // Block from 820ACAD8h-820ACAE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ACAE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACAE0);
		  /* 820ACAE0h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820ACAE0h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ACAE0h case    0:*/		return 0x820ACAE4;
		  /* 820ACAE4h */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820ACAE4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACAC8;  }
		/* 820ACAE4h case    1:*/		return 0x820ACAE8;
	}
	return 0x820ACAE8;
} // Block from 820ACAE0h-820ACAE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ACAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACAE8);
		  /* 820ACAE8h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820ACAE8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACAE8h case    0:*/		return 0x820ACAEC;
		  /* 820ACAECh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820ACAECh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ACAECh case    1:*/		return 0x820ACAF0;
		  /* 820ACAF0h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACAF0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820ACB04;  }
		/* 820ACAF0h case    2:*/		return 0x820ACAF4;
		  /* 820ACAF4h */ case    3:  		/* mr R3, R30 */
		/* 820ACAF4h case    3:*/		regs.R3 = regs.R30;
		/* 820ACAF4h case    3:*/		return 0x820ACAF8;
		  /* 820ACAF8h */ case    4:  		/* bl -106384 */
		/* 820ACAF8h case    4:*/		regs.LR = 0x820ACAFC; return 0x82092B68;
		/* 820ACAF8h case    4:*/		return 0x820ACAFC;
		  /* 820ACAFCh */ case    5:  		/* mr R27, R3 */
		/* 820ACAFCh case    5:*/		regs.R27 = regs.R3;
		/* 820ACAFCh case    5:*/		return 0x820ACB00;
		  /* 820ACB00h */ case    6:  		/* b 8 */
		/* 820ACB00h case    6:*/		return 0x820ACB08;
		/* 820ACB00h case    6:*/		return 0x820ACB04;
	}
	return 0x820ACB04;
} // Block from 820ACAE8h-820ACB04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ACB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACB04);
		  /* 820ACB04h */ case    0:  		/* mr R27, R23 */
		/* 820ACB04h case    0:*/		regs.R27 = regs.R23;
		/* 820ACB04h case    0:*/		return 0x820ACB08;
	}
	return 0x820ACB08;
} // Block from 820ACB04h-820ACB08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ACB08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACB08);
		  /* 820ACB08h */ case    0:  		/* cmplwi CR6, R27, 15 */
		/* 820ACB08h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x0000000F);
		/* 820ACB08h case    0:*/		return 0x820ACB0C;
		  /* 820ACB0Ch */ case    1:  		/* bc 12, CR6_GT, 968 */
		/* 820ACB0Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x820ACED4;  }
		/* 820ACB0Ch case    1:*/		return 0x820ACB10;
		  /* 820ACB10h */ case    2:  		/* lbz R29, <#[R30]> */
		/* 820ACB10h case    2:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACB10h case    2:*/		return 0x820ACB14;
		  /* 820ACB14h */ case    3:  		/* mr R28, R30 */
		/* 820ACB14h case    3:*/		regs.R28 = regs.R30;
		/* 820ACB14h case    3:*/		return 0x820ACB18;
		  /* 820ACB18h */ case    4:  		/* cmplwi CR0, R29, 0 */
		/* 820ACB18h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 820ACB18h case    4:*/		return 0x820ACB1C;
		  /* 820ACB1Ch */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 820ACB1Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820ACB28;  }
		/* 820ACB1Ch case    5:*/		return 0x820ACB20;
		  /* 820ACB20h */ case    6:  		/* stb R23, <#[R30]> */
		/* 820ACB20h case    6:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACB20h case    6:*/		return 0x820ACB24;
		  /* 820ACB24h */ case    7:  		/* addi R30, R30, 1 */
		/* 820ACB24h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820ACB24h case    7:*/		return 0x820ACB28;
	}
	return 0x820ACB28;
} // Block from 820ACB08h-820ACB28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820ACB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACB28);
		  /* 820ACB28h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820ACB28h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACB28h case    0:*/		return 0x820ACB2C;
		  /* 820ACB2Ch */ case    1:  		/* b 20 */
		/* 820ACB2Ch case    1:*/		return 0x820ACB40;
		/* 820ACB2Ch case    1:*/		return 0x820ACB30;
		  /* 820ACB30h */ case    2:  		/* bl -78880 */
		/* 820ACB30h case    2:*/		regs.LR = 0x820ACB34; return 0x82099710;
		/* 820ACB30h case    2:*/		return 0x820ACB34;
		  /* 820ACB34h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820ACB34h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ACB34h case    3:*/		return 0x820ACB38;
		  /* 820ACB38h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820ACB38h case    4:*/		if ( regs.CR[0].eq ) { return 0x820ACB48;  }
		/* 820ACB38h case    4:*/		return 0x820ACB3C;
		  /* 820ACB3Ch */ case    5:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820ACB3Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820ACB3Ch case    5:*/		return 0x820ACB40;
	}
	return 0x820ACB40;
} // Block from 820ACB28h-820ACB40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ACB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACB40);
		  /* 820ACB40h */ case    0:  		/* extsb. R3, R11 */
		/* 820ACB40h case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820ACB40h case    0:*/		return 0x820ACB44;
		  /* 820ACB44h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820ACB44h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACB30;  }
		/* 820ACB44h case    1:*/		return 0x820ACB48;
	}
	return 0x820ACB48;
} // Block from 820ACB40h-820ACB48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ACB48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACB48);
		  /* 820ACB48h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820ACB48h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACB48h case    0:*/		return 0x820ACB4C;
		  /* 820ACB4Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820ACB4Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ACB4Ch case    1:*/		return 0x820ACB50;
		  /* 820ACB50h */ case    2:  		/* bc 4, CR0_EQ, 892 */
		/* 820ACB50h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820ACECC;  }
		/* 820ACB50h case    2:*/		return 0x820ACB54;
		  /* 820ACB54h */ case    3:  		/* mr R10, R19 */
		/* 820ACB54h case    3:*/		regs.R10 = regs.R19;
		/* 820ACB54h case    3:*/		return 0x820ACB58;
		  /* 820ACB58h */ case    4:  		/* addi R11, R1, 112 */
		/* 820ACB58h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACB58h case    4:*/		return 0x820ACB5C;
		  /* 820ACB5Ch */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820ACB5Ch case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACB5Ch case    5:*/		return 0x820ACB60;
		  /* 820ACB60h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820ACB60h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACB60h case    6:*/		return 0x820ACB64;
		  /* 820ACB64h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820ACB64h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACB64h case    7:*/		return 0x820ACB68;
		  /* 820ACB68h */ case    8:  		/* subf R9, R8, R9 */
		/* 820ACB68h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACB68h case    8:*/		return 0x820ACB6C;
		  /* 820ACB6Ch */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACB6Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820ACB80;  }
		/* 820ACB6Ch case    9:*/		return 0x820ACB70;
		  /* 820ACB70h */ case   10:  		/* addi R11, R11, 1 */
		/* 820ACB70h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACB70h case   10:*/		return 0x820ACB74;
		  /* 820ACB74h */ case   11:  		/* addi R10, R10, 1 */
		/* 820ACB74h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACB74h case   11:*/		return 0x820ACB78;
		  /* 820ACB78h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820ACB78h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACB78h case   12:*/		return 0x820ACB7C;
		  /* 820ACB7Ch */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACB7Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820ACB5C;  }
		/* 820ACB7Ch case   13:*/		return 0x820ACB80;
	}
	return 0x820ACB80;
} // Block from 820ACB48h-820ACB80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ACB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACB80);
		  /* 820ACB80h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACB80h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACB80h case    0:*/		return 0x820ACB84;
		  /* 820ACB84h */ case    1:  		/* bc 4, CR0_EQ, 52 */
		/* 820ACB84h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACBB8;  }
		/* 820ACB84h case    1:*/		return 0x820ACB88;
		  /* 820ACB88h */ case    2:  		/* mr R11, R23 */
		/* 820ACB88h case    2:*/		regs.R11 = regs.R23;
		/* 820ACB88h case    2:*/		return 0x820ACB8C;
		  /* 820ACB8Ch */ case    3:  		/* cmplwi CR6, R27, 0 */
		/* 820ACB8Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820ACB8Ch case    3:*/		return 0x820ACB90;
		  /* 820ACB90h */ case    4:  		/* bc 12, CR6_EQ, 828 */
		/* 820ACB90h case    4:*/		if ( regs.CR[6].eq ) { return 0x820ACECC;  }
		/* 820ACB90h case    4:*/		return 0x820ACB94;
		  /* 820ACB94h */ case    5:  		/* rlwinm R10, R27, 16, 12, 15 */
		/* 820ACB94h case    5:*/		cpu::op::rlwinm<0,16,12,15>(regs,&regs.R10,regs.R27);
		/* 820ACB94h case    5:*/		return 0x820ACB98;
		  /* 820ACB98h */ case    6:  		/* lwz R28, <#[R1 + 132]> */
		/* 820ACB98h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000084) );
		/* 820ACB98h case    6:*/		return 0x820ACB9C;
		  /* 820ACB9Ch */ case    7:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 820ACB9Ch case    7:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 820ACB9Ch case    7:*/		return 0x820ACBA0;
		  /* 820ACBA0h */ case    8:  		/* lwz R27, <#[R1 + 140]> */
		/* 820ACBA0h case    8:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000008C) );
		/* 820ACBA0h case    8:*/		return 0x820ACBA4;
		  /* 820ACBA4h */ case    9:  		/* mr R25, R23 */
		/* 820ACBA4h case    9:*/		regs.R25 = regs.R23;
		/* 820ACBA4h case    9:*/		return 0x820ACBA8;
		  /* 820ACBA8h */ case   10:  		/* stw R23, <#[R1 + 144]> */
		/* 820ACBA8h case   10:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000090) );
		/* 820ACBA8h case   10:*/		return 0x820ACBAC;
		  /* 820ACBACh */ case   11:  		/* or R11, R10, R11 */
		/* 820ACBACh case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820ACBACh case   11:*/		return 0x820ACBB0;
		  /* 820ACBB0h */ case   12:  		/* or R26, R11, R26 */
		/* 820ACBB0h case   12:*/		cpu::op::or<0>(regs,&regs.R26,regs.R11,regs.R26);
		/* 820ACBB0h case   12:*/		return 0x820ACBB4;
		  /* 820ACBB4h */ case   13:  		/* b 2184 */
		/* 820ACBB4h case   13:*/		return 0x820AD43C;
		/* 820ACBB4h case   13:*/		return 0x820ACBB8;
	}
	return 0x820ACBB8;
} // Block from 820ACB80h-820ACBB8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ACBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACBB8);
		  /* 820ACBB8h */ case    0:  		/* mr R10, R20 */
		/* 820ACBB8h case    0:*/		regs.R10 = regs.R20;
		/* 820ACBB8h case    0:*/		return 0x820ACBBC;
		  /* 820ACBBCh */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACBBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACBBCh case    1:*/		return 0x820ACBC0;
		  /* 820ACBC0h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACBC0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACBC0h case    2:*/		return 0x820ACBC4;
		  /* 820ACBC4h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACBC4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACBC4h case    3:*/		return 0x820ACBC8;
		  /* 820ACBC8h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACBC8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACBC8h case    4:*/		return 0x820ACBCC;
		  /* 820ACBCCh */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACBCCh case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACBCCh case    5:*/		return 0x820ACBD0;
		  /* 820ACBD0h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACBD0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACBE4;  }
		/* 820ACBD0h case    6:*/		return 0x820ACBD4;
		  /* 820ACBD4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACBD4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACBD4h case    7:*/		return 0x820ACBD8;
		  /* 820ACBD8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACBD8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACBD8h case    8:*/		return 0x820ACBDC;
		  /* 820ACBDCh */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACBDCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACBDCh case    9:*/		return 0x820ACBE0;
		  /* 820ACBE0h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACBE0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACBC0;  }
		/* 820ACBE0h case   10:*/		return 0x820ACBE4;
	}
	return 0x820ACBE4;
} // Block from 820ACBB8h-820ACBE4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACBE4);
		  /* 820ACBE4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACBE4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACBE4h case    0:*/		return 0x820ACBE8;
		  /* 820ACBE8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACBE8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACBF4;  }
		/* 820ACBE8h case    1:*/		return 0x820ACBEC;
		  /* 820ACBECh */ case    2:  		/* li R11, 1 */
		/* 820ACBECh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820ACBECh case    2:*/		return 0x820ACBF0;
	}
	return 0x820ACBF0;
} // Block from 820ACBE4h-820ACBF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ACBF0h
// Function '?Static_Error@CAssembler@D3DXShader@@SAXPAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACBF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACBF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACBF0);
		  /* 820ACBF0h */ case    0:  		/* b -92 */
		/* 820ACBF0h case    0:*/		return 0x820ACB94;
		/* 820ACBF0h case    0:*/		return 0x820ACBF4;
	}
	return 0x820ACBF4;
} // Block from 820ACBF0h-820ACBF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ACBF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACBF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACBF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACBF4);
		  /* 820ACBF4h */ case    0:  		/* lwz R10, <#[R1 + 228]> */
		/* 820ACBF4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000E4) );
		/* 820ACBF4h case    0:*/		return 0x820ACBF8;
		  /* 820ACBF8h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACBF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACBF8h case    1:*/		return 0x820ACBFC;
		  /* 820ACBFCh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACBFCh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACBFCh case    2:*/		return 0x820ACC00;
		  /* 820ACC00h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACC00h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACC00h case    3:*/		return 0x820ACC04;
		  /* 820ACC04h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACC04h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACC04h case    4:*/		return 0x820ACC08;
		  /* 820ACC08h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACC08h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACC08h case    5:*/		return 0x820ACC0C;
		  /* 820ACC0Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACC0Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACC20;  }
		/* 820ACC0Ch case    6:*/		return 0x820ACC10;
		  /* 820ACC10h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACC10h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACC10h case    7:*/		return 0x820ACC14;
		  /* 820ACC14h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACC14h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACC14h case    8:*/		return 0x820ACC18;
		  /* 820ACC18h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACC18h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACC18h case    9:*/		return 0x820ACC1C;
		  /* 820ACC1Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACC1Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACBFC;  }
		/* 820ACC1Ch case   10:*/		return 0x820ACC20;
	}
	return 0x820ACC20;
} // Block from 820ACBF4h-820ACC20h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACC20);
		  /* 820ACC20h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACC20h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACC20h case    0:*/		return 0x820ACC24;
		  /* 820ACC24h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACC24h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACC30;  }
		/* 820ACC24h case    1:*/		return 0x820ACC28;
		  /* 820ACC28h */ case    2:  		/* li R11, 2 */
		/* 820ACC28h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820ACC28h case    2:*/		return 0x820ACC2C;
		  /* 820ACC2Ch */ case    3:  		/* b -152 */
		/* 820ACC2Ch case    3:*/		return 0x820ACB94;
		/* 820ACC2Ch case    3:*/		return 0x820ACC30;
	}
	return 0x820ACC30;
} // Block from 820ACC20h-820ACC30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACC30);
		  /* 820ACC30h */ case    0:  		/* lwz R10, <#[R1 + 200]> */
		/* 820ACC30h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000C8) );
		/* 820ACC30h case    0:*/		return 0x820ACC34;
		  /* 820ACC34h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACC34h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACC34h case    1:*/		return 0x820ACC38;
		  /* 820ACC38h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACC38h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACC38h case    2:*/		return 0x820ACC3C;
		  /* 820ACC3Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACC3Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACC3Ch case    3:*/		return 0x820ACC40;
	}
	return 0x820ACC40;
} // Block from 820ACC30h-820ACC40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACC40h
// Function '?Error@CAssembler@D3DXShader@@IAAXPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACC40);
		  /* 820ACC40h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACC40h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACC40h case    0:*/		return 0x820ACC44;
		  /* 820ACC44h */ case    1:  		/* subf R9, R8, R9 */
		/* 820ACC44h case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACC44h case    1:*/		return 0x820ACC48;
		  /* 820ACC48h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACC48h case    2:*/		if ( regs.CR[0].eq ) { return 0x820ACC5C;  }
		/* 820ACC48h case    2:*/		return 0x820ACC4C;
		  /* 820ACC4Ch */ case    3:  		/* addi R11, R11, 1 */
		/* 820ACC4Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACC4Ch case    3:*/		return 0x820ACC50;
		  /* 820ACC50h */ case    4:  		/* addi R10, R10, 1 */
		/* 820ACC50h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACC50h case    4:*/		return 0x820ACC54;
		  /* 820ACC54h */ case    5:  		/* cmpwi CR6, R9, 0 */
		/* 820ACC54h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACC54h case    5:*/		return 0x820ACC58;
		  /* 820ACC58h */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACC58h case    6:*/		if ( regs.CR[6].eq ) { return 0x820ACC38;  }
		/* 820ACC58h case    6:*/		return 0x820ACC5C;
	}
	return 0x820ACC5C;
} // Block from 820ACC40h-820ACC5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ACC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACC5C);
		  /* 820ACC5Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACC5Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACC5Ch case    0:*/		return 0x820ACC60;
		  /* 820ACC60h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACC60h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACC6C;  }
		/* 820ACC60h case    1:*/		return 0x820ACC64;
		  /* 820ACC64h */ case    2:  		/* li R11, 3 */
		/* 820ACC64h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820ACC64h case    2:*/		return 0x820ACC68;
		  /* 820ACC68h */ case    3:  		/* b -212 */
		/* 820ACC68h case    3:*/		return 0x820ACB94;
		/* 820ACC68h case    3:*/		return 0x820ACC6C;
	}
	return 0x820ACC6C;
} // Block from 820ACC5Ch-820ACC6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACC6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACC6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACC6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACC6C);
		  /* 820ACC6Ch */ case    0:  		/* lwz R10, <#[R1 + 208]> */
		/* 820ACC6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000D0) );
		/* 820ACC6Ch case    0:*/		return 0x820ACC70;
		  /* 820ACC70h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACC70h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACC70h case    1:*/		return 0x820ACC74;
		  /* 820ACC74h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACC74h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACC74h case    2:*/		return 0x820ACC78;
		  /* 820ACC78h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACC78h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACC78h case    3:*/		return 0x820ACC7C;
		  /* 820ACC7Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACC7Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACC7Ch case    4:*/		return 0x820ACC80;
		  /* 820ACC80h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACC80h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACC80h case    5:*/		return 0x820ACC84;
		  /* 820ACC84h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACC84h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACC98;  }
		/* 820ACC84h case    6:*/		return 0x820ACC88;
		  /* 820ACC88h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACC88h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACC88h case    7:*/		return 0x820ACC8C;
		  /* 820ACC8Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACC8Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACC8Ch case    8:*/		return 0x820ACC90;
	}
	return 0x820ACC90;
} // Block from 820ACC6Ch-820ACC90h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820ACC90h
// Function '?DecodeOpcode@CAssembler@D3DXShader@@IAAHPAUD3DXTOKEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACC90);
		  /* 820ACC90h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 820ACC90h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACC90h case    0:*/		return 0x820ACC94;
		  /* 820ACC94h */ case    1:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACC94h case    1:*/		if ( regs.CR[6].eq ) { return 0x820ACC74;  }
		/* 820ACC94h case    1:*/		return 0x820ACC98;
	}
	return 0x820ACC98;
} // Block from 820ACC90h-820ACC98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ACC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACC98);
		  /* 820ACC98h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACC98h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACC98h case    0:*/		return 0x820ACC9C;
		  /* 820ACC9Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACC9Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACCA8;  }
		/* 820ACC9Ch case    1:*/		return 0x820ACCA0;
		  /* 820ACCA0h */ case    2:  		/* li R11, 4 */
		/* 820ACCA0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820ACCA0h case    2:*/		return 0x820ACCA4;
		  /* 820ACCA4h */ case    3:  		/* b -272 */
		/* 820ACCA4h case    3:*/		return 0x820ACB94;
		/* 820ACCA4h case    3:*/		return 0x820ACCA8;
	}
	return 0x820ACCA8;
} // Block from 820ACC98h-820ACCA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACCA8);
		  /* 820ACCA8h */ case    0:  		/* lwz R10, <#[R1 + 188]> */
		/* 820ACCA8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000BC) );
		/* 820ACCA8h case    0:*/		return 0x820ACCAC;
		  /* 820ACCACh */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACCACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACCACh case    1:*/		return 0x820ACCB0;
		  /* 820ACCB0h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACCB0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACCB0h case    2:*/		return 0x820ACCB4;
		  /* 820ACCB4h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACCB4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACCB4h case    3:*/		return 0x820ACCB8;
		  /* 820ACCB8h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACCB8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACCB8h case    4:*/		return 0x820ACCBC;
		  /* 820ACCBCh */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACCBCh case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACCBCh case    5:*/		return 0x820ACCC0;
		  /* 820ACCC0h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACCC0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACCD4;  }
		/* 820ACCC0h case    6:*/		return 0x820ACCC4;
		  /* 820ACCC4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACCC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACCC4h case    7:*/		return 0x820ACCC8;
		  /* 820ACCC8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACCC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACCC8h case    8:*/		return 0x820ACCCC;
		  /* 820ACCCCh */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACCCCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACCCCh case    9:*/		return 0x820ACCD0;
		  /* 820ACCD0h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACCD0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACCB0;  }
		/* 820ACCD0h case   10:*/		return 0x820ACCD4;
	}
	return 0x820ACCD4;
} // Block from 820ACCA8h-820ACCD4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACCD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACCD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACCD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACCD4);
		  /* 820ACCD4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACCD4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACCD4h case    0:*/		return 0x820ACCD8;
		  /* 820ACCD8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACCD8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACCE4;  }
		/* 820ACCD8h case    1:*/		return 0x820ACCDC;
		  /* 820ACCDCh */ case    2:  		/* li R11, 5 */
		/* 820ACCDCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820ACCDCh case    2:*/		return 0x820ACCE0;
		  /* 820ACCE0h */ case    3:  		/* b -332 */
		/* 820ACCE0h case    3:*/		return 0x820ACB94;
		/* 820ACCE0h case    3:*/		return 0x820ACCE4;
	}
	return 0x820ACCE4;
} // Block from 820ACCD4h-820ACCE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACCE4);
		  /* 820ACCE4h */ case    0:  		/* lwz R10, <#[R1 + 192]> */
		/* 820ACCE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000C0) );
		/* 820ACCE4h case    0:*/		return 0x820ACCE8;
		  /* 820ACCE8h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACCE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACCE8h case    1:*/		return 0x820ACCEC;
		  /* 820ACCECh */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACCECh case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACCECh case    2:*/		return 0x820ACCF0;
		  /* 820ACCF0h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACCF0h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACCF0h case    3:*/		return 0x820ACCF4;
		  /* 820ACCF4h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACCF4h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACCF4h case    4:*/		return 0x820ACCF8;
		  /* 820ACCF8h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACCF8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACCF8h case    5:*/		return 0x820ACCFC;
		  /* 820ACCFCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACCFCh case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACD10;  }
		/* 820ACCFCh case    6:*/		return 0x820ACD00;
		  /* 820ACD00h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACD00h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACD00h case    7:*/		return 0x820ACD04;
		  /* 820ACD04h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACD04h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACD04h case    8:*/		return 0x820ACD08;
		  /* 820ACD08h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACD08h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACD08h case    9:*/		return 0x820ACD0C;
		  /* 820ACD0Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACD0Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACCEC;  }
		/* 820ACD0Ch case   10:*/		return 0x820ACD10;
	}
	return 0x820ACD10;
} // Block from 820ACCE4h-820ACD10h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACD10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACD10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACD10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACD10);
		  /* 820ACD10h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACD10h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACD10h case    0:*/		return 0x820ACD14;
		  /* 820ACD14h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACD14h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACD20;  }
		/* 820ACD14h case    1:*/		return 0x820ACD18;
		  /* 820ACD18h */ case    2:  		/* li R11, 6 */
		/* 820ACD18h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820ACD18h case    2:*/		return 0x820ACD1C;
		  /* 820ACD1Ch */ case    3:  		/* b -392 */
		/* 820ACD1Ch case    3:*/		return 0x820ACB94;
		/* 820ACD1Ch case    3:*/		return 0x820ACD20;
	}
	return 0x820ACD20;
} // Block from 820ACD10h-820ACD20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACD20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACD20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACD20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACD20);
		  /* 820ACD20h */ case    0:  		/* lwz R10, <#[R1 + 204]> */
		/* 820ACD20h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000CC) );
		/* 820ACD20h case    0:*/		return 0x820ACD24;
		  /* 820ACD24h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACD24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACD24h case    1:*/		return 0x820ACD28;
		  /* 820ACD28h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACD28h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACD28h case    2:*/		return 0x820ACD2C;
		  /* 820ACD2Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACD2Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACD2Ch case    3:*/		return 0x820ACD30;
		  /* 820ACD30h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACD30h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACD30h case    4:*/		return 0x820ACD34;
		  /* 820ACD34h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACD34h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACD34h case    5:*/		return 0x820ACD38;
		  /* 820ACD38h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACD38h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACD4C;  }
		/* 820ACD38h case    6:*/		return 0x820ACD3C;
		  /* 820ACD3Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACD3Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACD3Ch case    7:*/		return 0x820ACD40;
		  /* 820ACD40h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACD40h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACD40h case    8:*/		return 0x820ACD44;
		  /* 820ACD44h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACD44h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACD44h case    9:*/		return 0x820ACD48;
		  /* 820ACD48h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACD48h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACD28;  }
		/* 820ACD48h case   10:*/		return 0x820ACD4C;
	}
	return 0x820ACD4C;
} // Block from 820ACD20h-820ACD4Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACD4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACD4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACD4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACD4C);
		  /* 820ACD4Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACD4Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACD4Ch case    0:*/		return 0x820ACD50;
		  /* 820ACD50h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACD50h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACD5C;  }
		/* 820ACD50h case    1:*/		return 0x820ACD54;
		  /* 820ACD54h */ case    2:  		/* li R11, 7 */
		/* 820ACD54h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820ACD54h case    2:*/		return 0x820ACD58;
		  /* 820ACD58h */ case    3:  		/* b -452 */
		/* 820ACD58h case    3:*/		return 0x820ACB94;
		/* 820ACD58h case    3:*/		return 0x820ACD5C;
	}
	return 0x820ACD5C;
} // Block from 820ACD4Ch-820ACD5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACD5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACD5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACD5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACD5C);
		  /* 820ACD5Ch */ case    0:  		/* lwz R10, <#[R1 + 216]> */
		/* 820ACD5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000D8) );
		/* 820ACD5Ch case    0:*/		return 0x820ACD60;
		  /* 820ACD60h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACD60h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACD60h case    1:*/		return 0x820ACD64;
		  /* 820ACD64h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACD64h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACD64h case    2:*/		return 0x820ACD68;
		  /* 820ACD68h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACD68h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACD68h case    3:*/		return 0x820ACD6C;
		  /* 820ACD6Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACD6Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACD6Ch case    4:*/		return 0x820ACD70;
		  /* 820ACD70h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACD70h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACD70h case    5:*/		return 0x820ACD74;
		  /* 820ACD74h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACD74h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACD88;  }
		/* 820ACD74h case    6:*/		return 0x820ACD78;
		  /* 820ACD78h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACD78h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACD78h case    7:*/		return 0x820ACD7C;
		  /* 820ACD7Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACD7Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACD7Ch case    8:*/		return 0x820ACD80;
		  /* 820ACD80h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACD80h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACD80h case    9:*/		return 0x820ACD84;
		  /* 820ACD84h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACD84h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACD64;  }
		/* 820ACD84h case   10:*/		return 0x820ACD88;
	}
	return 0x820ACD88;
} // Block from 820ACD5Ch-820ACD88h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACD88);
		  /* 820ACD88h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACD88h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACD88h case    0:*/		return 0x820ACD8C;
		  /* 820ACD8Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACD8Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACD98;  }
		/* 820ACD8Ch case    1:*/		return 0x820ACD90;
		  /* 820ACD90h */ case    2:  		/* li R11, 8 */
		/* 820ACD90h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820ACD90h case    2:*/		return 0x820ACD94;
		  /* 820ACD94h */ case    3:  		/* b -512 */
		/* 820ACD94h case    3:*/		return 0x820ACB94;
		/* 820ACD94h case    3:*/		return 0x820ACD98;
	}
	return 0x820ACD98;
} // Block from 820ACD88h-820ACD98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACD98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACD98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACD98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACD98);
		  /* 820ACD98h */ case    0:  		/* lwz R10, <#[R1 + 184]> */
		/* 820ACD98h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 820ACD98h case    0:*/		return 0x820ACD9C;
		  /* 820ACD9Ch */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACD9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACD9Ch case    1:*/		return 0x820ACDA0;
		  /* 820ACDA0h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACDA0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACDA0h case    2:*/		return 0x820ACDA4;
		  /* 820ACDA4h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACDA4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACDA4h case    3:*/		return 0x820ACDA8;
		  /* 820ACDA8h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACDA8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACDA8h case    4:*/		return 0x820ACDAC;
		  /* 820ACDACh */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACDACh case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACDACh case    5:*/		return 0x820ACDB0;
		  /* 820ACDB0h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACDB0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACDC4;  }
		/* 820ACDB0h case    6:*/		return 0x820ACDB4;
		  /* 820ACDB4h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACDB4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACDB4h case    7:*/		return 0x820ACDB8;
		  /* 820ACDB8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACDB8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACDB8h case    8:*/		return 0x820ACDBC;
		  /* 820ACDBCh */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACDBCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACDBCh case    9:*/		return 0x820ACDC0;
		  /* 820ACDC0h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACDC0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACDA0;  }
		/* 820ACDC0h case   10:*/		return 0x820ACDC4;
	}
	return 0x820ACDC4;
} // Block from 820ACD98h-820ACDC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACDC4);
		  /* 820ACDC4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACDC4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACDC4h case    0:*/		return 0x820ACDC8;
		  /* 820ACDC8h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 820ACDC8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACDDC;  }
		/* 820ACDC8h case    1:*/		return 0x820ACDCC;
		  /* 820ACDCCh */ case    2:  		/* lwz R4, <#[R1 + 212]> */
		/* 820ACDCCh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000D4) );
		/* 820ACDCCh case    2:*/		return 0x820ACDD0;
		  /* 820ACDD0h */ case    3:  		/* lwz R3, <#[R1 + 452]> */
		/* 820ACDD0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000001C4) );
		/* 820ACDD0h case    3:*/		return 0x820ACDD4;
		  /* 820ACDD4h */ case    4:  		/* bl -3004 */
		/* 820ACDD4h case    4:*/		regs.LR = 0x820ACDD8; return 0x820AC218;
		/* 820ACDD4h case    4:*/		return 0x820ACDD8;
		  /* 820ACDD8h */ case    5:  		/* b -592 */
		/* 820ACDD8h case    5:*/		return 0x820ACB88;
		/* 820ACDD8h case    5:*/		return 0x820ACDDC;
	}
	return 0x820ACDDC;
} // Block from 820ACDC4h-820ACDDCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ACDDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACDDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACDDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACDDC);
		  /* 820ACDDCh */ case    0:  		/* lwz R10, <#[R1 + 224]> */
		/* 820ACDDCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000E0) );
		/* 820ACDDCh case    0:*/		return 0x820ACDE0;
		  /* 820ACDE0h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACDE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACDE0h case    1:*/		return 0x820ACDE4;
		  /* 820ACDE4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACDE4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACDE4h case    2:*/		return 0x820ACDE8;
		  /* 820ACDE8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACDE8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACDE8h case    3:*/		return 0x820ACDEC;
		  /* 820ACDECh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACDECh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACDECh case    4:*/		return 0x820ACDF0;
		  /* 820ACDF0h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACDF0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACDF0h case    5:*/		return 0x820ACDF4;
		  /* 820ACDF4h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACDF4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACE08;  }
		/* 820ACDF4h case    6:*/		return 0x820ACDF8;
		  /* 820ACDF8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACDF8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACDF8h case    7:*/		return 0x820ACDFC;
		  /* 820ACDFCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACDFCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACDFCh case    8:*/		return 0x820ACE00;
		  /* 820ACE00h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACE00h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACE00h case    9:*/		return 0x820ACE04;
		  /* 820ACE04h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACE04h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACDE4;  }
		/* 820ACE04h case   10:*/		return 0x820ACE08;
	}
	return 0x820ACE08;
} // Block from 820ACDDCh-820ACE08h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACE08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACE08);
		  /* 820ACE08h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACE08h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACE08h case    0:*/		return 0x820ACE0C;
		  /* 820ACE0Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACE0Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACE18;  }
		/* 820ACE0Ch case    1:*/		return 0x820ACE10;
		  /* 820ACE10h */ case    2:  		/* li R11, 10 */
		/* 820ACE10h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820ACE10h case    2:*/		return 0x820ACE14;
		  /* 820ACE14h */ case    3:  		/* b -640 */
		/* 820ACE14h case    3:*/		return 0x820ACB94;
		/* 820ACE14h case    3:*/		return 0x820ACE18;
	}
	return 0x820ACE18;
} // Block from 820ACE08h-820ACE18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACE18);
		  /* 820ACE18h */ case    0:  		/* mr R10, R31 */
		/* 820ACE18h case    0:*/		regs.R10 = regs.R31;
		/* 820ACE18h case    0:*/		return 0x820ACE1C;
		  /* 820ACE1Ch */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACE1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACE1Ch case    1:*/		return 0x820ACE20;
		  /* 820ACE20h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACE20h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACE20h case    2:*/		return 0x820ACE24;
		  /* 820ACE24h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACE24h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACE24h case    3:*/		return 0x820ACE28;
		  /* 820ACE28h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACE28h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACE28h case    4:*/		return 0x820ACE2C;
		  /* 820ACE2Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACE2Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACE2Ch case    5:*/		return 0x820ACE30;
		  /* 820ACE30h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACE30h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACE44;  }
		/* 820ACE30h case    6:*/		return 0x820ACE34;
		  /* 820ACE34h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACE34h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACE34h case    7:*/		return 0x820ACE38;
		  /* 820ACE38h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACE38h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACE38h case    8:*/		return 0x820ACE3C;
		  /* 820ACE3Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACE3Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACE3Ch case    9:*/		return 0x820ACE40;
		  /* 820ACE40h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACE40h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACE20;  }
		/* 820ACE40h case   10:*/		return 0x820ACE44;
	}
	return 0x820ACE44;
} // Block from 820ACE18h-820ACE44h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACE44);
		  /* 820ACE44h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACE44h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACE44h case    0:*/		return 0x820ACE48;
		  /* 820ACE48h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACE48h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACE54;  }
		/* 820ACE48h case    1:*/		return 0x820ACE4C;
		  /* 820ACE4Ch */ case    2:  		/* li R11, 11 */
		/* 820ACE4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820ACE4Ch case    2:*/		return 0x820ACE50;
		  /* 820ACE50h */ case    3:  		/* b -700 */
		/* 820ACE50h case    3:*/		return 0x820ACB94;
		/* 820ACE50h case    3:*/		return 0x820ACE54;
	}
	return 0x820ACE54;
} // Block from 820ACE44h-820ACE54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACE54);
		  /* 820ACE54h */ case    0:  		/* lwz R10, <#[R1 + 232]> */
		/* 820ACE54h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000E8) );
		/* 820ACE54h case    0:*/		return 0x820ACE58;
		  /* 820ACE58h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACE58h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACE58h case    1:*/		return 0x820ACE5C;
		  /* 820ACE5Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACE5Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACE5Ch case    2:*/		return 0x820ACE60;
		  /* 820ACE60h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACE60h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACE60h case    3:*/		return 0x820ACE64;
		  /* 820ACE64h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACE64h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACE64h case    4:*/		return 0x820ACE68;
		  /* 820ACE68h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACE68h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACE68h case    5:*/		return 0x820ACE6C;
		  /* 820ACE6Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACE6Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACE80;  }
		/* 820ACE6Ch case    6:*/		return 0x820ACE70;
		  /* 820ACE70h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACE70h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACE70h case    7:*/		return 0x820ACE74;
		  /* 820ACE74h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACE74h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACE74h case    8:*/		return 0x820ACE78;
		  /* 820ACE78h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACE78h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACE78h case    9:*/		return 0x820ACE7C;
		  /* 820ACE7Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACE7Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACE5C;  }
		/* 820ACE7Ch case   10:*/		return 0x820ACE80;
	}
	return 0x820ACE80;
} // Block from 820ACE54h-820ACE80h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACE80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACE80);
		  /* 820ACE80h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACE80h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACE80h case    0:*/		return 0x820ACE84;
		  /* 820ACE84h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACE84h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACE90;  }
		/* 820ACE84h case    1:*/		return 0x820ACE88;
		  /* 820ACE88h */ case    2:  		/* li R11, 12 */
		/* 820ACE88h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820ACE88h case    2:*/		return 0x820ACE8C;
		  /* 820ACE8Ch */ case    3:  		/* b -760 */
		/* 820ACE8Ch case    3:*/		return 0x820ACB94;
		/* 820ACE8Ch case    3:*/		return 0x820ACE90;
	}
	return 0x820ACE90;
} // Block from 820ACE80h-820ACE90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACE90);
		  /* 820ACE90h */ case    0:  		/* lwz R10, <#[R1 + 220]> */
		/* 820ACE90h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000DC) );
		/* 820ACE90h case    0:*/		return 0x820ACE94;
		  /* 820ACE94h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACE94h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACE94h case    1:*/		return 0x820ACE98;
		  /* 820ACE98h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACE98h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACE98h case    2:*/		return 0x820ACE9C;
		  /* 820ACE9Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACE9Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACE9Ch case    3:*/		return 0x820ACEA0;
		  /* 820ACEA0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACEA0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACEA0h case    4:*/		return 0x820ACEA4;
		  /* 820ACEA4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACEA4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACEA4h case    5:*/		return 0x820ACEA8;
		  /* 820ACEA8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACEA8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACEBC;  }
		/* 820ACEA8h case    6:*/		return 0x820ACEAC;
		  /* 820ACEACh */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACEACh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACEACh case    7:*/		return 0x820ACEB0;
		  /* 820ACEB0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACEB0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACEB0h case    8:*/		return 0x820ACEB4;
		  /* 820ACEB4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACEB4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACEB4h case    9:*/		return 0x820ACEB8;
		  /* 820ACEB8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACEB8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACE98;  }
		/* 820ACEB8h case   10:*/		return 0x820ACEBC;
	}
	return 0x820ACEBC;
} // Block from 820ACE90h-820ACEBCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACEBC);
		  /* 820ACEBCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACEBCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACEBCh case    0:*/		return 0x820ACEC0;
		  /* 820ACEC0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACEC0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACECC;  }
		/* 820ACEC0h case    1:*/		return 0x820ACEC4;
		  /* 820ACEC4h */ case    2:  		/* li R11, 13 */
		/* 820ACEC4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820ACEC4h case    2:*/		return 0x820ACEC8;
		  /* 820ACEC8h */ case    3:  		/* b -820 */
		/* 820ACEC8h case    3:*/		return 0x820ACB94;
		/* 820ACEC8h case    3:*/		return 0x820ACECC;
	}
	return 0x820ACECC;
} // Block from 820ACEBCh-820ACECCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACECC);
		  /* 820ACECCh */ case    0:  		/* stb R29, <#[R28]> */
		/* 820ACECCh case    0:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R28 + 0x00000000) );
		/* 820ACECCh case    0:*/		return 0x820ACED0;
		  /* 820ACED0h */ case    1:  		/* lwz R28, <#[R1 + 132]> */
		/* 820ACED0h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000084) );
		/* 820ACED0h case    1:*/		return 0x820ACED4;
	}
	return 0x820ACED4;
} // Block from 820ACECCh-820ACED4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ACED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACED4);
		  /* 820ACED4h */ case    0:  		/* lwz R27, <#[R1 + 140]> */
		/* 820ACED4h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000008C) );
		/* 820ACED4h case    0:*/		return 0x820ACED8;
	}
	return 0x820ACED8;
} // Block from 820ACED4h-820ACED8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ACED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACED8);
		  /* 820ACED8h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 820ACED8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820ACED8h case    0:*/		return 0x820ACEDC;
		  /* 820ACEDCh */ case    1:  		/* bc 12, CR6_EQ, 1004 */
		/* 820ACEDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820AD2C8;  }
		/* 820ACEDCh case    1:*/		return 0x820ACEE0;
		  /* 820ACEE0h */ case    2:  		/* lbz R11, <#[R1 + 112]> */
		/* 820ACEE0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820ACEE0h case    2:*/		return 0x820ACEE4;
		  /* 820ACEE4h */ case    3:  		/* addi R30, R1, 112 */
		/* 820ACEE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x70);
		/* 820ACEE4h case    3:*/		return 0x820ACEE8;
		  /* 820ACEE8h */ case    4:  		/* b 28 */
		/* 820ACEE8h case    4:*/		return 0x820ACF04;
		/* 820ACEE8h case    4:*/		return 0x820ACEEC;
		  /* 820ACEECh */ case    5:  		/* lbz R11, <#[R30]> */
		/* 820ACEECh case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACEECh case    5:*/		return 0x820ACEF0;
		  /* 820ACEF0h */ case    6:  		/* extsb R3, R11 */
		/* 820ACEF0h case    6:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820ACEF0h case    6:*/		return 0x820ACEF4;
		  /* 820ACEF4h */ case    7:  		/* bl -79876 */
		/* 820ACEF4h case    7:*/		regs.LR = 0x820ACEF8; return 0x820996F0;
		/* 820ACEF4h case    7:*/		return 0x820ACEF8;
		  /* 820ACEF8h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820ACEF8h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ACEF8h case    8:*/		return 0x820ACEFC;
		  /* 820ACEFCh */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 820ACEFCh case    9:*/		if ( regs.CR[0].eq ) { return 0x820ACF0C;  }
		/* 820ACEFCh case    9:*/		return 0x820ACF00;
		  /* 820ACF00h */ case   10:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820ACF00h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820ACF00h case   10:*/		return 0x820ACF04;
	}
	return 0x820ACF04;
} // Block from 820ACED8h-820ACF04h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACF04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACF04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACF04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACF04);
		  /* 820ACF04h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 820ACF04h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ACF04h case    0:*/		return 0x820ACF08;
		  /* 820ACF08h */ case    1:  		/* bc 4, CR0_EQ, -28 */
		/* 820ACF08h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACEEC;  }
		/* 820ACF08h case    1:*/		return 0x820ACF0C;
	}
	return 0x820ACF0C;
} // Block from 820ACF04h-820ACF0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ACF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACF0C);
		  /* 820ACF0Ch */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820ACF0Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACF0Ch case    0:*/		return 0x820ACF10;
		  /* 820ACF10h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820ACF10h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ACF10h case    1:*/		return 0x820ACF14;
		  /* 820ACF14h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACF14h case    2:*/		if ( regs.CR[0].eq ) { return 0x820ACF28;  }
		/* 820ACF14h case    2:*/		return 0x820ACF18;
		  /* 820ACF18h */ case    3:  		/* mr R3, R30 */
		/* 820ACF18h case    3:*/		regs.R3 = regs.R30;
		/* 820ACF18h case    3:*/		return 0x820ACF1C;
		  /* 820ACF1Ch */ case    4:  		/* bl -107444 */
		/* 820ACF1Ch case    4:*/		regs.LR = 0x820ACF20; return 0x82092B68;
		/* 820ACF1Ch case    4:*/		return 0x820ACF20;
		  /* 820ACF20h */ case    5:  		/* mr R29, R3 */
		/* 820ACF20h case    5:*/		regs.R29 = regs.R3;
		/* 820ACF20h case    5:*/		return 0x820ACF24;
		  /* 820ACF24h */ case    6:  		/* b 8 */
		/* 820ACF24h case    6:*/		return 0x820ACF2C;
		/* 820ACF24h case    6:*/		return 0x820ACF28;
	}
	return 0x820ACF28;
} // Block from 820ACF0Ch-820ACF28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ACF28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACF28);
		  /* 820ACF28h */ case    0:  		/* mr R29, R23 */
		/* 820ACF28h case    0:*/		regs.R29 = regs.R23;
		/* 820ACF28h case    0:*/		return 0x820ACF2C;
	}
	return 0x820ACF2C;
} // Block from 820ACF28h-820ACF2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ACF2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACF2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACF2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACF2C);
		  /* 820ACF2Ch */ case    0:  		/* cmplwi CR6, R29, 15 */
		/* 820ACF2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000F);
		/* 820ACF2Ch case    0:*/		return 0x820ACF30;
		  /* 820ACF30h */ case    1:  		/* bc 12, CR6_GT, 1476 */
		/* 820ACF30h case    1:*/		if ( regs.CR[6].gt ) { return 0x820AD4F4;  }
		/* 820ACF30h case    1:*/		return 0x820ACF34;
		  /* 820ACF34h */ case    2:  		/* lbz R11, <#[R30]> */
		/* 820ACF34h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACF34h case    2:*/		return 0x820ACF38;
		  /* 820ACF38h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820ACF38h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ACF38h case    3:*/		return 0x820ACF3C;
		  /* 820ACF3Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 820ACF3Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820ACF48;  }
		/* 820ACF3Ch case    4:*/		return 0x820ACF40;
		  /* 820ACF40h */ case    5:  		/* stb R23, <#[R30]> */
		/* 820ACF40h case    5:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACF40h case    5:*/		return 0x820ACF44;
		  /* 820ACF44h */ case    6:  		/* addi R30, R30, 1 */
		/* 820ACF44h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820ACF44h case    6:*/		return 0x820ACF48;
	}
	return 0x820ACF48;
} // Block from 820ACF2Ch-820ACF48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ACF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACF48);
		  /* 820ACF48h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820ACF48h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACF48h case    0:*/		return 0x820ACF4C;
		  /* 820ACF4Ch */ case    1:  		/* b 20 */
		/* 820ACF4Ch case    1:*/		return 0x820ACF60;
		/* 820ACF4Ch case    1:*/		return 0x820ACF50;
		  /* 820ACF50h */ case    2:  		/* bl -79936 */
		/* 820ACF50h case    2:*/		regs.LR = 0x820ACF54; return 0x82099710;
		/* 820ACF50h case    2:*/		return 0x820ACF54;
		  /* 820ACF54h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820ACF54h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ACF54h case    3:*/		return 0x820ACF58;
		  /* 820ACF58h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820ACF58h case    4:*/		if ( regs.CR[0].eq ) { return 0x820ACF68;  }
		/* 820ACF58h case    4:*/		return 0x820ACF5C;
		  /* 820ACF5Ch */ case    5:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820ACF5Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820ACF5Ch case    5:*/		return 0x820ACF60;
	}
	return 0x820ACF60;
} // Block from 820ACF48h-820ACF60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820ACF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACF60);
		  /* 820ACF60h */ case    0:  		/* extsb. R3, R11 */
		/* 820ACF60h case    0:*/		cpu::op::extsb<1>(regs,&regs.R3,regs.R11);
		/* 820ACF60h case    0:*/		return 0x820ACF64;
		  /* 820ACF64h */ case    1:  		/* bc 4, CR0_EQ, -20 */
		/* 820ACF64h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACF50;  }
		/* 820ACF64h case    1:*/		return 0x820ACF68;
	}
	return 0x820ACF68;
} // Block from 820ACF60h-820ACF68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ACF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACF68);
		  /* 820ACF68h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820ACF68h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820ACF68h case    0:*/		return 0x820ACF6C;
		  /* 820ACF6Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820ACF6Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820ACF6Ch case    1:*/		return 0x820ACF70;
		  /* 820ACF70h */ case    2:  		/* bc 4, CR0_EQ, 1412 */
		/* 820ACF70h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820AD4F4;  }
		/* 820ACF70h case    2:*/		return 0x820ACF74;
		  /* 820ACF74h */ case    3:  		/* mr R10, R19 */
		/* 820ACF74h case    3:*/		regs.R10 = regs.R19;
		/* 820ACF74h case    3:*/		return 0x820ACF78;
		  /* 820ACF78h */ case    4:  		/* addi R11, R1, 112 */
		/* 820ACF78h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACF78h case    4:*/		return 0x820ACF7C;
		  /* 820ACF7Ch */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820ACF7Ch case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACF7Ch case    5:*/		return 0x820ACF80;
		  /* 820ACF80h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 820ACF80h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACF80h case    6:*/		return 0x820ACF84;
		  /* 820ACF84h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820ACF84h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACF84h case    7:*/		return 0x820ACF88;
		  /* 820ACF88h */ case    8:  		/* subf R9, R8, R9 */
		/* 820ACF88h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACF88h case    8:*/		return 0x820ACF8C;
		  /* 820ACF8Ch */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACF8Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820ACFA0;  }
		/* 820ACF8Ch case    9:*/		return 0x820ACF90;
		  /* 820ACF90h */ case   10:  		/* addi R11, R11, 1 */
		/* 820ACF90h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACF90h case   10:*/		return 0x820ACF94;
		  /* 820ACF94h */ case   11:  		/* addi R10, R10, 1 */
		/* 820ACF94h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACF94h case   11:*/		return 0x820ACF98;
		  /* 820ACF98h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820ACF98h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACF98h case   12:*/		return 0x820ACF9C;
		  /* 820ACF9Ch */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACF9Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820ACF7C;  }
		/* 820ACF9Ch case   13:*/		return 0x820ACFA0;
	}
	return 0x820ACFA0;
} // Block from 820ACF68h-820ACFA0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ACFA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACFA0);
		  /* 820ACFA0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACFA0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACFA0h case    0:*/		return 0x820ACFA4;
		  /* 820ACFA4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACFA4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACFB0;  }
		/* 820ACFA4h case    1:*/		return 0x820ACFA8;
		  /* 820ACFA8h */ case    2:  		/* mr R11, R23 */
		/* 820ACFA8h case    2:*/		regs.R11 = regs.R23;
		/* 820ACFA8h case    2:*/		return 0x820ACFAC;
		  /* 820ACFACh */ case    3:  		/* b 772 */
		/* 820ACFACh case    3:*/		return 0x820AD2B0;
		/* 820ACFACh case    3:*/		return 0x820ACFB0;
	}
	return 0x820ACFB0;
} // Block from 820ACFA0h-820ACFB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACFB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACFB0);
		  /* 820ACFB0h */ case    0:  		/* mr R10, R20 */
		/* 820ACFB0h case    0:*/		regs.R10 = regs.R20;
		/* 820ACFB0h case    0:*/		return 0x820ACFB4;
		  /* 820ACFB4h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACFB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACFB4h case    1:*/		return 0x820ACFB8;
		  /* 820ACFB8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACFB8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACFB8h case    2:*/		return 0x820ACFBC;
		  /* 820ACFBCh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACFBCh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACFBCh case    3:*/		return 0x820ACFC0;
		  /* 820ACFC0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACFC0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACFC0h case    4:*/		return 0x820ACFC4;
		  /* 820ACFC4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820ACFC4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820ACFC4h case    5:*/		return 0x820ACFC8;
		  /* 820ACFC8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820ACFC8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820ACFDC;  }
		/* 820ACFC8h case    6:*/		return 0x820ACFCC;
		  /* 820ACFCCh */ case    7:  		/* addi R11, R11, 1 */
		/* 820ACFCCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ACFCCh case    7:*/		return 0x820ACFD0;
		  /* 820ACFD0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820ACFD0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ACFD0h case    8:*/		return 0x820ACFD4;
		  /* 820ACFD4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820ACFD4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ACFD4h case    9:*/		return 0x820ACFD8;
		  /* 820ACFD8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820ACFD8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACFB8;  }
		/* 820ACFD8h case   10:*/		return 0x820ACFDC;
	}
	return 0x820ACFDC;
} // Block from 820ACFB0h-820ACFDCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820ACFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACFDC);
		  /* 820ACFDCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ACFDCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACFDCh case    0:*/		return 0x820ACFE0;
		  /* 820ACFE0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820ACFE0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ACFEC;  }
		/* 820ACFE0h case    1:*/		return 0x820ACFE4;
		  /* 820ACFE4h */ case    2:  		/* li R11, 1 */
		/* 820ACFE4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820ACFE4h case    2:*/		return 0x820ACFE8;
		  /* 820ACFE8h */ case    3:  		/* b 712 */
		/* 820ACFE8h case    3:*/		return 0x820AD2B0;
		/* 820ACFE8h case    3:*/		return 0x820ACFEC;
	}
	return 0x820ACFEC;
} // Block from 820ACFDCh-820ACFECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ACFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ACFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ACFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ACFEC);
		  /* 820ACFECh */ case    0:  		/* lwz R10, <#[R1 + 228]> */
		/* 820ACFECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000E4) );
		/* 820ACFECh case    0:*/		return 0x820ACFF0;
		  /* 820ACFF0h */ case    1:  		/* addi R11, R1, 112 */
		/* 820ACFF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820ACFF0h case    1:*/		return 0x820ACFF4;
		  /* 820ACFF4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820ACFF4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ACFF4h case    2:*/		return 0x820ACFF8;
		  /* 820ACFF8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820ACFF8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820ACFF8h case    3:*/		return 0x820ACFFC;
		  /* 820ACFFCh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820ACFFCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ACFFCh case    4:*/		return 0x820AD000;
		  /* 820AD000h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD000h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD000h case    5:*/		return 0x820AD004;
		  /* 820AD004h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD004h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD018;  }
		/* 820AD004h case    6:*/		return 0x820AD008;
		  /* 820AD008h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD008h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD008h case    7:*/		return 0x820AD00C;
		  /* 820AD00Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD00Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD00Ch case    8:*/		return 0x820AD010;
		  /* 820AD010h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD010h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD010h case    9:*/		return 0x820AD014;
		  /* 820AD014h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD014h case   10:*/		if ( regs.CR[6].eq ) { return 0x820ACFF4;  }
		/* 820AD014h case   10:*/		return 0x820AD018;
	}
	return 0x820AD018;
} // Block from 820ACFECh-820AD018h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD018);
		  /* 820AD018h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD018h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD018h case    0:*/		return 0x820AD01C;
		  /* 820AD01Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD01Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD028;  }
		/* 820AD01Ch case    1:*/		return 0x820AD020;
		  /* 820AD020h */ case    2:  		/* li R11, 2 */
		/* 820AD020h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820AD020h case    2:*/		return 0x820AD024;
		  /* 820AD024h */ case    3:  		/* b 652 */
		/* 820AD024h case    3:*/		return 0x820AD2B0;
		/* 820AD024h case    3:*/		return 0x820AD028;
	}
	return 0x820AD028;
} // Block from 820AD018h-820AD028h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD028);
		  /* 820AD028h */ case    0:  		/* lwz R10, <#[R1 + 200]> */
		/* 820AD028h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000C8) );
		/* 820AD028h case    0:*/		return 0x820AD02C;
		  /* 820AD02Ch */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD02Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD02Ch case    1:*/		return 0x820AD030;
		  /* 820AD030h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD030h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD030h case    2:*/		return 0x820AD034;
		  /* 820AD034h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD034h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD034h case    3:*/		return 0x820AD038;
		  /* 820AD038h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD038h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD038h case    4:*/		return 0x820AD03C;
		  /* 820AD03Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD03Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD03Ch case    5:*/		return 0x820AD040;
		  /* 820AD040h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD040h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD054;  }
		/* 820AD040h case    6:*/		return 0x820AD044;
		  /* 820AD044h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD044h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD044h case    7:*/		return 0x820AD048;
		  /* 820AD048h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD048h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD048h case    8:*/		return 0x820AD04C;
		  /* 820AD04Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD04Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD04Ch case    9:*/		return 0x820AD050;
		  /* 820AD050h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD050h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD030;  }
		/* 820AD050h case   10:*/		return 0x820AD054;
	}
	return 0x820AD054;
} // Block from 820AD028h-820AD054h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD054);
		  /* 820AD054h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD054h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD054h case    0:*/		return 0x820AD058;
		  /* 820AD058h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD058h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD064;  }
		/* 820AD058h case    1:*/		return 0x820AD05C;
		  /* 820AD05Ch */ case    2:  		/* li R11, 3 */
		/* 820AD05Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820AD05Ch case    2:*/		return 0x820AD060;
		  /* 820AD060h */ case    3:  		/* b 592 */
		/* 820AD060h case    3:*/		return 0x820AD2B0;
		/* 820AD060h case    3:*/		return 0x820AD064;
	}
	return 0x820AD064;
} // Block from 820AD054h-820AD064h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD064);
		  /* 820AD064h */ case    0:  		/* lwz R10, <#[R1 + 208]> */
		/* 820AD064h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000D0) );
		/* 820AD064h case    0:*/		return 0x820AD068;
		  /* 820AD068h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD068h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD068h case    1:*/		return 0x820AD06C;
		  /* 820AD06Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD06Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD06Ch case    2:*/		return 0x820AD070;
		  /* 820AD070h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD070h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD070h case    3:*/		return 0x820AD074;
		  /* 820AD074h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD074h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD074h case    4:*/		return 0x820AD078;
		  /* 820AD078h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD078h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD078h case    5:*/		return 0x820AD07C;
		  /* 820AD07Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD07Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD090;  }
		/* 820AD07Ch case    6:*/		return 0x820AD080;
		  /* 820AD080h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD080h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD080h case    7:*/		return 0x820AD084;
		  /* 820AD084h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD084h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD084h case    8:*/		return 0x820AD088;
		  /* 820AD088h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD088h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD088h case    9:*/		return 0x820AD08C;
		  /* 820AD08Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD08Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD06C;  }
		/* 820AD08Ch case   10:*/		return 0x820AD090;
	}
	return 0x820AD090;
} // Block from 820AD064h-820AD090h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD090);
		  /* 820AD090h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD090h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD090h case    0:*/		return 0x820AD094;
		  /* 820AD094h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD094h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD0A0;  }
		/* 820AD094h case    1:*/		return 0x820AD098;
		  /* 820AD098h */ case    2:  		/* li R11, 4 */
		/* 820AD098h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820AD098h case    2:*/		return 0x820AD09C;
		  /* 820AD09Ch */ case    3:  		/* b 532 */
		/* 820AD09Ch case    3:*/		return 0x820AD2B0;
		/* 820AD09Ch case    3:*/		return 0x820AD0A0;
	}
	return 0x820AD0A0;
} // Block from 820AD090h-820AD0A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD0A0);
		  /* 820AD0A0h */ case    0:  		/* lwz R10, <#[R1 + 188]> */
		/* 820AD0A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000BC) );
		/* 820AD0A0h case    0:*/		return 0x820AD0A4;
		  /* 820AD0A4h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD0A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD0A4h case    1:*/		return 0x820AD0A8;
		  /* 820AD0A8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD0A8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD0A8h case    2:*/		return 0x820AD0AC;
		  /* 820AD0ACh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD0ACh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD0ACh case    3:*/		return 0x820AD0B0;
		  /* 820AD0B0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD0B0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD0B0h case    4:*/		return 0x820AD0B4;
		  /* 820AD0B4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD0B4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD0B4h case    5:*/		return 0x820AD0B8;
		  /* 820AD0B8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD0B8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD0CC;  }
		/* 820AD0B8h case    6:*/		return 0x820AD0BC;
		  /* 820AD0BCh */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD0BCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD0BCh case    7:*/		return 0x820AD0C0;
		  /* 820AD0C0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD0C0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD0C0h case    8:*/		return 0x820AD0C4;
		  /* 820AD0C4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD0C4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD0C4h case    9:*/		return 0x820AD0C8;
		  /* 820AD0C8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD0C8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD0A8;  }
		/* 820AD0C8h case   10:*/		return 0x820AD0CC;
	}
	return 0x820AD0CC;
} // Block from 820AD0A0h-820AD0CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD0CC);
		  /* 820AD0CCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD0CCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD0CCh case    0:*/		return 0x820AD0D0;
		  /* 820AD0D0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD0D0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD0DC;  }
		/* 820AD0D0h case    1:*/		return 0x820AD0D4;
		  /* 820AD0D4h */ case    2:  		/* li R11, 5 */
		/* 820AD0D4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820AD0D4h case    2:*/		return 0x820AD0D8;
		  /* 820AD0D8h */ case    3:  		/* b 472 */
		/* 820AD0D8h case    3:*/		return 0x820AD2B0;
		/* 820AD0D8h case    3:*/		return 0x820AD0DC;
	}
	return 0x820AD0DC;
} // Block from 820AD0CCh-820AD0DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD0DC);
		  /* 820AD0DCh */ case    0:  		/* lwz R10, <#[R1 + 192]> */
		/* 820AD0DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000C0) );
		/* 820AD0DCh case    0:*/		return 0x820AD0E0;
		  /* 820AD0E0h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD0E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD0E0h case    1:*/		return 0x820AD0E4;
		  /* 820AD0E4h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD0E4h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD0E4h case    2:*/		return 0x820AD0E8;
		  /* 820AD0E8h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD0E8h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD0E8h case    3:*/		return 0x820AD0EC;
		  /* 820AD0ECh */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD0ECh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD0ECh case    4:*/		return 0x820AD0F0;
		  /* 820AD0F0h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD0F0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD0F0h case    5:*/		return 0x820AD0F4;
		  /* 820AD0F4h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD0F4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD108;  }
		/* 820AD0F4h case    6:*/		return 0x820AD0F8;
		  /* 820AD0F8h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD0F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD0F8h case    7:*/		return 0x820AD0FC;
		  /* 820AD0FCh */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD0FCh case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD0FCh case    8:*/		return 0x820AD100;
		  /* 820AD100h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD100h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD100h case    9:*/		return 0x820AD104;
		  /* 820AD104h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD104h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD0E4;  }
		/* 820AD104h case   10:*/		return 0x820AD108;
	}
	return 0x820AD108;
} // Block from 820AD0DCh-820AD108h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD108);
		  /* 820AD108h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD108h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD108h case    0:*/		return 0x820AD10C;
		  /* 820AD10Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD10Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD118;  }
		/* 820AD10Ch case    1:*/		return 0x820AD110;
		  /* 820AD110h */ case    2:  		/* li R11, 6 */
		/* 820AD110h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820AD110h case    2:*/		return 0x820AD114;
		  /* 820AD114h */ case    3:  		/* b 412 */
		/* 820AD114h case    3:*/		return 0x820AD2B0;
		/* 820AD114h case    3:*/		return 0x820AD118;
	}
	return 0x820AD118;
} // Block from 820AD108h-820AD118h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD118);
		  /* 820AD118h */ case    0:  		/* lwz R10, <#[R1 + 204]> */
		/* 820AD118h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000CC) );
		/* 820AD118h case    0:*/		return 0x820AD11C;
		  /* 820AD11Ch */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD11Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD11Ch case    1:*/		return 0x820AD120;
		  /* 820AD120h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD120h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD120h case    2:*/		return 0x820AD124;
		  /* 820AD124h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD124h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD124h case    3:*/		return 0x820AD128;
		  /* 820AD128h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD128h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD128h case    4:*/		return 0x820AD12C;
		  /* 820AD12Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD12Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD12Ch case    5:*/		return 0x820AD130;
		  /* 820AD130h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD130h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD144;  }
		/* 820AD130h case    6:*/		return 0x820AD134;
		  /* 820AD134h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD134h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD134h case    7:*/		return 0x820AD138;
		  /* 820AD138h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD138h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD138h case    8:*/		return 0x820AD13C;
		  /* 820AD13Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD13Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD13Ch case    9:*/		return 0x820AD140;
		  /* 820AD140h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD140h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD120;  }
		/* 820AD140h case   10:*/		return 0x820AD144;
	}
	return 0x820AD144;
} // Block from 820AD118h-820AD144h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD144);
		  /* 820AD144h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD144h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD144h case    0:*/		return 0x820AD148;
		  /* 820AD148h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD148h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD154;  }
		/* 820AD148h case    1:*/		return 0x820AD14C;
		  /* 820AD14Ch */ case    2:  		/* li R11, 7 */
		/* 820AD14Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820AD14Ch case    2:*/		return 0x820AD150;
		  /* 820AD150h */ case    3:  		/* b 352 */
		/* 820AD150h case    3:*/		return 0x820AD2B0;
		/* 820AD150h case    3:*/		return 0x820AD154;
	}
	return 0x820AD154;
} // Block from 820AD144h-820AD154h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD154);
		  /* 820AD154h */ case    0:  		/* lwz R10, <#[R1 + 216]> */
		/* 820AD154h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000D8) );
		/* 820AD154h case    0:*/		return 0x820AD158;
		  /* 820AD158h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD158h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD158h case    1:*/		return 0x820AD15C;
		  /* 820AD15Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD15Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD15Ch case    2:*/		return 0x820AD160;
		  /* 820AD160h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD160h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD160h case    3:*/		return 0x820AD164;
		  /* 820AD164h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD164h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD164h case    4:*/		return 0x820AD168;
		  /* 820AD168h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD168h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD168h case    5:*/		return 0x820AD16C;
		  /* 820AD16Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD16Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD180;  }
		/* 820AD16Ch case    6:*/		return 0x820AD170;
		  /* 820AD170h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD170h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD170h case    7:*/		return 0x820AD174;
		  /* 820AD174h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD174h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD174h case    8:*/		return 0x820AD178;
		  /* 820AD178h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD178h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD178h case    9:*/		return 0x820AD17C;
		  /* 820AD17Ch */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD17Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD15C;  }
		/* 820AD17Ch case   10:*/		return 0x820AD180;
	}
	return 0x820AD180;
} // Block from 820AD154h-820AD180h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD180);
		  /* 820AD180h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD180h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD180h case    0:*/		return 0x820AD184;
		  /* 820AD184h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD184h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD190;  }
		/* 820AD184h case    1:*/		return 0x820AD188;
		  /* 820AD188h */ case    2:  		/* li R11, 8 */
		/* 820AD188h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820AD188h case    2:*/		return 0x820AD18C;
		  /* 820AD18Ch */ case    3:  		/* b 292 */
		/* 820AD18Ch case    3:*/		return 0x820AD2B0;
		/* 820AD18Ch case    3:*/		return 0x820AD190;
	}
	return 0x820AD190;
} // Block from 820AD180h-820AD190h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD190);
		  /* 820AD190h */ case    0:  		/* lwz R10, <#[R1 + 184]> */
		/* 820AD190h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 820AD190h case    0:*/		return 0x820AD194;
		  /* 820AD194h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD194h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD194h case    1:*/		return 0x820AD198;
		  /* 820AD198h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD198h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD198h case    2:*/		return 0x820AD19C;
		  /* 820AD19Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD19Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD19Ch case    3:*/		return 0x820AD1A0;
		  /* 820AD1A0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD1A0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD1A0h case    4:*/		return 0x820AD1A4;
		  /* 820AD1A4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD1A4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD1A4h case    5:*/		return 0x820AD1A8;
		  /* 820AD1A8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD1A8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD1BC;  }
		/* 820AD1A8h case    6:*/		return 0x820AD1AC;
		  /* 820AD1ACh */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD1ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD1ACh case    7:*/		return 0x820AD1B0;
		  /* 820AD1B0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD1B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD1B0h case    8:*/		return 0x820AD1B4;
		  /* 820AD1B4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD1B4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD1B4h case    9:*/		return 0x820AD1B8;
		  /* 820AD1B8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD1B8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD198;  }
		/* 820AD1B8h case   10:*/		return 0x820AD1BC;
	}
	return 0x820AD1BC;
} // Block from 820AD190h-820AD1BCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD1BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD1BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD1BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD1BC);
		  /* 820AD1BCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD1BCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD1BCh case    0:*/		return 0x820AD1C0;
		  /* 820AD1C0h */ case    1:  		/* bc 12, CR0_EQ, 844 */
		/* 820AD1C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820AD50C;  }
		/* 820AD1C0h case    1:*/		return 0x820AD1C4;
		  /* 820AD1C4h */ case    2:  		/* lwz R10, <#[R1 + 224]> */
		/* 820AD1C4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000E0) );
		/* 820AD1C4h case    2:*/		return 0x820AD1C8;
		  /* 820AD1C8h */ case    3:  		/* addi R11, R1, 112 */
		/* 820AD1C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD1C8h case    3:*/		return 0x820AD1CC;
		  /* 820AD1CCh */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820AD1CCh case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD1CCh case    4:*/		return 0x820AD1D0;
		  /* 820AD1D0h */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820AD1D0h case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD1D0h case    5:*/		return 0x820AD1D4;
		  /* 820AD1D4h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820AD1D4h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD1D4h case    6:*/		return 0x820AD1D8;
		  /* 820AD1D8h */ case    7:  		/* subf R9, R8, R9 */
		/* 820AD1D8h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD1D8h case    7:*/		return 0x820AD1DC;
		  /* 820AD1DCh */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD1DCh case    8:*/		if ( regs.CR[0].eq ) { return 0x820AD1F0;  }
		/* 820AD1DCh case    8:*/		return 0x820AD1E0;
		  /* 820AD1E0h */ case    9:  		/* addi R11, R11, 1 */
		/* 820AD1E0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD1E0h case    9:*/		return 0x820AD1E4;
		  /* 820AD1E4h */ case   10:  		/* addi R10, R10, 1 */
		/* 820AD1E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD1E4h case   10:*/		return 0x820AD1E8;
		  /* 820AD1E8h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820AD1E8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD1E8h case   11:*/		return 0x820AD1EC;
		  /* 820AD1ECh */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD1ECh case   12:*/		if ( regs.CR[6].eq ) { return 0x820AD1CC;  }
		/* 820AD1ECh case   12:*/		return 0x820AD1F0;
	}
	return 0x820AD1F0;
} // Block from 820AD1BCh-820AD1F0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AD1F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD1F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD1F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD1F0);
		  /* 820AD1F0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD1F0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD1F0h case    0:*/		return 0x820AD1F4;
		  /* 820AD1F4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD1F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD200;  }
		/* 820AD1F4h case    1:*/		return 0x820AD1F8;
		  /* 820AD1F8h */ case    2:  		/* li R11, 10 */
		/* 820AD1F8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820AD1F8h case    2:*/		return 0x820AD1FC;
		  /* 820AD1FCh */ case    3:  		/* b 180 */
		/* 820AD1FCh case    3:*/		return 0x820AD2B0;
		/* 820AD1FCh case    3:*/		return 0x820AD200;
	}
	return 0x820AD200;
} // Block from 820AD1F0h-820AD200h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD200);
		  /* 820AD200h */ case    0:  		/* mr R10, R31 */
		/* 820AD200h case    0:*/		regs.R10 = regs.R31;
		/* 820AD200h case    0:*/		return 0x820AD204;
		  /* 820AD204h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD204h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD204h case    1:*/		return 0x820AD208;
		  /* 820AD208h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD208h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD208h case    2:*/		return 0x820AD20C;
		  /* 820AD20Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD20Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD20Ch case    3:*/		return 0x820AD210;
		  /* 820AD210h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD210h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD210h case    4:*/		return 0x820AD214;
		  /* 820AD214h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD214h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD214h case    5:*/		return 0x820AD218;
		  /* 820AD218h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD218h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD22C;  }
		/* 820AD218h case    6:*/		return 0x820AD21C;
		  /* 820AD21Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD21Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD21Ch case    7:*/		return 0x820AD220;
		  /* 820AD220h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD220h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD220h case    8:*/		return 0x820AD224;
		  /* 820AD224h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD224h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD224h case    9:*/		return 0x820AD228;
		  /* 820AD228h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD228h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD208;  }
		/* 820AD228h case   10:*/		return 0x820AD22C;
	}
	return 0x820AD22C;
} // Block from 820AD200h-820AD22Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD22C);
		  /* 820AD22Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD22Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD22Ch case    0:*/		return 0x820AD230;
		  /* 820AD230h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD230h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD23C;  }
		/* 820AD230h case    1:*/		return 0x820AD234;
		  /* 820AD234h */ case    2:  		/* li R11, 11 */
		/* 820AD234h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820AD234h case    2:*/		return 0x820AD238;
		  /* 820AD238h */ case    3:  		/* b 120 */
		/* 820AD238h case    3:*/		return 0x820AD2B0;
		/* 820AD238h case    3:*/		return 0x820AD23C;
	}
	return 0x820AD23C;
} // Block from 820AD22Ch-820AD23Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD23Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD23C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD23C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD23C);
		  /* 820AD23Ch */ case    0:  		/* lwz R10, <#[R1 + 232]> */
		/* 820AD23Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000E8) );
		/* 820AD23Ch case    0:*/		return 0x820AD240;
		  /* 820AD240h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD240h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD240h case    1:*/		return 0x820AD244;
		  /* 820AD244h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD244h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD244h case    2:*/		return 0x820AD248;
		  /* 820AD248h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD248h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD248h case    3:*/		return 0x820AD24C;
		  /* 820AD24Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD24Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD24Ch case    4:*/		return 0x820AD250;
		  /* 820AD250h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD250h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD250h case    5:*/		return 0x820AD254;
		  /* 820AD254h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD254h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD268;  }
		/* 820AD254h case    6:*/		return 0x820AD258;
		  /* 820AD258h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD258h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD258h case    7:*/		return 0x820AD25C;
		  /* 820AD25Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD25Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD25Ch case    8:*/		return 0x820AD260;
		  /* 820AD260h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD260h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD260h case    9:*/		return 0x820AD264;
		  /* 820AD264h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD264h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD244;  }
		/* 820AD264h case   10:*/		return 0x820AD268;
	}
	return 0x820AD268;
} // Block from 820AD23Ch-820AD268h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD268);
		  /* 820AD268h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD268h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD268h case    0:*/		return 0x820AD26C;
		  /* 820AD26Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD26Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD278;  }
		/* 820AD26Ch case    1:*/		return 0x820AD270;
		  /* 820AD270h */ case    2:  		/* li R11, 12 */
		/* 820AD270h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820AD270h case    2:*/		return 0x820AD274;
		  /* 820AD274h */ case    3:  		/* b 60 */
		/* 820AD274h case    3:*/		return 0x820AD2B0;
		/* 820AD274h case    3:*/		return 0x820AD278;
	}
	return 0x820AD278;
} // Block from 820AD268h-820AD278h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD278);
		  /* 820AD278h */ case    0:  		/* lwz R10, <#[R1 + 220]> */
		/* 820AD278h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000DC) );
		/* 820AD278h case    0:*/		return 0x820AD27C;
		  /* 820AD27Ch */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD27Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD27Ch case    1:*/		return 0x820AD280;
		  /* 820AD280h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD280h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD280h case    2:*/		return 0x820AD284;
		  /* 820AD284h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD284h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD284h case    3:*/		return 0x820AD288;
		  /* 820AD288h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD288h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD288h case    4:*/		return 0x820AD28C;
		  /* 820AD28Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD28Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD28Ch case    5:*/		return 0x820AD290;
		  /* 820AD290h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD290h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD2A4;  }
		/* 820AD290h case    6:*/		return 0x820AD294;
		  /* 820AD294h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD294h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD294h case    7:*/		return 0x820AD298;
		  /* 820AD298h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD298h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD298h case    8:*/		return 0x820AD29C;
		  /* 820AD29Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD29Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD29Ch case    9:*/		return 0x820AD2A0;
		  /* 820AD2A0h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD2A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD280;  }
		/* 820AD2A0h case   10:*/		return 0x820AD2A4;
	}
	return 0x820AD2A4;
} // Block from 820AD278h-820AD2A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD2A4);
		  /* 820AD2A4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD2A4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD2A4h case    0:*/		return 0x820AD2A8;
		  /* 820AD2A8h */ case    1:  		/* bc 4, CR0_EQ, 588 */
		/* 820AD2A8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD4F4;  }
		/* 820AD2A8h case    1:*/		return 0x820AD2AC;
		  /* 820AD2ACh */ case    2:  		/* li R11, 13 */
		/* 820AD2ACh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820AD2ACh case    2:*/		return 0x820AD2B0;
	}
	return 0x820AD2B0;
} // Block from 820AD2A4h-820AD2B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AD2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD2B0);
		  /* 820AD2B0h */ case    0:  		/* rlwinm R10, R29, 16, 12, 15 */
		/* 820AD2B0h case    0:*/		cpu::op::rlwinm<0,16,12,15>(regs,&regs.R10,regs.R29);
		/* 820AD2B0h case    0:*/		return 0x820AD2B4;
		  /* 820AD2B4h */ case    1:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 820AD2B4h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 820AD2B4h case    1:*/		return 0x820AD2B8;
		  /* 820AD2B8h */ case    2:  		/* mr R24, R23 */
		/* 820AD2B8h case    2:*/		regs.R24 = regs.R23;
		/* 820AD2B8h case    2:*/		return 0x820AD2BC;
		  /* 820AD2BCh */ case    3:  		/* or R26, R10, R11 */
		/* 820AD2BCh case    3:*/		cpu::op::or<0>(regs,&regs.R26,regs.R10,regs.R11);
		/* 820AD2BCh case    3:*/		return 0x820AD2C0;
		  /* 820AD2C0h */ case    4:  		/* mr R25, R23 */
		/* 820AD2C0h case    4:*/		regs.R25 = regs.R23;
		/* 820AD2C0h case    4:*/		return 0x820AD2C4;
		  /* 820AD2C4h */ case    5:  		/* b 376 */
		/* 820AD2C4h case    5:*/		return 0x820AD43C;
		/* 820AD2C4h case    5:*/		return 0x820AD2C8;
	}
	return 0x820AD2C8;
} // Block from 820AD2B0h-820AD2C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AD2C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD2C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD2C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD2C8);
		  /* 820AD2C8h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820AD2C8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820AD2C8h case    0:*/		return 0x820AD2CC;
		  /* 820AD2CCh */ case    1:  		/* bc 12, CR6_EQ, 552 */
		/* 820AD2CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820AD4F4;  }
		/* 820AD2CCh case    1:*/		return 0x820AD2D0;
		  /* 820AD2D0h */ case    2:  		/* lwz R10, <#[R1 + 244]> */
		/* 820AD2D0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000F4) );
		/* 820AD2D0h case    2:*/		return 0x820AD2D4;
		  /* 820AD2D4h */ case    3:  		/* addi R11, R1, 112 */
		/* 820AD2D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD2D4h case    3:*/		return 0x820AD2D8;
		  /* 820AD2D8h */ case    4:  		/* lbz R9, <#[R11]> */
		/* 820AD2D8h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD2D8h case    4:*/		return 0x820AD2DC;
		  /* 820AD2DCh */ case    5:  		/* lbz R8, <#[R10]> */
		/* 820AD2DCh case    5:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD2DCh case    5:*/		return 0x820AD2E0;
		  /* 820AD2E0h */ case    6:  		/* cmpwi CR0, R9, 0 */
		/* 820AD2E0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD2E0h case    6:*/		return 0x820AD2E4;
		  /* 820AD2E4h */ case    7:  		/* subf R9, R8, R9 */
		/* 820AD2E4h case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD2E4h case    7:*/		return 0x820AD2E8;
		  /* 820AD2E8h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD2E8h case    8:*/		if ( regs.CR[0].eq ) { return 0x820AD2FC;  }
		/* 820AD2E8h case    8:*/		return 0x820AD2EC;
		  /* 820AD2ECh */ case    9:  		/* addi R11, R11, 1 */
		/* 820AD2ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD2ECh case    9:*/		return 0x820AD2F0;
		  /* 820AD2F0h */ case   10:  		/* addi R10, R10, 1 */
		/* 820AD2F0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD2F0h case   10:*/		return 0x820AD2F4;
		  /* 820AD2F4h */ case   11:  		/* cmpwi CR6, R9, 0 */
		/* 820AD2F4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD2F4h case   11:*/		return 0x820AD2F8;
		  /* 820AD2F8h */ case   12:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD2F8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820AD2D8;  }
		/* 820AD2F8h case   12:*/		return 0x820AD2FC;
	}
	return 0x820AD2FC;
} // Block from 820AD2C8h-820AD2FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AD2FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD2FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD2FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD2FC);
		  /* 820AD2FCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD2FCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD2FCh case    0:*/		return 0x820AD300;
		  /* 820AD300h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD300h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD30C;  }
		/* 820AD300h case    1:*/		return 0x820AD304;
		  /* 820AD304h */ case    2:  		/* li R26, 1 */
		/* 820AD304h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 820AD304h case    2:*/		return 0x820AD308;
		  /* 820AD308h */ case    3:  		/* b 300 */
		/* 820AD308h case    3:*/		return 0x820AD434;
		/* 820AD308h case    3:*/		return 0x820AD30C;
	}
	return 0x820AD30C;
} // Block from 820AD2FCh-820AD30Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD30C);
		  /* 820AD30Ch */ case    0:  		/* lwz R10, <#[R1 + 260]> */
		/* 820AD30Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000104) );
		/* 820AD30Ch case    0:*/		return 0x820AD310;
		  /* 820AD310h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD310h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD310h case    1:*/		return 0x820AD314;
		  /* 820AD314h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD314h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD314h case    2:*/		return 0x820AD318;
		  /* 820AD318h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD318h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD318h case    3:*/		return 0x820AD31C;
		  /* 820AD31Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD31Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD31Ch case    4:*/		return 0x820AD320;
		  /* 820AD320h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD320h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD320h case    5:*/		return 0x820AD324;
		  /* 820AD324h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD324h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD338;  }
		/* 820AD324h case    6:*/		return 0x820AD328;
		  /* 820AD328h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD328h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD328h case    7:*/		return 0x820AD32C;
		  /* 820AD32Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD32Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD32Ch case    8:*/		return 0x820AD330;
		  /* 820AD330h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD330h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD330h case    9:*/		return 0x820AD334;
		  /* 820AD334h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD334h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD314;  }
		/* 820AD334h case   10:*/		return 0x820AD338;
	}
	return 0x820AD338;
} // Block from 820AD30Ch-820AD338h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD338);
		  /* 820AD338h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD338h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD338h case    0:*/		return 0x820AD33C;
		  /* 820AD33Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD33Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD348;  }
		/* 820AD33Ch case    1:*/		return 0x820AD340;
		  /* 820AD340h */ case    2:  		/* li R26, 2 */
		/* 820AD340h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x2);
		/* 820AD340h case    2:*/		return 0x820AD344;
		  /* 820AD344h */ case    3:  		/* b 240 */
		/* 820AD344h case    3:*/		return 0x820AD434;
		/* 820AD344h case    3:*/		return 0x820AD348;
	}
	return 0x820AD348;
} // Block from 820AD338h-820AD348h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD348);
		  /* 820AD348h */ case    0:  		/* lwz R10, <#[R1 + 252]> */
		/* 820AD348h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000FC) );
		/* 820AD348h case    0:*/		return 0x820AD34C;
		  /* 820AD34Ch */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD34Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD34Ch case    1:*/		return 0x820AD350;
		  /* 820AD350h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD350h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD350h case    2:*/		return 0x820AD354;
		  /* 820AD354h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD354h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD354h case    3:*/		return 0x820AD358;
		  /* 820AD358h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD358h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD358h case    4:*/		return 0x820AD35C;
		  /* 820AD35Ch */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD35Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD35Ch case    5:*/		return 0x820AD360;
		  /* 820AD360h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD360h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD374;  }
		/* 820AD360h case    6:*/		return 0x820AD364;
		  /* 820AD364h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD364h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD364h case    7:*/		return 0x820AD368;
		  /* 820AD368h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD368h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD368h case    8:*/		return 0x820AD36C;
		  /* 820AD36Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD36Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD36Ch case    9:*/		return 0x820AD370;
		  /* 820AD370h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD370h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD350;  }
		/* 820AD370h case   10:*/		return 0x820AD374;
	}
	return 0x820AD374;
} // Block from 820AD348h-820AD374h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD374);
		  /* 820AD374h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD374h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD374h case    0:*/		return 0x820AD378;
		  /* 820AD378h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD378h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD384;  }
		/* 820AD378h case    1:*/		return 0x820AD37C;
		  /* 820AD37Ch */ case    2:  		/* li R26, 3 */
		/* 820AD37Ch case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x3);
		/* 820AD37Ch case    2:*/		return 0x820AD380;
		  /* 820AD380h */ case    3:  		/* b 180 */
		/* 820AD380h case    3:*/		return 0x820AD434;
		/* 820AD380h case    3:*/		return 0x820AD384;
	}
	return 0x820AD384;
} // Block from 820AD374h-820AD384h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD384);
		  /* 820AD384h */ case    0:  		/* lwz R10, <#[R1 + 240]> */
		/* 820AD384h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000F0) );
		/* 820AD384h case    0:*/		return 0x820AD388;
		  /* 820AD388h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD388h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD388h case    1:*/		return 0x820AD38C;
		  /* 820AD38Ch */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD38Ch case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD38Ch case    2:*/		return 0x820AD390;
		  /* 820AD390h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD390h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD390h case    3:*/		return 0x820AD394;
		  /* 820AD394h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD394h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD394h case    4:*/		return 0x820AD398;
		  /* 820AD398h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD398h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD398h case    5:*/		return 0x820AD39C;
		  /* 820AD39Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD39Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD3B0;  }
		/* 820AD39Ch case    6:*/		return 0x820AD3A0;
		  /* 820AD3A0h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD3A0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD3A0h case    7:*/		return 0x820AD3A4;
		  /* 820AD3A4h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD3A4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD3A4h case    8:*/		return 0x820AD3A8;
		  /* 820AD3A8h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD3A8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD3A8h case    9:*/		return 0x820AD3AC;
		  /* 820AD3ACh */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD3ACh case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD38C;  }
		/* 820AD3ACh case   10:*/		return 0x820AD3B0;
	}
	return 0x820AD3B0;
} // Block from 820AD384h-820AD3B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD3B0);
		  /* 820AD3B0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD3B0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD3B0h case    0:*/		return 0x820AD3B4;
		  /* 820AD3B4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD3B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD3C0;  }
		/* 820AD3B4h case    1:*/		return 0x820AD3B8;
		  /* 820AD3B8h */ case    2:  		/* li R26, 4 */
		/* 820AD3B8h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x4);
		/* 820AD3B8h case    2:*/		return 0x820AD3BC;
		  /* 820AD3BCh */ case    3:  		/* b 120 */
		/* 820AD3BCh case    3:*/		return 0x820AD434;
		/* 820AD3BCh case    3:*/		return 0x820AD3C0;
	}
	return 0x820AD3C0;
} // Block from 820AD3B0h-820AD3C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD3C0);
		  /* 820AD3C0h */ case    0:  		/* lwz R10, <#[R1 + 248]> */
		/* 820AD3C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000F8) );
		/* 820AD3C0h case    0:*/		return 0x820AD3C4;
		  /* 820AD3C4h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD3C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD3C4h case    1:*/		return 0x820AD3C8;
		  /* 820AD3C8h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD3C8h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD3C8h case    2:*/		return 0x820AD3CC;
		  /* 820AD3CCh */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD3CCh case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD3CCh case    3:*/		return 0x820AD3D0;
		  /* 820AD3D0h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD3D0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD3D0h case    4:*/		return 0x820AD3D4;
		  /* 820AD3D4h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD3D4h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD3D4h case    5:*/		return 0x820AD3D8;
		  /* 820AD3D8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD3D8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD3EC;  }
		/* 820AD3D8h case    6:*/		return 0x820AD3DC;
		  /* 820AD3DCh */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD3DCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD3DCh case    7:*/		return 0x820AD3E0;
		  /* 820AD3E0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD3E0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD3E0h case    8:*/		return 0x820AD3E4;
		  /* 820AD3E4h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD3E4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD3E4h case    9:*/		return 0x820AD3E8;
		  /* 820AD3E8h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD3E8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD3C8;  }
		/* 820AD3E8h case   10:*/		return 0x820AD3EC;
	}
	return 0x820AD3EC;
} // Block from 820AD3C0h-820AD3ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD3EC);
		  /* 820AD3ECh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD3ECh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD3ECh case    0:*/		return 0x820AD3F0;
		  /* 820AD3F0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD3F0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD3FC;  }
		/* 820AD3F0h case    1:*/		return 0x820AD3F4;
		  /* 820AD3F4h */ case    2:  		/* li R26, 5 */
		/* 820AD3F4h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x5);
		/* 820AD3F4h case    2:*/		return 0x820AD3F8;
		  /* 820AD3F8h */ case    3:  		/* b 60 */
		/* 820AD3F8h case    3:*/		return 0x820AD434;
		/* 820AD3F8h case    3:*/		return 0x820AD3FC;
	}
	return 0x820AD3FC;
} // Block from 820AD3ECh-820AD3FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD3FC);
		  /* 820AD3FCh */ case    0:  		/* lwz R10, <#[R1 + 256]> */
		/* 820AD3FCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000100) );
		/* 820AD3FCh case    0:*/		return 0x820AD400;
		  /* 820AD400h */ case    1:  		/* addi R11, R1, 112 */
		/* 820AD400h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820AD400h case    1:*/		return 0x820AD404;
		  /* 820AD404h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820AD404h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD404h case    2:*/		return 0x820AD408;
		  /* 820AD408h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820AD408h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD408h case    3:*/		return 0x820AD40C;
		  /* 820AD40Ch */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820AD40Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD40Ch case    4:*/		return 0x820AD410;
		  /* 820AD410h */ case    5:  		/* subf R9, R8, R9 */
		/* 820AD410h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD410h case    5:*/		return 0x820AD414;
		  /* 820AD414h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD414h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AD428;  }
		/* 820AD414h case    6:*/		return 0x820AD418;
		  /* 820AD418h */ case    7:  		/* addi R11, R11, 1 */
		/* 820AD418h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD418h case    7:*/		return 0x820AD41C;
		  /* 820AD41Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 820AD41Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD41Ch case    8:*/		return 0x820AD420;
		  /* 820AD420h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820AD420h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD420h case    9:*/		return 0x820AD424;
		  /* 820AD424h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD424h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AD404;  }
		/* 820AD424h case   10:*/		return 0x820AD428;
	}
	return 0x820AD428;
} // Block from 820AD3FCh-820AD428h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AD428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD428);
		  /* 820AD428h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD428h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD428h case    0:*/		return 0x820AD42C;
		  /* 820AD42Ch */ case    1:  		/* bc 4, CR0_EQ, 200 */
		/* 820AD42Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD4F4;  }
		/* 820AD42Ch case    1:*/		return 0x820AD430;
		  /* 820AD430h */ case    2:  		/* li R26, 6 */
		/* 820AD430h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x6);
		/* 820AD430h case    2:*/		return 0x820AD434;
	}
	return 0x820AD434;
} // Block from 820AD428h-820AD434h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AD434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD434);
		  /* 820AD434h */ case    0:  		/* mr R28, R23 */
		/* 820AD434h case    0:*/		regs.R28 = regs.R23;
		/* 820AD434h case    0:*/		return 0x820AD438;
		  /* 820AD438h */ case    1:  		/* stw R23, <#[R1 + 132]> */
		/* 820AD438h case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000084) );
		/* 820AD438h case    1:*/		return 0x820AD43C;
	}
	return 0x820AD43C;
} // Block from 820AD434h-820AD43Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AD43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD43C);
		  /* 820AD43Ch */ case    0:  		/* lwz R8, <#[R1 + 452]> */
		/* 820AD43Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000001C4) );
		/* 820AD43Ch case    0:*/		return 0x820AD440;
	}
	return 0x820AD440;
} // Block from 820AD43Ch-820AD440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AD440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD440);
		  /* 820AD440h */ case    0:  		/* lwz R11, <#[R1 + 128]> */
		/* 820AD440h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820AD440h case    0:*/		return 0x820AD444;
		  /* 820AD444h */ case    1:  		/* lbz R11, <#[R11]> */
		/* 820AD444h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD444h case    1:*/		return 0x820AD448;
		  /* 820AD448h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 820AD448h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820AD448h case    2:*/		return 0x820AD44C;
		  /* 820AD44Ch */ case    3:  		/* bc 4, CR0_EQ, -4052 */
		/* 820AD44Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x820AC478;  }
		/* 820AD44Ch case    3:*/		return 0x820AD450;
		  /* 820AD450h */ case    4:  		/* cmplwi CR6, R22, 40 */
		/* 820AD450h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000028);
		/* 820AD450h case    4:*/		return 0x820AD454;
		  /* 820AD454h */ case    5:  		/* bc 4, CR6_EQ, 52 */
		/* 820AD454h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AD488;  }
		/* 820AD454h case    5:*/		return 0x820AD458;
		  /* 820AD458h */ case    6:  		/* cmpwi CR6, R28, 0 */
		/* 820AD458h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820AD458h case    6:*/		return 0x820AD45C;
		  /* 820AD45Ch */ case    7:  		/* bc 4, CR6_EQ, 112 */
		/* 820AD45Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820AD4CC;  }
		/* 820AD45Ch case    7:*/		return 0x820AD460;
		  /* 820AD460h */ case    8:  		/* lwz R10, <#[R8 + 64]> */
		/* 820AD460h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000040) );
		/* 820AD460h case    8:*/		return 0x820AD464;
		  /* 820AD464h */ case    9:  		/* addi R11, R27, -72 */
		/* 820AD464h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFB8);
		/* 820AD464h case    9:*/		return 0x820AD468;
		  /* 820AD468h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AD468h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AD468h case   10:*/		return 0x820AD46C;
		  /* 820AD46Ch */ case   11:  		/* addi R11, R11, 8 */
		/* 820AD46Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820AD46Ch case   11:*/		return 0x820AD470;
		  /* 820AD470h */ case   12:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820AD470h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820AD470h case   12:*/		return 0x820AD474;
		  /* 820AD474h */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 820AD474h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AD474h case   13:*/		return 0x820AD478;
		  /* 820AD478h */ case   14:  		/* bc 12, CR6_EQ, 124 */
		/* 820AD478h case   14:*/		if ( regs.CR[6].eq ) { return 0x820AD4F4;  }
		/* 820AD478h case   14:*/		return 0x820AD47C;
		  /* 820AD47Ch */ case   15:  		/* li R11, 268 */
		/* 820AD47Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x10C);
		/* 820AD47Ch case   15:*/		return 0x820AD480;
		  /* 820AD480h */ case   16:  		/* li R22, 41 */
		/* 820AD480h case   16:*/		cpu::op::li<0>(regs,&regs.R22,0x29);
		/* 820AD480h case   16:*/		return 0x820AD484;
		  /* 820AD484h */ case   17:  		/* stw R11, <#[R1 + 96]> */
		/* 820AD484h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820AD484h case   17:*/		return 0x820AD488;
	}
	return 0x820AD488;
} // Block from 820AD440h-820AD488h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820AD488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD488);
		  /* 820AD488h */ case    0:  		/* cmplwi CR6, R22, 44 */
		/* 820AD488h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000002C);
		/* 820AD488h case    0:*/		return 0x820AD48C;
		  /* 820AD48Ch */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 820AD48Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AD4BC;  }
		/* 820AD48Ch case    1:*/		return 0x820AD490;
		  /* 820AD490h */ case    2:  		/* cmpwi CR6, R28, 0 */
		/* 820AD490h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820AD490h case    2:*/		return 0x820AD494;
		  /* 820AD494h */ case    3:  		/* bc 4, CR6_EQ, 56 */
		/* 820AD494h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AD4CC;  }
		/* 820AD494h case    3:*/		return 0x820AD498;
		  /* 820AD498h */ case    4:  		/* lwz R11, <#[R8 + 64]> */
		/* 820AD498h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000040) );
		/* 820AD498h case    4:*/		return 0x820AD49C;
		  /* 820AD49Ch */ case    5:  		/* addi R10, R27, 8 */
		/* 820AD49Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x8);
		/* 820AD49Ch case    5:*/		return 0x820AD4A0;
		  /* 820AD4A0h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AD4A0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AD4A0h case    6:*/		return 0x820AD4A4;
		  /* 820AD4A4h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820AD4A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AD4A4h case    7:*/		return 0x820AD4A8;
		  /* 820AD4A8h */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 820AD4A8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AD4A8h case    8:*/		return 0x820AD4AC;
		  /* 820AD4ACh */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 820AD4ACh case    9:*/		if ( regs.CR[6].eq ) { return 0x820AD4F4;  }
		/* 820AD4ACh case    9:*/		return 0x820AD4B0;
		  /* 820AD4B0h */ case   10:  		/* li R11, 268 */
		/* 820AD4B0h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x10C);
		/* 820AD4B0h case   10:*/		return 0x820AD4B4;
		  /* 820AD4B4h */ case   11:  		/* li R22, 45 */
		/* 820AD4B4h case   11:*/		cpu::op::li<0>(regs,&regs.R22,0x2D);
		/* 820AD4B4h case   11:*/		return 0x820AD4B8;
		  /* 820AD4B8h */ case   12:  		/* stw R11, <#[R1 + 96]> */
		/* 820AD4B8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820AD4B8h case   12:*/		return 0x820AD4BC;
	}
	return 0x820AD4BC;
} // Block from 820AD488h-820AD4BCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AD4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD4BC);
		  /* 820AD4BCh */ case    0:  		/* cmplwi CR6, R22, 94 */
		/* 820AD4BCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x0000005E);
		/* 820AD4BCh case    0:*/		return 0x820AD4C0;
		  /* 820AD4C0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820AD4C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AD4CC;  }
		/* 820AD4C0h case    1:*/		return 0x820AD4C4;
		  /* 820AD4C4h */ case    2:  		/* cmpwi CR6, R28, 0 */
		/* 820AD4C4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820AD4C4h case    2:*/		return 0x820AD4C8;
		  /* 820AD4C8h */ case    3:  		/* bc 4, CR6_EQ, 44 */
		/* 820AD4C8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AD4F4;  }
		/* 820AD4C8h case    3:*/		return 0x820AD4CC;
	}
	return 0x820AD4CC;
} // Block from 820AD4BCh-820AD4CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD4CC);
		  /* 820AD4CCh */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 820AD4CCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820AD4CCh case    0:*/		return 0x820AD4D0;
		  /* 820AD4D0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 820AD4D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AD4F4;  }
		/* 820AD4D0h case    1:*/		return 0x820AD4D4;
	}
	return 0x820AD4D4;
} // Block from 820AD4CCh-820AD4D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AD4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD4D4);
		  /* 820AD4D4h */ case    0:  		/* lwz R11, <#[R1 + 452]> */
		/* 820AD4D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000001C4) );
		/* 820AD4D4h case    0:*/		return 0x820AD4D8;
		  /* 820AD4D8h */ case    1:  		/* lwz R3, <#[R1 + 96]> */
		/* 820AD4D8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 820AD4D8h case    1:*/		return 0x820AD4DC;
		  /* 820AD4DCh */ case    2:  		/* stw R22, <#[R11 + 72]> */
		/* 820AD4DCh case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000048) );
		/* 820AD4DCh case    2:*/		return 0x820AD4E0;
		  /* 820AD4E0h */ case    3:  		/* stw R21, <#[R11 + 76]> */
		/* 820AD4E0h case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x0000004C) );
		/* 820AD4E0h case    3:*/		return 0x820AD4E4;
		  /* 820AD4E4h */ case    4:  		/* stw R26, <#[R11 + 80]> */
		/* 820AD4E4h case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000050) );
		/* 820AD4E4h case    4:*/		return 0x820AD4E8;
		  /* 820AD4E8h */ case    5:  		/* stw R23, <#[R11 + 96]> */
		/* 820AD4E8h case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000060) );
		/* 820AD4E8h case    5:*/		return 0x820AD4EC;
		  /* 820AD4ECh */ case    6:  		/* addi R1, R1, 432 */
		/* 820AD4ECh case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1B0);
		/* 820AD4ECh case    6:*/		return 0x820AD4F0;
		  /* 820AD4F0h */ case    7:  		/* b -115328 */
		/* 820AD4F0h case    7:*/		return 0x82091270;
		/* 820AD4F0h case    7:*/		return 0x820AD4F4;
	}
	return 0x820AD4F4;
} // Block from 820AD4D4h-820AD4F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AD4F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD4F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD4F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD4F4);
		  /* 820AD4F4h */ case    0:  		/* li R3, 269 */
		/* 820AD4F4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x10D);
		/* 820AD4F4h case    0:*/		return 0x820AD4F8;
		  /* 820AD4F8h */ case    1:  		/* b -12 */
		/* 820AD4F8h case    1:*/		return 0x820AD4EC;
		/* 820AD4F8h case    1:*/		return 0x820AD4FC;
	}
	return 0x820AD4FC;
} // Block from 820AD4F4h-820AD4FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AD4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD4FC);
		  /* 820AD4FCh */ case    0:  		/* li R11, 2023 */
		/* 820AD4FCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7E7);
		/* 820AD4FCh case    0:*/		return 0x820AD500;
		  /* 820AD500h */ case    1:  		/* li R3, 269 */
		/* 820AD500h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x10D);
		/* 820AD500h case    1:*/		return 0x820AD504;
		  /* 820AD504h */ case    2:  		/* stw R11, <#[R8 + 96]> */
		/* 820AD504h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000060) );
		/* 820AD504h case    2:*/		return 0x820AD508;
		  /* 820AD508h */ case    3:  		/* b -28 */
		/* 820AD508h case    3:*/		return 0x820AD4EC;
		/* 820AD508h case    3:*/		return 0x820AD50C;
	}
	return 0x820AD50C;
} // Block from 820AD4FCh-820AD50Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD50C);
		  /* 820AD50Ch */ case    0:  		/* lwz R4, <#[R1 + 212]> */
		/* 820AD50Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000D4) );
		/* 820AD50Ch case    0:*/		return 0x820AD510;
		  /* 820AD510h */ case    1:  		/* lwz R3, <#[R1 + 452]> */
		/* 820AD510h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000001C4) );
		/* 820AD510h case    1:*/		return 0x820AD514;
		  /* 820AD514h */ case    2:  		/* bl -4860 */
		/* 820AD514h case    2:*/		regs.LR = 0x820AD518; return 0x820AC218;
		/* 820AD514h case    2:*/		return 0x820AD518;
		  /* 820AD518h */ case    3:  		/* b -36 */
		/* 820AD518h case    3:*/		return 0x820AD4F4;
		/* 820AD518h case    3:*/		return 0x820AD51C;
		  /* 820AD51Ch */ case    4:  		/* nop */
		/* 820AD51Ch case    4:*/		cpu::op::nop();
		/* 820AD51Ch case    4:*/		return 0x820AD520;
	}
	return 0x820AD520;
} // Block from 820AD50Ch-820AD520h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AD520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD520);
		  /* 820AD520h */ case    0:  		/* mfspr R12, LR */
		/* 820AD520h case    0:*/		regs.R12 = regs.LR;
		/* 820AD520h case    0:*/		return 0x820AD524;
		  /* 820AD524h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AD524h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AD524h case    1:*/		return 0x820AD528;
		  /* 820AD528h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820AD528h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AD528h case    2:*/		return 0x820AD52C;
		  /* 820AD52Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820AD52Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AD52Ch case    3:*/		return 0x820AD530;
		  /* 820AD530h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820AD530h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820AD530h case    4:*/		return 0x820AD534;
		  /* 820AD534h */ case    5:  		/* mr R31, R3 */
		/* 820AD534h case    5:*/		regs.R31 = regs.R3;
		/* 820AD534h case    5:*/		return 0x820AD538;
		  /* 820AD538h */ case    6:  		/* addi R30, R3, 16 */
		/* 820AD538h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x10);
		/* 820AD538h case    6:*/		return 0x820AD53C;
		  /* 820AD53Ch */ case    7:  		/* mr R4, R30 */
		/* 820AD53Ch case    7:*/		regs.R4 = regs.R30;
		/* 820AD53Ch case    7:*/		return 0x820AD540;
		  /* 820AD540h */ case    8:  		/* lwz R3, <#[R31 + 4]> */
		/* 820AD540h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820AD540h case    8:*/		return 0x820AD544;
		  /* 820AD544h */ case    9:  		/* bl -35996 */
		/* 820AD544h case    9:*/		regs.LR = 0x820AD548; return 0x820A48A8;
		/* 820AD544h case    9:*/		return 0x820AD548;
		  /* 820AD548h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820AD548h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AD548h case   10:*/		return 0x820AD54C;
		  /* 820AD54Ch */ case   11:  		/* bc 4, CR0_LT, 24 */
		/* 820AD54Ch case   11:*/		if ( !regs.CR[0].lt ) { return 0x820AD564;  }
		/* 820AD54Ch case   11:*/		return 0x820AD550;
		  /* 820AD550h */ case   12:  		/* li R11, 1 */
		/* 820AD550h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820AD550h case   12:*/		return 0x820AD554;
		  /* 820AD554h */ case   13:  		/* stw R11, <#[R31 + 84]> */
		/* 820AD554h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820AD554h case   13:*/		return 0x820AD558;
		  /* 820AD558h */ case   14:  		/* stw R11, <#[R31 + 88]> */
		/* 820AD558h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 820AD558h case   14:*/		return 0x820AD55C;
		  /* 820AD55Ch */ case   15:  		/* li R3, -1 */
		/* 820AD55Ch case   15:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820AD55Ch case   15:*/		return 0x820AD560;
		  /* 820AD560h */ case   16:  		/* b 328 */
		/* 820AD560h case   16:*/		return 0x820AD6A8;
		/* 820AD560h case   16:*/		return 0x820AD564;
	}
	return 0x820AD564;
} // Block from 820AD520h-820AD564h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820AD564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD564);
		  /* 820AD564h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820AD564h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820AD564h case    0:*/		return 0x820AD568;
		  /* 820AD568h */ case    1:  		/* cmplwi CR6, R11, 17 */
		/* 820AD568h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 820AD568h case    1:*/		return 0x820AD56C;
		  /* 820AD56Ch */ case    2:  		/* bc 12, CR6_GT, 312 */
		/* 820AD56Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x820AD6A4;  }
		/* 820AD56Ch case    2:*/		return 0x820AD570;
		  /* 820AD570h */ case    3:  		/* lis R12, -32255 */
		/* 820AD570h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820AD570h case    3:*/		return 0x820AD574;
		  /* 820AD574h */ case    4:  		/* addi R12, R12, 2144 */
		/* 820AD574h case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x860);
		/* 820AD574h case    4:*/		return 0x820AD578;
		  /* 820AD578h */ case    5:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820AD578h case    5:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820AD578h case    5:*/		return 0x820AD57C;
		  /* 820AD57Ch */ case    6:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820AD57Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820AD57Ch case    6:*/		return 0x820AD580;
		  /* 820AD580h */ case    7:  		/* lis R12, -32245 */
		/* 820AD580h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820B);
		/* 820AD580h case    7:*/		return 0x820AD584;
		  /* 820AD584h */ case    8:  		/* ori R0, R0, 0 */
		/* 820AD584h case    8:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820AD584h case    8:*/		return 0x820AD588;
		  /* 820AD588h */ case    9:  		/* addi R12, R12, -10948 */
		/* 820AD588h case    9:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFD53C);
		/* 820AD588h case    9:*/		return 0x820AD58C;
		  /* 820AD58Ch */ case   10:  		/* add R12, R12, R0 */
		/* 820AD58Ch case   10:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820AD58Ch case   10:*/		return 0x820AD590;
		  /* 820AD590h */ case   11:  		/* mtspr CTR, R12 */
		/* 820AD590h case   11:*/		regs.CTR = regs.R12;
		/* 820AD590h case   11:*/		return 0x820AD594;
		  /* 820AD594h */ case   12:  		/* bcctr 20, CR0_LT */
		/* 820AD594h case   12:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820AD594h case   12:*/		return 0x820AD598;
		  /* 820AD598h */ case   13:  		/* lbz R11, <#[R31 + 25]> */
		/* 820AD598h case   13:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000019) );
		/* 820AD598h case   13:*/		return 0x820AD59C;
		  /* 820AD59Ch */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 820AD59Ch case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820AD59Ch case   14:*/		return 0x820AD5A0;
		  /* 820AD5A0h */ case   15:  		/* bc 4, CR0_EQ, 260 */
		/* 820AD5A0h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820AD6A4;  }
		/* 820AD5A0h case   15:*/		return 0x820AD5A4;
		  /* 820AD5A4h */ case   16:  		/* lbz R3, <#[R31 + 24]> */
		/* 820AD5A4h case   16:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820AD5A4h case   16:*/		return 0x820AD5A8;
		  /* 820AD5A8h */ case   17:  		/* b 256 */
		/* 820AD5A8h case   17:*/		return 0x820AD6A8;
		/* 820AD5A8h case   17:*/		return 0x820AD5AC;
		  /* 820AD5ACh */ case   18:  		/* li R3, 270 */
		/* 820AD5ACh case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x10E);
		/* 820AD5ACh case   18:*/		return 0x820AD5B0;
		  /* 820AD5B0h */ case   19:  		/* b 248 */
		/* 820AD5B0h case   19:*/		return 0x820AD6A8;
		/* 820AD5B0h case   19:*/		return 0x820AD5B4;
		  /* 820AD5B4h */ case   20:  		/* li R3, 271 */
		/* 820AD5B4h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x10F);
		/* 820AD5B4h case   20:*/		return 0x820AD5B8;
		  /* 820AD5B8h */ case   21:  		/* b 240 */
		/* 820AD5B8h case   21:*/		return 0x820AD6A8;
		/* 820AD5B8h case   21:*/		return 0x820AD5BC;
		  /* 820AD5BCh */ case   22:  		/* lis R11, -32255 */
		/* 820AD5BCh case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AD5BCh case   22:*/		return 0x820AD5C0;
		  /* 820AD5C0h */ case   23:  		/* lwz R8, <#[R31 + 24]> */
		/* 820AD5C0h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820AD5C0h case   23:*/		return 0x820AD5C4;
		  /* 820AD5C4h */ case   24:  		/* addi R10, R11, 5232 */
		/* 820AD5C4h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1470);
		/* 820AD5C4h case   24:*/		return 0x820AD5C8;
		  /* 820AD5C8h */ case   25:  		/* mr R11, R8 */
		/* 820AD5C8h case   25:*/		regs.R11 = regs.R8;
		/* 820AD5C8h case   25:*/		return 0x820AD5CC;
		  /* 820AD5CCh */ case   26:  		/* lbz R9, <#[R11]> */
		/* 820AD5CCh case   26:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD5CCh case   26:*/		return 0x820AD5D0;
		  /* 820AD5D0h */ case   27:  		/* lbz R7, <#[R10]> */
		/* 820AD5D0h case   27:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD5D0h case   27:*/		return 0x820AD5D4;
		  /* 820AD5D4h */ case   28:  		/* cmpwi CR0, R9, 0 */
		/* 820AD5D4h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD5D4h case   28:*/		return 0x820AD5D8;
		  /* 820AD5D8h */ case   29:  		/* subf R9, R7, R9 */
		/* 820AD5D8h case   29:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820AD5D8h case   29:*/		return 0x820AD5DC;
		  /* 820AD5DCh */ case   30:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD5DCh case   30:*/		if ( regs.CR[0].eq ) { return 0x820AD5F0;  }
		/* 820AD5DCh case   30:*/		return 0x820AD5E0;
		  /* 820AD5E0h */ case   31:  		/* addi R11, R11, 1 */
		/* 820AD5E0h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD5E0h case   31:*/		return 0x820AD5E4;
		  /* 820AD5E4h */ case   32:  		/* addi R10, R10, 1 */
		/* 820AD5E4h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD5E4h case   32:*/		return 0x820AD5E8;
		  /* 820AD5E8h */ case   33:  		/* cmpwi CR6, R9, 0 */
		/* 820AD5E8h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD5E8h case   33:*/		return 0x820AD5EC;
		  /* 820AD5ECh */ case   34:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD5ECh case   34:*/		if ( regs.CR[6].eq ) { return 0x820AD5CC;  }
		/* 820AD5ECh case   34:*/		return 0x820AD5F0;
	}
	return 0x820AD5F0;
} // Block from 820AD564h-820AD5F0h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820AD5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD5F0);
		  /* 820AD5F0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD5F0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD5F0h case    0:*/		return 0x820AD5F4;
		  /* 820AD5F4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD5F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD600;  }
		/* 820AD5F4h case    1:*/		return 0x820AD5F8;
		  /* 820AD5F8h */ case    2:  		/* li R3, 257 */
		/* 820AD5F8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x101);
		/* 820AD5F8h case    2:*/		return 0x820AD5FC;
		  /* 820AD5FCh */ case    3:  		/* b 172 */
		/* 820AD5FCh case    3:*/		return 0x820AD6A8;
		/* 820AD5FCh case    3:*/		return 0x820AD600;
	}
	return 0x820AD600;
} // Block from 820AD5F0h-820AD600h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD600);
		  /* 820AD600h */ case    0:  		/* lis R10, -32255 */
		/* 820AD600h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AD600h case    0:*/		return 0x820AD604;
		  /* 820AD604h */ case    1:  		/* mr R11, R8 */
		/* 820AD604h case    1:*/		regs.R11 = regs.R8;
		/* 820AD604h case    1:*/		return 0x820AD608;
		  /* 820AD608h */ case    2:  		/* addi R10, R10, 5224 */
		/* 820AD608h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1468);
		/* 820AD608h case    2:*/		return 0x820AD60C;
		  /* 820AD60Ch */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820AD60Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD60Ch case    3:*/		return 0x820AD610;
		  /* 820AD610h */ case    4:  		/* lbz R7, <#[R10]> */
		/* 820AD610h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD610h case    4:*/		return 0x820AD614;
		  /* 820AD614h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820AD614h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD614h case    5:*/		return 0x820AD618;
		  /* 820AD618h */ case    6:  		/* subf R9, R7, R9 */
		/* 820AD618h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820AD618h case    6:*/		return 0x820AD61C;
		  /* 820AD61Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD61Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820AD630;  }
		/* 820AD61Ch case    7:*/		return 0x820AD620;
		  /* 820AD620h */ case    8:  		/* addi R11, R11, 1 */
		/* 820AD620h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD620h case    8:*/		return 0x820AD624;
		  /* 820AD624h */ case    9:  		/* addi R10, R10, 1 */
		/* 820AD624h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD624h case    9:*/		return 0x820AD628;
		  /* 820AD628h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820AD628h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD628h case   10:*/		return 0x820AD62C;
		  /* 820AD62Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD62Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820AD60C;  }
		/* 820AD62Ch case   11:*/		return 0x820AD630;
	}
	return 0x820AD630;
} // Block from 820AD600h-820AD630h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AD630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD630);
		  /* 820AD630h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD630h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD630h case    0:*/		return 0x820AD634;
		  /* 820AD634h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD634h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD640;  }
		/* 820AD634h case    1:*/		return 0x820AD638;
		  /* 820AD638h */ case    2:  		/* li R3, 273 */
		/* 820AD638h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x111);
		/* 820AD638h case    2:*/		return 0x820AD63C;
		  /* 820AD63Ch */ case    3:  		/* b 108 */
		/* 820AD63Ch case    3:*/		return 0x820AD6A8;
		/* 820AD63Ch case    3:*/		return 0x820AD640;
	}
	return 0x820AD640;
} // Block from 820AD630h-820AD640h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD640);
		  /* 820AD640h */ case    0:  		/* lis R10, -32255 */
		/* 820AD640h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AD640h case    0:*/		return 0x820AD644;
		  /* 820AD644h */ case    1:  		/* mr R11, R8 */
		/* 820AD644h case    1:*/		regs.R11 = regs.R8;
		/* 820AD644h case    1:*/		return 0x820AD648;
		  /* 820AD648h */ case    2:  		/* addi R10, R10, 5216 */
		/* 820AD648h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1460);
		/* 820AD648h case    2:*/		return 0x820AD64C;
		  /* 820AD64Ch */ case    3:  		/* lbz R9, <#[R11]> */
		/* 820AD64Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD64Ch case    3:*/		return 0x820AD650;
		  /* 820AD650h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 820AD650h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820AD650h case    4:*/		return 0x820AD654;
		  /* 820AD654h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 820AD654h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD654h case    5:*/		return 0x820AD658;
		  /* 820AD658h */ case    6:  		/* subf R9, R8, R9 */
		/* 820AD658h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820AD658h case    6:*/		return 0x820AD65C;
		  /* 820AD65Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820AD65Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820AD670;  }
		/* 820AD65Ch case    7:*/		return 0x820AD660;
		  /* 820AD660h */ case    8:  		/* addi R11, R11, 1 */
		/* 820AD660h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AD660h case    8:*/		return 0x820AD664;
		  /* 820AD664h */ case    9:  		/* addi R10, R10, 1 */
		/* 820AD664h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AD664h case    9:*/		return 0x820AD668;
		  /* 820AD668h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 820AD668h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AD668h case   10:*/		return 0x820AD66C;
		  /* 820AD66Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 820AD66Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820AD64C;  }
		/* 820AD66Ch case   11:*/		return 0x820AD670;
	}
	return 0x820AD670;
} // Block from 820AD640h-820AD670h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AD670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD670);
		  /* 820AD670h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AD670h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AD670h case    0:*/		return 0x820AD674;
		  /* 820AD674h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AD674h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AD680;  }
		/* 820AD674h case    1:*/		return 0x820AD678;
		  /* 820AD678h */ case    2:  		/* li R3, 274 */
		/* 820AD678h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x112);
		/* 820AD678h case    2:*/		return 0x820AD67C;
		  /* 820AD67Ch */ case    3:  		/* b 44 */
		/* 820AD67Ch case    3:*/		return 0x820AD6A8;
		/* 820AD67Ch case    3:*/		return 0x820AD680;
	}
	return 0x820AD680;
} // Block from 820AD670h-820AD680h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AD680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD680);
		  /* 820AD680h */ case    0:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AD680h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AD680h case    0:*/		return 0x820AD684;
		  /* 820AD684h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820AD684h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820AD684h case    1:*/		return 0x820AD688;
		  /* 820AD688h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820AD688h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AD69C;  }
		/* 820AD688h case    2:*/		return 0x820AD68C;
		  /* 820AD68Ch */ case    3:  		/* mr R4, R30 */
		/* 820AD68Ch case    3:*/		regs.R4 = regs.R30;
		/* 820AD68Ch case    3:*/		return 0x820AD690;
		  /* 820AD690h */ case    4:  		/* mr R3, R31 */
		/* 820AD690h case    4:*/		regs.R3 = regs.R31;
		/* 820AD690h case    4:*/		return 0x820AD694;
		  /* 820AD694h */ case    5:  		/* bl -5164 */
		/* 820AD694h case    5:*/		regs.LR = 0x820AD698; return 0x820AC268;
		/* 820AD694h case    5:*/		return 0x820AD698;
		  /* 820AD698h */ case    6:  		/* b 16 */
		/* 820AD698h case    6:*/		return 0x820AD6A8;
		/* 820AD698h case    6:*/		return 0x820AD69C;
	}
	return 0x820AD69C;
} // Block from 820AD680h-820AD69Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AD69Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD69C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD69C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD69C);
		  /* 820AD69Ch */ case    0:  		/* li R3, 269 */
		/* 820AD69Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x10D);
		/* 820AD69Ch case    0:*/		return 0x820AD6A0;
		  /* 820AD6A0h */ case    1:  		/* b 8 */
		/* 820AD6A0h case    1:*/		return 0x820AD6A8;
		/* 820AD6A0h case    1:*/		return 0x820AD6A4;
	}
	return 0x820AD6A4;
} // Block from 820AD69Ch-820AD6A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AD6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD6A4);
		  /* 820AD6A4h */ case    0:  		/* li R3, 272 */
		/* 820AD6A4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x110);
		/* 820AD6A4h case    0:*/		return 0x820AD6A8;
	}
	return 0x820AD6A8;
} // Block from 820AD6A4h-820AD6A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AD6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD6A8);
		  /* 820AD6A8h */ case    0:  		/* addi R1, R1, 112 */
		/* 820AD6A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820AD6A8h case    0:*/		return 0x820AD6AC;
		  /* 820AD6ACh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AD6ACh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AD6ACh case    1:*/		return 0x820AD6B0;
		  /* 820AD6B0h */ case    2:  		/* mtspr LR, R12 */
		/* 820AD6B0h case    2:*/		regs.LR = regs.R12;
		/* 820AD6B0h case    2:*/		return 0x820AD6B4;
		  /* 820AD6B4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820AD6B4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AD6B4h case    3:*/		return 0x820AD6B8;
		  /* 820AD6B8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820AD6B8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AD6B8h case    4:*/		return 0x820AD6BC;
		  /* 820AD6BCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820AD6BCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AD6BCh case    5:*/		return 0x820AD6C0;
	}
	return 0x820AD6C0;
} // Block from 820AD6A8h-820AD6C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AD6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD6C0);
		  /* 820AD6C0h */ case    0:  		/* mfspr R12, LR */
		/* 820AD6C0h case    0:*/		regs.R12 = regs.LR;
		/* 820AD6C0h case    0:*/		return 0x820AD6C4;
		  /* 820AD6C4h */ case    1:  		/* bl -115840 */
		/* 820AD6C4h case    1:*/		regs.LR = 0x820AD6C8; return 0x82091244;
		/* 820AD6C4h case    1:*/		return 0x820AD6C8;
		  /* 820AD6C8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820AD6C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820AD6C8h case    2:*/		return 0x820AD6CC;
		  /* 820AD6CCh */ case    3:  		/* addi R11, R3, 1032 */
		/* 820AD6CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x408);
		/* 820AD6CCh case    3:*/		return 0x820AD6D0;
		  /* 820AD6D0h */ case    4:  		/* li R25, 0 */
		/* 820AD6D0h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820AD6D0h case    4:*/		return 0x820AD6D4;
		  /* 820AD6D4h */ case    5:  		/* stw R11, <#[R3 + 20]> */
		/* 820AD6D4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820AD6D4h case    5:*/		return 0x820AD6D8;
		  /* 820AD6D8h */ case    6:  		/* li R26, -1 */
		/* 820AD6D8h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 820AD6D8h case    6:*/		return 0x820AD6DC;
		  /* 820AD6DCh */ case    7:  		/* addi R24, R3, 32 */
		/* 820AD6DCh case    7:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R3,0x20);
		/* 820AD6DCh case    7:*/		return 0x820AD6E0;
		  /* 820AD6E0h */ case    8:  		/* stw R25, <#[R3 + 4]> */
		/* 820AD6E0h case    8:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000004) );
		/* 820AD6E0h case    8:*/		return 0x820AD6E4;
		  /* 820AD6E4h */ case    9:  		/* lis R11, -32255 */
		/* 820AD6E4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AD6E4h case    9:*/		return 0x820AD6E8;
		  /* 820AD6E8h */ case   10:  		/* stw R25, <#[R3 + 8]> */
		/* 820AD6E8h case   10:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000008) );
		/* 820AD6E8h case   10:*/		return 0x820AD6EC;
		  /* 820AD6ECh */ case   11:  		/* lis R10, -32255 */
		/* 820AD6ECh case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AD6ECh case   11:*/		return 0x820AD6F0;
		  /* 820AD6F0h */ case   12:  		/* stw R26, <#[R3 + 12]> */
		/* 820AD6F0h case   12:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000000C) );
		/* 820AD6F0h case   12:*/		return 0x820AD6F4;
		  /* 820AD6F4h */ case   13:  		/* stw R24, <#[R3 + 16]> */
		/* 820AD6F4h case   13:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000010) );
		/* 820AD6F4h case   13:*/		return 0x820AD6F8;
		  /* 820AD6F8h */ case   14:  		/* mr R31, R3 */
		/* 820AD6F8h case   14:*/		regs.R31 = regs.R3;
		/* 820AD6F8h case   14:*/		return 0x820AD6FC;
		  /* 820AD6FCh */ case   15:  		/* mr R30, R25 */
		/* 820AD6FCh case   15:*/		regs.R30 = regs.R25;
		/* 820AD6FCh case   15:*/		return 0x820AD700;
		  /* 820AD700h */ case   16:  		/* sth R25, <#[R3 + 32]> */
		/* 820AD700h case   16:*/		cpu::mem::store16( regs, regs.R25, (uint32)(regs.R3 + 0x00000020) );
		/* 820AD700h case   16:*/		return 0x820AD704;
		  /* 820AD704h */ case   17:  		/* addi R27, R11, -8152 */
		/* 820AD704h case   17:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFE028);
		/* 820AD704h case   17:*/		return 0x820AD708;
		  /* 820AD708h */ case   18:  		/* addi R23, R10, -10392 */
		/* 820AD708h case   18:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFD768);
		/* 820AD708h case   18:*/		return 0x820AD70C;
		  /* 820AD70Ch */ case   19:  		/* addi R11, R27, 256 */
		/* 820AD70Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x100);
		/* 820AD70Ch case   19:*/		return 0x820AD710;
		  /* 820AD710h */ case   20:  		/* rlwinm R29, R30, 1, 0, 30 */
		/* 820AD710h case   20:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R30);
		/* 820AD710h case   20:*/		return 0x820AD714;
		  /* 820AD714h */ case   21:  		/* lhax R11, <#[R29 + R11]> */
		/* 820AD714h case   21:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820AD714h case   21:*/		return 0x820AD718;
		  /* 820AD718h */ case   22:  		/* cmpwi CR0, R11, 0 */
		/* 820AD718h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820AD718h case   22:*/		return 0x820AD71C;
		  /* 820AD71Ch */ case   23:  		/* bc 4, CR0_EQ, 244 */
		/* 820AD71Ch case   23:*/		if ( !regs.CR[0].eq ) { return 0x820AD810;  }
		/* 820AD71Ch case   23:*/		return 0x820AD720;
		  /* 820AD720h */ case   24:  		/* lwz R11, <#[R31 + 12]> */
		/* 820AD720h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AD720h case   24:*/		return 0x820AD724;
		  /* 820AD724h */ case   25:  		/* cmpwi CR6, R11, 0 */
		/* 820AD724h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AD724h case   25:*/		return 0x820AD728;
		  /* 820AD728h */ case   26:  		/* bc 4, CR6_LT, 28 */
		/* 820AD728h case   26:*/		if ( !regs.CR[6].lt ) { return 0x820AD744;  }
		/* 820AD728h case   26:*/		return 0x820AD72C;
		  /* 820AD72Ch */ case   27:  		/* lwz R3, <#[R31 + 3032]> */
		/* 820AD72Ch case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000BD8) );
		/* 820AD72Ch case   27:*/		return 0x820AD730;
		  /* 820AD730h */ case   28:  		/* bl -528 */
		/* 820AD730h case   28:*/		regs.LR = 0x820AD734; return 0x820AD520;
		/* 820AD730h case   28:*/		return 0x820AD734;
		  /* 820AD734h */ case   29:  		/* stw R3, <#[R31 + 12]> */
		/* 820AD734h case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AD734h case   29:*/		return 0x820AD738;
		  /* 820AD738h */ case   30:  		/* cmpwi CR0, R3, 0 */
		/* 820AD738h case   30:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AD738h case   30:*/		return 0x820AD73C;
		  /* 820AD73Ch */ case   31:  		/* bc 4, CR0_LT, 8 */
		/* 820AD73Ch case   31:*/		if ( !regs.CR[0].lt ) { return 0x820AD744;  }
		/* 820AD73Ch case   31:*/		return 0x820AD740;
		  /* 820AD740h */ case   32:  		/* stw R25, <#[R31 + 12]> */
		/* 820AD740h case   32:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AD740h case   32:*/		return 0x820AD744;
	}
	return 0x820AD744;
} // Block from 820AD6C0h-820AD744h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820AD744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD744);
		  /* 820AD744h */ case    0:  		/* addi R11, R27, 584 */
		/* 820AD744h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x248);
		/* 820AD744h case    0:*/		return 0x820AD748;
		  /* 820AD748h */ case    1:  		/* lhax R11, <#[R29 + R11]> */
		/* 820AD748h case    1:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820AD748h case    1:*/		return 0x820AD74C;
		  /* 820AD74Ch */ case    2:  		/* cmpwi CR0, R11, 0 */
		/* 820AD74Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820AD74Ch case    2:*/		return 0x820AD750;
		  /* 820AD750h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820AD750h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AD7D0;  }
		/* 820AD750h case    3:*/		return 0x820AD754;
		  /* 820AD754h */ case    4:  		/* lwz R9, <#[R31 + 12]> */
		/* 820AD754h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AD754h case    4:*/		return 0x820AD758;
		  /* 820AD758h */ case    5:  		/* add. R11, R9, R11 */
		/* 820AD758h case    5:*/		cpu::op::add<1>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820AD758h case    5:*/		return 0x820AD75C;
		  /* 820AD75Ch */ case    6:  		/* bc 12, CR0_LT, 116 */
		/* 820AD75Ch case    6:*/		if ( regs.CR[0].lt ) { return 0x820AD7D0;  }
		/* 820AD75Ch case    6:*/		return 0x820AD760;
		  /* 820AD760h */ case    7:  		/* cmpwi CR6, R11, 295 */
		/* 820AD760h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000127);
		/* 820AD760h case    7:*/		return 0x820AD764;
		  /* 820AD764h */ case    8:  		/* bc 12, CR6_GT, 108 */
		/* 820AD764h case    8:*/		if ( regs.CR[6].gt ) { return 0x820AD7D0;  }
		/* 820AD764h case    8:*/		return 0x820AD768;
		  /* 820AD768h */ case    9:  		/* addi R8, R27, 1768 */
		/* 820AD768h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0x6E8);
		/* 820AD768h case    9:*/		return 0x820AD76C;
		  /* 820AD76Ch */ case   10:  		/* rlwinm R10, R11, 1, 0, 30 */
		/* 820AD76Ch case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R11);
		/* 820AD76Ch case   10:*/		return 0x820AD770;
		  /* 820AD770h */ case   11:  		/* lhax R11, <#[R10 + R8]> */
		/* 820AD770h case   11:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820AD770h case   11:*/		return 0x820AD774;
		  /* 820AD774h */ case   12:  		/* cmpw CR6, R11, R9 */
		/* 820AD774h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820AD774h case   12:*/		return 0x820AD778;
		  /* 820AD778h */ case   13:  		/* bc 4, CR6_EQ, 88 */
		/* 820AD778h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820AD7D0;  }
		/* 820AD778h case   13:*/		return 0x820AD77C;
		  /* 820AD77Ch */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 820AD77Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820AD77Ch case   14:*/		return 0x820AD780;
		  /* 820AD780h */ case   15:  		/* addi R9, R31, 1030 */
		/* 820AD780h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x406);
		/* 820AD780h case   15:*/		return 0x820AD784;
		  /* 820AD784h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 820AD784h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820AD784h case   16:*/		return 0x820AD788;
		  /* 820AD788h */ case   17:  		/* bc 4, CR6_LT, 1392 */
		/* 820AD788h case   17:*/		if ( !regs.CR[6].lt ) { return 0x820ADCF8;  }
		/* 820AD788h case   17:*/		return 0x820AD78C;
		  /* 820AD78Ch */ case   18:  		/* addi R9, R27, 1176 */
		/* 820AD78Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x498);
		/* 820AD78Ch case   18:*/		return 0x820AD790;
		  /* 820AD790h */ case   19:  		/* addi R11, R11, 2 */
		/* 820AD790h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820AD790h case   19:*/		return 0x820AD794;
		  /* 820AD794h */ case   20:  		/* lhax R30, <#[R10 + R9]> */
		/* 820AD794h case   20:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820AD794h case   20:*/		return 0x820AD798;
		  /* 820AD798h */ case   21:  		/* stw R11, <#[R31 + 16]> */
		/* 820AD798h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820AD798h case   21:*/		return 0x820AD79C;
		  /* 820AD79Ch */ case   22:  		/* sth R30, <#[R11]> */
		/* 820AD79Ch case   22:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD79Ch case   22:*/		return 0x820AD7A0;
		  /* 820AD7A0h */ case   23:  		/* lwz R10, <#[R31 + 28]> */
		/* 820AD7A0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820AD7A0h case   23:*/		return 0x820AD7A4;
		  /* 820AD7A4h */ case   24:  		/* lwz R11, <#[R31 + 20]> */
		/* 820AD7A4h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820AD7A4h case   24:*/		return 0x820AD7A8;
		  /* 820AD7A8h */ case   25:  		/* addi R11, R11, 4 */
		/* 820AD7A8h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820AD7A8h case   25:*/		return 0x820AD7AC;
		  /* 820AD7ACh */ case   26:  		/* stw R11, <#[R31 + 20]> */
		/* 820AD7ACh case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820AD7ACh case   26:*/		return 0x820AD7B0;
		  /* 820AD7B0h */ case   27:  		/* stw R10, <#[R11]> */
		/* 820AD7B0h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820AD7B0h case   27:*/		return 0x820AD7B4;
		  /* 820AD7B4h */ case   28:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AD7B4h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AD7B4h case   28:*/		return 0x820AD7B8;
		  /* 820AD7B8h */ case   29:  		/* cmpwi CR6, R11, 0 */
		/* 820AD7B8h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AD7B8h case   29:*/		return 0x820AD7BC;
		  /* 820AD7BCh */ case   30:  		/* stw R26, <#[R31 + 12]> */
		/* 820AD7BCh case   30:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AD7BCh case   30:*/		return 0x820AD7C0;
		  /* 820AD7C0h */ case   31:  		/* bc 4, CR6_GT, -180 */
		/* 820AD7C0h case   31:*/		if ( !regs.CR[6].gt ) { return 0x820AD70C;  }
		/* 820AD7C0h case   31:*/		return 0x820AD7C4;
		  /* 820AD7C4h */ case   32:  		/* addi R11, R11, -1 */
		/* 820AD7C4h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820AD7C4h case   32:*/		return 0x820AD7C8;
		  /* 820AD7C8h */ case   33:  		/* stw R11, <#[R31 + 8]> */
		/* 820AD7C8h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AD7C8h case   33:*/		return 0x820AD7CC;
		  /* 820AD7CCh */ case   34:  		/* b -192 */
		/* 820AD7CCh case   34:*/		return 0x820AD70C;
		/* 820AD7CCh case   34:*/		return 0x820AD7D0;
	}
	return 0x820AD7D0;
} // Block from 820AD744h-820AD7D0h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820AD7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD7D0);
		  /* 820AD7D0h */ case    0:  		/* addi R11, R27, 848 */
		/* 820AD7D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x350);
		/* 820AD7D0h case    0:*/		return 0x820AD7D4;
		  /* 820AD7D4h */ case    1:  		/* lhax R11, <#[R29 + R11]> */
		/* 820AD7D4h case    1:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820AD7D4h case    1:*/		return 0x820AD7D8;
		  /* 820AD7D8h */ case    2:  		/* cmpwi CR0, R11, 0 */
		/* 820AD7D8h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820AD7D8h case    2:*/		return 0x820AD7DC;
		  /* 820AD7DCh */ case    3:  		/* bc 12, CR0_EQ, 1096 */
		/* 820AD7DCh case    3:*/		if ( regs.CR[0].eq ) { return 0x820ADC24;  }
		/* 820AD7DCh case    3:*/		return 0x820AD7E0;
		  /* 820AD7E0h */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 820AD7E0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AD7E0h case    4:*/		return 0x820AD7E4;
		  /* 820AD7E4h */ case    5:  		/* add. R11, R10, R11 */
		/* 820AD7E4h case    5:*/		cpu::op::add<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820AD7E4h case    5:*/		return 0x820AD7E8;
		  /* 820AD7E8h */ case    6:  		/* bc 12, CR0_LT, 1084 */
		/* 820AD7E8h case    6:*/		if ( regs.CR[0].lt ) { return 0x820ADC24;  }
		/* 820AD7E8h case    6:*/		return 0x820AD7EC;
		  /* 820AD7ECh */ case    7:  		/* cmpwi CR6, R11, 295 */
		/* 820AD7ECh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000127);
		/* 820AD7ECh case    7:*/		return 0x820AD7F0;
		  /* 820AD7F0h */ case    8:  		/* bc 12, CR6_GT, 1076 */
		/* 820AD7F0h case    8:*/		if ( regs.CR[6].gt ) { return 0x820ADC24;  }
		/* 820AD7F0h case    8:*/		return 0x820AD7F4;
		  /* 820AD7F4h */ case    9:  		/* addi R9, R27, 1768 */
		/* 820AD7F4h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x6E8);
		/* 820AD7F4h case    9:*/		return 0x820AD7F8;
		  /* 820AD7F8h */ case   10:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820AD7F8h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820AD7F8h case   10:*/		return 0x820AD7FC;
		  /* 820AD7FCh */ case   11:  		/* lhax R9, <#[R11 + R9]> */
		/* 820AD7FCh case   11:*/		cpu::mem::load16a( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820AD7FCh case   11:*/		return 0x820AD800;
		  /* 820AD800h */ case   12:  		/* cmpw CR6, R9, R10 */
		/* 820AD800h case   12:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 820AD800h case   12:*/		return 0x820AD804;
		  /* 820AD804h */ case   13:  		/* bc 4, CR6_EQ, 1056 */
		/* 820AD804h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820ADC24;  }
		/* 820AD804h case   13:*/		return 0x820AD808;
		  /* 820AD808h */ case   14:  		/* addi R10, R27, 1176 */
		/* 820AD808h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x498);
		/* 820AD808h case   14:*/		return 0x820AD80C;
		  /* 820AD80Ch */ case   15:  		/* lhax R11, <#[R11 + R10]> */
		/* 820AD80Ch case   15:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AD80Ch case   15:*/		return 0x820AD810;
	}
	return 0x820AD810;
} // Block from 820AD7D0h-820AD810h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820AD810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AD810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AD810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AD810);
		  /* 820AD810h */ case    0:  		/* rlwinm R30, R11, 1, 0, 30 */
		/* 820AD810h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R11);
		/* 820AD810h case    0:*/		return 0x820AD814;
		  /* 820AD814h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 820AD814h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820AD814h case    1:*/		return 0x820AD818;
		  /* 820AD818h */ case    2:  		/* addi R9, R27, 128 */
		/* 820AD818h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x80);
		/* 820AD818h case    2:*/		return 0x820AD81C;
		  /* 820AD81Ch */ case    3:  		/* addi R11, R11, -1 */
		/* 820AD81Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820AD81Ch case    3:*/		return 0x820AD820;
		  /* 820AD820h */ case    4:  		/* cmplwi CR6, R11, 61 */
		/* 820AD820h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003D);
		/* 820AD820h case    4:*/		return 0x820AD824;
		  /* 820AD824h */ case    5:  		/* lhax R29, <#[R30 + R9]> */
		/* 820AD824h case    5:*/		cpu::mem::load16a( regs, &regs.R29, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 820AD824h case    5:*/		return 0x820AD828;
		  /* 820AD828h */ case    6:  		/* rlwinm R28, R29, 2, 0, 29 */
		/* 820AD828h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R29);
		/* 820AD828h case    6:*/		return 0x820AD82C;
		  /* 820AD82Ch */ case    7:  		/* subf R10, R28, R10 */
		/* 820AD82Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R10);
		/* 820AD82Ch case    7:*/		return 0x820AD830;
		  /* 820AD830h */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 820AD830h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820AD830h case    8:*/		return 0x820AD834;
		  /* 820AD834h */ case    9:  		/* stw R10, <#[R31 + 24]> */
		/* 820AD834h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820AD834h case    9:*/		return 0x820AD838;
		  /* 820AD838h */ case   10:  		/* bc 12, CR6_GT, 724 */
		/* 820AD838h case   10:*/		if ( regs.CR[6].gt ) { return 0x820ADB0C;  }
		/* 820AD838h case   10:*/		return 0x820AD83C;
		  /* 820AD83Ch */ case   11:  		/* lis R12, -32255 */
		/* 820AD83Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820AD83Ch case   11:*/		return 0x820AD840;
		  /* 820AD840h */ case   12:  		/* addi R12, R12, 2168 */
		/* 820AD840h case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x878);
		/* 820AD840h case   12:*/		return 0x820AD844;
		  /* 820AD844h */ case   13:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820AD844h case   13:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820AD844h case   13:*/		return 0x820AD848;
		  /* 820AD848h */ case   14:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820AD848h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820AD848h case   14:*/		return 0x820AD84C;
		  /* 820AD84Ch */ case   15:  		/* lis R12, -32245 */
		/* 820AD84Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820B);
		/* 820AD84Ch case   15:*/		return 0x820AD850;
		  /* 820AD850h */ case   16:  		/* ori R0, R0, 0 */
		/* 820AD850h case   16:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820AD850h case   16:*/		return 0x820AD854;
		  /* 820AD854h */ case   17:  		/* addi R12, R12, -10140 */
		/* 820AD854h case   17:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFD864);
		/* 820AD854h case   17:*/		return 0x820AD858;
		  /* 820AD858h */ case   18:  		/* add R12, R12, R0 */
		/* 820AD858h case   18:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820AD858h case   18:*/		return 0x820AD85C;
		  /* 820AD85Ch */ case   19:  		/* mtspr CTR, R12 */
		/* 820AD85Ch case   19:*/		regs.CTR = regs.R12;
		/* 820AD85Ch case   19:*/		return 0x820AD860;
		  /* 820AD860h */ case   20:  		/* bcctr 20, CR0_LT */
		/* 820AD860h case   20:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820AD860h case   20:*/		return 0x820AD864;
		  /* 820AD864h */ case   21:  		/* li R4, 0 */
		/* 820AD864h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AD864h case   21:*/		return 0x820AD868;
		  /* 820AD868h */ case   22:  		/* b 664 */
		/* 820AD868h case   22:*/		return 0x820ADB00;
		/* 820AD868h case   22:*/		return 0x820AD86C;
		  /* 820AD86Ch */ case   23:  		/* li R5, 1 */
		/* 820AD86Ch case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD86Ch case   23:*/		return 0x820AD870;
		  /* 820AD870h */ case   24:  		/* li R4, 1 */
		/* 820AD870h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820AD870h case   24:*/		return 0x820AD874;
		  /* 820AD874h */ case   25:  		/* b 656 */
		/* 820AD874h case   25:*/		return 0x820ADB04;
		/* 820AD874h case   25:*/		return 0x820AD878;
		  /* 820AD878h */ case   26:  		/* li R5, 1 */
		/* 820AD878h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD878h case   26:*/		return 0x820AD87C;
		  /* 820AD87Ch */ case   27:  		/* li R4, 2 */
		/* 820AD87Ch case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820AD87Ch case   27:*/		return 0x820AD880;
		  /* 820AD880h */ case   28:  		/* b 644 */
		/* 820AD880h case   28:*/		return 0x820ADB04;
		/* 820AD880h case   28:*/		return 0x820AD884;
		  /* 820AD884h */ case   29:  		/* li R5, 2 */
		/* 820AD884h case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD884h case   29:*/		return 0x820AD888;
		  /* 820AD888h */ case   30:  		/* li R4, 3 */
		/* 820AD888h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 820AD888h case   30:*/		return 0x820AD88C;
		  /* 820AD88Ch */ case   31:  		/* b 632 */
		/* 820AD88Ch case   31:*/		return 0x820ADB04;
		/* 820AD88Ch case   31:*/		return 0x820AD890;
		  /* 820AD890h */ case   32:  		/* li R5, 1 */
		/* 820AD890h case   32:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD890h case   32:*/		return 0x820AD894;
		  /* 820AD894h */ case   33:  		/* li R4, 4 */
		/* 820AD894h case   33:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 820AD894h case   33:*/		return 0x820AD898;
		  /* 820AD898h */ case   34:  		/* b 620 */
		/* 820AD898h case   34:*/		return 0x820ADB04;
		/* 820AD898h case   34:*/		return 0x820AD89C;
		  /* 820AD89Ch */ case   35:  		/* li R5, 1 */
		/* 820AD89Ch case   35:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD89Ch case   35:*/		return 0x820AD8A0;
		  /* 820AD8A0h */ case   36:  		/* li R4, 5 */
		/* 820AD8A0h case   36:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 820AD8A0h case   36:*/		return 0x820AD8A4;
		  /* 820AD8A4h */ case   37:  		/* b 608 */
		/* 820AD8A4h case   37:*/		return 0x820ADB04;
		/* 820AD8A4h case   37:*/		return 0x820AD8A8;
		  /* 820AD8A8h */ case   38:  		/* li R4, 6 */
		/* 820AD8A8h case   38:*/		cpu::op::li<0>(regs,&regs.R4,0x6);
		/* 820AD8A8h case   38:*/		return 0x820AD8AC;
		  /* 820AD8ACh */ case   39:  		/* b 596 */
		/* 820AD8ACh case   39:*/		return 0x820ADB00;
		/* 820AD8ACh case   39:*/		return 0x820AD8B0;
		  /* 820AD8B0h */ case   40:  		/* li R5, 1 */
		/* 820AD8B0h case   40:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD8B0h case   40:*/		return 0x820AD8B4;
		  /* 820AD8B4h */ case   41:  		/* li R4, 7 */
		/* 820AD8B4h case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x7);
		/* 820AD8B4h case   41:*/		return 0x820AD8B8;
		  /* 820AD8B8h */ case   42:  		/* b 588 */
		/* 820AD8B8h case   42:*/		return 0x820ADB04;
		/* 820AD8B8h case   42:*/		return 0x820AD8BC;
		  /* 820AD8BCh */ case   43:  		/* li R5, 1 */
		/* 820AD8BCh case   43:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD8BCh case   43:*/		return 0x820AD8C0;
		  /* 820AD8C0h */ case   44:  		/* li R4, 8 */
		/* 820AD8C0h case   44:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 820AD8C0h case   44:*/		return 0x820AD8C4;
		  /* 820AD8C4h */ case   45:  		/* b 576 */
		/* 820AD8C4h case   45:*/		return 0x820ADB04;
		/* 820AD8C4h case   45:*/		return 0x820AD8C8;
		  /* 820AD8C8h */ case   46:  		/* li R5, 1 */
		/* 820AD8C8h case   46:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD8C8h case   46:*/		return 0x820AD8CC;
		  /* 820AD8CCh */ case   47:  		/* li R4, 9 */
		/* 820AD8CCh case   47:*/		cpu::op::li<0>(regs,&regs.R4,0x9);
		/* 820AD8CCh case   47:*/		return 0x820AD8D0;
		  /* 820AD8D0h */ case   48:  		/* b 564 */
		/* 820AD8D0h case   48:*/		return 0x820ADB04;
		/* 820AD8D0h case   48:*/		return 0x820AD8D4;
		  /* 820AD8D4h */ case   49:  		/* li R5, 1 */
		/* 820AD8D4h case   49:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD8D4h case   49:*/		return 0x820AD8D8;
		  /* 820AD8D8h */ case   50:  		/* li R4, 10 */
		/* 820AD8D8h case   50:*/		cpu::op::li<0>(regs,&regs.R4,0xA);
		/* 820AD8D8h case   50:*/		return 0x820AD8DC;
		  /* 820AD8DCh */ case   51:  		/* b 552 */
		/* 820AD8DCh case   51:*/		return 0x820ADB04;
		/* 820AD8DCh case   51:*/		return 0x820AD8E0;
		  /* 820AD8E0h */ case   52:  		/* li R5, 2 */
		/* 820AD8E0h case   52:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD8E0h case   52:*/		return 0x820AD8E4;
		  /* 820AD8E4h */ case   53:  		/* li R4, 11 */
		/* 820AD8E4h case   53:*/		cpu::op::li<0>(regs,&regs.R4,0xB);
		/* 820AD8E4h case   53:*/		return 0x820AD8E8;
		  /* 820AD8E8h */ case   54:  		/* b 540 */
		/* 820AD8E8h case   54:*/		return 0x820ADB04;
		/* 820AD8E8h case   54:*/		return 0x820AD8EC;
		  /* 820AD8ECh */ case   55:  		/* li R5, 1 */
		/* 820AD8ECh case   55:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD8ECh case   55:*/		return 0x820AD8F0;
		  /* 820AD8F0h */ case   56:  		/* li R4, 12 */
		/* 820AD8F0h case   56:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 820AD8F0h case   56:*/		return 0x820AD8F4;
		  /* 820AD8F4h */ case   57:  		/* b 528 */
		/* 820AD8F4h case   57:*/		return 0x820ADB04;
		/* 820AD8F4h case   57:*/		return 0x820AD8F8;
		  /* 820AD8F8h */ case   58:  		/* li R5, 2 */
		/* 820AD8F8h case   58:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD8F8h case   58:*/		return 0x820AD8FC;
		  /* 820AD8FCh */ case   59:  		/* li R4, 13 */
		/* 820AD8FCh case   59:*/		cpu::op::li<0>(regs,&regs.R4,0xD);
		/* 820AD8FCh case   59:*/		return 0x820AD900;
		  /* 820AD900h */ case   60:  		/* b 516 */
		/* 820AD900h case   60:*/		return 0x820ADB04;
		/* 820AD900h case   60:*/		return 0x820AD904;
		  /* 820AD904h */ case   61:  		/* li R5, 3 */
		/* 820AD904h case   61:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 820AD904h case   61:*/		return 0x820AD908;
		  /* 820AD908h */ case   62:  		/* li R4, 14 */
		/* 820AD908h case   62:*/		cpu::op::li<0>(regs,&regs.R4,0xE);
		/* 820AD908h case   62:*/		return 0x820AD90C;
		  /* 820AD90Ch */ case   63:  		/* b 504 */
		/* 820AD90Ch case   63:*/		return 0x820ADB04;
		/* 820AD90Ch case   63:*/		return 0x820AD910;
		  /* 820AD910h */ case   64:  		/* li R5, 4 */
		/* 820AD910h case   64:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820AD910h case   64:*/		return 0x820AD914;
		  /* 820AD914h */ case   65:  		/* li R4, 15 */
		/* 820AD914h case   65:*/		cpu::op::li<0>(regs,&regs.R4,0xF);
		/* 820AD914h case   65:*/		return 0x820AD918;
		  /* 820AD918h */ case   66:  		/* b 492 */
		/* 820AD918h case   66:*/		return 0x820ADB04;
		/* 820AD918h case   66:*/		return 0x820AD91C;
		  /* 820AD91Ch */ case   67:  		/* li R5, 5 */
		/* 820AD91Ch case   67:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 820AD91Ch case   67:*/		return 0x820AD920;
		  /* 820AD920h */ case   68:  		/* li R4, 16 */
		/* 820AD920h case   68:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820AD920h case   68:*/		return 0x820AD924;
		  /* 820AD924h */ case   69:  		/* b 480 */
		/* 820AD924h case   69:*/		return 0x820ADB04;
		/* 820AD924h case   69:*/		return 0x820AD928;
		  /* 820AD928h */ case   70:  		/* li R5, 6 */
		/* 820AD928h case   70:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 820AD928h case   70:*/		return 0x820AD92C;
		  /* 820AD92Ch */ case   71:  		/* li R4, 17 */
		/* 820AD92Ch case   71:*/		cpu::op::li<0>(regs,&regs.R4,0x11);
		/* 820AD92Ch case   71:*/		return 0x820AD930;
		  /* 820AD930h */ case   72:  		/* b 468 */
		/* 820AD930h case   72:*/		return 0x820ADB04;
		/* 820AD930h case   72:*/		return 0x820AD934;
		  /* 820AD934h */ case   73:  		/* li R5, 6 */
		/* 820AD934h case   73:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 820AD934h case   73:*/		return 0x820AD938;
		  /* 820AD938h */ case   74:  		/* li R4, 18 */
		/* 820AD938h case   74:*/		cpu::op::li<0>(regs,&regs.R4,0x12);
		/* 820AD938h case   74:*/		return 0x820AD93C;
		  /* 820AD93Ch */ case   75:  		/* b 456 */
		/* 820AD93Ch case   75:*/		return 0x820ADB04;
		/* 820AD93Ch case   75:*/		return 0x820AD940;
		  /* 820AD940h */ case   76:  		/* li R5, 6 */
		/* 820AD940h case   76:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 820AD940h case   76:*/		return 0x820AD944;
		  /* 820AD944h */ case   77:  		/* li R4, 19 */
		/* 820AD944h case   77:*/		cpu::op::li<0>(regs,&regs.R4,0x13);
		/* 820AD944h case   77:*/		return 0x820AD948;
		  /* 820AD948h */ case   78:  		/* b 444 */
		/* 820AD948h case   78:*/		return 0x820ADB04;
		/* 820AD948h case   78:*/		return 0x820AD94C;
		  /* 820AD94Ch */ case   79:  		/* li R5, 3 */
		/* 820AD94Ch case   79:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 820AD94Ch case   79:*/		return 0x820AD950;
		  /* 820AD950h */ case   80:  		/* li R4, 20 */
		/* 820AD950h case   80:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 820AD950h case   80:*/		return 0x820AD954;
		  /* 820AD954h */ case   81:  		/* b 432 */
		/* 820AD954h case   81:*/		return 0x820ADB04;
		/* 820AD954h case   81:*/		return 0x820AD958;
		  /* 820AD958h */ case   82:  		/* li R5, 2 */
		/* 820AD958h case   82:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD958h case   82:*/		return 0x820AD95C;
		  /* 820AD95Ch */ case   83:  		/* li R4, 21 */
		/* 820AD95Ch case   83:*/		cpu::op::li<0>(regs,&regs.R4,0x15);
		/* 820AD95Ch case   83:*/		return 0x820AD960;
		  /* 820AD960h */ case   84:  		/* b 420 */
		/* 820AD960h case   84:*/		return 0x820ADB04;
		/* 820AD960h case   84:*/		return 0x820AD964;
		  /* 820AD964h */ case   85:  		/* li R5, 3 */
		/* 820AD964h case   85:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 820AD964h case   85:*/		return 0x820AD968;
		  /* 820AD968h */ case   86:  		/* li R4, 22 */
		/* 820AD968h case   86:*/		cpu::op::li<0>(regs,&regs.R4,0x16);
		/* 820AD968h case   86:*/		return 0x820AD96C;
		  /* 820AD96Ch */ case   87:  		/* b 408 */
		/* 820AD96Ch case   87:*/		return 0x820ADB04;
		/* 820AD96Ch case   87:*/		return 0x820AD970;
		  /* 820AD970h */ case   88:  		/* li R5, 1 */
		/* 820AD970h case   88:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD970h case   88:*/		return 0x820AD974;
		  /* 820AD974h */ case   89:  		/* li R4, 23 */
		/* 820AD974h case   89:*/		cpu::op::li<0>(regs,&regs.R4,0x17);
		/* 820AD974h case   89:*/		return 0x820AD978;
		  /* 820AD978h */ case   90:  		/* b 396 */
		/* 820AD978h case   90:*/		return 0x820ADB04;
		/* 820AD978h case   90:*/		return 0x820AD97C;
		  /* 820AD97Ch */ case   91:  		/* li R5, 2 */
		/* 820AD97Ch case   91:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD97Ch case   91:*/		return 0x820AD980;
		  /* 820AD980h */ case   92:  		/* li R4, 24 */
		/* 820AD980h case   92:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820AD980h case   92:*/		return 0x820AD984;
		  /* 820AD984h */ case   93:  		/* b 384 */
		/* 820AD984h case   93:*/		return 0x820ADB04;
		/* 820AD984h case   93:*/		return 0x820AD988;
		  /* 820AD988h */ case   94:  		/* li R5, 1 */
		/* 820AD988h case   94:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD988h case   94:*/		return 0x820AD98C;
		  /* 820AD98Ch */ case   95:  		/* li R4, 25 */
		/* 820AD98Ch case   95:*/		cpu::op::li<0>(regs,&regs.R4,0x19);
		/* 820AD98Ch case   95:*/		return 0x820AD990;
		  /* 820AD990h */ case   96:  		/* b 372 */
		/* 820AD990h case   96:*/		return 0x820ADB04;
		/* 820AD990h case   96:*/		return 0x820AD994;
		  /* 820AD994h */ case   97:  		/* li R5, 1 */
		/* 820AD994h case   97:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD994h case   97:*/		return 0x820AD998;
		  /* 820AD998h */ case   98:  		/* li R4, 26 */
		/* 820AD998h case   98:*/		cpu::op::li<0>(regs,&regs.R4,0x1A);
		/* 820AD998h case   98:*/		return 0x820AD99C;
		  /* 820AD99Ch */ case   99:  		/* b 360 */
		/* 820AD99Ch case   99:*/		return 0x820ADB04;
		/* 820AD99Ch case   99:*/		return 0x820AD9A0;
		  /* 820AD9A0h */ case  100:  		/* li R5, 1 */
		/* 820AD9A0h case  100:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD9A0h case  100:*/		return 0x820AD9A4;
		  /* 820AD9A4h */ case  101:  		/* li R4, 27 */
		/* 820AD9A4h case  101:*/		cpu::op::li<0>(regs,&regs.R4,0x1B);
		/* 820AD9A4h case  101:*/		return 0x820AD9A8;
		  /* 820AD9A8h */ case  102:  		/* b 348 */
		/* 820AD9A8h case  102:*/		return 0x820ADB04;
		/* 820AD9A8h case  102:*/		return 0x820AD9AC;
		  /* 820AD9ACh */ case  103:  		/* li R5, 2 */
		/* 820AD9ACh case  103:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD9ACh case  103:*/		return 0x820AD9B0;
		  /* 820AD9B0h */ case  104:  		/* li R4, 28 */
		/* 820AD9B0h case  104:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 820AD9B0h case  104:*/		return 0x820AD9B4;
		  /* 820AD9B4h */ case  105:  		/* b 336 */
		/* 820AD9B4h case  105:*/		return 0x820ADB04;
		/* 820AD9B4h case  105:*/		return 0x820AD9B8;
		  /* 820AD9B8h */ case  106:  		/* li R5, 1 */
		/* 820AD9B8h case  106:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD9B8h case  106:*/		return 0x820AD9BC;
		  /* 820AD9BCh */ case  107:  		/* li R4, 29 */
		/* 820AD9BCh case  107:*/		cpu::op::li<0>(regs,&regs.R4,0x1D);
		/* 820AD9BCh case  107:*/		return 0x820AD9C0;
		  /* 820AD9C0h */ case  108:  		/* b 324 */
		/* 820AD9C0h case  108:*/		return 0x820ADB04;
		/* 820AD9C0h case  108:*/		return 0x820AD9C4;
		  /* 820AD9C4h */ case  109:  		/* li R5, 2 */
		/* 820AD9C4h case  109:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD9C4h case  109:*/		return 0x820AD9C8;
		  /* 820AD9C8h */ case  110:  		/* li R4, 30 */
		/* 820AD9C8h case  110:*/		cpu::op::li<0>(regs,&regs.R4,0x1E);
		/* 820AD9C8h case  110:*/		return 0x820AD9CC;
		  /* 820AD9CCh */ case  111:  		/* b 312 */
		/* 820AD9CCh case  111:*/		return 0x820ADB04;
		/* 820AD9CCh case  111:*/		return 0x820AD9D0;
		  /* 820AD9D0h */ case  112:  		/* li R5, 1 */
		/* 820AD9D0h case  112:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD9D0h case  112:*/		return 0x820AD9D4;
		  /* 820AD9D4h */ case  113:  		/* li R4, 33 */
		/* 820AD9D4h case  113:*/		cpu::op::li<0>(regs,&regs.R4,0x21);
		/* 820AD9D4h case  113:*/		return 0x820AD9D8;
		  /* 820AD9D8h */ case  114:  		/* b 300 */
		/* 820AD9D8h case  114:*/		return 0x820ADB04;
		/* 820AD9D8h case  114:*/		return 0x820AD9DC;
		  /* 820AD9DCh */ case  115:  		/* li R5, 2 */
		/* 820AD9DCh case  115:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD9DCh case  115:*/		return 0x820AD9E0;
		  /* 820AD9E0h */ case  116:  		/* li R4, 34 */
		/* 820AD9E0h case  116:*/		cpu::op::li<0>(regs,&regs.R4,0x22);
		/* 820AD9E0h case  116:*/		return 0x820AD9E4;
		  /* 820AD9E4h */ case  117:  		/* b 288 */
		/* 820AD9E4h case  117:*/		return 0x820ADB04;
		/* 820AD9E4h case  117:*/		return 0x820AD9E8;
		  /* 820AD9E8h */ case  118:  		/* li R5, 1 */
		/* 820AD9E8h case  118:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820AD9E8h case  118:*/		return 0x820AD9EC;
		  /* 820AD9ECh */ case  119:  		/* li R4, 35 */
		/* 820AD9ECh case  119:*/		cpu::op::li<0>(regs,&regs.R4,0x23);
		/* 820AD9ECh case  119:*/		return 0x820AD9F0;
		  /* 820AD9F0h */ case  120:  		/* b 276 */
		/* 820AD9F0h case  120:*/		return 0x820ADB04;
		/* 820AD9F0h case  120:*/		return 0x820AD9F4;
		  /* 820AD9F4h */ case  121:  		/* li R5, 2 */
		/* 820AD9F4h case  121:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 820AD9F4h case  121:*/		return 0x820AD9F8;
		  /* 820AD9F8h */ case  122:  		/* li R4, 36 */
		/* 820AD9F8h case  122:*/		cpu::op::li<0>(regs,&regs.R4,0x24);
		/* 820AD9F8h case  122:*/		return 0x820AD9FC;
		  /* 820AD9FCh */ case  123:  		/* b 264 */
		/* 820AD9FCh case  123:*/		return 0x820ADB04;
		/* 820AD9FCh case  123:*/		return 0x820ADA00;
		  /* 820ADA00h */ case  124:  		/* li R5, 1 */
		/* 820ADA00h case  124:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA00h case  124:*/		return 0x820ADA04;
		  /* 820ADA04h */ case  125:  		/* li R4, 37 */
		/* 820ADA04h case  125:*/		cpu::op::li<0>(regs,&regs.R4,0x25);
		/* 820ADA04h case  125:*/		return 0x820ADA08;
		  /* 820ADA08h */ case  126:  		/* b 252 */
		/* 820ADA08h case  126:*/		return 0x820ADB04;
		/* 820ADA08h case  126:*/		return 0x820ADA0C;
		  /* 820ADA0Ch */ case  127:  		/* li R5, 1 */
		/* 820ADA0Ch case  127:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA0Ch case  127:*/		return 0x820ADA10;
		  /* 820ADA10h */ case  128:  		/* li R4, 38 */
		/* 820ADA10h case  128:*/		cpu::op::li<0>(regs,&regs.R4,0x26);
		/* 820ADA10h case  128:*/		return 0x820ADA14;
		  /* 820ADA14h */ case  129:  		/* b 240 */
		/* 820ADA14h case  129:*/		return 0x820ADB04;
		/* 820ADA14h case  129:*/		return 0x820ADA18;
		  /* 820ADA18h */ case  130:  		/* li R4, 39 */
		/* 820ADA18h case  130:*/		cpu::op::li<0>(regs,&regs.R4,0x27);
		/* 820ADA18h case  130:*/		return 0x820ADA1C;
		  /* 820ADA1Ch */ case  131:  		/* b 228 */
		/* 820ADA1Ch case  131:*/		return 0x820ADB00;
		/* 820ADA1Ch case  131:*/		return 0x820ADA20;
		  /* 820ADA20h */ case  132:  		/* li R4, 40 */
		/* 820ADA20h case  132:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 820ADA20h case  132:*/		return 0x820ADA24;
		  /* 820ADA24h */ case  133:  		/* b 220 */
		/* 820ADA24h case  133:*/		return 0x820ADB00;
		/* 820ADA24h case  133:*/		return 0x820ADA28;
		  /* 820ADA28h */ case  134:  		/* li R5, 1 */
		/* 820ADA28h case  134:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA28h case  134:*/		return 0x820ADA2C;
		  /* 820ADA2Ch */ case  135:  		/* li R4, 41 */
		/* 820ADA2Ch case  135:*/		cpu::op::li<0>(regs,&regs.R4,0x29);
		/* 820ADA2Ch case  135:*/		return 0x820ADA30;
		  /* 820ADA30h */ case  136:  		/* b 212 */
		/* 820ADA30h case  136:*/		return 0x820ADB04;
		/* 820ADA30h case  136:*/		return 0x820ADA34;
		  /* 820ADA34h */ case  137:  		/* li R5, 1 */
		/* 820ADA34h case  137:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA34h case  137:*/		return 0x820ADA38;
		  /* 820ADA38h */ case  138:  		/* li R4, 42 */
		/* 820ADA38h case  138:*/		cpu::op::li<0>(regs,&regs.R4,0x2A);
		/* 820ADA38h case  138:*/		return 0x820ADA3C;
		  /* 820ADA3Ch */ case  139:  		/* b 200 */
		/* 820ADA3Ch case  139:*/		return 0x820ADB04;
		/* 820ADA3Ch case  139:*/		return 0x820ADA40;
		  /* 820ADA40h */ case  140:  		/* li R5, 1 */
		/* 820ADA40h case  140:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA40h case  140:*/		return 0x820ADA44;
		  /* 820ADA44h */ case  141:  		/* li R4, 43 */
		/* 820ADA44h case  141:*/		cpu::op::li<0>(regs,&regs.R4,0x2B);
		/* 820ADA44h case  141:*/		return 0x820ADA48;
		  /* 820ADA48h */ case  142:  		/* b 188 */
		/* 820ADA48h case  142:*/		return 0x820ADB04;
		/* 820ADA48h case  142:*/		return 0x820ADA4C;
		  /* 820ADA4Ch */ case  143:  		/* li R5, 1 */
		/* 820ADA4Ch case  143:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA4Ch case  143:*/		return 0x820ADA50;
		  /* 820ADA50h */ case  144:  		/* li R4, 44 */
		/* 820ADA50h case  144:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 820ADA50h case  144:*/		return 0x820ADA54;
		  /* 820ADA54h */ case  145:  		/* b 176 */
		/* 820ADA54h case  145:*/		return 0x820ADB04;
		/* 820ADA54h case  145:*/		return 0x820ADA58;
		  /* 820ADA58h */ case  146:  		/* li R5, 1 */
		/* 820ADA58h case  146:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA58h case  146:*/		return 0x820ADA5C;
		  /* 820ADA5Ch */ case  147:  		/* li R4, 45 */
		/* 820ADA5Ch case  147:*/		cpu::op::li<0>(regs,&regs.R4,0x2D);
		/* 820ADA5Ch case  147:*/		return 0x820ADA60;
		  /* 820ADA60h */ case  148:  		/* b 164 */
		/* 820ADA60h case  148:*/		return 0x820ADB04;
		/* 820ADA60h case  148:*/		return 0x820ADA64;
		  /* 820ADA64h */ case  149:  		/* li R5, 1 */
		/* 820ADA64h case  149:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA64h case  149:*/		return 0x820ADA68;
		  /* 820ADA68h */ case  150:  		/* li R4, 46 */
		/* 820ADA68h case  150:*/		cpu::op::li<0>(regs,&regs.R4,0x2E);
		/* 820ADA68h case  150:*/		return 0x820ADA6C;
		  /* 820ADA6Ch */ case  151:  		/* b 152 */
		/* 820ADA6Ch case  151:*/		return 0x820ADB04;
		/* 820ADA6Ch case  151:*/		return 0x820ADA70;
		  /* 820ADA70h */ case  152:  		/* li R5, 1 */
		/* 820ADA70h case  152:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA70h case  152:*/		return 0x820ADA74;
		  /* 820ADA74h */ case  153:  		/* li R4, 47 */
		/* 820ADA74h case  153:*/		cpu::op::li<0>(regs,&regs.R4,0x2F);
		/* 820ADA74h case  153:*/		return 0x820ADA78;
		  /* 820ADA78h */ case  154:  		/* b 140 */
		/* 820ADA78h case  154:*/		return 0x820ADB04;
		/* 820ADA78h case  154:*/		return 0x820ADA7C;
		  /* 820ADA7Ch */ case  155:  		/* li R5, 1 */
		/* 820ADA7Ch case  155:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA7Ch case  155:*/		return 0x820ADA80;
		  /* 820ADA80h */ case  156:  		/* li R4, 48 */
		/* 820ADA80h case  156:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 820ADA80h case  156:*/		return 0x820ADA84;
		  /* 820ADA84h */ case  157:  		/* b 128 */
		/* 820ADA84h case  157:*/		return 0x820ADB04;
		/* 820ADA84h case  157:*/		return 0x820ADA88;
		  /* 820ADA88h */ case  158:  		/* li R5, 1 */
		/* 820ADA88h case  158:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820ADA88h case  158:*/		return 0x820ADA8C;
		  /* 820ADA8Ch */ case  159:  		/* li R4, 49 */
		/* 820ADA8Ch case  159:*/		cpu::op::li<0>(regs,&regs.R4,0x31);
		/* 820ADA8Ch case  159:*/		return 0x820ADA90;
		  /* 820ADA90h */ case  160:  		/* b 116 */
		/* 820ADA90h case  160:*/		return 0x820ADB04;
		/* 820ADA90h case  160:*/		return 0x820ADA94;
		  /* 820ADA94h */ case  161:  		/* li R4, 50 */
		/* 820ADA94h case  161:*/		cpu::op::li<0>(regs,&regs.R4,0x32);
		/* 820ADA94h case  161:*/		return 0x820ADA98;
		  /* 820ADA98h */ case  162:  		/* b 104 */
		/* 820ADA98h case  162:*/		return 0x820ADB00;
		/* 820ADA98h case  162:*/		return 0x820ADA9C;
		  /* 820ADA9Ch */ case  163:  		/* li R4, 51 */
		/* 820ADA9Ch case  163:*/		cpu::op::li<0>(regs,&regs.R4,0x33);
		/* 820ADA9Ch case  163:*/		return 0x820ADAA0;
		  /* 820ADAA0h */ case  164:  		/* b 96 */
		/* 820ADAA0h case  164:*/		return 0x820ADB00;
		/* 820ADAA0h case  164:*/		return 0x820ADAA4;
		  /* 820ADAA4h */ case  165:  		/* li R4, 52 */
		/* 820ADAA4h case  165:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 820ADAA4h case  165:*/		return 0x820ADAA8;
		  /* 820ADAA8h */ case  166:  		/* b 88 */
		/* 820ADAA8h case  166:*/		return 0x820ADB00;
		/* 820ADAA8h case  166:*/		return 0x820ADAAC;
		  /* 820ADAACh */ case  167:  		/* li R4, 53 */
		/* 820ADAACh case  167:*/		cpu::op::li<0>(regs,&regs.R4,0x35);
		/* 820ADAACh case  167:*/		return 0x820ADAB0;
		  /* 820ADAB0h */ case  168:  		/* b 80 */
		/* 820ADAB0h case  168:*/		return 0x820ADB00;
		/* 820ADAB0h case  168:*/		return 0x820ADAB4;
		  /* 820ADAB4h */ case  169:  		/* li R4, 54 */
		/* 820ADAB4h case  169:*/		cpu::op::li<0>(regs,&regs.R4,0x36);
		/* 820ADAB4h case  169:*/		return 0x820ADAB8;
		  /* 820ADAB8h */ case  170:  		/* b 72 */
		/* 820ADAB8h case  170:*/		return 0x820ADB00;
		/* 820ADAB8h case  170:*/		return 0x820ADABC;
		  /* 820ADABCh */ case  171:  		/* li R4, 55 */
		/* 820ADABCh case  171:*/		cpu::op::li<0>(regs,&regs.R4,0x37);
		/* 820ADABCh case  171:*/		return 0x820ADAC0;
		  /* 820ADAC0h */ case  172:  		/* b 64 */
		/* 820ADAC0h case  172:*/		return 0x820ADB00;
		/* 820ADAC0h case  172:*/		return 0x820ADAC4;
		  /* 820ADAC4h */ case  173:  		/* li R4, 56 */
		/* 820ADAC4h case  173:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 820ADAC4h case  173:*/		return 0x820ADAC8;
		  /* 820ADAC8h */ case  174:  		/* b 56 */
		/* 820ADAC8h case  174:*/		return 0x820ADB00;
		/* 820ADAC8h case  174:*/		return 0x820ADACC;
		  /* 820ADACCh */ case  175:  		/* li R4, 57 */
		/* 820ADACCh case  175:*/		cpu::op::li<0>(regs,&regs.R4,0x39);
		/* 820ADACCh case  175:*/		return 0x820ADAD0;
		  /* 820ADAD0h */ case  176:  		/* b 48 */
		/* 820ADAD0h case  176:*/		return 0x820ADB00;
		/* 820ADAD0h case  176:*/		return 0x820ADAD4;
		  /* 820ADAD4h */ case  177:  		/* li R4, 58 */
		/* 820ADAD4h case  177:*/		cpu::op::li<0>(regs,&regs.R4,0x3A);
		/* 820ADAD4h case  177:*/		return 0x820ADAD8;
		  /* 820ADAD8h */ case  178:  		/* b 40 */
		/* 820ADAD8h case  178:*/		return 0x820ADB00;
		/* 820ADAD8h case  178:*/		return 0x820ADADC;
		  /* 820ADADCh */ case  179:  		/* li R4, 59 */
		/* 820ADADCh case  179:*/		cpu::op::li<0>(regs,&regs.R4,0x3B);
		/* 820ADADCh case  179:*/		return 0x820ADAE0;
		  /* 820ADAE0h */ case  180:  		/* b 32 */
		/* 820ADAE0h case  180:*/		return 0x820ADB00;
		/* 820ADAE0h case  180:*/		return 0x820ADAE4;
		  /* 820ADAE4h */ case  181:  		/* li R4, 60 */
		/* 820ADAE4h case  181:*/		cpu::op::li<0>(regs,&regs.R4,0x3C);
		/* 820ADAE4h case  181:*/		return 0x820ADAE8;
		  /* 820ADAE8h */ case  182:  		/* b 24 */
		/* 820ADAE8h case  182:*/		return 0x820ADB00;
		/* 820ADAE8h case  182:*/		return 0x820ADAEC;
		  /* 820ADAECh */ case  183:  		/* li R4, 61 */
		/* 820ADAECh case  183:*/		cpu::op::li<0>(regs,&regs.R4,0x3D);
		/* 820ADAECh case  183:*/		return 0x820ADAF0;
		  /* 820ADAF0h */ case  184:  		/* b 16 */
		/* 820ADAF0h case  184:*/		return 0x820ADB00;
		/* 820ADAF0h case  184:*/		return 0x820ADAF4;
		  /* 820ADAF4h */ case  185:  		/* li R4, 62 */
		/* 820ADAF4h case  185:*/		cpu::op::li<0>(regs,&regs.R4,0x3E);
		/* 820ADAF4h case  185:*/		return 0x820ADAF8;
		  /* 820ADAF8h */ case  186:  		/* b 8 */
		/* 820ADAF8h case  186:*/		return 0x820ADB00;
		/* 820ADAF8h case  186:*/		return 0x820ADAFC;
		  /* 820ADAFCh */ case  187:  		/* li R4, 63 */
		/* 820ADAFCh case  187:*/		cpu::op::li<0>(regs,&regs.R4,0x3F);
		/* 820ADAFCh case  187:*/		return 0x820ADB00;
	}
	return 0x820ADB00;
} // Block from 820AD810h-820ADB00h (188 instructions)

//////////////////////////////////////////////////////
// Block at 820ADB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADB00);
		  /* 820ADB00h */ case    0:  		/* li R5, 0 */
		/* 820ADB00h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ADB00h case    0:*/		return 0x820ADB04;
	}
	return 0x820ADB04;
} // Block from 820ADB00h-820ADB04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ADB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADB04);
		  /* 820ADB04h */ case    0:  		/* lwz R3, <#[R31 + 3032]> */
		/* 820ADB04h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000BD8) );
		/* 820ADB04h case    0:*/		return 0x820ADB08;
		  /* 820ADB08h */ case    1:  		/* bl -8368 */
		/* 820ADB08h case    1:*/		regs.LR = 0x820ADB0C; return 0x820ABA58;
		/* 820ADB08h case    1:*/		return 0x820ADB0C;
	}
	return 0x820ADB0C;
} // Block from 820ADB04h-820ADB0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ADB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADB0C);
		  /* 820ADB0Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820ADB0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADB0Ch case    0:*/		return 0x820ADB10;
		  /* 820ADB10h */ case    1:  		/* rlwinm R10, R29, 1, 0, 30 */
		/* 820ADB10h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R29);
		/* 820ADB10h case    1:*/		return 0x820ADB14;
		  /* 820ADB14h */ case    2:  		/* lwz R9, <#[R31 + 20]> */
		/* 820ADB14h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADB14h case    2:*/		return 0x820ADB18;
		  /* 820ADB18h */ case    3:  		/* subf R11, R10, R11 */
		/* 820ADB18h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820ADB18h case    3:*/		return 0x820ADB1C;
		  /* 820ADB1Ch */ case    4:  		/* subf R10, R28, R9 */
		/* 820ADB1Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R9);
		/* 820ADB1Ch case    4:*/		return 0x820ADB20;
		  /* 820ADB20h */ case    5:  		/* stw R11, <#[R31 + 16]> */
		/* 820ADB20h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADB20h case    5:*/		return 0x820ADB24;
		  /* 820ADB24h */ case    6:  		/* lha R11, <#[R11]> */
		/* 820ADB24h case    6:*/		cpu::mem::load16a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADB24h case    6:*/		return 0x820ADB28;
		  /* 820ADB28h */ case    7:  		/* stw R10, <#[R31 + 20]> */
		/* 820ADB28h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADB28h case    7:*/		return 0x820ADB2C;
		  /* 820ADB2Ch */ case    8:  		/* lhax R10, <#[R30 + R27]> */
		/* 820ADB2Ch case    8:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R30 + regs.R27 + 0x00000000) );
		/* 820ADB2Ch case    8:*/		return 0x820ADB30;
		  /* 820ADB30h */ case    9:  		/* cmpwi CR0, R11, 0 */
		/* 820ADB30h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 820ADB30h case    9:*/		return 0x820ADB34;
		  /* 820ADB34h */ case   10:  		/* bc 4, CR0_EQ, 112 */
		/* 820ADB34h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820ADBA4;  }
		/* 820ADB34h case   10:*/		return 0x820ADB38;
		  /* 820ADB38h */ case   11:  		/* cmpwi CR6, R10, 0 */
		/* 820ADB38h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820ADB38h case   11:*/		return 0x820ADB3C;
		  /* 820ADB3Ch */ case   12:  		/* bc 4, CR6_EQ, 104 */
		/* 820ADB3Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820ADBA4;  }
		/* 820ADB3Ch case   12:*/		return 0x820ADB40;
		  /* 820ADB40h */ case   13:  		/* lwz R11, <#[R31 + 16]> */
		/* 820ADB40h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADB40h case   13:*/		return 0x820ADB44;
		  /* 820ADB44h */ case   14:  		/* li R10, 16 */
		/* 820ADB44h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 820ADB44h case   14:*/		return 0x820ADB48;
		  /* 820ADB48h */ case   15:  		/* li R30, 16 */
		/* 820ADB48h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x10);
		/* 820ADB48h case   15:*/		return 0x820ADB4C;
		  /* 820ADB4Ch */ case   16:  		/* addi R11, R11, 2 */
		/* 820ADB4Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820ADB4Ch case   16:*/		return 0x820ADB50;
		  /* 820ADB50h */ case   17:  		/* stw R11, <#[R31 + 16]> */
		/* 820ADB50h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADB50h case   17:*/		return 0x820ADB54;
		  /* 820ADB54h */ case   18:  		/* sth R10, <#[R11]> */
		/* 820ADB54h case   18:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADB54h case   18:*/		return 0x820ADB58;
		  /* 820ADB58h */ case   19:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ADB58h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADB58h case   19:*/		return 0x820ADB5C;
		  /* 820ADB5Ch */ case   20:  		/* lwz R11, <#[R31 + 20]> */
		/* 820ADB5Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADB5Ch case   20:*/		return 0x820ADB60;
		  /* 820ADB60h */ case   21:  		/* addi R11, R11, 4 */
		/* 820ADB60h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820ADB60h case   21:*/		return 0x820ADB64;
		  /* 820ADB64h */ case   22:  		/* stw R11, <#[R31 + 20]> */
		/* 820ADB64h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADB64h case   22:*/		return 0x820ADB68;
		  /* 820ADB68h */ case   23:  		/* stw R10, <#[R11]> */
		/* 820ADB68h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADB68h case   23:*/		return 0x820ADB6C;
		  /* 820ADB6Ch */ case   24:  		/* lwz R11, <#[R31 + 12]> */
		/* 820ADB6Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820ADB6Ch case   24:*/		return 0x820ADB70;
		  /* 820ADB70h */ case   25:  		/* cmpwi CR6, R11, 0 */
		/* 820ADB70h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ADB70h case   25:*/		return 0x820ADB74;
		  /* 820ADB74h */ case   26:  		/* bc 4, CR6_LT, 28 */
		/* 820ADB74h case   26:*/		if ( !regs.CR[6].lt ) { return 0x820ADB90;  }
		/* 820ADB74h case   26:*/		return 0x820ADB78;
		  /* 820ADB78h */ case   27:  		/* lwz R3, <#[R31 + 3032]> */
		/* 820ADB78h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000BD8) );
		/* 820ADB78h case   27:*/		return 0x820ADB7C;
		  /* 820ADB7Ch */ case   28:  		/* bl -1628 */
		/* 820ADB7Ch case   28:*/		regs.LR = 0x820ADB80; return 0x820AD520;
		/* 820ADB7Ch case   28:*/		return 0x820ADB80;
		  /* 820ADB80h */ case   29:  		/* stw R3, <#[R31 + 12]> */
		/* 820ADB80h case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820ADB80h case   29:*/		return 0x820ADB84;
		  /* 820ADB84h */ case   30:  		/* cmpwi CR0, R3, 0 */
		/* 820ADB84h case   30:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ADB84h case   30:*/		return 0x820ADB88;
		  /* 820ADB88h */ case   31:  		/* bc 4, CR0_LT, 8 */
		/* 820ADB88h case   31:*/		if ( !regs.CR[0].lt ) { return 0x820ADB90;  }
		/* 820ADB88h case   31:*/		return 0x820ADB8C;
		  /* 820ADB8Ch */ case   32:  		/* stw R25, <#[R31 + 12]> */
		/* 820ADB8Ch case   32:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000000C) );
		/* 820ADB8Ch case   32:*/		return 0x820ADB90;
	}
	return 0x820ADB90;
} // Block from 820ADB0Ch-820ADB90h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820ADB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADB90);
		  /* 820ADB90h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820ADB90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820ADB90h case    0:*/		return 0x820ADB94;
		  /* 820ADB94h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820ADB94h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ADB94h case    1:*/		return 0x820ADB98;
		  /* 820ADB98h */ case    2:  		/* bc 4, CR6_EQ, -1164 */
		/* 820ADB98h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AD70C;  }
		/* 820ADB98h case    2:*/		return 0x820ADB9C;
		  /* 820ADB9Ch */ case    3:  		/* li R3, 0 */
		/* 820ADB9Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820ADB9Ch case    3:*/		return 0x820ADBA0;
		  /* 820ADBA0h */ case    4:  		/* b 364 */
		/* 820ADBA0h case    4:*/		return 0x820ADD0C;
		/* 820ADBA0h case    4:*/		return 0x820ADBA4;
	}
	return 0x820ADBA4;
} // Block from 820ADB90h-820ADBA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ADBA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADBA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADBA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADBA4);
		  /* 820ADBA4h */ case    0:  		/* rlwinm R9, R10, 1, 0, 30 */
		/* 820ADBA4h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R10);
		/* 820ADBA4h case    0:*/		return 0x820ADBA8;
		  /* 820ADBA8h */ case    1:  		/* addi R10, R27, 1112 */
		/* 820ADBA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x458);
		/* 820ADBA8h case    1:*/		return 0x820ADBAC;
		  /* 820ADBACh */ case    2:  		/* lhax R10, <#[R9 + R10]> */
		/* 820ADBACh case    2:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820ADBACh case    2:*/		return 0x820ADBB0;
		  /* 820ADBB0h */ case    3:  		/* cmpwi CR0, R10, 0 */
		/* 820ADBB0h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 820ADBB0h case    3:*/		return 0x820ADBB4;
		  /* 820ADBB4h */ case    4:  		/* bc 12, CR0_EQ, 52 */
		/* 820ADBB4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820ADBE8;  }
		/* 820ADBB4h case    4:*/		return 0x820ADBB8;
		  /* 820ADBB8h */ case    5:  		/* add. R10, R10, R11 */
		/* 820ADBB8h case    5:*/		cpu::op::add<1>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820ADBB8h case    5:*/		return 0x820ADBBC;
		  /* 820ADBBCh */ case    6:  		/* bc 12, CR0_LT, 44 */
		/* 820ADBBCh case    6:*/		if ( regs.CR[0].lt ) { return 0x820ADBE8;  }
		/* 820ADBBCh case    6:*/		return 0x820ADBC0;
		  /* 820ADBC0h */ case    7:  		/* cmpwi CR6, R10, 295 */
		/* 820ADBC0h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000127);
		/* 820ADBC0h case    7:*/		return 0x820ADBC4;
		  /* 820ADBC4h */ case    8:  		/* bc 12, CR6_GT, 36 */
		/* 820ADBC4h case    8:*/		if ( regs.CR[6].gt ) { return 0x820ADBE8;  }
		/* 820ADBC4h case    8:*/		return 0x820ADBC8;
		  /* 820ADBC8h */ case    9:  		/* addi R8, R27, 1768 */
		/* 820ADBC8h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0x6E8);
		/* 820ADBC8h case    9:*/		return 0x820ADBCC;
		  /* 820ADBCCh */ case   10:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 820ADBCCh case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 820ADBCCh case   10:*/		return 0x820ADBD0;
		  /* 820ADBD0h */ case   11:  		/* lhax R8, <#[R10 + R8]> */
		/* 820ADBD0h case   11:*/		cpu::mem::load16a( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820ADBD0h case   11:*/		return 0x820ADBD4;
		  /* 820ADBD4h */ case   12:  		/* cmpw CR6, R8, R11 */
		/* 820ADBD4h case   12:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R11);
		/* 820ADBD4h case   12:*/		return 0x820ADBD8;
		  /* 820ADBD8h */ case   13:  		/* bc 4, CR6_EQ, 16 */
		/* 820ADBD8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820ADBE8;  }
		/* 820ADBD8h case   13:*/		return 0x820ADBDC;
		  /* 820ADBDCh */ case   14:  		/* addi R11, R27, 1176 */
		/* 820ADBDCh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x498);
		/* 820ADBDCh case   14:*/		return 0x820ADBE0;
		  /* 820ADBE0h */ case   15:  		/* lhax R30, <#[R10 + R11]> */
		/* 820ADBE0h case   15:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820ADBE0h case   15:*/		return 0x820ADBE4;
		  /* 820ADBE4h */ case   16:  		/* b 12 */
		/* 820ADBE4h case   16:*/		return 0x820ADBF0;
		/* 820ADBE4h case   16:*/		return 0x820ADBE8;
	}
	return 0x820ADBE8;
} // Block from 820ADBA4h-820ADBE8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820ADBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADBE8);
		  /* 820ADBE8h */ case    0:  		/* addi R11, R27, 520 */
		/* 820ADBE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x208);
		/* 820ADBE8h case    0:*/		return 0x820ADBEC;
		  /* 820ADBECh */ case    1:  		/* lhax R30, <#[R9 + R11]> */
		/* 820ADBECh case    1:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820ADBECh case    1:*/		return 0x820ADBF0;
	}
	return 0x820ADBF0;
} // Block from 820ADBE8h-820ADBF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ADBF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADBF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADBF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADBF0);
		  /* 820ADBF0h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820ADBF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADBF0h case    0:*/		return 0x820ADBF4;
		  /* 820ADBF4h */ case    1:  		/* addi R10, R31, 1030 */
		/* 820ADBF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x406);
		/* 820ADBF4h case    1:*/		return 0x820ADBF8;
		  /* 820ADBF8h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820ADBF8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ADBF8h case    2:*/		return 0x820ADBFC;
		  /* 820ADBFCh */ case    3:  		/* bc 4, CR6_LT, 252 */
		/* 820ADBFCh case    3:*/		if ( !regs.CR[6].lt ) { return 0x820ADCF8;  }
		/* 820ADBFCh case    3:*/		return 0x820ADC00;
		  /* 820ADC00h */ case    4:  		/* addi R11, R11, 2 */
		/* 820ADC00h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820ADC00h case    4:*/		return 0x820ADC04;
		  /* 820ADC04h */ case    5:  		/* stw R11, <#[R31 + 16]> */
		/* 820ADC04h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADC04h case    5:*/		return 0x820ADC08;
		  /* 820ADC08h */ case    6:  		/* sth R30, <#[R11]> */
		/* 820ADC08h case    6:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADC08h case    6:*/		return 0x820ADC0C;
		  /* 820ADC0Ch */ case    7:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ADC0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADC0Ch case    7:*/		return 0x820ADC10;
		  /* 820ADC10h */ case    8:  		/* lwz R11, <#[R31 + 20]> */
		/* 820ADC10h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADC10h case    8:*/		return 0x820ADC14;
		  /* 820ADC14h */ case    9:  		/* addi R11, R11, 4 */
		/* 820ADC14h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820ADC14h case    9:*/		return 0x820ADC18;
		  /* 820ADC18h */ case   10:  		/* stw R11, <#[R31 + 20]> */
		/* 820ADC18h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADC18h case   10:*/		return 0x820ADC1C;
		  /* 820ADC1Ch */ case   11:  		/* stw R10, <#[R11]> */
		/* 820ADC1Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADC1Ch case   11:*/		return 0x820ADC20;
		  /* 820ADC20h */ case   12:  		/* b -1300 */
		/* 820ADC20h case   12:*/		return 0x820AD70C;
		/* 820ADC20h case   12:*/		return 0x820ADC24;
	}
	return 0x820ADC24;
} // Block from 820ADBF0h-820ADC24h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820ADC24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADC24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADC24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADC24);
		  /* 820ADC24h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820ADC24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820ADC24h case    0:*/		return 0x820ADC28;
		  /* 820ADC28h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820ADC28h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ADC28h case    1:*/		return 0x820ADC2C;
		  /* 820ADC2Ch */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 820ADC2Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820ADC48;  }
		/* 820ADC2Ch case    2:*/		return 0x820ADC30;
		  /* 820ADC30h */ case    3:  		/* mr R4, R23 */
		/* 820ADC30h case    3:*/		regs.R4 = regs.R23;
		/* 820ADC30h case    3:*/		return 0x820ADC34;
		  /* 820ADC34h */ case    4:  		/* mr R3, R31 */
		/* 820ADC34h case    4:*/		regs.R3 = regs.R31;
		/* 820ADC34h case    4:*/		return 0x820ADC38;
		  /* 820ADC38h */ case    5:  		/* bl -6768 */
		/* 820ADC38h case    5:*/		regs.LR = 0x820ADC3C; return 0x820AC1C8;
		/* 820ADC38h case    5:*/		return 0x820ADC3C;
		  /* 820ADC3Ch */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 820ADC3Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820ADC3Ch case    6:*/		return 0x820ADC40;
		  /* 820ADC40h */ case    7:  		/* addi R11, R11, 1 */
		/* 820ADC40h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ADC40h case    7:*/		return 0x820ADC44;
		  /* 820ADC44h */ case    8:  		/* stw R11, <#[R31 + 4]> */
		/* 820ADC44h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820ADC44h case    8:*/		return 0x820ADC48;
	}
	return 0x820ADC48;
} // Block from 820ADC24h-820ADC48h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820ADC48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADC48);
		  /* 820ADC48h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820ADC48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820ADC48h case    0:*/		return 0x820ADC4C;
		  /* 820ADC4Ch */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 820ADC4Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820ADC4Ch case    1:*/		return 0x820ADC50;
		  /* 820ADC50h */ case    2:  		/* bc 4, CR6_LT, 148 */
		/* 820ADC50h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820ADCE4;  }
		/* 820ADC50h case    2:*/		return 0x820ADC54;
		  /* 820ADC54h */ case    3:  		/* li R11, 3 */
		/* 820ADC54h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820ADC54h case    3:*/		return 0x820ADC58;
		  /* 820ADC58h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 820ADC58h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820ADC58h case    4:*/		return 0x820ADC5C;
		  /* 820ADC5Ch */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 820ADC5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADC5Ch case    5:*/		return 0x820ADC60;
		  /* 820ADC60h */ case    6:  		/* addi R10, R27, 584 */
		/* 820ADC60h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x248);
		/* 820ADC60h case    6:*/		return 0x820ADC64;
		  /* 820ADC64h */ case    7:  		/* lha R9, <#[R11]> */
		/* 820ADC64h case    7:*/		cpu::mem::load16a( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADC64h case    7:*/		return 0x820ADC68;
		  /* 820ADC68h */ case    8:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 820ADC68h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 820ADC68h case    8:*/		return 0x820ADC6C;
		  /* 820ADC6Ch */ case    9:  		/* lhax R10, <#[R9 + R10]> */
		/* 820ADC6Ch case    9:*/		cpu::mem::load16a( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820ADC6Ch case    9:*/		return 0x820ADC70;
		  /* 820ADC70h */ case   10:  		/* cmpwi CR0, R10, 0 */
		/* 820ADC70h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 820ADC70h case   10:*/		return 0x820ADC74;
		  /* 820ADC74h */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 820ADC74h case   11:*/		if ( regs.CR[0].eq ) { return 0x820ADC9C;  }
		/* 820ADC74h case   11:*/		return 0x820ADC78;
		  /* 820ADC78h */ case   12:  		/* addic. R10, R10, 256 */
		/* 820ADC78h case   12:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0x100);
		/* 820ADC78h case   12:*/		return 0x820ADC7C;
		  /* 820ADC7Ch */ case   13:  		/* bc 12, CR0_LT, 32 */
		/* 820ADC7Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820ADC9C;  }
		/* 820ADC7Ch case   13:*/		return 0x820ADC80;
		  /* 820ADC80h */ case   14:  		/* cmpwi CR6, R10, 295 */
		/* 820ADC80h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000127);
		/* 820ADC80h case   14:*/		return 0x820ADC84;
		  /* 820ADC84h */ case   15:  		/* bc 12, CR6_GT, 24 */
		/* 820ADC84h case   15:*/		if ( regs.CR[6].gt ) { return 0x820ADC9C;  }
		/* 820ADC84h case   15:*/		return 0x820ADC88;
		  /* 820ADC88h */ case   16:  		/* addi R9, R27, 1768 */
		/* 820ADC88h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x6E8);
		/* 820ADC88h case   16:*/		return 0x820ADC8C;
		  /* 820ADC8Ch */ case   17:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 820ADC8Ch case   17:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 820ADC8Ch case   17:*/		return 0x820ADC90;
		  /* 820ADC90h */ case   18:  		/* lhzx R9, <#[R10 + R9]> */
		/* 820ADC90h case   18:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820ADC90h case   18:*/		return 0x820ADC94;
		  /* 820ADC94h */ case   19:  		/* cmplwi CR6, R9, 256 */
		/* 820ADC94h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000100);
		/* 820ADC94h case   19:*/		return 0x820ADC98;
		  /* 820ADC98h */ case   20:  		/* bc 12, CR6_EQ, 36 */
		/* 820ADC98h case   20:*/		if ( regs.CR[6].eq ) { return 0x820ADCBC;  }
		/* 820ADC98h case   20:*/		return 0x820ADC9C;
	}
	return 0x820ADC9C;
} // Block from 820ADC48h-820ADC9Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820ADC9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADC9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADC9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADC9C);
		  /* 820ADC9Ch */ case    0:  		/* cmplw CR6, R11, R24 */
		/* 820ADC9Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 820ADC9Ch case    0:*/		return 0x820ADCA0;
		  /* 820ADCA0h */ case    1:  		/* bc 4, CR6_GT, 104 */
		/* 820ADCA0h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820ADD08;  }
		/* 820ADCA0h case    1:*/		return 0x820ADCA4;
		  /* 820ADCA4h */ case    2:  		/* lwz R10, <#[R31 + 20]> */
		/* 820ADCA4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADCA4h case    2:*/		return 0x820ADCA8;
		  /* 820ADCA8h */ case    3:  		/* addi R11, R11, -2 */
		/* 820ADCA8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 820ADCA8h case    3:*/		return 0x820ADCAC;
		  /* 820ADCACh */ case    4:  		/* addi R10, R10, -4 */
		/* 820ADCACh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820ADCACh case    4:*/		return 0x820ADCB0;
		  /* 820ADCB0h */ case    5:  		/* stw R11, <#[R31 + 16]> */
		/* 820ADCB0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADCB0h case    5:*/		return 0x820ADCB4;
		  /* 820ADCB4h */ case    6:  		/* stw R10, <#[R31 + 20]> */
		/* 820ADCB4h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820ADCB4h case    6:*/		return 0x820ADCB8;
		  /* 820ADCB8h */ case    7:  		/* b -92 */
		/* 820ADCB8h case    7:*/		return 0x820ADC5C;
		/* 820ADCB8h case    7:*/		return 0x820ADCBC;
	}
	return 0x820ADCBC;
} // Block from 820ADC9Ch-820ADCBCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820ADCBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADCBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADCBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADCBC);
		  /* 820ADCBCh */ case    0:  		/* addi R9, R31, 1030 */
		/* 820ADCBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x406);
		/* 820ADCBCh case    0:*/		return 0x820ADCC0;
		  /* 820ADCC0h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 820ADCC0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820ADCC0h case    1:*/		return 0x820ADCC4;
		  /* 820ADCC4h */ case    2:  		/* bc 4, CR6_LT, 52 */
		/* 820ADCC4h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820ADCF8;  }
		/* 820ADCC4h case    2:*/		return 0x820ADCC8;
		  /* 820ADCC8h */ case    3:  		/* addi R9, R27, 1176 */
		/* 820ADCC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x498);
		/* 820ADCC8h case    3:*/		return 0x820ADCCC;
		  /* 820ADCCCh */ case    4:  		/* addi R11, R11, 2 */
		/* 820ADCCCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820ADCCCh case    4:*/		return 0x820ADCD0;
		  /* 820ADCD0h */ case    5:  		/* lhax R30, <#[R10 + R9]> */
		/* 820ADCD0h case    5:*/		cpu::mem::load16a( regs, &regs.R30, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820ADCD0h case    5:*/		return 0x820ADCD4;
		  /* 820ADCD4h */ case    6:  		/* stw R11, <#[R31 + 16]> */
		/* 820ADCD4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADCD4h case    6:*/		return 0x820ADCD8;
		  /* 820ADCD8h */ case    7:  		/* sth R30, <#[R11]> */
		/* 820ADCD8h case    7:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADCD8h case    7:*/		return 0x820ADCDC;
		  /* 820ADCDCh */ case    8:  		/* lwz R10, <#[R31 + 28]> */
		/* 820ADCDCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820ADCDCh case    8:*/		return 0x820ADCE0;
		  /* 820ADCE0h */ case    9:  		/* b -208 */
		/* 820ADCE0h case    9:*/		return 0x820ADC10;
		/* 820ADCE0h case    9:*/		return 0x820ADCE4;
	}
	return 0x820ADCE4;
} // Block from 820ADCBCh-820ADCE4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ADCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADCE4);
		  /* 820ADCE4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820ADCE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820ADCE4h case    0:*/		return 0x820ADCE8;
		  /* 820ADCE8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820ADCE8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820ADCE8h case    1:*/		return 0x820ADCEC;
		  /* 820ADCECh */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820ADCECh case    2:*/		if ( regs.CR[6].eq ) { return 0x820ADD08;  }
		/* 820ADCECh case    2:*/		return 0x820ADCF0;
		  /* 820ADCF0h */ case    3:  		/* stw R26, <#[R31 + 12]> */
		/* 820ADCF0h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000000C) );
		/* 820ADCF0h case    3:*/		return 0x820ADCF4;
		  /* 820ADCF4h */ case    4:  		/* b -1512 */
		/* 820ADCF4h case    4:*/		return 0x820AD70C;
		/* 820ADCF4h case    4:*/		return 0x820ADCF8;
	}
	return 0x820ADCF8;
} // Block from 820ADCE4h-820ADCF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820ADCF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADCF8);
		  /* 820ADCF8h */ case    0:  		/* lis R11, -32255 */
		/* 820ADCF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ADCF8h case    0:*/		return 0x820ADCFC;
		  /* 820ADCFCh */ case    1:  		/* mr R3, R31 */
		/* 820ADCFCh case    1:*/		regs.R3 = regs.R31;
		/* 820ADCFCh case    1:*/		return 0x820ADD00;
		  /* 820ADD00h */ case    2:  		/* addi R4, R11, -9924 */
		/* 820ADD00h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD93C);
		/* 820ADD00h case    2:*/		return 0x820ADD04;
		  /* 820ADD04h */ case    3:  		/* bl -6972 */
		/* 820ADD04h case    3:*/		regs.LR = 0x820ADD08; return 0x820AC1C8;
		/* 820ADD04h case    3:*/		return 0x820ADD08;
	}
	return 0x820ADD08;
} // Block from 820ADCF8h-820ADD08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ADD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADD08);
		  /* 820ADD08h */ case    0:  		/* li R3, 1 */
		/* 820ADD08h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820ADD08h case    0:*/		return 0x820ADD0C;
	}
	return 0x820ADD0C;
} // Block from 820ADD08h-820ADD0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820ADD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADD0C);
		  /* 820ADD0Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 820ADD0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820ADD0Ch case    0:*/		return 0x820ADD10;
		  /* 820ADD10h */ case    1:  		/* b -117372 */
		/* 820ADD10h case    1:*/		return 0x82091294;
		/* 820ADD10h case    1:*/		return 0x820ADD14;
		  /* 820ADD14h */ case    2:  		/* nop */
		/* 820ADD14h case    2:*/		cpu::op::nop();
		/* 820ADD14h case    2:*/		return 0x820ADD18;
	}
	return 0x820ADD18;
} // Block from 820ADD0Ch-820ADD18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820ADD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADD18);
		  /* 820ADD18h */ case    0:  		/* mfspr R12, LR */
		/* 820ADD18h case    0:*/		regs.R12 = regs.LR;
		/* 820ADD18h case    0:*/		return 0x820ADD1C;
		  /* 820ADD1Ch */ case    1:  		/* bl -117472 */
		/* 820ADD1Ch case    1:*/		regs.LR = 0x820ADD20; return 0x8209123C;
		/* 820ADD1Ch case    1:*/		return 0x820ADD20;
		  /* 820ADD20h */ case    2:  		/* stwu R1, <#[R1 - 3296]> */
		/* 820ADD20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF320) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF320);
		/* 820ADD20h case    2:*/		return 0x820ADD24;
		  /* 820ADD24h */ case    3:  		/* lis R12, -27 */
		/* 820ADD24h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFE5);
		/* 820ADD24h case    3:*/		return 0x820ADD28;
		  /* 820ADD28h */ case    4:  		/* mr R31, R3 */
		/* 820ADD28h case    4:*/		regs.R31 = regs.R3;
		/* 820ADD28h case    4:*/		return 0x820ADD2C;
		  /* 820ADD2Ch */ case    5:  		/* ori R12, R12, 65340 */
		/* 820ADD2Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFF3C);
		/* 820ADD2Ch case    5:*/		return 0x820ADD30;
		  /* 820ADD30h */ case    6:  		/* mr R30, R4 */
		/* 820ADD30h case    6:*/		regs.R30 = regs.R4;
		/* 820ADD30h case    6:*/		return 0x820ADD34;
		  /* 820ADD34h */ case    7:  		/* mr R28, R5 */
		/* 820ADD34h case    7:*/		regs.R28 = regs.R5;
		/* 820ADD34h case    7:*/		return 0x820ADD38;
		  /* 820ADD38h */ case    8:  		/* mr R27, R6 */
		/* 820ADD38h case    8:*/		regs.R27 = regs.R6;
		/* 820ADD38h case    8:*/		return 0x820ADD3C;
		  /* 820ADD3Ch */ case    9:  		/* mr R23, R7 */
		/* 820ADD3Ch case    9:*/		regs.R23 = regs.R7;
		/* 820ADD3Ch case    9:*/		return 0x820ADD40;
		  /* 820ADD40h */ case   10:  		/* mr R22, R8 */
		/* 820ADD40h case   10:*/		regs.R22 = regs.R8;
		/* 820ADD40h case   10:*/		return 0x820ADD44;
		  /* 820ADD44h */ case   11:  		/* and. R11, R5, R12 */
		/* 820ADD44h case   11:*/		cpu::op::and<1>(regs,&regs.R11,regs.R5,regs.R12);
		/* 820ADD44h case   11:*/		return 0x820ADD48;
		  /* 820ADD48h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820ADD48h case   12:*/		if ( regs.CR[0].eq ) { return 0x820ADD58;  }
		/* 820ADD48h case   12:*/		return 0x820ADD4C;
		  /* 820ADD4Ch */ case   13:  		/* lis R3, -30602 */
		/* 820ADD4Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820ADD4Ch case   13:*/		return 0x820ADD50;
		  /* 820ADD50h */ case   14:  		/* ori R3, R3, 2156 */
		/* 820ADD50h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820ADD50h case   14:*/		return 0x820ADD54;
		  /* 820ADD54h */ case   15:  		/* b 2072 */
		/* 820ADD54h case   15:*/		return 0x820AE56C;
		/* 820ADD54h case   15:*/		return 0x820ADD58;
	}
	return 0x820ADD58;
} // Block from 820ADD18h-820ADD58h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820ADD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADD58);
		  /* 820ADD58h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820ADD58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820ADD58h case    0:*/		return 0x820ADD5C;
		  /* 820ADD5Ch */ case    1:  		/* bc 12, CR6_EQ, -16 */
		/* 820ADD5Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820ADD4C;  }
		/* 820ADD5Ch case    1:*/		return 0x820ADD60;
		  /* 820ADD60h */ case    2:  		/* li R24, 0 */
		/* 820ADD60h case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820ADD60h case    2:*/		return 0x820ADD64;
		  /* 820ADD64h */ case    3:  		/* lis R4, 9345 */
		/* 820ADD64h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820ADD64h case    3:*/		return 0x820ADD68;
		  /* 820ADD68h */ case    4:  		/* stw R24, <#[R23]> */
		/* 820ADD68h case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R23 + 0x00000000) );
		/* 820ADD68h case    4:*/		return 0x820ADD6C;
		  /* 820ADD6Ch */ case    5:  		/* lwz R3, <#[R31 + 100]> */
		/* 820ADD6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 820ADD6Ch case    5:*/		return 0x820ADD70;
		  /* 820ADD70h */ case    6:  		/* bl -154168 */
		/* 820ADD70h case    6:*/		regs.LR = 0x820ADD74; return 0x82088338;
		/* 820ADD70h case    6:*/		return 0x820ADD74;
		  /* 820ADD74h */ case    7:  		/* lwz R29, <#[R31 + 132]> */
		/* 820ADD74h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000084) );
		/* 820ADD74h case    7:*/		return 0x820ADD78;
		  /* 820ADD78h */ case    8:  		/* cmplwi CR6, R29, 0 */
		/* 820ADD78h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820ADD78h case    8:*/		return 0x820ADD7C;
		  /* 820ADD7Ch */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 820ADD7Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820ADD94;  }
		/* 820ADD7Ch case    9:*/		return 0x820ADD80;
		  /* 820ADD80h */ case   10:  		/* mr R3, R29 */
		/* 820ADD80h case   10:*/		regs.R3 = regs.R29;
		/* 820ADD80h case   10:*/		return 0x820ADD84;
		  /* 820ADD84h */ case   11:  		/* bl -18020 */
		/* 820ADD84h case   11:*/		regs.LR = 0x820ADD88; return 0x820A9720;
		/* 820ADD84h case   11:*/		return 0x820ADD88;
		  /* 820ADD88h */ case   12:  		/* lis R4, 9345 */
		/* 820ADD88h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820ADD88h case   12:*/		return 0x820ADD8C;
		  /* 820ADD8Ch */ case   13:  		/* mr R3, R29 */
		/* 820ADD8Ch case   13:*/		regs.R3 = regs.R29;
		/* 820ADD8Ch case   13:*/		return 0x820ADD90;
		  /* 820ADD90h */ case   14:  		/* bl -154200 */
		/* 820ADD90h case   14:*/		regs.LR = 0x820ADD94; return 0x82088338;
		/* 820ADD90h case   14:*/		return 0x820ADD94;
	}
	return 0x820ADD94;
} // Block from 820ADD58h-820ADD94h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820ADD94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADD94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADD94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADD94);
		  /* 820ADD94h */ case    0:  		/* addi R11, R30, 24 */
		/* 820ADD94h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x18);
		/* 820ADD94h case    0:*/		return 0x820ADD98;
		  /* 820ADD98h */ case    1:  		/* stw R30, <#[R31 + 4]> */
		/* 820ADD98h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 820ADD98h case    1:*/		return 0x820ADD9C;
		  /* 820ADD9Ch */ case    2:  		/* li R10, -1 */
		/* 820ADD9Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820ADD9Ch case    2:*/		return 0x820ADDA0;
		  /* 820ADDA0h */ case    3:  		/* stw R28, <#[R31 + 68]> */
		/* 820ADDA0h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000044) );
		/* 820ADDA0h case    3:*/		return 0x820ADDA4;
		  /* 820ADDA4h */ case    4:  		/* stw R24, <#[R31 + 8]> */
		/* 820ADDA4h case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000008) );
		/* 820ADDA4h case    4:*/		return 0x820ADDA8;
		  /* 820ADDA8h */ case    5:  		/* li R5, 0 */
		/* 820ADDA8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820ADDA8h case    5:*/		return 0x820ADDAC;
		  /* 820ADDACh */ case    6:  		/* stw R24, <#[R31 + 56]> */
		/* 820ADDACh case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000038) );
		/* 820ADDACh case    6:*/		return 0x820ADDB0;
		  /* 820ADDB0h */ case    7:  		/* addi R4, R1, 132 */
		/* 820ADDB0h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x84);
		/* 820ADDB0h case    7:*/		return 0x820ADDB4;
		  /* 820ADDB4h */ case    8:  		/* stw R11, <#[R31]> */
		/* 820ADDB4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820ADDB4h case    8:*/		return 0x820ADDB8;
		  /* 820ADDB8h */ case    9:  		/* mr R3, R30 */
		/* 820ADDB8h case    9:*/		regs.R3 = regs.R30;
		/* 820ADDB8h case    9:*/		return 0x820ADDBC;
		  /* 820ADDBCh */ case   10:  		/* stw R24, <#[R31 + 60]> */
		/* 820ADDBCh case   10:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000003C) );
		/* 820ADDBCh case   10:*/		return 0x820ADDC0;
		  /* 820ADDC0h */ case   11:  		/* addi R26, R31, 120 */
		/* 820ADDC0h case   11:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R31,0x78);
		/* 820ADDC0h case   11:*/		return 0x820ADDC4;
		  /* 820ADDC4h */ case   12:  		/* stw R24, <#[R31 + 100]> */
		/* 820ADDC4h case   12:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000064) );
		/* 820ADDC4h case   12:*/		return 0x820ADDC8;
		  /* 820ADDC8h */ case   13:  		/* addi R25, R31, 124 */
		/* 820ADDC8h case   13:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R31,0x7C);
		/* 820ADDC8h case   13:*/		return 0x820ADDCC;
		  /* 820ADDCCh */ case   14:  		/* stw R24, <#[R31 + 104]> */
		/* 820ADDCCh case   14:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000068) );
		/* 820ADDCCh case   14:*/		return 0x820ADDD0;
		  /* 820ADDD0h */ case   15:  		/* stw R24, <#[R31 + 108]> */
		/* 820ADDD0h case   15:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000006C) );
		/* 820ADDD0h case   15:*/		return 0x820ADDD4;
		  /* 820ADDD4h */ case   16:  		/* stw R24, <#[R31 + 112]> */
		/* 820ADDD4h case   16:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000070) );
		/* 820ADDD4h case   16:*/		return 0x820ADDD8;
		  /* 820ADDD8h */ case   17:  		/* stw R24, <#[R31 + 116]> */
		/* 820ADDD8h case   17:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000074) );
		/* 820ADDD8h case   17:*/		return 0x820ADDDC;
		  /* 820ADDDCh */ case   18:  		/* stw R24, <#[R31 + 84]> */
		/* 820ADDDCh case   18:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000054) );
		/* 820ADDDCh case   18:*/		return 0x820ADDE0;
		  /* 820ADDE0h */ case   19:  		/* stw R24, <#[R31 + 88]> */
		/* 820ADDE0h case   19:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000058) );
		/* 820ADDE0h case   19:*/		return 0x820ADDE4;
		  /* 820ADDE4h */ case   20:  		/* stw R24, <#[R31 + 96]> */
		/* 820ADDE4h case   20:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000060) );
		/* 820ADDE4h case   20:*/		return 0x820ADDE8;
		  /* 820ADDE8h */ case   21:  		/* stw R24, <#[R31 + 120]> */
		/* 820ADDE8h case   21:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000078) );
		/* 820ADDE8h case   21:*/		return 0x820ADDEC;
		  /* 820ADDECh */ case   22:  		/* stw R24, <#[R31 + 124]> */
		/* 820ADDECh case   22:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000007C) );
		/* 820ADDECh case   22:*/		return 0x820ADDF0;
		  /* 820ADDF0h */ case   23:  		/* stw R10, <#[R31 + 64]> */
		/* 820ADDF0h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000040) );
		/* 820ADDF0h case   23:*/		return 0x820ADDF4;
		  /* 820ADDF4h */ case   24:  		/* stw R24, <#[R31 + 128]> */
		/* 820ADDF4h case   24:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000080) );
		/* 820ADDF4h case   24:*/		return 0x820ADDF8;
		  /* 820ADDF8h */ case   25:  		/* bl -57360 */
		/* 820ADDF8h case   25:*/		regs.LR = 0x820ADDFC; return 0x8209FDE8;
		/* 820ADDF8h case   25:*/		return 0x820ADDFC;
		  /* 820ADDFCh */ case   26:  		/* lwz R11, <#[R1 + 132]> */
		/* 820ADDFCh case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820ADDFCh case   26:*/		return 0x820ADE00;
		  /* 820ADE00h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 820ADE00h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820ADE00h case   27:*/		return 0x820ADE04;
		  /* 820ADE04h */ case   28:  		/* bc 4, CR6_EQ, 20 */
		/* 820ADE04h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820ADE18;  }
		/* 820ADE04h case   28:*/		return 0x820ADE08;
		  /* 820ADE08h */ case   29:  		/* mr R5, R25 */
		/* 820ADE08h case   29:*/		regs.R5 = regs.R25;
		/* 820ADE08h case   29:*/		return 0x820ADE0C;
		  /* 820ADE0Ch */ case   30:  		/* lwz R3, <#[R31 + 4]> */
		/* 820ADE0Ch case   30:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820ADE0Ch case   30:*/		return 0x820ADE10;
		  /* 820ADE10h */ case   31:  		/* mr R4, R26 */
		/* 820ADE10h case   31:*/		regs.R4 = regs.R26;
		/* 820ADE10h case   31:*/		return 0x820ADE14;
		  /* 820ADE14h */ case   32:  		/* bl -57340 */
		/* 820ADE14h case   32:*/		regs.LR = 0x820ADE18; return 0x8209FE18;
		/* 820ADE14h case   32:*/		return 0x820ADE18;
	}
	return 0x820ADE18;
} // Block from 820ADD94h-820ADE18h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820ADE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADE18);
		  /* 820ADE18h */ case    0:  		/* li R4, 2 */
		/* 820ADE18h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820ADE18h case    0:*/		return 0x820ADE1C;
		  /* 820ADE1Ch */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820ADE1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820ADE1Ch case    1:*/		return 0x820ADE20;
		  /* 820ADE20h */ case    2:  		/* bl -52336 */
		/* 820ADE20h case    2:*/		regs.LR = 0x820ADE24; return 0x820A11B0;
		/* 820ADE20h case    2:*/		return 0x820ADE24;
		  /* 820ADE24h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820ADE24h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ADE24h case    3:*/		return 0x820ADE28;
		  /* 820ADE28h */ case    4:  		/* bc 12, CR0_LT, 1860 */
		/* 820ADE28h case    4:*/		if ( regs.CR[0].lt ) { return 0x820AE56C;  }
		/* 820ADE28h case    4:*/		return 0x820ADE2C;
		  /* 820ADE2Ch */ case    5:  		/* mr R3, R31 */
		/* 820ADE2Ch case    5:*/		regs.R3 = regs.R31;
		/* 820ADE2Ch case    5:*/		return 0x820ADE30;
		  /* 820ADE30h */ case    6:  		/* bl -2320 */
		/* 820ADE30h case    6:*/		regs.LR = 0x820ADE34; return 0x820AD520;
		/* 820ADE30h case    6:*/		return 0x820ADE34;
		  /* 820ADE34h */ case    7:  		/* lwz R11, <#[R31 + 16]> */
		/* 820ADE34h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820ADE34h case    7:*/		return 0x820ADE38;
		  /* 820ADE38h */ case    8:  		/* addi R29, R31, 16 */
		/* 820ADE38h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x10);
		/* 820ADE38h case    8:*/		return 0x820ADE3C;
		  /* 820ADE3Ch */ case    9:  		/* cmpwi CR6, R11, 11 */
		/* 820ADE3Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820ADE3Ch case    9:*/		return 0x820ADE40;
		  /* 820ADE40h */ case   10:  		/* bc 4, CR6_EQ, 40 */
		/* 820ADE40h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820ADE68;  }
		/* 820ADE40h case   10:*/		return 0x820ADE44;
		  /* 820ADE44h */ case   11:  		/* addi R5, R1, 136 */
		/* 820ADE44h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x88);
		/* 820ADE44h case   11:*/		return 0x820ADE48;
		  /* 820ADE48h */ case   12:  		/* lwz R3, <#[R31 + 24]> */
		/* 820ADE48h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADE48h case   12:*/		return 0x820ADE4C;
		  /* 820ADE4Ch */ case   13:  		/* li R4, 1 */
		/* 820ADE4Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820ADE4Ch case   13:*/		return 0x820ADE50;
		  /* 820ADE50h */ case   14:  		/* bl -61632 */
		/* 820ADE50h case   14:*/		regs.LR = 0x820ADE54; return 0x8209ED90;
		/* 820ADE50h case   14:*/		return 0x820ADE54;
		  /* 820ADE54h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820ADE54h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820ADE54h case   15:*/		return 0x820ADE58;
		  /* 820ADE58h */ case   16:  		/* bc 12, CR0_LT, 16 */
		/* 820ADE58h case   16:*/		if ( regs.CR[0].lt ) { return 0x820ADE68;  }
		/* 820ADE58h case   16:*/		return 0x820ADE5C;
		  /* 820ADE5Ch */ case   17:  		/* lwz R11, <#[R1 + 140]> */
		/* 820ADE5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 820ADE5Ch case   17:*/		return 0x820ADE60;
		  /* 820ADE60h */ case   18:  		/* stw R24, <#[R29]> */
		/* 820ADE60h case   18:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R29 + 0x00000000) );
		/* 820ADE60h case   18:*/		return 0x820ADE64;
		  /* 820ADE64h */ case   19:  		/* stw R11, <#[R31 + 24]> */
		/* 820ADE64h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADE64h case   19:*/		return 0x820ADE68;
	}
	return 0x820ADE68;
} // Block from 820ADE18h-820ADE68h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820ADE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADE68);
		  /* 820ADE68h */ case    0:  		/* lwz R8, <#[R29]> */
		/* 820ADE68h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 820ADE68h case    0:*/		return 0x820ADE6C;
		  /* 820ADE6Ch */ case    1:  		/* li R21, 1 */
		/* 820ADE6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 820ADE6Ch case    1:*/		return 0x820ADE70;
		  /* 820ADE70h */ case    2:  		/* cmpwi CR6, R8, 11 */
		/* 820ADE70h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000B);
		/* 820ADE70h case    2:*/		return 0x820ADE74;
		  /* 820ADE74h */ case    3:  		/* bc 4, CR6_EQ, 196 */
		/* 820ADE74h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820ADF38;  }
		/* 820ADE74h case    3:*/		return 0x820ADE78;
		  /* 820ADE78h */ case    4:  		/* lis R11, -32255 */
		/* 820ADE78h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ADE78h case    4:*/		return 0x820ADE7C;
		  /* 820ADE7Ch */ case    5:  		/* lwz R5, <#[R31 + 24]> */
		/* 820ADE7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADE7Ch case    5:*/		return 0x820ADE80;
		  /* 820ADE80h */ case    6:  		/* addi R10, R11, 6764 */
		/* 820ADE80h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1A6C);
		/* 820ADE80h case    6:*/		return 0x820ADE84;
		  /* 820ADE84h */ case    7:  		/* mr R11, R5 */
		/* 820ADE84h case    7:*/		regs.R11 = regs.R5;
		/* 820ADE84h case    7:*/		return 0x820ADE88;
		  /* 820ADE88h */ case    8:  		/* lbz R9, <#[R11]> */
		/* 820ADE88h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADE88h case    8:*/		return 0x820ADE8C;
		  /* 820ADE8Ch */ case    9:  		/* lbz R7, <#[R10]> */
		/* 820ADE8Ch case    9:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820ADE8Ch case    9:*/		return 0x820ADE90;
		  /* 820ADE90h */ case   10:  		/* cmpwi CR0, R9, 0 */
		/* 820ADE90h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ADE90h case   10:*/		return 0x820ADE94;
		  /* 820ADE94h */ case   11:  		/* subf R9, R7, R9 */
		/* 820ADE94h case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820ADE94h case   11:*/		return 0x820ADE98;
		  /* 820ADE98h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 820ADE98h case   12:*/		if ( regs.CR[0].eq ) { return 0x820ADEAC;  }
		/* 820ADE98h case   12:*/		return 0x820ADE9C;
		  /* 820ADE9Ch */ case   13:  		/* addi R11, R11, 1 */
		/* 820ADE9Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ADE9Ch case   13:*/		return 0x820ADEA0;
		  /* 820ADEA0h */ case   14:  		/* addi R10, R10, 1 */
		/* 820ADEA0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ADEA0h case   14:*/		return 0x820ADEA4;
		  /* 820ADEA4h */ case   15:  		/* cmpwi CR6, R9, 0 */
		/* 820ADEA4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ADEA4h case   15:*/		return 0x820ADEA8;
		  /* 820ADEA8h */ case   16:  		/* bc 12, CR6_EQ, -32 */
		/* 820ADEA8h case   16:*/		if ( regs.CR[6].eq ) { return 0x820ADE88;  }
		/* 820ADEA8h case   16:*/		return 0x820ADEAC;
	}
	return 0x820ADEAC;
} // Block from 820ADE68h-820ADEACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820ADEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADEAC);
		  /* 820ADEACh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ADEACh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ADEACh case    0:*/		return 0x820ADEB0;
		  /* 820ADEB0h */ case    1:  		/* bc 12, CR0_EQ, 60 */
		/* 820ADEB0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ADEEC;  }
		/* 820ADEB0h case    1:*/		return 0x820ADEB4;
		  /* 820ADEB4h */ case    2:  		/* lis R10, -32255 */
		/* 820ADEB4h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820ADEB4h case    2:*/		return 0x820ADEB8;
		  /* 820ADEB8h */ case    3:  		/* mr R11, R5 */
		/* 820ADEB8h case    3:*/		regs.R11 = regs.R5;
		/* 820ADEB8h case    3:*/		return 0x820ADEBC;
		  /* 820ADEBCh */ case    4:  		/* addi R10, R10, 6756 */
		/* 820ADEBCh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1A64);
		/* 820ADEBCh case    4:*/		return 0x820ADEC0;
		  /* 820ADEC0h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 820ADEC0h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820ADEC0h case    5:*/		return 0x820ADEC4;
		  /* 820ADEC4h */ case    6:  		/* lbz R7, <#[R10]> */
		/* 820ADEC4h case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820ADEC4h case    6:*/		return 0x820ADEC8;
		  /* 820ADEC8h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 820ADEC8h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ADEC8h case    7:*/		return 0x820ADECC;
		  /* 820ADECCh */ case    8:  		/* subf R9, R7, R9 */
		/* 820ADECCh case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820ADECCh case    8:*/		return 0x820ADED0;
		  /* 820ADED0h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 820ADED0h case    9:*/		if ( regs.CR[0].eq ) { return 0x820ADEE4;  }
		/* 820ADED0h case    9:*/		return 0x820ADED4;
		  /* 820ADED4h */ case   10:  		/* addi R11, R11, 1 */
		/* 820ADED4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820ADED4h case   10:*/		return 0x820ADED8;
		  /* 820ADED8h */ case   11:  		/* addi R10, R10, 1 */
		/* 820ADED8h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820ADED8h case   11:*/		return 0x820ADEDC;
		  /* 820ADEDCh */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 820ADEDCh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820ADEDCh case   12:*/		return 0x820ADEE0;
		  /* 820ADEE0h */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 820ADEE0h case   13:*/		if ( regs.CR[6].eq ) { return 0x820ADEC0;  }
		/* 820ADEE0h case   13:*/		return 0x820ADEE4;
	}
	return 0x820ADEE4;
} // Block from 820ADEACh-820ADEE4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ADEE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADEE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADEE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADEE4);
		  /* 820ADEE4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820ADEE4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820ADEE4h case    0:*/		return 0x820ADEE8;
		  /* 820ADEE8h */ case    1:  		/* bc 4, CR0_EQ, 80 */
		/* 820ADEE8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820ADF38;  }
		/* 820ADEE8h case    1:*/		return 0x820ADEEC;
	}
	return 0x820ADEEC;
} // Block from 820ADEE4h-820ADEECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ADEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADEEC);
		  /* 820ADEECh */ case    0:  		/* rlwinm. R11, R28, 0, 11, 11 */
		/* 820ADEECh case    0:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R28);
		/* 820ADEECh case    0:*/		return 0x820ADEF0;
		  /* 820ADEF0h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 820ADEF0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ADF10;  }
		/* 820ADEF0h case    1:*/		return 0x820ADEF4;
		  /* 820ADEF4h */ case    2:  		/* lis R11, -32255 */
		/* 820ADEF4h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ADEF4h case    2:*/		return 0x820ADEF8;
		  /* 820ADEF8h */ case    3:  		/* mr R3, R31 */
		/* 820ADEF8h case    3:*/		regs.R3 = regs.R31;
		/* 820ADEF8h case    3:*/		return 0x820ADEFC;
		  /* 820ADEFCh */ case    4:  		/* addi R4, R11, 6672 */
		/* 820ADEFCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1A10);
		/* 820ADEFCh case    4:*/		return 0x820ADF00;
		  /* 820ADF00h */ case    5:  		/* bl -7400 */
		/* 820ADF00h case    5:*/		regs.LR = 0x820ADF04; return 0x820AC218;
		/* 820ADF00h case    5:*/		return 0x820ADF04;
		  /* 820ADF04h */ case    6:  		/* lis R30, -32768 */
		/* 820ADF04h case    6:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8000);
		/* 820ADF04h case    6:*/		return 0x820ADF08;
		  /* 820ADF08h */ case    7:  		/* ori R30, R30, 16389 */
		/* 820ADF08h case    7:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x4005);
		/* 820ADF08h case    7:*/		return 0x820ADF0C;
		  /* 820ADF0Ch */ case    8:  		/* b 1572 */
		/* 820ADF0Ch case    8:*/		return 0x820AE530;
		/* 820ADF0Ch case    8:*/		return 0x820ADF10;
	}
	return 0x820ADF10;
} // Block from 820ADEECh-820ADF10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820ADF10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADF10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADF10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADF10);
		  /* 820ADF10h */ case    0:  		/* mr R8, R22 */
		/* 820ADF10h case    0:*/		regs.R8 = regs.R22;
		/* 820ADF10h case    0:*/		return 0x820ADF14;
		  /* 820ADF14h */ case    1:  		/* lwz R6, <#[R31]> */
		/* 820ADF14h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 820ADF14h case    1:*/		return 0x820ADF18;
		  /* 820ADF18h */ case    2:  		/* mr R7, R23 */
		/* 820ADF18h case    2:*/		regs.R7 = regs.R23;
		/* 820ADF18h case    2:*/		return 0x820ADF1C;
		  /* 820ADF1Ch */ case    3:  		/* lwz R3, <#[R31 + 4]> */
		/* 820ADF1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820ADF1Ch case    3:*/		return 0x820ADF20;
		  /* 820ADF20h */ case    4:  		/* mr R5, R28 */
		/* 820ADF20h case    4:*/		regs.R5 = regs.R28;
		/* 820ADF20h case    4:*/		return 0x820ADF24;
		  /* 820ADF24h */ case    5:  		/* mr R4, R29 */
		/* 820ADF24h case    5:*/		regs.R4 = regs.R29;
		/* 820ADF24h case    5:*/		return 0x820ADF28;
		  /* 820ADF28h */ case    6:  		/* bl 173872 */
		/* 820ADF28h case    6:*/		regs.LR = 0x820ADF2C; return 0x820D8658;
		/* 820ADF28h case    6:*/		return 0x820ADF2C;
		  /* 820ADF2Ch */ case    7:  		/* or. R30, R3, R3 */
		/* 820ADF2Ch case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820ADF2Ch case    7:*/		return 0x820ADF30;
		  /* 820ADF30h */ case    8:  		/* bc 12, CR0_LT, 1536 */
		/* 820ADF30h case    8:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820ADF30h case    8:*/		return 0x820ADF34;
		  /* 820ADF34h */ case    9:  		/* b 1544 */
		/* 820ADF34h case    9:*/		return 0x820AE53C;
		/* 820ADF34h case    9:*/		return 0x820ADF38;
	}
	return 0x820ADF38;
} // Block from 820ADF10h-820ADF38h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820ADF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADF38);
		  /* 820ADF38h */ case    0:  		/* cmpwi CR6, R8, 0 */
		/* 820ADF38h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820ADF38h case    0:*/		return 0x820ADF3C;
		  /* 820ADF3Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820ADF3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820ADF50;  }
		/* 820ADF3Ch case    1:*/		return 0x820ADF40;
		  /* 820ADF40h */ case    2:  		/* lis R11, -32255 */
		/* 820ADF40h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ADF40h case    2:*/		return 0x820ADF44;
		  /* 820ADF44h */ case    3:  		/* li R5, 2001 */
		/* 820ADF44h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x7D1);
		/* 820ADF44h case    3:*/		return 0x820ADF48;
	}
	return 0x820ADF48;
} // Block from 820ADF38h-820ADF48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820ADF48h
// Function '?Token@CAssembler@D3DXShader@@IAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADF48);
		  /* 820ADF48h */ case    0:  		/* addi R6, R11, 6644 */
		/* 820ADF48h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x19F4);
		/* 820ADF48h case    0:*/		return 0x820ADF4C;
		  /* 820ADF4Ch */ case    1:  		/* b 472 */
		/* 820ADF4Ch case    1:*/		return 0x820AE124;
		/* 820ADF4Ch case    1:*/		return 0x820ADF50;
	}
	return 0x820ADF50;
} // Block from 820ADF48h-820ADF50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820ADF50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADF50);
		  /* 820ADF50h */ case    0:  		/* lis R11, -2 */
		/* 820ADF50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFE);
		/* 820ADF50h case    0:*/		return 0x820ADF54;
		  /* 820ADF54h */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ADF54h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADF54h case    1:*/		return 0x820ADF58;
		  /* 820ADF58h */ case    2:  		/* lis R9, -2 */
		/* 820ADF58h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFFE);
		/* 820ADF58h case    2:*/		return 0x820ADF5C;
		  /* 820ADF5Ch */ case    3:  		/* ori R11, R11, 256 */
		/* 820ADF5Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820ADF5Ch case    3:*/		return 0x820ADF60;
		  /* 820ADF60h */ case    4:  		/* ori R30, R9, 257 */
		/* 820ADF60h case    4:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R9,0x101);
		/* 820ADF60h case    4:*/		return 0x820ADF64;
		  /* 820ADF64h */ case    5:  		/* cmplw CR6, R10, R11 */
		/* 820ADF64h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820ADF64h case    5:*/		return 0x820ADF68;
		  /* 820ADF68h */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 820ADF68h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820ADF88;  }
		/* 820ADF68h case    6:*/		return 0x820ADF6C;
		  /* 820ADF6Ch */ case    7:  		/* lis R11, -32255 */
		/* 820ADF6Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ADF6Ch case    7:*/		return 0x820ADF70;
		  /* 820ADF70h */ case    8:  		/* lwz R3, <#[R31]> */
		/* 820ADF70h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820ADF70h case    8:*/		return 0x820ADF74;
		  /* 820ADF74h */ case    9:  		/* li R5, 2015 */
		/* 820ADF74h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x7DF);
		/* 820ADF74h case    9:*/		return 0x820ADF78;
		  /* 820ADF78h */ case   10:  		/* addi R6, R11, 6600 */
		/* 820ADF78h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x19C8);
		/* 820ADF78h case   10:*/		return 0x820ADF7C;
		  /* 820ADF7Ch */ case   11:  		/* mr R4, R29 */
		/* 820ADF7Ch case   11:*/		regs.R4 = regs.R29;
		/* 820ADF7Ch case   11:*/		return 0x820ADF80;
		  /* 820ADF80h */ case   12:  		/* bl -27688 */
		/* 820ADF80h case   12:*/		regs.LR = 0x820ADF84; return 0x820A7358;
		/* 820ADF80h case   12:*/		return 0x820ADF84;
		  /* 820ADF84h */ case   13:  		/* stw R30, <#[R31 + 24]> */
		/* 820ADF84h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADF84h case   13:*/		return 0x820ADF88;
	}
	return 0x820ADF88;
} // Block from 820ADF50h-820ADF88h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ADF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADF88);
		  /* 820ADF88h */ case    0:  		/* lis R11, -1 */
		/* 820ADF88h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820ADF88h case    0:*/		return 0x820ADF8C;
		  /* 820ADF8Ch */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ADF8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADF8Ch case    1:*/		return 0x820ADF90;
		  /* 820ADF90h */ case    2:  		/* ori R11, R11, 256 */
		/* 820ADF90h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820ADF90h case    2:*/		return 0x820ADF94;
		  /* 820ADF94h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 820ADF94h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820ADF94h case    3:*/		return 0x820ADF98;
		  /* 820ADF98h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 820ADF98h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820ADFC0;  }
		/* 820ADF98h case    4:*/		return 0x820ADF9C;
		  /* 820ADF9Ch */ case    5:  		/* lis R11, -32255 */
		/* 820ADF9Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820ADF9Ch case    5:*/		return 0x820ADFA0;
		  /* 820ADFA0h */ case    6:  		/* lwz R3, <#[R31]> */
		/* 820ADFA0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820ADFA0h case    6:*/		return 0x820ADFA4;
		  /* 820ADFA4h */ case    7:  		/* li R5, 2015 */
		/* 820ADFA4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x7DF);
		/* 820ADFA4h case    7:*/		return 0x820ADFA8;
		  /* 820ADFA8h */ case    8:  		/* addi R6, R11, 6556 */
		/* 820ADFA8h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x199C);
		/* 820ADFA8h case    8:*/		return 0x820ADFAC;
		  /* 820ADFACh */ case    9:  		/* mr R4, R29 */
		/* 820ADFACh case    9:*/		regs.R4 = regs.R29;
		/* 820ADFACh case    9:*/		return 0x820ADFB0;
		  /* 820ADFB0h */ case   10:  		/* bl -27736 */
		/* 820ADFB0h case   10:*/		regs.LR = 0x820ADFB4; return 0x820A7358;
		/* 820ADFB0h case   10:*/		return 0x820ADFB4;
		  /* 820ADFB4h */ case   11:  		/* lis R11, -1 */
		/* 820ADFB4h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820ADFB4h case   11:*/		return 0x820ADFB8;
		  /* 820ADFB8h */ case   12:  		/* ori R11, R11, 257 */
		/* 820ADFB8h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x101);
		/* 820ADFB8h case   12:*/		return 0x820ADFBC;
		  /* 820ADFBCh */ case   13:  		/* stw R11, <#[R31 + 24]> */
		/* 820ADFBCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADFBCh case   13:*/		return 0x820ADFC0;
	}
	return 0x820ADFC0;
} // Block from 820ADF88h-820ADFC0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820ADFC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADFC0);
		  /* 820ADFC0h */ case    0:  		/* lis R11, -1 */
		/* 820ADFC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820ADFC0h case    0:*/		return 0x820ADFC4;
		  /* 820ADFC4h */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 820ADFC4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADFC4h case    1:*/		return 0x820ADFC8;
		  /* 820ADFC8h */ case    2:  		/* ori R11, R11, 514 */
		/* 820ADFC8h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x202);
		/* 820ADFC8h case    2:*/		return 0x820ADFCC;
		  /* 820ADFCCh */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 820ADFCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820ADFCCh case    3:*/		return 0x820ADFD0;
		  /* 820ADFD0h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 820ADFD0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820ADFE0;  }
		/* 820ADFD0h case    4:*/		return 0x820ADFD4;
		  /* 820ADFD4h */ case    5:  		/* lis R11, -1 */
		/* 820ADFD4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820ADFD4h case    5:*/		return 0x820ADFD8;
		  /* 820ADFD8h */ case    6:  		/* ori R11, R11, 513 */
		/* 820ADFD8h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x201);
		/* 820ADFD8h case    6:*/		return 0x820ADFDC;
		  /* 820ADFDCh */ case    7:  		/* stw R11, <#[R31 + 24]> */
		/* 820ADFDCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADFDCh case    7:*/		return 0x820ADFE0;
	}
	return 0x820ADFE0;
} // Block from 820ADFC0h-820ADFE0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820ADFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADFE0);
		  /* 820ADFE0h */ case    0:  		/* rlwinm. R11, R28, 0, 25, 25 */
		/* 820ADFE0h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R28);
		/* 820ADFE0h case    0:*/		return 0x820ADFE4;
		  /* 820ADFE4h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 820ADFE4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820ADFFC;  }
		/* 820ADFE4h case    1:*/		return 0x820ADFE8;
		  /* 820ADFE8h */ case    2:  		/* lwz R11, <#[R31 + 24]> */
		/* 820ADFE8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820ADFE8h case    2:*/		return 0x820ADFEC;
		  /* 820ADFECh */ case    3:  		/* lis R10, -2 */
		/* 820ADFECh case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820ADFECh case    3:*/		return 0x820ADFF0;
		  /* 820ADFF0h */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820ADFF0h case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820ADFF0h case    4:*/		return 0x820ADFF4;
		  /* 820ADFF4h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820ADFF4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820ADFF4h case    5:*/		return 0x820ADFF8;
		  /* 820ADFF8h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 820ADFF8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820AE018;  }
		/* 820ADFF8h case    6:*/		return 0x820ADFFC;
	}
	return 0x820ADFFC;
} // Block from 820ADFE0h-820ADFFCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820ADFFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820ADFFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820ADFFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820ADFFC);
		  /* 820ADFFCh */ case    0:  		/* rlwinm. R11, R28, 0, 24, 24 */
		/* 820ADFFCh case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R28);
		/* 820ADFFCh case    0:*/		return 0x820AE000;
		  /* 820AE000h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 820AE000h case    1:*/		if ( regs.CR[0].eq ) { return 0x820AE024;  }
		/* 820AE000h case    1:*/		return 0x820AE004;
		  /* 820AE004h */ case    2:  		/* lwz R11, <#[R31 + 24]> */
		/* 820AE004h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820AE004h case    2:*/		return 0x820AE008;
		  /* 820AE008h */ case    3:  		/* lis R10, -1 */
		/* 820AE008h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820AE008h case    3:*/		return 0x820AE00C;
		  /* 820AE00Ch */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820AE00Ch case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820AE00Ch case    4:*/		return 0x820AE010;
		  /* 820AE010h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820AE010h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AE010h case    5:*/		return 0x820AE014;
		  /* 820AE014h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820AE014h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820AE024;  }
		/* 820AE014h case    6:*/		return 0x820AE018;
	}
	return 0x820AE018;
} // Block from 820ADFFCh-820AE018h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AE018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE018);
		  /* 820AE018h */ case    0:  		/* lwz R11, <#[R31 + 68]> */
		/* 820AE018h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820AE018h case    0:*/		return 0x820AE01C;
		  /* 820AE01Ch */ case    1:  		/* ori R11, R11, 1 */
		/* 820AE01Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AE01Ch case    1:*/		return 0x820AE020;
		  /* 820AE020h */ case    2:  		/* stw R11, <#[R31 + 68]> */
		/* 820AE020h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820AE020h case    2:*/		return 0x820AE024;
	}
	return 0x820AE024;
} // Block from 820AE018h-820AE024h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE024);
		  /* 820AE024h */ case    0:  		/* lis R10, -1 */
		/* 820AE024h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820AE024h case    0:*/		return 0x820AE028;
		  /* 820AE028h */ case    1:  		/* lwz R11, <#[R31 + 24]> */
		/* 820AE028h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820AE028h case    1:*/		return 0x820AE02C;
		  /* 820AE02Ch */ case    2:  		/* ori R10, R10, 259 */
		/* 820AE02Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x103);
		/* 820AE02Ch case    2:*/		return 0x820AE030;
		  /* 820AE030h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820AE030h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AE030h case    3:*/		return 0x820AE034;
		  /* 820AE034h */ case    4:  		/* bc 12, CR6_GT, 164 */
		/* 820AE034h case    4:*/		if ( regs.CR[6].gt ) { return 0x820AE0D8;  }
		/* 820AE034h case    4:*/		return 0x820AE038;
		  /* 820AE038h */ case    5:  		/* bc 12, CR6_EQ, 152 */
		/* 820AE038h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AE0D0;  }
		/* 820AE038h case    5:*/		return 0x820AE03C;
		  /* 820AE03Ch */ case    6:  		/* lis R10, -2 */
		/* 820AE03Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820AE03Ch case    6:*/		return 0x820AE040;
		  /* 820AE040h */ case    7:  		/* ori R10, R10, 768 */
		/* 820AE040h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x300);
		/* 820AE040h case    7:*/		return 0x820AE044;
		  /* 820AE044h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820AE044h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AE044h case    8:*/		return 0x820AE048;
		  /* 820AE048h */ case    9:  		/* bc 12, CR6_GT, 80 */
		/* 820AE048h case    9:*/		if ( regs.CR[6].gt ) { return 0x820AE098;  }
		/* 820AE048h case    9:*/		return 0x820AE04C;
		  /* 820AE04Ch */ case   10:  		/* bc 12, CR6_EQ, 68 */
		/* 820AE04Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820AE090;  }
		/* 820AE04Ch case   10:*/		return 0x820AE050;
		  /* 820AE050h */ case   11:  		/* subf. R11, R30, R11 */
		/* 820AE050h case   11:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820AE050h case   11:*/		return 0x820AE054;
		  /* 820AE054h */ case   12:  		/* bc 12, CR0_EQ, 52 */
		/* 820AE054h case   12:*/		if ( regs.CR[0].eq ) { return 0x820AE088;  }
		/* 820AE054h case   12:*/		return 0x820AE058;
		  /* 820AE058h */ case   13:  		/* cmplwi CR6, R11, 255 */
		/* 820AE058h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 820AE058h case   13:*/		return 0x820AE05C;
		  /* 820AE05Ch */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 820AE05Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820AE080;  }
		/* 820AE05Ch case   14:*/		return 0x820AE060;
		  /* 820AE060h */ case   15:  		/* cmplwi CR6, R11, 256 */
		/* 820AE060h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 820AE060h case   15:*/		return 0x820AE064;
		  /* 820AE064h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 820AE064h case   16:*/		if ( regs.CR[6].eq ) { return 0x820AE078;  }
		/* 820AE064h case   16:*/		return 0x820AE068;
		  /* 820AE068h */ case   17:  		/* cmplwi CR6, R11, 510 */
		/* 820AE068h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000001FE);
		/* 820AE068h case   17:*/		return 0x820AE06C;
		  /* 820AE06Ch */ case   18:  		/* bc 4, CR6_EQ, 172 */
		/* 820AE06Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x820AE118;  }
		/* 820AE06Ch case   18:*/		return 0x820AE070;
		  /* 820AE070h */ case   19:  		/* li R11, 3 */
		/* 820AE070h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 820AE070h case   19:*/		return 0x820AE074;
		  /* 820AE074h */ case   20:  		/* b 244 */
		/* 820AE074h case   20:*/		return 0x820AE168;
		/* 820AE074h case   20:*/		return 0x820AE078;
	}
	return 0x820AE078;
} // Block from 820AE024h-820AE078h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AE078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE078);
		  /* 820AE078h */ case    0:  		/* li R11, 2 */
		/* 820AE078h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820AE078h case    0:*/		return 0x820AE07C;
		  /* 820AE07Ch */ case    1:  		/* b 236 */
		/* 820AE07Ch case    1:*/		return 0x820AE168;
		/* 820AE07Ch case    1:*/		return 0x820AE080;
	}
	return 0x820AE080;
} // Block from 820AE078h-820AE080h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE080);
		  /* 820AE080h */ case    0:  		/* stw R21, <#[R31 + 64]> */
		/* 820AE080h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000040) );
		/* 820AE080h case    0:*/		return 0x820AE084;
		  /* 820AE084h */ case    1:  		/* b 232 */
		/* 820AE084h case    1:*/		return 0x820AE16C;
		/* 820AE084h case    1:*/		return 0x820AE088;
	}
	return 0x820AE088;
} // Block from 820AE080h-820AE088h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE088);
		  /* 820AE088h */ case    0:  		/* stw R24, <#[R31 + 64]> */
		/* 820AE088h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000040) );
		/* 820AE088h case    0:*/		return 0x820AE08C;
		  /* 820AE08Ch */ case    1:  		/* b 224 */
		/* 820AE08Ch case    1:*/		return 0x820AE16C;
		/* 820AE08Ch case    1:*/		return 0x820AE090;
	}
	return 0x820AE090;
} // Block from 820AE088h-820AE090h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE090);
		  /* 820AE090h */ case    0:  		/* li R11, 4 */
		/* 820AE090h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820AE090h case    0:*/		return 0x820AE094;
		  /* 820AE094h */ case    1:  		/* b 212 */
		/* 820AE094h case    1:*/		return 0x820AE168;
		/* 820AE094h case    1:*/		return 0x820AE098;
	}
	return 0x820AE098;
} // Block from 820AE090h-820AE098h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE098);
		  /* 820AE098h */ case    0:  		/* lis R10, -2 */
		/* 820AE098h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820AE098h case    0:*/		return 0x820AE09C;
		  /* 820AE09Ch */ case    1:  		/* ori R10, R10, 1023 */
		/* 820AE09Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3FF);
		/* 820AE09Ch case    1:*/		return 0x820AE0A0;
		  /* 820AE0A0h */ case    2:  		/* subf. R11, R10, R11 */
		/* 820AE0A0h case    2:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820AE0A0h case    2:*/		return 0x820AE0A4;
		  /* 820AE0A4h */ case    3:  		/* bc 12, CR0_EQ, 36 */
		/* 820AE0A4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AE0C8;  }
		/* 820AE0A4h case    3:*/		return 0x820AE0A8;
		  /* 820AE0A8h */ case    4:  		/* cmplwi CR6, R11, 64770 */
		/* 820AE0A8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FD02);
		/* 820AE0A8h case    4:*/		return 0x820AE0AC;
		  /* 820AE0ACh */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820AE0ACh case    5:*/		if ( regs.CR[6].eq ) { return 0x820AE0C0;  }
		/* 820AE0ACh case    5:*/		return 0x820AE0B0;
		  /* 820AE0B0h */ case    6:  		/* cmplwi CR6, R11, 64771 */
		/* 820AE0B0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FD03);
		/* 820AE0B0h case    6:*/		return 0x820AE0B4;
		  /* 820AE0B4h */ case    7:  		/* bc 4, CR6_EQ, 100 */
		/* 820AE0B4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820AE118;  }
		/* 820AE0B4h case    7:*/		return 0x820AE0B8;
		  /* 820AE0B8h */ case    8:  		/* li R11, 7 */
		/* 820AE0B8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 820AE0B8h case    8:*/		return 0x820AE0BC;
		  /* 820AE0BCh */ case    9:  		/* b 172 */
		/* 820AE0BCh case    9:*/		return 0x820AE168;
		/* 820AE0BCh case    9:*/		return 0x820AE0C0;
	}
	return 0x820AE0C0;
} // Block from 820AE098h-820AE0C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AE0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE0C0);
		  /* 820AE0C0h */ case    0:  		/* li R11, 6 */
		/* 820AE0C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 820AE0C0h case    0:*/		return 0x820AE0C4;
		  /* 820AE0C4h */ case    1:  		/* b 164 */
		/* 820AE0C4h case    1:*/		return 0x820AE168;
		/* 820AE0C4h case    1:*/		return 0x820AE0C8;
	}
	return 0x820AE0C8;
} // Block from 820AE0C0h-820AE0C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE0C8);
		  /* 820AE0C8h */ case    0:  		/* li R11, 5 */
		/* 820AE0C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820AE0C8h case    0:*/		return 0x820AE0CC;
		  /* 820AE0CCh */ case    1:  		/* b 156 */
		/* 820AE0CCh case    1:*/		return 0x820AE168;
		/* 820AE0CCh case    1:*/		return 0x820AE0D0;
	}
	return 0x820AE0D0;
} // Block from 820AE0C8h-820AE0D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE0D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE0D0);
		  /* 820AE0D0h */ case    0:  		/* li R11, 8 */
		/* 820AE0D0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820AE0D0h case    0:*/		return 0x820AE0D4;
		  /* 820AE0D4h */ case    1:  		/* b 148 */
		/* 820AE0D4h case    1:*/		return 0x820AE168;
		/* 820AE0D4h case    1:*/		return 0x820AE0D8;
	}
	return 0x820AE0D8;
} // Block from 820AE0D0h-820AE0D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE0D8);
		  /* 820AE0D8h */ case    0:  		/* lis R10, -1 */
		/* 820AE0D8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820AE0D8h case    0:*/		return 0x820AE0DC;
		  /* 820AE0DCh */ case    1:  		/* ori R10, R10, 260 */
		/* 820AE0DCh case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x104);
		/* 820AE0DCh case    1:*/		return 0x820AE0E0;
		  /* 820AE0E0h */ case    2:  		/* subf. R11, R10, R11 */
		/* 820AE0E0h case    2:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820AE0E0h case    2:*/		return 0x820AE0E4;
		  /* 820AE0E4h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820AE0E4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AE164;  }
		/* 820AE0E4h case    3:*/		return 0x820AE0E8;
	}
	return 0x820AE0E8;
} // Block from 820AE0D8h-820AE0E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE0E8h
// Function '?d3dxasm_parse@CAssemblerYaccStruct@D3DXShader@@QAAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE0E8);
		  /* 820AE0E8h */ case    0:  		/* cmplwi CR6, R11, 252 */
		/* 820AE0E8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FC);
		/* 820AE0E8h case    0:*/		return 0x820AE0EC;
		  /* 820AE0ECh */ case    1:  		/* bc 12, CR6_EQ, 112 */
		/* 820AE0ECh case    1:*/		if ( regs.CR[6].eq ) { return 0x820AE15C;  }
		/* 820AE0ECh case    1:*/		return 0x820AE0F0;
		  /* 820AE0F0h */ case    2:  		/* cmplwi CR6, R11, 253 */
		/* 820AE0F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FD);
		/* 820AE0F0h case    2:*/		return 0x820AE0F4;
		  /* 820AE0F4h */ case    3:  		/* bc 12, CR6_EQ, 96 */
		/* 820AE0F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AE154;  }
		/* 820AE0F4h case    3:*/		return 0x820AE0F8;
		  /* 820AE0F8h */ case    4:  		/* cmplwi CR6, R11, 352 */
		/* 820AE0F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000160);
		/* 820AE0F8h case    4:*/		return 0x820AE0FC;
		  /* 820AE0FCh */ case    5:  		/* bc 12, CR6_EQ, 80 */
		/* 820AE0FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820AE14C;  }
		/* 820AE0FCh case    5:*/		return 0x820AE100;
		  /* 820AE100h */ case    6:  		/* cmplwi CR6, R11, 507 */
		/* 820AE100h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000001FB);
		/* 820AE100h case    6:*/		return 0x820AE104;
		  /* 820AE104h */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 820AE104h case    7:*/		if ( regs.CR[6].eq ) { return 0x820AE144;  }
		/* 820AE104h case    7:*/		return 0x820AE108;
		  /* 820AE108h */ case    8:  		/* cmplwi CR6, R11, 508 */
		/* 820AE108h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000001FC);
		/* 820AE108h case    8:*/		return 0x820AE10C;
		  /* 820AE10Ch */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 820AE10Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820AE13C;  }
		/* 820AE10Ch case    9:*/		return 0x820AE110;
		  /* 820AE110h */ case   10:  		/* cmplwi CR6, R11, 763 */
		/* 820AE110h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000002FB);
		/* 820AE110h case   10:*/		return 0x820AE114;
		  /* 820AE114h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820AE114h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AE134;  }
		/* 820AE114h case   11:*/		return 0x820AE118;
	}
	return 0x820AE118;
} // Block from 820AE0E8h-820AE118h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AE118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE118);
		  /* 820AE118h */ case    0:  		/* lis R11, -32255 */
		/* 820AE118h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE118h case    0:*/		return 0x820AE11C;
		  /* 820AE11Ch */ case    1:  		/* li R5, 2002 */
		/* 820AE11Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x7D2);
		/* 820AE11Ch case    1:*/		return 0x820AE120;
		  /* 820AE120h */ case    2:  		/* addi R6, R11, 6528 */
		/* 820AE120h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1980);
		/* 820AE120h case    2:*/		return 0x820AE124;
	}
	return 0x820AE124;
} // Block from 820AE118h-820AE124h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE124);
		  /* 820AE124h */ case    0:  		/* mr R4, R29 */
		/* 820AE124h case    0:*/		regs.R4 = regs.R29;
		/* 820AE124h case    0:*/		return 0x820AE128;
		  /* 820AE128h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AE128h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AE128h case    1:*/		return 0x820AE12C;
		  /* 820AE12Ch */ case    2:  		/* bl -28572 */
		/* 820AE12Ch case    2:*/		regs.LR = 0x820AE130; return 0x820A7190;
		/* 820AE12Ch case    2:*/		return 0x820AE130;
		  /* 820AE130h */ case    3:  		/* b 588 */
		/* 820AE130h case    3:*/		return 0x820AE37C;
		/* 820AE130h case    3:*/		return 0x820AE134;
	}
	return 0x820AE134;
} // Block from 820AE124h-820AE134h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE134);
		  /* 820AE134h */ case    0:  		/* li R11, 15 */
		/* 820AE134h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 820AE134h case    0:*/		return 0x820AE138;
		  /* 820AE138h */ case    1:  		/* b 48 */
		/* 820AE138h case    1:*/		return 0x820AE168;
		/* 820AE138h case    1:*/		return 0x820AE13C;
	}
	return 0x820AE13C;
} // Block from 820AE134h-820AE13Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE13C);
		  /* 820AE13Ch */ case    0:  		/* li R11, 14 */
		/* 820AE13Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 820AE13Ch case    0:*/		return 0x820AE140;
		  /* 820AE140h */ case    1:  		/* b 40 */
		/* 820AE140h case    1:*/		return 0x820AE168;
		/* 820AE140h case    1:*/		return 0x820AE144;
	}
	return 0x820AE144;
} // Block from 820AE13Ch-820AE144h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE144);
		  /* 820AE144h */ case    0:  		/* li R11, 13 */
		/* 820AE144h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xD);
		/* 820AE144h case    0:*/		return 0x820AE148;
		  /* 820AE148h */ case    1:  		/* b 32 */
		/* 820AE148h case    1:*/		return 0x820AE168;
		/* 820AE148h case    1:*/		return 0x820AE14C;
	}
	return 0x820AE14C;
} // Block from 820AE144h-820AE14Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE14C);
		  /* 820AE14Ch */ case    0:  		/* li R11, 11 */
		/* 820AE14Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 820AE14Ch case    0:*/		return 0x820AE150;
		  /* 820AE150h */ case    1:  		/* b 24 */
		/* 820AE150h case    1:*/		return 0x820AE168;
		/* 820AE150h case    1:*/		return 0x820AE154;
	}
	return 0x820AE154;
} // Block from 820AE14Ch-820AE154h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE154);
		  /* 820AE154h */ case    0:  		/* li R11, 12 */
		/* 820AE154h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 820AE154h case    0:*/		return 0x820AE158;
		  /* 820AE158h */ case    1:  		/* b 16 */
		/* 820AE158h case    1:*/		return 0x820AE168;
		/* 820AE158h case    1:*/		return 0x820AE15C;
	}
	return 0x820AE15C;
} // Block from 820AE154h-820AE15Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE15Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE15C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE15C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE15C);
		  /* 820AE15Ch */ case    0:  		/* li R11, 10 */
		/* 820AE15Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 820AE15Ch case    0:*/		return 0x820AE160;
		  /* 820AE160h */ case    1:  		/* b 8 */
		/* 820AE160h case    1:*/		return 0x820AE168;
		/* 820AE160h case    1:*/		return 0x820AE164;
	}
	return 0x820AE164;
} // Block from 820AE15Ch-820AE164h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE164);
		  /* 820AE164h */ case    0:  		/* li R11, 9 */
		/* 820AE164h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 820AE164h case    0:*/		return 0x820AE168;
	}
	return 0x820AE168;
} // Block from 820AE164h-820AE168h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE168);
		  /* 820AE168h */ case    0:  		/* stw R11, <#[R31 + 64]> */
		/* 820AE168h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AE168h case    0:*/		return 0x820AE16C;
	}
	return 0x820AE16C;
} // Block from 820AE168h-820AE16Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE16C);
		  /* 820AE16Ch */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820AE16Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820AE16Ch case    0:*/		return 0x820AE170;
		  /* 820AE170h */ case    1:  		/* bc 12, CR6_EQ, 184 */
		/* 820AE170h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AE228;  }
		/* 820AE170h case    1:*/		return 0x820AE174;
		  /* 820AE174h */ case    2:  		/* lwz R11, <#[R31 + 68]> */
		/* 820AE174h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820AE174h case    2:*/		return 0x820AE178;
		  /* 820AE178h */ case    3:  		/* lis R4, 9345 */
		/* 820AE178h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820AE178h case    3:*/		return 0x820AE17C;
		  /* 820AE17Ch */ case    4:  		/* stw R27, <#[R31 + 136]> */
		/* 820AE17Ch case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000088) );
		/* 820AE17Ch case    4:*/		return 0x820AE180;
		  /* 820AE180h */ case    5:  		/* li R3, 184 */
		/* 820AE180h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0xB8);
		/* 820AE180h case    5:*/		return 0x820AE184;
		  /* 820AE184h */ case    6:  		/* ori R11, R11, 2 */
		/* 820AE184h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820AE184h case    6:*/		return 0x820AE188;
		  /* 820AE188h */ case    7:  		/* stw R11, <#[R31 + 68]> */
		/* 820AE188h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820AE188h case    7:*/		return 0x820AE18C;
		  /* 820AE18Ch */ case    8:  		/* bl -155532 */
		/* 820AE18Ch case    8:*/		regs.LR = 0x820AE190; return 0x82088200;
		/* 820AE18Ch case    8:*/		return 0x820AE190;
		  /* 820AE190h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820AE190h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AE190h case    9:*/		return 0x820AE194;
		  /* 820AE194h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820AE194h case   10:*/		if ( regs.CR[0].eq ) { return 0x820AE1A4;  }
		/* 820AE194h case   10:*/		return 0x820AE198;
		  /* 820AE198h */ case   11:  		/* lwz R4, <#[R31 + 64]> */
		/* 820AE198h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000040) );
		/* 820AE198h case   11:*/		return 0x820AE19C;
		  /* 820AE19Ch */ case   12:  		/* bl -19276 */
		/* 820AE19Ch case   12:*/		regs.LR = 0x820AE1A0; return 0x820A9650;
		/* 820AE19Ch case   12:*/		return 0x820AE1A0;
		  /* 820AE1A0h */ case   13:  		/* b 8 */
		/* 820AE1A0h case   13:*/		return 0x820AE1A8;
		/* 820AE1A0h case   13:*/		return 0x820AE1A4;
	}
	return 0x820AE1A4;
} // Block from 820AE16Ch-820AE1A4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820AE1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE1A4);
		  /* 820AE1A4h */ case    0:  		/* mr R3, R24 */
		/* 820AE1A4h case    0:*/		regs.R3 = regs.R24;
		/* 820AE1A4h case    0:*/		return 0x820AE1A8;
	}
	return 0x820AE1A8;
} // Block from 820AE1A4h-820AE1A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE1A8);
		  /* 820AE1A8h */ case    0:  		/* stw R3, <#[R31 + 132]> */
		/* 820AE1A8h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000084) );
		/* 820AE1A8h case    0:*/		return 0x820AE1AC;
		  /* 820AE1ACh */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820AE1ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AE1ACh case    1:*/		return 0x820AE1B0;
		  /* 820AE1B0h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820AE1B0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AE1C0;  }
		/* 820AE1B0h case    2:*/		return 0x820AE1B4;
		  /* 820AE1B4h */ case    3:  		/* lis R3, -32761 */
		/* 820AE1B4h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820AE1B4h case    3:*/		return 0x820AE1B8;
		  /* 820AE1B8h */ case    4:  		/* ori R3, R3, 14 */
		/* 820AE1B8h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820AE1B8h case    4:*/		return 0x820AE1BC;
		  /* 820AE1BCh */ case    5:  		/* b 944 */
		/* 820AE1BCh case    5:*/		return 0x820AE56C;
		/* 820AE1BCh case    5:*/		return 0x820AE1C0;
	}
	return 0x820AE1C0;
} // Block from 820AE1A8h-820AE1C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AE1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE1C0);
		  /* 820AE1C0h */ case    0:  		/* lwz R11, <#[R31 + 64]> */
		/* 820AE1C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820AE1C0h case    0:*/		return 0x820AE1C4;
		  /* 820AE1C4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AE1C4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AE1C4h case    1:*/		return 0x820AE1C8;
		  /* 820AE1C8h */ case    2:  		/* bc 12, CR6_LT, 28 */
		/* 820AE1C8h case    2:*/		if ( regs.CR[6].lt ) { return 0x820AE1E4;  }
		/* 820AE1C8h case    2:*/		return 0x820AE1CC;
		  /* 820AE1CCh */ case    3:  		/* cmpwi CR6, R11, 5 */
		/* 820AE1CCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 820AE1CCh case    3:*/		return 0x820AE1D0;
		  /* 820AE1D0h */ case    4:  		/* bc 12, CR6_GT, 20 */
		/* 820AE1D0h case    4:*/		if ( regs.CR[6].gt ) { return 0x820AE1E4;  }
		/* 820AE1D0h case    4:*/		return 0x820AE1D4;
		  /* 820AE1D4h */ case    5:  		/* lbz R11, <#[R31 + 26]> */
		/* 820AE1D4h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001A) );
		/* 820AE1D4h case    5:*/		return 0x820AE1D8;
		  /* 820AE1D8h */ case    6:  		/* rlwinm R11, R11, 8, 0, 31 */
		/* 820AE1D8h case    6:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R11,regs.R11);
		/* 820AE1D8h case    6:*/		return 0x820AE1DC;
		  /* 820AE1DCh */ case    7:  		/* oris R11, R11, 32766 */
		/* 820AE1DCh case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x7FFE);
		/* 820AE1DCh case    7:*/		return 0x820AE1E0;
		  /* 820AE1E0h */ case    8:  		/* b 32 */
		/* 820AE1E0h case    8:*/		return 0x820AE200;
		/* 820AE1E0h case    8:*/		return 0x820AE1E4;
	}
	return 0x820AE1E4;
} // Block from 820AE1C0h-820AE1E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AE1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE1E4);
		  /* 820AE1E4h */ case    0:  		/* cmpwi CR6, R11, 10 */
		/* 820AE1E4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820AE1E4h case    0:*/		return 0x820AE1E8;
		  /* 820AE1E8h */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 820AE1E8h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AE210;  }
		/* 820AE1E8h case    1:*/		return 0x820AE1EC;
		  /* 820AE1ECh */ case    2:  		/* cmpwi CR6, R11, 15 */
		/* 820AE1ECh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 820AE1ECh case    2:*/		return 0x820AE1F0;
		  /* 820AE1F0h */ case    3:  		/* bc 12, CR6_GT, 32 */
		/* 820AE1F0h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AE210;  }
		/* 820AE1F0h case    3:*/		return 0x820AE1F4;
		  /* 820AE1F4h */ case    4:  		/* lbz R11, <#[R31 + 26]> */
		/* 820AE1F4h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001A) );
		/* 820AE1F4h case    4:*/		return 0x820AE1F8;
		  /* 820AE1F8h */ case    5:  		/* rlwinm R11, R11, 8, 0, 31 */
		/* 820AE1F8h case    5:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R11,regs.R11);
		/* 820AE1F8h case    5:*/		return 0x820AE1FC;
		  /* 820AE1FCh */ case    6:  		/* oris R11, R11, 32767 */
		/* 820AE1FCh case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x7FFF);
		/* 820AE1FCh case    6:*/		return 0x820AE200;
	}
	return 0x820AE200;
} // Block from 820AE1E4h-820AE200h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AE200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE200);
		  /* 820AE200h */ case    0:  		/* lbz R10, <#[R31 + 27]> */
		/* 820AE200h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001B) );
		/* 820AE200h case    0:*/		return 0x820AE204;
		  /* 820AE204h */ case    1:  		/* or R11, R11, R10 */
		/* 820AE204h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820AE204h case    1:*/		return 0x820AE208;
		  /* 820AE208h */ case    2:  		/* stw R11, <#[R31 + 24]> */
		/* 820AE208h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820AE208h case    2:*/		return 0x820AE20C;
		  /* 820AE20Ch */ case    3:  		/* b 28 */
		/* 820AE20Ch case    3:*/		return 0x820AE228;
		/* 820AE20Ch case    3:*/		return 0x820AE210;
	}
	return 0x820AE210;
} // Block from 820AE200h-820AE210h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE210);
		  /* 820AE210h */ case    0:  		/* lis R11, -32255 */
		/* 820AE210h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE210h case    0:*/		return 0x820AE214;
		  /* 820AE214h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AE214h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AE214h case    1:*/		return 0x820AE218;
		  /* 820AE218h */ case    2:  		/* li R5, 2001 */
		/* 820AE218h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x7D1);
		/* 820AE218h case    2:*/		return 0x820AE21C;
		  /* 820AE21Ch */ case    3:  		/* addi R6, R11, 6424 */
		/* 820AE21Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1918);
		/* 820AE21Ch case    3:*/		return 0x820AE220;
		  /* 820AE220h */ case    4:  		/* mr R4, R29 */
		/* 820AE220h case    4:*/		regs.R4 = regs.R29;
		/* 820AE220h case    4:*/		return 0x820AE224;
		  /* 820AE224h */ case    5:  		/* bl -28820 */
		/* 820AE224h case    5:*/		regs.LR = 0x820AE228; return 0x820A7190;
		/* 820AE224h case    5:*/		return 0x820AE228;
	}
	return 0x820AE228;
} // Block from 820AE210h-820AE228h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AE228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE228);
		  /* 820AE228h */ case    0:  		/* lwz R11, <#[R31 + 68]> */
		/* 820AE228h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820AE228h case    0:*/		return 0x820AE22C;
		  /* 820AE22Ch */ case    1:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820AE22Ch case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820AE22Ch case    1:*/		return 0x820AE230;
		  /* 820AE230h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 820AE230h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820AE238;  }
		/* 820AE230h case    2:*/		return 0x820AE234;
		  /* 820AE234h */ case    3:  		/* stw R24, <#[R31 + 8]> */
		/* 820AE234h case    3:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000008) );
		/* 820AE234h case    3:*/		return 0x820AE238;
	}
	return 0x820AE238;
} // Block from 820AE228h-820AE238h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE238);
		  /* 820AE238h */ case    0:  		/* mr R3, R31 */
		/* 820AE238h case    0:*/		regs.R3 = regs.R31;
		/* 820AE238h case    0:*/		return 0x820AE23C;
		  /* 820AE23Ch */ case    1:  		/* lwz R4, <#[R31 + 24]> */
		/* 820AE23Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820AE23Ch case    1:*/		return 0x820AE240;
		  /* 820AE240h */ case    2:  		/* bl -15248 */
		/* 820AE240h case    2:*/		regs.LR = 0x820AE244; return 0x820AA6B0;
		/* 820AE240h case    2:*/		return 0x820AE244;
		  /* 820AE244h */ case    3:  		/* or. R30, R3, R3 */
		/* 820AE244h case    3:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE244h case    3:*/		return 0x820AE248;
		  /* 820AE248h */ case    4:  		/* bc 12, CR0_LT, 744 */
		/* 820AE248h case    4:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820AE248h case    4:*/		return 0x820AE24C;
		  /* 820AE24Ch */ case    5:  		/* mr R4, R29 */
		/* 820AE24Ch case    5:*/		regs.R4 = regs.R29;
		/* 820AE24Ch case    5:*/		return 0x820AE250;
		  /* 820AE250h */ case    6:  		/* mr R3, R31 */
		/* 820AE250h case    6:*/		regs.R3 = regs.R31;
		/* 820AE250h case    6:*/		return 0x820AE254;
		  /* 820AE254h */ case    7:  		/* bl -21212 */
		/* 820AE254h case    7:*/		regs.LR = 0x820AE258; return 0x820A8F78;
		/* 820AE254h case    7:*/		return 0x820AE258;
		  /* 820AE258h */ case    8:  		/* or. R30, R3, R3 */
		/* 820AE258h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE258h case    8:*/		return 0x820AE25C;
		  /* 820AE25Ch */ case    9:  		/* bc 12, CR0_LT, 724 */
		/* 820AE25Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820AE25Ch case    9:*/		return 0x820AE260;
		  /* 820AE260h */ case   10:  		/* lwz R11, <#[R31 + 84]> */
		/* 820AE260h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820AE260h case   10:*/		return 0x820AE264;
		  /* 820AE264h */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 820AE264h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AE264h case   11:*/		return 0x820AE268;
		  /* 820AE268h */ case   12:  		/* bc 4, CR6_EQ, 44 */
		/* 820AE268h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820AE294;  }
		/* 820AE268h case   12:*/		return 0x820AE26C;
		  /* 820AE26Ch */ case   13:  		/* li R5, 3036 */
		/* 820AE26Ch case   13:*/		cpu::op::li<0>(regs,&regs.R5,0xBDC);
		/* 820AE26Ch case   13:*/		return 0x820AE270;
		  /* 820AE270h */ case   14:  		/* li R4, 0 */
		/* 820AE270h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AE270h case   14:*/		return 0x820AE274;
		  /* 820AE274h */ case   15:  		/* addi R3, R1, 160 */
		/* 820AE274h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820AE274h case   15:*/		return 0x820AE278;
		  /* 820AE278h */ case   16:  		/* bl -118584 */
		/* 820AE278h case   16:*/		regs.LR = 0x820AE27C; return 0x82091340;
		/* 820AE278h case   16:*/		return 0x820AE27C;
		  /* 820AE27Ch */ case   17:  		/* stw R31, <#[R1 + 3192]> */
		/* 820AE27Ch case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000C78) );
		/* 820AE27Ch case   17:*/		return 0x820AE280;
		  /* 820AE280h */ case   18:  		/* addi R3, R1, 160 */
		/* 820AE280h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 820AE280h case   18:*/		return 0x820AE284;
		  /* 820AE284h */ case   19:  		/* bl -3012 */
		/* 820AE284h case   19:*/		regs.LR = 0x820AE288; return 0x820AD6C0;
		/* 820AE284h case   19:*/		return 0x820AE288;
		  /* 820AE288h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820AE288h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AE288h case   20:*/		return 0x820AE28C;
		  /* 820AE28Ch */ case   21:  		/* bc 12, CR0_EQ, 8 */
		/* 820AE28Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x820AE294;  }
		/* 820AE28Ch case   21:*/		return 0x820AE290;
		  /* 820AE290h */ case   22:  		/* stw R21, <#[R31 + 84]> */
		/* 820AE290h case   22:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000054) );
		/* 820AE290h case   22:*/		return 0x820AE294;
	}
	return 0x820AE294;
} // Block from 820AE238h-820AE294h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820AE294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE294);
		  /* 820AE294h */ case    0:  		/* lwz R11, <#[R31 + 84]> */
		/* 820AE294h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820AE294h case    0:*/		return 0x820AE298;
		  /* 820AE298h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820AE298h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AE298h case    1:*/		return 0x820AE29C;
		  /* 820AE29Ch */ case    2:  		/* bc 4, CR6_EQ, 224 */
		/* 820AE29Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AE37C;  }
		/* 820AE29Ch case    2:*/		return 0x820AE2A0;
		  /* 820AE2A0h */ case    3:  		/* lwz R11, <#[R26]> */
		/* 820AE2A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820AE2A0h case    3:*/		return 0x820AE2A4;
		  /* 820AE2A4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820AE2A4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AE2A4h case    4:*/		return 0x820AE2A8;
		  /* 820AE2A8h */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 820AE2A8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AE2E4;  }
		/* 820AE2A8h case    5:*/		return 0x820AE2AC;
		  /* 820AE2ACh */ case    6:  		/* li R5, 0 */
		/* 820AE2ACh case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820AE2ACh case    6:*/		return 0x820AE2B0;
		  /* 820AE2B0h */ case    7:  		/* lwz R3, <#[R31 + 4]> */
		/* 820AE2B0h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820AE2B0h case    7:*/		return 0x820AE2B4;
		  /* 820AE2B4h */ case    8:  		/* addi R4, R1, 128 */
		/* 820AE2B4h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 820AE2B4h case    8:*/		return 0x820AE2B8;
		  /* 820AE2B8h */ case    9:  		/* bl -58528 */
		/* 820AE2B8h case    9:*/		regs.LR = 0x820AE2BC; return 0x8209FE18;
		/* 820AE2B8h case    9:*/		return 0x820AE2BC;
		  /* 820AE2BCh */ case   10:  		/* lwz R11, <#[R26]> */
		/* 820AE2BCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820AE2BCh case   10:*/		return 0x820AE2C0;
		  /* 820AE2C0h */ case   11:  		/* lwz R10, <#[R1 + 128]> */
		/* 820AE2C0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820AE2C0h case   11:*/		return 0x820AE2C4;
		  /* 820AE2C4h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820AE2C4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AE2C4h case   12:*/		return 0x820AE2C8;
		  /* 820AE2C8h */ case   13:  		/* bc 4, CR6_LT, 28 */
		/* 820AE2C8h case   13:*/		if ( !regs.CR[6].lt ) { return 0x820AE2E4;  }
		/* 820AE2C8h case   13:*/		return 0x820AE2CC;
		  /* 820AE2CCh */ case   14:  		/* lwz R9, <#[R25]> */
		/* 820AE2CCh case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 820AE2CCh case   14:*/		return 0x820AE2D0;
		  /* 820AE2D0h */ case   15:  		/* add R9, R11, R9 */
		/* 820AE2D0h case   15:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820AE2D0h case   15:*/		return 0x820AE2D4;
		  /* 820AE2D4h */ case   16:  		/* cmplw CR6, R9, R10 */
		/* 820AE2D4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820AE2D4h case   16:*/		return 0x820AE2D8;
		  /* 820AE2D8h */ case   17:  		/* bc 4, CR6_GT, 12 */
		/* 820AE2D8h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820AE2E4;  }
		/* 820AE2D8h case   17:*/		return 0x820AE2DC;
		  /* 820AE2DCh */ case   18:  		/* subf R11, R11, R10 */
		/* 820AE2DCh case   18:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820AE2DCh case   18:*/		return 0x820AE2E0;
		  /* 820AE2E0h */ case   19:  		/* stw R11, <#[R25]> */
		/* 820AE2E0h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AE2E0h case   19:*/		return 0x820AE2E4;
	}
	return 0x820AE2E4;
} // Block from 820AE294h-820AE2E4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AE2E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE2E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE2E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE2E4);
		  /* 820AE2E4h */ case    0:  		/* lwz R11, <#[R31 + 132]> */
		/* 820AE2E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 820AE2E4h case    0:*/		return 0x820AE2E8;
		  /* 820AE2E8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AE2E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AE2E8h case    1:*/		return 0x820AE2EC;
		  /* 820AE2ECh */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820AE2ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x820AE300;  }
		/* 820AE2ECh case    2:*/		return 0x820AE2F0;
		  /* 820AE2F0h */ case    3:  		/* mr R3, R31 */
		/* 820AE2F0h case    3:*/		regs.R3 = regs.R31;
		/* 820AE2F0h case    3:*/		return 0x820AE2F4;
		  /* 820AE2F4h */ case    4:  		/* bl -12804 */
		/* 820AE2F4h case    4:*/		regs.LR = 0x820AE2F8; return 0x820AB0F0;
		/* 820AE2F4h case    4:*/		return 0x820AE2F8;
		  /* 820AE2F8h */ case    5:  		/* or. R30, R3, R3 */
		/* 820AE2F8h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE2F8h case    5:*/		return 0x820AE2FC;
		  /* 820AE2FCh */ case    6:  		/* bc 12, CR0_LT, 564 */
		/* 820AE2FCh case    6:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820AE2FCh case    6:*/		return 0x820AE300;
	}
	return 0x820AE300;
} // Block from 820AE2E4h-820AE300h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AE300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE300);
		  /* 820AE300h */ case    0:  		/* lwz R11, <#[R31 + 68]> */
		/* 820AE300h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000044) );
		/* 820AE300h case    0:*/		return 0x820AE304;
		  /* 820AE304h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820AE304h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820AE304h case    1:*/		return 0x820AE308;
		  /* 820AE308h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820AE308h case    2:*/		if ( regs.CR[0].eq ) { return 0x820AE31C;  }
		/* 820AE308h case    2:*/		return 0x820AE30C;
		  /* 820AE30Ch */ case    3:  		/* mr R3, R31 */
		/* 820AE30Ch case    3:*/		regs.R3 = regs.R31;
		/* 820AE30Ch case    3:*/		return 0x820AE310;
		  /* 820AE310h */ case    4:  		/* bl -11768 */
		/* 820AE310h case    4:*/		regs.LR = 0x820AE314; return 0x820AB518;
		/* 820AE310h case    4:*/		return 0x820AE314;
		  /* 820AE314h */ case    5:  		/* or. R30, R3, R3 */
		/* 820AE314h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE314h case    5:*/		return 0x820AE318;
		  /* 820AE318h */ case    6:  		/* bc 12, CR0_LT, 536 */
		/* 820AE318h case    6:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820AE318h case    6:*/		return 0x820AE31C;
	}
	return 0x820AE31C;
} // Block from 820AE300h-820AE31Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AE31Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE31C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE31C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE31C);
		  /* 820AE31Ch */ case    0:  		/* lis R4, 0 */
		/* 820AE31Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x0);
		/* 820AE31Ch case    0:*/		return 0x820AE320;
		  /* 820AE320h */ case    1:  		/* mr R3, R31 */
		/* 820AE320h case    1:*/		regs.R3 = regs.R31;
		/* 820AE320h case    1:*/		return 0x820AE324;
		  /* 820AE324h */ case    2:  		/* ori R4, R4, 65535 */
		/* 820AE324h case    2:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0xFFFF);
		/* 820AE324h case    2:*/		return 0x820AE328;
		  /* 820AE328h */ case    3:  		/* bl -15480 */
		/* 820AE328h case    3:*/		regs.LR = 0x820AE32C; return 0x820AA6B0;
		/* 820AE328h case    3:*/		return 0x820AE32C;
		  /* 820AE32Ch */ case    4:  		/* or. R30, R3, R3 */
		/* 820AE32Ch case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE32Ch case    4:*/		return 0x820AE330;
		  /* 820AE330h */ case    5:  		/* bc 12, CR0_LT, 512 */
		/* 820AE330h case    5:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820AE330h case    5:*/		return 0x820AE334;
		  /* 820AE334h */ case    6:  		/* mr R4, R29 */
		/* 820AE334h case    6:*/		regs.R4 = regs.R29;
		/* 820AE334h case    6:*/		return 0x820AE338;
		  /* 820AE338h */ case    7:  		/* mr R3, R31 */
		/* 820AE338h case    7:*/		regs.R3 = regs.R31;
		/* 820AE338h case    7:*/		return 0x820AE33C;
		  /* 820AE33Ch */ case    8:  		/* bl -21444 */
		/* 820AE33Ch case    8:*/		regs.LR = 0x820AE340; return 0x820A8F78;
		/* 820AE33Ch case    8:*/		return 0x820AE340;
		  /* 820AE340h */ case    9:  		/* or. R30, R3, R3 */
		/* 820AE340h case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE340h case    9:*/		return 0x820AE344;
		  /* 820AE344h */ case   10:  		/* bc 12, CR0_LT, 492 */
		/* 820AE344h case   10:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820AE344h case   10:*/		return 0x820AE348;
		  /* 820AE348h */ case   11:  		/* lwz R3, <#[R31 + 8]> */
		/* 820AE348h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820AE348h case   11:*/		return 0x820AE34C;
		  /* 820AE34Ch */ case   12:  		/* cmplwi CR6, R3, 0 */
		/* 820AE34Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AE34Ch case   12:*/		return 0x820AE350;
		  /* 820AE350h */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 820AE350h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AE36C;  }
		/* 820AE350h case   13:*/		return 0x820AE354;
		  /* 820AE354h */ case   14:  		/* lwz R11, <#[R3]> */
		/* 820AE354h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820AE354h case   14:*/		return 0x820AE358;
		  /* 820AE358h */ case   15:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AE358h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AE358h case   15:*/		return 0x820AE35C;
		  /* 820AE35Ch */ case   16:  		/* mtspr CTR, R11 */
		/* 820AE35Ch case   16:*/		regs.CTR = regs.R11;
		/* 820AE35Ch case   16:*/		return 0x820AE360;
		  /* 820AE360h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820AE360h case   17:*/		if ( 1 ) { regs.LR = 0x820AE364; return (uint32)regs.CTR; }
		/* 820AE360h case   17:*/		return 0x820AE364;
		  /* 820AE364h */ case   18:  		/* or. R30, R3, R3 */
		/* 820AE364h case   18:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE364h case   18:*/		return 0x820AE368;
		  /* 820AE368h */ case   19:  		/* bc 12, CR0_LT, 456 */
		/* 820AE368h case   19:*/		if ( regs.CR[0].lt ) { return 0x820AE530;  }
		/* 820AE368h case   19:*/		return 0x820AE36C;
	}
	return 0x820AE36C;
} // Block from 820AE31Ch-820AE36Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AE36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE36C);
		  /* 820AE36Ch */ case    0:  		/* lwz R3, <#[R31]> */
		/* 820AE36Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AE36Ch case    0:*/		return 0x820AE370;
		  /* 820AE370h */ case    1:  		/* bl -34384 */
		/* 820AE370h case    1:*/		regs.LR = 0x820AE374; return 0x820A5D20;
		/* 820AE370h case    1:*/		return 0x820AE374;
		  /* 820AE374h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820AE374h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AE374h case    2:*/		return 0x820AE378;
		  /* 820AE378h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820AE378h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AE388;  }
		/* 820AE378h case    3:*/		return 0x820AE37C;
	}
	return 0x820AE37C;
} // Block from 820AE36Ch-820AE37Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE37C);
		  /* 820AE37Ch */ case    0:  		/* lis R30, -30602 */
		/* 820AE37Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8876);
		/* 820AE37Ch case    0:*/		return 0x820AE380;
		  /* 820AE380h */ case    1:  		/* ori R30, R30, 2905 */
		/* 820AE380h case    1:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xB59);
		/* 820AE380h case    1:*/		return 0x820AE384;
		  /* 820AE384h */ case    2:  		/* b 428 */
		/* 820AE384h case    2:*/		return 0x820AE530;
		/* 820AE384h case    2:*/		return 0x820AE388;
	}
	return 0x820AE388;
} // Block from 820AE37Ch-820AE388h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE388);
		  /* 820AE388h */ case    0:  		/* mr R5, R22 */
		/* 820AE388h case    0:*/		regs.R5 = regs.R22;
		/* 820AE388h case    0:*/		return 0x820AE38C;
		  /* 820AE38Ch */ case    1:  		/* mr R4, R23 */
		/* 820AE38Ch case    1:*/		regs.R4 = regs.R23;
		/* 820AE38Ch case    1:*/		return 0x820AE390;
		  /* 820AE390h */ case    2:  		/* mr R3, R31 */
		/* 820AE390h case    2:*/		regs.R3 = regs.R31;
		/* 820AE390h case    2:*/		return 0x820AE394;
		  /* 820AE394h */ case    3:  		/* bl -10852 */
		/* 820AE394h case    3:*/		regs.LR = 0x820AE398; return 0x820AB930;
		/* 820AE394h case    3:*/		return 0x820AE398;
		  /* 820AE398h */ case    4:  		/* or. R30, R3, R3 */
		/* 820AE398h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820AE398h case    4:*/		return 0x820AE39C;
		  /* 820AE39Ch */ case    5:  		/* bc 4, CR0_LT, 412 */
		/* 820AE39Ch case    5:*/		if ( !regs.CR[0].lt ) { return 0x820AE538;  }
		/* 820AE39Ch case    5:*/		return 0x820AE3A0;
		  /* 820AE3A0h */ case    6:  		/* addis R11, R30, 30602 */
		/* 820AE3A0h case    6:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R30,0x778A);
		/* 820AE3A0h case    6:*/		return 0x820AE3A4;
		  /* 820AE3A4h */ case    7:  		/* addi R11, R11, -2920 */
		/* 820AE3A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFF498);
		/* 820AE3A4h case    7:*/		return 0x820AE3A8;
		  /* 820AE3A8h */ case    8:  		/* cmplwi CR6, R11, 24 */
		/* 820AE3A8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 820AE3A8h case    8:*/		return 0x820AE3AC;
		  /* 820AE3ACh */ case    9:  		/* bc 12, CR6_GT, 364 */
		/* 820AE3ACh case    9:*/		if ( regs.CR[6].gt ) { return 0x820AE518;  }
		/* 820AE3ACh case    9:*/		return 0x820AE3B0;
		  /* 820AE3B0h */ case   10:  		/* lis R12, -32255 */
		/* 820AE3B0h case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820AE3B0h case   10:*/		return 0x820AE3B4;
		  /* 820AE3B4h */ case   11:  		/* addi R12, R12, 2232 */
		/* 820AE3B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x8B8);
		/* 820AE3B4h case   11:*/		return 0x820AE3B8;
		  /* 820AE3B8h */ case   12:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820AE3B8h case   12:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820AE3B8h case   12:*/		return 0x820AE3BC;
		  /* 820AE3BCh */ case   13:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 820AE3BCh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 820AE3BCh case   13:*/		return 0x820AE3C0;
		  /* 820AE3C0h */ case   14:  		/* lis R12, -32245 */
		/* 820AE3C0h case   14:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820B);
		/* 820AE3C0h case   14:*/		return 0x820AE3C4;
		  /* 820AE3C4h */ case   15:  		/* ori R0, R0, 0 */
		/* 820AE3C4h case   15:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820AE3C4h case   15:*/		return 0x820AE3C8;
		  /* 820AE3C8h */ case   16:  		/* addi R12, R12, -7208 */
		/* 820AE3C8h case   16:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFE3D8);
		/* 820AE3C8h case   16:*/		return 0x820AE3CC;
		  /* 820AE3CCh */ case   17:  		/* add R12, R12, R0 */
		/* 820AE3CCh case   17:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820AE3CCh case   17:*/		return 0x820AE3D0;
		  /* 820AE3D0h */ case   18:  		/* mtspr CTR, R12 */
		/* 820AE3D0h case   18:*/		regs.CTR = regs.R12;
		/* 820AE3D0h case   18:*/		return 0x820AE3D4;
		  /* 820AE3D4h */ case   19:  		/* bcctr 20, CR0_LT */
		/* 820AE3D4h case   19:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820AE3D4h case   19:*/		return 0x820AE3D8;
		  /* 820AE3D8h */ case   20:  		/* lis R11, -32255 */
		/* 820AE3D8h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE3D8h case   20:*/		return 0x820AE3DC;
		  /* 820AE3DCh */ case   21:  		/* li R5, 7001 */
		/* 820AE3DCh case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x1B59);
		/* 820AE3DCh case   21:*/		return 0x820AE3E0;
		  /* 820AE3E0h */ case   22:  		/* addi R6, R11, 6392 */
		/* 820AE3E0h case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x18F8);
		/* 820AE3E0h case   22:*/		return 0x820AE3E4;
		  /* 820AE3E4h */ case   23:  		/* b 320 */
		/* 820AE3E4h case   23:*/		return 0x820AE524;
		/* 820AE3E4h case   23:*/		return 0x820AE3E8;
		  /* 820AE3E8h */ case   24:  		/* lis R11, -32255 */
		/* 820AE3E8h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE3E8h case   24:*/		return 0x820AE3EC;
		  /* 820AE3ECh */ case   25:  		/* li R5, 7003 */
		/* 820AE3ECh case   25:*/		cpu::op::li<0>(regs,&regs.R5,0x1B5B);
		/* 820AE3ECh case   25:*/		return 0x820AE3F0;
		  /* 820AE3F0h */ case   26:  		/* addi R6, R11, 6332 */
		/* 820AE3F0h case   26:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x18BC);
		/* 820AE3F0h case   26:*/		return 0x820AE3F4;
		  /* 820AE3F4h */ case   27:  		/* b 304 */
		/* 820AE3F4h case   27:*/		return 0x820AE524;
		/* 820AE3F4h case   27:*/		return 0x820AE3F8;
		  /* 820AE3F8h */ case   28:  		/* lis R11, -32255 */
		/* 820AE3F8h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE3F8h case   28:*/		return 0x820AE3FC;
		  /* 820AE3FCh */ case   29:  		/* li R5, 7002 */
		/* 820AE3FCh case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x1B5A);
		/* 820AE3FCh case   29:*/		return 0x820AE400;
		  /* 820AE400h */ case   30:  		/* addi R6, R11, 6264 */
		/* 820AE400h case   30:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1878);
		/* 820AE400h case   30:*/		return 0x820AE404;
		  /* 820AE404h */ case   31:  		/* b 288 */
		/* 820AE404h case   31:*/		return 0x820AE524;
		/* 820AE404h case   31:*/		return 0x820AE408;
		  /* 820AE408h */ case   32:  		/* lis R11, -32255 */
		/* 820AE408h case   32:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE408h case   32:*/		return 0x820AE40C;
		  /* 820AE40Ch */ case   33:  		/* li R5, 7000 */
		/* 820AE40Ch case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x1B58);
		/* 820AE40Ch case   33:*/		return 0x820AE410;
		  /* 820AE410h */ case   34:  		/* addi R6, R11, 6224 */
		/* 820AE410h case   34:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1850);
		/* 820AE410h case   34:*/		return 0x820AE414;
		  /* 820AE414h */ case   35:  		/* b 272 */
		/* 820AE414h case   35:*/		return 0x820AE524;
		/* 820AE414h case   35:*/		return 0x820AE418;
		  /* 820AE418h */ case   36:  		/* lis R11, -32255 */
		/* 820AE418h case   36:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE418h case   36:*/		return 0x820AE41C;
		  /* 820AE41Ch */ case   37:  		/* li R5, 7004 */
		/* 820AE41Ch case   37:*/		cpu::op::li<0>(regs,&regs.R5,0x1B5C);
		/* 820AE41Ch case   37:*/		return 0x820AE420;
		  /* 820AE420h */ case   38:  		/* addi R6, R11, 6128 */
		/* 820AE420h case   38:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x17F0);
		/* 820AE420h case   38:*/		return 0x820AE424;
		  /* 820AE424h */ case   39:  		/* b 256 */
		/* 820AE424h case   39:*/		return 0x820AE524;
		/* 820AE424h case   39:*/		return 0x820AE428;
		  /* 820AE428h */ case   40:  		/* lis R11, -32255 */
		/* 820AE428h case   40:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE428h case   40:*/		return 0x820AE42C;
		  /* 820AE42Ch */ case   41:  		/* li R5, 7005 */
		/* 820AE42Ch case   41:*/		cpu::op::li<0>(regs,&regs.R5,0x1B5D);
		/* 820AE42Ch case   41:*/		return 0x820AE430;
		  /* 820AE430h */ case   42:  		/* addi R6, R11, 6080 */
		/* 820AE430h case   42:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x17C0);
		/* 820AE430h case   42:*/		return 0x820AE434;
		  /* 820AE434h */ case   43:  		/* b 240 */
		/* 820AE434h case   43:*/		return 0x820AE524;
		/* 820AE434h case   43:*/		return 0x820AE438;
		  /* 820AE438h */ case   44:  		/* lis R11, -32255 */
		/* 820AE438h case   44:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE438h case   44:*/		return 0x820AE43C;
		  /* 820AE43Ch */ case   45:  		/* li R5, 7006 */
		/* 820AE43Ch case   45:*/		cpu::op::li<0>(regs,&regs.R5,0x1B5E);
		/* 820AE43Ch case   45:*/		return 0x820AE440;
		  /* 820AE440h */ case   46:  		/* addi R6, R11, 6032 */
		/* 820AE440h case   46:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1790);
		/* 820AE440h case   46:*/		return 0x820AE444;
		  /* 820AE444h */ case   47:  		/* b 224 */
		/* 820AE444h case   47:*/		return 0x820AE524;
		/* 820AE444h case   47:*/		return 0x820AE448;
		  /* 820AE448h */ case   48:  		/* lis R11, -32255 */
		/* 820AE448h case   48:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE448h case   48:*/		return 0x820AE44C;
		  /* 820AE44Ch */ case   49:  		/* li R5, 7007 */
		/* 820AE44Ch case   49:*/		cpu::op::li<0>(regs,&regs.R5,0x1B5F);
		/* 820AE44Ch case   49:*/		return 0x820AE450;
		  /* 820AE450h */ case   50:  		/* addi R6, R11, 5980 */
		/* 820AE450h case   50:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x175C);
		/* 820AE450h case   50:*/		return 0x820AE454;
		  /* 820AE454h */ case   51:  		/* b 208 */
		/* 820AE454h case   51:*/		return 0x820AE524;
		/* 820AE454h case   51:*/		return 0x820AE458;
		  /* 820AE458h */ case   52:  		/* lis R11, -32255 */
		/* 820AE458h case   52:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE458h case   52:*/		return 0x820AE45C;
		  /* 820AE45Ch */ case   53:  		/* li R5, 7008 */
		/* 820AE45Ch case   53:*/		cpu::op::li<0>(regs,&regs.R5,0x1B60);
		/* 820AE45Ch case   53:*/		return 0x820AE460;
		  /* 820AE460h */ case   54:  		/* addi R6, R11, 5920 */
		/* 820AE460h case   54:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1720);
		/* 820AE460h case   54:*/		return 0x820AE464;
		  /* 820AE464h */ case   55:  		/* b 192 */
		/* 820AE464h case   55:*/		return 0x820AE524;
		/* 820AE464h case   55:*/		return 0x820AE468;
		  /* 820AE468h */ case   56:  		/* lis R11, -32255 */
		/* 820AE468h case   56:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE468h case   56:*/		return 0x820AE46C;
		  /* 820AE46Ch */ case   57:  		/* li R5, 7009 */
		/* 820AE46Ch case   57:*/		cpu::op::li<0>(regs,&regs.R5,0x1B61);
		/* 820AE46Ch case   57:*/		return 0x820AE470;
		  /* 820AE470h */ case   58:  		/* addi R6, R11, 5864 */
		/* 820AE470h case   58:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x16E8);
		/* 820AE470h case   58:*/		return 0x820AE474;
		  /* 820AE474h */ case   59:  		/* b 176 */
		/* 820AE474h case   59:*/		return 0x820AE524;
		/* 820AE474h case   59:*/		return 0x820AE478;
		  /* 820AE478h */ case   60:  		/* lis R11, -32255 */
		/* 820AE478h case   60:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE478h case   60:*/		return 0x820AE47C;
		  /* 820AE47Ch */ case   61:  		/* li R5, 7010 */
		/* 820AE47Ch case   61:*/		cpu::op::li<0>(regs,&regs.R5,0x1B62);
		/* 820AE47Ch case   61:*/		return 0x820AE480;
		  /* 820AE480h */ case   62:  		/* addi R6, R11, 5812 */
		/* 820AE480h case   62:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x16B4);
		/* 820AE480h case   62:*/		return 0x820AE484;
		  /* 820AE484h */ case   63:  		/* b 160 */
		/* 820AE484h case   63:*/		return 0x820AE524;
		/* 820AE484h case   63:*/		return 0x820AE488;
		  /* 820AE488h */ case   64:  		/* lis R11, -32255 */
		/* 820AE488h case   64:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE488h case   64:*/		return 0x820AE48C;
		  /* 820AE48Ch */ case   65:  		/* li R5, 7011 */
		/* 820AE48Ch case   65:*/		cpu::op::li<0>(regs,&regs.R5,0x1B63);
		/* 820AE48Ch case   65:*/		return 0x820AE490;
		  /* 820AE490h */ case   66:  		/* addi R6, R11, 5756 */
		/* 820AE490h case   66:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x167C);
		/* 820AE490h case   66:*/		return 0x820AE494;
		  /* 820AE494h */ case   67:  		/* b 144 */
		/* 820AE494h case   67:*/		return 0x820AE524;
		/* 820AE494h case   67:*/		return 0x820AE498;
		  /* 820AE498h */ case   68:  		/* lis R11, -32255 */
		/* 820AE498h case   68:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE498h case   68:*/		return 0x820AE49C;
		  /* 820AE49Ch */ case   69:  		/* li R5, 7012 */
		/* 820AE49Ch case   69:*/		cpu::op::li<0>(regs,&regs.R5,0x1B64);
		/* 820AE49Ch case   69:*/		return 0x820AE4A0;
		  /* 820AE4A0h */ case   70:  		/* addi R6, R11, 5696 */
		/* 820AE4A0h case   70:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1640);
		/* 820AE4A0h case   70:*/		return 0x820AE4A4;
		  /* 820AE4A4h */ case   71:  		/* b 128 */
		/* 820AE4A4h case   71:*/		return 0x820AE524;
		/* 820AE4A4h case   71:*/		return 0x820AE4A8;
		  /* 820AE4A8h */ case   72:  		/* lis R11, -32255 */
		/* 820AE4A8h case   72:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE4A8h case   72:*/		return 0x820AE4AC;
		  /* 820AE4ACh */ case   73:  		/* li R5, 7013 */
		/* 820AE4ACh case   73:*/		cpu::op::li<0>(regs,&regs.R5,0x1B65);
		/* 820AE4ACh case   73:*/		return 0x820AE4B0;
		  /* 820AE4B0h */ case   74:  		/* addi R6, R11, 5636 */
		/* 820AE4B0h case   74:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1604);
		/* 820AE4B0h case   74:*/		return 0x820AE4B4;
		  /* 820AE4B4h */ case   75:  		/* b 112 */
		/* 820AE4B4h case   75:*/		return 0x820AE524;
		/* 820AE4B4h case   75:*/		return 0x820AE4B8;
		  /* 820AE4B8h */ case   76:  		/* lis R11, -32255 */
		/* 820AE4B8h case   76:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE4B8h case   76:*/		return 0x820AE4BC;
		  /* 820AE4BCh */ case   77:  		/* li R5, 7014 */
		/* 820AE4BCh case   77:*/		cpu::op::li<0>(regs,&regs.R5,0x1B66);
		/* 820AE4BCh case   77:*/		return 0x820AE4C0;
		  /* 820AE4C0h */ case   78:  		/* addi R6, R11, 5568 */
		/* 820AE4C0h case   78:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x15C0);
		/* 820AE4C0h case   78:*/		return 0x820AE4C4;
		  /* 820AE4C4h */ case   79:  		/* b 96 */
		/* 820AE4C4h case   79:*/		return 0x820AE524;
		/* 820AE4C4h case   79:*/		return 0x820AE4C8;
		  /* 820AE4C8h */ case   80:  		/* lis R11, -32255 */
		/* 820AE4C8h case   80:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE4C8h case   80:*/		return 0x820AE4CC;
		  /* 820AE4CCh */ case   81:  		/* li R5, 7012 */
		/* 820AE4CCh case   81:*/		cpu::op::li<0>(regs,&regs.R5,0x1B64);
		/* 820AE4CCh case   81:*/		return 0x820AE4D0;
		  /* 820AE4D0h */ case   82:  		/* addi R6, R11, 5504 */
		/* 820AE4D0h case   82:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1580);
		/* 820AE4D0h case   82:*/		return 0x820AE4D4;
		  /* 820AE4D4h */ case   83:  		/* b 80 */
		/* 820AE4D4h case   83:*/		return 0x820AE524;
		/* 820AE4D4h case   83:*/		return 0x820AE4D8;
		  /* 820AE4D8h */ case   84:  		/* lis R11, -32255 */
		/* 820AE4D8h case   84:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE4D8h case   84:*/		return 0x820AE4DC;
		  /* 820AE4DCh */ case   85:  		/* li R5, 7014 */
		/* 820AE4DCh case   85:*/		cpu::op::li<0>(regs,&regs.R5,0x1B66);
		/* 820AE4DCh case   85:*/		return 0x820AE4E0;
		  /* 820AE4E0h */ case   86:  		/* addi R6, R11, 5440 */
		/* 820AE4E0h case   86:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1540);
		/* 820AE4E0h case   86:*/		return 0x820AE4E4;
		  /* 820AE4E4h */ case   87:  		/* b 64 */
		/* 820AE4E4h case   87:*/		return 0x820AE524;
		/* 820AE4E4h case   87:*/		return 0x820AE4E8;
		  /* 820AE4E8h */ case   88:  		/* lis R11, -32255 */
		/* 820AE4E8h case   88:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE4E8h case   88:*/		return 0x820AE4EC;
		  /* 820AE4ECh */ case   89:  		/* li R5, 7015 */
		/* 820AE4ECh case   89:*/		cpu::op::li<0>(regs,&regs.R5,0x1B67);
		/* 820AE4ECh case   89:*/		return 0x820AE4F0;
		  /* 820AE4F0h */ case   90:  		/* addi R6, R11, 5392 */
		/* 820AE4F0h case   90:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1510);
		/* 820AE4F0h case   90:*/		return 0x820AE4F4;
		  /* 820AE4F4h */ case   91:  		/* b 48 */
		/* 820AE4F4h case   91:*/		return 0x820AE524;
		/* 820AE4F4h case   91:*/		return 0x820AE4F8;
		  /* 820AE4F8h */ case   92:  		/* lis R11, -32255 */
		/* 820AE4F8h case   92:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE4F8h case   92:*/		return 0x820AE4FC;
		  /* 820AE4FCh */ case   93:  		/* li R5, 7016 */
		/* 820AE4FCh case   93:*/		cpu::op::li<0>(regs,&regs.R5,0x1B68);
		/* 820AE4FCh case   93:*/		return 0x820AE500;
		  /* 820AE500h */ case   94:  		/* addi R6, R11, 5344 */
		/* 820AE500h case   94:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x14E0);
		/* 820AE500h case   94:*/		return 0x820AE504;
		  /* 820AE504h */ case   95:  		/* b 32 */
		/* 820AE504h case   95:*/		return 0x820AE524;
		/* 820AE504h case   95:*/		return 0x820AE508;
		  /* 820AE508h */ case   96:  		/* lis R11, -32255 */
		/* 820AE508h case   96:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE508h case   96:*/		return 0x820AE50C;
		  /* 820AE50Ch */ case   97:  		/* li R5, 7017 */
		/* 820AE50Ch case   97:*/		cpu::op::li<0>(regs,&regs.R5,0x1B69);
		/* 820AE50Ch case   97:*/		return 0x820AE510;
		  /* 820AE510h */ case   98:  		/* addi R6, R11, 5288 */
		/* 820AE510h case   98:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x14A8);
		/* 820AE510h case   98:*/		return 0x820AE514;
		  /* 820AE514h */ case   99:  		/* b 16 */
		/* 820AE514h case   99:*/		return 0x820AE524;
		/* 820AE514h case   99:*/		return 0x820AE518;
	}
	return 0x820AE518;
} // Block from 820AE388h-820AE518h (100 instructions)

//////////////////////////////////////////////////////
// Block at 820AE518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE518);
		  /* 820AE518h */ case    0:  		/* lis R11, -32255 */
		/* 820AE518h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE518h case    0:*/		return 0x820AE51C;
		  /* 820AE51Ch */ case    1:  		/* mr R5, R30 */
		/* 820AE51Ch case    1:*/		regs.R5 = regs.R30;
		/* 820AE51Ch case    1:*/		return 0x820AE520;
		  /* 820AE520h */ case    2:  		/* addi R6, R11, 5244 */
		/* 820AE520h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x147C);
		/* 820AE520h case    2:*/		return 0x820AE524;
	}
	return 0x820AE524;
} // Block from 820AE518h-820AE524h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE524);
		  /* 820AE524h */ case    0:  		/* mr R4, R29 */
		/* 820AE524h case    0:*/		regs.R4 = regs.R29;
		/* 820AE524h case    0:*/		return 0x820AE528;
		  /* 820AE528h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820AE528h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820AE528h case    1:*/		return 0x820AE52C;
		  /* 820AE52Ch */ case    2:  		/* bl -29596 */
		/* 820AE52Ch case    2:*/		regs.LR = 0x820AE530; return 0x820A7190;
		/* 820AE52Ch case    2:*/		return 0x820AE530;
	}
	return 0x820AE530;
} // Block from 820AE524h-820AE530h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE530);
		  /* 820AE530h */ case    0:  		/* stw R21, <#[R31 + 84]> */
		/* 820AE530h case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000054) );
		/* 820AE530h case    0:*/		return 0x820AE534;
		  /* 820AE534h */ case    1:  		/* b 8 */
		/* 820AE534h case    1:*/		return 0x820AE53C;
		/* 820AE534h case    1:*/		return 0x820AE538;
	}
	return 0x820AE538;
} // Block from 820AE530h-820AE538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE538);
		  /* 820AE538h */ case    0:  		/* mr R30, R24 */
		/* 820AE538h case    0:*/		regs.R30 = regs.R24;
		/* 820AE538h case    0:*/		return 0x820AE53C;
	}
	return 0x820AE53C;
} // Block from 820AE538h-820AE53Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE53C);
		  /* 820AE53Ch */ case    0:  		/* lwz R3, <#[R31 + 8]> */
		/* 820AE53Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820AE53Ch case    0:*/		return 0x820AE540;
		  /* 820AE540h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820AE540h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820AE540h case    1:*/		return 0x820AE544;
		  /* 820AE544h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820AE544h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AE55C;  }
		/* 820AE544h case    2:*/		return 0x820AE548;
		  /* 820AE548h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820AE548h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820AE548h case    3:*/		return 0x820AE54C;
		  /* 820AE54Ch */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 820AE54Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820AE54Ch case    4:*/		return 0x820AE550;
		  /* 820AE550h */ case    5:  		/* mtspr CTR, R11 */
		/* 820AE550h case    5:*/		regs.CTR = regs.R11;
		/* 820AE550h case    5:*/		return 0x820AE554;
		  /* 820AE554h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820AE554h case    6:*/		if ( 1 ) { regs.LR = 0x820AE558; return (uint32)regs.CTR; }
		/* 820AE554h case    6:*/		return 0x820AE558;
		  /* 820AE558h */ case    7:  		/* stw R24, <#[R31 + 8]> */
		/* 820AE558h case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000008) );
		/* 820AE558h case    7:*/		return 0x820AE55C;
	}
	return 0x820AE55C;
} // Block from 820AE53Ch-820AE55Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AE55Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE55C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE55C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE55C);
		  /* 820AE55Ch */ case    0:  		/* li R4, 0 */
		/* 820AE55Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AE55Ch case    0:*/		return 0x820AE560;
		  /* 820AE560h */ case    1:  		/* lwz R3, <#[R31 + 4]> */
		/* 820AE560h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820AE560h case    1:*/		return 0x820AE564;
		  /* 820AE564h */ case    2:  		/* bl -38716 */
		/* 820AE564h case    2:*/		regs.LR = 0x820AE568; return 0x820A4E28;
		/* 820AE564h case    2:*/		return 0x820AE568;
		  /* 820AE568h */ case    3:  		/* mr R3, R30 */
		/* 820AE568h case    3:*/		regs.R3 = regs.R30;
		/* 820AE568h case    3:*/		return 0x820AE56C;
	}
	return 0x820AE56C;
} // Block from 820AE55Ch-820AE56Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE56C);
		  /* 820AE56Ch */ case    0:  		/* addi R1, R1, 3296 */
		/* 820AE56Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xCE0);
		/* 820AE56Ch case    0:*/		return 0x820AE570;
		  /* 820AE570h */ case    1:  		/* b -119524 */
		/* 820AE570h case    1:*/		return 0x8209128C;
		/* 820AE570h case    1:*/		return 0x820AE574;
		  /* 820AE574h */ case    2:  		/* nop */
		/* 820AE574h case    2:*/		cpu::op::nop();
		/* 820AE574h case    2:*/		return 0x820AE578;
	}
	return 0x820AE578;
} // Block from 820AE56Ch-820AE578h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE578);
		  /* 820AE578h */ case    0:  		/* mfspr R12, LR */
		/* 820AE578h case    0:*/		regs.R12 = regs.LR;
		/* 820AE578h case    0:*/		return 0x820AE57C;
		  /* 820AE57Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AE57Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AE57Ch case    1:*/		return 0x820AE580;
		  /* 820AE580h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820AE580h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AE580h case    2:*/		return 0x820AE584;
		  /* 820AE584h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820AE584h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820AE584h case    3:*/		return 0x820AE588;
		  /* 820AE588h */ case    4:  		/* mr R31, R3 */
		/* 820AE588h case    4:*/		regs.R31 = regs.R3;
		/* 820AE588h case    4:*/		return 0x820AE58C;
		  /* 820AE58Ch */ case    5:  		/* bl 178812 */
		/* 820AE58Ch case    5:*/		regs.LR = 0x820AE590; return 0x820DA008;
		/* 820AE58Ch case    5:*/		return 0x820AE590;
		  /* 820AE590h */ case    6:  		/* lis R11, -32255 */
		/* 820AE590h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE590h case    6:*/		return 0x820AE594;
		  /* 820AE594h */ case    7:  		/* mr R3, R31 */
		/* 820AE594h case    7:*/		regs.R3 = regs.R31;
		/* 820AE594h case    7:*/		return 0x820AE598;
		  /* 820AE598h */ case    8:  		/* addi R11, R11, 6776 */
		/* 820AE598h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1A78);
		/* 820AE598h case    8:*/		return 0x820AE59C;
		  /* 820AE59Ch */ case    9:  		/* stw R11, <#[R31]> */
		/* 820AE59Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AE59Ch case    9:*/		return 0x820AE5A0;
		  /* 820AE5A0h */ case   10:  		/* addi R1, R1, 96 */
		/* 820AE5A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820AE5A0h case   10:*/		return 0x820AE5A4;
		  /* 820AE5A4h */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AE5A4h case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AE5A4h case   11:*/		return 0x820AE5A8;
		  /* 820AE5A8h */ case   12:  		/* mtspr LR, R12 */
		/* 820AE5A8h case   12:*/		regs.LR = regs.R12;
		/* 820AE5A8h case   12:*/		return 0x820AE5AC;
		  /* 820AE5ACh */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 820AE5ACh case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AE5ACh case   13:*/		return 0x820AE5B0;
		  /* 820AE5B0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820AE5B0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AE5B0h case   14:*/		return 0x820AE5B4;
	}
	return 0x820AE5B4;
} // Block from 820AE578h-820AE5B4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AE5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE5B4);
		  /* 820AE5B4h */ case    0:  		/* nop */
		/* 820AE5B4h case    0:*/		cpu::op::nop();
		/* 820AE5B4h case    0:*/		return 0x820AE5B8;
	}
	return 0x820AE5B8;
} // Block from 820AE5B4h-820AE5B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE5B8);
		  /* 820AE5B8h */ case    0:  		/* mfspr R12, LR */
		/* 820AE5B8h case    0:*/		regs.R12 = regs.LR;
		/* 820AE5B8h case    0:*/		return 0x820AE5BC;
		  /* 820AE5BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AE5BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AE5BCh case    1:*/		return 0x820AE5C0;
		  /* 820AE5C0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820AE5C0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AE5C0h case    2:*/		return 0x820AE5C4;
		  /* 820AE5C4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820AE5C4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820AE5C4h case    3:*/		return 0x820AE5C8;
		  /* 820AE5C8h */ case    4:  		/* mr R31, R3 */
		/* 820AE5C8h case    4:*/		regs.R31 = regs.R3;
		/* 820AE5C8h case    4:*/		return 0x820AE5CC;
		  /* 820AE5CCh */ case    5:  		/* bl 178748 */
		/* 820AE5CCh case    5:*/		regs.LR = 0x820AE5D0; return 0x820DA008;
		/* 820AE5CCh case    5:*/		return 0x820AE5D0;
		  /* 820AE5D0h */ case    6:  		/* lis R11, -32255 */
		/* 820AE5D0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AE5D0h case    6:*/		return 0x820AE5D4;
		  /* 820AE5D4h */ case    7:  		/* mr R3, R31 */
		/* 820AE5D4h case    7:*/		regs.R3 = regs.R31;
		/* 820AE5D4h case    7:*/		return 0x820AE5D8;
		  /* 820AE5D8h */ case    8:  		/* addi R11, R11, 7424 */
		/* 820AE5D8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1D00);
		/* 820AE5D8h case    8:*/		return 0x820AE5DC;
		  /* 820AE5DCh */ case    9:  		/* stw R11, <#[R31]> */
		/* 820AE5DCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AE5DCh case    9:*/		return 0x820AE5E0;
		  /* 820AE5E0h */ case   10:  		/* addi R1, R1, 96 */
		/* 820AE5E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820AE5E0h case   10:*/		return 0x820AE5E4;
		  /* 820AE5E4h */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AE5E4h case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AE5E4h case   11:*/		return 0x820AE5E8;
		  /* 820AE5E8h */ case   12:  		/* mtspr LR, R12 */
		/* 820AE5E8h case   12:*/		regs.LR = regs.R12;
		/* 820AE5E8h case   12:*/		return 0x820AE5EC;
		  /* 820AE5ECh */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 820AE5ECh case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AE5ECh case   13:*/		return 0x820AE5F0;
		  /* 820AE5F0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820AE5F0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AE5F0h case   14:*/		return 0x820AE5F4;
	}
	return 0x820AE5F4;
} // Block from 820AE5B8h-820AE5F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AE5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE5F4);
		  /* 820AE5F4h */ case    0:  		/* nop */
		/* 820AE5F4h case    0:*/		cpu::op::nop();
		/* 820AE5F4h case    0:*/		return 0x820AE5F8;
	}
	return 0x820AE5F8;
} // Block from 820AE5F4h-820AE5F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE5F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE5F8);
		  /* 820AE5F8h */ case    0:  		/* lis R10, -32255 */
		/* 820AE5F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AE5F8h case    0:*/		return 0x820AE5FC;
		  /* 820AE5FCh */ case    1:  		/* stw R4, <#[R3 + 140]> */
		/* 820AE5FCh case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000008C) );
		/* 820AE5FCh case    1:*/		return 0x820AE600;
		  /* 820AE600h */ case    2:  		/* li R9, 2047 */
		/* 820AE600h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x7FF);
		/* 820AE600h case    2:*/		return 0x820AE604;
		  /* 820AE604h */ case    3:  		/* li R8, 4095 */
		/* 820AE604h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0xFFF);
		/* 820AE604h case    3:*/		return 0x820AE608;
		  /* 820AE608h */ case    4:  		/* li R11, 0 */
		/* 820AE608h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AE608h case    4:*/		return 0x820AE60C;
		  /* 820AE60Ch */ case    5:  		/* rldicr R9, R9, 52, 11 */
		/* 820AE60Ch case    5:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R9,regs.R9);
		/* 820AE60Ch case    5:*/		return 0x820AE610;
		  /* 820AE610h */ case    6:  		/* rldicr R8, R8, 52, 11 */
		/* 820AE610h case    6:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R8,regs.R8);
		/* 820AE610h case    6:*/		return 0x820AE614;
		  /* 820AE614h */ case    7:  		/* lfd FR0, <#[R10 + 8072]> */
		/* 820AE614h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00001F88) );
		/* 820AE614h case    7:*/		return 0x820AE618;
		  /* 820AE618h */ case    8:  		/* stfd FR0, <#[R3 + 184]> */
		/* 820AE618h case    8:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R3 + 0x000000B8) );
		/* 820AE618h case    8:*/		return 0x820AE61C;
		  /* 820AE61Ch */ case    9:  		/* stw R11, <#[R3]> */
		/* 820AE61Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820AE61Ch case    9:*/		return 0x820AE620;
		  /* 820AE620h */ case   10:  		/* stw R11, <#[R3 + 4]> */
		/* 820AE620h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820AE620h case   10:*/		return 0x820AE624;
		  /* 820AE624h */ case   11:  		/* stw R11, <#[R3 + 8]> */
		/* 820AE624h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AE624h case   11:*/		return 0x820AE628;
		  /* 820AE628h */ case   12:  		/* stw R11, <#[R3 + 24]> */
		/* 820AE628h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820AE628h case   12:*/		return 0x820AE62C;
		  /* 820AE62Ch */ case   13:  		/* stw R11, <#[R3 + 76]> */
		/* 820AE62Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 820AE62Ch case   13:*/		return 0x820AE630;
		  /* 820AE630h */ case   14:  		/* stw R11, <#[R3 + 80]> */
		/* 820AE630h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 820AE630h case   14:*/		return 0x820AE634;
		  /* 820AE634h */ case   15:  		/* stw R11, <#[R3 + 84]> */
		/* 820AE634h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 820AE634h case   15:*/		return 0x820AE638;
		  /* 820AE638h */ case   16:  		/* stw R11, <#[R3 + 88]> */
		/* 820AE638h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000058) );
		/* 820AE638h case   16:*/		return 0x820AE63C;
		  /* 820AE63Ch */ case   17:  		/* stw R11, <#[R3 + 92]> */
		/* 820AE63Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000005C) );
		/* 820AE63Ch case   17:*/		return 0x820AE640;
		  /* 820AE640h */ case   18:  		/* stw R11, <#[R3 + 96]> */
		/* 820AE640h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000060) );
		/* 820AE640h case   18:*/		return 0x820AE644;
		  /* 820AE644h */ case   19:  		/* stw R11, <#[R3 + 104]> */
		/* 820AE644h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000068) );
		/* 820AE644h case   19:*/		return 0x820AE648;
		  /* 820AE648h */ case   20:  		/* stw R11, <#[R3 + 100]> */
		/* 820AE648h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000064) );
		/* 820AE648h case   20:*/		return 0x820AE64C;
		  /* 820AE64Ch */ case   21:  		/* stw R11, <#[R3 + 136]> */
		/* 820AE64Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000088) );
		/* 820AE64Ch case   21:*/		return 0x820AE650;
		  /* 820AE650h */ case   22:  		/* stw R11, <#[R3 + 144]> */
		/* 820AE650h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000090) );
		/* 820AE650h case   22:*/		return 0x820AE654;
		  /* 820AE654h */ case   23:  		/* stw R11, <#[R3 + 148]> */
		/* 820AE654h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000094) );
		/* 820AE654h case   23:*/		return 0x820AE658;
		  /* 820AE658h */ case   24:  		/* stw R11, <#[R3 + 152]> */
		/* 820AE658h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000098) );
		/* 820AE658h case   24:*/		return 0x820AE65C;
		  /* 820AE65Ch */ case   25:  		/* stw R11, <#[R3 + 156]> */
		/* 820AE65Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000009C) );
		/* 820AE65Ch case   25:*/		return 0x820AE660;
		  /* 820AE660h */ case   26:  		/* stw R11, <#[R3 + 160]> */
		/* 820AE660h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000A0) );
		/* 820AE660h case   26:*/		return 0x820AE664;
		  /* 820AE664h */ case   27:  		/* stw R11, <#[R3 + 164]> */
		/* 820AE664h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000A4) );
		/* 820AE664h case   27:*/		return 0x820AE668;
		  /* 820AE668h */ case   28:  		/* std R9, <#[R3 + 168]> */
		/* 820AE668h case   28:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R3 + 0x000000A8) );
		/* 820AE668h case   28:*/		return 0x820AE66C;
		  /* 820AE66Ch */ case   29:  		/* std R8, <#[R3 + 176]> */
		/* 820AE66Ch case   29:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R3 + 0x000000B0) );
		/* 820AE66Ch case   29:*/		return 0x820AE670;
		  /* 820AE670h */ case   30:  		/* bclr 20, CR0_LT */
		/* 820AE670h case   30:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AE670h case   30:*/		return 0x820AE674;
	}
	return 0x820AE674;
} // Block from 820AE5F8h-820AE674h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820AE674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE674);
		  /* 820AE674h */ case    0:  		/* nop */
		/* 820AE674h case    0:*/		cpu::op::nop();
		/* 820AE674h case    0:*/		return 0x820AE678;
		  /* 820AE678h */ case    1:  		/* rlwinm. R11, R3, 0, 29, 29 */
		/* 820AE678h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R3);
		/* 820AE678h case    1:*/		return 0x820AE67C;
		  /* 820AE67Ch */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 820AE67Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820AE6B0;  }
		/* 820AE67Ch case    2:*/		return 0x820AE680;
		  /* 820AE680h */ case    3:  		/* lbz R11, <#[R5 + 8]> */
		/* 820AE680h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 820AE680h case    3:*/		return 0x820AE684;
		  /* 820AE684h */ case    4:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 820AE684h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 820AE684h case    4:*/		return 0x820AE688;
		  /* 820AE688h */ case    5:  		/* cmplwi CR6, R11, 29 */
		/* 820AE688h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001D);
		/* 820AE688h case    5:*/		return 0x820AE68C;
		  /* 820AE68Ch */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 820AE68Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820AE6A8;  }
		/* 820AE68Ch case    6:*/		return 0x820AE690;
		  /* 820AE690h */ case    7:  		/* lwz R11, <#[R5]> */
		/* 820AE690h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820AE690h case    7:*/		return 0x820AE694;
		  /* 820AE694h */ case    8:  		/* rlwinm R11, R11, 6, 26, 31 */
		/* 820AE694h case    8:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R11,regs.R11);
		/* 820AE694h case    8:*/		return 0x820AE698;
		  /* 820AE698h */ case    9:  		/* cmplwi CR6, R11, 23 */
		/* 820AE698h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000017);
		/* 820AE698h case    9:*/		return 0x820AE69C;
		  /* 820AE69Ch */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820AE69Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820AE6A8;  }
		/* 820AE69Ch case   10:*/		return 0x820AE6A0;
		  /* 820AE6A0h */ case   11:  		/* cmplwi CR6, R11, 24 */
		/* 820AE6A0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 820AE6A0h case   11:*/		return 0x820AE6A4;
		  /* 820AE6A4h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 820AE6A4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820AE6B0;  }
		/* 820AE6A4h case   12:*/		return 0x820AE6A8;
	}
	return 0x820AE6A8;
} // Block from 820AE674h-820AE6A8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AE6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE6A8);
		  /* 820AE6A8h */ case    0:  		/* li R11, 1 */
		/* 820AE6A8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820AE6A8h case    0:*/		return 0x820AE6AC;
		  /* 820AE6ACh */ case    1:  		/* stw R11, <#[R6]> */
		/* 820AE6ACh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820AE6ACh case    1:*/		return 0x820AE6B0;
	}
	return 0x820AE6B0;
} // Block from 820AE6A8h-820AE6B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE6B0);
		  /* 820AE6B0h */ case    0:  		/* li R3, 0 */
		/* 820AE6B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AE6B0h case    0:*/		return 0x820AE6B4;
		  /* 820AE6B4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820AE6B4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AE6B4h case    1:*/		return 0x820AE6B8;
	}
	return 0x820AE6B8;
} // Block from 820AE6B0h-820AE6B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE6B8);
		  /* 820AE6B8h */ case    0:  		/* mfspr R12, LR */
		/* 820AE6B8h case    0:*/		regs.R12 = regs.LR;
		/* 820AE6B8h case    0:*/		return 0x820AE6BC;
		  /* 820AE6BCh */ case    1:  		/* bl -119948 */
		/* 820AE6BCh case    1:*/		regs.LR = 0x820AE6C0; return 0x82091230;
		/* 820AE6BCh case    1:*/		return 0x820AE6C0;
		  /* 820AE6C0h */ case    2:  		/* mullw. R20, R5, R6 */
		/* 820AE6C0h case    2:*/		cpu::op::mullw<1>(regs,&regs.R20,regs.R5,regs.R6);
		/* 820AE6C0h case    2:*/		return 0x820AE6C4;
		  /* 820AE6C4h */ case    3:  		/* bc 12, CR0_EQ, 368 */
		/* 820AE6C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AE834;  }
		/* 820AE6C4h case    3:*/		return 0x820AE6C8;
		  /* 820AE6C8h */ case    4:  		/* cmpwi CR6, R4, 2 */
		/* 820AE6C8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000002);
		/* 820AE6C8h case    4:*/		return 0x820AE6CC;
		  /* 820AE6CCh */ case    5:  		/* bc 4, CR6_EQ, 72 */
		/* 820AE6CCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AE714;  }
		/* 820AE6CCh case    5:*/		return 0x820AE6D0;
		  /* 820AE6D0h */ case    6:  		/* rlwinm. R11, R7, 0, 21, 21 */
		/* 820AE6D0h case    6:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R7);
		/* 820AE6D0h case    6:*/		return 0x820AE6D4;
		  /* 820AE6D4h */ case    7:  		/* bc 4, CR0_EQ, 64 */
		/* 820AE6D4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820AE714;  }
		/* 820AE6D4h case    7:*/		return 0x820AE6D8;
		  /* 820AE6D8h */ case    8:  		/* mr R11, R5 */
		/* 820AE6D8h case    8:*/		regs.R11 = regs.R5;
		/* 820AE6D8h case    8:*/		return 0x820AE6DC;
		  /* 820AE6DCh */ case    9:  		/* mr R5, R6 */
		/* 820AE6DCh case    9:*/		regs.R5 = regs.R6;
		/* 820AE6DCh case    9:*/		return 0x820AE6E0;
		  /* 820AE6E0h */ case   10:  		/* li R19, 1 */
		/* 820AE6E0h case   10:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 820AE6E0h case   10:*/		return 0x820AE6E4;
		  /* 820AE6E4h */ case   11:  		/* mr R6, R11 */
		/* 820AE6E4h case   11:*/		regs.R6 = regs.R11;
		/* 820AE6E4h case   11:*/		return 0x820AE6E8;
		  /* 820AE6E8h */ case   12:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AE6E8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AE6E8h case   12:*/		return 0x820AE6EC;
		  /* 820AE6ECh */ case   13:  		/* addi R7, R6, 3 */
		/* 820AE6ECh case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0x3);
		/* 820AE6ECh case   13:*/		return 0x820AE6F0;
		  /* 820AE6F0h */ case   14:  		/* rlwinm R22, R7, 30, 2, 31 */
		/* 820AE6F0h case   14:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R22,regs.R7);
		/* 820AE6F0h case   14:*/		return 0x820AE6F4;
		  /* 820AE6F4h */ case   15:  		/* mullw R21, R22, R5 */
		/* 820AE6F4h case   15:*/		cpu::op::mullw<0>(regs,&regs.R21,regs.R22,regs.R5);
		/* 820AE6F4h case   15:*/		return 0x820AE6F8;
		  /* 820AE6F8h */ case   16:  		/* lwz R7, <#[R11 + 4]> */
		/* 820AE6F8h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820AE6F8h case   16:*/		return 0x820AE6FC;
		  /* 820AE6FCh */ case   17:  		/* cmplw CR6, R9, R7 */
		/* 820AE6FCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820AE6FCh case   17:*/		return 0x820AE700;
		  /* 820AE700h */ case   18:  		/* bc 4, CR6_LT, 28 */
		/* 820AE700h case   18:*/		if ( !regs.CR[6].lt ) { return 0x820AE71C;  }
		/* 820AE700h case   18:*/		return 0x820AE704;
		  /* 820AE704h */ case   19:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AE704h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AE704h case   19:*/		return 0x820AE708;
		  /* 820AE708h */ case   20:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 820AE708h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 820AE708h case   20:*/		return 0x820AE70C;
		  /* 820AE70Ch */ case   21:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820AE70Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820AE70Ch case   21:*/		return 0x820AE710;
		  /* 820AE710h */ case   22:  		/* b 16 */
		/* 820AE710h case   22:*/		return 0x820AE720;
		/* 820AE710h case   22:*/		return 0x820AE714;
	}
	return 0x820AE714;
} // Block from 820AE6B8h-820AE714h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820AE714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE714);
		  /* 820AE714h */ case    0:  		/* li R19, 0 */
		/* 820AE714h case    0:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 820AE714h case    0:*/		return 0x820AE718;
		  /* 820AE718h */ case    1:  		/* b -48 */
		/* 820AE718h case    1:*/		return 0x820AE6E8;
		/* 820AE718h case    1:*/		return 0x820AE71C;
	}
	return 0x820AE71C;
} // Block from 820AE714h-820AE71Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE71C);
		  /* 820AE71Ch */ case    0:  		/* li R11, 0 */
		/* 820AE71Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AE71Ch case    0:*/		return 0x820AE720;
	}
	return 0x820AE720;
} // Block from 820AE71Ch-820AE720h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE720);
		  /* 820AE720h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820AE720h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AE720h case    0:*/		return 0x820AE724;
		  /* 820AE724h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820AE724h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AE734;  }
		/* 820AE724h case    1:*/		return 0x820AE728;
		  /* 820AE728h */ case    2:  		/* lis R3, -32768 */
		/* 820AE728h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820AE728h case    2:*/		return 0x820AE72C;
		  /* 820AE72Ch */ case    3:  		/* ori R3, R3, 16389 */
		/* 820AE72Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820AE72Ch case    3:*/		return 0x820AE730;
		  /* 820AE730h */ case    4:  		/* b 280 */
		/* 820AE730h case    4:*/		return 0x820AE848;
		/* 820AE730h case    4:*/		return 0x820AE734;
	}
	return 0x820AE734;
} // Block from 820AE720h-820AE734h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AE734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE734);
		  /* 820AE734h */ case    0:  		/* lwz R28, <#[R11 + 16]> */
		/* 820AE734h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000010) );
		/* 820AE734h case    0:*/		return 0x820AE738;
		  /* 820AE738h */ case    1:  		/* lwz R4, <#[R11 + 4]> */
		/* 820AE738h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820AE738h case    1:*/		return 0x820AE73C;
		  /* 820AE73Ch */ case    2:  		/* add R7, R28, R21 */
		/* 820AE73Ch case    2:*/		cpu::op::add<0>(regs,&regs.R7,regs.R28,regs.R21);
		/* 820AE73Ch case    2:*/		return 0x820AE740;
	}
	return 0x820AE740;
} // Block from 820AE734h-820AE740h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE740h
// Function '?Assemble@CAssembler@D3DXShader@@QAAJPAVCPreProcessor@2@KPAVCFragmentConstants@2@PAPAUID3DXBuffer@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE740);
		  /* 820AE740h */ case    0:  		/* rlwinm. R4, R4, 0, 25, 25 */
		/* 820AE740h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R4,regs.R4);
		/* 820AE740h case    0:*/		return 0x820AE744;
		  /* 820AE744h */ case    1:  		/* stw R7, <#[R11 + 16]> */
		/* 820AE744h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000010) );
		/* 820AE744h case    1:*/		return 0x820AE748;
		  /* 820AE748h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 820AE748h case    2:*/		if ( regs.CR[0].eq ) { return 0x820AE750;  }
		/* 820AE748h case    2:*/		return 0x820AE74C;
		  /* 820AE74Ch */ case    3:  		/* stw R7, <#[R11 + 8]> */
		/* 820AE74Ch case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 820AE74Ch case    3:*/		return 0x820AE750;
	}
	return 0x820AE750;
} // Block from 820AE740h-820AE750h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE750);
		  /* 820AE750h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820AE750h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820AE750h case    0:*/		return 0x820AE754;
		  /* 820AE754h */ case    1:  		/* bc 12, CR6_EQ, 208 */
		/* 820AE754h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AE824;  }
		/* 820AE754h case    1:*/		return 0x820AE758;
		  /* 820AE758h */ case    2:  		/* li R29, 0 */
		/* 820AE758h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820AE758h case    2:*/		return 0x820AE75C;
		  /* 820AE75Ch */ case    3:  		/* li R27, 0 */
		/* 820AE75Ch case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820AE75Ch case    3:*/		return 0x820AE760;
		  /* 820AE760h */ case    4:  		/* mr R25, R8 */
		/* 820AE760h case    4:*/		regs.R25 = regs.R8;
		/* 820AE760h case    4:*/		return 0x820AE764;
		  /* 820AE764h */ case    5:  		/* mr R24, R5 */
		/* 820AE764h case    5:*/		regs.R24 = regs.R5;
		/* 820AE764h case    5:*/		return 0x820AE768;
		  /* 820AE768h */ case    6:  		/* li R30, 0 */
		/* 820AE768h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820AE768h case    6:*/		return 0x820AE76C;
		  /* 820AE76Ch */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 820AE76Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820AE76Ch case    7:*/		return 0x820AE770;
		  /* 820AE770h */ case    8:  		/* bc 12, CR6_EQ, 160 */
		/* 820AE770h case    8:*/		if ( regs.CR[6].eq ) { return 0x820AE810;  }
		/* 820AE770h case    8:*/		return 0x820AE774;
		  /* 820AE774h */ case    9:  		/* rlwinm R23, R5, 2, 0, 29 */
		/* 820AE774h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R23,regs.R5);
		/* 820AE774h case    9:*/		return 0x820AE778;
		  /* 820AE778h */ case   10:  		/* mtspr CTR, R6 */
		/* 820AE778h case   10:*/		regs.CTR = regs.R6;
		/* 820AE778h case   10:*/		return 0x820AE77C;
		  /* 820AE77Ch */ case   11:  		/* mr R26, R25 */
		/* 820AE77Ch case   11:*/		regs.R26 = regs.R25;
		/* 820AE77Ch case   11:*/		return 0x820AE780;
		  /* 820AE780h */ case   12:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AE780h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AE780h case   12:*/		return 0x820AE784;
		  /* 820AE784h */ case   13:  		/* cmpwi CR6, R19, 0 */
		/* 820AE784h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 820AE784h case   13:*/		return 0x820AE788;
		  /* 820AE788h */ case   14:  		/* lwz R4, <#[R11 + 8]> */
		/* 820AE788h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000008) );
		/* 820AE788h case   14:*/		return 0x820AE78C;
		  /* 820AE78Ch */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 820AE78Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820AE798;  }
		/* 820AE78Ch case   15:*/		return 0x820AE790;
		  /* 820AE790h */ case   16:  		/* lwz R7, <#[R26]> */
		/* 820AE790h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000000) );
		/* 820AE790h case   16:*/		return 0x820AE794;
		  /* 820AE794h */ case   17:  		/* b 16 */
		/* 820AE794h case   17:*/		return 0x820AE7A4;
		/* 820AE794h case   17:*/		return 0x820AE798;
	}
	return 0x820AE798;
} // Block from 820AE750h-820AE798h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820AE798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE798);
		  /* 820AE798h */ case    0:  		/* add R7, R27, R30 */
		/* 820AE798h case    0:*/		cpu::op::add<0>(regs,&regs.R7,regs.R27,regs.R30);
		/* 820AE798h case    0:*/		return 0x820AE79C;
		  /* 820AE79Ch */ case    1:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820AE79Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820AE79Ch case    1:*/		return 0x820AE7A0;
		  /* 820AE7A0h */ case    2:  		/* lwzx R7, <#[R7 + R8]> */
		/* 820AE7A0h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820AE7A0h case    2:*/		return 0x820AE7A4;
	}
	return 0x820AE7A4;
} // Block from 820AE798h-820AE7A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE7A4);
		  /* 820AE7A4h */ case    0:  		/* cmplw CR6, R7, R4 */
		/* 820AE7A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 820AE7A4h case    0:*/		return 0x820AE7A8;
		  /* 820AE7A8h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 820AE7A8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820AE7BC;  }
		/* 820AE7A8h case    1:*/		return 0x820AE7AC;
		  /* 820AE7ACh */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 820AE7ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820AE7ACh case    2:*/		return 0x820AE7B0;
		  /* 820AE7B0h */ case    3:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820AE7B0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820AE7B0h case    3:*/		return 0x820AE7B4;
		  /* 820AE7B4h */ case    4:  		/* lwzx R11, <#[R7 + R11]> */
		/* 820AE7B4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820AE7B4h case    4:*/		return 0x820AE7B8;
		  /* 820AE7B8h */ case    5:  		/* b 8 */
		/* 820AE7B8h case    5:*/		return 0x820AE7C0;
		/* 820AE7B8h case    5:*/		return 0x820AE7BC;
	}
	return 0x820AE7BC;
} // Block from 820AE7A4h-820AE7BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AE7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE7BC);
		  /* 820AE7BCh */ case    0:  		/* li R11, 0 */
		/* 820AE7BCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AE7BCh case    0:*/		return 0x820AE7C0;
	}
	return 0x820AE7C0;
} // Block from 820AE7BCh-820AE7C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE7C0);
		  /* 820AE7C0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820AE7C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AE7C0h case    0:*/		return 0x820AE7C4;
		  /* 820AE7C4h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820AE7C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AE804;  }
		/* 820AE7C4h case    1:*/		return 0x820AE7C8;
		  /* 820AE7C8h */ case    2:  		/* rlwinm R7, R30, 30, 2, 31 */
		/* 820AE7C8h case    2:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R7,regs.R30);
		/* 820AE7C8h case    2:*/		return 0x820AE7CC;
		  /* 820AE7CCh */ case    3:  		/* lwz R31, <#[R1 + 84]> */
		/* 820AE7CCh case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820AE7CCh case    3:*/		return 0x820AE7D0;
		  /* 820AE7D0h */ case    4:  		/* rlwinm R4, R30, 0, 30, 31 */
		/* 820AE7D0h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R30);
		/* 820AE7D0h case    4:*/		return 0x820AE7D4;
		  /* 820AE7D4h */ case    5:  		/* stw R9, <#[R11 + 4]> */
		/* 820AE7D4h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820AE7D4h case    5:*/		return 0x820AE7D8;
		  /* 820AE7D8h */ case    6:  		/* add R7, R7, R29 */
		/* 820AE7D8h case    6:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R29);
		/* 820AE7D8h case    6:*/		return 0x820AE7DC;
		  /* 820AE7DCh */ case    7:  		/* stw R4, <#[R11 + 16]> */
		/* 820AE7DCh case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 820AE7DCh case    7:*/		return 0x820AE7E0;
		  /* 820AE7E0h */ case    8:  		/* add R7, R7, R28 */
		/* 820AE7E0h case    8:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R28);
		/* 820AE7E0h case    8:*/		return 0x820AE7E4;
		  /* 820AE7E4h */ case    9:  		/* stw R31, <#[R11 + 104]> */
		/* 820AE7E4h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000068) );
		/* 820AE7E4h case    9:*/		return 0x820AE7E8;
		  /* 820AE7E8h */ case   10:  		/* subf R18, R28, R7 */
		/* 820AE7E8h case   10:*/		cpu::op::subf<0>(regs,&regs.R18,regs.R28,regs.R7);
		/* 820AE7E8h case   10:*/		return 0x820AE7EC;
		  /* 820AE7ECh */ case   11:  		/* stw R7, <#[R11 + 12]> */
		/* 820AE7ECh case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820AE7ECh case   11:*/		return 0x820AE7F0;
		  /* 820AE7F0h */ case   12:  		/* lwz R31, <#[R10]> */
		/* 820AE7F0h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000000) );
		/* 820AE7F0h case   12:*/		return 0x820AE7F4;
		  /* 820AE7F4h */ case   13:  		/* rlwinm R7, R18, 2, 0, 29 */
		/* 820AE7F4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R18);
		/* 820AE7F4h case   13:*/		return 0x820AE7F8;
		  /* 820AE7F8h */ case   14:  		/* add R7, R7, R31 */
		/* 820AE7F8h case   14:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R31);
		/* 820AE7F8h case   14:*/		return 0x820AE7FC;
		  /* 820AE7FCh */ case   15:  		/* add R7, R7, R4 */
		/* 820AE7FCh case   15:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R4);
		/* 820AE7FCh case   15:*/		return 0x820AE800;
		  /* 820AE800h */ case   16:  		/* stw R7, <#[R11 + 112]> */
		/* 820AE800h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000070) );
		/* 820AE800h case   16:*/		return 0x820AE804;
	}
	return 0x820AE804;
} // Block from 820AE7C0h-820AE804h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820AE804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE804);
		  /* 820AE804h */ case    0:  		/* addi R30, R30, 1 */
		/* 820AE804h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820AE804h case    0:*/		return 0x820AE808;
		  /* 820AE808h */ case    1:  		/* add R26, R23, R26 */
		/* 820AE808h case    1:*/		cpu::op::add<0>(regs,&regs.R26,regs.R23,regs.R26);
		/* 820AE808h case    1:*/		return 0x820AE80C;
		  /* 820AE80Ch */ case    2:  		/* bc 16, CR0_LT, -140 */
		/* 820AE80Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820AE780;  }
		/* 820AE80Ch case    2:*/		return 0x820AE810;
	}
	return 0x820AE810;
} // Block from 820AE804h-820AE810h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AE810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE810);
		  /* 820AE810h */ case    0:  		/* addic. R24, R24, -1 */
		/* 820AE810h case    0:*/		cpu::op::addic<1>(regs,&regs.R24,regs.R24,0xFFFFFFFF);
		/* 820AE810h case    0:*/		return 0x820AE814;
		  /* 820AE814h */ case    1:  		/* addi R25, R25, 4 */
		/* 820AE814h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 820AE814h case    1:*/		return 0x820AE818;
		  /* 820AE818h */ case    2:  		/* add R27, R27, R6 */
		/* 820AE818h case    2:*/		cpu::op::add<0>(regs,&regs.R27,regs.R27,regs.R6);
		/* 820AE818h case    2:*/		return 0x820AE81C;
		  /* 820AE81Ch */ case    3:  		/* add R29, R29, R22 */
		/* 820AE81Ch case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R29,regs.R22);
		/* 820AE81Ch case    3:*/		return 0x820AE820;
		  /* 820AE820h */ case    4:  		/* bc 4, CR0_EQ, -184 */
		/* 820AE820h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820AE768;  }
		/* 820AE820h case    4:*/		return 0x820AE824;
	}
	return 0x820AE824;
} // Block from 820AE810h-820AE824h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AE824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE824);
		  /* 820AE824h */ case    0:  		/* lwz R9, <#[R10]> */
		/* 820AE824h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820AE824h case    0:*/		return 0x820AE828;
		  /* 820AE828h */ case    1:  		/* rlwinm R11, R21, 2, 0, 29 */
		/* 820AE828h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R21);
		/* 820AE828h case    1:*/		return 0x820AE82C;
		  /* 820AE82Ch */ case    2:  		/* add R11, R11, R9 */
		/* 820AE82Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820AE82Ch case    2:*/		return 0x820AE830;
		  /* 820AE830h */ case    3:  		/* stw R11, <#[R10]> */
		/* 820AE830h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820AE830h case    3:*/		return 0x820AE834;
	}
	return 0x820AE834;
} // Block from 820AE824h-820AE834h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE834);
		  /* 820AE834h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 820AE834h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820AE834h case    0:*/		return 0x820AE838;
		  /* 820AE838h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820AE838h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AE838h case    1:*/		return 0x820AE83C;
		  /* 820AE83Ch */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820AE83Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820AE844;  }
		/* 820AE83Ch case    2:*/		return 0x820AE840;
		  /* 820AE840h */ case    3:  		/* stw R20, <#[R11]> */
		/* 820AE840h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000000) );
		/* 820AE840h case    3:*/		return 0x820AE844;
	}
	return 0x820AE844;
} // Block from 820AE834h-820AE844h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE844);
		  /* 820AE844h */ case    0:  		/* li R3, 0 */
		/* 820AE844h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AE844h case    0:*/		return 0x820AE848;
	}
	return 0x820AE848;
} // Block from 820AE844h-820AE848h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AE848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE848);
		  /* 820AE848h */ case    0:  		/* b -120264 */
		/* 820AE848h case    0:*/		return 0x82091280;
		/* 820AE848h case    0:*/		return 0x820AE84C;
		  /* 820AE84Ch */ case    1:  		/* nop */
		/* 820AE84Ch case    1:*/		cpu::op::nop();
		/* 820AE84Ch case    1:*/		return 0x820AE850;
	}
	return 0x820AE850;
} // Block from 820AE848h-820AE850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AE850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE850);
		  /* 820AE850h */ case    0:  		/* mfspr R12, LR */
		/* 820AE850h case    0:*/		regs.R12 = regs.LR;
		/* 820AE850h case    0:*/		return 0x820AE854;
		  /* 820AE854h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AE854h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AE854h case    1:*/		return 0x820AE858;
		  /* 820AE858h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820AE858h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AE858h case    2:*/		return 0x820AE85C;
		  /* 820AE85Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820AE85Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AE85Ch case    3:*/		return 0x820AE860;
		  /* 820AE860h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820AE860h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820AE860h case    4:*/		return 0x820AE864;
		  /* 820AE864h */ case    5:  		/* lwz R11, <#[R4 + 20]> */
		/* 820AE864h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 820AE864h case    5:*/		return 0x820AE868;
		  /* 820AE868h */ case    6:  		/* mr R30, R3 */
		/* 820AE868h case    6:*/		regs.R30 = regs.R3;
		/* 820AE868h case    6:*/		return 0x820AE86C;
		  /* 820AE86Ch */ case    7:  		/* mr R31, R4 */
		/* 820AE86Ch case    7:*/		regs.R31 = regs.R4;
		/* 820AE86Ch case    7:*/		return 0x820AE870;
		  /* 820AE870h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820AE870h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AE870h case    8:*/		return 0x820AE874;
		  /* 820AE874h */ case    9:  		/* bc 12, CR6_EQ, 392 */
		/* 820AE874h case    9:*/		if ( regs.CR[6].eq ) { return 0x820AE9FC;  }
		/* 820AE874h case    9:*/		return 0x820AE878;
		  /* 820AE878h */ case   10:  		/* lwz R10, <#[R4 + 56]> */
		/* 820AE878h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000038) );
		/* 820AE878h case   10:*/		return 0x820AE87C;
		  /* 820AE87Ch */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820AE87Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AE87Ch case   11:*/		return 0x820AE880;
		  /* 820AE880h */ case   12:  		/* bc 12, CR6_EQ, 380 */
		/* 820AE880h case   12:*/		if ( regs.CR[6].eq ) { return 0x820AE9FC;  }
		/* 820AE880h case   12:*/		return 0x820AE884;
		  /* 820AE884h */ case   13:  		/* lwz R10, <#[R4 + 80]> */
		/* 820AE884h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000050) );
		/* 820AE884h case   13:*/		return 0x820AE888;
		  /* 820AE888h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 820AE888h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AE888h case   14:*/		return 0x820AE88C;
		  /* 820AE88Ch */ case   15:  		/* bc 4, CR6_EQ, 368 */
		/* 820AE88Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x820AE9FC;  }
		/* 820AE88Ch case   15:*/		return 0x820AE890;
		  /* 820AE890h */ case   16:  		/* li R9, 0 */
		/* 820AE890h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820AE890h case   16:*/		return 0x820AE894;
		  /* 820AE894h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820AE894h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AE894h case   17:*/		return 0x820AE898;
		  /* 820AE898h */ case   18:  		/* stw R9, <#[R4 + 76]> */
		/* 820AE898h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x0000004C) );
		/* 820AE898h case   18:*/		return 0x820AE89C;
		  /* 820AE89Ch */ case   19:  		/* bc 12, CR6_EQ, 80 */
		/* 820AE89Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x820AE8EC;  }
		/* 820AE89Ch case   19:*/		return 0x820AE8A0;
		  /* 820AE8A0h */ case   20:  		/* lwz R9, <#[R4 + 16]> */
		/* 820AE8A0h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000010) );
		/* 820AE8A0h case   20:*/		return 0x820AE8A4;
		  /* 820AE8A4h */ case   21:  		/* add R11, R9, R10 */
		/* 820AE8A4h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 820AE8A4h case   21:*/		return 0x820AE8A8;
		  /* 820AE8A8h */ case   22:  		/* lwz R8, <#[R30 + 24]> */
		/* 820AE8A8h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000018) );
		/* 820AE8A8h case   22:*/		return 0x820AE8AC;
		  /* 820AE8ACh */ case   23:  		/* lwz R7, <#[R30 + 8]> */
		/* 820AE8ACh case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 820AE8ACh case   23:*/		return 0x820AE8B0;
		  /* 820AE8B0h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AE8B0h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AE8B0h case   24:*/		return 0x820AE8B4;
		  /* 820AE8B4h */ case   25:  		/* lwz R6, <#[R31 + 76]> */
		/* 820AE8B4h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000004C) );
		/* 820AE8B4h case   25:*/		return 0x820AE8B8;
		  /* 820AE8B8h */ case   26:  		/* lwz R7, <#[R7 + 20]> */
		/* 820AE8B8h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 820AE8B8h case   26:*/		return 0x820AE8BC;
		  /* 820AE8BCh */ case   27:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820AE8BCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820AE8BCh case   27:*/		return 0x820AE8C0;
		  /* 820AE8C0h */ case   28:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AE8C0h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AE8C0h case   28:*/		return 0x820AE8C4;
		  /* 820AE8C4h */ case   29:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820AE8C4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820AE8C4h case   29:*/		return 0x820AE8C8;
		  /* 820AE8C8h */ case   30:  		/* lwz R11, <#[R11 + 112]> */
		/* 820AE8C8h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820AE8C8h case   30:*/		return 0x820AE8CC;
		  /* 820AE8CCh */ case   31:  		/* addi R11, R11, 1 */
		/* 820AE8CCh case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AE8CCh case   31:*/		return 0x820AE8D0;
		  /* 820AE8D0h */ case   32:  		/* cmplw CR6, R6, R11 */
		/* 820AE8D0h case   32:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820AE8D0h case   32:*/		return 0x820AE8D4;
		  /* 820AE8D4h */ case   33:  		/* bc 4, CR6_LT, 8 */
		/* 820AE8D4h case   33:*/		if ( !regs.CR[6].lt ) { return 0x820AE8DC;  }
		/* 820AE8D4h case   33:*/		return 0x820AE8D8;
		  /* 820AE8D8h */ case   34:  		/* stw R11, <#[R31 + 76]> */
		/* 820AE8D8h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820AE8D8h case   34:*/		return 0x820AE8DC;
	}
	return 0x820AE8DC;
} // Block from 820AE850h-820AE8DCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 820AE8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE8DC);
		  /* 820AE8DCh */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820AE8DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820AE8DCh case    0:*/		return 0x820AE8E0;
		  /* 820AE8E0h */ case    1:  		/* addi R10, R10, 1 */
		/* 820AE8E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AE8E0h case    1:*/		return 0x820AE8E4;
		  /* 820AE8E4h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 820AE8E4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820AE8E4h case    2:*/		return 0x820AE8E8;
		  /* 820AE8E8h */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 820AE8E8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820AE8A4;  }
		/* 820AE8E8h case    3:*/		return 0x820AE8EC;
	}
	return 0x820AE8EC;
} // Block from 820AE8DCh-820AE8ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AE8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE8EC);
		  /* 820AE8ECh */ case    0:  		/* lwz R11, <#[R31 + 76]> */
		/* 820AE8ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820AE8ECh case    0:*/		return 0x820AE8F0;
		  /* 820AE8F0h */ case    1:  		/* li R4, 16 */
		/* 820AE8F0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820AE8F0h case    1:*/		return 0x820AE8F4;
		  /* 820AE8F4h */ case    2:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820AE8F4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820AE8F4h case    2:*/		return 0x820AE8F8;
		  /* 820AE8F8h */ case    3:  		/* bl 108776 */
		/* 820AE8F8h case    3:*/		regs.LR = 0x820AE8FC; return 0x820C91E0;
		/* 820AE8F8h case    3:*/		return 0x820AE8FC;
		  /* 820AE8FCh */ case    4:  		/* stw R3, <#[R31 + 80]> */
		/* 820AE8FCh case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 820AE8FCh case    4:*/		return 0x820AE900;
		  /* 820AE900h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820AE900h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AE900h case    5:*/		return 0x820AE904;
		  /* 820AE904h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 820AE904h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820AE914;  }
		/* 820AE904h case    6:*/		return 0x820AE908;
		  /* 820AE908h */ case    7:  		/* lis R3, -32761 */
		/* 820AE908h case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820AE908h case    7:*/		return 0x820AE90C;
		  /* 820AE90Ch */ case    8:  		/* ori R3, R3, 14 */
		/* 820AE90Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820AE90Ch case    8:*/		return 0x820AE910;
		  /* 820AE910h */ case    9:  		/* b 240 */
		/* 820AE910h case    9:*/		return 0x820AEA00;
		/* 820AE910h case    9:*/		return 0x820AE914;
	}
	return 0x820AE914;
} // Block from 820AE8ECh-820AE914h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AE914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE914);
		  /* 820AE914h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820AE914h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820AE914h case    0:*/		return 0x820AE918;
		  /* 820AE918h */ case    1:  		/* li R4, 16 */
		/* 820AE918h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820AE918h case    1:*/		return 0x820AE91C;
		  /* 820AE91Ch */ case    2:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820AE91Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820AE91Ch case    2:*/		return 0x820AE920;
		  /* 820AE920h */ case    3:  		/* bl 108736 */
		/* 820AE920h case    3:*/		regs.LR = 0x820AE924; return 0x820C91E0;
		/* 820AE920h case    3:*/		return 0x820AE924;
		  /* 820AE924h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820AE924h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820AE924h case    4:*/		return 0x820AE928;
		  /* 820AE928h */ case    5:  		/* stw R3, <#[R31 + 84]> */
		/* 820AE928h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 820AE928h case    5:*/		return 0x820AE92C;
		  /* 820AE92Ch */ case    6:  		/* bc 12, CR0_EQ, -36 */
		/* 820AE92Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820AE908;  }
		/* 820AE92Ch case    6:*/		return 0x820AE930;
		  /* 820AE930h */ case    7:  		/* lwz R11, <#[R31 + 76]> */
		/* 820AE930h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820AE930h case    7:*/		return 0x820AE934;
		  /* 820AE934h */ case    8:  		/* li R4, 0 */
		/* 820AE934h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AE934h case    8:*/		return 0x820AE938;
		  /* 820AE938h */ case    9:  		/* lwz R3, <#[R31 + 80]> */
		/* 820AE938h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 820AE938h case    9:*/		return 0x820AE93C;
		  /* 820AE93Ch */ case   10:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820AE93Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820AE93Ch case   10:*/		return 0x820AE940;
		  /* 820AE940h */ case   11:  		/* bl -120320 */
		/* 820AE940h case   11:*/		regs.LR = 0x820AE944; return 0x82091340;
		/* 820AE940h case   11:*/		return 0x820AE944;
		  /* 820AE944h */ case   12:  		/* lwz R11, <#[R31 + 20]> */
		/* 820AE944h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820AE944h case   12:*/		return 0x820AE948;
		  /* 820AE948h */ case   13:  		/* li R4, 0 */
		/* 820AE948h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AE948h case   13:*/		return 0x820AE94C;
		  /* 820AE94Ch */ case   14:  		/* lwz R3, <#[R31 + 84]> */
		/* 820AE94Ch case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 820AE94Ch case   14:*/		return 0x820AE950;
		  /* 820AE950h */ case   15:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820AE950h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820AE950h case   15:*/		return 0x820AE954;
		  /* 820AE954h */ case   16:  		/* bl -120340 */
		/* 820AE954h case   16:*/		regs.LR = 0x820AE958; return 0x82091340;
		/* 820AE954h case   16:*/		return 0x820AE958;
		  /* 820AE958h */ case   17:  		/* lwz R11, <#[R31 + 56]> */
		/* 820AE958h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820AE958h case   17:*/		return 0x820AE95C;
		  /* 820AE95Ch */ case   18:  		/* lwz R10, <#[R31 + 20]> */
		/* 820AE95Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820AE95Ch case   18:*/		return 0x820AE960;
		  /* 820AE960h */ case   19:  		/* li R9, 0 */
		/* 820AE960h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820AE960h case   19:*/		return 0x820AE964;
		  /* 820AE964h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 820AE964h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AE964h case   20:*/		return 0x820AE968;
		  /* 820AE968h */ case   21:  		/* lwz R10, <#[R11 + 32]> */
		/* 820AE968h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 820AE968h case   21:*/		return 0x820AE96C;
		  /* 820AE96Ch */ case   22:  		/* bc 4, CR6_GT, 144 */
		/* 820AE96Ch case   22:*/		if ( !regs.CR[6].gt ) { return 0x820AE9FC;  }
		/* 820AE96Ch case   22:*/		return 0x820AE970;
		  /* 820AE970h */ case   23:  		/* cmplwi CR6, R10, 0 */
		/* 820AE970h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820AE970h case   23:*/		return 0x820AE974;
		  /* 820AE974h */ case   24:  		/* bc 12, CR6_EQ, 136 */
		/* 820AE974h case   24:*/		if ( regs.CR[6].eq ) { return 0x820AE9FC;  }
		/* 820AE974h case   24:*/		return 0x820AE978;
		  /* 820AE978h */ case   25:  		/* lwz R11, <#[R31 + 16]> */
		/* 820AE978h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820AE978h case   25:*/		return 0x820AE97C;
		  /* 820AE97Ch */ case   26:  		/* lwz R8, <#[R30 + 24]> */
		/* 820AE97Ch case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000018) );
		/* 820AE97Ch case   26:*/		return 0x820AE980;
		  /* 820AE980h */ case   27:  		/* add R11, R11, R9 */
		/* 820AE980h case   27:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820AE980h case   27:*/		return 0x820AE984;
		  /* 820AE984h */ case   28:  		/* lwz R7, <#[R30 + 8]> */
		/* 820AE984h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 820AE984h case   28:*/		return 0x820AE988;
		  /* 820AE988h */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AE988h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AE988h case   29:*/		return 0x820AE98C;
		  /* 820AE98Ch */ case   30:  		/* lwz R6, <#[R7 + 20]> */
		/* 820AE98Ch case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000014) );
		/* 820AE98Ch case   30:*/		return 0x820AE990;
		  /* 820AE990h */ case   31:  		/* lwz R7, <#[R7 + 16]> */
		/* 820AE990h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000010) );
		/* 820AE990h case   31:*/		return 0x820AE994;
		  /* 820AE994h */ case   32:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820AE994h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820AE994h case   32:*/		return 0x820AE998;
		  /* 820AE998h */ case   33:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AE998h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AE998h case   33:*/		return 0x820AE99C;
		  /* 820AE99Ch */ case   34:  		/* lwzx R11, <#[R11 + R6]> */
		/* 820AE99Ch case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820AE99Ch case   34:*/		return 0x820AE9A0;
		  /* 820AE9A0h */ case   35:  		/* lwz R8, <#[R11 + 4]> */
		/* 820AE9A0h case   35:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820AE9A0h case   35:*/		return 0x820AE9A4;
		  /* 820AE9A4h */ case   36:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820AE9A4h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820AE9A4h case   36:*/		return 0x820AE9A8;
		  /* 820AE9A8h */ case   37:  		/* lwzx R8, <#[R8 + R7]> */
		/* 820AE9A8h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820AE9A8h case   37:*/		return 0x820AE9AC;
		  /* 820AE9ACh */ case   38:  		/* lwz R8, <#[R8 + 4]> */
		/* 820AE9ACh case   38:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820AE9ACh case   38:*/		return 0x820AE9B0;
		  /* 820AE9B0h */ case   39:  		/* rlwinm. R8, R8, 0, 24, 24 */
		/* 820AE9B0h case   39:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R8,regs.R8);
		/* 820AE9B0h case   39:*/		return 0x820AE9B4;
		  /* 820AE9B4h */ case   40:  		/* bc 4, CR0_EQ, 52 */
		/* 820AE9B4h case   40:*/		if ( !regs.CR[0].eq ) { return 0x820AE9E8;  }
		/* 820AE9B4h case   40:*/		return 0x820AE9B8;
		  /* 820AE9B8h */ case   41:  		/* lwz R7, <#[R11 + 112]> */
		/* 820AE9B8h case   41:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000070) );
		/* 820AE9B8h case   41:*/		return 0x820AE9BC;
		  /* 820AE9BCh */ case   42:  		/* lwz R8, <#[R10 + 8]> */
		/* 820AE9BCh case   42:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820AE9BCh case   42:*/		return 0x820AE9C0;
		  /* 820AE9C0h */ case   43:  		/* lwz R6, <#[R31 + 80]> */
		/* 820AE9C0h case   43:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000050) );
		/* 820AE9C0h case   43:*/		return 0x820AE9C4;
		  /* 820AE9C4h */ case   44:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820AE9C4h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820AE9C4h case   44:*/		return 0x820AE9C8;
		  /* 820AE9C8h */ case   45:  		/* addi R8, R8, 16 */
		/* 820AE9C8h case   45:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x10);
		/* 820AE9C8h case   45:*/		return 0x820AE9CC;
		  /* 820AE9CCh */ case   46:  		/* stwx R8, <#[R7 + R6]> */
		/* 820AE9CCh case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 820AE9CCh case   46:*/		return 0x820AE9D0;
		  /* 820AE9D0h */ case   47:  		/* lwz R8, <#[R31 + 84]> */
		/* 820AE9D0h case   47:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000054) );
		/* 820AE9D0h case   47:*/		return 0x820AE9D4;
		  /* 820AE9D4h */ case   48:  		/* lwz R11, <#[R11 + 100]> */
		/* 820AE9D4h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000064) );
		/* 820AE9D4h case   48:*/		return 0x820AE9D8;
		  /* 820AE9D8h */ case   49:  		/* rlwinm R7, R11, 2, 0, 29 */
		/* 820AE9D8h case   49:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R11);
		/* 820AE9D8h case   49:*/		return 0x820AE9DC;
		  /* 820AE9DCh */ case   50:  		/* lwz R11, <#[R10 + 8]> */
		/* 820AE9DCh case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820AE9DCh case   50:*/		return 0x820AE9E0;
		  /* 820AE9E0h */ case   51:  		/* addi R11, R11, 16 */
		/* 820AE9E0h case   51:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820AE9E0h case   51:*/		return 0x820AE9E4;
		  /* 820AE9E4h */ case   52:  		/* stwx R11, <#[R7 + R8]> */
		/* 820AE9E4h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820AE9E4h case   52:*/		return 0x820AE9E8;
	}
	return 0x820AE9E8;
} // Block from 820AE914h-820AE9E8h (53 instructions)

//////////////////////////////////////////////////////
// Block at 820AE9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE9E8);
		  /* 820AE9E8h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820AE9E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820AE9E8h case    0:*/		return 0x820AE9EC;
		  /* 820AE9ECh */ case    1:  		/* addi R9, R9, 1 */
		/* 820AE9ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820AE9ECh case    1:*/		return 0x820AE9F0;
		  /* 820AE9F0h */ case    2:  		/* lwz R10, <#[R10 + 12]> */
		/* 820AE9F0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820AE9F0h case    2:*/		return 0x820AE9F4;
		  /* 820AE9F4h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 820AE9F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820AE9F4h case    3:*/		return 0x820AE9F8;
		  /* 820AE9F8h */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 820AE9F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820AE970;  }
		/* 820AE9F8h case    4:*/		return 0x820AE9FC;
	}
	return 0x820AE9FC;
} // Block from 820AE9E8h-820AE9FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AE9FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AE9FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AE9FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AE9FC);
		  /* 820AE9FCh */ case    0:  		/* li R3, 0 */
		/* 820AE9FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AE9FCh case    0:*/		return 0x820AEA00;
	}
	return 0x820AEA00;
} // Block from 820AE9FCh-820AEA00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AEA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEA00);
		  /* 820AEA00h */ case    0:  		/* addi R1, R1, 112 */
		/* 820AEA00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820AEA00h case    0:*/		return 0x820AEA04;
		  /* 820AEA04h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AEA04h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AEA04h case    1:*/		return 0x820AEA08;
		  /* 820AEA08h */ case    2:  		/* mtspr LR, R12 */
		/* 820AEA08h case    2:*/		regs.LR = regs.R12;
		/* 820AEA08h case    2:*/		return 0x820AEA0C;
		  /* 820AEA0Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820AEA0Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AEA0Ch case    3:*/		return 0x820AEA10;
		  /* 820AEA10h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820AEA10h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AEA10h case    4:*/		return 0x820AEA14;
		  /* 820AEA14h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820AEA14h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AEA14h case    5:*/		return 0x820AEA18;
	}
	return 0x820AEA18;
} // Block from 820AEA00h-820AEA18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AEA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEA18);
		  /* 820AEA18h */ case    0:  		/* mfspr R12, LR */
		/* 820AEA18h case    0:*/		regs.R12 = regs.LR;
		/* 820AEA18h case    0:*/		return 0x820AEA1C;
		  /* 820AEA1Ch */ case    1:  		/* bl -120772 */
		/* 820AEA1Ch case    1:*/		regs.LR = 0x820AEA20; return 0x82091258;
		/* 820AEA1Ch case    1:*/		return 0x820AEA20;
		  /* 820AEA20h */ case    2:  		/* stfd FR31, <#[R1 - 48]> */
		/* 820AEA20h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 820AEA20h case    2:*/		return 0x820AEA24;
		  /* 820AEA24h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 820AEA24h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820AEA24h case    3:*/		return 0x820AEA28;
		  /* 820AEA28h */ case    4:  		/* lfd FR0, <#[R5]> */
		/* 820AEA28h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 820AEA28h case    4:*/		return 0x820AEA2C;
		  /* 820AEA2Ch */ case    5:  		/* lis R11, -32256 */
		/* 820AEA2Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820AEA2Ch case    5:*/		return 0x820AEA30;
		  /* 820AEA30h */ case    6:  		/* lfd FR13, <#[R6]> */
		/* 820AEA30h case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R6 + 0x00000000) );
		/* 820AEA30h case    6:*/		return 0x820AEA34;
		  /* 820AEA34h */ case    7:  		/* mr R31, R4 */
		/* 820AEA34h case    7:*/		regs.R31 = regs.R4;
		/* 820AEA34h case    7:*/		return 0x820AEA38;
		  /* 820AEA38h */ case    8:  		/* lfd FR12, <#[R6 + 8]> */
		/* 820AEA38h case    8:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R6 + 0x00000008) );
		/* 820AEA38h case    8:*/		return 0x820AEA3C;
		  /* 820AEA3Ch */ case    9:  		/* fmul FR11, FR13, FR0 */
		/* 820AEA3Ch case    9:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR13,regs.FR0);
		/* 820AEA3Ch case    9:*/		return 0x820AEA40;
		  /* 820AEA40h */ case   10:  		/* lfd FR10, <#[R5 + 8]> */
		/* 820AEA40h case   10:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R5 + 0x00000008) );
		/* 820AEA40h case   10:*/		return 0x820AEA44;
		  /* 820AEA44h */ case   11:  		/* fmul FR0, FR12, FR0 */
		/* 820AEA44h case   11:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 820AEA44h case   11:*/		return 0x820AEA48;
		  /* 820AEA48h */ case   12:  		/* lfd FR9, <#[R3 + 168]> */
		/* 820AEA48h case   12:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R3 + 0x000000A8) );
		/* 820AEA48h case   12:*/		return 0x820AEA4C;
		  /* 820AEA4Ch */ case   13:  		/* fmul FR13, FR10, FR13 */
		/* 820AEA4Ch case   13:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR10,regs.FR13);
		/* 820AEA4Ch case   13:*/		return 0x820AEA50;
		  /* 820AEA50h */ case   14:  		/* fmul FR12, FR10, FR12 */
		/* 820AEA50h case   14:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR10,regs.FR12);
		/* 820AEA50h case   14:*/		return 0x820AEA54;
		  /* 820AEA54h */ case   15:  		/* stfd FR9, <#[R4]> */
		/* 820AEA54h case   15:*/		cpu::mem::store64f( regs, regs.FR9, (uint32)(regs.R4 + 0x00000000) );
		/* 820AEA54h case   15:*/		return 0x820AEA58;
		  /* 820AEA58h */ case   16:  		/* lfd FR10, <#[R3 + 176]> */
		/* 820AEA58h case   16:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R3 + 0x000000B0) );
		/* 820AEA58h case   16:*/		return 0x820AEA5C;
		  /* 820AEA5Ch */ case   17:  		/* mr R28, R7 */
		/* 820AEA5Ch case   17:*/		regs.R28 = regs.R7;
		/* 820AEA5Ch case   17:*/		return 0x820AEA60;
		  /* 820AEA60h */ case   18:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820AEA60h case   18:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820AEA60h case   18:*/		return 0x820AEA64;
		  /* 820AEA64h */ case   19:  		/* li R29, 0 */
		/* 820AEA64h case   19:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820AEA64h case   19:*/		return 0x820AEA68;
		  /* 820AEA68h */ case   20:  		/* stfd FR11, <#[R1 + 80]> */
		/* 820AEA68h case   20:*/		cpu::mem::store64f( regs, regs.FR11, (uint32)(regs.R1 + 0x00000050) );
		/* 820AEA68h case   20:*/		return 0x820AEA6C;
		  /* 820AEA6Ch */ case   21:  		/* addi R30, R1, 80 */
		/* 820AEA6Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x50);
		/* 820AEA6Ch case   21:*/		return 0x820AEA70;
		  /* 820AEA70h */ case   22:  		/* stfd FR0, <#[R1 + 88]> */
		/* 820AEA70h case   22:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AEA70h case   22:*/		return 0x820AEA74;
		  /* 820AEA74h */ case   23:  		/* stfd FR13, <#[R1 + 96]> */
		/* 820AEA74h case   23:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEA74h case   23:*/		return 0x820AEA78;
		  /* 820AEA78h */ case   24:  		/* stfd FR12, <#[R1 + 104]> */
		/* 820AEA78h case   24:*/		cpu::mem::store64f( regs, regs.FR12, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEA78h case   24:*/		return 0x820AEA7C;
		  /* 820AEA7Ch */ case   25:  		/* stfd FR10, <#[R4 + 8]> */
		/* 820AEA7Ch case   25:*/		cpu::mem::store64f( regs, regs.FR10, (uint32)(regs.R4 + 0x00000008) );
		/* 820AEA7Ch case   25:*/		return 0x820AEA80;
		  /* 820AEA80h */ case   26:  		/* lfd FR1, <#[R30]> */
		/* 820AEA80h case   26:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R30 + 0x00000000) );
		/* 820AEA80h case   26:*/		return 0x820AEA84;
		  /* 820AEA84h */ case   27:  		/* bl -92820 */
		/* 820AEA84h case   27:*/		regs.LR = 0x820AEA88; return 0x82097FF0;
		/* 820AEA84h case   27:*/		return 0x820AEA88;
		  /* 820AEA88h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 820AEA88h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AEA88h case   28:*/		return 0x820AEA8C;
		  /* 820AEA8Ch */ case   29:  		/* bc 12, CR0_EQ, 16 */
		/* 820AEA8Ch case   29:*/		if ( regs.CR[0].eq ) { return 0x820AEA9C;  }
		/* 820AEA8Ch case   29:*/		return 0x820AEA90;
		  /* 820AEA90h */ case   30:  		/* rlwinm. R11, R28, 0, 25, 25 */
		/* 820AEA90h case   30:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R28);
		/* 820AEA90h case   30:*/		return 0x820AEA94;
		  /* 820AEA94h */ case   31:  		/* bc 4, CR0_EQ, 64 */
		/* 820AEA94h case   31:*/		if ( !regs.CR[0].eq ) { return 0x820AEAD4;  }
		/* 820AEA94h case   31:*/		return 0x820AEA98;
		  /* 820AEA98h */ case   32:  		/* stfd FR31, <#[R30]> */
		/* 820AEA98h case   32:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R30 + 0x00000000) );
		/* 820AEA98h case   32:*/		return 0x820AEA9C;
	}
	return 0x820AEA9C;
} // Block from 820AEA18h-820AEA9Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 820AEA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEA9C);
		  /* 820AEA9Ch */ case    0:  		/* lfd FR0, <#[R30]> */
		/* 820AEA9Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 820AEA9Ch case    0:*/		return 0x820AEAA0;
		  /* 820AEAA0h */ case    1:  		/* lfd FR13, <#[R31]> */
		/* 820AEAA0h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEAA0h case    1:*/		return 0x820AEAA4;
		  /* 820AEAA4h */ case    2:  		/* fcmpu CR6, FR13, FR0 */
		/* 820AEAA4h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820AEAA4h case    2:*/		return 0x820AEAA8;
		  /* 820AEAA8h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820AEAA8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820AEAB0;  }
		/* 820AEAA8h case    3:*/		return 0x820AEAAC;
		  /* 820AEAACh */ case    4:  		/* stfd FR0, <#[R31]> */
		/* 820AEAACh case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEAACh case    4:*/		return 0x820AEAB0;
	}
	return 0x820AEAB0;
} // Block from 820AEA9Ch-820AEAB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AEAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEAB0);
		  /* 820AEAB0h */ case    0:  		/* lfd FR13, <#[R31 + 8]> */
		/* 820AEAB0h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000008) );
		/* 820AEAB0h case    0:*/		return 0x820AEAB4;
		  /* 820AEAB4h */ case    1:  		/* fcmpu CR6, FR13, FR0 */
		/* 820AEAB4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820AEAB4h case    1:*/		return 0x820AEAB8;
		  /* 820AEAB8h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 820AEAB8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820AEAC0;  }
		/* 820AEAB8h case    2:*/		return 0x820AEABC;
		  /* 820AEABCh */ case    3:  		/* stfd FR0, <#[R31 + 8]> */
		/* 820AEABCh case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000008) );
		/* 820AEABCh case    3:*/		return 0x820AEAC0;
	}
	return 0x820AEAC0;
} // Block from 820AEAB0h-820AEAC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AEAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEAC0);
		  /* 820AEAC0h */ case    0:  		/* addi R29, R29, 1 */
		/* 820AEAC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820AEAC0h case    0:*/		return 0x820AEAC4;
		  /* 820AEAC4h */ case    1:  		/* addi R30, R30, 8 */
		/* 820AEAC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 820AEAC4h case    1:*/		return 0x820AEAC8;
		  /* 820AEAC8h */ case    2:  		/* cmplwi CR6, R29, 4 */
		/* 820AEAC8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000004);
		/* 820AEAC8h case    2:*/		return 0x820AEACC;
		  /* 820AEACCh */ case    3:  		/* bc 12, CR6_LT, -76 */
		/* 820AEACCh case    3:*/		if ( regs.CR[6].lt ) { return 0x820AEA80;  }
		/* 820AEACCh case    3:*/		return 0x820AEAD0;
		  /* 820AEAD0h */ case    4:  		/* b 24 */
		/* 820AEAD0h case    4:*/		return 0x820AEAE8;
		/* 820AEAD0h case    4:*/		return 0x820AEAD4;
	}
	return 0x820AEAD4;
} // Block from 820AEAC0h-820AEAD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AEAD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEAD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEAD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEAD4);
		  /* 820AEAD4h */ case    0:  		/* rlwinm R11, R29, 3, 0, 28 */
		/* 820AEAD4h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R29);
		/* 820AEAD4h case    0:*/		return 0x820AEAD8;
		  /* 820AEAD8h */ case    1:  		/* addi R10, R1, 80 */
		/* 820AEAD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820AEAD8h case    1:*/		return 0x820AEADC;
		  /* 820AEADCh */ case    2:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 820AEADCh case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AEADCh case    2:*/		return 0x820AEAE0;
		  /* 820AEAE0h */ case    3:  		/* stfd FR0, <#[R31]> */
		/* 820AEAE0h case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEAE0h case    3:*/		return 0x820AEAE4;
		  /* 820AEAE4h */ case    4:  		/* stfd FR0, <#[R31 + 8]> */
		/* 820AEAE4h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000008) );
		/* 820AEAE4h case    4:*/		return 0x820AEAE8;
	}
	return 0x820AEAE8;
} // Block from 820AEAD4h-820AEAE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AEAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEAE8);
		  /* 820AEAE8h */ case    0:  		/* addi R1, R1, 160 */
		/* 820AEAE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820AEAE8h case    0:*/		return 0x820AEAEC;
		  /* 820AEAECh */ case    1:  		/* lfd FR31, <#[R1 - 48]> */
		/* 820AEAECh case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 820AEAECh case    1:*/		return 0x820AEAF0;
		  /* 820AEAF0h */ case    2:  		/* b -120904 */
		/* 820AEAF0h case    2:*/		return 0x820912A8;
		/* 820AEAF0h case    2:*/		return 0x820AEAF4;
		  /* 820AEAF4h */ case    3:  		/* nop */
		/* 820AEAF4h case    3:*/		cpu::op::nop();
		/* 820AEAF4h case    3:*/		return 0x820AEAF8;
	}
	return 0x820AEAF8;
} // Block from 820AEAE8h-820AEAF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AEAF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEAF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEAF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEAF8);
		  /* 820AEAF8h */ case    0:  		/* mfspr R12, LR */
		/* 820AEAF8h case    0:*/		regs.R12 = regs.LR;
		/* 820AEAF8h case    0:*/		return 0x820AEAFC;
		  /* 820AEAFCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AEAFCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AEAFCh case    1:*/		return 0x820AEB00;
		  /* 820AEB00h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820AEB00h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AEB00h case    2:*/		return 0x820AEB04;
		  /* 820AEB04h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820AEB04h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AEB04h case    3:*/		return 0x820AEB08;
		  /* 820AEB08h */ case    4:  		/* addi R12, R1, -24 */
		/* 820AEB08h case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFE8);
		/* 820AEB08h case    4:*/		return 0x820AEB0C;
		  /* 820AEB0Ch */ case    5:  		/* bl -120564 */
		/* 820AEB0Ch case    5:*/		regs.LR = 0x820AEB10; return 0x82091418;
		/* 820AEB0Ch case    5:*/		return 0x820AEB10;
		  /* 820AEB10h */ case    6:  		/* stwu R1, <#[R1 - 176]> */
		/* 820AEB10h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820AEB10h case    6:*/		return 0x820AEB14;
		  /* 820AEB14h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AEB14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AEB14h case    7:*/		return 0x820AEB18;
		  /* 820AEB18h */ case    8:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820AEB18h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820AEB18h case    8:*/		return 0x820AEB1C;
		  /* 820AEB1Ch */ case    9:  		/* mr R30, R5 */
		/* 820AEB1Ch case    9:*/		regs.R30 = regs.R5;
		/* 820AEB1Ch case    9:*/		return 0x820AEB20;
		  /* 820AEB20h */ case   10:  		/* lwz R11, <#[R11 + 20]> */
		/* 820AEB20h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820AEB20h case   10:*/		return 0x820AEB24;
		  /* 820AEB24h */ case   11:  		/* lwzx R31, <#[R11 + R10]> */
		/* 820AEB24h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AEB24h case   11:*/		return 0x820AEB28;
		  /* 820AEB28h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820AEB28h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEB28h case   12:*/		return 0x820AEB2C;
		  /* 820AEB2Ch */ case   13:  		/* rlwinm. R10, R11, 0, 23, 23 */
		/* 820AEB2Ch case   13:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R11);
		/* 820AEB2Ch case   13:*/		return 0x820AEB30;
		  /* 820AEB30h */ case   14:  		/* bc 12, CR0_EQ, 36 */
		/* 820AEB30h case   14:*/		if ( regs.CR[0].eq ) { return 0x820AEB54;  }
		/* 820AEB30h case   14:*/		return 0x820AEB34;
		  /* 820AEB34h */ case   15:  		/* cmplwi CR6, R5, 0 */
		/* 820AEB34h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820AEB34h case   15:*/		return 0x820AEB38;
		  /* 820AEB38h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 820AEB38h case   16:*/		if ( regs.CR[6].eq ) { return 0x820AEB4C;  }
		/* 820AEB38h case   16:*/		return 0x820AEB3C;
		  /* 820AEB3Ch */ case   17:  		/* lfd FR0, <#[R31 + 32]> */
		/* 820AEB3Ch case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820AEB3Ch case   17:*/		return 0x820AEB40;
		  /* 820AEB40h */ case   18:  		/* stfd FR0, <#[R5]> */
		/* 820AEB40h case   18:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 820AEB40h case   18:*/		return 0x820AEB44;
		  /* 820AEB44h */ case   19:  		/* lfd FR0, <#[R31 + 40]> */
		/* 820AEB44h case   19:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000028) );
		/* 820AEB44h case   19:*/		return 0x820AEB48;
		  /* 820AEB48h */ case   20:  		/* stfd FR0, <#[R30 + 8]> */
		/* 820AEB48h case   20:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000008) );
		/* 820AEB48h case   20:*/		return 0x820AEB4C;
	}
	return 0x820AEB4C;
} // Block from 820AEAF8h-820AEB4Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AEB4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEB4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEB4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEB4C);
		  /* 820AEB4Ch */ case    0:  		/* li R3, 0 */
		/* 820AEB4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AEB4Ch case    0:*/		return 0x820AEB50;
		  /* 820AEB50h */ case    1:  		/* b 488 */
		/* 820AEB50h case    1:*/		return 0x820AED38;
		/* 820AEB50h case    1:*/		return 0x820AEB54;
	}
	return 0x820AEB54;
} // Block from 820AEB4Ch-820AEB54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AEB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEB54);
		  /* 820AEB54h */ case    0:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 820AEB54h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 820AEB54h case    0:*/		return 0x820AEB58;
		  /* 820AEB58h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 820AEB58h case    1:*/		if ( regs.CR[0].eq ) { return 0x820AEB74;  }
		/* 820AEB58h case    1:*/		return 0x820AEB5C;
		  /* 820AEB5Ch */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 820AEB5Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820AEB5Ch case    2:*/		return 0x820AEB60;
		  /* 820AEB60h */ case    3:  		/* bc 12, CR6_EQ, -20 */
		/* 820AEB60h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AEB4C;  }
		/* 820AEB60h case    3:*/		return 0x820AEB64;
		  /* 820AEB64h */ case    4:  		/* lfd FR0, <#[R31 + 32]> */
		/* 820AEB64h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820AEB64h case    4:*/		return 0x820AEB68;
		  /* 820AEB68h */ case    5:  		/* stfd FR0, <#[R30]> */
		/* 820AEB68h case    5:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 820AEB68h case    5:*/		return 0x820AEB6C;
		  /* 820AEB6Ch */ case    6:  		/* lfd FR0, <#[R31 + 32]> */
		/* 820AEB6Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820AEB6Ch case    6:*/		return 0x820AEB70;
		  /* 820AEB70h */ case    7:  		/* b -40 */
		/* 820AEB70h case    7:*/		return 0x820AEB48;
		/* 820AEB70h case    7:*/		return 0x820AEB74;
	}
	return 0x820AEB74;
} // Block from 820AEB54h-820AEB74h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AEB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEB74);
		  /* 820AEB74h */ case    0:  		/* lfd FR31, <#[R3 + 176]> */
		/* 820AEB74h case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R3 + 0x000000B0) );
		/* 820AEB74h case    0:*/		return 0x820AEB78;
		  /* 820AEB78h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 820AEB78h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 820AEB78h case    1:*/		return 0x820AEB7C;
		  /* 820AEB7Ch */ case    2:  		/* lfd FR30, <#[R3 + 168]> */
		/* 820AEB7Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R3 + 0x000000A8) );
		/* 820AEB7Ch case    2:*/		return 0x820AEB80;
		  /* 820AEB80h */ case    3:  		/* stfd FR31, <#[R1 + 96]> */
		/* 820AEB80h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEB80h case    3:*/		return 0x820AEB84;
		  /* 820AEB84h */ case    4:  		/* stfd FR30, <#[R1 + 104]> */
		/* 820AEB84h case    4:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEB84h case    4:*/		return 0x820AEB88;
		  /* 820AEB88h */ case    5:  		/* bc 12, CR0_EQ, 52 */
		/* 820AEB88h case    5:*/		if ( regs.CR[0].eq ) { return 0x820AEBBC;  }
		/* 820AEB88h case    5:*/		return 0x820AEB8C;
		  /* 820AEB8Ch */ case    6:  		/* lis R11, -32256 */
		/* 820AEB8Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820AEB8Ch case    6:*/		return 0x820AEB90;
		  /* 820AEB90h */ case    7:  		/* addi R10, R11, 1808 */
		/* 820AEB90h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x710);
		/* 820AEB90h case    7:*/		return 0x820AEB94;
		  /* 820AEB94h */ case    8:  		/* lfd FR29, <#[R11 + 1808]> */
		/* 820AEB94h case    8:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R11 + 0x00000710) );
		/* 820AEB94h case    8:*/		return 0x820AEB98;
		  /* 820AEB98h */ case    9:  		/* fcmpu CR6, FR31, FR29 */
		/* 820AEB98h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR29);
		/* 820AEB98h case    9:*/		return 0x820AEB9C;
		  /* 820AEB9Ch */ case   10:  		/* bc 12, CR6_GT, 12 */
		/* 820AEB9Ch case   10:*/		if ( regs.CR[6].gt ) { return 0x820AEBA8;  }
		/* 820AEB9Ch case   10:*/		return 0x820AEBA0;
		  /* 820AEBA0h */ case   11:  		/* stfd FR29, <#[R1 + 96]> */
		/* 820AEBA0h case   11:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEBA0h case   11:*/		return 0x820AEBA4;
		  /* 820AEBA4h */ case   12:  		/* fmr FR31, FR29 */
		/* 820AEBA4h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR29);
		/* 820AEBA4h case   12:*/		return 0x820AEBA8;
	}
	return 0x820AEBA8;
} // Block from 820AEB74h-820AEBA8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AEBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEBA8);
		  /* 820AEBA8h */ case    0:  		/* fcmpu CR6, FR30, FR29 */
		/* 820AEBA8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR29);
		/* 820AEBA8h case    0:*/		return 0x820AEBAC;
		  /* 820AEBACh */ case    1:  		/* bc 12, CR6_GT, 44 */
		/* 820AEBACh case    1:*/		if ( regs.CR[6].gt ) { return 0x820AEBD8;  }
		/* 820AEBACh case    1:*/		return 0x820AEBB0;
		  /* 820AEBB0h */ case    2:  		/* stfd FR29, <#[R1 + 104]> */
		/* 820AEBB0h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEBB0h case    2:*/		return 0x820AEBB4;
		  /* 820AEBB4h */ case    3:  		/* fmr FR30, FR29 */
		/* 820AEBB4h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR29);
		/* 820AEBB4h case    3:*/		return 0x820AEBB8;
		  /* 820AEBB8h */ case    4:  		/* b 32 */
		/* 820AEBB8h case    4:*/		return 0x820AEBD8;
		/* 820AEBB8h case    4:*/		return 0x820AEBBC;
	}
	return 0x820AEBBC;
} // Block from 820AEBA8h-820AEBBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AEBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEBBC);
		  /* 820AEBBCh */ case    0:  		/* lis R10, -32256 */
		/* 820AEBBCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820AEBBCh case    0:*/		return 0x820AEBC0;
		  /* 820AEBC0h */ case    1:  		/* addi R10, R10, 1808 */
		/* 820AEBC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x710);
		/* 820AEBC0h case    1:*/		return 0x820AEBC4;
		  /* 820AEBC4h */ case    2:  		/* lfd FR29, <#[R10]> */
		/* 820AEBC4h case    2:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R10 + 0x00000000) );
		/* 820AEBC4h case    2:*/		return 0x820AEBC8;
		  /* 820AEBC8h */ case    3:  		/* fcmpu CR6, FR31, FR29 */
		/* 820AEBC8h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR29);
		/* 820AEBC8h case    3:*/		return 0x820AEBCC;
		  /* 820AEBCCh */ case    4:  		/* bc 12, CR6_LT, 12 */
		/* 820AEBCCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820AEBD8;  }
		/* 820AEBCCh case    4:*/		return 0x820AEBD0;
		  /* 820AEBD0h */ case    5:  		/* ori R11, R11, 4 */
		/* 820AEBD0h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820AEBD0h case    5:*/		return 0x820AEBD4;
		  /* 820AEBD4h */ case    6:  		/* stw R11, <#[R31]> */
		/* 820AEBD4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEBD4h case    6:*/		return 0x820AEBD8;
	}
	return 0x820AEBD8;
} // Block from 820AEBBCh-820AEBD8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AEBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEBD8);
		  /* 820AEBD8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820AEBD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEBD8h case    0:*/		return 0x820AEBDC;
		  /* 820AEBDCh */ case    1:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 820AEBDCh case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 820AEBDCh case    1:*/		return 0x820AEBE0;
		  /* 820AEBE0h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 820AEBE0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820AEBF8;  }
		/* 820AEBE0h case    2:*/		return 0x820AEBE4;
		  /* 820AEBE4h */ case    3:  		/* fsel FR31, FR31, FR29, FR31 */
		/* 820AEBE4h case    3:*/		cpu::op::fsel<0>(regs,&regs.FR31,regs.FR31,regs.FR29,regs.FR31);
		/* 820AEBE4h case    3:*/		return 0x820AEBE8;
		  /* 820AEBE8h */ case    4:  		/* stfd FR31, <#[R1 + 96]> */
		/* 820AEBE8h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEBE8h case    4:*/		return 0x820AEBEC;
		  /* 820AEBECh */ case    5:  		/* fsel FR30, FR30, FR29, FR30 */
		/* 820AEBECh case    5:*/		cpu::op::fsel<0>(regs,&regs.FR30,regs.FR30,regs.FR29,regs.FR30);
		/* 820AEBECh case    5:*/		return 0x820AEBF0;
		  /* 820AEBF0h */ case    6:  		/* stfd FR30, <#[R1 + 104]> */
		/* 820AEBF0h case    6:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEBF0h case    6:*/		return 0x820AEBF4;
		  /* 820AEBF4h */ case    7:  		/* b 20 */
		/* 820AEBF4h case    7:*/		return 0x820AEC08;
		/* 820AEBF4h case    7:*/		return 0x820AEBF8;
	}
	return 0x820AEBF8;
} // Block from 820AEBD8h-820AEBF8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AEBF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEBF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEBF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEBF8);
		  /* 820AEBF8h */ case    0:  		/* fcmpu CR6, FR30, FR29 */
		/* 820AEBF8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR29);
		/* 820AEBF8h case    0:*/		return 0x820AEBFC;
		  /* 820AEBFCh */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 820AEBFCh case    1:*/		if ( regs.CR[6].gt ) { return 0x820AEC08;  }
		/* 820AEBFCh case    1:*/		return 0x820AEC00;
		  /* 820AEC00h */ case    2:  		/* ori R11, R11, 8 */
		/* 820AEC00h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820AEC00h case    2:*/		return 0x820AEC04;
		  /* 820AEC04h */ case    3:  		/* stw R11, <#[R31]> */
		/* 820AEC04h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEC04h case    3:*/		return 0x820AEC08;
	}
	return 0x820AEC08;
} // Block from 820AEBF8h-820AEC08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AEC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEC08);
		  /* 820AEC08h */ case    0:  		/* lis R10, -32256 */
		/* 820AEC08h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820AEC08h case    0:*/		return 0x820AEC0C;
		  /* 820AEC0Ch */ case    1:  		/* lwz R11, <#[R31]> */
		/* 820AEC0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEC0Ch case    1:*/		return 0x820AEC10;
		  /* 820AEC10h */ case    2:  		/* rlwinm. R9, R11, 0, 27, 27 */
		/* 820AEC10h case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R11);
		/* 820AEC10h case    2:*/		return 0x820AEC14;
		  /* 820AEC14h */ case    3:  		/* lfd FR28, <#[R10 + 1848]> */
		/* 820AEC14h case    3:*/		cpu::mem::load64f( regs, &regs.FR28, (uint32)(regs.R10 + 0x00000738) );
		/* 820AEC14h case    3:*/		return 0x820AEC18;
		  /* 820AEC18h */ case    4:  		/* bc 12, CR0_EQ, 80 */
		/* 820AEC18h case    4:*/		if ( regs.CR[0].eq ) { return 0x820AEC68;  }
		/* 820AEC18h case    4:*/		return 0x820AEC1C;
		  /* 820AEC1Ch */ case    5:  		/* lis R11, -32255 */
		/* 820AEC1Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AEC1Ch case    5:*/		return 0x820AEC20;
		  /* 820AEC20h */ case    6:  		/* lfd FR0, <#[R11 - 24488]> */
		/* 820AEC20h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 820AEC20h case    6:*/		return 0x820AEC24;
		  /* 820AEC24h */ case    7:  		/* fcmpu CR6, FR31, FR0 */
		/* 820AEC24h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820AEC24h case    7:*/		return 0x820AEC28;
		  /* 820AEC28h */ case    8:  		/* bc 12, CR6_GT, 12 */
		/* 820AEC28h case    8:*/		if ( regs.CR[6].gt ) { return 0x820AEC34;  }
		/* 820AEC28h case    8:*/		return 0x820AEC2C;
		  /* 820AEC2Ch */ case    9:  		/* stfd FR0, <#[R1 + 96]> */
		/* 820AEC2Ch case    9:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEC2Ch case    9:*/		return 0x820AEC30;
		  /* 820AEC30h */ case   10:  		/* fmr FR31, FR0 */
		/* 820AEC30h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR0);
		/* 820AEC30h case   10:*/		return 0x820AEC34;
	}
	return 0x820AEC34;
} // Block from 820AEC08h-820AEC34h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AEC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEC34);
		  /* 820AEC34h */ case    0:  		/* fcmpu CR6, FR30, FR0 */
		/* 820AEC34h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR0);
		/* 820AEC34h case    0:*/		return 0x820AEC38;
		  /* 820AEC38h */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 820AEC38h case    1:*/		if ( regs.CR[6].gt ) { return 0x820AEC44;  }
		/* 820AEC38h case    1:*/		return 0x820AEC3C;
		  /* 820AEC3Ch */ case    2:  		/* stfd FR0, <#[R1 + 104]> */
		/* 820AEC3Ch case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEC3Ch case    2:*/		return 0x820AEC40;
		  /* 820AEC40h */ case    3:  		/* fmr FR30, FR0 */
		/* 820AEC40h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR0);
		/* 820AEC40h case    3:*/		return 0x820AEC44;
	}
	return 0x820AEC44;
} // Block from 820AEC34h-820AEC44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AEC44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEC44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEC44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEC44);
		  /* 820AEC44h */ case    0:  		/* fcmpu CR6, FR31, FR28 */
		/* 820AEC44h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR28);
		/* 820AEC44h case    0:*/		return 0x820AEC48;
		  /* 820AEC48h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 820AEC48h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AEC54;  }
		/* 820AEC48h case    1:*/		return 0x820AEC4C;
		  /* 820AEC4Ch */ case    2:  		/* stfd FR28, <#[R1 + 96]> */
		/* 820AEC4Ch case    2:*/		cpu::mem::store64f( regs, regs.FR28, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEC4Ch case    2:*/		return 0x820AEC50;
		  /* 820AEC50h */ case    3:  		/* fmr FR31, FR28 */
		/* 820AEC50h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR28);
		/* 820AEC50h case    3:*/		return 0x820AEC54;
	}
	return 0x820AEC54;
} // Block from 820AEC44h-820AEC54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AEC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEC54);
		  /* 820AEC54h */ case    0:  		/* fcmpu CR6, FR30, FR28 */
		/* 820AEC54h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR28);
		/* 820AEC54h case    0:*/		return 0x820AEC58;
		  /* 820AEC58h */ case    1:  		/* bc 12, CR6_LT, 48 */
		/* 820AEC58h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AEC88;  }
		/* 820AEC58h case    1:*/		return 0x820AEC5C;
		  /* 820AEC5Ch */ case    2:  		/* stfd FR28, <#[R1 + 104]> */
		/* 820AEC5Ch case    2:*/		cpu::mem::store64f( regs, regs.FR28, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEC5Ch case    2:*/		return 0x820AEC60;
		  /* 820AEC60h */ case    3:  		/* fmr FR30, FR28 */
		/* 820AEC60h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR28);
		/* 820AEC60h case    3:*/		return 0x820AEC64;
		  /* 820AEC64h */ case    4:  		/* b 36 */
		/* 820AEC64h case    4:*/		return 0x820AEC88;
		/* 820AEC64h case    4:*/		return 0x820AEC68;
	}
	return 0x820AEC68;
} // Block from 820AEC54h-820AEC68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AEC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEC68);
		  /* 820AEC68h */ case    0:  		/* lis R10, -32255 */
		/* 820AEC68h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AEC68h case    0:*/		return 0x820AEC6C;
		  /* 820AEC6Ch */ case    1:  		/* lfd FR0, <#[R10 - 24488]> */
		/* 820AEC6Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFFA058) );
		/* 820AEC6Ch case    1:*/		return 0x820AEC70;
		  /* 820AEC70h */ case    2:  		/* fcmpu CR6, FR31, FR0 */
		/* 820AEC70h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820AEC70h case    2:*/		return 0x820AEC74;
		  /* 820AEC74h */ case    3:  		/* bc 12, CR6_LT, 20 */
		/* 820AEC74h case    3:*/		if ( regs.CR[6].lt ) { return 0x820AEC88;  }
		/* 820AEC74h case    3:*/		return 0x820AEC78;
		  /* 820AEC78h */ case    4:  		/* fcmpu CR6, FR30, FR28 */
		/* 820AEC78h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR28);
		/* 820AEC78h case    4:*/		return 0x820AEC7C;
		  /* 820AEC7Ch */ case    5:  		/* bc 12, CR6_GT, 12 */
		/* 820AEC7Ch case    5:*/		if ( regs.CR[6].gt ) { return 0x820AEC88;  }
		/* 820AEC7Ch case    5:*/		return 0x820AEC80;
		  /* 820AEC80h */ case    6:  		/* ori R11, R11, 16 */
		/* 820AEC80h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820AEC80h case    6:*/		return 0x820AEC84;
		  /* 820AEC84h */ case    7:  		/* stw R11, <#[R31]> */
		/* 820AEC84h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEC84h case    7:*/		return 0x820AEC88;
	}
	return 0x820AEC88;
} // Block from 820AEC68h-820AEC88h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AEC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEC88);
		  /* 820AEC88h */ case    0:  		/* fcmpu CR6, FR31, FR30 */
		/* 820AEC88h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR30);
		/* 820AEC88h case    0:*/		return 0x820AEC8C;
		  /* 820AEC8Ch */ case    1:  		/* bc 4, CR6_EQ, 116 */
		/* 820AEC8Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AED00;  }
		/* 820AEC8Ch case    1:*/		return 0x820AEC90;
		  /* 820AEC90h */ case    2:  		/* fmr FR1, FR31 */
		/* 820AEC90h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AEC90h case    2:*/		return 0x820AEC94;
		  /* 820AEC94h */ case    3:  		/* bl -93380 */
		/* 820AEC94h case    3:*/		regs.LR = 0x820AEC98; return 0x82097FD0;
		/* 820AEC94h case    3:*/		return 0x820AEC98;
		  /* 820AEC98h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820AEC98h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AEC98h case    4:*/		return 0x820AEC9C;
		  /* 820AEC9Ch */ case    5:  		/* bc 12, CR0_EQ, 100 */
		/* 820AEC9Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820AED00;  }
		/* 820AEC9Ch case    5:*/		return 0x820AECA0;
		  /* 820AECA0h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820AECA0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AECA0h case    6:*/		return 0x820AECA4;
		  /* 820AECA4h */ case    7:  		/* fcmpu CR6, FR31, FR29 */
		/* 820AECA4h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR29);
		/* 820AECA4h case    7:*/		return 0x820AECA8;
		  /* 820AECA8h */ case    8:  		/* ori R11, R11, 128 */
		/* 820AECA8h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820AECA8h case    8:*/		return 0x820AECAC;
		  /* 820AECACh */ case    9:  		/* stw R11, <#[R31]> */
		/* 820AECACh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AECACh case    9:*/		return 0x820AECB0;
		  /* 820AECB0h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820AECB0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AECBC;  }
		/* 820AECB0h case   10:*/		return 0x820AECB4;
		  /* 820AECB4h */ case   11:  		/* fcmpu CR6, FR31, FR28 */
		/* 820AECB4h case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR28);
		/* 820AECB4h case   11:*/		return 0x820AECB8;
		  /* 820AECB8h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 820AECB8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820AECC4;  }
		/* 820AECB8h case   12:*/		return 0x820AECBC;
	}
	return 0x820AECBC;
} // Block from 820AEC88h-820AECBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AECBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AECBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AECBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AECBC);
		  /* 820AECBCh */ case    0:  		/* ori R11, R11, 1 */
		/* 820AECBCh case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AECBCh case    0:*/		return 0x820AECC0;
		  /* 820AECC0h */ case    1:  		/* stw R11, <#[R31]> */
		/* 820AECC0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AECC0h case    1:*/		return 0x820AECC4;
	}
	return 0x820AECC4;
} // Block from 820AECBCh-820AECC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AECC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AECC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AECC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AECC4);
		  /* 820AECC4h */ case    0:  		/* fctiwz FR0, FR31 */
		/* 820AECC4h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR31);
		/* 820AECC4h case    0:*/		return 0x820AECC8;
		  /* 820AECC8h */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 820AECC8h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AECC8h case    1:*/		return 0x820AECCC;
		  /* 820AECCCh */ case    2:  		/* lwa R11, <#[R1 + 84]> */
		/* 820AECCCh case    2:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820AECCCh case    2:*/		return 0x820AECD0;
		  /* 820AECD0h */ case    3:  		/* std R11, <#[R1 + 80]> */
		/* 820AECD0h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820AECD0h case    3:*/		return 0x820AECD4;
		  /* 820AECD4h */ case    4:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820AECD4h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AECD4h case    4:*/		return 0x820AECD8;
		  /* 820AECD8h */ case    5:  		/* fcfid FR0, FR0 */
		/* 820AECD8h case    5:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820AECD8h case    5:*/		return 0x820AECDC;
		  /* 820AECDCh */ case    6:  		/* lis R11, -32255 */
		/* 820AECDCh case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AECDCh case    6:*/		return 0x820AECE0;
		  /* 820AECE0h */ case    7:  		/* fsub FR13, FR31, FR0 */
		/* 820AECE0h case    7:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR31,regs.FR0);
		/* 820AECE0h case    7:*/		return 0x820AECE4;
		  /* 820AECE4h */ case    8:  		/* lfd FR0, <#[R11 + 8072]> */
		/* 820AECE4h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001F88) );
		/* 820AECE4h case    8:*/		return 0x820AECE8;
		  /* 820AECE8h */ case    9:  		/* fabs FR13, FR13 */
		/* 820AECE8h case    9:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR13);
		/* 820AECE8h case    9:*/		return 0x820AECEC;
		  /* 820AECECh */ case   10:  		/* fcmpu CR6, FR13, FR0 */
		/* 820AECECh case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820AECECh case   10:*/		return 0x820AECF0;
		  /* 820AECF0h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 820AECF0h case   11:*/		if ( !regs.CR[6].lt ) { return 0x820AED00;  }
		/* 820AECF0h case   11:*/		return 0x820AECF4;
		  /* 820AECF4h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820AECF4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AECF4h case   12:*/		return 0x820AECF8;
		  /* 820AECF8h */ case   13:  		/* ori R11, R11, 2 */
		/* 820AECF8h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820AECF8h case   13:*/		return 0x820AECFC;
		  /* 820AECFCh */ case   14:  		/* stw R11, <#[R31]> */
		/* 820AECFCh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AECFCh case   14:*/		return 0x820AED00;
	}
	return 0x820AED00;
} // Block from 820AECC4h-820AED00h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AED00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AED00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AED00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AED00);
		  /* 820AED00h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820AED00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AED00h case    0:*/		return 0x820AED04;
		  /* 820AED04h */ case    1:  		/* stfd FR31, <#[R31 + 32]> */
		/* 820AED04h case    1:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R31 + 0x00000020) );
		/* 820AED04h case    1:*/		return 0x820AED08;
		  /* 820AED08h */ case    2:  		/* stfd FR30, <#[R31 + 40]> */
		/* 820AED08h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R31 + 0x00000028) );
		/* 820AED08h case    2:*/		return 0x820AED0C;
		  /* 820AED0Ch */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 820AED0Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820AED0Ch case    3:*/		return 0x820AED10;
		  /* 820AED10h */ case    4:  		/* ori R11, R11, 256 */
		/* 820AED10h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820AED10h case    4:*/		return 0x820AED14;
		  /* 820AED14h */ case    5:  		/* stw R11, <#[R31]> */
		/* 820AED14h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AED14h case    5:*/		return 0x820AED18;
		  /* 820AED18h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820AED18h case    6:*/		if ( regs.CR[6].eq ) { return 0x820AED30;  }
		/* 820AED18h case    6:*/		return 0x820AED1C;
		  /* 820AED1Ch */ case    7:  		/* addi R11, R1, 96 */
		/* 820AED1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820AED1Ch case    7:*/		return 0x820AED20;
		  /* 820AED20h */ case    8:  		/* ld R10, <#[R11]> */
		/* 820AED20h case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820AED20h case    8:*/		return 0x820AED24;
		  /* 820AED24h */ case    9:  		/* ld R11, <#[R11 + 8]> */
		/* 820AED24h case    9:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820AED24h case    9:*/		return 0x820AED28;
		  /* 820AED28h */ case   10:  		/* std R10, <#[R30]> */
		/* 820AED28h case   10:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820AED28h case   10:*/		return 0x820AED2C;
		  /* 820AED2Ch */ case   11:  		/* std R11, <#[R30 + 8]> */
		/* 820AED2Ch case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820AED2Ch case   11:*/		return 0x820AED30;
	}
	return 0x820AED30;
} // Block from 820AED00h-820AED30h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AED30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AED30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AED30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AED30);
		  /* 820AED30h */ case    0:  		/* lis R3, -32768 */
		/* 820AED30h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820AED30h case    0:*/		return 0x820AED34;
		  /* 820AED34h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820AED34h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820AED34h case    1:*/		return 0x820AED38;
	}
	return 0x820AED38;
} // Block from 820AED30h-820AED38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AED38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AED38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AED38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AED38);
		  /* 820AED38h */ case    0:  		/* addi R1, R1, 176 */
		/* 820AED38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820AED38h case    0:*/		return 0x820AED3C;
		  /* 820AED3Ch */ case    1:  		/* addi R12, R1, -24 */
		/* 820AED3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFE8);
		/* 820AED3Ch case    1:*/		return 0x820AED40;
		  /* 820AED40h */ case    2:  		/* bl -121052 */
		/* 820AED40h case    2:*/		regs.LR = 0x820AED44; return 0x82091464;
		/* 820AED40h case    2:*/		return 0x820AED44;
		  /* 820AED44h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AED44h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AED44h case    3:*/		return 0x820AED48;
		  /* 820AED48h */ case    4:  		/* mtspr LR, R12 */
		/* 820AED48h case    4:*/		regs.LR = regs.R12;
		/* 820AED48h case    4:*/		return 0x820AED4C;
		  /* 820AED4Ch */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 820AED4Ch case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AED4Ch case    5:*/		return 0x820AED50;
		  /* 820AED50h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 820AED50h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AED50h case    6:*/		return 0x820AED54;
		  /* 820AED54h */ case    7:  		/* bclr 20, CR0_LT */
		/* 820AED54h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AED54h case    7:*/		return 0x820AED58;
	}
	return 0x820AED58;
} // Block from 820AED38h-820AED58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AED58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AED58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AED58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AED58);
		  /* 820AED58h */ case    0:  		/* mfspr R12, LR */
		/* 820AED58h case    0:*/		regs.R12 = regs.LR;
		/* 820AED58h case    0:*/		return 0x820AED5C;
		  /* 820AED5Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820AED5Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AED5Ch case    1:*/		return 0x820AED60;
		  /* 820AED60h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820AED60h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AED60h case    2:*/		return 0x820AED64;
		  /* 820AED64h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820AED64h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AED64h case    3:*/		return 0x820AED68;
		  /* 820AED68h */ case    4:  		/* stfd FR31, <#[R1 - 32]> */
		/* 820AED68h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 820AED68h case    4:*/		return 0x820AED6C;
		  /* 820AED6Ch */ case    5:  		/* stwu R1, <#[R1 - 128]> */
		/* 820AED6Ch case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820AED6Ch case    5:*/		return 0x820AED70;
		  /* 820AED70h */ case    6:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AED70h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AED70h case    6:*/		return 0x820AED74;
		  /* 820AED74h */ case    7:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820AED74h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820AED74h case    7:*/		return 0x820AED78;
		  /* 820AED78h */ case    8:  		/* mr R30, R5 */
		/* 820AED78h case    8:*/		regs.R30 = regs.R5;
		/* 820AED78h case    8:*/		return 0x820AED7C;
		  /* 820AED7Ch */ case    9:  		/* lwz R11, <#[R11 + 20]> */
		/* 820AED7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820AED7Ch case    9:*/		return 0x820AED80;
		  /* 820AED80h */ case   10:  		/* lwzx R31, <#[R11 + R10]> */
		/* 820AED80h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AED80h case   10:*/		return 0x820AED84;
		  /* 820AED84h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 820AED84h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AED84h case   11:*/		return 0x820AED88;
		  /* 820AED88h */ case   12:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 820AED88h case   12:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 820AED88h case   12:*/		return 0x820AED8C;
		  /* 820AED8Ch */ case   13:  		/* bc 12, CR0_EQ, 40 */
		/* 820AED8Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x820AEDB4;  }
		/* 820AED8Ch case   13:*/		return 0x820AED90;
		  /* 820AED90h */ case   14:  		/* lfd FR1, <#[R31 + 32]> */
		/* 820AED90h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000020) );
		/* 820AED90h case   14:*/		return 0x820AED94;
		  /* 820AED94h */ case   15:  		/* bl -93636 */
		/* 820AED94h case   15:*/		regs.LR = 0x820AED98; return 0x82097FD0;
		/* 820AED94h case   15:*/		return 0x820AED98;
		  /* 820AED98h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820AED98h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AED98h case   16:*/		return 0x820AED9C;
		  /* 820AED9Ch */ case   17:  		/* bc 12, CR0_EQ, 92 */
		/* 820AED9Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x820AEDF8;  }
		/* 820AED9Ch case   17:*/		return 0x820AEDA0;
		  /* 820AEDA0h */ case   18:  		/* cmplwi CR6, R30, 0 */
		/* 820AEDA0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820AEDA0h case   18:*/		return 0x820AEDA4;
		  /* 820AEDA4h */ case   19:  		/* bc 12, CR6_EQ, 76 */
		/* 820AEDA4h case   19:*/		if ( regs.CR[6].eq ) { return 0x820AEDF0;  }
		/* 820AEDA4h case   19:*/		return 0x820AEDA8;
		  /* 820AEDA8h */ case   20:  		/* lfd FR0, <#[R31 + 32]> */
		/* 820AEDA8h case   20:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820AEDA8h case   20:*/		return 0x820AEDAC;
		  /* 820AEDACh */ case   21:  		/* stfd FR0, <#[R30]> */
		/* 820AEDACh case   21:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 820AEDACh case   21:*/		return 0x820AEDB0;
		  /* 820AEDB0h */ case   22:  		/* b 64 */
		/* 820AEDB0h case   22:*/		return 0x820AEDF0;
		/* 820AEDB0h case   22:*/		return 0x820AEDB4;
	}
	return 0x820AEDB4;
} // Block from 820AED58h-820AEDB4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820AEDB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEDB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEDB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEDB4);
		  /* 820AEDB4h */ case    0:  		/* addi R5, R1, 80 */
		/* 820AEDB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820AEDB4h case    0:*/		return 0x820AEDB8;
		  /* 820AEDB8h */ case    1:  		/* bl -704 */
		/* 820AEDB8h case    1:*/		regs.LR = 0x820AEDBC; return 0x820AEAF8;
		/* 820AEDB8h case    1:*/		return 0x820AEDBC;
		  /* 820AEDBCh */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820AEDBCh case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AEDBCh case    2:*/		return 0x820AEDC0;
		  /* 820AEDC0h */ case    3:  		/* bc 12, CR0_LT, 64 */
		/* 820AEDC0h case    3:*/		if ( regs.CR[0].lt ) { return 0x820AEE00;  }
		/* 820AEDC0h case    3:*/		return 0x820AEDC4;
		  /* 820AEDC4h */ case    4:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AEDC4h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AEDC4h case    4:*/		return 0x820AEDC8;
		  /* 820AEDC8h */ case    5:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820AEDC8h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820AEDC8h case    5:*/		return 0x820AEDCC;
		  /* 820AEDCCh */ case    6:  		/* fcmpu CR6, FR31, FR0 */
		/* 820AEDCCh case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820AEDCCh case    6:*/		return 0x820AEDD0;
		  /* 820AEDD0h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 820AEDD0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820AEDF8;  }
		/* 820AEDD0h case    7:*/		return 0x820AEDD4;
		  /* 820AEDD4h */ case    8:  		/* fmr FR1, FR31 */
		/* 820AEDD4h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AEDD4h case    8:*/		return 0x820AEDD8;
		  /* 820AEDD8h */ case    9:  		/* bl -93704 */
		/* 820AEDD8h case    9:*/		regs.LR = 0x820AEDDC; return 0x82097FD0;
		/* 820AEDD8h case    9:*/		return 0x820AEDDC;
		  /* 820AEDDCh */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820AEDDCh case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AEDDCh case   10:*/		return 0x820AEDE0;
		  /* 820AEDE0h */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 820AEDE0h case   11:*/		if ( regs.CR[0].eq ) { return 0x820AEDF8;  }
		/* 820AEDE0h case   11:*/		return 0x820AEDE4;
		  /* 820AEDE4h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 820AEDE4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820AEDE4h case   12:*/		return 0x820AEDE8;
		  /* 820AEDE8h */ case   13:  		/* bc 12, CR6_EQ, 8 */
		/* 820AEDE8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AEDF0;  }
		/* 820AEDE8h case   13:*/		return 0x820AEDEC;
		  /* 820AEDECh */ case   14:  		/* stfd FR31, <#[R30]> */
		/* 820AEDECh case   14:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R30 + 0x00000000) );
		/* 820AEDECh case   14:*/		return 0x820AEDF0;
	}
	return 0x820AEDF0;
} // Block from 820AEDB4h-820AEDF0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AEDF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEDF0);
		  /* 820AEDF0h */ case    0:  		/* li R3, 0 */
		/* 820AEDF0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AEDF0h case    0:*/		return 0x820AEDF4;
		  /* 820AEDF4h */ case    1:  		/* b 12 */
		/* 820AEDF4h case    1:*/		return 0x820AEE00;
		/* 820AEDF4h case    1:*/		return 0x820AEDF8;
	}
	return 0x820AEDF8;
} // Block from 820AEDF0h-820AEDF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AEDF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEDF8);
		  /* 820AEDF8h */ case    0:  		/* lis R3, -32768 */
		/* 820AEDF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820AEDF8h case    0:*/		return 0x820AEDFC;
		  /* 820AEDFCh */ case    1:  		/* ori R3, R3, 16389 */
		/* 820AEDFCh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820AEDFCh case    1:*/		return 0x820AEE00;
	}
	return 0x820AEE00;
} // Block from 820AEDF8h-820AEE00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AEE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEE00);
		  /* 820AEE00h */ case    0:  		/* addi R1, R1, 128 */
		/* 820AEE00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820AEE00h case    0:*/		return 0x820AEE04;
		  /* 820AEE04h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820AEE04h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820AEE04h case    1:*/		return 0x820AEE08;
		  /* 820AEE08h */ case    2:  		/* mtspr LR, R12 */
		/* 820AEE08h case    2:*/		regs.LR = regs.R12;
		/* 820AEE08h case    2:*/		return 0x820AEE0C;
		  /* 820AEE0Ch */ case    3:  		/* lfd FR31, <#[R1 - 32]> */
		/* 820AEE0Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 820AEE0Ch case    3:*/		return 0x820AEE10;
		  /* 820AEE10h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820AEE10h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820AEE10h case    4:*/		return 0x820AEE14;
		  /* 820AEE14h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820AEE14h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820AEE14h case    5:*/		return 0x820AEE18;
		  /* 820AEE18h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820AEE18h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AEE18h case    6:*/		return 0x820AEE1C;
	}
	return 0x820AEE1C;
} // Block from 820AEE00h-820AEE1Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AEE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEE1C);
		  /* 820AEE1Ch */ case    0:  		/* nop */
		/* 820AEE1Ch case    0:*/		cpu::op::nop();
		/* 820AEE1Ch case    0:*/		return 0x820AEE20;
	}
	return 0x820AEE20;
} // Block from 820AEE1Ch-820AEE20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AEE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEE20);
		  /* 820AEE20h */ case    0:  		/* mfspr R12, LR */
		/* 820AEE20h case    0:*/		regs.R12 = regs.LR;
		/* 820AEE20h case    0:*/		return 0x820AEE24;
		  /* 820AEE24h */ case    1:  		/* bl -121820 */
		/* 820AEE24h case    1:*/		regs.LR = 0x820AEE28; return 0x82091248;
		/* 820AEE24h case    1:*/		return 0x820AEE28;
		  /* 820AEE28h */ case    2:  		/* addi R12, R1, -72 */
		/* 820AEE28h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFB8);
		/* 820AEE28h case    2:*/		return 0x820AEE2C;
		  /* 820AEE2Ch */ case    3:  		/* bl -121376 */
		/* 820AEE2Ch case    3:*/		regs.LR = 0x820AEE30; return 0x8209140C;
		/* 820AEE2Ch case    3:*/		return 0x820AEE30;
		  /* 820AEE30h */ case    4:  		/* stwu R1, <#[R1 - 272]> */
		/* 820AEE30h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 820AEE30h case    4:*/		return 0x820AEE34;
		  /* 820AEE34h */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AEE34h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AEE34h case    5:*/		return 0x820AEE38;
		  /* 820AEE38h */ case    6:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820AEE38h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820AEE38h case    6:*/		return 0x820AEE3C;
		  /* 820AEE3Ch */ case    7:  		/* mr R26, R3 */
		/* 820AEE3Ch case    7:*/		regs.R26 = regs.R3;
		/* 820AEE3Ch case    7:*/		return 0x820AEE40;
		  /* 820AEE40h */ case    8:  		/* mr R24, R5 */
		/* 820AEE40h case    8:*/		regs.R24 = regs.R5;
		/* 820AEE40h case    8:*/		return 0x820AEE44;
		  /* 820AEE44h */ case    9:  		/* lwz R9, <#[R11 + 20]> */
		/* 820AEE44h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820AEE44h case    9:*/		return 0x820AEE48;
		  /* 820AEE48h */ case   10:  		/* lwzx R25, <#[R9 + R10]> */
		/* 820AEE48h case   10:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820AEE48h case   10:*/		return 0x820AEE4C;
		  /* 820AEE4Ch */ case   11:  		/* lwz R10, <#[R25]> */
		/* 820AEE4Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820AEE4Ch case   11:*/		return 0x820AEE50;
		  /* 820AEE50h */ case   12:  		/* rlwinm. R9, R10, 0, 23, 23 */
		/* 820AEE50h case   12:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R10);
		/* 820AEE50h case   12:*/		return 0x820AEE54;
		  /* 820AEE54h */ case   13:  		/* bc 12, CR0_EQ, 36 */
		/* 820AEE54h case   13:*/		if ( regs.CR[0].eq ) { return 0x820AEE78;  }
		/* 820AEE54h case   13:*/		return 0x820AEE58;
		  /* 820AEE58h */ case   14:  		/* cmplwi CR6, R5, 0 */
		/* 820AEE58h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820AEE58h case   14:*/		return 0x820AEE5C;
		  /* 820AEE5Ch */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 820AEE5Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820AEE70;  }
		/* 820AEE5Ch case   15:*/		return 0x820AEE60;
		  /* 820AEE60h */ case   16:  		/* lfd FR0, <#[R25 + 32]> */
		/* 820AEE60h case   16:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R25 + 0x00000020) );
		/* 820AEE60h case   16:*/		return 0x820AEE64;
		  /* 820AEE64h */ case   17:  		/* stfd FR0, <#[R5]> */
		/* 820AEE64h case   17:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 820AEE64h case   17:*/		return 0x820AEE68;
		  /* 820AEE68h */ case   18:  		/* lfd FR0, <#[R25 + 40]> */
		/* 820AEE68h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R25 + 0x00000028) );
		/* 820AEE68h case   18:*/		return 0x820AEE6C;
		  /* 820AEE6Ch */ case   19:  		/* stfd FR0, <#[R24 + 8]> */
		/* 820AEE6Ch case   19:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R24 + 0x00000008) );
		/* 820AEE6Ch case   19:*/		return 0x820AEE70;
	}
	return 0x820AEE70;
} // Block from 820AEE20h-820AEE70h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AEE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEE70);
		  /* 820AEE70h */ case    0:  		/* li R3, 0 */
		/* 820AEE70h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AEE70h case    0:*/		return 0x820AEE74;
		  /* 820AEE74h */ case    1:  		/* b 3232 */
		/* 820AEE74h case    1:*/		return 0x820AFB14;
		/* 820AEE74h case    1:*/		return 0x820AEE78;
	}
	return 0x820AEE78;
} // Block from 820AEE70h-820AEE78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AEE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEE78);
		  /* 820AEE78h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 24 */
		/* 820AEE78h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R10);
		/* 820AEE78h case    0:*/		return 0x820AEE7C;
		  /* 820AEE7Ch */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 820AEE7Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820AEE98;  }
		/* 820AEE7Ch case    1:*/		return 0x820AEE80;
		  /* 820AEE80h */ case    2:  		/* cmplwi CR6, R24, 0 */
		/* 820AEE80h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820AEE80h case    2:*/		return 0x820AEE84;
		  /* 820AEE84h */ case    3:  		/* bc 12, CR6_EQ, -20 */
		/* 820AEE84h case    3:*/		if ( regs.CR[6].eq ) { return 0x820AEE70;  }
		/* 820AEE84h case    3:*/		return 0x820AEE88;
		  /* 820AEE88h */ case    4:  		/* lfd FR0, <#[R25 + 32]> */
		/* 820AEE88h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R25 + 0x00000020) );
		/* 820AEE88h case    4:*/		return 0x820AEE8C;
		  /* 820AEE8Ch */ case    5:  		/* stfd FR0, <#[R24]> */
		/* 820AEE8Ch case    5:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R24 + 0x00000000) );
		/* 820AEE8Ch case    5:*/		return 0x820AEE90;
		  /* 820AEE90h */ case    6:  		/* lfd FR0, <#[R25 + 32]> */
		/* 820AEE90h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R25 + 0x00000020) );
		/* 820AEE90h case    6:*/		return 0x820AEE94;
		  /* 820AEE94h */ case    7:  		/* b -40 */
		/* 820AEE94h case    7:*/		return 0x820AEE6C;
		/* 820AEE94h case    7:*/		return 0x820AEE98;
	}
	return 0x820AEE98;
} // Block from 820AEE78h-820AEE98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AEE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEE98);
		  /* 820AEE98h */ case    0:  		/* lis R10, -32256 */
		/* 820AEE98h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820AEE98h case    0:*/		return 0x820AEE9C;
		  /* 820AEE9Ch */ case    1:  		/* lwz R4, <#[R25 + 8]> */
		/* 820AEE9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000008) );
		/* 820AEE9Ch case    1:*/		return 0x820AEEA0;
		  /* 820AEEA0h */ case    2:  		/* lis R9, -32255 */
		/* 820AEEA0h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820AEEA0h case    2:*/		return 0x820AEEA4;
		  /* 820AEEA4h */ case    3:  		/* lfd FR30, <#[R26 + 176]> */
		/* 820AEEA4h case    3:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R26 + 0x000000B0) );
		/* 820AEEA4h case    3:*/		return 0x820AEEA8;
		  /* 820AEEA8h */ case    4:  		/* lis R8, -32256 */
		/* 820AEEA8h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 820AEEA8h case    4:*/		return 0x820AEEAC;
		  /* 820AEEACh */ case    5:  		/* lfd FR31, <#[R26 + 168]> */
		/* 820AEEACh case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R26 + 0x000000A8) );
		/* 820AEEACh case    5:*/		return 0x820AEEB0;
		  /* 820AEEB0h */ case    6:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AEEB0h case    6:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEEB0h case    6:*/		return 0x820AEEB4;
		  /* 820AEEB4h */ case    7:  		/* cmpwi CR6, R4, -1 */
		/* 820AEEB4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 820AEEB4h case    7:*/		return 0x820AEEB8;
		  /* 820AEEB8h */ case    8:  		/* stfd FR31, <#[R1 + 104]> */
		/* 820AEEB8h case    8:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEEB8h case    8:*/		return 0x820AEEBC;
		  /* 820AEEBCh */ case    9:  		/* lfd FR27, <#[R10 + 1808]> */
		/* 820AEEBCh case    9:*/		cpu::mem::load64f( regs, &regs.FR27, (uint32)(regs.R10 + 0x00000710) );
		/* 820AEEBCh case    9:*/		return 0x820AEEC0;
		  /* 820AEEC0h */ case   10:  		/* lfd FR25, <#[R9 - 24488]> */
		/* 820AEEC0h case   10:*/		cpu::mem::load64f( regs, &regs.FR25, (uint32)(regs.R9 + 0xFFFFA058) );
		/* 820AEEC0h case   10:*/		return 0x820AEEC4;
		  /* 820AEEC4h */ case   11:  		/* lfd FR26, <#[R8 + 1848]> */
		/* 820AEEC4h case   11:*/		cpu::mem::load64f( regs, &regs.FR26, (uint32)(regs.R8 + 0x00000738) );
		/* 820AEEC4h case   11:*/		return 0x820AEEC8;
		  /* 820AEEC8h */ case   12:  		/* bc 12, CR6_EQ, 188 */
		/* 820AEEC8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820AEF84;  }
		/* 820AEEC8h case   12:*/		return 0x820AEECC;
		  /* 820AEECCh */ case   13:  		/* addi R5, R1, 80 */
		/* 820AEECCh case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820AEECCh case   13:*/		return 0x820AEED0;
		  /* 820AEED0h */ case   14:  		/* mr R3, R26 */
		/* 820AEED0h case   14:*/		regs.R3 = regs.R26;
		/* 820AEED0h case   14:*/		return 0x820AEED4;
		  /* 820AEED4h */ case   15:  		/* bl -380 */
		/* 820AEED4h case   15:*/		regs.LR = 0x820AEED8; return 0x820AED58;
		/* 820AEED4h case   15:*/		return 0x820AEED8;
		  /* 820AEED8h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820AEED8h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AEED8h case   16:*/		return 0x820AEEDC;
		  /* 820AEEDCh */ case   17:  		/* bc 12, CR0_LT, 2744 */
		/* 820AEEDCh case   17:*/		if ( regs.CR[0].lt ) { return 0x820AF994;  }
		/* 820AEEDCh case   17:*/		return 0x820AEEE0;
		  /* 820AEEE0h */ case   18:  		/* lwz R11, <#[R26 + 8]> */
		/* 820AEEE0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820AEEE0h case   18:*/		return 0x820AEEE4;
		  /* 820AEEE4h */ case   19:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820AEEE4h case   19:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AEEE4h case   19:*/		return 0x820AEEE8;
		  /* 820AEEE8h */ case   20:  		/* lwz R9, <#[R25 + 12]> */
		/* 820AEEE8h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x0000000C) );
		/* 820AEEE8h case   20:*/		return 0x820AEEEC;
		  /* 820AEEECh */ case   21:  		/* fctidz FR0, FR0 */
		/* 820AEEECh case   21:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 820AEEECh case   21:*/		return 0x820AEEF0;
		  /* 820AEEF0h */ case   22:  		/* stfd FR0, <#[R1 + 80]> */
		/* 820AEEF0h case   22:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AEEF0h case   22:*/		return 0x820AEEF4;
		  /* 820AEEF4h */ case   23:  		/* lwz R10, <#[R1 + 84]> */
		/* 820AEEF4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820AEEF4h case   23:*/		return 0x820AEEF8;
		  /* 820AEEF8h */ case   24:  		/* li R4, 0 */
		/* 820AEEF8h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820AEEF8h case   24:*/		return 0x820AEEFC;
		  /* 820AEEFCh */ case   25:  		/* add R6, R9, R10 */
		/* 820AEEFCh case   25:*/		cpu::op::add<0>(regs,&regs.R6,regs.R9,regs.R10);
		/* 820AEEFCh case   25:*/		return 0x820AEF00;
		  /* 820AEF00h */ case   26:  		/* lwz R8, <#[R11 + 8]> */
		/* 820AEF00h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 820AEF00h case   26:*/		return 0x820AEF04;
		  /* 820AEF04h */ case   27:  		/* cmplwi CR6, R8, 0 */
		/* 820AEF04h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AEF04h case   27:*/		return 0x820AEF08;
		  /* 820AEF08h */ case   28:  		/* bc 12, CR6_EQ, 2700 */
		/* 820AEF08h case   28:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AEF08h case   28:*/		return 0x820AEF0C;
		  /* 820AEF0Ch */ case   29:  		/* lwz R9, <#[R11 + 20]> */
		/* 820AEF0Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820AEF0Ch case   29:*/		return 0x820AEF10;
		  /* 820AEF10h */ case   30:  		/* li R10, 0 */
		/* 820AEF10h case   30:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820AEF10h case   30:*/		return 0x820AEF14;
		  /* 820AEF14h */ case   31:  		/* lwz R7, <#[R25 + 4]> */
		/* 820AEF14h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000004) );
		/* 820AEF14h case   31:*/		return 0x820AEF18;
		  /* 820AEF18h */ case   32:  		/* lwzx R11, <#[R9 + R10]> */
		/* 820AEF18h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820AEF18h case   32:*/		return 0x820AEF1C;
		  /* 820AEF1Ch */ case   33:  		/* lwz R5, <#[R11 + 4]> */
		/* 820AEF1Ch case   33:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 820AEF1Ch case   33:*/		return 0x820AEF20;
		  /* 820AEF20h */ case   34:  		/* cmplw CR6, R5, R7 */
		/* 820AEF20h case   34:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R7);
		/* 820AEF20h case   34:*/		return 0x820AEF24;
		  /* 820AEF24h */ case   35:  		/* bc 4, CR6_EQ, 44 */
		/* 820AEF24h case   35:*/		if ( !regs.CR[6].eq ) { return 0x820AEF50;  }
		/* 820AEF24h case   35:*/		return 0x820AEF28;
		  /* 820AEF28h */ case   36:  		/* lwz R5, <#[R11 + 8]> */
		/* 820AEF28h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 820AEF28h case   36:*/		return 0x820AEF2C;
		  /* 820AEF2Ch */ case   37:  		/* cmpwi CR6, R5, -1 */
		/* 820AEF2Ch case   37:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 820AEF2Ch case   37:*/		return 0x820AEF30;
		  /* 820AEF30h */ case   38:  		/* bc 4, CR6_EQ, 32 */
		/* 820AEF30h case   38:*/		if ( !regs.CR[6].eq ) { return 0x820AEF50;  }
		/* 820AEF30h case   38:*/		return 0x820AEF34;
		  /* 820AEF34h */ case   39:  		/* lwz R5, <#[R11 + 12]> */
		/* 820AEF34h case   39:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 820AEF34h case   39:*/		return 0x820AEF38;
		  /* 820AEF38h */ case   40:  		/* cmplw CR6, R5, R6 */
		/* 820AEF38h case   40:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 820AEF38h case   40:*/		return 0x820AEF3C;
		  /* 820AEF3Ch */ case   41:  		/* bc 4, CR6_EQ, 20 */
		/* 820AEF3Ch case   41:*/		if ( !regs.CR[6].eq ) { return 0x820AEF50;  }
		/* 820AEF3Ch case   41:*/		return 0x820AEF40;
		  /* 820AEF40h */ case   42:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AEF40h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AEF40h case   42:*/		return 0x820AEF44;
		  /* 820AEF44h */ case   43:  		/* lwz R5, <#[R25 + 16]> */
		/* 820AEF44h case   43:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x00000010) );
		/* 820AEF44h case   43:*/		return 0x820AEF48;
		  /* 820AEF48h */ case   44:  		/* cmplw CR6, R11, R5 */
		/* 820AEF48h case   44:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820AEF48h case   44:*/		return 0x820AEF4C;
		  /* 820AEF4Ch */ case   45:  		/* bc 12, CR6_EQ, 24 */
		/* 820AEF4Ch case   45:*/		if ( regs.CR[6].eq ) { return 0x820AEF64;  }
		/* 820AEF4Ch case   45:*/		return 0x820AEF50;
	}
	return 0x820AEF50;
} // Block from 820AEE98h-820AEF50h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820AEF50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEF50);
		  /* 820AEF50h */ case    0:  		/* addi R4, R4, 1 */
		/* 820AEF50h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820AEF50h case    0:*/		return 0x820AEF54;
		  /* 820AEF54h */ case    1:  		/* addi R10, R10, 4 */
		/* 820AEF54h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820AEF54h case    1:*/		return 0x820AEF58;
		  /* 820AEF58h */ case    2:  		/* cmplw CR6, R4, R8 */
		/* 820AEF58h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 820AEF58h case    2:*/		return 0x820AEF5C;
		  /* 820AEF5Ch */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 820AEF5Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820AEF18;  }
		/* 820AEF5Ch case    3:*/		return 0x820AEF60;
		  /* 820AEF60h */ case    4:  		/* b 2612 */
		/* 820AEF60h case    4:*/		return 0x820AF994;
		/* 820AEF60h case    4:*/		return 0x820AEF64;
	}
	return 0x820AEF64;
} // Block from 820AEF50h-820AEF64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AEF64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEF64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEF64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEF64);
		  /* 820AEF64h */ case    0:  		/* addi R5, R1, 96 */
		/* 820AEF64h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 820AEF64h case    0:*/		return 0x820AEF68;
		  /* 820AEF68h */ case    1:  		/* mr R3, R26 */
		/* 820AEF68h case    1:*/		regs.R3 = regs.R26;
		/* 820AEF68h case    1:*/		return 0x820AEF6C;
		  /* 820AEF6Ch */ case    2:  		/* bl -1140 */
		/* 820AEF6Ch case    2:*/		regs.LR = 0x820AEF70; return 0x820AEAF8;
		/* 820AEF6Ch case    2:*/		return 0x820AEF70;
		  /* 820AEF70h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820AEF70h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AEF70h case    3:*/		return 0x820AEF74;
		  /* 820AEF74h */ case    4:  		/* bc 12, CR0_LT, 2488 */
		/* 820AEF74h case    4:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AEF74h case    4:*/		return 0x820AEF78;
		  /* 820AEF78h */ case    5:  		/* lfd FR31, <#[R1 + 104]> */
		/* 820AEF78h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 820AEF78h case    5:*/		return 0x820AEF7C;
		  /* 820AEF7Ch */ case    6:  		/* lfd FR30, <#[R1 + 96]> */
		/* 820AEF7Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AEF7Ch case    6:*/		return 0x820AEF80;
		  /* 820AEF80h */ case    7:  		/* b 2580 */
		/* 820AEF80h case    7:*/		return 0x820AF994;
		/* 820AEF80h case    7:*/		return 0x820AEF84;
	}
	return 0x820AEF84;
} // Block from 820AEF64h-820AEF84h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AEF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEF84);
		  /* 820AEF84h */ case    0:  		/* lwz R10, <#[R25 + 4]> */
		/* 820AEF84h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820AEF84h case    0:*/		return 0x820AEF88;
		  /* 820AEF88h */ case    1:  		/* lwz R9, <#[R11 + 16]> */
		/* 820AEF88h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 820AEF88h case    1:*/		return 0x820AEF8C;
		  /* 820AEF8Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AEF8Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AEF8Ch case    2:*/		return 0x820AEF90;
		  /* 820AEF90h */ case    3:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820AEF90h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820AEF90h case    3:*/		return 0x820AEF94;
		  /* 820AEF94h */ case    4:  		/* lwz R10, <#[R10 + 4]> */
		/* 820AEF94h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820AEF94h case    4:*/		return 0x820AEF98;
		  /* 820AEF98h */ case    5:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820AEF98h case    5:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820AEF98h case    5:*/		return 0x820AEF9C;
		  /* 820AEF9Ch */ case    6:  		/* bc 12, CR0_EQ, 2552 */
		/* 820AEF9Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820AF994;  }
		/* 820AEF9Ch case    6:*/		return 0x820AEFA0;
	}
	return 0x820AEFA0;
} // Block from 820AEF84h-820AEFA0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AEFA0h
// Function '??0C30SWProgramCI@D3DXShader@@QAA@HHPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEFA0);
		  /* 820AEFA0h */ case    0:  		/* lwz R10, <#[R25 + 72]> */
		/* 820AEFA0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000048) );
		/* 820AEFA0h case    0:*/		return 0x820AEFA4;
		  /* 820AEFA4h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 820AEFA4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820AEFA4h case    1:*/		return 0x820AEFA8;
		  /* 820AEFA8h */ case    2:  		/* bc 12, CR6_EQ, 2540 */
		/* 820AEFA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AEFA8h case    2:*/		return 0x820AEFAC;
		  /* 820AEFACh */ case    3:  		/* lwz R11, <#[R11 + 24]> */
		/* 820AEFACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820AEFACh case    3:*/		return 0x820AEFB0;
		  /* 820AEFB0h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AEFB0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AEFB0h case    4:*/		return 0x820AEFB4;
		  /* 820AEFB4h */ case    5:  		/* lis R29, 4096 */
		/* 820AEFB4h case    5:*/		cpu::op::lis<0>(regs,&regs.R29,0x1000);
		/* 820AEFB4h case    5:*/		return 0x820AEFB8;
		  /* 820AEFB8h */ case    6:  		/* lwz R30, <#[R25 + 16]> */
		/* 820AEFB8h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000010) );
		/* 820AEFB8h case    6:*/		return 0x820AEFBC;
		  /* 820AEFBCh */ case    7:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820AEFBCh case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820AEFBCh case    7:*/		return 0x820AEFC0;
		  /* 820AEFC0h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 820AEFC0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AEFC0h case    8:*/		return 0x820AEFC4;
		  /* 820AEFC4h */ case    9:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 820AEFC4h case    9:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 820AEFC4h case    9:*/		return 0x820AEFC8;
		  /* 820AEFC8h */ case   10:  		/* cmplw CR6, R10, R29 */
		/* 820AEFC8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 820AEFC8h case   10:*/		return 0x820AEFCC;
		  /* 820AEFCCh */ case   11:  		/* bc 4, CR6_EQ, 1032 */
		/* 820AEFCCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x820AF3D4;  }
		/* 820AEFCCh case   11:*/		return 0x820AEFD0;
		  /* 820AEFD0h */ case   12:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820AEFD0h case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820AEFD0h case   12:*/		return 0x820AEFD4;
		  /* 820AEFD4h */ case   13:  		/* lis R10, 4336 */
		/* 820AEFD4h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x10F0);
		/* 820AEFD4h case   13:*/		return 0x820AEFD8;
		  /* 820AEFD8h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820AEFD8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AEFD8h case   14:*/		return 0x820AEFDC;
		  /* 820AEFDCh */ case   15:  		/* bc 12, CR6_EQ, 2488 */
		/* 820AEFDCh case   15:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AEFDCh case   15:*/		return 0x820AEFE0;
	}
	return 0x820AEFE0;
} // Block from 820AEFA0h-820AEFE0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820AEFE0h
// Function '?EmitDSY@C30SWProgram@D3DXShader@@MAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEFE0);
		  /* 820AEFE0h */ case    0:  		/* lis R10, 4352 */
		/* 820AEFE0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1100);
		/* 820AEFE0h case    0:*/		return 0x820AEFE4;
		  /* 820AEFE4h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820AEFE4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AEFE4h case    1:*/		return 0x820AEFE8;
		  /* 820AEFE8h */ case    2:  		/* bc 12, CR6_EQ, 2476 */
		/* 820AEFE8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AEFE8h case    2:*/		return 0x820AEFEC;
		  /* 820AEFECh */ case    3:  		/* lis R10, 4368 */
		/* 820AEFECh case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x1110);
		/* 820AEFECh case    3:*/		return 0x820AEFF0;
	}
	return 0x820AEFF0;
} // Block from 820AEFE0h-820AEFF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AEFF0h
// Function '??0C30SWProgramML@D3DXShader@@QAA@HHPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AEFF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AEFF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AEFF0);
		  /* 820AEFF0h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820AEFF0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AEFF0h case    0:*/		return 0x820AEFF4;
		  /* 820AEFF4h */ case    1:  		/* bc 12, CR6_EQ, 2464 */
		/* 820AEFF4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AEFF4h case    1:*/		return 0x820AEFF8;
		  /* 820AEFF8h */ case    2:  		/* lis R10, 4384 */
		/* 820AEFF8h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x1120);
		/* 820AEFF8h case    2:*/		return 0x820AEFFC;
		  /* 820AEFFCh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820AEFFCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AEFFCh case    3:*/		return 0x820AF000;
		  /* 820AF000h */ case    4:  		/* bc 12, CR6_EQ, 2452 */
		/* 820AF000h case    4:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF000h case    4:*/		return 0x820AF004;
		  /* 820AF004h */ case    5:  		/* lis R10, 4400 */
		/* 820AF004h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x1130);
		/* 820AF004h case    5:*/		return 0x820AF008;
		  /* 820AF008h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820AF008h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF008h case    6:*/		return 0x820AF00C;
		  /* 820AF00Ch */ case    7:  		/* bc 12, CR6_EQ, 2440 */
		/* 820AF00Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF00Ch case    7:*/		return 0x820AF010;
		  /* 820AF010h */ case    8:  		/* lis R10, 4416 */
		/* 820AF010h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x1140);
		/* 820AF010h case    8:*/		return 0x820AF014;
		  /* 820AF014h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820AF014h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF014h case    9:*/		return 0x820AF018;
		  /* 820AF018h */ case   10:  		/* bc 12, CR6_EQ, 2428 */
		/* 820AF018h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF018h case   10:*/		return 0x820AF01C;
		  /* 820AF01Ch */ case   11:  		/* lis R10, 4432 */
		/* 820AF01Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x1150);
		/* 820AF01Ch case   11:*/		return 0x820AF020;
		  /* 820AF020h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 820AF020h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF020h case   12:*/		return 0x820AF024;
		  /* 820AF024h */ case   13:  		/* bc 12, CR6_EQ, 2416 */
		/* 820AF024h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF024h case   13:*/		return 0x820AF028;
		  /* 820AF028h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF028h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF028h case   14:*/		return 0x820AF02C;
		  /* 820AF02Ch */ case   15:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820AF02Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820AF02Ch case   15:*/		return 0x820AF030;
	}
	return 0x820AF030;
} // Block from 820AEFF0h-820AF030h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820AF030h
// Function '??0CCompiler@D3DXShader@@QAA@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF030);
		  /* 820AF030h */ case    0:  		/* addi R5, R1, 80 */
		/* 820AF030h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820AF030h case    0:*/		return 0x820AF034;
		  /* 820AF034h */ case    1:  		/* mr R3, R26 */
		/* 820AF034h case    1:*/		regs.R3 = regs.R26;
		/* 820AF034h case    1:*/		return 0x820AF038;
		  /* 820AF038h */ case    2:  		/* lwzx R4, <#[R10 + R11]> */
		/* 820AF038h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820AF038h case    2:*/		return 0x820AF03C;
		  /* 820AF03Ch */ case    3:  		/* bl -1348 */
		/* 820AF03Ch case    3:*/		regs.LR = 0x820AF040; return 0x820AEAF8;
		/* 820AF03Ch case    3:*/		return 0x820AF040;
		  /* 820AF040h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820AF040h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF040h case    4:*/		return 0x820AF044;
		  /* 820AF044h */ case    5:  		/* bc 12, CR0_LT, 2280 */
		/* 820AF044h case    5:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF044h case    5:*/		return 0x820AF048;
		  /* 820AF048h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820AF048h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AF048h case    6:*/		return 0x820AF04C;
		  /* 820AF04Ch */ case    7:  		/* lis R10, 4208 */
		/* 820AF04Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x1070);
		/* 820AF04Ch case    7:*/		return 0x820AF050;
		  /* 820AF050h */ case    8:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820AF050h case    8:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820AF050h case    8:*/		return 0x820AF054;
		  /* 820AF054h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820AF054h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF054h case    9:*/		return 0x820AF058;
		  /* 820AF058h */ case   10:  		/* bc 12, CR6_GT, 500 */
		/* 820AF058h case   10:*/		if ( regs.CR[6].gt ) { return 0x820AF24C;  }
		/* 820AF058h case   10:*/		return 0x820AF05C;
		  /* 820AF05Ch */ case   11:  		/* bc 12, CR6_EQ, 460 */
		/* 820AF05Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820AF228;  }
		/* 820AF05Ch case   11:*/		return 0x820AF060;
		  /* 820AF060h */ case   12:  		/* cmplw CR6, R11, R29 */
		/* 820AF060h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820AF060h case   12:*/		return 0x820AF064;
		  /* 820AF064h */ case   13:  		/* bc 12, CR6_EQ, 440 */
		/* 820AF064h case   13:*/		if ( regs.CR[6].eq ) { return 0x820AF21C;  }
		/* 820AF064h case   13:*/		return 0x820AF068;
		  /* 820AF068h */ case   14:  		/* lis R10, 4112 */
		/* 820AF068h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x1010);
		/* 820AF068h case   14:*/		return 0x820AF06C;
		  /* 820AF06Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820AF06Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF06Ch case   15:*/		return 0x820AF070;
		  /* 820AF070h */ case   16:  		/* bc 12, CR6_EQ, 408 */
		/* 820AF070h case   16:*/		if ( regs.CR[6].eq ) { return 0x820AF208;  }
		/* 820AF070h case   16:*/		return 0x820AF074;
		  /* 820AF074h */ case   17:  		/* lis R10, 4128 */
		/* 820AF074h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x1020);
		/* 820AF074h case   17:*/		return 0x820AF078;
		  /* 820AF078h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 820AF078h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF078h case   18:*/		return 0x820AF07C;
		  /* 820AF07Ch */ case   19:  		/* bc 12, CR6_EQ, 292 */
		/* 820AF07Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x820AF1A0;  }
		/* 820AF07Ch case   19:*/		return 0x820AF080;
		  /* 820AF080h */ case   20:  		/* lis R10, 4144 */
		/* 820AF080h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0x1030);
		/* 820AF080h case   20:*/		return 0x820AF084;
		  /* 820AF084h */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 820AF084h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF084h case   21:*/		return 0x820AF088;
		  /* 820AF088h */ case   22:  		/* bc 12, CR6_EQ, 244 */
		/* 820AF088h case   22:*/		if ( regs.CR[6].eq ) { return 0x820AF17C;  }
		/* 820AF088h case   22:*/		return 0x820AF08C;
		  /* 820AF08Ch */ case   23:  		/* lis R10, 4160 */
		/* 820AF08Ch case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0x1040);
		/* 820AF08Ch case   23:*/		return 0x820AF090;
		  /* 820AF090h */ case   24:  		/* cmplw CR6, R11, R10 */
		/* 820AF090h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF090h case   24:*/		return 0x820AF094;
		  /* 820AF094h */ case   25:  		/* bc 12, CR6_EQ, 172 */
		/* 820AF094h case   25:*/		if ( regs.CR[6].eq ) { return 0x820AF140;  }
		/* 820AF094h case   25:*/		return 0x820AF098;
		  /* 820AF098h */ case   26:  		/* lis R10, 4176 */
		/* 820AF098h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x1050);
		/* 820AF098h case   26:*/		return 0x820AF09C;
		  /* 820AF09Ch */ case   27:  		/* cmplw CR6, R11, R10 */
		/* 820AF09Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF09Ch case   27:*/		return 0x820AF0A0;
		  /* 820AF0A0h */ case   28:  		/* bc 12, CR6_EQ, 112 */
		/* 820AF0A0h case   28:*/		if ( regs.CR[6].eq ) { return 0x820AF110;  }
		/* 820AF0A0h case   28:*/		return 0x820AF0A4;
		  /* 820AF0A4h */ case   29:  		/* lis R10, 4192 */
		/* 820AF0A4h case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0x1060);
		/* 820AF0A4h case   29:*/		return 0x820AF0A8;
		  /* 820AF0A8h */ case   30:  		/* cmplw CR6, R11, R10 */
		/* 820AF0A8h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF0A8h case   30:*/		return 0x820AF0AC;
		  /* 820AF0ACh */ case   31:  		/* bc 4, CR6_EQ, 2280 */
		/* 820AF0ACh case   31:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF0ACh case   31:*/		return 0x820AF0B0;
	}
	return 0x820AF0B0;
} // Block from 820AF030h-820AF0B0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820AF0B0h
// Function '?LookForA0Callback@D3DXShader@@YAJKKPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF0B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF0B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF0B0);
		  /* 820AF0B0h */ case    0:  		/* lis R11, -32255 */
		/* 820AF0B0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AF0B0h case    0:*/		return 0x820AF0B4;
		  /* 820AF0B4h */ case    1:  		/* lfd FR1, <#[R1 + 80]> */
		/* 820AF0B4h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF0B4h case    1:*/		return 0x820AF0B8;
		  /* 820AF0B8h */ case    2:  		/* fcmpu CR6, FR1, FR27 */
		/* 820AF0B8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR27);
		/* 820AF0B8h case    2:*/		return 0x820AF0BC;
		  /* 820AF0BCh */ case    3:  		/* lfd FR31, <#[R11 - 24504]> */
		/* 820AF0BCh case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 820AF0BCh case    3:*/		return 0x820AF0C0;
		  /* 820AF0C0h */ case    4:  		/* bc 4, CR6_GT, 28 */
		/* 820AF0C0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820AF0DC;  }
		/* 820AF0C0h case    4:*/		return 0x820AF0C4;
		  /* 820AF0C4h */ case    5:  		/* bl -94956 */
		/* 820AF0C4h case    5:*/		regs.LR = 0x820AF0C8; return 0x82097DD8;
		/* 820AF0C4h case    5:*/		return 0x820AF0C8;
		  /* 820AF0C8h */ case    6:  		/* fmr FR30, FR1 */
		/* 820AF0C8h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 820AF0C8h case    6:*/		return 0x820AF0CC;
		  /* 820AF0CCh */ case    7:  		/* fmr FR1, FR31 */
		/* 820AF0CCh case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF0CCh case    7:*/		return 0x820AF0D0;
		  /* 820AF0D0h */ case    8:  		/* bl -94968 */
		/* 820AF0D0h case    8:*/		regs.LR = 0x820AF0D4; return 0x82097DD8;
		/* 820AF0D0h case    8:*/		return 0x820AF0D4;
		  /* 820AF0D4h */ case    9:  		/* fdiv FR30, FR30, FR1 */
		/* 820AF0D4h case    9:*/		cpu::op::fdiv<0>(regs,&regs.FR30,regs.FR30,regs.FR1);
		/* 820AF0D4h case    9:*/		return 0x820AF0D8;
		  /* 820AF0D8h */ case   10:  		/* b 8 */
		/* 820AF0D8h case   10:*/		return 0x820AF0E0;
		/* 820AF0D8h case   10:*/		return 0x820AF0DC;
	}
	return 0x820AF0DC;
} // Block from 820AF0B0h-820AF0DCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AF0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF0DC);
		  /* 820AF0DCh */ case    0:  		/* lfd FR30, <#[R26 + 176]> */
		/* 820AF0DCh case    0:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R26 + 0x000000B0) );
		/* 820AF0DCh case    0:*/		return 0x820AF0E0;
	}
	return 0x820AF0E0;
} // Block from 820AF0DCh-820AF0E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF0E0);
		  /* 820AF0E0h */ case    0:  		/* lfd FR1, <#[R1 + 88]> */
		/* 820AF0E0h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF0E0h case    0:*/		return 0x820AF0E4;
		  /* 820AF0E4h */ case    1:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF0E4h case    1:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF0E4h case    1:*/		return 0x820AF0E8;
		  /* 820AF0E8h */ case    2:  		/* fcmpu CR6, FR1, FR27 */
		/* 820AF0E8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR27);
		/* 820AF0E8h case    2:*/		return 0x820AF0EC;
		  /* 820AF0ECh */ case    3:  		/* bc 4, CR6_GT, 28 */
		/* 820AF0ECh case    3:*/		if ( !regs.CR[6].gt ) { return 0x820AF108;  }
		/* 820AF0ECh case    3:*/		return 0x820AF0F0;
	}
	return 0x820AF0F0;
} // Block from 820AF0E0h-820AF0F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AF0F0h
// Function '?VectorizeBase@CCompiler@D3DXShader@@IAAJW4_D3DTYPE_TEMPLATE@2@IIKPAII1PAVCNode@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF0F0);
		  /* 820AF0F0h */ case    0:  		/* bl -95000 */
		/* 820AF0F0h case    0:*/		regs.LR = 0x820AF0F4; return 0x82097DD8;
		/* 820AF0F0h case    0:*/		return 0x820AF0F4;
		  /* 820AF0F4h */ case    1:  		/* fmr FR29, FR1 */
		/* 820AF0F4h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR1);
		/* 820AF0F4h case    1:*/		return 0x820AF0F8;
		  /* 820AF0F8h */ case    2:  		/* fmr FR1, FR31 */
		/* 820AF0F8h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF0F8h case    2:*/		return 0x820AF0FC;
		  /* 820AF0FCh */ case    3:  		/* bl -95012 */
		/* 820AF0FCh case    3:*/		regs.LR = 0x820AF100; return 0x82097DD8;
		/* 820AF0FCh case    3:*/		return 0x820AF100;
		  /* 820AF100h */ case    4:  		/* fdiv FR31, FR29, FR1 */
		/* 820AF100h case    4:*/		cpu::op::fdiv<0>(regs,&regs.FR31,regs.FR29,regs.FR1);
		/* 820AF100h case    4:*/		return 0x820AF104;
		  /* 820AF104h */ case    5:  		/* b 2188 */
		/* 820AF104h case    5:*/		return 0x820AF990;
		/* 820AF104h case    5:*/		return 0x820AF108;
	}
	return 0x820AF108;
} // Block from 820AF0F0h-820AF108h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AF108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF108);
		  /* 820AF108h */ case    0:  		/* lfd FR31, <#[R26 + 176]> */
		/* 820AF108h case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R26 + 0x000000B0) );
		/* 820AF108h case    0:*/		return 0x820AF10C;
		  /* 820AF10Ch */ case    1:  		/* b 2180 */
		/* 820AF10Ch case    1:*/		return 0x820AF990;
		/* 820AF10Ch case    1:*/		return 0x820AF110;
	}
	return 0x820AF110;
} // Block from 820AF108h-820AF110h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AF110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF110);
		  /* 820AF110h */ case    0:  		/* lis R11, -32255 */
		/* 820AF110h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AF110h case    0:*/		return 0x820AF114;
		  /* 820AF114h */ case    1:  		/* lfd FR2, <#[R1 + 80]> */
		/* 820AF114h case    1:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF114h case    1:*/		return 0x820AF118;
		  /* 820AF118h */ case    2:  		/* lfd FR31, <#[R11 - 24504]> */
		/* 820AF118h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 820AF118h case    2:*/		return 0x820AF11C;
		  /* 820AF11Ch */ case    3:  		/* fmr FR1, FR31 */
		/* 820AF11Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF11Ch case    3:*/		return 0x820AF120;
		  /* 820AF120h */ case    4:  		/* bl -117608 */
		/* 820AF120h case    4:*/		regs.LR = 0x820AF124; return 0x820925B8;
		/* 820AF120h case    4:*/		return 0x820AF124;
		  /* 820AF124h */ case    5:  		/* lfd FR2, <#[R1 + 88]> */
		/* 820AF124h case    5:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF124h case    5:*/		return 0x820AF128;
		  /* 820AF128h */ case    6:  		/* fmr FR30, FR1 */
		/* 820AF128h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 820AF128h case    6:*/		return 0x820AF12C;
		  /* 820AF12Ch */ case    7:  		/* stfd FR1, <#[R1 + 96]> */
		/* 820AF12Ch case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF12Ch case    7:*/		return 0x820AF130;
		  /* 820AF130h */ case    8:  		/* fmr FR1, FR31 */
		/* 820AF130h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF130h case    8:*/		return 0x820AF134;
		  /* 820AF134h */ case    9:  		/* bl -117628 */
		/* 820AF134h case    9:*/		regs.LR = 0x820AF138; return 0x820925B8;
		/* 820AF134h case    9:*/		return 0x820AF138;
		  /* 820AF138h */ case   10:  		/* fmr FR31, FR1 */
		/* 820AF138h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 820AF138h case   10:*/		return 0x820AF13C;
		  /* 820AF13Ch */ case   11:  		/* b 2132 */
		/* 820AF13Ch case   11:*/		return 0x820AF990;
		/* 820AF13Ch case   11:*/		return 0x820AF140;
	}
	return 0x820AF140;
} // Block from 820AF110h-820AF140h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AF140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF140);
		  /* 820AF140h */ case    0:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820AF140h case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF140h case    0:*/		return 0x820AF144;
		  /* 820AF144h */ case    1:  		/* lfd FR30, <#[R1 + 88]> */
		/* 820AF144h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF144h case    1:*/		return 0x820AF148;
		  /* 820AF148h */ case    2:  		/* fcmpu CR6, FR31, FR30 */
		/* 820AF148h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR30);
		/* 820AF148h case    2:*/		return 0x820AF14C;
		  /* 820AF14Ch */ case    3:  		/* bc 4, CR6_EQ, 40 */
		/* 820AF14Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF174;  }
		/* 820AF14Ch case    3:*/		return 0x820AF150;
		  /* 820AF150h */ case    4:  		/* fmr FR1, FR31 */
		/* 820AF150h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF150h case    4:*/		return 0x820AF154;
		  /* 820AF154h */ case    5:  		/* bl -94596 */
		/* 820AF154h case    5:*/		regs.LR = 0x820AF158; return 0x82097FD0;
		/* 820AF154h case    5:*/		return 0x820AF158;
		  /* 820AF158h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820AF158h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF158h case    6:*/		return 0x820AF15C;
		  /* 820AF15Ch */ case    7:  		/* bc 12, CR0_EQ, 352 */
		/* 820AF15Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820AF2BC;  }
		/* 820AF15Ch case    7:*/		return 0x820AF160;
		  /* 820AF160h */ case    8:  		/* fmr FR1, FR30 */
		/* 820AF160h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 820AF160h case    8:*/		return 0x820AF164;
		  /* 820AF164h */ case    9:  		/* bl -119428 */
		/* 820AF164h case    9:*/		regs.LR = 0x820AF168; return 0x82091EE0;
		/* 820AF164h case    9:*/		return 0x820AF168;
		  /* 820AF168h */ case   10:  		/* fsub FR31, FR31, FR1 */
		/* 820AF168h case   10:*/		cpu::op::fsub<0>(regs,&regs.FR31,regs.FR31,regs.FR1);
		/* 820AF168h case   10:*/		return 0x820AF16C;
		  /* 820AF16Ch */ case   11:  		/* fmr FR30, FR31 */
		/* 820AF16Ch case   11:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR31);
		/* 820AF16Ch case   11:*/		return 0x820AF170;
		  /* 820AF170h */ case   12:  		/* b 2076 */
		/* 820AF170h case   12:*/		return 0x820AF98C;
		/* 820AF170h case   12:*/		return 0x820AF174;
	}
	return 0x820AF174;
} // Block from 820AF140h-820AF174h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AF174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF174);
		  /* 820AF174h */ case    0:  		/* fmr FR30, FR27 */
		/* 820AF174h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF174h case    0:*/		return 0x820AF178;
		  /* 820AF178h */ case    1:  		/* b 2064 */
		/* 820AF178h case    1:*/		return 0x820AF988;
		/* 820AF178h case    1:*/		return 0x820AF17C;
	}
	return 0x820AF17C;
} // Block from 820AF174h-820AF17Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AF17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF17C);
		  /* 820AF17Ch */ case    0:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820AF17Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF17Ch case    0:*/		return 0x820AF180;
		  /* 820AF180h */ case    1:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF180h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF180h case    1:*/		return 0x820AF184;
		  /* 820AF184h */ case    2:  		/* fcmpu CR6, FR13, FR27 */
		/* 820AF184h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR27);
		/* 820AF184h case    2:*/		return 0x820AF188;
		  /* 820AF188h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 820AF188h case    3:*/		if ( regs.CR[6].gt ) { return 0x820AF194;  }
		/* 820AF188h case    3:*/		return 0x820AF18C;
		  /* 820AF18Ch */ case    4:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF18Ch case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF18Ch case    4:*/		return 0x820AF190;
		  /* 820AF190h */ case    5:  		/* bc 4, CR6_LT, 2052 */
		/* 820AF190h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820AF994;  }
		/* 820AF190h case    5:*/		return 0x820AF194;
	}
	return 0x820AF194;
} // Block from 820AF17Ch-820AF194h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AF194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF194);
		  /* 820AF194h */ case    0:  		/* fdiv FR30, FR26, FR0 */
		/* 820AF194h case    0:*/		cpu::op::fdiv<0>(regs,&regs.FR30,regs.FR26,regs.FR0);
		/* 820AF194h case    0:*/		return 0x820AF198;
		  /* 820AF198h */ case    1:  		/* fdiv FR31, FR26, FR13 */
		/* 820AF198h case    1:*/		cpu::op::fdiv<0>(regs,&regs.FR31,regs.FR26,regs.FR13);
		/* 820AF198h case    1:*/		return 0x820AF19C;
		  /* 820AF19Ch */ case    2:  		/* b 2032 */
		/* 820AF19Ch case    2:*/		return 0x820AF98C;
		/* 820AF19Ch case    2:*/		return 0x820AF1A0;
	}
	return 0x820AF1A0;
} // Block from 820AF194h-820AF1A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AF1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF1A0);
		  /* 820AF1A0h */ case    0:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820AF1A0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF1A0h case    0:*/		return 0x820AF1A4;
		  /* 820AF1A4h */ case    1:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF1A4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF1A4h case    1:*/		return 0x820AF1A8;
		  /* 820AF1A8h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 820AF1A8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820AF1B8;  }
		/* 820AF1A8h case    2:*/		return 0x820AF1AC;
		  /* 820AF1ACh */ case    3:  		/* lfd FR13, <#[R26 + 184]> */
		/* 820AF1ACh case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + 0x000000B8) );
		/* 820AF1ACh case    3:*/		return 0x820AF1B0;
		  /* 820AF1B0h */ case    4:  		/* fsub FR30, FR0, FR13 */
		/* 820AF1B0h case    4:*/		cpu::op::fsub<0>(regs,&regs.FR30,regs.FR0,regs.FR13);
		/* 820AF1B0h case    4:*/		return 0x820AF1B4;
		  /* 820AF1B4h */ case    5:  		/* b 28 */
		/* 820AF1B4h case    5:*/		return 0x820AF1D0;
		/* 820AF1B4h case    5:*/		return 0x820AF1B8;
	}
	return 0x820AF1B8;
} // Block from 820AF1A0h-820AF1B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AF1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF1B8);
		  /* 820AF1B8h */ case    0:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF1B8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF1B8h case    0:*/		return 0x820AF1BC;
		  /* 820AF1BCh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820AF1BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AF1C8;  }
		/* 820AF1BCh case    1:*/		return 0x820AF1C0;
		  /* 820AF1C0h */ case    2:  		/* fmr FR30, FR27 */
		/* 820AF1C0h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF1C0h case    2:*/		return 0x820AF1C4;
		  /* 820AF1C4h */ case    3:  		/* b 12 */
		/* 820AF1C4h case    3:*/		return 0x820AF1D0;
		/* 820AF1C4h case    3:*/		return 0x820AF1C8;
	}
	return 0x820AF1C8;
} // Block from 820AF1B8h-820AF1C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AF1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF1C8);
		  /* 820AF1C8h */ case    0:  		/* lfd FR13, <#[R26 + 184]> */
		/* 820AF1C8h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + 0x000000B8) );
		/* 820AF1C8h case    0:*/		return 0x820AF1CC;
		  /* 820AF1CCh */ case    1:  		/* fadd FR30, FR13, FR0 */
		/* 820AF1CCh case    1:*/		cpu::op::fadd<0>(regs,&regs.FR30,regs.FR13,regs.FR0);
		/* 820AF1CCh case    1:*/		return 0x820AF1D0;
	}
	return 0x820AF1D0;
} // Block from 820AF1C8h-820AF1D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AF1D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF1D0);
		  /* 820AF1D0h */ case    0:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF1D0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF1D0h case    0:*/		return 0x820AF1D4;
		  /* 820AF1D4h */ case    1:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF1D4h case    1:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF1D4h case    1:*/		return 0x820AF1D8;
		  /* 820AF1D8h */ case    2:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF1D8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF1D8h case    2:*/		return 0x820AF1DC;
		  /* 820AF1DCh */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 820AF1DCh case    3:*/		if ( !regs.CR[6].lt ) { return 0x820AF1EC;  }
		/* 820AF1DCh case    3:*/		return 0x820AF1E0;
		  /* 820AF1E0h */ case    4:  		/* lfd FR13, <#[R26 + 184]> */
		/* 820AF1E0h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + 0x000000B8) );
		/* 820AF1E0h case    4:*/		return 0x820AF1E4;
		  /* 820AF1E4h */ case    5:  		/* fsub FR31, FR0, FR13 */
		/* 820AF1E4h case    5:*/		cpu::op::fsub<0>(regs,&regs.FR31,regs.FR0,regs.FR13);
		/* 820AF1E4h case    5:*/		return 0x820AF1E8;
		  /* 820AF1E8h */ case    6:  		/* b 1960 */
		/* 820AF1E8h case    6:*/		return 0x820AF990;
		/* 820AF1E8h case    6:*/		return 0x820AF1EC;
	}
	return 0x820AF1EC;
} // Block from 820AF1D0h-820AF1ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AF1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF1EC);
		  /* 820AF1ECh */ case    0:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF1ECh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF1ECh case    0:*/		return 0x820AF1F0;
		  /* 820AF1F0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820AF1F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AF1FC;  }
		/* 820AF1F0h case    1:*/		return 0x820AF1F4;
		  /* 820AF1F4h */ case    2:  		/* fmr FR31, FR27 */
		/* 820AF1F4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR27);
		/* 820AF1F4h case    2:*/		return 0x820AF1F8;
		  /* 820AF1F8h */ case    3:  		/* b 1944 */
		/* 820AF1F8h case    3:*/		return 0x820AF990;
		/* 820AF1F8h case    3:*/		return 0x820AF1FC;
	}
	return 0x820AF1FC;
} // Block from 820AF1ECh-820AF1FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AF1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF1FC);
		  /* 820AF1FCh */ case    0:  		/* lfd FR13, <#[R26 + 184]> */
		/* 820AF1FCh case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + 0x000000B8) );
		/* 820AF1FCh case    0:*/		return 0x820AF200;
		  /* 820AF200h */ case    1:  		/* fadd FR31, FR13, FR0 */
		/* 820AF200h case    1:*/		cpu::op::fadd<0>(regs,&regs.FR31,regs.FR13,regs.FR0);
		/* 820AF200h case    1:*/		return 0x820AF204;
		  /* 820AF204h */ case    2:  		/* b 1932 */
		/* 820AF204h case    2:*/		return 0x820AF990;
		/* 820AF204h case    2:*/		return 0x820AF208;
	}
	return 0x820AF208;
} // Block from 820AF1FCh-820AF208h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AF208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF208);
		  /* 820AF208h */ case    0:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF208h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF208h case    0:*/		return 0x820AF20C;
		  /* 820AF20Ch */ case    1:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820AF20Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF20Ch case    1:*/		return 0x820AF210;
		  /* 820AF210h */ case    2:  		/* fneg FR30, FR0 */
		/* 820AF210h case    2:*/		cpu::op::fneg<0>(regs,&regs.FR30,regs.FR0);
		/* 820AF210h case    2:*/		return 0x820AF214;
		  /* 820AF214h */ case    3:  		/* fneg FR31, FR13 */
		/* 820AF214h case    3:*/		cpu::op::fneg<0>(regs,&regs.FR31,regs.FR13);
		/* 820AF214h case    3:*/		return 0x820AF218;
		  /* 820AF218h */ case    4:  		/* b 1908 */
		/* 820AF218h case    4:*/		return 0x820AF98C;
		/* 820AF218h case    4:*/		return 0x820AF21C;
	}
	return 0x820AF21C;
} // Block from 820AF208h-820AF21Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF21C);
		  /* 820AF21Ch */ case    0:  		/* lfd FR30, <#[R1 + 80]> */
		/* 820AF21Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF21Ch case    0:*/		return 0x820AF220;
		  /* 820AF220h */ case    1:  		/* lfd FR31, <#[R1 + 88]> */
		/* 820AF220h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF220h case    1:*/		return 0x820AF224;
		  /* 820AF224h */ case    2:  		/* b 1896 */
		/* 820AF224h case    2:*/		return 0x820AF98C;
		/* 820AF224h case    2:*/		return 0x820AF228;
	}
	return 0x820AF228;
} // Block from 820AF21Ch-820AF228h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AF228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF228);
		  /* 820AF228h */ case    0:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820AF228h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF228h case    0:*/		return 0x820AF22C;
		  /* 820AF22Ch */ case    1:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF22Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF22Ch case    1:*/		return 0x820AF230;
		  /* 820AF230h */ case    2:  		/* bc 12, CR6_LT, 1892 */
		/* 820AF230h case    2:*/		if ( regs.CR[6].lt ) { return 0x820AF994;  }
		/* 820AF230h case    2:*/		return 0x820AF234;
		  /* 820AF234h */ case    3:  		/* lfd FR13, <#[R1 + 88]> */
		/* 820AF234h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF234h case    3:*/		return 0x820AF238;
		  /* 820AF238h */ case    4:  		/* fsqrt FR0, FR0 */
		/* 820AF238h case    4:*/		cpu::op::fsqrt<0>(regs,&regs.FR0,regs.FR0);
		/* 820AF238h case    4:*/		return 0x820AF23C;
		  /* 820AF23Ch */ case    5:  		/* fsqrt FR13, FR13 */
		/* 820AF23Ch case    5:*/		cpu::op::fsqrt<0>(regs,&regs.FR13,regs.FR13);
		/* 820AF23Ch case    5:*/		return 0x820AF240;
		  /* 820AF240h */ case    6:  		/* fdiv FR30, FR26, FR13 */
		/* 820AF240h case    6:*/		cpu::op::fdiv<0>(regs,&regs.FR30,regs.FR26,regs.FR13);
		/* 820AF240h case    6:*/		return 0x820AF244;
		  /* 820AF244h */ case    7:  		/* fdiv FR31, FR26, FR0 */
		/* 820AF244h case    7:*/		cpu::op::fdiv<0>(regs,&regs.FR31,regs.FR26,regs.FR0);
		/* 820AF244h case    7:*/		return 0x820AF248;
		  /* 820AF248h */ case    8:  		/* b 1860 */
		/* 820AF248h case    8:*/		return 0x820AF98C;
		/* 820AF248h case    8:*/		return 0x820AF24C;
	}
	return 0x820AF24C;
} // Block from 820AF228h-820AF24Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AF24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF24C);
		  /* 820AF24Ch */ case    0:  		/* lis R10, 4224 */
		/* 820AF24Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1080);
		/* 820AF24Ch case    0:*/		return 0x820AF250;
		  /* 820AF250h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820AF250h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF250h case    1:*/		return 0x820AF254;
		  /* 820AF254h */ case    2:  		/* bc 12, CR6_EQ, 340 */
		/* 820AF254h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AF3A8;  }
		/* 820AF254h case    2:*/		return 0x820AF258;
		  /* 820AF258h */ case    3:  		/* lis R10, 4240 */
		/* 820AF258h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x1090);
		/* 820AF258h case    3:*/		return 0x820AF25C;
		  /* 820AF25Ch */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820AF25Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF25Ch case    4:*/		return 0x820AF260;
		  /* 820AF260h */ case    5:  		/* bc 12, CR6_EQ, 284 */
		/* 820AF260h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AF37C;  }
		/* 820AF260h case    5:*/		return 0x820AF264;
		  /* 820AF264h */ case    6:  		/* lis R10, 4256 */
		/* 820AF264h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x10A0);
		/* 820AF264h case    6:*/		return 0x820AF268;
		  /* 820AF268h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820AF268h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF268h case    7:*/		return 0x820AF26C;
		  /* 820AF26Ch */ case    8:  		/* bc 12, CR6_EQ, 224 */
		/* 820AF26Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820AF34C;  }
		/* 820AF26Ch case    8:*/		return 0x820AF270;
		  /* 820AF270h */ case    9:  		/* lis R10, 4272 */
		/* 820AF270h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x10B0);
		/* 820AF270h case    9:*/		return 0x820AF274;
		  /* 820AF274h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820AF274h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF274h case   10:*/		return 0x820AF278;
		  /* 820AF278h */ case   11:  		/* bc 12, CR6_EQ, 148 */
		/* 820AF278h case   11:*/		if ( regs.CR[6].eq ) { return 0x820AF30C;  }
		/* 820AF278h case   11:*/		return 0x820AF27C;
		  /* 820AF27Ch */ case   12:  		/* lis R10, 4288 */
		/* 820AF27Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x10C0);
		/* 820AF27Ch case   12:*/		return 0x820AF280;
		  /* 820AF280h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820AF280h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF280h case   13:*/		return 0x820AF284;
		  /* 820AF284h */ case   14:  		/* bc 12, CR6_EQ, 68 */
		/* 820AF284h case   14:*/		if ( regs.CR[6].eq ) { return 0x820AF2C8;  }
		/* 820AF284h case   14:*/		return 0x820AF288;
	}
	return 0x820AF288;
} // Block from 820AF24Ch-820AF288h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AF288h
// Function '?VectorizeDefaults@CCompiler@D3DXShader@@IAAJPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF288);
		  /* 820AF288h */ case    0:  		/* lis R10, 4304 */
		/* 820AF288h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x10D0);
		/* 820AF288h case    0:*/		return 0x820AF28C;
		  /* 820AF28Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820AF28Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF28Ch case    1:*/		return 0x820AF290;
		  /* 820AF290h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820AF290h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AF2A0;  }
		/* 820AF290h case    2:*/		return 0x820AF294;
		  /* 820AF294h */ case    3:  		/* lis R10, 4320 */
		/* 820AF294h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x10E0);
		/* 820AF294h case    3:*/		return 0x820AF298;
		  /* 820AF298h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820AF298h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF298h case    4:*/		return 0x820AF29C;
		  /* 820AF29Ch */ case    5:  		/* bc 4, CR6_EQ, 1784 */
		/* 820AF29Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF29Ch case    5:*/		return 0x820AF2A0;
	}
	return 0x820AF2A0;
} // Block from 820AF288h-820AF2A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AF2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF2A0);
		  /* 820AF2A0h */ case    0:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF2A0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF2A0h case    0:*/		return 0x820AF2A4;
		  /* 820AF2A4h */ case    1:  		/* lfd FR1, <#[R1 + 80]> */
		/* 820AF2A4h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF2A4h case    1:*/		return 0x820AF2A8;
		  /* 820AF2A8h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 820AF2A8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 820AF2A8h case    2:*/		return 0x820AF2AC;
		  /* 820AF2ACh */ case    3:  		/* bc 4, CR6_EQ, 1768 */
		/* 820AF2ACh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF2ACh case    3:*/		return 0x820AF2B0;
		  /* 820AF2B0h */ case    4:  		/* bl -94944 */
		/* 820AF2B0h case    4:*/		regs.LR = 0x820AF2B4; return 0x82097FD0;
		/* 820AF2B0h case    4:*/		return 0x820AF2B4;
		  /* 820AF2B4h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820AF2B4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF2B4h case    5:*/		return 0x820AF2B8;
		  /* 820AF2B8h */ case    6:  		/* bc 12, CR0_EQ, 1756 */
		/* 820AF2B8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820AF994;  }
		/* 820AF2B8h case    6:*/		return 0x820AF2BC;
	}
	return 0x820AF2BC;
} // Block from 820AF2A0h-820AF2BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AF2BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF2BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF2BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF2BC);
		  /* 820AF2BCh */ case    0:  		/* fmr FR30, FR27 */
		/* 820AF2BCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF2BCh case    0:*/		return 0x820AF2C0;
		  /* 820AF2C0h */ case    1:  		/* fmr FR31, FR27 */
		/* 820AF2C0h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR27);
		/* 820AF2C0h case    1:*/		return 0x820AF2C4;
		  /* 820AF2C4h */ case    2:  		/* b 1736 */
		/* 820AF2C4h case    2:*/		return 0x820AF98C;
		/* 820AF2C4h case    2:*/		return 0x820AF2C8;
	}
	return 0x820AF2C8;
} // Block from 820AF2BCh-820AF2C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AF2C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF2C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF2C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF2C8);
		  /* 820AF2C8h */ case    0:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF2C8h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF2C8h case    0:*/		return 0x820AF2CC;
		  /* 820AF2CCh */ case    1:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820AF2CCh case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF2CCh case    1:*/		return 0x820AF2D0;
		  /* 820AF2D0h */ case    2:  		/* fcmpu CR6, FR31, FR0 */
		/* 820AF2D0h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820AF2D0h case    2:*/		return 0x820AF2D4;
		  /* 820AF2D4h */ case    3:  		/* bc 4, CR6_EQ, 36 */
		/* 820AF2D4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF2F8;  }
		/* 820AF2D4h case    3:*/		return 0x820AF2D8;
		  /* 820AF2D8h */ case    4:  		/* fmr FR1, FR31 */
		/* 820AF2D8h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF2D8h case    4:*/		return 0x820AF2DC;
		  /* 820AF2DCh */ case    5:  		/* bl -94988 */
		/* 820AF2DCh case    5:*/		regs.LR = 0x820AF2E0; return 0x82097FD0;
		/* 820AF2DCh case    5:*/		return 0x820AF2E0;
		  /* 820AF2E0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820AF2E0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF2E0h case    6:*/		return 0x820AF2E4;
		  /* 820AF2E4h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 820AF2E4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820AF2F8;  }
		/* 820AF2E4h case    7:*/		return 0x820AF2E8;
		  /* 820AF2E8h */ case    8:  		/* fmr FR1, FR31 */
		/* 820AF2E8h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF2E8h case    8:*/		return 0x820AF2EC;
		  /* 820AF2ECh */ case    9:  		/* bl 1805292 */
		/* 820AF2ECh case    9:*/		regs.LR = 0x820AF2F0; return 0x82267ED8;
		/* 820AF2ECh case    9:*/		return 0x820AF2F0;
		  /* 820AF2F0h */ case   10:  		/* fmr FR31, FR1 */
		/* 820AF2F0h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 820AF2F0h case   10:*/		return 0x820AF2F4;
		  /* 820AF2F4h */ case   11:  		/* b -392 */
		/* 820AF2F4h case   11:*/		return 0x820AF16C;
		/* 820AF2F4h case   11:*/		return 0x820AF2F8;
	}
	return 0x820AF2F8;
} // Block from 820AF2C8h-820AF2F8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AF2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF2F8);
		  /* 820AF2F8h */ case    0:  		/* lis R11, -32255 */
		/* 820AF2F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AF2F8h case    0:*/		return 0x820AF2FC;
		  /* 820AF2FCh */ case    1:  		/* lis R10, -32255 */
		/* 820AF2FCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AF2FCh case    1:*/		return 0x820AF300;
		  /* 820AF300h */ case    2:  		/* lfd FR30, <#[R11 + 8104]> */
		/* 820AF300h case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00001FA8) );
		/* 820AF300h case    2:*/		return 0x820AF304;
		  /* 820AF304h */ case    3:  		/* lfd FR31, <#[R10 + 8096]> */
		/* 820AF304h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00001FA0) );
		/* 820AF304h case    3:*/		return 0x820AF308;
		  /* 820AF308h */ case    4:  		/* b 1668 */
		/* 820AF308h case    4:*/		return 0x820AF98C;
		/* 820AF308h case    4:*/		return 0x820AF30C;
	}
	return 0x820AF30C;
} // Block from 820AF2F8h-820AF30Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF30C);
		  /* 820AF30Ch */ case    0:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820AF30Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF30Ch case    0:*/		return 0x820AF310;
		  /* 820AF310h */ case    1:  		/* fcmpu CR6, FR31, FR25 */
		/* 820AF310h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR25);
		/* 820AF310h case    1:*/		return 0x820AF314;
		  /* 820AF314h */ case    2:  		/* bc 12, CR6_LT, 40 */
		/* 820AF314h case    2:*/		if ( regs.CR[6].lt ) { return 0x820AF33C;  }
		/* 820AF314h case    2:*/		return 0x820AF318;
		  /* 820AF318h */ case    3:  		/* lfd FR1, <#[R1 + 88]> */
		/* 820AF318h case    3:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF318h case    3:*/		return 0x820AF31C;
		  /* 820AF31Ch */ case    4:  		/* fcmpu CR6, FR1, FR26 */
		/* 820AF31Ch case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR26);
		/* 820AF31Ch case    4:*/		return 0x820AF320;
		  /* 820AF320h */ case    5:  		/* bc 12, CR6_GT, 28 */
		/* 820AF320h case    5:*/		if ( regs.CR[6].gt ) { return 0x820AF33C;  }
		/* 820AF320h case    5:*/		return 0x820AF324;
		  /* 820AF324h */ case    6:  		/* bl 1806220 */
		/* 820AF324h case    6:*/		regs.LR = 0x820AF328; return 0x822682B0;
		/* 820AF324h case    6:*/		return 0x820AF328;
		  /* 820AF328h */ case    7:  		/* stfd FR1, <#[R1 + 96]> */
		/* 820AF328h case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF328h case    7:*/		return 0x820AF32C;
		  /* 820AF32Ch */ case    8:  		/* fmr FR30, FR1 */
		/* 820AF32Ch case    8:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 820AF32Ch case    8:*/		return 0x820AF330;
		  /* 820AF330h */ case    9:  		/* fmr FR1, FR31 */
		/* 820AF330h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF330h case    9:*/		return 0x820AF334;
		  /* 820AF334h */ case   10:  		/* bl 1806204 */
		/* 820AF334h case   10:*/		regs.LR = 0x820AF338; return 0x822682B0;
		/* 820AF334h case   10:*/		return 0x820AF338;
		  /* 820AF338h */ case   11:  		/* b -512 */
		/* 820AF338h case   11:*/		return 0x820AF138;
		/* 820AF338h case   11:*/		return 0x820AF33C;
	}
	return 0x820AF33C;
} // Block from 820AF30Ch-820AF33Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AF33Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF33C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF33C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF33C);
		  /* 820AF33Ch */ case    0:  		/* lis R11, -32255 */
		/* 820AF33Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AF33Ch case    0:*/		return 0x820AF340;
		  /* 820AF340h */ case    1:  		/* fmr FR30, FR27 */
		/* 820AF340h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF340h case    1:*/		return 0x820AF344;
		  /* 820AF344h */ case    2:  		/* lfd FR31, <#[R11 + 8088]> */
		/* 820AF344h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00001F98) );
		/* 820AF344h case    2:*/		return 0x820AF348;
		  /* 820AF348h */ case    3:  		/* b 1604 */
		/* 820AF348h case    3:*/		return 0x820AF98C;
		/* 820AF348h case    3:*/		return 0x820AF34C;
	}
	return 0x820AF34C;
} // Block from 820AF33Ch-820AF34Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AF34Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF34C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF34C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF34C);
		  /* 820AF34Ch */ case    0:  		/* lfd FR1, <#[R1 + 80]> */
		/* 820AF34Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF34Ch case    0:*/		return 0x820AF350;
		  /* 820AF350h */ case    1:  		/* fcmpu CR6, FR1, FR25 */
		/* 820AF350h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR25);
		/* 820AF350h case    1:*/		return 0x820AF354;
		  /* 820AF354h */ case    2:  		/* bc 12, CR6_LT, -92 */
		/* 820AF354h case    2:*/		if ( regs.CR[6].lt ) { return 0x820AF2F8;  }
		/* 820AF354h case    2:*/		return 0x820AF358;
		  /* 820AF358h */ case    3:  		/* lfd FR31, <#[R1 + 88]> */
		/* 820AF358h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF358h case    3:*/		return 0x820AF35C;
		  /* 820AF35Ch */ case    4:  		/* fcmpu CR6, FR31, FR26 */
		/* 820AF35Ch case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR26);
		/* 820AF35Ch case    4:*/		return 0x820AF360;
		  /* 820AF360h */ case    5:  		/* bc 12, CR6_GT, -104 */
		/* 820AF360h case    5:*/		if ( regs.CR[6].gt ) { return 0x820AF2F8;  }
		/* 820AF360h case    5:*/		return 0x820AF364;
		  /* 820AF364h */ case    6:  		/* bl 1805956 */
		/* 820AF364h case    6:*/		regs.LR = 0x820AF368; return 0x822681E8;
		/* 820AF364h case    6:*/		return 0x820AF368;
		  /* 820AF368h */ case    7:  		/* stfd FR1, <#[R1 + 96]> */
		/* 820AF368h case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF368h case    7:*/		return 0x820AF36C;
		  /* 820AF36Ch */ case    8:  		/* fmr FR30, FR1 */
		/* 820AF36Ch case    8:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 820AF36Ch case    8:*/		return 0x820AF370;
		  /* 820AF370h */ case    9:  		/* fmr FR1, FR31 */
		/* 820AF370h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF370h case    9:*/		return 0x820AF374;
		  /* 820AF374h */ case   10:  		/* bl 1805940 */
		/* 820AF374h case   10:*/		regs.LR = 0x820AF378; return 0x822681E8;
		/* 820AF374h case   10:*/		return 0x820AF378;
		  /* 820AF378h */ case   11:  		/* b -576 */
		/* 820AF378h case   11:*/		return 0x820AF138;
		/* 820AF378h case   11:*/		return 0x820AF37C;
	}
	return 0x820AF37C;
} // Block from 820AF34Ch-820AF37Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AF37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF37C);
		  /* 820AF37Ch */ case    0:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF37Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF37Ch case    0:*/		return 0x820AF380;
		  /* 820AF380h */ case    1:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820AF380h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF380h case    1:*/		return 0x820AF384;
		  /* 820AF384h */ case    2:  		/* fcmpu CR6, FR31, FR0 */
		/* 820AF384h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820AF384h case    2:*/		return 0x820AF388;
		  /* 820AF388h */ case    3:  		/* bc 4, CR6_EQ, 1532 */
		/* 820AF388h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF984;  }
		/* 820AF388h case    3:*/		return 0x820AF38C;
		  /* 820AF38Ch */ case    4:  		/* fmr FR1, FR31 */
		/* 820AF38Ch case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF38Ch case    4:*/		return 0x820AF390;
		  /* 820AF390h */ case    5:  		/* bl -95168 */
		/* 820AF390h case    5:*/		regs.LR = 0x820AF394; return 0x82097FD0;
		/* 820AF390h case    5:*/		return 0x820AF394;
		  /* 820AF394h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820AF394h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF394h case    6:*/		return 0x820AF398;
		  /* 820AF398h */ case    7:  		/* bc 12, CR0_EQ, 1516 */
		/* 820AF398h case    7:*/		if ( regs.CR[0].eq ) { return 0x820AF984;  }
		/* 820AF398h case    7:*/		return 0x820AF39C;
		  /* 820AF39Ch */ case    8:  		/* fmr FR1, FR31 */
		/* 820AF39Ch case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF39Ch case    8:*/		return 0x820AF3A0;
		  /* 820AF3A0h */ case    9:  		/* bl -124920 */
		/* 820AF3A0h case    9:*/		regs.LR = 0x820AF3A4; return 0x82090BA8;
		/* 820AF3A0h case    9:*/		return 0x820AF3A4;
		  /* 820AF3A4h */ case   10:  		/* b -180 */
		/* 820AF3A4h case   10:*/		return 0x820AF2F0;
		/* 820AF3A4h case   10:*/		return 0x820AF3A8;
	}
	return 0x820AF3A8;
} // Block from 820AF37Ch-820AF3A8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AF3A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF3A8);
		  /* 820AF3A8h */ case    0:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF3A8h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF3A8h case    0:*/		return 0x820AF3AC;
		  /* 820AF3ACh */ case    1:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820AF3ACh case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF3ACh case    1:*/		return 0x820AF3B0;
		  /* 820AF3B0h */ case    2:  		/* fcmpu CR6, FR31, FR0 */
		/* 820AF3B0h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820AF3B0h case    2:*/		return 0x820AF3B4;
		  /* 820AF3B4h */ case    3:  		/* bc 4, CR6_EQ, 1488 */
		/* 820AF3B4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF984;  }
		/* 820AF3B4h case    3:*/		return 0x820AF3B8;
		  /* 820AF3B8h */ case    4:  		/* fmr FR1, FR31 */
		/* 820AF3B8h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF3B8h case    4:*/		return 0x820AF3BC;
		  /* 820AF3BCh */ case    5:  		/* bl -95212 */
		/* 820AF3BCh case    5:*/		regs.LR = 0x820AF3C0; return 0x82097FD0;
		/* 820AF3BCh case    5:*/		return 0x820AF3C0;
		  /* 820AF3C0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820AF3C0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF3C0h case    6:*/		return 0x820AF3C4;
		  /* 820AF3C4h */ case    7:  		/* bc 12, CR0_EQ, 1472 */
		/* 820AF3C4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820AF984;  }
		/* 820AF3C4h case    7:*/		return 0x820AF3C8;
		  /* 820AF3C8h */ case    8:  		/* fmr FR1, FR31 */
		/* 820AF3C8h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF3C8h case    8:*/		return 0x820AF3CC;
		  /* 820AF3CCh */ case    9:  		/* bl -125188 */
		/* 820AF3CCh case    9:*/		regs.LR = 0x820AF3D0; return 0x82090AC8;
		/* 820AF3CCh case    9:*/		return 0x820AF3D0;
		  /* 820AF3D0h */ case   10:  		/* b -224 */
		/* 820AF3D0h case   10:*/		return 0x820AF2F0;
		/* 820AF3D0h case   10:*/		return 0x820AF3D4;
	}
	return 0x820AF3D4;
} // Block from 820AF3A8h-820AF3D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820AF3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF3D4);
		  /* 820AF3D4h */ case    0:  		/* lis R29, 8192 */
		/* 820AF3D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0x2000);
		/* 820AF3D4h case    0:*/		return 0x820AF3D8;
		  /* 820AF3D8h */ case    1:  		/* cmplw CR6, R10, R29 */
		/* 820AF3D8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 820AF3D8h case    1:*/		return 0x820AF3DC;
		  /* 820AF3DCh */ case    2:  		/* bc 4, CR6_EQ, 552 */
		/* 820AF3DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AF604;  }
		/* 820AF3DCh case    2:*/		return 0x820AF3E0;
		  /* 820AF3E0h */ case    3:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820AF3E0h case    3:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820AF3E0h case    3:*/		return 0x820AF3E4;
		  /* 820AF3E4h */ case    4:  		/* lis R10, 8336 */
		/* 820AF3E4h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 820AF3E4h case    4:*/		return 0x820AF3E8;
		  /* 820AF3E8h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820AF3E8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF3E8h case    5:*/		return 0x820AF3EC;
		  /* 820AF3ECh */ case    6:  		/* bc 12, CR6_EQ, 1448 */
		/* 820AF3ECh case    6:*/		if ( regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF3ECh case    6:*/		return 0x820AF3F0;
		  /* 820AF3F0h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF3F0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF3F0h case    7:*/		return 0x820AF3F4;
		  /* 820AF3F4h */ case    8:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820AF3F4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820AF3F4h case    8:*/		return 0x820AF3F8;
		  /* 820AF3F8h */ case    9:  		/* addi R5, R1, 112 */
		/* 820AF3F8h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820AF3F8h case    9:*/		return 0x820AF3FC;
		  /* 820AF3FCh */ case   10:  		/* mr R3, R26 */
		/* 820AF3FCh case   10:*/		regs.R3 = regs.R26;
		/* 820AF3FCh case   10:*/		return 0x820AF400;
		  /* 820AF400h */ case   11:  		/* lwzx R4, <#[R10 + R11]> */
		/* 820AF400h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820AF400h case   11:*/		return 0x820AF404;
		  /* 820AF404h */ case   12:  		/* bl -2316 */
		/* 820AF404h case   12:*/		regs.LR = 0x820AF408; return 0x820AEAF8;
		/* 820AF404h case   12:*/		return 0x820AF408;
		  /* 820AF408h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820AF408h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF408h case   13:*/		return 0x820AF40C;
		  /* 820AF40Ch */ case   14:  		/* bc 12, CR0_LT, 1312 */
		/* 820AF40Ch case   14:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF40Ch case   14:*/		return 0x820AF410;
		  /* 820AF410h */ case   15:  		/* lwz R11, <#[R31 + 12]> */
		/* 820AF410h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AF410h case   15:*/		return 0x820AF414;
		  /* 820AF414h */ case   16:  		/* addi R5, R1, 80 */
		/* 820AF414h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820AF414h case   16:*/		return 0x820AF418;
		  /* 820AF418h */ case   17:  		/* lwz R10, <#[R31 + 8]> */
		/* 820AF418h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF418h case   17:*/		return 0x820AF41C;
		  /* 820AF41Ch */ case   18:  		/* mr R3, R26 */
		/* 820AF41Ch case   18:*/		regs.R3 = regs.R26;
		/* 820AF41Ch case   18:*/		return 0x820AF420;
		  /* 820AF420h */ case   19:  		/* add R11, R11, R30 */
		/* 820AF420h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820AF420h case   19:*/		return 0x820AF424;
		  /* 820AF424h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AF424h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AF424h case   20:*/		return 0x820AF428;
		  /* 820AF428h */ case   21:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820AF428h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820AF428h case   21:*/		return 0x820AF42C;
		  /* 820AF42Ch */ case   22:  		/* bl -2356 */
		/* 820AF42Ch case   22:*/		regs.LR = 0x820AF430; return 0x820AEAF8;
		/* 820AF42Ch case   22:*/		return 0x820AF430;
		  /* 820AF430h */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 820AF430h case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF430h case   23:*/		return 0x820AF434;
		  /* 820AF434h */ case   24:  		/* bc 12, CR0_LT, 1272 */
		/* 820AF434h case   24:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF434h case   24:*/		return 0x820AF438;
		  /* 820AF438h */ case   25:  		/* lwz R11, <#[R31]> */
		/* 820AF438h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AF438h case   25:*/		return 0x820AF43C;
		  /* 820AF43Ch */ case   26:  		/* lis R10, 8256 */
		/* 820AF43Ch case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820AF43Ch case   26:*/		return 0x820AF440;
		  /* 820AF440h */ case   27:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820AF440h case   27:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820AF440h case   27:*/		return 0x820AF444;
		  /* 820AF444h */ case   28:  		/* cmplw CR6, R11, R10 */
		/* 820AF444h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF444h case   28:*/		return 0x820AF448;
		  /* 820AF448h */ case   29:  		/* bc 12, CR6_GT, 248 */
		/* 820AF448h case   29:*/		if ( regs.CR[6].gt ) { return 0x820AF540;  }
		/* 820AF448h case   29:*/		return 0x820AF44C;
		  /* 820AF44Ch */ case   30:  		/* bc 12, CR6_EQ, 216 */
		/* 820AF44Ch case   30:*/		if ( regs.CR[6].eq ) { return 0x820AF524;  }
		/* 820AF44Ch case   30:*/		return 0x820AF450;
	}
	return 0x820AF450;
} // Block from 820AF3D4h-820AF450h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820AF450h
// Function '?EvalRange_Mul@CCompiler@D3DXShader@@IAAXPAU_D3DXRANGE@2@00K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF450);
		  /* 820AF450h */ case    0:  		/* cmplw CR6, R11, R29 */
		/* 820AF450h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820AF450h case    0:*/		return 0x820AF454;
		  /* 820AF454h */ case    1:  		/* bc 12, CR6_EQ, 164 */
		/* 820AF454h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AF4F8;  }
		/* 820AF454h case    1:*/		return 0x820AF458;
		  /* 820AF458h */ case    2:  		/* lis R10, 8208 */
		/* 820AF458h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x2010);
		/* 820AF458h case    2:*/		return 0x820AF45C;
		  /* 820AF45Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820AF45Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF45Ch case    3:*/		return 0x820AF460;
		  /* 820AF460h */ case    4:  		/* bc 12, CR6_EQ, 104 */
		/* 820AF460h case    4:*/		if ( regs.CR[6].eq ) { return 0x820AF4C8;  }
		/* 820AF460h case    4:*/		return 0x820AF464;
		  /* 820AF464h */ case    5:  		/* lis R10, 8224 */
		/* 820AF464h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x2020);
		/* 820AF464h case    5:*/		return 0x820AF468;
		  /* 820AF468h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820AF468h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF468h case    6:*/		return 0x820AF46C;
		  /* 820AF46Ch */ case    7:  		/* bc 12, CR6_EQ, 56 */
		/* 820AF46Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820AF4A4;  }
		/* 820AF46Ch case    7:*/		return 0x820AF470;
		  /* 820AF470h */ case    8:  		/* lis R10, 8240 */
		/* 820AF470h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x2030);
		/* 820AF470h case    8:*/		return 0x820AF474;
		  /* 820AF474h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820AF474h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF474h case    9:*/		return 0x820AF478;
		  /* 820AF478h */ case   10:  		/* bc 4, CR6_EQ, 1308 */
		/* 820AF478h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF478h case   10:*/		return 0x820AF47C;
		  /* 820AF47Ch */ case   11:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820AF47Ch case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF47Ch case   11:*/		return 0x820AF480;
		  /* 820AF480h */ case   12:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820AF480h case   12:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF480h case   12:*/		return 0x820AF484;
		  /* 820AF484h */ case   13:  		/* fcmpu CR6, FR0, FR13 */
		/* 820AF484h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820AF484h case   13:*/		return 0x820AF488;
		  /* 820AF488h */ case   14:  		/* bc 12, CR6_LT, -460 */
		/* 820AF488h case   14:*/		if ( regs.CR[6].lt ) { return 0x820AF2BC;  }
		/* 820AF488h case   14:*/		return 0x820AF48C;
		  /* 820AF48Ch */ case   15:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820AF48Ch case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF48Ch case   15:*/		return 0x820AF490;
		  /* 820AF490h */ case   16:  		/* lfd FR13, <#[R1 + 88]> */
		/* 820AF490h case   16:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF490h case   16:*/		return 0x820AF494;
		  /* 820AF494h */ case   17:  		/* fcmpu CR6, FR0, FR13 */
		/* 820AF494h case   17:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820AF494h case   17:*/		return 0x820AF498;
		  /* 820AF498h */ case   18:  		/* bc 12, CR6_LT, -804 */
		/* 820AF498h case   18:*/		if ( regs.CR[6].lt ) { return 0x820AF174;  }
		/* 820AF498h case   18:*/		return 0x820AF49C;
		  /* 820AF49Ch */ case   19:  		/* fmr FR30, FR26 */
		/* 820AF49Ch case   19:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR26);
		/* 820AF49Ch case   19:*/		return 0x820AF4A0;
		  /* 820AF4A0h */ case   20:  		/* b 1256 */
		/* 820AF4A0h case   20:*/		return 0x820AF988;
		/* 820AF4A0h case   20:*/		return 0x820AF4A4;
	}
	return 0x820AF4A4;
} // Block from 820AF450h-820AF4A4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820AF4A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF4A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF4A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF4A4);
		  /* 820AF4A4h */ case    0:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820AF4A4h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF4A4h case    0:*/		return 0x820AF4A8;
		  /* 820AF4A8h */ case    1:  		/* lfd FR13, <#[R1 + 88]> */
		/* 820AF4A8h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF4A8h case    1:*/		return 0x820AF4AC;
		  /* 820AF4ACh */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 820AF4ACh case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820AF4ACh case    2:*/		return 0x820AF4B0;
		  /* 820AF4B0h */ case    3:  		/* bc 4, CR6_LT, -500 */
		/* 820AF4B0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820AF2BC;  }
		/* 820AF4B0h case    3:*/		return 0x820AF4B4;
		  /* 820AF4B4h */ case    4:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820AF4B4h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF4B4h case    4:*/		return 0x820AF4B8;
		  /* 820AF4B8h */ case    5:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820AF4B8h case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF4B8h case    5:*/		return 0x820AF4BC;
		  /* 820AF4BCh */ case    6:  		/* fcmpu CR6, FR0, FR13 */
		/* 820AF4BCh case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820AF4BCh case    6:*/		return 0x820AF4C0;
		  /* 820AF4C0h */ case    7:  		/* bc 4, CR6_LT, -844 */
		/* 820AF4C0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820AF174;  }
		/* 820AF4C0h case    7:*/		return 0x820AF4C4;
		  /* 820AF4C4h */ case    8:  		/* b -40 */
		/* 820AF4C4h case    8:*/		return 0x820AF49C;
		/* 820AF4C4h case    8:*/		return 0x820AF4C8;
	}
	return 0x820AF4C8;
} // Block from 820AF4A4h-820AF4C8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AF4C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF4C8);
		  /* 820AF4C8h */ case    0:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820AF4C8h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF4C8h case    0:*/		return 0x820AF4CC;
		  /* 820AF4CCh */ case    1:  		/* lfd FR30, <#[R1 + 80]> */
		/* 820AF4CCh case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF4CCh case    1:*/		return 0x820AF4D0;
		  /* 820AF4D0h */ case    2:  		/* fcmpu CR6, FR0, FR30 */
		/* 820AF4D0h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 820AF4D0h case    2:*/		return 0x820AF4D4;
		  /* 820AF4D4h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820AF4D4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820AF4DC;  }
		/* 820AF4D4h case    3:*/		return 0x820AF4D8;
		  /* 820AF4D8h */ case    4:  		/* fmr FR30, FR0 */
		/* 820AF4D8h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR0);
		/* 820AF4D8h case    4:*/		return 0x820AF4DC;
	}
	return 0x820AF4DC;
} // Block from 820AF4C8h-820AF4DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF4DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF4DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF4DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF4DC);
		  /* 820AF4DCh */ case    0:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820AF4DCh case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF4DCh case    0:*/		return 0x820AF4E0;
		  /* 820AF4E0h */ case    1:  		/* lfd FR31, <#[R1 + 88]> */
		/* 820AF4E0h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF4E0h case    1:*/		return 0x820AF4E4;
		  /* 820AF4E4h */ case    2:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF4E4h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF4E4h case    2:*/		return 0x820AF4E8;
		  /* 820AF4E8h */ case    3:  		/* fcmpu CR6, FR0, FR31 */
		/* 820AF4E8h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820AF4E8h case    3:*/		return 0x820AF4EC;
		  /* 820AF4ECh */ case    4:  		/* bc 4, CR6_GT, 1188 */
		/* 820AF4ECh case    4:*/		if ( !regs.CR[6].gt ) { return 0x820AF990;  }
		/* 820AF4ECh case    4:*/		return 0x820AF4F0;
		  /* 820AF4F0h */ case    5:  		/* fmr FR31, FR0 */
		/* 820AF4F0h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR0);
		/* 820AF4F0h case    5:*/		return 0x820AF4F4;
		  /* 820AF4F4h */ case    6:  		/* b 1180 */
		/* 820AF4F4h case    6:*/		return 0x820AF990;
		/* 820AF4F4h case    6:*/		return 0x820AF4F8;
	}
	return 0x820AF4F8;
} // Block from 820AF4DCh-820AF4F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AF4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF4F8);
		  /* 820AF4F8h */ case    0:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820AF4F8h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF4F8h case    0:*/		return 0x820AF4FC;
		  /* 820AF4FCh */ case    1:  		/* lfd FR30, <#[R1 + 80]> */
		/* 820AF4FCh case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF4FCh case    1:*/		return 0x820AF500;
		  /* 820AF500h */ case    2:  		/* fcmpu CR6, FR0, FR30 */
		/* 820AF500h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 820AF500h case    2:*/		return 0x820AF504;
		  /* 820AF504h */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 820AF504h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820AF50C;  }
		/* 820AF504h case    3:*/		return 0x820AF508;
		  /* 820AF508h */ case    4:  		/* fmr FR30, FR0 */
		/* 820AF508h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR0);
		/* 820AF508h case    4:*/		return 0x820AF50C;
	}
	return 0x820AF50C;
} // Block from 820AF4F8h-820AF50Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF50C);
		  /* 820AF50Ch */ case    0:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820AF50Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF50Ch case    0:*/		return 0x820AF510;
		  /* 820AF510h */ case    1:  		/* lfd FR31, <#[R1 + 88]> */
		/* 820AF510h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF510h case    1:*/		return 0x820AF514;
		  /* 820AF514h */ case    2:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF514h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF514h case    2:*/		return 0x820AF518;
		  /* 820AF518h */ case    3:  		/* fcmpu CR6, FR0, FR31 */
		/* 820AF518h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820AF518h case    3:*/		return 0x820AF51C;
		  /* 820AF51Ch */ case    4:  		/* bc 4, CR6_LT, 1140 */
		/* 820AF51Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x820AF990;  }
		/* 820AF51Ch case    4:*/		return 0x820AF520;
		  /* 820AF520h */ case    5:  		/* b -48 */
		/* 820AF520h case    5:*/		return 0x820AF4F0;
		/* 820AF520h case    5:*/		return 0x820AF524;
	}
	return 0x820AF524;
} // Block from 820AF50Ch-820AF524h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AF524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF524);
		  /* 820AF524h */ case    0:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820AF524h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF524h case    0:*/		return 0x820AF528;
		  /* 820AF528h */ case    1:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820AF528h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF528h case    1:*/		return 0x820AF52C;
		  /* 820AF52Ch */ case    2:  		/* fadd FR30, FR13, FR0 */
		/* 820AF52Ch case    2:*/		cpu::op::fadd<0>(regs,&regs.FR30,regs.FR13,regs.FR0);
		/* 820AF52Ch case    2:*/		return 0x820AF530;
	}
	return 0x820AF530;
} // Block from 820AF524h-820AF530h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AF530h
// Function '?EvalRangeNoRecurse@CCompiler@D3DXShader@@IAAJIPAU_D3DXRANGE@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF530);
		  /* 820AF530h */ case    0:  		/* lfd FR12, <#[R1 + 120]> */
		/* 820AF530h case    0:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF530h case    0:*/		return 0x820AF534;
		  /* 820AF534h */ case    1:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF534h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF534h case    1:*/		return 0x820AF538;
		  /* 820AF538h */ case    2:  		/* fadd FR31, FR0, FR12 */
		/* 820AF538h case    2:*/		cpu::op::fadd<0>(regs,&regs.FR31,regs.FR0,regs.FR12);
		/* 820AF538h case    2:*/		return 0x820AF53C;
		  /* 820AF53Ch */ case    3:  		/* b 1104 */
		/* 820AF53Ch case    3:*/		return 0x820AF98C;
		/* 820AF53Ch case    3:*/		return 0x820AF540;
	}
	return 0x820AF540;
} // Block from 820AF530h-820AF540h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AF540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF540);
		  /* 820AF540h */ case    0:  		/* lis R10, 8272 */
		/* 820AF540h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 820AF540h case    0:*/		return 0x820AF544;
		  /* 820AF544h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820AF544h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF544h case    1:*/		return 0x820AF548;
		  /* 820AF548h */ case    2:  		/* bc 12, CR6_EQ, 160 */
		/* 820AF548h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AF5E8;  }
		/* 820AF548h case    2:*/		return 0x820AF54C;
		  /* 820AF54Ch */ case    3:  		/* lis R10, 8288 */
		/* 820AF54Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x2060);
		/* 820AF54Ch case    3:*/		return 0x820AF550;
		  /* 820AF550h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820AF550h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF550h case    4:*/		return 0x820AF554;
		  /* 820AF554h */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 820AF554h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AF584;  }
		/* 820AF554h case    5:*/		return 0x820AF558;
		  /* 820AF558h */ case    6:  		/* lis R10, 8304 */
		/* 820AF558h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x2070);
		/* 820AF558h case    6:*/		return 0x820AF55C;
		  /* 820AF55Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820AF55Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF55Ch case    7:*/		return 0x820AF560;
		  /* 820AF560h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 820AF560h case    8:*/		if ( regs.CR[6].eq ) { return 0x820AF570;  }
		/* 820AF560h case    8:*/		return 0x820AF564;
		  /* 820AF564h */ case    9:  		/* lis R10, 8320 */
		/* 820AF564h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x2080);
		/* 820AF564h case    9:*/		return 0x820AF568;
		  /* 820AF568h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820AF568h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820AF568h case   10:*/		return 0x820AF56C;
		  /* 820AF56Ch */ case   11:  		/* bc 4, CR6_EQ, 1064 */
		/* 820AF56Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF56Ch case   11:*/		return 0x820AF570;
	}
	return 0x820AF570;
} // Block from 820AF540h-820AF570h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AF570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF570);
		  /* 820AF570h */ case    0:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820AF570h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF570h case    0:*/		return 0x820AF574;
		  /* 820AF574h */ case    1:  		/* lfd FR30, <#[R1 + 80]> */
		/* 820AF574h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF574h case    1:*/		return 0x820AF578;
		  /* 820AF578h */ case    2:  		/* fcmpu CR6, FR0, FR30 */
		/* 820AF578h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 820AF578h case    2:*/		return 0x820AF57C;
		  /* 820AF57Ch */ case    3:  		/* bc 4, CR6_LT, -160 */
		/* 820AF57Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820AF4DC;  }
		/* 820AF57Ch case    3:*/		return 0x820AF580;
		  /* 820AF580h */ case    4:  		/* b -168 */
		/* 820AF580h case    4:*/		return 0x820AF4D8;
		/* 820AF580h case    4:*/		return 0x820AF584;
	}
	return 0x820AF584;
} // Block from 820AF570h-820AF584h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF584);
		  /* 820AF584h */ case    0:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820AF584h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF584h case    0:*/		return 0x820AF588;
		  /* 820AF588h */ case    1:  		/* lfd FR30, <#[R1 + 112]> */
		/* 820AF588h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF588h case    1:*/		return 0x820AF58C;
		  /* 820AF58Ch */ case    2:  		/* fcmpu CR6, FR30, FR0 */
		/* 820AF58Ch case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR0);
		/* 820AF58Ch case    2:*/		return 0x820AF590;
		  /* 820AF590h */ case    3:  		/* bc 4, CR6_EQ, 68 */
		/* 820AF590h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF5D4;  }
		/* 820AF590h case    3:*/		return 0x820AF594;
		  /* 820AF594h */ case    4:  		/* fmr FR1, FR30 */
		/* 820AF594h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 820AF594h case    4:*/		return 0x820AF598;
		  /* 820AF598h */ case    5:  		/* bl -95688 */
		/* 820AF598h case    5:*/		regs.LR = 0x820AF59C; return 0x82097FD0;
		/* 820AF598h case    5:*/		return 0x820AF59C;
		  /* 820AF59Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820AF59Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF59Ch case    6:*/		return 0x820AF5A0;
		  /* 820AF5A0h */ case    7:  		/* bc 12, CR0_EQ, 52 */
		/* 820AF5A0h case    7:*/		if ( regs.CR[0].eq ) { return 0x820AF5D4;  }
		/* 820AF5A0h case    7:*/		return 0x820AF5A4;
		  /* 820AF5A4h */ case    8:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820AF5A4h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF5A4h case    8:*/		return 0x820AF5A8;
		  /* 820AF5A8h */ case    9:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820AF5A8h case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF5A8h case    9:*/		return 0x820AF5AC;
		  /* 820AF5ACh */ case   10:  		/* fcmpu CR6, FR31, FR0 */
		/* 820AF5ACh case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820AF5ACh case   10:*/		return 0x820AF5B0;
		  /* 820AF5B0h */ case   11:  		/* bc 4, CR6_EQ, 36 */
		/* 820AF5B0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820AF5D4;  }
		/* 820AF5B0h case   11:*/		return 0x820AF5B4;
		  /* 820AF5B4h */ case   12:  		/* fmr FR1, FR31 */
		/* 820AF5B4h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820AF5B4h case   12:*/		return 0x820AF5B8;
		  /* 820AF5B8h */ case   13:  		/* bl -95720 */
		/* 820AF5B8h case   13:*/		regs.LR = 0x820AF5BC; return 0x82097FD0;
		/* 820AF5B8h case   13:*/		return 0x820AF5BC;
		  /* 820AF5BCh */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 820AF5BCh case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF5BCh case   14:*/		return 0x820AF5C0;
		  /* 820AF5C0h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 820AF5C0h case   15:*/		if ( regs.CR[0].eq ) { return 0x820AF5D4;  }
		/* 820AF5C0h case   15:*/		return 0x820AF5C4;
		  /* 820AF5C4h */ case   16:  		/* fmr FR2, FR31 */
		/* 820AF5C4h case   16:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 820AF5C4h case   16:*/		return 0x820AF5C8;
		  /* 820AF5C8h */ case   17:  		/* fmr FR1, FR30 */
		/* 820AF5C8h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 820AF5C8h case   17:*/		return 0x820AF5CC;
		  /* 820AF5CCh */ case   18:  		/* bl 1804788 */
		/* 820AF5CCh case   18:*/		regs.LR = 0x820AF5D0; return 0x82267FC0;
		/* 820AF5CCh case   18:*/		return 0x820AF5D0;
		  /* 820AF5D0h */ case   19:  		/* b -736 */
		/* 820AF5D0h case   19:*/		return 0x820AF2F0;
		/* 820AF5D0h case   19:*/		return 0x820AF5D4;
	}
	return 0x820AF5D4;
} // Block from 820AF584h-820AF5D4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820AF5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF5D4);
		  /* 820AF5D4h */ case    0:  		/* lis R11, -32255 */
		/* 820AF5D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AF5D4h case    0:*/		return 0x820AF5D8;
		  /* 820AF5D8h */ case    1:  		/* lis R10, -32255 */
		/* 820AF5D8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820AF5D8h case    1:*/		return 0x820AF5DC;
		  /* 820AF5DCh */ case    2:  		/* lfd FR30, <#[R11 + 8080]> */
		/* 820AF5DCh case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00001F90) );
		/* 820AF5DCh case    2:*/		return 0x820AF5E0;
		  /* 820AF5E0h */ case    3:  		/* lfd FR31, <#[R10 + 8088]> */
		/* 820AF5E0h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00001F98) );
		/* 820AF5E0h case    3:*/		return 0x820AF5E4;
		  /* 820AF5E4h */ case    4:  		/* b 936 */
		/* 820AF5E4h case    4:*/		return 0x820AF98C;
		/* 820AF5E4h case    4:*/		return 0x820AF5E8;
	}
	return 0x820AF5E8;
} // Block from 820AF5D4h-820AF5E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF5E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF5E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF5E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF5E8);
		  /* 820AF5E8h */ case    0:  		/* addi R6, R1, 80 */
		/* 820AF5E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820AF5E8h case    0:*/		return 0x820AF5EC;
		  /* 820AF5ECh */ case    1:  		/* lwz R7, <#[R25]> */
		/* 820AF5ECh case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000000) );
		/* 820AF5ECh case    1:*/		return 0x820AF5F0;
		  /* 820AF5F0h */ case    2:  		/* addi R5, R1, 112 */
		/* 820AF5F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820AF5F0h case    2:*/		return 0x820AF5F4;
		  /* 820AF5F4h */ case    3:  		/* addi R4, R1, 96 */
		/* 820AF5F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820AF5F4h case    3:*/		return 0x820AF5F8;
		  /* 820AF5F8h */ case    4:  		/* mr R3, R26 */
		/* 820AF5F8h case    4:*/		regs.R3 = regs.R26;
		/* 820AF5F8h case    4:*/		return 0x820AF5FC;
		  /* 820AF5FCh */ case    5:  		/* bl -3044 */
		/* 820AF5FCh case    5:*/		regs.LR = 0x820AF600; return 0x820AEA18;
		/* 820AF5FCh case    5:*/		return 0x820AF600;
		  /* 820AF600h */ case    6:  		/* b -1672 */
		/* 820AF600h case    6:*/		return 0x820AEF78;
		/* 820AF600h case    6:*/		return 0x820AF604;
	}
	return 0x820AF604;
} // Block from 820AF5E8h-820AF604h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AF604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF604);
		  /* 820AF604h */ case    0:  		/* rlwinm R10, R11, 0, 0, 11 */
		/* 820AF604h case    0:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R11);
		/* 820AF604h case    0:*/		return 0x820AF608;
		  /* 820AF608h */ case    1:  		/* lis R9, 20480 */
		/* 820AF608h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x5000);
		/* 820AF608h case    1:*/		return 0x820AF60C;
		  /* 820AF60Ch */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 820AF60Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820AF60Ch case    2:*/		return 0x820AF610;
		  /* 820AF610h */ case    3:  		/* bc 4, CR6_EQ, 168 */
		/* 820AF610h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF6B8;  }
		/* 820AF610h case    3:*/		return 0x820AF614;
		  /* 820AF614h */ case    4:  		/* stfd FR27, <#[R1 + 96]> */
		/* 820AF614h case    4:*/		cpu::mem::store64f( regs, regs.FR27, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF614h case    4:*/		return 0x820AF618;
		  /* 820AF618h */ case    5:  		/* rlwinm. R27, R11, 0, 12, 31 */
		/* 820AF618h case    5:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R27,regs.R11);
		/* 820AF618h case    5:*/		return 0x820AF61C;
		  /* 820AF61Ch */ case    6:  		/* stfd FR27, <#[R1 + 104]> */
		/* 820AF61Ch case    6:*/		cpu::mem::store64f( regs, regs.FR27, (uint32)(regs.R1 + 0x00000068) );
		/* 820AF61Ch case    6:*/		return 0x820AF620;
		  /* 820AF620h */ case    7:  		/* fmr FR30, FR27 */
		/* 820AF620h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF620h case    7:*/		return 0x820AF624;
		  /* 820AF624h */ case    8:  		/* fmr FR31, FR27 */
		/* 820AF624h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR27);
		/* 820AF624h case    8:*/		return 0x820AF628;
		  /* 820AF628h */ case    9:  		/* li R28, 0 */
		/* 820AF628h case    9:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820AF628h case    9:*/		return 0x820AF62C;
		  /* 820AF62Ch */ case   10:  		/* bc 12, CR0_EQ, 872 */
		/* 820AF62Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820AF994;  }
		/* 820AF62Ch case   10:*/		return 0x820AF630;
		  /* 820AF630h */ case   11:  		/* li R30, 0 */
		/* 820AF630h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820AF630h case   11:*/		return 0x820AF634;
		  /* 820AF634h */ case   12:  		/* rlwinm R29, R27, 2, 0, 29 */
		/* 820AF634h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R27);
		/* 820AF634h case   12:*/		return 0x820AF638;
		  /* 820AF638h */ case   13:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF638h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF638h case   13:*/		return 0x820AF63C;
		  /* 820AF63Ch */ case   14:  		/* addi R5, R1, 80 */
		/* 820AF63Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820AF63Ch case   14:*/		return 0x820AF640;
		  /* 820AF640h */ case   15:  		/* mr R3, R26 */
		/* 820AF640h case   15:*/		regs.R3 = regs.R26;
		/* 820AF640h case   15:*/		return 0x820AF644;
		  /* 820AF644h */ case   16:  		/* lwzx R4, <#[R11 + R30]> */
		/* 820AF644h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820AF644h case   16:*/		return 0x820AF648;
		  /* 820AF648h */ case   17:  		/* bl -2896 */
		/* 820AF648h case   17:*/		regs.LR = 0x820AF64C; return 0x820AEAF8;
		/* 820AF648h case   17:*/		return 0x820AF64C;
		  /* 820AF64Ch */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820AF64Ch case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF64Ch case   18:*/		return 0x820AF650;
		  /* 820AF650h */ case   19:  		/* bc 12, CR0_LT, 732 */
		/* 820AF650h case   19:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF650h case   19:*/		return 0x820AF654;
		  /* 820AF654h */ case   20:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF654h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF654h case   20:*/		return 0x820AF658;
		  /* 820AF658h */ case   21:  		/* addi R5, R1, 128 */
		/* 820AF658h case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820AF658h case   21:*/		return 0x820AF65C;
		  /* 820AF65Ch */ case   22:  		/* mr R3, R26 */
		/* 820AF65Ch case   22:*/		regs.R3 = regs.R26;
		/* 820AF65Ch case   22:*/		return 0x820AF660;
		  /* 820AF660h */ case   23:  		/* lwzx R4, <#[R11 + R29]> */
		/* 820AF660h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820AF660h case   23:*/		return 0x820AF664;
		  /* 820AF664h */ case   24:  		/* bl -2924 */
		/* 820AF664h case   24:*/		regs.LR = 0x820AF668; return 0x820AEAF8;
		/* 820AF664h case   24:*/		return 0x820AF668;
		  /* 820AF668h */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 820AF668h case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF668h case   25:*/		return 0x820AF66C;
		  /* 820AF66Ch */ case   26:  		/* bc 12, CR0_LT, 704 */
		/* 820AF66Ch case   26:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF66Ch case   26:*/		return 0x820AF670;
		  /* 820AF670h */ case   27:  		/* addi R6, R1, 128 */
		/* 820AF670h case   27:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820AF670h case   27:*/		return 0x820AF674;
		  /* 820AF674h */ case   28:  		/* lwz R7, <#[R25]> */
		/* 820AF674h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000000) );
		/* 820AF674h case   28:*/		return 0x820AF678;
		  /* 820AF678h */ case   29:  		/* addi R5, R1, 80 */
		/* 820AF678h case   29:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820AF678h case   29:*/		return 0x820AF67C;
		  /* 820AF67Ch */ case   30:  		/* addi R4, R1, 112 */
		/* 820AF67Ch case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820AF67Ch case   30:*/		return 0x820AF680;
		  /* 820AF680h */ case   31:  		/* mr R3, R26 */
		/* 820AF680h case   31:*/		regs.R3 = regs.R26;
		/* 820AF680h case   31:*/		return 0x820AF684;
		  /* 820AF684h */ case   32:  		/* bl -3180 */
		/* 820AF684h case   32:*/		regs.LR = 0x820AF688; return 0x820AEA18;
		/* 820AF684h case   32:*/		return 0x820AF688;
		  /* 820AF688h */ case   33:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820AF688h case   33:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF688h case   33:*/		return 0x820AF68C;
		  /* 820AF68Ch */ case   34:  		/* lfd FR13, <#[R1 + 120]> */
		/* 820AF68Ch case   34:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF68Ch case   34:*/		return 0x820AF690;
		  /* 820AF690h */ case   35:  		/* addi R28, R28, 1 */
		/* 820AF690h case   35:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820AF690h case   35:*/		return 0x820AF694;
		  /* 820AF694h */ case   36:  		/* fadd FR30, FR0, FR30 */
		/* 820AF694h case   36:*/		cpu::op::fadd<0>(regs,&regs.FR30,regs.FR0,regs.FR30);
		/* 820AF694h case   36:*/		return 0x820AF698;
		  /* 820AF698h */ case   37:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF698h case   37:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF698h case   37:*/		return 0x820AF69C;
		  /* 820AF69Ch */ case   38:  		/* fadd FR31, FR13, FR31 */
		/* 820AF69Ch case   38:*/		cpu::op::fadd<0>(regs,&regs.FR31,regs.FR13,regs.FR31);
		/* 820AF69Ch case   38:*/		return 0x820AF6A0;
		  /* 820AF6A0h */ case   39:  		/* stfd FR31, <#[R1 + 104]> */
		/* 820AF6A0h case   39:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 820AF6A0h case   39:*/		return 0x820AF6A4;
		  /* 820AF6A4h */ case   40:  		/* addi R30, R30, 4 */
		/* 820AF6A4h case   40:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820AF6A4h case   40:*/		return 0x820AF6A8;
		  /* 820AF6A8h */ case   41:  		/* addi R29, R29, 4 */
		/* 820AF6A8h case   41:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820AF6A8h case   41:*/		return 0x820AF6AC;
		  /* 820AF6ACh */ case   42:  		/* cmplw CR6, R28, R27 */
		/* 820AF6ACh case   42:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 820AF6ACh case   42:*/		return 0x820AF6B0;
		  /* 820AF6B0h */ case   43:  		/* bc 12, CR6_LT, -120 */
		/* 820AF6B0h case   43:*/		if ( regs.CR[6].lt ) { return 0x820AF638;  }
		/* 820AF6B0h case   43:*/		return 0x820AF6B4;
		  /* 820AF6B4h */ case   44:  		/* b 736 */
		/* 820AF6B4h case   44:*/		return 0x820AF994;
		/* 820AF6B4h case   44:*/		return 0x820AF6B8;
	}
	return 0x820AF6B8;
} // Block from 820AF604h-820AF6B8h (45 instructions)

//////////////////////////////////////////////////////
// Block at 820AF6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF6B8);
		  /* 820AF6B8h */ case    0:  		/* lis R27, 12288 */
		/* 820AF6B8h case    0:*/		cpu::op::lis<0>(regs,&regs.R27,0x3000);
		/* 820AF6B8h case    0:*/		return 0x820AF6BC;
		  /* 820AF6BCh */ case    1:  		/* cmplw CR6, R10, R27 */
		/* 820AF6BCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R27);
		/* 820AF6BCh case    1:*/		return 0x820AF6C0;
		  /* 820AF6C0h */ case    2:  		/* bc 4, CR6_EQ, 300 */
		/* 820AF6C0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AF7EC;  }
		/* 820AF6C0h case    2:*/		return 0x820AF6C4;
		  /* 820AF6C4h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 820AF6C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820AF6C4h case    3:*/		return 0x820AF6C8;
		  /* 820AF6C8h */ case    4:  		/* rlwinm R9, R30, 2, 0, 29 */
		/* 820AF6C8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R30);
		/* 820AF6C8h case    4:*/		return 0x820AF6CC;
		  /* 820AF6CCh */ case    5:  		/* lwz R8, <#[R31 + 8]> */
		/* 820AF6CCh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF6CCh case    5:*/		return 0x820AF6D0;
		  /* 820AF6D0h */ case    6:  		/* addi R5, R1, 128 */
		/* 820AF6D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820AF6D0h case    6:*/		return 0x820AF6D4;
		  /* 820AF6D4h */ case    7:  		/* rlwinm R10, R11, 1, 0, 30 */
		/* 820AF6D4h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R11);
		/* 820AF6D4h case    7:*/		return 0x820AF6D8;
		  /* 820AF6D8h */ case    8:  		/* add R11, R11, R30 */
		/* 820AF6D8h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820AF6D8h case    8:*/		return 0x820AF6DC;
		  /* 820AF6DCh */ case    9:  		/* add R10, R10, R30 */
		/* 820AF6DCh case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 820AF6DCh case    9:*/		return 0x820AF6E0;
		  /* 820AF6E0h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AF6E0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AF6E0h case   10:*/		return 0x820AF6E4;
		  /* 820AF6E4h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AF6E4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AF6E4h case   11:*/		return 0x820AF6E8;
		  /* 820AF6E8h */ case   12:  		/* lwzx R30, <#[R9 + R8]> */
		/* 820AF6E8h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820AF6E8h case   12:*/		return 0x820AF6EC;
		  /* 820AF6ECh */ case   13:  		/* mr R3, R26 */
		/* 820AF6ECh case   13:*/		regs.R3 = regs.R26;
		/* 820AF6ECh case   13:*/		return 0x820AF6F0;
		  /* 820AF6F0h */ case   14:  		/* mr R4, R30 */
		/* 820AF6F0h case   14:*/		regs.R4 = regs.R30;
		/* 820AF6F0h case   14:*/		return 0x820AF6F4;
		  /* 820AF6F4h */ case   15:  		/* lwzx R29, <#[R11 + R8]> */
		/* 820AF6F4h case   15:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820AF6F4h case   15:*/		return 0x820AF6F8;
		  /* 820AF6F8h */ case   16:  		/* lwzx R28, <#[R10 + R8]> */
		/* 820AF6F8h case   16:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820AF6F8h case   16:*/		return 0x820AF6FC;
		  /* 820AF6FCh */ case   17:  		/* bl -3076 */
		/* 820AF6FCh case   17:*/		regs.LR = 0x820AF700; return 0x820AEAF8;
		/* 820AF6FCh case   17:*/		return 0x820AF700;
		  /* 820AF700h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820AF700h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF700h case   18:*/		return 0x820AF704;
		  /* 820AF704h */ case   19:  		/* bc 12, CR0_LT, 552 */
		/* 820AF704h case   19:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF704h case   19:*/		return 0x820AF708;
		  /* 820AF708h */ case   20:  		/* addi R5, R1, 112 */
		/* 820AF708h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820AF708h case   20:*/		return 0x820AF70C;
		  /* 820AF70Ch */ case   21:  		/* mr R4, R29 */
		/* 820AF70Ch case   21:*/		regs.R4 = regs.R29;
		/* 820AF70Ch case   21:*/		return 0x820AF710;
		  /* 820AF710h */ case   22:  		/* mr R3, R26 */
		/* 820AF710h case   22:*/		regs.R3 = regs.R26;
		/* 820AF710h case   22:*/		return 0x820AF714;
		  /* 820AF714h */ case   23:  		/* bl -3100 */
		/* 820AF714h case   23:*/		regs.LR = 0x820AF718; return 0x820AEAF8;
		/* 820AF714h case   23:*/		return 0x820AF718;
		  /* 820AF718h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820AF718h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF718h case   24:*/		return 0x820AF71C;
		  /* 820AF71Ch */ case   25:  		/* bc 12, CR0_LT, 528 */
		/* 820AF71Ch case   25:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF71Ch case   25:*/		return 0x820AF720;
		  /* 820AF720h */ case   26:  		/* addi R5, R1, 80 */
		/* 820AF720h case   26:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820AF720h case   26:*/		return 0x820AF724;
		  /* 820AF724h */ case   27:  		/* mr R4, R28 */
		/* 820AF724h case   27:*/		regs.R4 = regs.R28;
		/* 820AF724h case   27:*/		return 0x820AF728;
		  /* 820AF728h */ case   28:  		/* mr R3, R26 */
		/* 820AF728h case   28:*/		regs.R3 = regs.R26;
		/* 820AF728h case   28:*/		return 0x820AF72C;
		  /* 820AF72Ch */ case   29:  		/* bl -3124 */
		/* 820AF72Ch case   29:*/		regs.LR = 0x820AF730; return 0x820AEAF8;
		/* 820AF72Ch case   29:*/		return 0x820AF730;
		  /* 820AF730h */ case   30:  		/* cmpwi CR0, R3, 0 */
		/* 820AF730h case   30:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF730h case   30:*/		return 0x820AF734;
		  /* 820AF734h */ case   31:  		/* bc 12, CR0_LT, 504 */
		/* 820AF734h case   31:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF734h case   31:*/		return 0x820AF738;
		  /* 820AF738h */ case   32:  		/* lwz R11, <#[R31]> */
		/* 820AF738h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AF738h case   32:*/		return 0x820AF73C;
		  /* 820AF73Ch */ case   33:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820AF73Ch case   33:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820AF73Ch case   33:*/		return 0x820AF740;
		  /* 820AF740h */ case   34:  		/* cmplw CR6, R11, R27 */
		/* 820AF740h case   34:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820AF740h case   34:*/		return 0x820AF744;
		  /* 820AF744h */ case   35:  		/* bc 4, CR6_EQ, 592 */
		/* 820AF744h case   35:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF744h case   35:*/		return 0x820AF748;
		  /* 820AF748h */ case   36:  		/* lfd FR30, <#[R1 + 112]> */
		/* 820AF748h case   36:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF748h case   36:*/		return 0x820AF74C;
		  /* 820AF74Ch */ case   37:  		/* cmplw CR6, R30, R29 */
		/* 820AF74Ch case   37:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 820AF74Ch case   37:*/		return 0x820AF750;
		  /* 820AF750h */ case   38:  		/* bc 4, CR6_EQ, 36 */
		/* 820AF750h case   38:*/		if ( !regs.CR[6].eq ) { return 0x820AF774;  }
		/* 820AF750h case   38:*/		return 0x820AF754;
		  /* 820AF754h */ case   39:  		/* fcmpu CR6, FR30, FR27 */
		/* 820AF754h case   39:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR27);
		/* 820AF754h case   39:*/		return 0x820AF758;
		  /* 820AF758h */ case   40:  		/* bc 4, CR6_LT, 8 */
		/* 820AF758h case   40:*/		if ( !regs.CR[6].lt ) { return 0x820AF760;  }
		/* 820AF758h case   40:*/		return 0x820AF75C;
		  /* 820AF75Ch */ case   41:  		/* fmr FR30, FR27 */
		/* 820AF75Ch case   41:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF75Ch case   41:*/		return 0x820AF760;
	}
	return 0x820AF760;
} // Block from 820AF6B8h-820AF760h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820AF760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF760);
		  /* 820AF760h */ case    0:  		/* lfd FR31, <#[R1 + 120]> */
		/* 820AF760h case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF760h case    0:*/		return 0x820AF764;
		  /* 820AF764h */ case    1:  		/* fcmpu CR6, FR31, FR27 */
		/* 820AF764h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR27);
		/* 820AF764h case    1:*/		return 0x820AF768;
		  /* 820AF768h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 820AF768h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820AF778;  }
		/* 820AF768h case    2:*/		return 0x820AF76C;
		  /* 820AF76Ch */ case    3:  		/* fmr FR31, FR27 */
		/* 820AF76Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR27);
		/* 820AF76Ch case    3:*/		return 0x820AF770;
		  /* 820AF770h */ case    4:  		/* b 8 */
		/* 820AF770h case    4:*/		return 0x820AF778;
		/* 820AF770h case    4:*/		return 0x820AF774;
	}
	return 0x820AF774;
} // Block from 820AF760h-820AF774h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF774);
		  /* 820AF774h */ case    0:  		/* lfd FR31, <#[R1 + 120]> */
		/* 820AF774h case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF774h case    0:*/		return 0x820AF778;
	}
	return 0x820AF778;
} // Block from 820AF774h-820AF778h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF778);
		  /* 820AF778h */ case    0:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820AF778h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AF778h case    0:*/		return 0x820AF77C;
		  /* 820AF77Ch */ case    1:  		/* cmplw CR6, R30, R28 */
		/* 820AF77Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R28);
		/* 820AF77Ch case    1:*/		return 0x820AF780;
		  /* 820AF780h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 820AF780h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AF7A4;  }
		/* 820AF780h case    2:*/		return 0x820AF784;
		  /* 820AF784h */ case    3:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF784h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF784h case    3:*/		return 0x820AF788;
		  /* 820AF788h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820AF788h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820AF790;  }
		/* 820AF788h case    4:*/		return 0x820AF78C;
		  /* 820AF78Ch */ case    5:  		/* fmr FR0, FR27 */
		/* 820AF78Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR27);
		/* 820AF78Ch case    5:*/		return 0x820AF790;
	}
	return 0x820AF790;
} // Block from 820AF778h-820AF790h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AF790h
// Function '?EvalValueNoRecurse@CCompiler@D3DXShader@@IAAJIPAN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF790);
		  /* 820AF790h */ case    0:  		/* lfd FR13, <#[R1 + 88]> */
		/* 820AF790h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF790h case    0:*/		return 0x820AF794;
		  /* 820AF794h */ case    1:  		/* fcmpu CR6, FR13, FR27 */
		/* 820AF794h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR27);
		/* 820AF794h case    1:*/		return 0x820AF798;
		  /* 820AF798h */ case    2:  		/* bc 4, CR6_GT, 16 */
		/* 820AF798h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820AF7A8;  }
		/* 820AF798h case    2:*/		return 0x820AF79C;
		  /* 820AF79Ch */ case    3:  		/* fmr FR13, FR27 */
		/* 820AF79Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR27);
		/* 820AF79Ch case    3:*/		return 0x820AF7A0;
		  /* 820AF7A0h */ case    4:  		/* b 8 */
		/* 820AF7A0h case    4:*/		return 0x820AF7A8;
		/* 820AF7A0h case    4:*/		return 0x820AF7A4;
	}
	return 0x820AF7A4;
} // Block from 820AF790h-820AF7A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF7A4);
		  /* 820AF7A4h */ case    0:  		/* lfd FR13, <#[R1 + 88]> */
		/* 820AF7A4h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 820AF7A4h case    0:*/		return 0x820AF7A8;
	}
	return 0x820AF7A8;
} // Block from 820AF7A4h-820AF7A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF7A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF7A8);
		  /* 820AF7A8h */ case    0:  		/* lfd FR12, <#[R1 + 128]> */
		/* 820AF7A8h case    0:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000080) );
		/* 820AF7A8h case    0:*/		return 0x820AF7AC;
		  /* 820AF7ACh */ case    1:  		/* fcmpu CR6, FR12, FR27 */
		/* 820AF7ACh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR27);
		/* 820AF7ACh case    1:*/		return 0x820AF7B0;
		  /* 820AF7B0h */ case    2:  		/* bc 4, CR6_LT, 476 */
		/* 820AF7B0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820AF98C;  }
		/* 820AF7B0h case    2:*/		return 0x820AF7B4;
		  /* 820AF7B4h */ case    3:  		/* lfd FR12, <#[R1 + 136]> */
		/* 820AF7B4h case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000088) );
		/* 820AF7B4h case    3:*/		return 0x820AF7B8;
		  /* 820AF7B8h */ case    4:  		/* fcmpu CR6, FR12, FR27 */
		/* 820AF7B8h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR27);
		/* 820AF7B8h case    4:*/		return 0x820AF7BC;
		  /* 820AF7BCh */ case    5:  		/* bc 4, CR6_LT, 16 */
		/* 820AF7BCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x820AF7CC;  }
		/* 820AF7BCh case    5:*/		return 0x820AF7C0;
		  /* 820AF7C0h */ case    6:  		/* fmr FR30, FR0 */
		/* 820AF7C0h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR0);
		/* 820AF7C0h case    6:*/		return 0x820AF7C4;
		  /* 820AF7C4h */ case    7:  		/* fmr FR31, FR13 */
		/* 820AF7C4h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR13);
		/* 820AF7C4h case    7:*/		return 0x820AF7C8;
		  /* 820AF7C8h */ case    8:  		/* b 452 */
		/* 820AF7C8h case    8:*/		return 0x820AF98C;
		/* 820AF7C8h case    8:*/		return 0x820AF7CC;
	}
	return 0x820AF7CC;
} // Block from 820AF7A8h-820AF7CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AF7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF7CC);
		  /* 820AF7CCh */ case    0:  		/* fcmpu CR6, FR30, FR0 */
		/* 820AF7CCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR0);
		/* 820AF7CCh case    0:*/		return 0x820AF7D0;
		  /* 820AF7D0h */ case    1:  		/* bc 12, CR6_LT, 8 */
		/* 820AF7D0h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AF7D8;  }
		/* 820AF7D0h case    1:*/		return 0x820AF7D4;
		  /* 820AF7D4h */ case    2:  		/* fmr FR30, FR0 */
		/* 820AF7D4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR0);
		/* 820AF7D4h case    2:*/		return 0x820AF7D8;
	}
	return 0x820AF7D8;
} // Block from 820AF7CCh-820AF7D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AF7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF7D8);
		  /* 820AF7D8h */ case    0:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF7D8h case    0:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF7D8h case    0:*/		return 0x820AF7DC;
		  /* 820AF7DCh */ case    1:  		/* fcmpu CR6, FR31, FR13 */
		/* 820AF7DCh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR13);
		/* 820AF7DCh case    1:*/		return 0x820AF7E0;
		  /* 820AF7E0h */ case    2:  		/* bc 12, CR6_GT, 432 */
		/* 820AF7E0h case    2:*/		if ( regs.CR[6].gt ) { return 0x820AF990;  }
		/* 820AF7E0h case    2:*/		return 0x820AF7E4;
		  /* 820AF7E4h */ case    3:  		/* fmr FR31, FR13 */
		/* 820AF7E4h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR13);
		/* 820AF7E4h case    3:*/		return 0x820AF7E8;
		  /* 820AF7E8h */ case    4:  		/* b 424 */
		/* 820AF7E8h case    4:*/		return 0x820AF990;
		/* 820AF7E8h case    4:*/		return 0x820AF7EC;
	}
	return 0x820AF7EC;
} // Block from 820AF7D8h-820AF7ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF7EC);
		  /* 820AF7ECh */ case    0:  		/* lis R11, 20496 */
		/* 820AF7ECh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5010);
		/* 820AF7ECh case    0:*/		return 0x820AF7F0;
		  /* 820AF7F0h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 820AF7F0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820AF7F0h case    1:*/		return 0x820AF7F4;
		  /* 820AF7F4h */ case    2:  		/* bc 4, CR6_EQ, 272 */
		/* 820AF7F4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AF904;  }
		/* 820AF7F4h case    2:*/		return 0x820AF7F8;
		  /* 820AF7F8h */ case    3:  		/* cmplwi CR6, R30, 1 */
		/* 820AF7F8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 820AF7F8h case    3:*/		return 0x820AF7FC;
		  /* 820AF7FCh */ case    4:  		/* bc 12, CR6_LT, -864 */
		/* 820AF7FCh case    4:*/		if ( regs.CR[6].lt ) { return 0x820AF49C;  }
		/* 820AF7FCh case    4:*/		return 0x820AF800;
		  /* 820AF800h */ case    5:  		/* bc 12, CR6_EQ, 196 */
		/* 820AF800h case    5:*/		if ( regs.CR[6].eq ) { return 0x820AF8C4;  }
		/* 820AF800h case    5:*/		return 0x820AF804;
		  /* 820AF804h */ case    6:  		/* cmplwi CR6, R30, 3 */
		/* 820AF804h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000003);
		/* 820AF804h case    6:*/		return 0x820AF808;
		  /* 820AF808h */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 820AF808h case    7:*/		if ( regs.CR[6].lt ) { return 0x820AF814;  }
		/* 820AF808h case    7:*/		return 0x820AF80C;
		  /* 820AF80Ch */ case    8:  		/* bc 4, CR6_EQ, 392 */
		/* 820AF80Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF80Ch case    8:*/		return 0x820AF810;
		  /* 820AF810h */ case    9:  		/* b -884 */
		/* 820AF810h case    9:*/		return 0x820AF49C;
		/* 820AF810h case    9:*/		return 0x820AF814;
	}
	return 0x820AF814;
} // Block from 820AF7ECh-820AF814h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AF814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF814);
		  /* 820AF814h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF814h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF814h case    0:*/		return 0x820AF818;
		  /* 820AF818h */ case    1:  		/* addi R5, R1, 112 */
		/* 820AF818h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820AF818h case    1:*/		return 0x820AF81C;
		  /* 820AF81Ch */ case    2:  		/* mr R3, R26 */
		/* 820AF81Ch case    2:*/		regs.R3 = regs.R26;
		/* 820AF81Ch case    2:*/		return 0x820AF820;
		  /* 820AF820h */ case    3:  		/* lwz R4, <#[R11]> */
		/* 820AF820h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820AF820h case    3:*/		return 0x820AF824;
		  /* 820AF824h */ case    4:  		/* bl -3372 */
		/* 820AF824h case    4:*/		regs.LR = 0x820AF828; return 0x820AEAF8;
		/* 820AF824h case    4:*/		return 0x820AF828;
		  /* 820AF828h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820AF828h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF828h case    5:*/		return 0x820AF82C;
		  /* 820AF82Ch */ case    6:  		/* bc 12, CR0_LT, 256 */
		/* 820AF82Ch case    6:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF82Ch case    6:*/		return 0x820AF830;
		  /* 820AF830h */ case    7:  		/* lfd FR0, <#[R1 + 120]> */
		/* 820AF830h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF830h case    7:*/		return 0x820AF834;
		  /* 820AF834h */ case    8:  		/* fcmpu CR6, FR0, FR27 */
		/* 820AF834h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR27);
		/* 820AF834h case    8:*/		return 0x820AF838;
		  /* 820AF838h */ case    9:  		/* bc 4, CR6_GT, -1404 */
		/* 820AF838h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820AF2BC;  }
		/* 820AF838h case    9:*/		return 0x820AF83C;
		  /* 820AF83Ch */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF83Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF83Ch case   10:*/		return 0x820AF840;
		  /* 820AF840h */ case   11:  		/* addi R5, R1, 128 */
		/* 820AF840h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820AF840h case   11:*/		return 0x820AF844;
		  /* 820AF844h */ case   12:  		/* mr R3, R26 */
		/* 820AF844h case   12:*/		regs.R3 = regs.R26;
		/* 820AF844h case   12:*/		return 0x820AF848;
		  /* 820AF848h */ case   13:  		/* lwz R4, <#[R11 + 4]> */
		/* 820AF848h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820AF848h case   13:*/		return 0x820AF84C;
		  /* 820AF84Ch */ case   14:  		/* bl -3412 */
		/* 820AF84Ch case   14:*/		regs.LR = 0x820AF850; return 0x820AEAF8;
		/* 820AF84Ch case   14:*/		return 0x820AF850;
		  /* 820AF850h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820AF850h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF850h case   15:*/		return 0x820AF854;
		  /* 820AF854h */ case   16:  		/* bc 12, CR0_LT, 216 */
		/* 820AF854h case   16:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF854h case   16:*/		return 0x820AF858;
	}
	return 0x820AF858;
} // Block from 820AF814h-820AF858h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820AF858h
// Function '?EvalRange@CCompiler@D3DXShader@@IAAJIPAU_D3DXRANGE@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF858);
		  /* 820AF858h */ case    0:  		/* lfd FR31, <#[R1 + 136]> */
		/* 820AF858h case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000088) );
		/* 820AF858h case    0:*/		return 0x820AF85C;
		  /* 820AF85Ch */ case    1:  		/* fcmpu CR6, FR31, FR27 */
		/* 820AF85Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR27);
		/* 820AF85Ch case    1:*/		return 0x820AF860;
		  /* 820AF860h */ case    2:  		/* bc 4, CR6_GT, -1444 */
		/* 820AF860h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820AF2BC;  }
		/* 820AF860h case    2:*/		return 0x820AF864;
		  /* 820AF864h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF864h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF864h case    3:*/		return 0x820AF868;
		  /* 820AF868h */ case    4:  		/* addi R5, R1, 112 */
		/* 820AF868h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820AF868h case    4:*/		return 0x820AF86C;
		  /* 820AF86Ch */ case    5:  		/* mr R3, R26 */
		/* 820AF86Ch case    5:*/		regs.R3 = regs.R26;
		/* 820AF86Ch case    5:*/		return 0x820AF870;
		  /* 820AF870h */ case    6:  		/* lwz R4, <#[R11 + 12]> */
		/* 820AF870h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 820AF870h case    6:*/		return 0x820AF874;
		  /* 820AF874h */ case    7:  		/* bl -3452 */
		/* 820AF874h case    7:*/		regs.LR = 0x820AF878; return 0x820AEAF8;
		/* 820AF874h case    7:*/		return 0x820AF878;
		  /* 820AF878h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820AF878h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF878h case    8:*/		return 0x820AF87C;
		  /* 820AF87Ch */ case    9:  		/* bc 12, CR0_LT, 176 */
		/* 820AF87Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF87Ch case    9:*/		return 0x820AF880;
		  /* 820AF880h */ case   10:  		/* lfd FR1, <#[R1 + 128]> */
		/* 820AF880h case   10:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000080) );
		/* 820AF880h case   10:*/		return 0x820AF884;
		  /* 820AF884h */ case   11:  		/* lfd FR29, <#[R1 + 112]> */
		/* 820AF884h case   11:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF884h case   11:*/		return 0x820AF888;
		  /* 820AF888h */ case   12:  		/* fcmpu CR6, FR1, FR26 */
		/* 820AF888h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR26);
		/* 820AF888h case   12:*/		return 0x820AF88C;
		  /* 820AF88Ch */ case   13:  		/* lfd FR28, <#[R1 + 120]> */
		/* 820AF88Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR28, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF88Ch case   13:*/		return 0x820AF890;
		  /* 820AF890h */ case   14:  		/* bc 4, CR6_LT, 12 */
		/* 820AF890h case   14:*/		if ( !regs.CR[6].lt ) { return 0x820AF89C;  }
		/* 820AF890h case   14:*/		return 0x820AF894;
		  /* 820AF894h */ case   15:  		/* fmr FR2, FR28 */
		/* 820AF894h case   15:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR28);
		/* 820AF894h case   15:*/		return 0x820AF898;
		  /* 820AF898h */ case   16:  		/* b 8 */
		/* 820AF898h case   16:*/		return 0x820AF8A0;
		/* 820AF898h case   16:*/		return 0x820AF89C;
	}
	return 0x820AF89C;
} // Block from 820AF858h-820AF89Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820AF89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF89C);
		  /* 820AF89Ch */ case    0:  		/* fmr FR2, FR29 */
		/* 820AF89Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR29);
		/* 820AF89Ch case    0:*/		return 0x820AF8A0;
	}
	return 0x820AF8A0;
} // Block from 820AF89Ch-820AF8A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF8A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF8A0);
		  /* 820AF8A0h */ case    0:  		/* bl -119528 */
		/* 820AF8A0h case    0:*/		regs.LR = 0x820AF8A4; return 0x820925B8;
		/* 820AF8A0h case    0:*/		return 0x820AF8A4;
		  /* 820AF8A4h */ case    1:  		/* stfd FR1, <#[R1 + 96]> */
		/* 820AF8A4h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF8A4h case    1:*/		return 0x820AF8A8;
		  /* 820AF8A8h */ case    2:  		/* fmr FR30, FR1 */
		/* 820AF8A8h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 820AF8A8h case    2:*/		return 0x820AF8AC;
		  /* 820AF8ACh */ case    3:  		/* fcmpu CR6, FR31, FR26 */
		/* 820AF8ACh case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR26);
		/* 820AF8ACh case    3:*/		return 0x820AF8B0;
		  /* 820AF8B0h */ case    4:  		/* bc 4, CR6_LT, 12 */
		/* 820AF8B0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x820AF8BC;  }
		/* 820AF8B0h case    4:*/		return 0x820AF8B4;
		  /* 820AF8B4h */ case    5:  		/* fmr FR2, FR29 */
		/* 820AF8B4h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR29);
		/* 820AF8B4h case    5:*/		return 0x820AF8B8;
		  /* 820AF8B8h */ case    6:  		/* b -1928 */
		/* 820AF8B8h case    6:*/		return 0x820AF130;
		/* 820AF8B8h case    6:*/		return 0x820AF8BC;
	}
	return 0x820AF8BC;
} // Block from 820AF8A0h-820AF8BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AF8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF8BC);
		  /* 820AF8BCh */ case    0:  		/* fmr FR2, FR28 */
		/* 820AF8BCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR28);
		/* 820AF8BCh case    0:*/		return 0x820AF8C0;
		  /* 820AF8C0h */ case    1:  		/* b -1936 */
		/* 820AF8C0h case    1:*/		return 0x820AF130;
		/* 820AF8C0h case    1:*/		return 0x820AF8C4;
	}
	return 0x820AF8C4;
} // Block from 820AF8BCh-820AF8C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AF8C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF8C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF8C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF8C4);
		  /* 820AF8C4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF8C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF8C4h case    0:*/		return 0x820AF8C8;
		  /* 820AF8C8h */ case    1:  		/* addi R5, R1, 112 */
		/* 820AF8C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 820AF8C8h case    1:*/		return 0x820AF8CC;
		  /* 820AF8CCh */ case    2:  		/* mr R3, R26 */
		/* 820AF8CCh case    2:*/		regs.R3 = regs.R26;
		/* 820AF8CCh case    2:*/		return 0x820AF8D0;
		  /* 820AF8D0h */ case    3:  		/* lwz R4, <#[R11]> */
		/* 820AF8D0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820AF8D0h case    3:*/		return 0x820AF8D4;
		  /* 820AF8D4h */ case    4:  		/* bl -3548 */
		/* 820AF8D4h case    4:*/		regs.LR = 0x820AF8D8; return 0x820AEAF8;
		/* 820AF8D4h case    4:*/		return 0x820AF8D8;
		  /* 820AF8D8h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820AF8D8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF8D8h case    5:*/		return 0x820AF8DC;
		  /* 820AF8DCh */ case    6:  		/* bc 12, CR0_LT, 80 */
		/* 820AF8DCh case    6:*/		if ( regs.CR[0].lt ) { return 0x820AF92C;  }
		/* 820AF8DCh case    6:*/		return 0x820AF8E0;
		  /* 820AF8E0h */ case    7:  		/* lfd FR30, <#[R1 + 112]> */
		/* 820AF8E0h case    7:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000070) );
		/* 820AF8E0h case    7:*/		return 0x820AF8E4;
		  /* 820AF8E4h */ case    8:  		/* lfd FR31, <#[R1 + 120]> */
		/* 820AF8E4h case    8:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000078) );
		/* 820AF8E4h case    8:*/		return 0x820AF8E8;
		  /* 820AF8E8h */ case    9:  		/* fcmpu CR6, FR30, FR27 */
		/* 820AF8E8h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR27);
		/* 820AF8E8h case    9:*/		return 0x820AF8EC;
		  /* 820AF8ECh */ case   10:  		/* bc 12, CR6_GT, 160 */
		/* 820AF8ECh case   10:*/		if ( regs.CR[6].gt ) { return 0x820AF98C;  }
		/* 820AF8ECh case   10:*/		return 0x820AF8F0;
		  /* 820AF8F0h */ case   11:  		/* stfd FR27, <#[R1 + 96]> */
		/* 820AF8F0h case   11:*/		cpu::mem::store64f( regs, regs.FR27, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF8F0h case   11:*/		return 0x820AF8F4;
		  /* 820AF8F4h */ case   12:  		/* fcmpu CR6, FR31, FR27 */
		/* 820AF8F4h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR27);
		/* 820AF8F4h case   12:*/		return 0x820AF8F8;
		  /* 820AF8F8h */ case   13:  		/* fmr FR30, FR27 */
		/* 820AF8F8h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF8F8h case   13:*/		return 0x820AF8FC;
		  /* 820AF8FCh */ case   14:  		/* bc 12, CR6_GT, 148 */
		/* 820AF8FCh case   14:*/		if ( regs.CR[6].gt ) { return 0x820AF990;  }
		/* 820AF8FCh case   14:*/		return 0x820AF900;
		  /* 820AF900h */ case   15:  		/* b -1804 */
		/* 820AF900h case   15:*/		return 0x820AF1F4;
		/* 820AF900h case   15:*/		return 0x820AF904;
	}
	return 0x820AF904;
} // Block from 820AF8C4h-820AF904h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820AF904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF904);
		  /* 820AF904h */ case    0:  		/* lis R11, 20528 */
		/* 820AF904h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5030);
		/* 820AF904h case    0:*/		return 0x820AF908;
		  /* 820AF908h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 820AF908h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820AF908h case    1:*/		return 0x820AF90C;
		  /* 820AF90Ch */ case    2:  		/* bc 4, CR6_EQ, 136 */
		/* 820AF90Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF90Ch case    2:*/		return 0x820AF910;
		  /* 820AF910h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 820AF910h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820AF910h case    3:*/		return 0x820AF914;
		  /* 820AF914h */ case    4:  		/* addi R5, R1, 128 */
		/* 820AF914h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820AF914h case    4:*/		return 0x820AF918;
		  /* 820AF918h */ case    5:  		/* mr R3, R26 */
		/* 820AF918h case    5:*/		regs.R3 = regs.R26;
		/* 820AF918h case    5:*/		return 0x820AF91C;
		  /* 820AF91Ch */ case    6:  		/* lwz R4, <#[R11]> */
		/* 820AF91Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820AF91Ch case    6:*/		return 0x820AF920;
		  /* 820AF920h */ case    7:  		/* bl -3624 */
		/* 820AF920h case    7:*/		regs.LR = 0x820AF924; return 0x820AEAF8;
		/* 820AF920h case    7:*/		return 0x820AF924;
		  /* 820AF924h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820AF924h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF924h case    8:*/		return 0x820AF928;
		  /* 820AF928h */ case    9:  		/* bc 4, CR0_LT, 32 */
		/* 820AF928h case    9:*/		if ( !regs.CR[0].lt ) { return 0x820AF948;  }
		/* 820AF928h case    9:*/		return 0x820AF92C;
	}
	return 0x820AF92C;
} // Block from 820AF904h-820AF92Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820AF92Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF92C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF92C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF92C);
		  /* 820AF92Ch */ case    0:  		/* lis R31, -32768 */
		/* 820AF92Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8000);
		/* 820AF92Ch case    0:*/		return 0x820AF930;
		  /* 820AF930h */ case    1:  		/* lfd FR30, <#[R26 + 176]> */
		/* 820AF930h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R26 + 0x000000B0) );
		/* 820AF930h case    1:*/		return 0x820AF934;
		  /* 820AF934h */ case    2:  		/* lfd FR31, <#[R26 + 168]> */
		/* 820AF934h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R26 + 0x000000A8) );
		/* 820AF934h case    2:*/		return 0x820AF938;
		  /* 820AF938h */ case    3:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF938h case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF938h case    3:*/		return 0x820AF93C;
		  /* 820AF93Ch */ case    4:  		/* ori R31, R31, 16389 */
		/* 820AF93Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x4005);
		/* 820AF93Ch case    4:*/		return 0x820AF940;
		  /* 820AF940h */ case    5:  		/* stfd FR31, <#[R1 + 104]> */
		/* 820AF940h case    5:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 820AF940h case    5:*/		return 0x820AF944;
		  /* 820AF944h */ case    6:  		/* b 84 */
		/* 820AF944h case    6:*/		return 0x820AF998;
		/* 820AF944h case    6:*/		return 0x820AF948;
	}
	return 0x820AF948;
} // Block from 820AF92Ch-820AF948h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AF948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF948);
		  /* 820AF948h */ case    0:  		/* lfd FR0, <#[R1 + 136]> */
		/* 820AF948h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 820AF948h case    0:*/		return 0x820AF94C;
		  /* 820AF94Ch */ case    1:  		/* lfd FR29, <#[R1 + 128]> */
		/* 820AF94Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0x00000080) );
		/* 820AF94Ch case    1:*/		return 0x820AF950;
		  /* 820AF950h */ case    2:  		/* fcmpu CR6, FR29, FR0 */
		/* 820AF950h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR0);
		/* 820AF950h case    2:*/		return 0x820AF954;
		  /* 820AF954h */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 820AF954h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820AF984;  }
		/* 820AF954h case    3:*/		return 0x820AF958;
		  /* 820AF958h */ case    4:  		/* fmr FR1, FR29 */
		/* 820AF958h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 820AF958h case    4:*/		return 0x820AF95C;
		  /* 820AF95Ch */ case    5:  		/* bl -96652 */
		/* 820AF95Ch case    5:*/		regs.LR = 0x820AF960; return 0x82097FD0;
		/* 820AF95Ch case    5:*/		return 0x820AF960;
		  /* 820AF960h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820AF960h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AF960h case    6:*/		return 0x820AF964;
		  /* 820AF964h */ case    7:  		/* bc 12, CR0_EQ, 32 */
		/* 820AF964h case    7:*/		if ( regs.CR[0].eq ) { return 0x820AF984;  }
		/* 820AF964h case    7:*/		return 0x820AF968;
		  /* 820AF968h */ case    8:  		/* cmplwi CR6, R30, 1 */
		/* 820AF968h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 820AF968h case    8:*/		return 0x820AF96C;
		  /* 820AF96Ch */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 820AF96Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x820AF97C;  }
		/* 820AF96Ch case    9:*/		return 0x820AF970;
		  /* 820AF970h */ case   10:  		/* bc 4, CR6_EQ, 36 */
		/* 820AF970h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820AF994;  }
		/* 820AF970h case   10:*/		return 0x820AF974;
		  /* 820AF974h */ case   11:  		/* fmr FR1, FR29 */
		/* 820AF974h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 820AF974h case   11:*/		return 0x820AF978;
		  /* 820AF978h */ case   12:  		/* b -1452 */
		/* 820AF978h case   12:*/		return 0x820AF3CC;
		/* 820AF978h case   12:*/		return 0x820AF97C;
	}
	return 0x820AF97C;
} // Block from 820AF948h-820AF97Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AF97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF97C);
		  /* 820AF97Ch */ case    0:  		/* fmr FR1, FR29 */
		/* 820AF97Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 820AF97Ch case    0:*/		return 0x820AF980;
		  /* 820AF980h */ case    1:  		/* b -1504 */
		/* 820AF980h case    1:*/		return 0x820AF3A0;
		/* 820AF980h case    1:*/		return 0x820AF984;
	}
	return 0x820AF984;
} // Block from 820AF97Ch-820AF984h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AF984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF984);
		  /* 820AF984h */ case    0:  		/* fmr FR30, FR25 */
		/* 820AF984h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR25);
		/* 820AF984h case    0:*/		return 0x820AF988;
	}
	return 0x820AF988;
} // Block from 820AF984h-820AF988h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF988);
		  /* 820AF988h */ case    0:  		/* fmr FR31, FR26 */
		/* 820AF988h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR26);
		/* 820AF988h case    0:*/		return 0x820AF98C;
	}
	return 0x820AF98C;
} // Block from 820AF988h-820AF98Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF98Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF98C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF98C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF98C);
		  /* 820AF98Ch */ case    0:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF98Ch case    0:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF98Ch case    0:*/		return 0x820AF990;
	}
	return 0x820AF990;
} // Block from 820AF98Ch-820AF990h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF990);
		  /* 820AF990h */ case    0:  		/* stfd FR31, <#[R1 + 104]> */
		/* 820AF990h case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 820AF990h case    0:*/		return 0x820AF994;
	}
	return 0x820AF994;
} // Block from 820AF990h-820AF994h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF994);
		  /* 820AF994h */ case    0:  		/* li R31, 0 */
		/* 820AF994h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820AF994h case    0:*/		return 0x820AF998;
	}
	return 0x820AF998;
} // Block from 820AF994h-820AF998h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AF998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF998);
		  /* 820AF998h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 820AF998h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AF998h case    0:*/		return 0x820AF99C;
		  /* 820AF99Ch */ case    1:  		/* fcmpu CR6, FR30, FR27 */
		/* 820AF99Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR27);
		/* 820AF99Ch case    1:*/		return 0x820AF9A0;
		  /* 820AF9A0h */ case    2:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 820AF9A0h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 820AF9A0h case    2:*/		return 0x820AF9A4;
		  /* 820AF9A4h */ case    3:  		/* bc 12, CR0_EQ, 36 */
		/* 820AF9A4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AF9C8;  }
		/* 820AF9A4h case    3:*/		return 0x820AF9A8;
		  /* 820AF9A8h */ case    4:  		/* bc 12, CR6_GT, 12 */
		/* 820AF9A8h case    4:*/		if ( regs.CR[6].gt ) { return 0x820AF9B4;  }
		/* 820AF9A8h case    4:*/		return 0x820AF9AC;
		  /* 820AF9ACh */ case    5:  		/* stfd FR27, <#[R1 + 96]> */
		/* 820AF9ACh case    5:*/		cpu::mem::store64f( regs, regs.FR27, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF9ACh case    5:*/		return 0x820AF9B0;
		  /* 820AF9B0h */ case    6:  		/* fmr FR30, FR27 */
		/* 820AF9B0h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR27);
		/* 820AF9B0h case    6:*/		return 0x820AF9B4;
	}
	return 0x820AF9B4;
} // Block from 820AF998h-820AF9B4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AF9B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF9B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF9B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF9B4);
		  /* 820AF9B4h */ case    0:  		/* fcmpu CR6, FR31, FR27 */
		/* 820AF9B4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR27);
		/* 820AF9B4h case    0:*/		return 0x820AF9B8;
		  /* 820AF9B8h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 820AF9B8h case    1:*/		if ( regs.CR[6].gt ) { return 0x820AF9D4;  }
		/* 820AF9B8h case    1:*/		return 0x820AF9BC;
		  /* 820AF9BCh */ case    2:  		/* stfd FR27, <#[R1 + 104]> */
		/* 820AF9BCh case    2:*/		cpu::mem::store64f( regs, regs.FR27, (uint32)(regs.R1 + 0x00000068) );
		/* 820AF9BCh case    2:*/		return 0x820AF9C0;
		  /* 820AF9C0h */ case    3:  		/* fmr FR31, FR27 */
		/* 820AF9C0h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR27);
		/* 820AF9C0h case    3:*/		return 0x820AF9C4;
		  /* 820AF9C4h */ case    4:  		/* b 16 */
		/* 820AF9C4h case    4:*/		return 0x820AF9D4;
		/* 820AF9C4h case    4:*/		return 0x820AF9C8;
	}
	return 0x820AF9C8;
} // Block from 820AF9B4h-820AF9C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AF9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF9C8);
		  /* 820AF9C8h */ case    0:  		/* bc 12, CR6_LT, 12 */
		/* 820AF9C8h case    0:*/		if ( regs.CR[6].lt ) { return 0x820AF9D4;  }
		/* 820AF9C8h case    0:*/		return 0x820AF9CC;
		  /* 820AF9CCh */ case    1:  		/* ori R11, R11, 4 */
		/* 820AF9CCh case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820AF9CCh case    1:*/		return 0x820AF9D0;
		  /* 820AF9D0h */ case    2:  		/* stw R11, <#[R25]> */
		/* 820AF9D0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AF9D0h case    2:*/		return 0x820AF9D4;
	}
	return 0x820AF9D4;
} // Block from 820AF9C8h-820AF9D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820AF9D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF9D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF9D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF9D4);
		  /* 820AF9D4h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 820AF9D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AF9D4h case    0:*/		return 0x820AF9D8;
		  /* 820AF9D8h */ case    1:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 820AF9D8h case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 820AF9D8h case    1:*/		return 0x820AF9DC;
		  /* 820AF9DCh */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 820AF9DCh case    2:*/		if ( regs.CR[0].eq ) { return 0x820AF9F4;  }
		/* 820AF9DCh case    2:*/		return 0x820AF9E0;
		  /* 820AF9E0h */ case    3:  		/* fsel FR30, FR30, FR27, FR30 */
		/* 820AF9E0h case    3:*/		cpu::op::fsel<0>(regs,&regs.FR30,regs.FR30,regs.FR27,regs.FR30);
		/* 820AF9E0h case    3:*/		return 0x820AF9E4;
		  /* 820AF9E4h */ case    4:  		/* stfd FR30, <#[R1 + 96]> */
		/* 820AF9E4h case    4:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0x00000060) );
		/* 820AF9E4h case    4:*/		return 0x820AF9E8;
		  /* 820AF9E8h */ case    5:  		/* fsel FR31, FR31, FR27, FR31 */
		/* 820AF9E8h case    5:*/		cpu::op::fsel<0>(regs,&regs.FR31,regs.FR31,regs.FR27,regs.FR31);
		/* 820AF9E8h case    5:*/		return 0x820AF9EC;
		  /* 820AF9ECh */ case    6:  		/* stfd FR31, <#[R1 + 104]> */
		/* 820AF9ECh case    6:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 820AF9ECh case    6:*/		return 0x820AF9F0;
		  /* 820AF9F0h */ case    7:  		/* b 20 */
		/* 820AF9F0h case    7:*/		return 0x820AFA04;
		/* 820AF9F0h case    7:*/		return 0x820AF9F4;
	}
	return 0x820AF9F4;
} // Block from 820AF9D4h-820AF9F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AF9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AF9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AF9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AF9F4);
		  /* 820AF9F4h */ case    0:  		/* fcmpu CR6, FR31, FR27 */
		/* 820AF9F4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR27);
		/* 820AF9F4h case    0:*/		return 0x820AF9F8;
		  /* 820AF9F8h */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 820AF9F8h case    1:*/		if ( regs.CR[6].gt ) { return 0x820AFA04;  }
		/* 820AF9F8h case    1:*/		return 0x820AF9FC;
		  /* 820AF9FCh */ case    2:  		/* ori R11, R11, 8 */
		/* 820AF9FCh case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820AF9FCh case    2:*/		return 0x820AFA00;
		  /* 820AFA00h */ case    3:  		/* stw R11, <#[R25]> */
		/* 820AFA00h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFA00h case    3:*/		return 0x820AFA04;
	}
	return 0x820AFA04;
} // Block from 820AF9F4h-820AFA04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AFA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFA04);
		  /* 820AFA04h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 820AFA04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFA04h case    0:*/		return 0x820AFA08;
		  /* 820AFA08h */ case    1:  		/* fcmpu CR6, FR30, FR25 */
		/* 820AFA08h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR25);
		/* 820AFA08h case    1:*/		return 0x820AFA0C;
		  /* 820AFA0Ch */ case    2:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820AFA0Ch case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820AFA0Ch case    2:*/		return 0x820AFA10;
		  /* 820AFA10h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 820AFA10h case    3:*/		if ( regs.CR[0].eq ) { return 0x820AFA54;  }
		/* 820AFA10h case    3:*/		return 0x820AFA14;
		  /* 820AFA14h */ case    4:  		/* bc 12, CR6_GT, 12 */
		/* 820AFA14h case    4:*/		if ( regs.CR[6].gt ) { return 0x820AFA20;  }
		/* 820AFA14h case    4:*/		return 0x820AFA18;
		  /* 820AFA18h */ case    5:  		/* stfd FR25, <#[R1 + 96]> */
		/* 820AFA18h case    5:*/		cpu::mem::store64f( regs, regs.FR25, (uint32)(regs.R1 + 0x00000060) );
		/* 820AFA18h case    5:*/		return 0x820AFA1C;
		  /* 820AFA1Ch */ case    6:  		/* fmr FR30, FR25 */
		/* 820AFA1Ch case    6:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR25);
		/* 820AFA1Ch case    6:*/		return 0x820AFA20;
	}
	return 0x820AFA20;
} // Block from 820AFA04h-820AFA20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820AFA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFA20);
		  /* 820AFA20h */ case    0:  		/* fcmpu CR6, FR31, FR25 */
		/* 820AFA20h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR25);
		/* 820AFA20h case    0:*/		return 0x820AFA24;
		  /* 820AFA24h */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 820AFA24h case    1:*/		if ( regs.CR[6].gt ) { return 0x820AFA30;  }
		/* 820AFA24h case    1:*/		return 0x820AFA28;
		  /* 820AFA28h */ case    2:  		/* stfd FR25, <#[R1 + 104]> */
		/* 820AFA28h case    2:*/		cpu::mem::store64f( regs, regs.FR25, (uint32)(regs.R1 + 0x00000068) );
		/* 820AFA28h case    2:*/		return 0x820AFA2C;
		  /* 820AFA2Ch */ case    3:  		/* fmr FR31, FR25 */
		/* 820AFA2Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR25);
		/* 820AFA2Ch case    3:*/		return 0x820AFA30;
	}
	return 0x820AFA30;
} // Block from 820AFA20h-820AFA30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AFA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFA30);
		  /* 820AFA30h */ case    0:  		/* fcmpu CR6, FR30, FR26 */
		/* 820AFA30h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR26);
		/* 820AFA30h case    0:*/		return 0x820AFA34;
		  /* 820AFA34h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 820AFA34h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AFA40;  }
		/* 820AFA34h case    1:*/		return 0x820AFA38;
		  /* 820AFA38h */ case    2:  		/* stfd FR26, <#[R1 + 96]> */
		/* 820AFA38h case    2:*/		cpu::mem::store64f( regs, regs.FR26, (uint32)(regs.R1 + 0x00000060) );
		/* 820AFA38h case    2:*/		return 0x820AFA3C;
		  /* 820AFA3Ch */ case    3:  		/* fmr FR30, FR26 */
		/* 820AFA3Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR26);
		/* 820AFA3Ch case    3:*/		return 0x820AFA40;
	}
	return 0x820AFA40;
} // Block from 820AFA30h-820AFA40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AFA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFA40);
		  /* 820AFA40h */ case    0:  		/* fcmpu CR6, FR31, FR26 */
		/* 820AFA40h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR26);
		/* 820AFA40h case    0:*/		return 0x820AFA44;
		  /* 820AFA44h */ case    1:  		/* bc 12, CR6_LT, 36 */
		/* 820AFA44h case    1:*/		if ( regs.CR[6].lt ) { return 0x820AFA68;  }
		/* 820AFA44h case    1:*/		return 0x820AFA48;
		  /* 820AFA48h */ case    2:  		/* stfd FR26, <#[R1 + 104]> */
		/* 820AFA48h case    2:*/		cpu::mem::store64f( regs, regs.FR26, (uint32)(regs.R1 + 0x00000068) );
		/* 820AFA48h case    2:*/		return 0x820AFA4C;
		  /* 820AFA4Ch */ case    3:  		/* fmr FR31, FR26 */
		/* 820AFA4Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR26);
		/* 820AFA4Ch case    3:*/		return 0x820AFA50;
		  /* 820AFA50h */ case    4:  		/* b 24 */
		/* 820AFA50h case    4:*/		return 0x820AFA68;
		/* 820AFA50h case    4:*/		return 0x820AFA54;
	}
	return 0x820AFA54;
} // Block from 820AFA40h-820AFA54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AFA54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFA54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFA54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFA54);
		  /* 820AFA54h */ case    0:  		/* bc 12, CR6_LT, 20 */
		/* 820AFA54h case    0:*/		if ( regs.CR[6].lt ) { return 0x820AFA68;  }
		/* 820AFA54h case    0:*/		return 0x820AFA58;
		  /* 820AFA58h */ case    1:  		/* fcmpu CR6, FR31, FR26 */
		/* 820AFA58h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR26);
		/* 820AFA58h case    1:*/		return 0x820AFA5C;
		  /* 820AFA5Ch */ case    2:  		/* bc 12, CR6_GT, 12 */
		/* 820AFA5Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x820AFA68;  }
		/* 820AFA5Ch case    2:*/		return 0x820AFA60;
		  /* 820AFA60h */ case    3:  		/* ori R11, R11, 16 */
		/* 820AFA60h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820AFA60h case    3:*/		return 0x820AFA64;
		  /* 820AFA64h */ case    4:  		/* stw R11, <#[R25]> */
		/* 820AFA64h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFA64h case    4:*/		return 0x820AFA68;
	}
	return 0x820AFA68;
} // Block from 820AFA54h-820AFA68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AFA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFA68);
		  /* 820AFA68h */ case    0:  		/* fcmpu CR6, FR30, FR31 */
		/* 820AFA68h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR31);
		/* 820AFA68h case    0:*/		return 0x820AFA6C;
		  /* 820AFA6Ch */ case    1:  		/* bc 4, CR6_EQ, 116 */
		/* 820AFA6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AFAE0;  }
		/* 820AFA6Ch case    1:*/		return 0x820AFA70;
		  /* 820AFA70h */ case    2:  		/* fmr FR1, FR30 */
		/* 820AFA70h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 820AFA70h case    2:*/		return 0x820AFA74;
		  /* 820AFA74h */ case    3:  		/* bl -96932 */
		/* 820AFA74h case    3:*/		regs.LR = 0x820AFA78; return 0x82097FD0;
		/* 820AFA74h case    3:*/		return 0x820AFA78;
		  /* 820AFA78h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820AFA78h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820AFA78h case    4:*/		return 0x820AFA7C;
		  /* 820AFA7Ch */ case    5:  		/* bc 12, CR0_EQ, 100 */
		/* 820AFA7Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820AFAE0;  }
		/* 820AFA7Ch case    5:*/		return 0x820AFA80;
		  /* 820AFA80h */ case    6:  		/* lwz R11, <#[R25]> */
		/* 820AFA80h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFA80h case    6:*/		return 0x820AFA84;
		  /* 820AFA84h */ case    7:  		/* fcmpu CR6, FR30, FR27 */
		/* 820AFA84h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR27);
		/* 820AFA84h case    7:*/		return 0x820AFA88;
		  /* 820AFA88h */ case    8:  		/* ori R11, R11, 128 */
		/* 820AFA88h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820AFA88h case    8:*/		return 0x820AFA8C;
		  /* 820AFA8Ch */ case    9:  		/* stw R11, <#[R25]> */
		/* 820AFA8Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFA8Ch case    9:*/		return 0x820AFA90;
		  /* 820AFA90h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820AFA90h case   10:*/		if ( regs.CR[6].eq ) { return 0x820AFA9C;  }
		/* 820AFA90h case   10:*/		return 0x820AFA94;
		  /* 820AFA94h */ case   11:  		/* fcmpu CR6, FR30, FR26 */
		/* 820AFA94h case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR26);
		/* 820AFA94h case   11:*/		return 0x820AFA98;
		  /* 820AFA98h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 820AFA98h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820AFAA4;  }
		/* 820AFA98h case   12:*/		return 0x820AFA9C;
	}
	return 0x820AFA9C;
} // Block from 820AFA68h-820AFA9Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820AFA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFA9C);
		  /* 820AFA9Ch */ case    0:  		/* ori R11, R11, 1 */
		/* 820AFA9Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AFA9Ch case    0:*/		return 0x820AFAA0;
		  /* 820AFAA0h */ case    1:  		/* stw R11, <#[R25]> */
		/* 820AFAA0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFAA0h case    1:*/		return 0x820AFAA4;
	}
	return 0x820AFAA4;
} // Block from 820AFA9Ch-820AFAA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFAA4);
		  /* 820AFAA4h */ case    0:  		/* fctiwz FR0, FR30 */
		/* 820AFAA4h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR30);
		/* 820AFAA4h case    0:*/		return 0x820AFAA8;
		  /* 820AFAA8h */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 820AFAA8h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AFAA8h case    1:*/		return 0x820AFAAC;
		  /* 820AFAACh */ case    2:  		/* lwa R11, <#[R1 + 84]> */
		/* 820AFAACh case    2:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820AFAACh case    2:*/		return 0x820AFAB0;
		  /* 820AFAB0h */ case    3:  		/* std R11, <#[R1 + 80]> */
		/* 820AFAB0h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820AFAB0h case    3:*/		return 0x820AFAB4;
		  /* 820AFAB4h */ case    4:  		/* lis R11, -32255 */
		/* 820AFAB4h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820AFAB4h case    4:*/		return 0x820AFAB8;
		  /* 820AFAB8h */ case    5:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820AFAB8h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820AFAB8h case    5:*/		return 0x820AFABC;
		  /* 820AFABCh */ case    6:  		/* fcfid FR0, FR0 */
		/* 820AFABCh case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820AFABCh case    6:*/		return 0x820AFAC0;
		  /* 820AFAC0h */ case    7:  		/* fsub FR13, FR30, FR0 */
		/* 820AFAC0h case    7:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR30,regs.FR0);
		/* 820AFAC0h case    7:*/		return 0x820AFAC4;
		  /* 820AFAC4h */ case    8:  		/* lfd FR0, <#[R11 + 8072]> */
		/* 820AFAC4h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001F88) );
		/* 820AFAC4h case    8:*/		return 0x820AFAC8;
		  /* 820AFAC8h */ case    9:  		/* fabs FR13, FR13 */
		/* 820AFAC8h case    9:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR13);
		/* 820AFAC8h case    9:*/		return 0x820AFACC;
		  /* 820AFACCh */ case   10:  		/* fcmpu CR6, FR13, FR0 */
		/* 820AFACCh case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820AFACCh case   10:*/		return 0x820AFAD0;
		  /* 820AFAD0h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 820AFAD0h case   11:*/		if ( !regs.CR[6].lt ) { return 0x820AFAE0;  }
		/* 820AFAD0h case   11:*/		return 0x820AFAD4;
		  /* 820AFAD4h */ case   12:  		/* lwz R11, <#[R25]> */
		/* 820AFAD4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFAD4h case   12:*/		return 0x820AFAD8;
		  /* 820AFAD8h */ case   13:  		/* ori R11, R11, 2 */
		/* 820AFAD8h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820AFAD8h case   13:*/		return 0x820AFADC;
		  /* 820AFADCh */ case   14:  		/* stw R11, <#[R25]> */
		/* 820AFADCh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFADCh case   14:*/		return 0x820AFAE0;
	}
	return 0x820AFAE0;
} // Block from 820AFAA4h-820AFAE0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820AFAE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFAE0);
		  /* 820AFAE0h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 820AFAE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFAE0h case    0:*/		return 0x820AFAE4;
		  /* 820AFAE4h */ case    1:  		/* stfd FR30, <#[R25 + 32]> */
		/* 820AFAE4h case    1:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R25 + 0x00000020) );
		/* 820AFAE4h case    1:*/		return 0x820AFAE8;
		  /* 820AFAE8h */ case    2:  		/* stfd FR31, <#[R25 + 40]> */
		/* 820AFAE8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R25 + 0x00000028) );
		/* 820AFAE8h case    2:*/		return 0x820AFAEC;
		  /* 820AFAECh */ case    3:  		/* cmplwi CR6, R24, 0 */
		/* 820AFAECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820AFAECh case    3:*/		return 0x820AFAF0;
		  /* 820AFAF0h */ case    4:  		/* ori R11, R11, 256 */
		/* 820AFAF0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820AFAF0h case    4:*/		return 0x820AFAF4;
		  /* 820AFAF4h */ case    5:  		/* stw R11, <#[R25]> */
		/* 820AFAF4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820AFAF4h case    5:*/		return 0x820AFAF8;
		  /* 820AFAF8h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820AFAF8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820AFB10;  }
		/* 820AFAF8h case    6:*/		return 0x820AFAFC;
		  /* 820AFAFCh */ case    7:  		/* addi R11, R1, 96 */
		/* 820AFAFCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820AFAFCh case    7:*/		return 0x820AFB00;
		  /* 820AFB00h */ case    8:  		/* ld R10, <#[R11]> */
		/* 820AFB00h case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820AFB00h case    8:*/		return 0x820AFB04;
		  /* 820AFB04h */ case    9:  		/* ld R11, <#[R11 + 8]> */
		/* 820AFB04h case    9:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820AFB04h case    9:*/		return 0x820AFB08;
		  /* 820AFB08h */ case   10:  		/* std R10, <#[R24]> */
		/* 820AFB08h case   10:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 820AFB08h case   10:*/		return 0x820AFB0C;
		  /* 820AFB0Ch */ case   11:  		/* std R11, <#[R24 + 8]> */
		/* 820AFB0Ch case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 820AFB0Ch case   11:*/		return 0x820AFB10;
	}
	return 0x820AFB10;
} // Block from 820AFAE0h-820AFB10h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820AFB10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFB10);
		  /* 820AFB10h */ case    0:  		/* mr R3, R31 */
		/* 820AFB10h case    0:*/		regs.R3 = regs.R31;
		/* 820AFB10h case    0:*/		return 0x820AFB14;
	}
	return 0x820AFB14;
} // Block from 820AFB10h-820AFB14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AFB14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFB14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFB14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFB14);
		  /* 820AFB14h */ case    0:  		/* addi R1, R1, 272 */
		/* 820AFB14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 820AFB14h case    0:*/		return 0x820AFB18;
		  /* 820AFB18h */ case    1:  		/* addi R12, R1, -72 */
		/* 820AFB18h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFB8);
		/* 820AFB18h case    1:*/		return 0x820AFB1C;
		  /* 820AFB1Ch */ case    2:  		/* bl -124612 */
		/* 820AFB1Ch case    2:*/		regs.LR = 0x820AFB20; return 0x82091458;
		/* 820AFB1Ch case    2:*/		return 0x820AFB20;
		  /* 820AFB20h */ case    3:  		/* b -125064 */
		/* 820AFB20h case    3:*/		return 0x82091298;
		/* 820AFB20h case    3:*/		return 0x820AFB24;
		  /* 820AFB24h */ case    4:  		/* nop */
		/* 820AFB24h case    4:*/		cpu::op::nop();
		/* 820AFB24h case    4:*/		return 0x820AFB28;
		  /* 820AFB28h */ case    5:  		/* li R9, 0 */
		/* 820AFB28h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820AFB28h case    5:*/		return 0x820AFB2C;
		  /* 820AFB2Ch */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 820AFB2Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820AFB2Ch case    6:*/		return 0x820AFB30;
		  /* 820AFB30h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 820AFB30h case    7:*/		if ( regs.CR[6].eq ) { return 0x820AFB80;  }
		/* 820AFB30h case    7:*/		return 0x820AFB34;
		  /* 820AFB34h */ case    8:  		/* lwz R10, <#[R3 + 8]> */
		/* 820AFB34h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFB34h case    8:*/		return 0x820AFB38;
		  /* 820AFB38h */ case    9:  		/* lwz R8, <#[R10 + 8]> */
		/* 820AFB38h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820AFB38h case    9:*/		return 0x820AFB3C;
		  /* 820AFB3Ch */ case   10:  		/* lwz R11, <#[R4]> */
		/* 820AFB3Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820AFB3Ch case   10:*/		return 0x820AFB40;
		  /* 820AFB40h */ case   11:  		/* cmplw CR6, R11, R8 */
		/* 820AFB40h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820AFB40h case   11:*/		return 0x820AFB44;
		  /* 820AFB44h */ case   12:  		/* bc 4, CR6_LT, 20 */
		/* 820AFB44h case   12:*/		if ( !regs.CR[6].lt ) { return 0x820AFB58;  }
		/* 820AFB44h case   12:*/		return 0x820AFB48;
		  /* 820AFB48h */ case   13:  		/* lwz R7, <#[R10 + 20]> */
		/* 820AFB48h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000014) );
		/* 820AFB48h case   13:*/		return 0x820AFB4C;
		  /* 820AFB4Ch */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AFB4Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AFB4Ch case   14:*/		return 0x820AFB50;
		  /* 820AFB50h */ case   15:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820AFB50h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820AFB50h case   15:*/		return 0x820AFB54;
		  /* 820AFB54h */ case   16:  		/* b 8 */
		/* 820AFB54h case   16:*/		return 0x820AFB5C;
		/* 820AFB54h case   16:*/		return 0x820AFB58;
	}
	return 0x820AFB58;
} // Block from 820AFB14h-820AFB58h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820AFB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFB58);
		  /* 820AFB58h */ case    0:  		/* li R11, 0 */
		/* 820AFB58h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AFB58h case    0:*/		return 0x820AFB5C;
	}
	return 0x820AFB5C;
} // Block from 820AFB58h-820AFB5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AFB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFB5C);
		  /* 820AFB5Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820AFB5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AFB5Ch case    0:*/		return 0x820AFB60;
		  /* 820AFB60h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820AFB60h case    1:*/		if ( regs.CR[6].eq ) { return 0x820AFB88;  }
		/* 820AFB60h case    1:*/		return 0x820AFB64;
		  /* 820AFB64h */ case    2:  		/* lwz R11, <#[R11 + 104]> */
		/* 820AFB64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000068) );
		/* 820AFB64h case    2:*/		return 0x820AFB68;
		  /* 820AFB68h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820AFB68h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AFB68h case    3:*/		return 0x820AFB6C;
		  /* 820AFB6Ch */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 820AFB6Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820AFB88;  }
		/* 820AFB6Ch case    4:*/		return 0x820AFB70;
		  /* 820AFB70h */ case    5:  		/* addi R9, R9, 1 */
		/* 820AFB70h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820AFB70h case    5:*/		return 0x820AFB74;
		  /* 820AFB74h */ case    6:  		/* addi R4, R4, 4 */
		/* 820AFB74h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820AFB74h case    6:*/		return 0x820AFB78;
		  /* 820AFB78h */ case    7:  		/* cmplw CR6, R9, R5 */
		/* 820AFB78h case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 820AFB78h case    7:*/		return 0x820AFB7C;
		  /* 820AFB7Ch */ case    8:  		/* bc 12, CR6_LT, -64 */
		/* 820AFB7Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x820AFB3C;  }
		/* 820AFB7Ch case    8:*/		return 0x820AFB80;
	}
	return 0x820AFB80;
} // Block from 820AFB5Ch-820AFB80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820AFB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFB80);
		  /* 820AFB80h */ case    0:  		/* li R3, 1 */
		/* 820AFB80h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820AFB80h case    0:*/		return 0x820AFB84;
		  /* 820AFB84h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820AFB84h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AFB84h case    1:*/		return 0x820AFB88;
	}
	return 0x820AFB88;
} // Block from 820AFB80h-820AFB88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFB88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFB88);
		  /* 820AFB88h */ case    0:  		/* li R3, 0 */
		/* 820AFB88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AFB88h case    0:*/		return 0x820AFB8C;
		  /* 820AFB8Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820AFB8Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820AFB8Ch case    1:*/		return 0x820AFB90;
	}
	return 0x820AFB90;
} // Block from 820AFB88h-820AFB90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFB90);
		  /* 820AFB90h */ case    0:  		/* mfspr R12, LR */
		/* 820AFB90h case    0:*/		regs.R12 = regs.LR;
		/* 820AFB90h case    0:*/		return 0x820AFB94;
		  /* 820AFB94h */ case    1:  		/* bl -125268 */
		/* 820AFB94h case    1:*/		regs.LR = 0x820AFB98; return 0x82091240;
		/* 820AFB94h case    1:*/		return 0x820AFB98;
		  /* 820AFB98h */ case    2:  		/* cmpwi CR6, R5, 2 */
		/* 820AFB98h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000002);
		/* 820AFB98h case    2:*/		return 0x820AFB9C;
		  /* 820AFB9Ch */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820AFB9Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820AFBB0;  }
		/* 820AFB9Ch case    3:*/		return 0x820AFBA0;
		  /* 820AFBA0h */ case    4:  		/* addi R11, R6, -1 */
		/* 820AFBA0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xFFFFFFFF);
		/* 820AFBA0h case    4:*/		return 0x820AFBA4;
		  /* 820AFBA4h */ case    5:  		/* cntlzw R11, R11 */
		/* 820AFBA4h case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820AFBA4h case    5:*/		return 0x820AFBA8;
		  /* 820AFBA8h */ case    6:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820AFBA8h case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820AFBA8h case    6:*/		return 0x820AFBAC;
		  /* 820AFBACh */ case    7:  		/* b 448 */
		/* 820AFBACh case    7:*/		return 0x820AFD6C;
		/* 820AFBACh case    7:*/		return 0x820AFBB0;
	}
	return 0x820AFBB0;
} // Block from 820AFB90h-820AFBB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AFBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFBB0);
		  /* 820AFBB0h */ case    0:  		/* mullw. R11, R6, R7 */
		/* 820AFBB0h case    0:*/		cpu::op::mullw<1>(regs,&regs.R11,regs.R6,regs.R7);
		/* 820AFBB0h case    0:*/		return 0x820AFBB4;
		  /* 820AFBB4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AFBB4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AFBC0;  }
		/* 820AFBB4h case    1:*/		return 0x820AFBB8;
		  /* 820AFBB8h */ case    2:  		/* li R3, 0 */
		/* 820AFBB8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AFBB8h case    2:*/		return 0x820AFBBC;
		  /* 820AFBBCh */ case    3:  		/* b 432 */
		/* 820AFBBCh case    3:*/		return 0x820AFD6C;
		/* 820AFBBCh case    3:*/		return 0x820AFBC0;
	}
	return 0x820AFBC0;
} // Block from 820AFBB0h-820AFBC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AFBC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFBC0);
		  /* 820AFBC0h */ case    0:  		/* li R23, 0 */
		/* 820AFBC0h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820AFBC0h case    0:*/		return 0x820AFBC4;
		  /* 820AFBC4h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 820AFBC4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820AFBC4h case    1:*/		return 0x820AFBC8;
		  /* 820AFBC8h */ case    2:  		/* bc 12, CR6_EQ, 200 */
		/* 820AFBC8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AFC90;  }
		/* 820AFBC8h case    2:*/		return 0x820AFBCC;
		  /* 820AFBCCh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AFBCCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFBCCh case    3:*/		return 0x820AFBD0;
		  /* 820AFBD0h */ case    4:  		/* mr R31, R4 */
		/* 820AFBD0h case    4:*/		regs.R31 = regs.R4;
		/* 820AFBD0h case    4:*/		return 0x820AFBD4;
		  /* 820AFBD4h */ case    5:  		/* lwz R25, <#[R11 + 20]> */
		/* 820AFBD4h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000014) );
		/* 820AFBD4h case    5:*/		return 0x820AFBD8;
		  /* 820AFBD8h */ case    6:  		/* lwz R24, <#[R11 + 16]> */
		/* 820AFBD8h case    6:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x00000010) );
		/* 820AFBD8h case    6:*/		return 0x820AFBDC;
		  /* 820AFBDCh */ case    7:  		/* lwz R11, <#[R31]> */
		/* 820AFBDCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AFBDCh case    7:*/		return 0x820AFBE0;
		  /* 820AFBE0h */ case    8:  		/* li R10, 0 */
		/* 820AFBE0h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820AFBE0h case    8:*/		return 0x820AFBE4;
		  /* 820AFBE4h */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 820AFBE4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820AFBE4h case    9:*/		return 0x820AFBE8;
		  /* 820AFBE8h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AFBE8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AFBE8h case   10:*/		return 0x820AFBEC;
		  /* 820AFBECh */ case   11:  		/* lwzx R9, <#[R11 + R25]> */
		/* 820AFBECh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820AFBECh case   11:*/		return 0x820AFBF0;
		  /* 820AFBF0h */ case   12:  		/* lwz R29, <#[R9 + 4]> */
		/* 820AFBF0h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x00000004) );
		/* 820AFBF0h case   12:*/		return 0x820AFBF4;
		  /* 820AFBF4h */ case   13:  		/* rlwinm R11, R29, 2, 0, 29 */
		/* 820AFBF4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R29);
		/* 820AFBF4h case   13:*/		return 0x820AFBF8;
		  /* 820AFBF8h */ case   14:  		/* lwzx R26, <#[R11 + R24]> */
		/* 820AFBF8h case   14:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 820AFBF8h case   14:*/		return 0x820AFBFC;
		  /* 820AFBFCh */ case   15:  		/* bc 12, CR6_EQ, 132 */
		/* 820AFBFCh case   15:*/		if ( regs.CR[6].eq ) { return 0x820AFC80;  }
		/* 820AFBFCh case   15:*/		return 0x820AFC00;
		  /* 820AFC00h */ case   16:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AFC00h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFC00h case   16:*/		return 0x820AFC04;
		  /* 820AFC04h */ case   17:  		/* rlwinm R28, R7, 2, 0, 29 */
		/* 820AFC04h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R7);
		/* 820AFC04h case   17:*/		return 0x820AFC08;
		  /* 820AFC08h */ case   18:  		/* mr R30, R31 */
		/* 820AFC08h case   18:*/		regs.R30 = regs.R31;
		/* 820AFC08h case   18:*/		return 0x820AFC0C;
		  /* 820AFC0Ch */ case   19:  		/* lwz R27, <#[R11 + 20]> */
		/* 820AFC0Ch case   19:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000014) );
		/* 820AFC0Ch case   19:*/		return 0x820AFC10;
		  /* 820AFC10h */ case   20:  		/* lwz R11, <#[R30]> */
		/* 820AFC10h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820AFC10h case   20:*/		return 0x820AFC14;
		  /* 820AFC14h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AFC14h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AFC14h case   21:*/		return 0x820AFC18;
		  /* 820AFC18h */ case   22:  		/* lwzx R11, <#[R11 + R27]> */
		/* 820AFC18h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 820AFC18h case   22:*/		return 0x820AFC1C;
		  /* 820AFC1Ch */ case   23:  		/* lwz R8, <#[R11 + 4]> */
		/* 820AFC1Ch case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820AFC1Ch case   23:*/		return 0x820AFC20;
		  /* 820AFC20h */ case   24:  		/* cmplw CR6, R29, R8 */
		/* 820AFC20h case   24:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R8);
		/* 820AFC20h case   24:*/		return 0x820AFC24;
		  /* 820AFC24h */ case   25:  		/* bc 4, CR6_EQ, 324 */
		/* 820AFC24h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820AFD68;  }
		/* 820AFC24h case   25:*/		return 0x820AFC28;
		  /* 820AFC28h */ case   26:  		/* lwz R8, <#[R26 + 4]> */
		/* 820AFC28h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000004) );
		/* 820AFC28h case   26:*/		return 0x820AFC2C;
		  /* 820AFC2Ch */ case   27:  		/* rlwinm. R8, R8, 0, 25, 25 */
		/* 820AFC2Ch case   27:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R8,regs.R8);
		/* 820AFC2Ch case   27:*/		return 0x820AFC30;
		  /* 820AFC30h */ case   28:  		/* bc 12, CR0_EQ, 48 */
		/* 820AFC30h case   28:*/		if ( regs.CR[0].eq ) { return 0x820AFC60;  }
		/* 820AFC30h case   28:*/		return 0x820AFC34;
		  /* 820AFC34h */ case   29:  		/* lwz R8, <#[R9 + 12]> */
		/* 820AFC34h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 820AFC34h case   29:*/		return 0x820AFC38;
		  /* 820AFC38h */ case   30:  		/* rlwinm R5, R10, 30, 2, 31 */
		/* 820AFC38h case   30:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R5,regs.R10);
		/* 820AFC38h case   30:*/		return 0x820AFC3C;
		  /* 820AFC3Ch */ case   31:  		/* lwz R22, <#[R11 + 12]> */
		/* 820AFC3Ch case   31:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x0000000C) );
		/* 820AFC3Ch case   31:*/		return 0x820AFC40;
		  /* 820AFC40h */ case   32:  		/* add R8, R5, R8 */
		/* 820AFC40h case   32:*/		cpu::op::add<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820AFC40h case   32:*/		return 0x820AFC44;
		  /* 820AFC44h */ case   33:  		/* cmplw CR6, R8, R22 */
		/* 820AFC44h case   33:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R22);
		/* 820AFC44h case   33:*/		return 0x820AFC48;
		  /* 820AFC48h */ case   34:  		/* bc 4, CR6_EQ, 288 */
		/* 820AFC48h case   34:*/		if ( !regs.CR[6].eq ) { return 0x820AFD68;  }
		/* 820AFC48h case   34:*/		return 0x820AFC4C;
		  /* 820AFC4Ch */ case   35:  		/* lwz R8, <#[R9 + 16]> */
		/* 820AFC4Ch case   35:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 820AFC4Ch case   35:*/		return 0x820AFC50;
		  /* 820AFC50h */ case   36:  		/* rlwinm R5, R10, 0, 30, 31 */
		/* 820AFC50h case   36:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R10);
		/* 820AFC50h case   36:*/		return 0x820AFC54;
		  /* 820AFC54h */ case   37:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AFC54h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AFC54h case   37:*/		return 0x820AFC58;
		  /* 820AFC58h */ case   38:  		/* add R8, R5, R8 */
		/* 820AFC58h case   38:*/		cpu::op::add<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820AFC58h case   38:*/		return 0x820AFC5C;
		  /* 820AFC5Ch */ case   39:  		/* b 12 */
		/* 820AFC5Ch case   39:*/		return 0x820AFC68;
		/* 820AFC5Ch case   39:*/		return 0x820AFC60;
	}
	return 0x820AFC60;
} // Block from 820AFBC0h-820AFC60h (40 instructions)

//////////////////////////////////////////////////////
// Block at 820AFC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFC60);
		  /* 820AFC60h */ case    0:  		/* lwz R8, <#[R9 + 72]> */
		/* 820AFC60h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000048) );
		/* 820AFC60h case    0:*/		return 0x820AFC64;
		  /* 820AFC64h */ case    1:  		/* lwz R11, <#[R11 + 72]> */
		/* 820AFC64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820AFC64h case    1:*/		return 0x820AFC68;
	}
	return 0x820AFC68;
} // Block from 820AFC60h-820AFC68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFC68);
		  /* 820AFC68h */ case    0:  		/* cmplw CR6, R8, R11 */
		/* 820AFC68h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820AFC68h case    0:*/		return 0x820AFC6C;
		  /* 820AFC6Ch */ case    1:  		/* bc 4, CR6_EQ, 252 */
		/* 820AFC6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AFD68;  }
		/* 820AFC6Ch case    1:*/		return 0x820AFC70;
		  /* 820AFC70h */ case    2:  		/* addi R10, R10, 1 */
		/* 820AFC70h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AFC70h case    2:*/		return 0x820AFC74;
		  /* 820AFC74h */ case    3:  		/* add R30, R28, R30 */
		/* 820AFC74h case    3:*/		cpu::op::add<0>(regs,&regs.R30,regs.R28,regs.R30);
		/* 820AFC74h case    3:*/		return 0x820AFC78;
		  /* 820AFC78h */ case    4:  		/* cmplw CR6, R10, R6 */
		/* 820AFC78h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 820AFC78h case    4:*/		return 0x820AFC7C;
		  /* 820AFC7Ch */ case    5:  		/* bc 12, CR6_LT, -108 */
		/* 820AFC7Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x820AFC10;  }
		/* 820AFC7Ch case    5:*/		return 0x820AFC80;
	}
	return 0x820AFC80;
} // Block from 820AFC68h-820AFC80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AFC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFC80);
		  /* 820AFC80h */ case    0:  		/* addi R23, R23, 1 */
		/* 820AFC80h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820AFC80h case    0:*/		return 0x820AFC84;
		  /* 820AFC84h */ case    1:  		/* addi R31, R31, 4 */
		/* 820AFC84h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820AFC84h case    1:*/		return 0x820AFC88;
		  /* 820AFC88h */ case    2:  		/* cmplw CR6, R23, R7 */
		/* 820AFC88h case    2:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R7);
		/* 820AFC88h case    2:*/		return 0x820AFC8C;
		  /* 820AFC8Ch */ case    3:  		/* bc 12, CR6_LT, -176 */
		/* 820AFC8Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820AFBDC;  }
		/* 820AFC8Ch case    3:*/		return 0x820AFC90;
	}
	return 0x820AFC90;
} // Block from 820AFC80h-820AFC90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AFC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFC90);
		  /* 820AFC90h */ case    0:  		/* li R23, 0 */
		/* 820AFC90h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820AFC90h case    0:*/		return 0x820AFC94;
		  /* 820AFC94h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 820AFC94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820AFC94h case    1:*/		return 0x820AFC98;
		  /* 820AFC98h */ case    2:  		/* bc 12, CR6_EQ, 208 */
		/* 820AFC98h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AFD68;  }
		/* 820AFC98h case    2:*/		return 0x820AFC9C;
		  /* 820AFC9Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AFC9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFC9Ch case    3:*/		return 0x820AFCA0;
		  /* 820AFCA0h */ case    4:  		/* li R29, 0 */
		/* 820AFCA0h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820AFCA0h case    4:*/		return 0x820AFCA4;
		  /* 820AFCA4h */ case    5:  		/* rlwinm R24, R7, 2, 0, 29 */
		/* 820AFCA4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R7);
		/* 820AFCA4h case    5:*/		return 0x820AFCA8;
		  /* 820AFCA8h */ case    6:  		/* mr R31, R4 */
		/* 820AFCA8h case    6:*/		regs.R31 = regs.R4;
		/* 820AFCA8h case    6:*/		return 0x820AFCAC;
		  /* 820AFCACh */ case    7:  		/* lwz R27, <#[R11 + 20]> */
		/* 820AFCACh case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000014) );
		/* 820AFCACh case    7:*/		return 0x820AFCB0;
		  /* 820AFCB0h */ case    8:  		/* lwz R26, <#[R11 + 16]> */
		/* 820AFCB0h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000010) );
		/* 820AFCB0h case    8:*/		return 0x820AFCB4;
		  /* 820AFCB4h */ case    9:  		/* lwz R10, <#[R31]> */
		/* 820AFCB4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820AFCB4h case    9:*/		return 0x820AFCB8;
		  /* 820AFCB8h */ case   10:  		/* li R11, 0 */
		/* 820AFCB8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AFCB8h case   10:*/		return 0x820AFCBC;
		  /* 820AFCBCh */ case   11:  		/* cmplwi CR6, R7, 0 */
		/* 820AFCBCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820AFCBCh case   11:*/		return 0x820AFCC0;
		  /* 820AFCC0h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AFCC0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AFCC0h case   12:*/		return 0x820AFCC4;
		  /* 820AFCC4h */ case   13:  		/* lwzx R9, <#[R10 + R27]> */
		/* 820AFCC4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 820AFCC4h case   13:*/		return 0x820AFCC8;
		  /* 820AFCC8h */ case   14:  		/* lwz R30, <#[R9 + 4]> */
		/* 820AFCC8h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 820AFCC8h case   14:*/		return 0x820AFCCC;
		  /* 820AFCCCh */ case   15:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820AFCCCh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820AFCCCh case   15:*/		return 0x820AFCD0;
		  /* 820AFCD0h */ case   16:  		/* lwzx R25, <#[R10 + R26]> */
		/* 820AFCD0h case   16:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 820AFCD0h case   16:*/		return 0x820AFCD4;
		  /* 820AFCD4h */ case   17:  		/* bc 12, CR6_EQ, 128 */
		/* 820AFCD4h case   17:*/		if ( regs.CR[6].eq ) { return 0x820AFD54;  }
		/* 820AFCD4h case   17:*/		return 0x820AFCD8;
		  /* 820AFCD8h */ case   18:  		/* lwz R10, <#[R3 + 8]> */
		/* 820AFCD8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFCD8h case   18:*/		return 0x820AFCDC;
		  /* 820AFCDCh */ case   19:  		/* lwz R28, <#[R10 + 20]> */
		/* 820AFCDCh case   19:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000014) );
		/* 820AFCDCh case   19:*/		return 0x820AFCE0;
		  /* 820AFCE0h */ case   20:  		/* add R10, R29, R11 */
		/* 820AFCE0h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R29,regs.R11);
		/* 820AFCE0h case   20:*/		return 0x820AFCE4;
		  /* 820AFCE4h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AFCE4h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AFCE4h case   21:*/		return 0x820AFCE8;
		  /* 820AFCE8h */ case   22:  		/* lwzx R10, <#[R10 + R4]> */
		/* 820AFCE8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 820AFCE8h case   22:*/		return 0x820AFCEC;
		  /* 820AFCECh */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AFCECh case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AFCECh case   23:*/		return 0x820AFCF0;
		  /* 820AFCF0h */ case   24:  		/* lwzx R10, <#[R10 + R28]> */
		/* 820AFCF0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820AFCF0h case   24:*/		return 0x820AFCF4;
		  /* 820AFCF4h */ case   25:  		/* lwz R8, <#[R10 + 4]> */
		/* 820AFCF4h case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 820AFCF4h case   25:*/		return 0x820AFCF8;
		  /* 820AFCF8h */ case   26:  		/* cmplw CR6, R30, R8 */
		/* 820AFCF8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R8);
		/* 820AFCF8h case   26:*/		return 0x820AFCFC;
		  /* 820AFCFCh */ case   27:  		/* bc 4, CR6_EQ, -324 */
		/* 820AFCFCh case   27:*/		if ( !regs.CR[6].eq ) { return 0x820AFBB8;  }
		/* 820AFCFCh case   27:*/		return 0x820AFD00;
		  /* 820AFD00h */ case   28:  		/* lwz R8, <#[R25 + 4]> */
		/* 820AFD00h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000004) );
		/* 820AFD00h case   28:*/		return 0x820AFD04;
		  /* 820AFD04h */ case   29:  		/* rlwinm. R8, R8, 0, 25, 25 */
		/* 820AFD04h case   29:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R8,regs.R8);
		/* 820AFD04h case   29:*/		return 0x820AFD08;
		  /* 820AFD08h */ case   30:  		/* bc 12, CR0_EQ, 48 */
		/* 820AFD08h case   30:*/		if ( regs.CR[0].eq ) { return 0x820AFD38;  }
		/* 820AFD08h case   30:*/		return 0x820AFD0C;
		  /* 820AFD0Ch */ case   31:  		/* lwz R5, <#[R9 + 12]> */
		/* 820AFD0Ch case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x0000000C) );
		/* 820AFD0Ch case   31:*/		return 0x820AFD10;
		  /* 820AFD10h */ case   32:  		/* rlwinm R8, R11, 30, 2, 31 */
		/* 820AFD10h case   32:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R8,regs.R11);
		/* 820AFD10h case   32:*/		return 0x820AFD14;
		  /* 820AFD14h */ case   33:  		/* lwz R22, <#[R10 + 12]> */
		/* 820AFD14h case   33:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R10 + 0x0000000C) );
		/* 820AFD14h case   33:*/		return 0x820AFD18;
		  /* 820AFD18h */ case   34:  		/* add R8, R8, R5 */
		/* 820AFD18h case   34:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 820AFD18h case   34:*/		return 0x820AFD1C;
		  /* 820AFD1Ch */ case   35:  		/* cmplw CR6, R8, R22 */
		/* 820AFD1Ch case   35:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R22);
		/* 820AFD1Ch case   35:*/		return 0x820AFD20;
		  /* 820AFD20h */ case   36:  		/* bc 4, CR6_EQ, -360 */
		/* 820AFD20h case   36:*/		if ( !regs.CR[6].eq ) { return 0x820AFBB8;  }
		/* 820AFD20h case   36:*/		return 0x820AFD24;
		  /* 820AFD24h */ case   37:  		/* lwz R5, <#[R9 + 16]> */
		/* 820AFD24h case   37:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000010) );
		/* 820AFD24h case   37:*/		return 0x820AFD28;
		  /* 820AFD28h */ case   38:  		/* rlwinm R8, R11, 0, 30, 31 */
		/* 820AFD28h case   38:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820AFD28h case   38:*/		return 0x820AFD2C;
		  /* 820AFD2Ch */ case   39:  		/* lwz R10, <#[R10 + 16]> */
		/* 820AFD2Ch case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820AFD2Ch case   39:*/		return 0x820AFD30;
		  /* 820AFD30h */ case   40:  		/* add R8, R8, R5 */
		/* 820AFD30h case   40:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 820AFD30h case   40:*/		return 0x820AFD34;
		  /* 820AFD34h */ case   41:  		/* b 12 */
		/* 820AFD34h case   41:*/		return 0x820AFD40;
		/* 820AFD34h case   41:*/		return 0x820AFD38;
	}
	return 0x820AFD38;
} // Block from 820AFC90h-820AFD38h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820AFD38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFD38);
		  /* 820AFD38h */ case    0:  		/* lwz R8, <#[R9 + 72]> */
		/* 820AFD38h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000048) );
		/* 820AFD38h case    0:*/		return 0x820AFD3C;
		  /* 820AFD3Ch */ case    1:  		/* lwz R10, <#[R10 + 72]> */
		/* 820AFD3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 820AFD3Ch case    1:*/		return 0x820AFD40;
	}
	return 0x820AFD40;
} // Block from 820AFD38h-820AFD40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFD40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFD40);
		  /* 820AFD40h */ case    0:  		/* cmplw CR6, R8, R10 */
		/* 820AFD40h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820AFD40h case    0:*/		return 0x820AFD44;
		  /* 820AFD44h */ case    1:  		/* bc 4, CR6_EQ, -396 */
		/* 820AFD44h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AFBB8;  }
		/* 820AFD44h case    1:*/		return 0x820AFD48;
		  /* 820AFD48h */ case    2:  		/* addi R11, R11, 1 */
		/* 820AFD48h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AFD48h case    2:*/		return 0x820AFD4C;
		  /* 820AFD4Ch */ case    3:  		/* cmplw CR6, R11, R7 */
		/* 820AFD4Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820AFD4Ch case    3:*/		return 0x820AFD50;
		  /* 820AFD50h */ case    4:  		/* bc 12, CR6_LT, -112 */
		/* 820AFD50h case    4:*/		if ( regs.CR[6].lt ) { return 0x820AFCE0;  }
		/* 820AFD50h case    4:*/		return 0x820AFD54;
	}
	return 0x820AFD54;
} // Block from 820AFD40h-820AFD54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AFD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFD54);
		  /* 820AFD54h */ case    0:  		/* addi R23, R23, 1 */
		/* 820AFD54h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820AFD54h case    0:*/		return 0x820AFD58;
		  /* 820AFD58h */ case    1:  		/* add R29, R29, R7 */
		/* 820AFD58h case    1:*/		cpu::op::add<0>(regs,&regs.R29,regs.R29,regs.R7);
		/* 820AFD58h case    1:*/		return 0x820AFD5C;
		  /* 820AFD5Ch */ case    2:  		/* add R31, R31, R24 */
		/* 820AFD5Ch case    2:*/		cpu::op::add<0>(regs,&regs.R31,regs.R31,regs.R24);
		/* 820AFD5Ch case    2:*/		return 0x820AFD60;
		  /* 820AFD60h */ case    3:  		/* cmplw CR6, R23, R6 */
		/* 820AFD60h case    3:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R6);
		/* 820AFD60h case    3:*/		return 0x820AFD64;
		  /* 820AFD64h */ case    4:  		/* bc 12, CR6_LT, -176 */
		/* 820AFD64h case    4:*/		if ( regs.CR[6].lt ) { return 0x820AFCB4;  }
		/* 820AFD64h case    4:*/		return 0x820AFD68;
	}
	return 0x820AFD68;
} // Block from 820AFD54h-820AFD68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AFD68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFD68);
		  /* 820AFD68h */ case    0:  		/* li R3, 1 */
		/* 820AFD68h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820AFD68h case    0:*/		return 0x820AFD6C;
	}
	return 0x820AFD6C;
} // Block from 820AFD68h-820AFD6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AFD6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFD6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFD6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFD6C);
		  /* 820AFD6Ch */ case    0:  		/* b -125660 */
		/* 820AFD6Ch case    0:*/		return 0x82091290;
		/* 820AFD6Ch case    0:*/		return 0x820AFD70;
	}
	return 0x820AFD70;
} // Block from 820AFD6Ch-820AFD70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AFD70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFD70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFD70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFD70);
		  /* 820AFD70h */ case    0:  		/* mfspr R12, LR */
		/* 820AFD70h case    0:*/		regs.R12 = regs.LR;
		/* 820AFD70h case    0:*/		return 0x820AFD74;
		  /* 820AFD74h */ case    1:  		/* bl -125748 */
		/* 820AFD74h case    1:*/		regs.LR = 0x820AFD78; return 0x82091240;
		/* 820AFD74h case    1:*/		return 0x820AFD78;
		  /* 820AFD78h */ case    2:  		/* cmpwi CR6, R5, 2 */
		/* 820AFD78h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000002);
		/* 820AFD78h case    2:*/		return 0x820AFD7C;
		  /* 820AFD7Ch */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820AFD7Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820AFD90;  }
		/* 820AFD7Ch case    3:*/		return 0x820AFD80;
		  /* 820AFD80h */ case    4:  		/* subfic R11, R6, 1 */
		/* 820AFD80h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R6,0x1);
		/* 820AFD80h case    4:*/		return 0x820AFD84;
		  /* 820AFD84h */ case    5:  		/* subfe R11, R11, R11 */
		/* 820AFD84h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820AFD84h case    5:*/		return 0x820AFD88;
		  /* 820AFD88h */ case    6:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820AFD88h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820AFD88h case    6:*/		return 0x820AFD8C;
		  /* 820AFD8Ch */ case    7:  		/* b 444 */
		/* 820AFD8Ch case    7:*/		return 0x820AFF48;
		/* 820AFD8Ch case    7:*/		return 0x820AFD90;
	}
	return 0x820AFD90;
} // Block from 820AFD70h-820AFD90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820AFD90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFD90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFD90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFD90);
		  /* 820AFD90h */ case    0:  		/* mullw. R11, R6, R7 */
		/* 820AFD90h case    0:*/		cpu::op::mullw<1>(regs,&regs.R11,regs.R6,regs.R7);
		/* 820AFD90h case    0:*/		return 0x820AFD94;
		  /* 820AFD94h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820AFD94h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820AFDA0;  }
		/* 820AFD94h case    1:*/		return 0x820AFD98;
		  /* 820AFD98h */ case    2:  		/* li R3, 0 */
		/* 820AFD98h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820AFD98h case    2:*/		return 0x820AFD9C;
		  /* 820AFD9Ch */ case    3:  		/* b 428 */
		/* 820AFD9Ch case    3:*/		return 0x820AFF48;
		/* 820AFD9Ch case    3:*/		return 0x820AFDA0;
	}
	return 0x820AFDA0;
} // Block from 820AFD90h-820AFDA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AFDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFDA0);
		  /* 820AFDA0h */ case    0:  		/* li R23, 0 */
		/* 820AFDA0h case    0:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820AFDA0h case    0:*/		return 0x820AFDA4;
		  /* 820AFDA4h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 820AFDA4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820AFDA4h case    1:*/		return 0x820AFDA8;
		  /* 820AFDA8h */ case    2:  		/* bc 12, CR6_EQ, 208 */
		/* 820AFDA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AFE78;  }
		/* 820AFDA8h case    2:*/		return 0x820AFDAC;
		  /* 820AFDACh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AFDACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFDACh case    3:*/		return 0x820AFDB0;
		  /* 820AFDB0h */ case    4:  		/* li R29, 0 */
		/* 820AFDB0h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820AFDB0h case    4:*/		return 0x820AFDB4;
		  /* 820AFDB4h */ case    5:  		/* rlwinm R24, R7, 2, 0, 29 */
		/* 820AFDB4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R7);
		/* 820AFDB4h case    5:*/		return 0x820AFDB8;
		  /* 820AFDB8h */ case    6:  		/* mr R31, R4 */
		/* 820AFDB8h case    6:*/		regs.R31 = regs.R4;
		/* 820AFDB8h case    6:*/		return 0x820AFDBC;
		  /* 820AFDBCh */ case    7:  		/* lwz R27, <#[R11 + 20]> */
		/* 820AFDBCh case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000014) );
		/* 820AFDBCh case    7:*/		return 0x820AFDC0;
		  /* 820AFDC0h */ case    8:  		/* lwz R26, <#[R11 + 16]> */
		/* 820AFDC0h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000010) );
		/* 820AFDC0h case    8:*/		return 0x820AFDC4;
		  /* 820AFDC4h */ case    9:  		/* lwz R10, <#[R31]> */
		/* 820AFDC4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820AFDC4h case    9:*/		return 0x820AFDC8;
		  /* 820AFDC8h */ case   10:  		/* li R11, 0 */
		/* 820AFDC8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820AFDC8h case   10:*/		return 0x820AFDCC;
		  /* 820AFDCCh */ case   11:  		/* cmplwi CR6, R7, 0 */
		/* 820AFDCCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820AFDCCh case   11:*/		return 0x820AFDD0;
		  /* 820AFDD0h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AFDD0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AFDD0h case   12:*/		return 0x820AFDD4;
		  /* 820AFDD4h */ case   13:  		/* lwzx R9, <#[R10 + R27]> */
		/* 820AFDD4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 820AFDD4h case   13:*/		return 0x820AFDD8;
		  /* 820AFDD8h */ case   14:  		/* lwz R30, <#[R9 + 4]> */
		/* 820AFDD8h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 820AFDD8h case   14:*/		return 0x820AFDDC;
		  /* 820AFDDCh */ case   15:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820AFDDCh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820AFDDCh case   15:*/		return 0x820AFDE0;
		  /* 820AFDE0h */ case   16:  		/* lwzx R25, <#[R10 + R26]> */
		/* 820AFDE0h case   16:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 820AFDE0h case   16:*/		return 0x820AFDE4;
		  /* 820AFDE4h */ case   17:  		/* bc 12, CR6_EQ, 128 */
		/* 820AFDE4h case   17:*/		if ( regs.CR[6].eq ) { return 0x820AFE64;  }
		/* 820AFDE4h case   17:*/		return 0x820AFDE8;
		  /* 820AFDE8h */ case   18:  		/* lwz R10, <#[R3 + 8]> */
		/* 820AFDE8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFDE8h case   18:*/		return 0x820AFDEC;
		  /* 820AFDECh */ case   19:  		/* lwz R28, <#[R10 + 20]> */
		/* 820AFDECh case   19:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000014) );
		/* 820AFDECh case   19:*/		return 0x820AFDF0;
		  /* 820AFDF0h */ case   20:  		/* add R10, R29, R11 */
		/* 820AFDF0h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R29,regs.R11);
		/* 820AFDF0h case   20:*/		return 0x820AFDF4;
		  /* 820AFDF4h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AFDF4h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AFDF4h case   21:*/		return 0x820AFDF8;
		  /* 820AFDF8h */ case   22:  		/* lwzx R10, <#[R10 + R4]> */
		/* 820AFDF8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 820AFDF8h case   22:*/		return 0x820AFDFC;
		  /* 820AFDFCh */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820AFDFCh case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820AFDFCh case   23:*/		return 0x820AFE00;
		  /* 820AFE00h */ case   24:  		/* lwzx R10, <#[R10 + R28]> */
		/* 820AFE00h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820AFE00h case   24:*/		return 0x820AFE04;
		  /* 820AFE04h */ case   25:  		/* lwz R8, <#[R10 + 4]> */
		/* 820AFE04h case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 820AFE04h case   25:*/		return 0x820AFE08;
		  /* 820AFE08h */ case   26:  		/* cmplw CR6, R30, R8 */
		/* 820AFE08h case   26:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R8);
		/* 820AFE08h case   26:*/		return 0x820AFE0C;
		  /* 820AFE0Ch */ case   27:  		/* bc 4, CR6_EQ, 312 */
		/* 820AFE0Ch case   27:*/		if ( !regs.CR[6].eq ) { return 0x820AFF44;  }
		/* 820AFE0Ch case   27:*/		return 0x820AFE10;
		  /* 820AFE10h */ case   28:  		/* lwz R8, <#[R25 + 4]> */
		/* 820AFE10h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000004) );
		/* 820AFE10h case   28:*/		return 0x820AFE14;
		  /* 820AFE14h */ case   29:  		/* rlwinm. R8, R8, 0, 25, 25 */
		/* 820AFE14h case   29:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R8,regs.R8);
		/* 820AFE14h case   29:*/		return 0x820AFE18;
		  /* 820AFE18h */ case   30:  		/* bc 12, CR0_EQ, 48 */
		/* 820AFE18h case   30:*/		if ( regs.CR[0].eq ) { return 0x820AFE48;  }
		/* 820AFE18h case   30:*/		return 0x820AFE1C;
		  /* 820AFE1Ch */ case   31:  		/* lwz R8, <#[R9 + 12]> */
		/* 820AFE1Ch case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 820AFE1Ch case   31:*/		return 0x820AFE20;
		  /* 820AFE20h */ case   32:  		/* rlwinm R5, R11, 30, 2, 31 */
		/* 820AFE20h case   32:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R5,regs.R11);
		/* 820AFE20h case   32:*/		return 0x820AFE24;
		  /* 820AFE24h */ case   33:  		/* lwz R22, <#[R10 + 12]> */
		/* 820AFE24h case   33:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R10 + 0x0000000C) );
		/* 820AFE24h case   33:*/		return 0x820AFE28;
		  /* 820AFE28h */ case   34:  		/* add R8, R5, R8 */
		/* 820AFE28h case   34:*/		cpu::op::add<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820AFE28h case   34:*/		return 0x820AFE2C;
		  /* 820AFE2Ch */ case   35:  		/* cmplw CR6, R8, R22 */
		/* 820AFE2Ch case   35:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R22);
		/* 820AFE2Ch case   35:*/		return 0x820AFE30;
		  /* 820AFE30h */ case   36:  		/* bc 4, CR6_EQ, 276 */
		/* 820AFE30h case   36:*/		if ( !regs.CR[6].eq ) { return 0x820AFF44;  }
		/* 820AFE30h case   36:*/		return 0x820AFE34;
		  /* 820AFE34h */ case   37:  		/* lwz R8, <#[R9 + 16]> */
		/* 820AFE34h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 820AFE34h case   37:*/		return 0x820AFE38;
		  /* 820AFE38h */ case   38:  		/* rlwinm R5, R11, 0, 30, 31 */
		/* 820AFE38h case   38:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R11);
		/* 820AFE38h case   38:*/		return 0x820AFE3C;
		  /* 820AFE3Ch */ case   39:  		/* lwz R10, <#[R10 + 16]> */
		/* 820AFE3Ch case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820AFE3Ch case   39:*/		return 0x820AFE40;
		  /* 820AFE40h */ case   40:  		/* add R8, R5, R8 */
		/* 820AFE40h case   40:*/		cpu::op::add<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820AFE40h case   40:*/		return 0x820AFE44;
		  /* 820AFE44h */ case   41:  		/* b 12 */
		/* 820AFE44h case   41:*/		return 0x820AFE50;
		/* 820AFE44h case   41:*/		return 0x820AFE48;
	}
	return 0x820AFE48;
} // Block from 820AFDA0h-820AFE48h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820AFE48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFE48);
		  /* 820AFE48h */ case    0:  		/* lwz R8, <#[R9 + 72]> */
		/* 820AFE48h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000048) );
		/* 820AFE48h case    0:*/		return 0x820AFE4C;
		  /* 820AFE4Ch */ case    1:  		/* lwz R10, <#[R10 + 72]> */
		/* 820AFE4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 820AFE4Ch case    1:*/		return 0x820AFE50;
	}
	return 0x820AFE50;
} // Block from 820AFE48h-820AFE50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFE50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFE50);
		  /* 820AFE50h */ case    0:  		/* cmplw CR6, R8, R10 */
		/* 820AFE50h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820AFE50h case    0:*/		return 0x820AFE54;
		  /* 820AFE54h */ case    1:  		/* bc 4, CR6_EQ, 240 */
		/* 820AFE54h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AFF44;  }
		/* 820AFE54h case    1:*/		return 0x820AFE58;
		  /* 820AFE58h */ case    2:  		/* addi R11, R11, 1 */
		/* 820AFE58h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AFE58h case    2:*/		return 0x820AFE5C;
		  /* 820AFE5Ch */ case    3:  		/* cmplw CR6, R11, R7 */
		/* 820AFE5Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820AFE5Ch case    3:*/		return 0x820AFE60;
		  /* 820AFE60h */ case    4:  		/* bc 12, CR6_LT, -112 */
		/* 820AFE60h case    4:*/		if ( regs.CR[6].lt ) { return 0x820AFDF0;  }
		/* 820AFE60h case    4:*/		return 0x820AFE64;
	}
	return 0x820AFE64;
} // Block from 820AFE50h-820AFE64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AFE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFE64);
		  /* 820AFE64h */ case    0:  		/* addi R23, R23, 1 */
		/* 820AFE64h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820AFE64h case    0:*/		return 0x820AFE68;
		  /* 820AFE68h */ case    1:  		/* add R29, R29, R7 */
		/* 820AFE68h case    1:*/		cpu::op::add<0>(regs,&regs.R29,regs.R29,regs.R7);
		/* 820AFE68h case    1:*/		return 0x820AFE6C;
		  /* 820AFE6Ch */ case    2:  		/* add R31, R24, R31 */
		/* 820AFE6Ch case    2:*/		cpu::op::add<0>(regs,&regs.R31,regs.R24,regs.R31);
		/* 820AFE6Ch case    2:*/		return 0x820AFE70;
		  /* 820AFE70h */ case    3:  		/* cmplw CR6, R23, R6 */
		/* 820AFE70h case    3:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R6);
		/* 820AFE70h case    3:*/		return 0x820AFE74;
		  /* 820AFE74h */ case    4:  		/* bc 12, CR6_LT, -176 */
		/* 820AFE74h case    4:*/		if ( regs.CR[6].lt ) { return 0x820AFDC4;  }
		/* 820AFE74h case    4:*/		return 0x820AFE78;
	}
	return 0x820AFE78;
} // Block from 820AFE64h-820AFE78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820AFE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFE78);
		  /* 820AFE78h */ case    0:  		/* li R24, 0 */
		/* 820AFE78h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820AFE78h case    0:*/		return 0x820AFE7C;
		  /* 820AFE7Ch */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 820AFE7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820AFE7Ch case    1:*/		return 0x820AFE80;
		  /* 820AFE80h */ case    2:  		/* bc 12, CR6_EQ, 196 */
		/* 820AFE80h case    2:*/		if ( regs.CR[6].eq ) { return 0x820AFF44;  }
		/* 820AFE80h case    2:*/		return 0x820AFE84;
		  /* 820AFE84h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AFE84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFE84h case    3:*/		return 0x820AFE88;
		  /* 820AFE88h */ case    4:  		/* lwz R26, <#[R11 + 20]> */
		/* 820AFE88h case    4:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000014) );
		/* 820AFE88h case    4:*/		return 0x820AFE8C;
		  /* 820AFE8Ch */ case    5:  		/* lwz R25, <#[R11 + 16]> */
		/* 820AFE8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000010) );
		/* 820AFE8Ch case    5:*/		return 0x820AFE90;
		  /* 820AFE90h */ case    6:  		/* lwz R11, <#[R4]> */
		/* 820AFE90h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820AFE90h case    6:*/		return 0x820AFE94;
		  /* 820AFE94h */ case    7:  		/* li R10, 0 */
		/* 820AFE94h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820AFE94h case    7:*/		return 0x820AFE98;
		  /* 820AFE98h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 820AFE98h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820AFE98h case    8:*/		return 0x820AFE9C;
		  /* 820AFE9Ch */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AFE9Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AFE9Ch case    9:*/		return 0x820AFEA0;
		  /* 820AFEA0h */ case   10:  		/* lwzx R9, <#[R11 + R26]> */
		/* 820AFEA0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820AFEA0h case   10:*/		return 0x820AFEA4;
		  /* 820AFEA4h */ case   11:  		/* lwz R30, <#[R9 + 4]> */
		/* 820AFEA4h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 820AFEA4h case   11:*/		return 0x820AFEA8;
		  /* 820AFEA8h */ case   12:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820AFEA8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820AFEA8h case   12:*/		return 0x820AFEAC;
		  /* 820AFEACh */ case   13:  		/* lwzx R27, <#[R11 + R25]> */
		/* 820AFEACh case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 820AFEACh case   13:*/		return 0x820AFEB0;
		  /* 820AFEB0h */ case   14:  		/* bc 12, CR6_EQ, 132 */
		/* 820AFEB0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820AFF34;  }
		/* 820AFEB0h case   14:*/		return 0x820AFEB4;
		  /* 820AFEB4h */ case   15:  		/* lwz R11, <#[R3 + 8]> */
		/* 820AFEB4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820AFEB4h case   15:*/		return 0x820AFEB8;
		  /* 820AFEB8h */ case   16:  		/* rlwinm R29, R7, 2, 0, 29 */
		/* 820AFEB8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R7);
		/* 820AFEB8h case   16:*/		return 0x820AFEBC;
		  /* 820AFEBCh */ case   17:  		/* mr R31, R4 */
		/* 820AFEBCh case   17:*/		regs.R31 = regs.R4;
		/* 820AFEBCh case   17:*/		return 0x820AFEC0;
		  /* 820AFEC0h */ case   18:  		/* lwz R28, <#[R11 + 20]> */
		/* 820AFEC0h case   18:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000014) );
		/* 820AFEC0h case   18:*/		return 0x820AFEC4;
		  /* 820AFEC4h */ case   19:  		/* lwz R11, <#[R31]> */
		/* 820AFEC4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820AFEC4h case   19:*/		return 0x820AFEC8;
		  /* 820AFEC8h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820AFEC8h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820AFEC8h case   20:*/		return 0x820AFECC;
		  /* 820AFECCh */ case   21:  		/* lwzx R11, <#[R11 + R28]> */
		/* 820AFECCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820AFECCh case   21:*/		return 0x820AFED0;
		  /* 820AFED0h */ case   22:  		/* lwz R8, <#[R11 + 4]> */
		/* 820AFED0h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820AFED0h case   22:*/		return 0x820AFED4;
		  /* 820AFED4h */ case   23:  		/* cmplw CR6, R30, R8 */
		/* 820AFED4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R8);
		/* 820AFED4h case   23:*/		return 0x820AFED8;
		  /* 820AFED8h */ case   24:  		/* bc 4, CR6_EQ, -320 */
		/* 820AFED8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820AFD98;  }
		/* 820AFED8h case   24:*/		return 0x820AFEDC;
		  /* 820AFEDCh */ case   25:  		/* lwz R8, <#[R27 + 4]> */
		/* 820AFEDCh case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000004) );
		/* 820AFEDCh case   25:*/		return 0x820AFEE0;
		  /* 820AFEE0h */ case   26:  		/* rlwinm. R8, R8, 0, 25, 25 */
		/* 820AFEE0h case   26:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R8,regs.R8);
		/* 820AFEE0h case   26:*/		return 0x820AFEE4;
		  /* 820AFEE4h */ case   27:  		/* bc 12, CR0_EQ, 48 */
		/* 820AFEE4h case   27:*/		if ( regs.CR[0].eq ) { return 0x820AFF14;  }
		/* 820AFEE4h case   27:*/		return 0x820AFEE8;
		  /* 820AFEE8h */ case   28:  		/* lwz R8, <#[R9 + 12]> */
		/* 820AFEE8h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 820AFEE8h case   28:*/		return 0x820AFEEC;
		  /* 820AFEECh */ case   29:  		/* rlwinm R5, R10, 30, 2, 31 */
		/* 820AFEECh case   29:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R5,regs.R10);
		/* 820AFEECh case   29:*/		return 0x820AFEF0;
		  /* 820AFEF0h */ case   30:  		/* lwz R23, <#[R11 + 12]> */
		/* 820AFEF0h case   30:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x0000000C) );
		/* 820AFEF0h case   30:*/		return 0x820AFEF4;
		  /* 820AFEF4h */ case   31:  		/* add R8, R5, R8 */
		/* 820AFEF4h case   31:*/		cpu::op::add<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 820AFEF4h case   31:*/		return 0x820AFEF8;
		  /* 820AFEF8h */ case   32:  		/* cmplw CR6, R8, R23 */
		/* 820AFEF8h case   32:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R23);
		/* 820AFEF8h case   32:*/		return 0x820AFEFC;
		  /* 820AFEFCh */ case   33:  		/* bc 4, CR6_EQ, -356 */
		/* 820AFEFCh case   33:*/		if ( !regs.CR[6].eq ) { return 0x820AFD98;  }
		/* 820AFEFCh case   33:*/		return 0x820AFF00;
		  /* 820AFF00h */ case   34:  		/* lwz R5, <#[R9 + 16]> */
		/* 820AFF00h case   34:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000010) );
		/* 820AFF00h case   34:*/		return 0x820AFF04;
		  /* 820AFF04h */ case   35:  		/* rlwinm R8, R10, 0, 30, 31 */
		/* 820AFF04h case   35:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R10);
		/* 820AFF04h case   35:*/		return 0x820AFF08;
		  /* 820AFF08h */ case   36:  		/* lwz R11, <#[R11 + 16]> */
		/* 820AFF08h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820AFF08h case   36:*/		return 0x820AFF0C;
		  /* 820AFF0Ch */ case   37:  		/* add R8, R8, R5 */
		/* 820AFF0Ch case   37:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 820AFF0Ch case   37:*/		return 0x820AFF10;
		  /* 820AFF10h */ case   38:  		/* b 12 */
		/* 820AFF10h case   38:*/		return 0x820AFF1C;
		/* 820AFF10h case   38:*/		return 0x820AFF14;
	}
	return 0x820AFF14;
} // Block from 820AFE78h-820AFF14h (39 instructions)

//////////////////////////////////////////////////////
// Block at 820AFF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFF14);
		  /* 820AFF14h */ case    0:  		/* lwz R8, <#[R9 + 72]> */
		/* 820AFF14h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000048) );
		/* 820AFF14h case    0:*/		return 0x820AFF18;
		  /* 820AFF18h */ case    1:  		/* lwz R11, <#[R11 + 72]> */
		/* 820AFF18h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820AFF18h case    1:*/		return 0x820AFF1C;
	}
	return 0x820AFF1C;
} // Block from 820AFF14h-820AFF1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFF1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFF1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFF1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFF1C);
		  /* 820AFF1Ch */ case    0:  		/* cmplw CR6, R8, R11 */
		/* 820AFF1Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 820AFF1Ch case    0:*/		return 0x820AFF20;
		  /* 820AFF20h */ case    1:  		/* bc 4, CR6_EQ, -392 */
		/* 820AFF20h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AFD98;  }
		/* 820AFF20h case    1:*/		return 0x820AFF24;
		  /* 820AFF24h */ case    2:  		/* addi R10, R10, 1 */
		/* 820AFF24h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AFF24h case    2:*/		return 0x820AFF28;
		  /* 820AFF28h */ case    3:  		/* add R31, R31, R29 */
		/* 820AFF28h case    3:*/		cpu::op::add<0>(regs,&regs.R31,regs.R31,regs.R29);
		/* 820AFF28h case    3:*/		return 0x820AFF2C;
		  /* 820AFF2Ch */ case    4:  		/* cmplw CR6, R10, R6 */
		/* 820AFF2Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 820AFF2Ch case    4:*/		return 0x820AFF30;
		  /* 820AFF30h */ case    5:  		/* bc 12, CR6_LT, -108 */
		/* 820AFF30h case    5:*/		if ( regs.CR[6].lt ) { return 0x820AFEC4;  }
		/* 820AFF30h case    5:*/		return 0x820AFF34;
	}
	return 0x820AFF34;
} // Block from 820AFF1Ch-820AFF34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820AFF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFF34);
		  /* 820AFF34h */ case    0:  		/* addi R24, R24, 1 */
		/* 820AFF34h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 820AFF34h case    0:*/		return 0x820AFF38;
		  /* 820AFF38h */ case    1:  		/* addi R4, R4, 4 */
		/* 820AFF38h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820AFF38h case    1:*/		return 0x820AFF3C;
		  /* 820AFF3Ch */ case    2:  		/* cmplw CR6, R24, R7 */
		/* 820AFF3Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R7);
		/* 820AFF3Ch case    2:*/		return 0x820AFF40;
		  /* 820AFF40h */ case    3:  		/* bc 12, CR6_LT, -176 */
		/* 820AFF40h case    3:*/		if ( regs.CR[6].lt ) { return 0x820AFE90;  }
		/* 820AFF40h case    3:*/		return 0x820AFF44;
	}
	return 0x820AFF44;
} // Block from 820AFF34h-820AFF44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820AFF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFF44);
		  /* 820AFF44h */ case    0:  		/* li R3, 1 */
		/* 820AFF44h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820AFF44h case    0:*/		return 0x820AFF48;
	}
	return 0x820AFF48;
} // Block from 820AFF44h-820AFF48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820AFF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFF48);
		  /* 820AFF48h */ case    0:  		/* b -126136 */
		/* 820AFF48h case    0:*/		return 0x82091290;
		/* 820AFF48h case    0:*/		return 0x820AFF4C;
		  /* 820AFF4Ch */ case    1:  		/* nop */
		/* 820AFF4Ch case    1:*/		cpu::op::nop();
		/* 820AFF4Ch case    1:*/		return 0x820AFF50;
	}
	return 0x820AFF50;
} // Block from 820AFF48h-820AFF50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820AFF50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFF50);
		  /* 820AFF50h */ case    0:  		/* mfspr R12, LR */
		/* 820AFF50h case    0:*/		regs.R12 = regs.LR;
		/* 820AFF50h case    0:*/		return 0x820AFF54;
		  /* 820AFF54h */ case    1:  		/* bl -126216 */
		/* 820AFF54h case    1:*/		regs.LR = 0x820AFF58; return 0x8209124C;
		/* 820AFF54h case    1:*/		return 0x820AFF58;
		  /* 820AFF58h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820AFF58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820AFF58h case    2:*/		return 0x820AFF5C;
		  /* 820AFF5Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 820AFF5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820AFF5Ch case    3:*/		return 0x820AFF60;
		  /* 820AFF60h */ case    4:  		/* li R25, -1 */
		/* 820AFF60h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 820AFF60h case    4:*/		return 0x820AFF64;
		  /* 820AFF64h */ case    5:  		/* mr R30, R3 */
		/* 820AFF64h case    5:*/		regs.R30 = regs.R3;
		/* 820AFF64h case    5:*/		return 0x820AFF68;
		  /* 820AFF68h */ case    6:  		/* mr R26, R4 */
		/* 820AFF68h case    6:*/		regs.R26 = regs.R4;
		/* 820AFF68h case    6:*/		return 0x820AFF6C;
		  /* 820AFF6Ch */ case    7:  		/* li R28, 0 */
		/* 820AFF6Ch case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820AFF6Ch case    7:*/		return 0x820AFF70;
		  /* 820AFF70h */ case    8:  		/* mr R29, R25 */
		/* 820AFF70h case    8:*/		regs.R29 = regs.R25;
		/* 820AFF70h case    8:*/		return 0x820AFF74;
		  /* 820AFF74h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820AFF74h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820AFF74h case    9:*/		return 0x820AFF78;
		  /* 820AFF78h */ case   10:  		/* bc 12, CR6_EQ, 280 */
		/* 820AFF78h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B0090;  }
		/* 820AFF78h case   10:*/		return 0x820AFF7C;
		  /* 820AFF7Ch */ case   11:  		/* lwz R10, <#[R11 + 4]> */
		/* 820AFF7Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820AFF7Ch case   11:*/		return 0x820AFF80;
		  /* 820AFF80h */ case   12:  		/* cmpwi CR6, R10, 4 */
		/* 820AFF80h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 820AFF80h case   12:*/		return 0x820AFF84;
		  /* 820AFF84h */ case   13:  		/* bc 4, CR6_EQ, 268 */
		/* 820AFF84h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820B0090;  }
		/* 820AFF84h case   13:*/		return 0x820AFF88;
		  /* 820AFF88h */ case   14:  		/* lwz R27, <#[R11 + 40]> */
		/* 820AFF88h case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000028) );
		/* 820AFF88h case   14:*/		return 0x820AFF8C;
		  /* 820AFF8Ch */ case   15:  		/* b 244 */
		/* 820AFF8Ch case   15:*/		return 0x820B0080;
		/* 820AFF8Ch case   15:*/		return 0x820AFF90;
		  /* 820AFF90h */ case   16:  		/* lwz R8, <#[R27 + 8]> */
		/* 820AFF90h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000008) );
		/* 820AFF90h case   16:*/		return 0x820AFF94;
		  /* 820AFF94h */ case   17:  		/* cmplwi CR6, R8, 0 */
		/* 820AFF94h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820AFF94h case   17:*/		return 0x820AFF98;
		  /* 820AFF98h */ case   18:  		/* bc 12, CR6_EQ, 228 */
		/* 820AFF98h case   18:*/		if ( regs.CR[6].eq ) { return 0x820B007C;  }
		/* 820AFF98h case   18:*/		return 0x820AFF9C;
		  /* 820AFF9Ch */ case   19:  		/* lwz R11, <#[R8 + 4]> */
		/* 820AFF9Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 820AFF9Ch case   19:*/		return 0x820AFFA0;
		  /* 820AFFA0h */ case   20:  		/* cmpwi CR6, R11, 6 */
		/* 820AFFA0h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820AFFA0h case   20:*/		return 0x820AFFA4;
		  /* 820AFFA4h */ case   21:  		/* bc 4, CR6_EQ, 216 */
		/* 820AFFA4h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820B007C;  }
		/* 820AFFA4h case   21:*/		return 0x820AFFA8;
		  /* 820AFFA8h */ case   22:  		/* lwz R11, <#[R8 + 16]> */
		/* 820AFFA8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 820AFFA8h case   22:*/		return 0x820AFFAC;
		  /* 820AFFACh */ case   23:  		/* cmpwi CR6, R11, 2 */
		/* 820AFFACh case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820AFFACh case   23:*/		return 0x820AFFB0;
		  /* 820AFFB0h */ case   24:  		/* bc 4, CR6_EQ, 204 */
		/* 820AFFB0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820B007C;  }
		/* 820AFFB0h case   24:*/		return 0x820AFFB4;
		  /* 820AFFB4h */ case   25:  		/* lwz R11, <#[R8 + 20]> */
		/* 820AFFB4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000014) );
		/* 820AFFB4h case   25:*/		return 0x820AFFB8;
		  /* 820AFFB8h */ case   26:  		/* mr R10, R26 */
		/* 820AFFB8h case   26:*/		regs.R10 = regs.R26;
		/* 820AFFB8h case   26:*/		return 0x820AFFBC;
		  /* 820AFFBCh */ case   27:  		/* lwz R11, <#[R11 + 24]> */
		/* 820AFFBCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820AFFBCh case   27:*/		return 0x820AFFC0;
		  /* 820AFFC0h */ case   28:  		/* lbz R9, <#[R11]> */
		/* 820AFFC0h case   28:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820AFFC0h case   28:*/		return 0x820AFFC4;
		  /* 820AFFC4h */ case   29:  		/* lbz R7, <#[R10]> */
		/* 820AFFC4h case   29:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820AFFC4h case   29:*/		return 0x820AFFC8;
		  /* 820AFFC8h */ case   30:  		/* cmpwi CR0, R9, 0 */
		/* 820AFFC8h case   30:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AFFC8h case   30:*/		return 0x820AFFCC;
		  /* 820AFFCCh */ case   31:  		/* subf R9, R7, R9 */
		/* 820AFFCCh case   31:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820AFFCCh case   31:*/		return 0x820AFFD0;
		  /* 820AFFD0h */ case   32:  		/* bc 12, CR0_EQ, 20 */
		/* 820AFFD0h case   32:*/		if ( regs.CR[0].eq ) { return 0x820AFFE4;  }
		/* 820AFFD0h case   32:*/		return 0x820AFFD4;
		  /* 820AFFD4h */ case   33:  		/* addi R11, R11, 1 */
		/* 820AFFD4h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820AFFD4h case   33:*/		return 0x820AFFD8;
		  /* 820AFFD8h */ case   34:  		/* addi R10, R10, 1 */
		/* 820AFFD8h case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820AFFD8h case   34:*/		return 0x820AFFDC;
		  /* 820AFFDCh */ case   35:  		/* cmpwi CR6, R9, 0 */
		/* 820AFFDCh case   35:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820AFFDCh case   35:*/		return 0x820AFFE0;
		  /* 820AFFE0h */ case   36:  		/* bc 12, CR6_EQ, -32 */
		/* 820AFFE0h case   36:*/		if ( regs.CR[6].eq ) { return 0x820AFFC0;  }
		/* 820AFFE0h case   36:*/		return 0x820AFFE4;
	}
	return 0x820AFFE4;
} // Block from 820AFF50h-820AFFE4h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820AFFE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820AFFE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820AFFE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820AFFE4);
		  /* 820AFFE4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820AFFE4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820AFFE4h case    0:*/		return 0x820AFFE8;
		  /* 820AFFE8h */ case    1:  		/* bc 4, CR0_EQ, 148 */
		/* 820AFFE8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820B007C;  }
		/* 820AFFE8h case    1:*/		return 0x820AFFEC;
		  /* 820AFFECh */ case    2:  		/* lwz R31, <#[R8 + 24]> */
		/* 820AFFECh case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + 0x00000018) );
		/* 820AFFECh case    2:*/		return 0x820AFFF0;
		  /* 820AFFF0h */ case    3:  		/* lwz R11, <#[R31 + 76]> */
		/* 820AFFF0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820AFFF0h case    3:*/		return 0x820AFFF4;
		  /* 820AFFF4h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820AFFF4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820AFFF4h case    4:*/		return 0x820AFFF8;
		  /* 820AFFF8h */ case    5:  		/* bc 12, CR6_EQ, 132 */
		/* 820AFFF8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820B007C;  }
		/* 820AFFF8h case    5:*/		return 0x820AFFFC;
		  /* 820AFFFCh */ case    6:  		/* lwz R11, <#[R31 + 32]> */
		/* 820AFFFCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820AFFFCh case    6:*/		return 0x820B0000;
		  /* 820B0000h */ case    7:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820B0000h case    7:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820B0000h case    7:*/		return 0x820B0004;
		  /* 820B0004h */ case    8:  		/* bc 4, CR0_EQ, 120 */
		/* 820B0004h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820B007C;  }
		/* 820B0004h case    8:*/		return 0x820B0008;
		  /* 820B0008h */ case    9:  		/* lwz R10, <#[R31 + 36]> */
		/* 820B0008h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 820B0008h case    9:*/		return 0x820B000C;
		  /* 820B000Ch */ case   10:  		/* li R11, 0 */
		/* 820B000Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B000Ch case   10:*/		return 0x820B0010;
		  /* 820B0010h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820B0010h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B0010h case   11:*/		return 0x820B0014;
		  /* 820B0014h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 820B0014h case   12:*/		if ( regs.CR[6].eq ) { return 0x820B0038;  }
		/* 820B0014h case   12:*/		return 0x820B0018;
		  /* 820B0018h */ case   13:  		/* addi R5, R1, 80 */
		/* 820B0018h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B0018h case   13:*/		return 0x820B001C;
		  /* 820B001Ch */ case   14:  		/* lwz R3, <#[R10 + 24]> */
		/* 820B001Ch case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000018) );
		/* 820B001Ch case   14:*/		return 0x820B0020;
		  /* 820B0020h */ case   15:  		/* li R4, 0 */
		/* 820B0020h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B0020h case   15:*/		return 0x820B0024;
		  /* 820B0024h */ case   16:  		/* bl -70292 */
		/* 820B0024h case   16:*/		regs.LR = 0x820B0028; return 0x8209ED90;
		/* 820B0024h case   16:*/		return 0x820B0028;
		  /* 820B0028h */ case   17:  		/* lwz R11, <#[R1 + 84]> */
		/* 820B0028h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820B0028h case   17:*/		return 0x820B002C;
		  /* 820B002Ch */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 820B002Ch case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B002Ch case   18:*/		return 0x820B0030;
		  /* 820B0030h */ case   19:  		/* bc 4, CR0_LT, 8 */
		/* 820B0030h case   19:*/		if ( !regs.CR[0].lt ) { return 0x820B0038;  }
		/* 820B0030h case   19:*/		return 0x820B0034;
		  /* 820B0034h */ case   20:  		/* mr R11, R25 */
		/* 820B0034h case   20:*/		regs.R11 = regs.R25;
		/* 820B0034h case   20:*/		return 0x820B0038;
	}
	return 0x820B0038;
} // Block from 820AFFE4h-820B0038h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820B0038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0038);
		  /* 820B0038h */ case    0:  		/* rlwinm. R10, R11, 0, 0, 15 */
		/* 820B0038h case    0:*/		cpu::op::rlwinm<1,0,0,15>(regs,&regs.R10,regs.R11);
		/* 820B0038h case    0:*/		return 0x820B003C;
		  /* 820B003Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820B003Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820B0050;  }
		/* 820B003Ch case    1:*/		return 0x820B0040;
		  /* 820B0040h */ case    2:  		/* lwz R9, <#[R30 + 16]> */
		/* 820B0040h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 820B0040h case    2:*/		return 0x820B0044;
		  /* 820B0044h */ case    3:  		/* rlwinm R9, R9, 0, 0, 15 */
		/* 820B0044h case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R9,regs.R9);
		/* 820B0044h case    3:*/		return 0x820B0048;
		  /* 820B0048h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 820B0048h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820B0048h case    4:*/		return 0x820B004C;
		  /* 820B004Ch */ case    5:  		/* bc 4, CR6_EQ, 48 */
		/* 820B004Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820B007C;  }
		/* 820B004Ch case    5:*/		return 0x820B0050;
	}
	return 0x820B0050;
} // Block from 820B0038h-820B0050h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B0050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0050);
		  /* 820B0050h */ case    0:  		/* rlwinm. R10, R11, 0, 16, 31 */
		/* 820B0050h case    0:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R10,regs.R11);
		/* 820B0050h case    0:*/		return 0x820B0054;
		  /* 820B0054h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820B0054h case    1:*/		if ( regs.CR[0].eq ) { return 0x820B0064;  }
		/* 820B0054h case    1:*/		return 0x820B0058;
		  /* 820B0058h */ case    2:  		/* lhz R9, <#[R30 + 18]> */
		/* 820B0058h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000012) );
		/* 820B0058h case    2:*/		return 0x820B005C;
		  /* 820B005Ch */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 820B005Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820B005Ch case    3:*/		return 0x820B0060;
		  /* 820B0060h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 820B0060h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820B007C;  }
		/* 820B0060h case    4:*/		return 0x820B0064;
	}
	return 0x820B0064;
} // Block from 820B0050h-820B0064h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B0064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0064);
		  /* 820B0064h */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 820B0064h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 820B0064h case    0:*/		return 0x820B0068;
		  /* 820B0068h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820B0068h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B0074;  }
		/* 820B0068h case    1:*/		return 0x820B006C;
		  /* 820B006Ch */ case    2:  		/* cmplw CR6, R11, R29 */
		/* 820B006Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820B006Ch case    2:*/		return 0x820B0070;
		  /* 820B0070h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 820B0070h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820B007C;  }
		/* 820B0070h case    3:*/		return 0x820B0074;
	}
	return 0x820B0074;
} // Block from 820B0064h-820B0074h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B0074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0074);
		  /* 820B0074h */ case    0:  		/* mr R28, R31 */
		/* 820B0074h case    0:*/		regs.R28 = regs.R31;
		/* 820B0074h case    0:*/		return 0x820B0078;
		  /* 820B0078h */ case    1:  		/* mr R29, R11 */
		/* 820B0078h case    1:*/		regs.R29 = regs.R11;
		/* 820B0078h case    1:*/		return 0x820B007C;
	}
	return 0x820B007C;
} // Block from 820B0074h-820B007Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B007Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B007C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B007C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B007C);
		  /* 820B007Ch */ case    0:  		/* lwz R27, <#[R27 + 12]> */
		/* 820B007Ch case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x0000000C) );
		/* 820B007Ch case    0:*/		return 0x820B0080;
	}
	return 0x820B0080;
} // Block from 820B007Ch-820B0080h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0080);
		  /* 820B0080h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820B0080h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820B0080h case    0:*/		return 0x820B0084;
		  /* 820B0084h */ case    1:  		/* bc 4, CR6_EQ, -244 */
		/* 820B0084h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820AFF90;  }
		/* 820B0084h case    1:*/		return 0x820B0088;
		  /* 820B0088h */ case    2:  		/* mr R3, R28 */
		/* 820B0088h case    2:*/		regs.R3 = regs.R28;
		/* 820B0088h case    2:*/		return 0x820B008C;
		  /* 820B008Ch */ case    3:  		/* b 8 */
		/* 820B008Ch case    3:*/		return 0x820B0094;
		/* 820B008Ch case    3:*/		return 0x820B0090;
	}
	return 0x820B0090;
} // Block from 820B0080h-820B0090h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B0090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0090);
		  /* 820B0090h */ case    0:  		/* li R3, 0 */
		/* 820B0090h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B0090h case    0:*/		return 0x820B0094;
	}
	return 0x820B0094;
} // Block from 820B0090h-820B0094h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0094);
		  /* 820B0094h */ case    0:  		/* addi R1, R1, 160 */
		/* 820B0094h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820B0094h case    0:*/		return 0x820B0098;
		  /* 820B0098h */ case    1:  		/* b -126460 */
		/* 820B0098h case    1:*/		return 0x8209129C;
		/* 820B0098h case    1:*/		return 0x820B009C;
		  /* 820B009Ch */ case    2:  		/* nop */
		/* 820B009Ch case    2:*/		cpu::op::nop();
		/* 820B009Ch case    2:*/		return 0x820B00A0;
	}
	return 0x820B00A0;
} // Block from 820B0094h-820B00A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B00A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B00A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B00A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B00A0);
		  /* 820B00A0h */ case    0:  		/* mfspr R12, LR */
		/* 820B00A0h case    0:*/		regs.R12 = regs.LR;
		/* 820B00A0h case    0:*/		return 0x820B00A4;
		  /* 820B00A4h */ case    1:  		/* bl -126564 */
		/* 820B00A4h case    1:*/		regs.LR = 0x820B00A8; return 0x82091240;
		/* 820B00A4h case    1:*/		return 0x820B00A8;
		  /* 820B00A8h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820B00A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820B00A8h case    2:*/		return 0x820B00AC;
		  /* 820B00ACh */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 820B00ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820B00ACh case    3:*/		return 0x820B00B0;
		  /* 820B00B0h */ case    4:  		/* li R23, -1 */
		/* 820B00B0h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 820B00B0h case    4:*/		return 0x820B00B4;
		  /* 820B00B4h */ case    5:  		/* mr R28, R3 */
		/* 820B00B4h case    5:*/		regs.R28 = regs.R3;
		/* 820B00B4h case    5:*/		return 0x820B00B8;
		  /* 820B00B8h */ case    6:  		/* mr R24, R4 */
		/* 820B00B8h case    6:*/		regs.R24 = regs.R4;
		/* 820B00B8h case    6:*/		return 0x820B00BC;
		  /* 820B00BCh */ case    7:  		/* mr R22, R5 */
		/* 820B00BCh case    7:*/		regs.R22 = regs.R5;
		/* 820B00BCh case    7:*/		return 0x820B00C0;
		  /* 820B00C0h */ case    8:  		/* li R26, 0 */
		/* 820B00C0h case    8:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820B00C0h case    8:*/		return 0x820B00C4;
		  /* 820B00C4h */ case    9:  		/* mr R29, R23 */
		/* 820B00C4h case    9:*/		regs.R29 = regs.R23;
		/* 820B00C4h case    9:*/		return 0x820B00C8;
		  /* 820B00C8h */ case   10:  		/* li R27, 0 */
		/* 820B00C8h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820B00C8h case   10:*/		return 0x820B00CC;
		  /* 820B00CCh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820B00CCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B00CCh case   11:*/		return 0x820B00D0;
		  /* 820B00D0h */ case   12:  		/* bc 12, CR6_EQ, 284 */
		/* 820B00D0h case   12:*/		if ( regs.CR[6].eq ) { return 0x820B01EC;  }
		/* 820B00D0h case   12:*/		return 0x820B00D4;
		  /* 820B00D4h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B00D4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B00D4h case   13:*/		return 0x820B00D8;
		  /* 820B00D8h */ case   14:  		/* cmpwi CR6, R10, 4 */
		/* 820B00D8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 820B00D8h case   14:*/		return 0x820B00DC;
		  /* 820B00DCh */ case   15:  		/* bc 4, CR6_EQ, 272 */
		/* 820B00DCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820B01EC;  }
		/* 820B00DCh case   15:*/		return 0x820B00E0;
		  /* 820B00E0h */ case   16:  		/* lwz R25, <#[R11 + 40]> */
		/* 820B00E0h case   16:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000028) );
		/* 820B00E0h case   16:*/		return 0x820B00E4;
		  /* 820B00E4h */ case   17:  		/* b 236 */
		/* 820B00E4h case   17:*/		return 0x820B01D0;
		/* 820B00E4h case   17:*/		return 0x820B00E8;
		  /* 820B00E8h */ case   18:  		/* lwz R30, <#[R25 + 8]> */
		/* 820B00E8h case   18:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000008) );
		/* 820B00E8h case   18:*/		return 0x820B00EC;
		  /* 820B00ECh */ case   19:  		/* cmplwi CR6, R30, 0 */
		/* 820B00ECh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B00ECh case   19:*/		return 0x820B00F0;
		  /* 820B00F0h */ case   20:  		/* bc 12, CR6_EQ, 220 */
		/* 820B00F0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B00F0h case   20:*/		return 0x820B00F4;
		  /* 820B00F4h */ case   21:  		/* lwz R11, <#[R30 + 4]> */
		/* 820B00F4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820B00F4h case   21:*/		return 0x820B00F8;
		  /* 820B00F8h */ case   22:  		/* cmpwi CR6, R11, 6 */
		/* 820B00F8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820B00F8h case   22:*/		return 0x820B00FC;
		  /* 820B00FCh */ case   23:  		/* bc 4, CR6_EQ, 208 */
		/* 820B00FCh case   23:*/		if ( !regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B00FCh case   23:*/		return 0x820B0100;
		  /* 820B0100h */ case   24:  		/* lwz R11, <#[R30 + 16]> */
		/* 820B0100h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820B0100h case   24:*/		return 0x820B0104;
		  /* 820B0104h */ case   25:  		/* cmpwi CR6, R11, 2 */
		/* 820B0104h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 820B0104h case   25:*/		return 0x820B0108;
		  /* 820B0108h */ case   26:  		/* bc 4, CR6_EQ, 196 */
		/* 820B0108h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B0108h case   26:*/		return 0x820B010C;
		  /* 820B010Ch */ case   27:  		/* mr R11, R24 */
		/* 820B010Ch case   27:*/		regs.R11 = regs.R24;
		/* 820B010Ch case   27:*/		return 0x820B0110;
		  /* 820B0110h */ case   28:  		/* cmplwi CR6, R24, 0 */
		/* 820B0110h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820B0110h case   28:*/		return 0x820B0114;
		  /* 820B0114h */ case   29:  		/* bc 12, CR6_EQ, 184 */
		/* 820B0114h case   29:*/		if ( regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B0114h case   29:*/		return 0x820B0118;
		  /* 820B0118h */ case   30:  		/* lwz R10, <#[R30 + 40]> */
		/* 820B0118h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 820B0118h case   30:*/		return 0x820B011C;
		  /* 820B011Ch */ case   31:  		/* lwz R9, <#[R11 + 8]> */
		/* 820B011Ch case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820B011Ch case   31:*/		return 0x820B0120;
		  /* 820B0120h */ case   32:  		/* lwz R9, <#[R9 + 24]> */
		/* 820B0120h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 820B0120h case   32:*/		return 0x820B0124;
		  /* 820B0124h */ case   33:  		/* cmplw CR6, R10, R9 */
		/* 820B0124h case   33:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820B0124h case   33:*/		return 0x820B0128;
		  /* 820B0128h */ case   34:  		/* bc 12, CR6_EQ, 16 */
		/* 820B0128h case   34:*/		if ( regs.CR[6].eq ) { return 0x820B0138;  }
		/* 820B0128h case   34:*/		return 0x820B012C;
		  /* 820B012Ch */ case   35:  		/* lwz R11, <#[R11 + 12]> */
		/* 820B012Ch case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820B012Ch case   35:*/		return 0x820B0130;
		  /* 820B0130h */ case   36:  		/* cmplwi CR6, R11, 0 */
		/* 820B0130h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B0130h case   36:*/		return 0x820B0134;
		  /* 820B0134h */ case   37:  		/* bc 4, CR6_EQ, -24 */
		/* 820B0134h case   37:*/		if ( !regs.CR[6].eq ) { return 0x820B011C;  }
		/* 820B0134h case   37:*/		return 0x820B0138;
	}
	return 0x820B0138;
} // Block from 820B00A0h-820B0138h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820B0138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0138);
		  /* 820B0138h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820B0138h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B0138h case    0:*/		return 0x820B013C;
		  /* 820B013Ch */ case    1:  		/* bc 12, CR6_EQ, 144 */
		/* 820B013Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B013Ch case    1:*/		return 0x820B0140;
		  /* 820B0140h */ case    2:  		/* lwz R31, <#[R30 + 24]> */
		/* 820B0140h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000018) );
		/* 820B0140h case    2:*/		return 0x820B0144;
		  /* 820B0144h */ case    3:  		/* lwz R11, <#[R31 + 76]> */
		/* 820B0144h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820B0144h case    3:*/		return 0x820B0148;
		  /* 820B0148h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820B0148h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820B0148h case    4:*/		return 0x820B014C;
		  /* 820B014Ch */ case    5:  		/* bc 12, CR6_EQ, 128 */
		/* 820B014Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B014Ch case    5:*/		return 0x820B0150;
		  /* 820B0150h */ case    6:  		/* lwz R10, <#[R31 + 36]> */
		/* 820B0150h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 820B0150h case    6:*/		return 0x820B0154;
		  /* 820B0154h */ case    7:  		/* li R11, 0 */
		/* 820B0154h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B0154h case    7:*/		return 0x820B0158;
		  /* 820B0158h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820B0158h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B0158h case    8:*/		return 0x820B015C;
		  /* 820B015Ch */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 820B015Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820B0180;  }
		/* 820B015Ch case    9:*/		return 0x820B0160;
		  /* 820B0160h */ case   10:  		/* addi R5, R1, 80 */
		/* 820B0160h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B0160h case   10:*/		return 0x820B0164;
		  /* 820B0164h */ case   11:  		/* lwz R3, <#[R10 + 24]> */
		/* 820B0164h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000018) );
		/* 820B0164h case   11:*/		return 0x820B0168;
		  /* 820B0168h */ case   12:  		/* li R4, 0 */
		/* 820B0168h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B0168h case   12:*/		return 0x820B016C;
		  /* 820B016Ch */ case   13:  		/* bl -70620 */
		/* 820B016Ch case   13:*/		regs.LR = 0x820B0170; return 0x8209ED90;
		/* 820B016Ch case   13:*/		return 0x820B0170;
		  /* 820B0170h */ case   14:  		/* lwz R11, <#[R1 + 84]> */
		/* 820B0170h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820B0170h case   14:*/		return 0x820B0174;
		  /* 820B0174h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820B0174h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0174h case   15:*/		return 0x820B0178;
		  /* 820B0178h */ case   16:  		/* bc 4, CR0_LT, 8 */
		/* 820B0178h case   16:*/		if ( !regs.CR[0].lt ) { return 0x820B0180;  }
		/* 820B0178h case   16:*/		return 0x820B017C;
		  /* 820B017Ch */ case   17:  		/* mr R11, R23 */
		/* 820B017Ch case   17:*/		regs.R11 = regs.R23;
		/* 820B017Ch case   17:*/		return 0x820B0180;
	}
	return 0x820B0180;
} // Block from 820B0138h-820B0180h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820B0180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0180);
		  /* 820B0180h */ case    0:  		/* rlwinm. R10, R11, 0, 0, 15 */
		/* 820B0180h case    0:*/		cpu::op::rlwinm<1,0,0,15>(regs,&regs.R10,regs.R11);
		/* 820B0180h case    0:*/		return 0x820B0184;
		  /* 820B0184h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820B0184h case    1:*/		if ( regs.CR[0].eq ) { return 0x820B0198;  }
		/* 820B0184h case    1:*/		return 0x820B0188;
		  /* 820B0188h */ case    2:  		/* lwz R9, <#[R28 + 16]> */
		/* 820B0188h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000010) );
		/* 820B0188h case    2:*/		return 0x820B018C;
		  /* 820B018Ch */ case    3:  		/* rlwinm R9, R9, 0, 0, 15 */
		/* 820B018Ch case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R9,regs.R9);
		/* 820B018Ch case    3:*/		return 0x820B0190;
		  /* 820B0190h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 820B0190h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820B0190h case    4:*/		return 0x820B0194;
		  /* 820B0194h */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 820B0194h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B0194h case    5:*/		return 0x820B0198;
	}
	return 0x820B0198;
} // Block from 820B0180h-820B0198h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B0198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0198);
		  /* 820B0198h */ case    0:  		/* rlwinm. R10, R11, 0, 16, 31 */
		/* 820B0198h case    0:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R10,regs.R11);
		/* 820B0198h case    0:*/		return 0x820B019C;
		  /* 820B019Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820B019Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820B01AC;  }
		/* 820B019Ch case    1:*/		return 0x820B01A0;
		  /* 820B01A0h */ case    2:  		/* lhz R9, <#[R28 + 18]> */
		/* 820B01A0h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000012) );
		/* 820B01A0h case    2:*/		return 0x820B01A4;
		  /* 820B01A4h */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 820B01A4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820B01A4h case    3:*/		return 0x820B01A8;
		  /* 820B01A8h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 820B01A8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820B01CC;  }
		/* 820B01A8h case    4:*/		return 0x820B01AC;
	}
	return 0x820B01AC;
} // Block from 820B0198h-820B01ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B01ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01AC);
		  /* 820B01ACh */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 820B01ACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 820B01ACh case    0:*/		return 0x820B01B0;
		  /* 820B01B0h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820B01B0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B01BC;  }
		/* 820B01B0h case    1:*/		return 0x820B01B4;
		  /* 820B01B4h */ case    2:  		/* cmplw CR6, R11, R29 */
		/* 820B01B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820B01B4h case    2:*/		return 0x820B01B8;
		  /* 820B01B8h */ case    3:  		/* bc 4, CR6_GT, 20 */
		/* 820B01B8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820B01CC;  }
		/* 820B01B8h case    3:*/		return 0x820B01BC;
	}
	return 0x820B01BC;
} // Block from 820B01ACh-820B01BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B01BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01BC);
		  /* 820B01BCh */ case    0:  		/* lwz R10, <#[R30 + 20]> */
		/* 820B01BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820B01BCh case    0:*/		return 0x820B01C0;
		  /* 820B01C0h */ case    1:  		/* mr R26, R31 */
		/* 820B01C0h case    1:*/		regs.R26 = regs.R31;
		/* 820B01C0h case    1:*/		return 0x820B01C4;
		  /* 820B01C4h */ case    2:  		/* mr R29, R11 */
		/* 820B01C4h case    2:*/		regs.R29 = regs.R11;
		/* 820B01C4h case    2:*/		return 0x820B01C8;
		  /* 820B01C8h */ case    3:  		/* lwz R27, <#[R10 + 24]> */
		/* 820B01C8h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0x00000018) );
		/* 820B01C8h case    3:*/		return 0x820B01CC;
	}
	return 0x820B01CC;
} // Block from 820B01BCh-820B01CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B01CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01CC);
		  /* 820B01CCh */ case    0:  		/* lwz R25, <#[R25 + 12]> */
		/* 820B01CCh case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x0000000C) );
		/* 820B01CCh case    0:*/		return 0x820B01D0;
	}
	return 0x820B01D0;
} // Block from 820B01CCh-820B01D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B01D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01D0);
		  /* 820B01D0h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820B01D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B01D0h case    0:*/		return 0x820B01D4;
		  /* 820B01D4h */ case    1:  		/* bc 4, CR6_EQ, -236 */
		/* 820B01D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B00E8;  }
		/* 820B01D4h case    1:*/		return 0x820B01D8;
		  /* 820B01D8h */ case    2:  		/* cmplwi CR6, R22, 0 */
		/* 820B01D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820B01D8h case    2:*/		return 0x820B01DC;
		  /* 820B01DCh */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 820B01DCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820B01E4;  }
		/* 820B01DCh case    3:*/		return 0x820B01E0;
		  /* 820B01E0h */ case    4:  		/* stw R27, <#[R22]> */
		/* 820B01E0h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R22 + 0x00000000) );
		/* 820B01E0h case    4:*/		return 0x820B01E4;
	}
	return 0x820B01E4;
} // Block from 820B01D0h-820B01E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B01E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01E4);
		  /* 820B01E4h */ case    0:  		/* mr R3, R26 */
		/* 820B01E4h case    0:*/		regs.R3 = regs.R26;
		/* 820B01E4h case    0:*/		return 0x820B01E8;
		  /* 820B01E8h */ case    1:  		/* b 8 */
		/* 820B01E8h case    1:*/		return 0x820B01F0;
		/* 820B01E8h case    1:*/		return 0x820B01EC;
	}
	return 0x820B01EC;
} // Block from 820B01E4h-820B01ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B01ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01EC);
		  /* 820B01ECh */ case    0:  		/* li R3, 0 */
		/* 820B01ECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B01ECh case    0:*/		return 0x820B01F0;
	}
	return 0x820B01F0;
} // Block from 820B01ECh-820B01F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B01F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01F0);
		  /* 820B01F0h */ case    0:  		/* addi R1, R1, 192 */
		/* 820B01F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820B01F0h case    0:*/		return 0x820B01F4;
		  /* 820B01F4h */ case    1:  		/* b -126820 */
		/* 820B01F4h case    1:*/		return 0x82091290;
		/* 820B01F4h case    1:*/		return 0x820B01F8;
	}
	return 0x820B01F8;
} // Block from 820B01F0h-820B01F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B01F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B01F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B01F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B01F8);
		  /* 820B01F8h */ case    0:  		/* mfspr R12, LR */
		/* 820B01F8h case    0:*/		regs.R12 = regs.LR;
		/* 820B01F8h case    0:*/		return 0x820B01FC;
		  /* 820B01FCh */ case    1:  		/* bl -126888 */
		/* 820B01FCh case    1:*/		regs.LR = 0x820B0200; return 0x82091254;
		/* 820B01FCh case    1:*/		return 0x820B0200;
		  /* 820B0200h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820B0200h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820B0200h case    2:*/		return 0x820B0204;
		  /* 820B0204h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820B0204h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820B0204h case    3:*/		return 0x820B0208;
		  /* 820B0208h */ case    4:  		/* mr R27, R3 */
		/* 820B0208h case    4:*/		regs.R27 = regs.R3;
		/* 820B0208h case    4:*/		return 0x820B020C;
		  /* 820B020Ch */ case    5:  		/* lwz R28, <#[R11 + 68]> */
		/* 820B020Ch case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000044) );
		/* 820B020Ch case    5:*/		return 0x820B0210;
		  /* 820B0210h */ case    6:  		/* b 240 */
		/* 820B0210h case    6:*/		return 0x820B0300;
		/* 820B0210h case    6:*/		return 0x820B0214;
		  /* 820B0214h */ case    7:  		/* lwz R29, <#[R28 + 4]> */
		/* 820B0214h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000004) );
		/* 820B0214h case    7:*/		return 0x820B0218;
		  /* 820B0218h */ case    8:  		/* li R30, 0 */
		/* 820B0218h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B0218h case    8:*/		return 0x820B021C;
		  /* 820B021Ch */ case    9:  		/* li R31, 0 */
		/* 820B021Ch case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B021Ch case    9:*/		return 0x820B0220;
		  /* 820B0220h */ case   10:  		/* mr R3, R29 */
		/* 820B0220h case   10:*/		regs.R3 = regs.R29;
		/* 820B0220h case   10:*/		return 0x820B0224;
		  /* 820B0224h */ case   11:  		/* lwz R4, <#[R28 + 4]> */
		/* 820B0224h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000004) );
		/* 820B0224h case   11:*/		return 0x820B0228;
		  /* 820B0228h */ case   12:  		/* bl -118264 */
		/* 820B0228h case   12:*/		regs.LR = 0x820B022C; return 0x82093430;
		/* 820B0228h case   12:*/		return 0x820B022C;
		  /* 820B022Ch */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 820B022Ch case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B022Ch case   13:*/		return 0x820B0230;
		  /* 820B0230h */ case   14:  		/* bc 4, CR0_EQ, 96 */
		/* 820B0230h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820B0290;  }
		/* 820B0230h case   14:*/		return 0x820B0234;
		  /* 820B0234h */ case   15:  		/* addi R5, R1, 80 */
		/* 820B0234h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B0234h case   15:*/		return 0x820B0238;
		  /* 820B0238h */ case   16:  		/* lwz R3, <#[R28]> */
		/* 820B0238h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 820B0238h case   16:*/		return 0x820B023C;
		  /* 820B023Ch */ case   17:  		/* li R4, 0 */
		/* 820B023Ch case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B023Ch case   17:*/		return 0x820B0240;
		  /* 820B0240h */ case   18:  		/* bl -70832 */
		/* 820B0240h case   18:*/		regs.LR = 0x820B0244; return 0x8209ED90;
		/* 820B0240h case   18:*/		return 0x820B0244;
		  /* 820B0244h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 820B0244h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0244h case   19:*/		return 0x820B0248;
		  /* 820B0248h */ case   20:  		/* bc 12, CR0_LT, 60 */
		/* 820B0248h case   20:*/		if ( regs.CR[0].lt ) { return 0x820B0284;  }
		/* 820B0248h case   20:*/		return 0x820B024C;
		  /* 820B024Ch */ case   21:  		/* lwz R11, <#[R27 + 16]> */
		/* 820B024Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 820B024Ch case   21:*/		return 0x820B0250;
		  /* 820B0250h */ case   22:  		/* lwz R10, <#[R1 + 84]> */
		/* 820B0250h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820B0250h case   22:*/		return 0x820B0254;
		  /* 820B0254h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820B0254h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B0254h case   23:*/		return 0x820B0258;
		  /* 820B0258h */ case   24:  		/* bc 4, CR6_EQ, 20 */
		/* 820B0258h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820B026C;  }
		/* 820B0258h case   24:*/		return 0x820B025C;
		  /* 820B025Ch */ case   25:  		/* cmplwi CR6, R30, 0 */
		/* 820B025Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B025Ch case   25:*/		return 0x820B0260;
		  /* 820B0260h */ case   26:  		/* bc 4, CR6_EQ, 36 */
		/* 820B0260h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820B0284;  }
		/* 820B0260h case   26:*/		return 0x820B0264;
		  /* 820B0264h */ case   27:  		/* mr R30, R28 */
		/* 820B0264h case   27:*/		regs.R30 = regs.R28;
		/* 820B0264h case   27:*/		return 0x820B0268;
		  /* 820B0268h */ case   28:  		/* b 28 */
		/* 820B0268h case   28:*/		return 0x820B0284;
		/* 820B0268h case   28:*/		return 0x820B026C;
	}
	return 0x820B026C;
} // Block from 820B01F8h-820B026Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 820B026Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B026C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B026C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B026C);
		  /* 820B026Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820B026Ch case    0:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820B026Ch case    0:*/		return 0x820B0270;
		  /* 820B0270h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820B0270h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B0270h case    1:*/		return 0x820B0274;
		  /* 820B0274h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820B0274h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B0284;  }
		/* 820B0274h case    2:*/		return 0x820B0278;
		  /* 820B0278h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 820B0278h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B0278h case    3:*/		return 0x820B027C;
		  /* 820B027Ch */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 820B027Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820B0284;  }
		/* 820B027Ch case    4:*/		return 0x820B0280;
		  /* 820B0280h */ case    5:  		/* mr R31, R28 */
		/* 820B0280h case    5:*/		regs.R31 = regs.R28;
		/* 820B0280h case    5:*/		return 0x820B0284;
	}
	return 0x820B0284;
} // Block from 820B026Ch-820B0284h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B0284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0284);
		  /* 820B0284h */ case    0:  		/* lwz R28, <#[R28 + 40]> */
		/* 820B0284h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000028) );
		/* 820B0284h case    0:*/		return 0x820B0288;
		  /* 820B0288h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820B0288h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820B0288h case    1:*/		return 0x820B028C;
		  /* 820B028Ch */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 820B028Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B0220;  }
		/* 820B028Ch case    2:*/		return 0x820B0290;
	}
	return 0x820B0290;
} // Block from 820B0284h-820B0290h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B0290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0290);
		  /* 820B0290h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820B0290h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B0290h case    0:*/		return 0x820B0294;
		  /* 820B0294h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820B0294h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B02A4;  }
		/* 820B0294h case    1:*/		return 0x820B0298;
		  /* 820B0298h */ case    2:  		/* mr R30, R31 */
		/* 820B0298h case    2:*/		regs.R30 = regs.R31;
		/* 820B0298h case    2:*/		return 0x820B029C;
		  /* 820B029Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 820B029Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B029Ch case    3:*/		return 0x820B02A0;
		  /* 820B02A0h */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 820B02A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820B0300;  }
		/* 820B02A0h case    4:*/		return 0x820B02A4;
	}
	return 0x820B02A4;
} // Block from 820B0290h-820B02A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B02A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B02A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B02A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B02A4);
		  /* 820B02A4h */ case    0:  		/* li R7, 4 */
		/* 820B02A4h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820B02A4h case    0:*/		return 0x820B02A8;
		  /* 820B02A8h */ case    1:  		/* lwz R4, <#[R30 + 4]> */
		/* 820B02A8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000004) );
		/* 820B02A8h case    1:*/		return 0x820B02AC;
		  /* 820B02ACh */ case    2:  		/* li R6, 1 */
		/* 820B02ACh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820B02ACh case    2:*/		return 0x820B02B0;
		  /* 820B02B0h */ case    3:  		/* lwz R3, <#[R27 + 8]> */
		/* 820B02B0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000008) );
		/* 820B02B0h case    3:*/		return 0x820B02B4;
		  /* 820B02B4h */ case    4:  		/* li R5, 2897 */
		/* 820B02B4h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0xB51);
		/* 820B02B4h case    4:*/		return 0x820B02B8;
		  /* 820B02B8h */ case    5:  		/* bl 315088 */
		/* 820B02B8h case    5:*/		regs.LR = 0x820B02BC; return 0x820FD188;
		/* 820B02B8h case    5:*/		return 0x820B02BC;
		  /* 820B02BCh */ case    6:  		/* mr R29, R3 */
		/* 820B02BCh case    6:*/		regs.R29 = regs.R3;
		/* 820B02BCh case    6:*/		return 0x820B02C0;
		  /* 820B02C0h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820B02C0h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820B02C0h case    7:*/		return 0x820B02C4;
		  /* 820B02C4h */ case    8:  		/* bc 12, CR6_EQ, 80 */
		/* 820B02C4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820B0314;  }
		/* 820B02C4h case    8:*/		return 0x820B02C8;
		  /* 820B02C8h */ case    9:  		/* li R31, 0 */
		/* 820B02C8h case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B02C8h case    9:*/		return 0x820B02CC;
		  /* 820B02CCh */ case   10:  		/* addi R30, R30, 8 */
		/* 820B02CCh case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 820B02CCh case   10:*/		return 0x820B02D0;
		  /* 820B02D0h */ case   11:  		/* mr R6, R31 */
		/* 820B02D0h case   11:*/		regs.R6 = regs.R31;
		/* 820B02D0h case   11:*/		return 0x820B02D4;
		  /* 820B02D4h */ case   12:  		/* lfd FR1, <#[R30]> */
		/* 820B02D4h case   12:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R30 + 0x00000000) );
		/* 820B02D4h case   12:*/		return 0x820B02D8;
		  /* 820B02D8h */ case   13:  		/* li R5, 0 */
		/* 820B02D8h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B02D8h case   13:*/		return 0x820B02DC;
		  /* 820B02DCh */ case   14:  		/* lwz R3, <#[R27 + 8]> */
		/* 820B02DCh case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000008) );
		/* 820B02DCh case   14:*/		return 0x820B02E0;
		  /* 820B02E0h */ case   15:  		/* mr R4, R29 */
		/* 820B02E0h case   15:*/		regs.R4 = regs.R29;
		/* 820B02E0h case   15:*/		return 0x820B02E4;
		  /* 820B02E4h */ case   16:  		/* bl 315204 */
		/* 820B02E4h case   16:*/		regs.LR = 0x820B02E8; return 0x820FD228;
		/* 820B02E4h case   16:*/		return 0x820B02E8;
		  /* 820B02E8h */ case   17:  		/* cmpwi CR6, R3, -1 */
		/* 820B02E8h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820B02E8h case   17:*/		return 0x820B02EC;
		  /* 820B02ECh */ case   18:  		/* bc 12, CR6_EQ, 40 */
		/* 820B02ECh case   18:*/		if ( regs.CR[6].eq ) { return 0x820B0314;  }
		/* 820B02ECh case   18:*/		return 0x820B02F0;
		  /* 820B02F0h */ case   19:  		/* addi R31, R31, 1 */
		/* 820B02F0h case   19:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820B02F0h case   19:*/		return 0x820B02F4;
		  /* 820B02F4h */ case   20:  		/* addi R30, R30, 8 */
		/* 820B02F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 820B02F4h case   20:*/		return 0x820B02F8;
		  /* 820B02F8h */ case   21:  		/* cmplwi CR6, R31, 4 */
		/* 820B02F8h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 820B02F8h case   21:*/		return 0x820B02FC;
		  /* 820B02FCh */ case   22:  		/* bc 12, CR6_LT, -44 */
		/* 820B02FCh case   22:*/		if ( regs.CR[6].lt ) { return 0x820B02D0;  }
		/* 820B02FCh case   22:*/		return 0x820B0300;
	}
	return 0x820B0300;
} // Block from 820B02A4h-820B0300h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820B0300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0300);
		  /* 820B0300h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820B0300h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820B0300h case    0:*/		return 0x820B0304;
		  /* 820B0304h */ case    1:  		/* bc 4, CR6_EQ, -240 */
		/* 820B0304h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B0214;  }
		/* 820B0304h case    1:*/		return 0x820B0308;
		  /* 820B0308h */ case    2:  		/* li R3, 0 */
		/* 820B0308h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B0308h case    2:*/		return 0x820B030C;
		  /* 820B030Ch */ case    3:  		/* addi R1, R1, 144 */
		/* 820B030Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820B030Ch case    3:*/		return 0x820B0310;
		  /* 820B0310h */ case    4:  		/* b -127084 */
		/* 820B0310h case    4:*/		return 0x820912A4;
		/* 820B0310h case    4:*/		return 0x820B0314;
	}
	return 0x820B0314;
} // Block from 820B0300h-820B0314h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B0314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0314);
		  /* 820B0314h */ case    0:  		/* lis R3, -32761 */
		/* 820B0314h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820B0314h case    0:*/		return 0x820B0318;
		  /* 820B0318h */ case    1:  		/* ori R3, R3, 14 */
		/* 820B0318h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820B0318h case    1:*/		return 0x820B031C;
		  /* 820B031Ch */ case    2:  		/* b -16 */
		/* 820B031Ch case    2:*/		return 0x820B030C;
		/* 820B031Ch case    2:*/		return 0x820B0320;
	}
	return 0x820B0320;
} // Block from 820B0314h-820B0320h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B0320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0320);
		  /* 820B0320h */ case    0:  		/* mfspr R12, LR */
		/* 820B0320h case    0:*/		regs.R12 = regs.LR;
		/* 820B0320h case    0:*/		return 0x820B0324;
		  /* 820B0324h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820B0324h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B0324h case    1:*/		return 0x820B0328;
		  /* 820B0328h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820B0328h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B0328h case    2:*/		return 0x820B032C;
		  /* 820B032Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820B032Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820B032Ch case    3:*/		return 0x820B0330;
		  /* 820B0330h */ case    4:  		/* mr R31, R3 */
		/* 820B0330h case    4:*/		regs.R31 = regs.R3;
		/* 820B0330h case    4:*/		return 0x820B0334;
		  /* 820B0334h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820B0334h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820B0334h case    5:*/		return 0x820B0338;
		  /* 820B0338h */ case    6:  		/* bc 12, CR6_EQ, 180 */
		/* 820B0338h case    6:*/		if ( regs.CR[6].eq ) { return 0x820B03EC;  }
		/* 820B0338h case    6:*/		return 0x820B033C;
		  /* 820B033Ch */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 820B033Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820B033Ch case    7:*/		return 0x820B0340;
		  /* 820B0340h */ case    8:  		/* cmpwi CR6, R11, 1 */
		/* 820B0340h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820B0340h case    8:*/		return 0x820B0344;
		  /* 820B0344h */ case    9:  		/* bc 12, CR6_EQ, 136 */
		/* 820B0344h case    9:*/		if ( regs.CR[6].eq ) { return 0x820B03CC;  }
		/* 820B0344h case    9:*/		return 0x820B0348;
		  /* 820B0348h */ case   10:  		/* cmpwi CR6, R11, 3 */
		/* 820B0348h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820B0348h case   10:*/		return 0x820B034C;
		  /* 820B034Ch */ case   11:  		/* bc 12, CR6_EQ, 120 */
		/* 820B034Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820B03C4;  }
		/* 820B034Ch case   11:*/		return 0x820B0350;
		  /* 820B0350h */ case   12:  		/* cmpwi CR6, R11, 6 */
		/* 820B0350h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820B0350h case   12:*/		return 0x820B0354;
		  /* 820B0354h */ case   13:  		/* bc 12, CR6_EQ, 92 */
		/* 820B0354h case   13:*/		if ( regs.CR[6].eq ) { return 0x820B03B0;  }
		/* 820B0354h case   13:*/		return 0x820B0358;
		  /* 820B0358h */ case   14:  		/* cmpwi CR6, R11, 11 */
		/* 820B0358h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820B0358h case   14:*/		return 0x820B035C;
		  /* 820B035Ch */ case   15:  		/* bc 12, CR6_EQ, 144 */
		/* 820B035Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820B03EC;  }
		/* 820B035Ch case   15:*/		return 0x820B0360;
		  /* 820B0360h */ case   16:  		/* cmpwi CR6, R11, 12 */
		/* 820B0360h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 820B0360h case   16:*/		return 0x820B0364;
		  /* 820B0364h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 820B0364h case   17:*/		if ( regs.CR[6].eq ) { return 0x820B0378;  }
		/* 820B0364h case   17:*/		return 0x820B0368;
		  /* 820B0368h */ case   18:  		/* cmpwi CR6, R11, 14 */
		/* 820B0368h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 820B0368h case   18:*/		return 0x820B036C;
		  /* 820B036Ch */ case   19:  		/* bc 4, CR6_EQ, 128 */
		/* 820B036Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820B03EC;  }
		/* 820B036Ch case   19:*/		return 0x820B0370;
		  /* 820B0370h */ case   20:  		/* addi R3, R3, 48 */
		/* 820B0370h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x30);
		/* 820B0370h case   20:*/		return 0x820B0374;
		  /* 820B0374h */ case   21:  		/* b 124 */
		/* 820B0374h case   21:*/		return 0x820B03F0;
		/* 820B0374h case   21:*/		return 0x820B0378;
	}
	return 0x820B0378;
} // Block from 820B0320h-820B0378h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B0378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0378);
		  /* 820B0378h */ case    0:  		/* lwz R3, <#[R31 + 20]> */
		/* 820B0378h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820B0378h case    0:*/		return 0x820B037C;
		  /* 820B037Ch */ case    1:  		/* bl -92 */
		/* 820B037Ch case    1:*/		regs.LR = 0x820B0380; return 0x820B0320;
		/* 820B037Ch case    1:*/		return 0x820B0380;
		  /* 820B0380h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820B0380h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B0380h case    2:*/		return 0x820B0384;
		  /* 820B0384h */ case    3:  		/* bc 4, CR0_EQ, 108 */
		/* 820B0384h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820B03F0;  }
		/* 820B0384h case    3:*/		return 0x820B0388;
		  /* 820B0388h */ case    4:  		/* lwz R3, <#[R31 + 24]> */
		/* 820B0388h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820B0388h case    4:*/		return 0x820B038C;
		  /* 820B038Ch */ case    5:  		/* bl -108 */
		/* 820B038Ch case    5:*/		regs.LR = 0x820B0390; return 0x820B0320;
		/* 820B038Ch case    5:*/		return 0x820B0390;
		  /* 820B0390h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820B0390h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B0390h case    6:*/		return 0x820B0394;
		  /* 820B0394h */ case    7:  		/* bc 4, CR0_EQ, 92 */
		/* 820B0394h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820B03F0;  }
		/* 820B0394h case    7:*/		return 0x820B0398;
		  /* 820B0398h */ case    8:  		/* lwz R3, <#[R31 + 28]> */
		/* 820B0398h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 820B0398h case    8:*/		return 0x820B039C;
		  /* 820B039Ch */ case    9:  		/* bl -124 */
		/* 820B039Ch case    9:*/		regs.LR = 0x820B03A0; return 0x820B0320;
		/* 820B039Ch case    9:*/		return 0x820B03A0;
		  /* 820B03A0h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820B03A0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B03A0h case   10:*/		return 0x820B03A4;
		  /* 820B03A4h */ case   11:  		/* bc 4, CR0_EQ, 76 */
		/* 820B03A4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820B03F0;  }
		/* 820B03A4h case   11:*/		return 0x820B03A8;
		  /* 820B03A8h */ case   12:  		/* lwz R3, <#[R31 + 32]> */
		/* 820B03A8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 820B03A8h case   12:*/		return 0x820B03AC;
		  /* 820B03ACh */ case   13:  		/* b 52 */
		/* 820B03ACh case   13:*/		return 0x820B03E0;
		/* 820B03ACh case   13:*/		return 0x820B03B0;
	}
	return 0x820B03B0;
} // Block from 820B0378h-820B03B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820B03B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B03B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B03B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B03B0);
		  /* 820B03B0h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820B03B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820B03B0h case    0:*/		return 0x820B03B4;
		  /* 820B03B4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820B03B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B03B4h case    1:*/		return 0x820B03B8;
		  /* 820B03B8h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820B03B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B03EC;  }
		/* 820B03B8h case    2:*/		return 0x820B03BC;
		  /* 820B03BCh */ case    3:  		/* addi R3, R11, 16 */
		/* 820B03BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 820B03BCh case    3:*/		return 0x820B03C0;
		  /* 820B03C0h */ case    4:  		/* b 48 */
		/* 820B03C0h case    4:*/		return 0x820B03F0;
		/* 820B03C0h case    4:*/		return 0x820B03C4;
	}
	return 0x820B03C4;
} // Block from 820B03B0h-820B03C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B03C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B03C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B03C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B03C4);
		  /* 820B03C4h */ case    0:  		/* addi R3, R31, 16 */
		/* 820B03C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10);
		/* 820B03C4h case    0:*/		return 0x820B03C8;
		  /* 820B03C8h */ case    1:  		/* b 40 */
		/* 820B03C8h case    1:*/		return 0x820B03F0;
		/* 820B03C8h case    1:*/		return 0x820B03CC;
	}
	return 0x820B03CC;
} // Block from 820B03C4h-820B03CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B03CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B03CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B03CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B03CC);
		  /* 820B03CCh */ case    0:  		/* lwz R3, <#[R31 + 8]> */
		/* 820B03CCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820B03CCh case    0:*/		return 0x820B03D0;
		  /* 820B03D0h */ case    1:  		/* bl -176 */
		/* 820B03D0h case    1:*/		regs.LR = 0x820B03D4; return 0x820B0320;
		/* 820B03D0h case    1:*/		return 0x820B03D4;
		  /* 820B03D4h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 820B03D4h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B03D4h case    2:*/		return 0x820B03D8;
		  /* 820B03D8h */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 820B03D8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820B03F0;  }
		/* 820B03D8h case    3:*/		return 0x820B03DC;
		  /* 820B03DCh */ case    4:  		/* lwz R3, <#[R31 + 12]> */
		/* 820B03DCh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B03DCh case    4:*/		return 0x820B03E0;
	}
	return 0x820B03E0;
} // Block from 820B03CCh-820B03E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B03E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B03E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B03E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B03E0);
		  /* 820B03E0h */ case    0:  		/* bl -192 */
		/* 820B03E0h case    0:*/		regs.LR = 0x820B03E4; return 0x820B0320;
		/* 820B03E0h case    0:*/		return 0x820B03E4;
		  /* 820B03E4h */ case    1:  		/* cmplwi CR0, R3, 0 */
		/* 820B03E4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B03E4h case    1:*/		return 0x820B03E8;
		  /* 820B03E8h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 820B03E8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B03F0;  }
		/* 820B03E8h case    2:*/		return 0x820B03EC;
	}
	return 0x820B03EC;
} // Block from 820B03E0h-820B03ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B03ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B03EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B03EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B03EC);
		  /* 820B03ECh */ case    0:  		/* li R3, 0 */
		/* 820B03ECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B03ECh case    0:*/		return 0x820B03F0;
	}
	return 0x820B03F0;
} // Block from 820B03ECh-820B03F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B03F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B03F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B03F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B03F0);
		  /* 820B03F0h */ case    0:  		/* addi R1, R1, 96 */
		/* 820B03F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820B03F0h case    0:*/		return 0x820B03F4;
		  /* 820B03F4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820B03F4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B03F4h case    1:*/		return 0x820B03F8;
		  /* 820B03F8h */ case    2:  		/* mtspr LR, R12 */
		/* 820B03F8h case    2:*/		regs.LR = regs.R12;
		/* 820B03F8h case    2:*/		return 0x820B03FC;
		  /* 820B03FCh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820B03FCh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B03FCh case    3:*/		return 0x820B0400;
		  /* 820B0400h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820B0400h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B0400h case    4:*/		return 0x820B0404;
	}
	return 0x820B0404;
} // Block from 820B03F0h-820B0404h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B0404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0404);
		  /* 820B0404h */ case    0:  		/* nop */
		/* 820B0404h case    0:*/		cpu::op::nop();
		/* 820B0404h case    0:*/		return 0x820B0408;
		  /* 820B0408h */ case    1:  		/* b -232 */
		/* 820B0408h case    1:*/		return 0x820B0320;
		/* 820B0408h case    1:*/		return 0x820B040C;
		  /* 820B040Ch */ case    2:  		/* nop */
		/* 820B040Ch case    2:*/		cpu::op::nop();
		/* 820B040Ch case    2:*/		return 0x820B0410;
		  /* 820B0410h */ case    3:  		/* lwz R11, <#[R5 + 24]> */
		/* 820B0410h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000018) );
		/* 820B0410h case    3:*/		return 0x820B0414;
		  /* 820B0414h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820B0414h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820B0414h case    4:*/		return 0x820B0418;
		  /* 820B0418h */ case    5:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 820B0418h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 820B0418h case    5:*/		return 0x820B041C;
		  /* 820B041Ch */ case    6:  		/* lwz R8, <#[R5 + 8]> */
		/* 820B041Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000008) );
		/* 820B041Ch case    6:*/		return 0x820B0420;
		  /* 820B0420h */ case    7:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820B0420h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B0420h case    7:*/		return 0x820B0424;
		  /* 820B0424h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820B0424h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B0424h case    8:*/		return 0x820B0428;
		  /* 820B0428h */ case    9:  		/* lwz R9, <#[R8 + 20]> */
		/* 820B0428h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000014) );
		/* 820B0428h case    9:*/		return 0x820B042C;
		  /* 820B042Ch */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B042Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B042Ch case   10:*/		return 0x820B0430;
		  /* 820B0430h */ case   11:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820B0430h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820B0430h case   11:*/		return 0x820B0434;
		  /* 820B0434h */ case   12:  		/* lwzx R11, <#[R10 + R9]> */
		/* 820B0434h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820B0434h case   12:*/		return 0x820B0438;
		  /* 820B0438h */ case   13:  		/* lwzx R10, <#[R8 + R9]> */
		/* 820B0438h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820B0438h case   13:*/		return 0x820B043C;
		  /* 820B043Ch */ case   14:  		/* lwz R9, <#[R11 + 108]> */
		/* 820B043Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000006C) );
		/* 820B043Ch case   14:*/		return 0x820B0440;
		  /* 820B0440h */ case   15:  		/* lwz R8, <#[R10 + 108]> */
		/* 820B0440h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000006C) );
		/* 820B0440h case   15:*/		return 0x820B0444;
		  /* 820B0444h */ case   16:  		/* cmplw CR6, R9, R8 */
		/* 820B0444h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820B0444h case   16:*/		return 0x820B0448;
		  /* 820B0448h */ case   17:  		/* bc 4, CR6_LT, 12 */
		/* 820B0448h case   17:*/		if ( !regs.CR[6].lt ) { return 0x820B0454;  }
		/* 820B0448h case   17:*/		return 0x820B044C;
		  /* 820B044Ch */ case   18:  		/* li R3, -1 */
		/* 820B044Ch case   18:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820B044Ch case   18:*/		return 0x820B0450;
		  /* 820B0450h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820B0450h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B0450h case   19:*/		return 0x820B0454;
	}
	return 0x820B0454;
} // Block from 820B0404h-820B0454h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820B0454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0454);
		  /* 820B0454h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 820B0454h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820B0460;  }
		/* 820B0454h case    0:*/		return 0x820B0458;
		  /* 820B0458h */ case    1:  		/* li R3, 1 */
		/* 820B0458h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820B0458h case    1:*/		return 0x820B045C;
		  /* 820B045Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 820B045Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B045Ch case    2:*/		return 0x820B0460;
	}
	return 0x820B0460;
} // Block from 820B0454h-820B0460h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B0460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0460);
		  /* 820B0460h */ case    0:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B0460h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B0460h case    0:*/		return 0x820B0464;
		  /* 820B0464h */ case    1:  		/* lwz R10, <#[R10 + 16]> */
		/* 820B0464h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820B0464h case    1:*/		return 0x820B0468;
		  /* 820B0468h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820B0468h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B0468h case    2:*/		return 0x820B046C;
		  /* 820B046Ch */ case    3:  		/* bc 12, CR6_LT, -32 */
		/* 820B046Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820B044C;  }
		/* 820B046Ch case    3:*/		return 0x820B0470;
		  /* 820B0470h */ case    4:  		/* bc 12, CR6_GT, -24 */
		/* 820B0470h case    4:*/		if ( regs.CR[6].gt ) { return 0x820B0458;  }
		/* 820B0470h case    4:*/		return 0x820B0474;
		  /* 820B0474h */ case    5:  		/* cmplw CR6, R3, R4 */
		/* 820B0474h case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 820B0474h case    5:*/		return 0x820B0478;
		  /* 820B0478h */ case    6:  		/* bc 12, CR6_LT, -44 */
		/* 820B0478h case    6:*/		if ( regs.CR[6].lt ) { return 0x820B044C;  }
		/* 820B0478h case    6:*/		return 0x820B047C;
		  /* 820B047Ch */ case    7:  		/* subfc R11, R3, R4 */
		/* 820B047Ch case    7:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 820B047Ch case    7:*/		return 0x820B0480;
		  /* 820B0480h */ case    8:  		/* subfe R11, R11, R11 */
		/* 820B0480h case    8:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820B0480h case    8:*/		return 0x820B0484;
		  /* 820B0484h */ case    9:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820B0484h case    9:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820B0484h case    9:*/		return 0x820B0488;
		  /* 820B0488h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820B0488h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B0488h case   10:*/		return 0x820B048C;
	}
	return 0x820B048C;
} // Block from 820B0460h-820B048Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B048Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B048C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B048C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B048C);
		  /* 820B048Ch */ case    0:  		/* nop */
		/* 820B048Ch case    0:*/		cpu::op::nop();
		/* 820B048Ch case    0:*/		return 0x820B0490;
	}
	return 0x820B0490;
} // Block from 820B048Ch-820B0490h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0490);
		  /* 820B0490h */ case    0:  		/* mfspr R12, LR */
		/* 820B0490h case    0:*/		regs.R12 = regs.LR;
		/* 820B0490h case    0:*/		return 0x820B0494;
		  /* 820B0494h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820B0494h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B0494h case    1:*/		return 0x820B0498;
		  /* 820B0498h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820B0498h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820B0498h case    2:*/		return 0x820B049C;
		  /* 820B049Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820B049Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B049Ch case    3:*/		return 0x820B04A0;
		  /* 820B04A0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820B04A0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820B04A0h case    4:*/		return 0x820B04A4;
		  /* 820B04A4h */ case    5:  		/* lis R11, -32255 */
		/* 820B04A4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B04A4h case    5:*/		return 0x820B04A8;
		  /* 820B04A8h */ case    6:  		/* mr R31, R3 */
		/* 820B04A8h case    6:*/		regs.R31 = regs.R3;
		/* 820B04A8h case    6:*/		return 0x820B04AC;
		  /* 820B04ACh */ case    7:  		/* addi R11, R11, 6776 */
		/* 820B04ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1A78);
		/* 820B04ACh case    7:*/		return 0x820B04B0;
		  /* 820B04B0h */ case    8:  		/* mr R30, R4 */
		/* 820B04B0h case    8:*/		regs.R30 = regs.R4;
		/* 820B04B0h case    8:*/		return 0x820B04B4;
		  /* 820B04B4h */ case    9:  		/* stw R11, <#[R3]> */
		/* 820B04B4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820B04B4h case    9:*/		return 0x820B04B8;
		  /* 820B04B8h */ case   10:  		/* bl 169808 */
		/* 820B04B8h case   10:*/		regs.LR = 0x820B04BC; return 0x820D9C08;
		/* 820B04B8h case   10:*/		return 0x820B04BC;
		  /* 820B04BCh */ case   11:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820B04BCh case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820B04BCh case   11:*/		return 0x820B04C0;
		  /* 820B04C0h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820B04C0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820B04D0;  }
		/* 820B04C0h case   12:*/		return 0x820B04C4;
		  /* 820B04C4h */ case   13:  		/* lis R4, 9345 */
		/* 820B04C4h case   13:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B04C4h case   13:*/		return 0x820B04C8;
		  /* 820B04C8h */ case   14:  		/* mr R3, R31 */
		/* 820B04C8h case   14:*/		regs.R3 = regs.R31;
		/* 820B04C8h case   14:*/		return 0x820B04CC;
		  /* 820B04CCh */ case   15:  		/* bl -164244 */
		/* 820B04CCh case   15:*/		regs.LR = 0x820B04D0; return 0x82088338;
		/* 820B04CCh case   15:*/		return 0x820B04D0;
	}
	return 0x820B04D0;
} // Block from 820B0490h-820B04D0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B04D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B04D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B04D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B04D0);
		  /* 820B04D0h */ case    0:  		/* mr R3, R31 */
		/* 820B04D0h case    0:*/		regs.R3 = regs.R31;
		/* 820B04D0h case    0:*/		return 0x820B04D4;
		  /* 820B04D4h */ case    1:  		/* addi R1, R1, 112 */
		/* 820B04D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820B04D4h case    1:*/		return 0x820B04D8;
		  /* 820B04D8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820B04D8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B04D8h case    2:*/		return 0x820B04DC;
		  /* 820B04DCh */ case    3:  		/* mtspr LR, R12 */
		/* 820B04DCh case    3:*/		regs.LR = regs.R12;
		/* 820B04DCh case    3:*/		return 0x820B04E0;
		  /* 820B04E0h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820B04E0h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820B04E0h case    4:*/		return 0x820B04E4;
		  /* 820B04E4h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820B04E4h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B04E4h case    5:*/		return 0x820B04E8;
		  /* 820B04E8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820B04E8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B04E8h case    6:*/		return 0x820B04EC;
	}
	return 0x820B04EC;
} // Block from 820B04D0h-820B04ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B04ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B04EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B04EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B04EC);
		  /* 820B04ECh */ case    0:  		/* nop */
		/* 820B04ECh case    0:*/		cpu::op::nop();
		/* 820B04ECh case    0:*/		return 0x820B04F0;
	}
	return 0x820B04F0;
} // Block from 820B04ECh-820B04F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B04F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B04F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B04F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B04F0);
		  /* 820B04F0h */ case    0:  		/* mfspr R12, LR */
		/* 820B04F0h case    0:*/		regs.R12 = regs.LR;
		/* 820B04F0h case    0:*/		return 0x820B04F4;
		  /* 820B04F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820B04F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B04F4h case    1:*/		return 0x820B04F8;
		  /* 820B04F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820B04F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820B04F8h case    2:*/		return 0x820B04FC;
		  /* 820B04FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820B04FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B04FCh case    3:*/		return 0x820B0500;
		  /* 820B0500h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820B0500h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820B0500h case    4:*/		return 0x820B0504;
		  /* 820B0504h */ case    5:  		/* lis R11, -32255 */
		/* 820B0504h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B0504h case    5:*/		return 0x820B0508;
		  /* 820B0508h */ case    6:  		/* mr R31, R3 */
		/* 820B0508h case    6:*/		regs.R31 = regs.R3;
		/* 820B0508h case    6:*/		return 0x820B050C;
		  /* 820B050Ch */ case    7:  		/* addi R11, R11, 7424 */
		/* 820B050Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1D00);
		/* 820B050Ch case    7:*/		return 0x820B0510;
		  /* 820B0510h */ case    8:  		/* mr R30, R4 */
		/* 820B0510h case    8:*/		regs.R30 = regs.R4;
		/* 820B0510h case    8:*/		return 0x820B0514;
		  /* 820B0514h */ case    9:  		/* stw R11, <#[R3]> */
		/* 820B0514h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820B0514h case    9:*/		return 0x820B0518;
		  /* 820B0518h */ case   10:  		/* bl 169712 */
		/* 820B0518h case   10:*/		regs.LR = 0x820B051C; return 0x820D9C08;
		/* 820B0518h case   10:*/		return 0x820B051C;
		  /* 820B051Ch */ case   11:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820B051Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820B051Ch case   11:*/		return 0x820B0520;
		  /* 820B0520h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820B0520h case   12:*/		if ( regs.CR[0].eq ) { return 0x820B0530;  }
		/* 820B0520h case   12:*/		return 0x820B0524;
		  /* 820B0524h */ case   13:  		/* lis R4, 9345 */
		/* 820B0524h case   13:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B0524h case   13:*/		return 0x820B0528;
		  /* 820B0528h */ case   14:  		/* mr R3, R31 */
		/* 820B0528h case   14:*/		regs.R3 = regs.R31;
		/* 820B0528h case   14:*/		return 0x820B052C;
		  /* 820B052Ch */ case   15:  		/* bl -164340 */
		/* 820B052Ch case   15:*/		regs.LR = 0x820B0530; return 0x82088338;
		/* 820B052Ch case   15:*/		return 0x820B0530;
	}
	return 0x820B0530;
} // Block from 820B04F0h-820B0530h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B0530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0530);
		  /* 820B0530h */ case    0:  		/* mr R3, R31 */
		/* 820B0530h case    0:*/		regs.R3 = regs.R31;
		/* 820B0530h case    0:*/		return 0x820B0534;
		  /* 820B0534h */ case    1:  		/* addi R1, R1, 112 */
		/* 820B0534h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820B0534h case    1:*/		return 0x820B0538;
		  /* 820B0538h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820B0538h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B0538h case    2:*/		return 0x820B053C;
		  /* 820B053Ch */ case    3:  		/* mtspr LR, R12 */
		/* 820B053Ch case    3:*/		regs.LR = regs.R12;
		/* 820B053Ch case    3:*/		return 0x820B0540;
		  /* 820B0540h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820B0540h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820B0540h case    4:*/		return 0x820B0544;
		  /* 820B0544h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820B0544h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B0544h case    5:*/		return 0x820B0548;
		  /* 820B0548h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820B0548h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B0548h case    6:*/		return 0x820B054C;
	}
	return 0x820B054C;
} // Block from 820B0530h-820B054Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B054Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B054C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B054C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B054C);
		  /* 820B054Ch */ case    0:  		/* nop */
		/* 820B054Ch case    0:*/		cpu::op::nop();
		/* 820B054Ch case    0:*/		return 0x820B0550;
	}
	return 0x820B0550;
} // Block from 820B054Ch-820B0550h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0550h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0550);
		  /* 820B0550h */ case    0:  		/* mfspr R12, LR */
		/* 820B0550h case    0:*/		regs.R12 = regs.LR;
		/* 820B0550h case    0:*/		return 0x820B0554;
		  /* 820B0554h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820B0554h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B0554h case    1:*/		return 0x820B0558;
		  /* 820B0558h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820B0558h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B0558h case    2:*/		return 0x820B055C;
		  /* 820B055Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820B055Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820B055Ch case    3:*/		return 0x820B0560;
	}
	return 0x820B0560;
} // Block from 820B0550h-820B0560h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B0560h
// Function '?IsFullySemantic@CCompiler@D3DXShader@@IAAHPAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0560);
		  /* 820B0560h */ case    0:  		/* mr R31, R3 */
		/* 820B0560h case    0:*/		regs.R31 = regs.R3;
		/* 820B0560h case    0:*/		return 0x820B0564;
		  /* 820B0564h */ case    1:  		/* lwz R3, <#[R3 + 8]> */
		/* 820B0564h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 820B0564h case    1:*/		return 0x820B0568;
		  /* 820B0568h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820B0568h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820B0568h case    2:*/		return 0x820B056C;
		  /* 820B056Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820B056Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820B0584;  }
		/* 820B056Ch case    3:*/		return 0x820B0570;
		  /* 820B0570h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820B0570h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820B0570h case    4:*/		return 0x820B0574;
		  /* 820B0574h */ case    5:  		/* li R4, 1 */
		/* 820B0574h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820B0574h case    5:*/		return 0x820B0578;
		  /* 820B0578h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820B0578h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820B0578h case    6:*/		return 0x820B057C;
		  /* 820B057Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 820B057Ch case    7:*/		regs.CTR = regs.R11;
		/* 820B057Ch case    7:*/		return 0x820B0580;
		  /* 820B0580h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820B0580h case    8:*/		if ( 1 ) { regs.LR = 0x820B0584; return (uint32)regs.CTR; }
		/* 820B0580h case    8:*/		return 0x820B0584;
	}
	return 0x820B0584;
} // Block from 820B0560h-820B0584h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B0584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0584);
		  /* 820B0584h */ case    0:  		/* lis R4, 9345 */
		/* 820B0584h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B0584h case    0:*/		return 0x820B0588;
		  /* 820B0588h */ case    1:  		/* lwz R3, <#[R31 + 24]> */
		/* 820B0588h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820B0588h case    1:*/		return 0x820B058C;
		  /* 820B058Ch */ case    2:  		/* bl -164436 */
		/* 820B058Ch case    2:*/		regs.LR = 0x820B0590; return 0x82088338;
		/* 820B058Ch case    2:*/		return 0x820B0590;
		  /* 820B0590h */ case    3:  		/* lis R4, 9345 */
		/* 820B0590h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B0590h case    3:*/		return 0x820B0594;
		  /* 820B0594h */ case    4:  		/* lwz R3, <#[R31 + 144]> */
		/* 820B0594h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000090) );
		/* 820B0594h case    4:*/		return 0x820B0598;
		  /* 820B0598h */ case    5:  		/* bl -164448 */
		/* 820B0598h case    5:*/		regs.LR = 0x820B059C; return 0x82088338;
		/* 820B0598h case    5:*/		return 0x820B059C;
		  /* 820B059Ch */ case    6:  		/* lis R4, 9345 */
		/* 820B059Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B059Ch case    6:*/		return 0x820B05A0;
		  /* 820B05A0h */ case    7:  		/* lwz R3, <#[R31 + 152]> */
		/* 820B05A0h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000098) );
		/* 820B05A0h case    7:*/		return 0x820B05A4;
		  /* 820B05A4h */ case    8:  		/* bl -164460 */
		/* 820B05A4h case    8:*/		regs.LR = 0x820B05A8; return 0x82088338;
		/* 820B05A4h case    8:*/		return 0x820B05A8;
		  /* 820B05A8h */ case    9:  		/* lis R4, 9345 */
		/* 820B05A8h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B05A8h case    9:*/		return 0x820B05AC;
		  /* 820B05ACh */ case   10:  		/* lwz R3, <#[R31 + 160]> */
		/* 820B05ACh case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A0) );
		/* 820B05ACh case   10:*/		return 0x820B05B0;
		  /* 820B05B0h */ case   11:  		/* bl -164472 */
		/* 820B05B0h case   11:*/		regs.LR = 0x820B05B4; return 0x82088338;
		/* 820B05B0h case   11:*/		return 0x820B05B4;
		  /* 820B05B4h */ case   12:  		/* addi R1, R1, 96 */
		/* 820B05B4h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820B05B4h case   12:*/		return 0x820B05B8;
		  /* 820B05B8h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 820B05B8h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B05B8h case   13:*/		return 0x820B05BC;
		  /* 820B05BCh */ case   14:  		/* mtspr LR, R12 */
		/* 820B05BCh case   14:*/		regs.LR = regs.R12;
		/* 820B05BCh case   14:*/		return 0x820B05C0;
		  /* 820B05C0h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 820B05C0h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B05C0h case   15:*/		return 0x820B05C4;
		  /* 820B05C4h */ case   16:  		/* bclr 20, CR0_LT */
		/* 820B05C4h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B05C4h case   16:*/		return 0x820B05C8;
	}
	return 0x820B05C8;
} // Block from 820B0584h-820B05C8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B05C8h
// Function '?IsRowMajor@CCompiler@D3DXShader@@IAAHPAIW4_D3DTYPE_TEMPLATE@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B05C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B05C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B05C8);
		  /* 820B05C8h */ case    0:  		/* mfspr R12, LR */
		/* 820B05C8h case    0:*/		regs.R12 = regs.LR;
		/* 820B05C8h case    0:*/		return 0x820B05CC;
		  /* 820B05CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820B05CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B05CCh case    1:*/		return 0x820B05D0;
		  /* 820B05D0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820B05D0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B05D0h case    2:*/		return 0x820B05D4;
		  /* 820B05D4h */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 820B05D4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820B05D4h case    3:*/		return 0x820B05D8;
		  /* 820B05D8h */ case    4:  		/* li R11, 0 */
		/* 820B05D8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B05D8h case    4:*/		return 0x820B05DC;
		  /* 820B05DCh */ case    5:  		/* lwz R10, <#[R3]> */
		/* 820B05DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820B05DCh case    5:*/		return 0x820B05E0;
		  /* 820B05E0h */ case    6:  		/* stw R11, <#[R1 + 96]> */
		/* 820B05E0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820B05E0h case    6:*/		return 0x820B05E4;
		  /* 820B05E4h */ case    7:  		/* lwz R11, <#[R10 + 12]> */
		/* 820B05E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820B05E4h case    7:*/		return 0x820B05E8;
		  /* 820B05E8h */ case    8:  		/* mtspr CTR, R11 */
		/* 820B05E8h case    8:*/		regs.CTR = regs.R11;
		/* 820B05E8h case    8:*/		return 0x820B05EC;
		  /* 820B05ECh */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820B05ECh case    9:*/		if ( 1 ) { regs.LR = 0x820B05F0; return (uint32)regs.CTR; }
		/* 820B05ECh case    9:*/		return 0x820B05F0;
		  /* 820B05F0h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 820B05F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820B05F0h case   10:*/		return 0x820B05F4;
		  /* 820B05F4h */ case   11:  		/* mr R31, R3 */
		/* 820B05F4h case   11:*/		regs.R31 = regs.R3;
		/* 820B05F4h case   11:*/		return 0x820B05F8;
		  /* 820B05F8h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820B05F8h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820B05F8h case   12:*/		return 0x820B05FC;
		  /* 820B05FCh */ case   13:  		/* bc 4, CR0_EQ, 96 */
		/* 820B05FCh case   13:*/		if ( !regs.CR[0].eq ) { return 0x820B065C;  }
		/* 820B05FCh case   13:*/		return 0x820B0600;
		  /* 820B0600h */ case   14:  		/* addi R4, R1, 112 */
		/* 820B0600h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 820B0600h case   14:*/		return 0x820B0604;
		  /* 820B0604h */ case   15:  		/* bl -293036 */
		/* 820B0604h case   15:*/		regs.LR = 0x820B0608; return 0x82068D58;
		/* 820B0604h case   15:*/		return 0x820B0608;
		  /* 820B0608h */ case   16:  		/* lwz R11, <#[R31 + 24]> */
		/* 820B0608h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820B0608h case   16:*/		return 0x820B060C;
		  /* 820B060Ch */ case   17:  		/* li R3, 0 */
		/* 820B060Ch case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B060Ch case   17:*/		return 0x820B0610;
		  /* 820B0610h */ case   18:  		/* li R4, 0 */
		/* 820B0610h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B0610h case   18:*/		return 0x820B0614;
		  /* 820B0614h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 820B0614h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B0614h case   19:*/		return 0x820B0618;
		  /* 820B0618h */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 820B0618h case   20:*/		if ( regs.CR[6].eq ) { return 0x820B062C;  }
		/* 820B0618h case   20:*/		return 0x820B061C;
		  /* 820B061Ch */ case   21:  		/* add. R11, R11, R31 */
		/* 820B061Ch case   21:*/		cpu::op::add<1>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820B061Ch case   21:*/		return 0x820B0620;
		  /* 820B0620h */ case   22:  		/* bc 12, CR0_EQ, 12 */
		/* 820B0620h case   22:*/		if ( regs.CR[0].eq ) { return 0x820B062C;  }
		/* 820B0620h case   22:*/		return 0x820B0624;
		  /* 820B0624h */ case   23:  		/* lwz R3, <#[R11]> */
		/* 820B0624h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 820B0624h case   23:*/		return 0x820B0628;
		  /* 820B0628h */ case   24:  		/* lwz R4, <#[R11 + 4]> */
		/* 820B0628h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820B0628h case   24:*/		return 0x820B062C;
	}
	return 0x820B062C;
} // Block from 820B05C8h-820B062Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 820B062Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B062C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B062C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B062C);
		  /* 820B062Ch */ case    0:  		/* addi R8, R1, 96 */
		/* 820B062Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 820B062Ch case    0:*/		return 0x820B0630;
		  /* 820B0630h */ case    1:  		/* lwz R11, <#[R1 + 120]> */
		/* 820B0630h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820B0630h case    1:*/		return 0x820B0634;
		  /* 820B0634h */ case    2:  		/* lis R10, -32245 */
		/* 820B0634h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF820B);
		/* 820B0634h case    2:*/		return 0x820B0638;
		  /* 820B0638h */ case    3:  		/* stw R8, <#[R1 + 84]> */
		/* 820B0638h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820B0638h case    3:*/		return 0x820B063C;
		  /* 820B063Ch */ case    4:  		/* li R9, 4 */
		/* 820B063Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B063Ch case    4:*/		return 0x820B0640;
		  /* 820B0640h */ case    5:  		/* addi R10, R10, -6536 */
		/* 820B0640h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFE678);
		/* 820B0640h case    5:*/		return 0x820B0644;
		  /* 820B0644h */ case    6:  		/* li R8, 0 */
		/* 820B0644h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B0644h case    6:*/		return 0x820B0648;
		  /* 820B0648h */ case    7:  		/* li R7, 0 */
		/* 820B0648h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820B0648h case    7:*/		return 0x820B064C;
		  /* 820B064Ch */ case    8:  		/* li R6, 0 */
		/* 820B064Ch case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B064Ch case    8:*/		return 0x820B0650;
		  /* 820B0650h */ case    9:  		/* li R5, 0 */
		/* 820B0650h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B0650h case    9:*/		return 0x820B0654;
		  /* 820B0654h */ case   10:  		/* add R3, R3, R11 */
		/* 820B0654h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 820B0654h case   10:*/		return 0x820B0658;
		  /* 820B0658h */ case   11:  		/* bl -295392 */
		/* 820B0658h case   11:*/		regs.LR = 0x820B065C; return 0x82068478;
		/* 820B0658h case   11:*/		return 0x820B065C;
	}
	return 0x820B065C;
} // Block from 820B062Ch-820B065Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B065Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B065C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B065C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B065C);
		  /* 820B065Ch */ case    0:  		/* lwz R3, <#[R1 + 96]> */
		/* 820B065Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 820B065Ch case    0:*/		return 0x820B0660;
		  /* 820B0660h */ case    1:  		/* addi R1, R1, 144 */
		/* 820B0660h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820B0660h case    1:*/		return 0x820B0664;
		  /* 820B0664h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820B0664h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B0664h case    2:*/		return 0x820B0668;
		  /* 820B0668h */ case    3:  		/* mtspr LR, R12 */
		/* 820B0668h case    3:*/		regs.LR = regs.R12;
		/* 820B0668h case    3:*/		return 0x820B066C;
		  /* 820B066Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820B066Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B066Ch case    4:*/		return 0x820B0670;
		  /* 820B0670h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820B0670h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B0670h case    5:*/		return 0x820B0674;
	}
	return 0x820B0674;
} // Block from 820B065Ch-820B0674h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B0674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0674);
		  /* 820B0674h */ case    0:  		/* nop */
		/* 820B0674h case    0:*/		cpu::op::nop();
		/* 820B0674h case    0:*/		return 0x820B0678;
	}
	return 0x820B0678;
} // Block from 820B0674h-820B0678h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0678);
		  /* 820B0678h */ case    0:  		/* mfspr R12, LR */
		/* 820B0678h case    0:*/		regs.R12 = regs.LR;
		/* 820B0678h case    0:*/		return 0x820B067C;
		  /* 820B067Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820B067Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B067Ch case    1:*/		return 0x820B0680;
		  /* 820B0680h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820B0680h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B0680h case    2:*/		return 0x820B0684;
		  /* 820B0684h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820B0684h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820B0684h case    3:*/		return 0x820B0688;
		  /* 820B0688h */ case    4:  		/* mr R31, R3 */
		/* 820B0688h case    4:*/		regs.R31 = regs.R3;
		/* 820B0688h case    4:*/		return 0x820B068C;
		  /* 820B068Ch */ case    5:  		/* lis R11, -32255 */
		/* 820B068Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B068Ch case    5:*/		return 0x820B0690;
		  /* 820B0690h */ case    6:  		/* mr R3, R5 */
		/* 820B0690h case    6:*/		regs.R3 = regs.R5;
		/* 820B0690h case    6:*/		return 0x820B0694;
		  /* 820B0694h */ case    7:  		/* addi R5, R6, 1100 */
		/* 820B0694h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R6,0x44C);
		/* 820B0694h case    7:*/		return 0x820B0698;
		  /* 820B0698h */ case    8:  		/* cmpwi CR6, R4, 0 */
		/* 820B0698h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820B0698h case    8:*/		return 0x820B069C;
		  /* 820B069Ch */ case    9:  		/* addi R6, R11, 2492 */
		/* 820B069Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x9BC);
		/* 820B069Ch case    9:*/		return 0x820B06A0;
		  /* 820B06A0h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 820B06A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B06C4;  }
		/* 820B06A0h case   10:*/		return 0x820B06A4;
		  /* 820B06A4h */ case   11:  		/* bl -900 */
		/* 820B06A4h case   11:*/		regs.LR = 0x820B06A8; return 0x820B0320;
		/* 820B06A4h case   11:*/		return 0x820B06A8;
		  /* 820B06A8h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 820B06A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B06A8h case   12:*/		return 0x820B06AC;
		  /* 820B06ACh */ case   13:  		/* mr R4, R3 */
		/* 820B06ACh case   13:*/		regs.R4 = regs.R3;
		/* 820B06ACh case   13:*/		return 0x820B06B0;
		  /* 820B06B0h */ case   14:  		/* addi R3, R11, 24 */
		/* 820B06B0h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820B06B0h case   14:*/		return 0x820B06B4;
		  /* 820B06B4h */ case   15:  		/* bl -38180 */
		/* 820B06B4h case   15:*/		regs.LR = 0x820B06B8; return 0x820A7190;
		/* 820B06B4h case   15:*/		return 0x820B06B8;
		  /* 820B06B8h */ case   16:  		/* li R11, 1 */
		/* 820B06B8h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820B06B8h case   16:*/		return 0x820B06BC;
		  /* 820B06BCh */ case   17:  		/* stw R11, <#[R31 + 76]> */
		/* 820B06BCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820B06BCh case   17:*/		return 0x820B06C0;
		  /* 820B06C0h */ case   18:  		/* b 24 */
		/* 820B06C0h case   18:*/		return 0x820B06D8;
		/* 820B06C0h case   18:*/		return 0x820B06C4;
	}
	return 0x820B06C4;
} // Block from 820B0678h-820B06C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820B06C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B06C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B06C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B06C4);
		  /* 820B06C4h */ case    0:  		/* bl -932 */
		/* 820B06C4h case    0:*/		regs.LR = 0x820B06C8; return 0x820B0320;
		/* 820B06C4h case    0:*/		return 0x820B06C8;
		  /* 820B06C8h */ case    1:  		/* lwz R11, <#[R31]> */
		/* 820B06C8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B06C8h case    1:*/		return 0x820B06CC;
		  /* 820B06CCh */ case    2:  		/* mr R4, R3 */
		/* 820B06CCh case    2:*/		regs.R4 = regs.R3;
		/* 820B06CCh case    2:*/		return 0x820B06D0;
		  /* 820B06D0h */ case    3:  		/* addi R3, R11, 24 */
		/* 820B06D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820B06D0h case    3:*/		return 0x820B06D4;
		  /* 820B06D4h */ case    4:  		/* bl -37756 */
		/* 820B06D4h case    4:*/		regs.LR = 0x820B06D8; return 0x820A7358;
		/* 820B06D4h case    4:*/		return 0x820B06D8;
	}
	return 0x820B06D8;
} // Block from 820B06C4h-820B06D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B06D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B06D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B06D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B06D8);
		  /* 820B06D8h */ case    0:  		/* addi R1, R1, 96 */
		/* 820B06D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820B06D8h case    0:*/		return 0x820B06DC;
		  /* 820B06DCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820B06DCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B06DCh case    1:*/		return 0x820B06E0;
		  /* 820B06E0h */ case    2:  		/* mtspr LR, R12 */
		/* 820B06E0h case    2:*/		regs.LR = regs.R12;
		/* 820B06E0h case    2:*/		return 0x820B06E4;
		  /* 820B06E4h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820B06E4h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B06E4h case    3:*/		return 0x820B06E8;
		  /* 820B06E8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820B06E8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B06E8h case    4:*/		return 0x820B06EC;
	}
	return 0x820B06EC;
} // Block from 820B06D8h-820B06ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B06ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B06EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B06EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B06EC);
		  /* 820B06ECh */ case    0:  		/* nop */
		/* 820B06ECh case    0:*/		cpu::op::nop();
		/* 820B06ECh case    0:*/		return 0x820B06F0;
	}
	return 0x820B06F0;
} // Block from 820B06ECh-820B06F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B06F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B06F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B06F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B06F0);
		  /* 820B06F0h */ case    0:  		/* mfspr R12, LR */
		/* 820B06F0h case    0:*/		regs.R12 = regs.LR;
		/* 820B06F0h case    0:*/		return 0x820B06F4;
		  /* 820B06F4h */ case    1:  		/* bl -128152 */
		/* 820B06F4h case    1:*/		regs.LR = 0x820B06F8; return 0x8209125C;
		/* 820B06F4h case    1:*/		return 0x820B06F8;
		  /* 820B06F8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820B06F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820B06F8h case    2:*/		return 0x820B06FC;
		  /* 820B06FCh */ case    3:  		/* lwz R11, <#[R3 + 156]> */
		/* 820B06FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000009C) );
		/* 820B06FCh case    3:*/		return 0x820B0700;
		  /* 820B0700h */ case    4:  		/* mr R29, R3 */
		/* 820B0700h case    4:*/		regs.R29 = regs.R3;
		/* 820B0700h case    4:*/		return 0x820B0704;
		  /* 820B0704h */ case    5:  		/* cmplw CR6, R4, R11 */
		/* 820B0704h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820B0704h case    5:*/		return 0x820B0708;
		  /* 820B0708h */ case    6:  		/* bc 4, CR6_GT, 84 */
		/* 820B0708h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820B075C;  }
		/* 820B0708h case    6:*/		return 0x820B070C;
		  /* 820B070Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820B070Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B070Ch case    7:*/		return 0x820B0710;
		  /* 820B0710h */ case    8:  		/* rlwinm R31, R11, 1, 0, 30 */
		/* 820B0710h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R11);
		/* 820B0710h case    8:*/		return 0x820B0714;
		  /* 820B0714h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 820B0714h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820B0724;  }
		/* 820B0714h case    9:*/		return 0x820B0718;
		  /* 820B0718h */ case   10:  		/* li R31, 16 */
		/* 820B0718h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x10);
		/* 820B0718h case   10:*/		return 0x820B071C;
		  /* 820B071Ch */ case   11:  		/* b 8 */
		/* 820B071Ch case   11:*/		return 0x820B0724;
		/* 820B071Ch case   11:*/		return 0x820B0720;
		  /* 820B0720h */ case   12:  		/* rlwinm R31, R31, 1, 0, 30 */
		/* 820B0720h case   12:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R31);
		/* 820B0720h case   12:*/		return 0x820B0724;
	}
	return 0x820B0724;
} // Block from 820B06F0h-820B0724h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820B0724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0724);
		  /* 820B0724h */ case    0:  		/* cmplw CR6, R31, R4 */
		/* 820B0724h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R4);
		/* 820B0724h case    0:*/		return 0x820B0728;
		  /* 820B0728h */ case    1:  		/* bc 12, CR6_LT, -8 */
		/* 820B0728h case    1:*/		if ( regs.CR[6].lt ) { return 0x820B0720;  }
		/* 820B0728h case    1:*/		return 0x820B072C;
		  /* 820B072Ch */ case    2:  		/* lis R4, 9345 */
		/* 820B072Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B072Ch case    2:*/		return 0x820B0730;
		  /* 820B0730h */ case    3:  		/* rlwinm R3, R31, 2, 0, 29 */
		/* 820B0730h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R31);
		/* 820B0730h case    3:*/		return 0x820B0734;
		  /* 820B0734h */ case    4:  		/* bl -165172 */
		/* 820B0734h case    4:*/		regs.LR = 0x820B0738; return 0x82088200;
		/* 820B0734h case    4:*/		return 0x820B0738;
		  /* 820B0738h */ case    5:  		/* or. R30, R3, R3 */
		/* 820B0738h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B0738h case    5:*/		return 0x820B073C;
		  /* 820B073Ch */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 820B073Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x820B0748;  }
		/* 820B073Ch case    6:*/		return 0x820B0740;
		  /* 820B0740h */ case    7:  		/* li R3, 0 */
		/* 820B0740h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B0740h case    7:*/		return 0x820B0744;
		  /* 820B0744h */ case    8:  		/* b 28 */
		/* 820B0744h case    8:*/		return 0x820B0760;
		/* 820B0744h case    8:*/		return 0x820B0748;
	}
	return 0x820B0748;
} // Block from 820B0724h-820B0748h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B0748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0748);
		  /* 820B0748h */ case    0:  		/* lis R4, 9345 */
		/* 820B0748h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B0748h case    0:*/		return 0x820B074C;
		  /* 820B074Ch */ case    1:  		/* lwz R3, <#[R29 + 152]> */
		/* 820B074Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000098) );
		/* 820B074Ch case    1:*/		return 0x820B0750;
		  /* 820B0750h */ case    2:  		/* bl -164888 */
		/* 820B0750h case    2:*/		regs.LR = 0x820B0754; return 0x82088338;
		/* 820B0750h case    2:*/		return 0x820B0754;
		  /* 820B0754h */ case    3:  		/* stw R30, <#[R29 + 152]> */
		/* 820B0754h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000098) );
		/* 820B0754h case    3:*/		return 0x820B0758;
		  /* 820B0758h */ case    4:  		/* stw R31, <#[R29 + 156]> */
		/* 820B0758h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x0000009C) );
		/* 820B0758h case    4:*/		return 0x820B075C;
	}
	return 0x820B075C;
} // Block from 820B0748h-820B075Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B075Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B075C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B075C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B075C);
		  /* 820B075Ch */ case    0:  		/* lwz R3, <#[R29 + 152]> */
		/* 820B075Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000098) );
		/* 820B075Ch case    0:*/		return 0x820B0760;
	}
	return 0x820B0760;
} // Block from 820B075Ch-820B0760h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0760);
		  /* 820B0760h */ case    0:  		/* addi R1, R1, 112 */
		/* 820B0760h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820B0760h case    0:*/		return 0x820B0764;
		  /* 820B0764h */ case    1:  		/* b -128184 */
		/* 820B0764h case    1:*/		return 0x820912AC;
		/* 820B0764h case    1:*/		return 0x820B0768;
	}
	return 0x820B0768;
} // Block from 820B0760h-820B0768h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B0768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0768);
		  /* 820B0768h */ case    0:  		/* mfspr R12, LR */
		/* 820B0768h case    0:*/		regs.R12 = regs.LR;
		/* 820B0768h case    0:*/		return 0x820B076C;
		  /* 820B076Ch */ case    1:  		/* bl -128272 */
		/* 820B076Ch case    1:*/		regs.LR = 0x820B0770; return 0x8209125C;
		/* 820B076Ch case    1:*/		return 0x820B0770;
		  /* 820B0770h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820B0770h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820B0770h case    2:*/		return 0x820B0774;
		  /* 820B0774h */ case    3:  		/* lwz R11, <#[R3 + 148]> */
		/* 820B0774h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000094) );
		/* 820B0774h case    3:*/		return 0x820B0778;
		  /* 820B0778h */ case    4:  		/* addi R30, R4, 2 */
		/* 820B0778h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0x2);
		/* 820B0778h case    4:*/		return 0x820B077C;
		  /* 820B077Ch */ case    5:  		/* mr R31, R3 */
		/* 820B077Ch case    5:*/		regs.R31 = regs.R3;
		/* 820B077Ch case    5:*/		return 0x820B0780;
		  /* 820B0780h */ case    6:  		/* cmplw CR6, R11, R30 */
		/* 820B0780h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820B0780h case    6:*/		return 0x820B0784;
		  /* 820B0784h */ case    7:  		/* bc 4, CR6_LT, 76 */
		/* 820B0784h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820B07D0;  }
		/* 820B0784h case    7:*/		return 0x820B0788;
		  /* 820B0788h */ case    8:  		/* mr R29, R30 */
		/* 820B0788h case    8:*/		regs.R29 = regs.R30;
		/* 820B0788h case    8:*/		return 0x820B078C;
		  /* 820B078Ch */ case    9:  		/* cmplwi CR6, R30, 8192 */
		/* 820B078Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00002000);
		/* 820B078Ch case    9:*/		return 0x820B0790;
		  /* 820B0790h */ case   10:  		/* bc 4, CR6_LT, 8 */
		/* 820B0790h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820B0798;  }
		/* 820B0790h case   10:*/		return 0x820B0794;
		  /* 820B0794h */ case   11:  		/* li R29, 8192 */
		/* 820B0794h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x2000);
		/* 820B0794h case   11:*/		return 0x820B0798;
	}
	return 0x820B0798;
} // Block from 820B0768h-820B0798h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B0798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0798);
		  /* 820B0798h */ case    0:  		/* lis R4, 9345 */
		/* 820B0798h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B0798h case    0:*/		return 0x820B079C;
		  /* 820B079Ch */ case    1:  		/* rlwinm R3, R29, 2, 0, 29 */
		/* 820B079Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R29);
		/* 820B079Ch case    1:*/		return 0x820B07A0;
		  /* 820B07A0h */ case    2:  		/* bl -165280 */
		/* 820B07A0h case    2:*/		regs.LR = 0x820B07A4; return 0x82088200;
		/* 820B07A0h case    2:*/		return 0x820B07A4;
		  /* 820B07A4h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820B07A4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B07A4h case    3:*/		return 0x820B07A8;
	}
	return 0x820B07A8;
} // Block from 820B0798h-820B07A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B07A8h
// Function '?IsColumnMajor@CCompiler@D3DXShader@@IAAHPAIW4_D3DTYPE_TEMPLATE@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B07A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B07A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B07A8);
		  /* 820B07A8h */ case    0:  		/* bc 12, CR0_EQ, 88 */
		/* 820B07A8h case    0:*/		if ( regs.CR[0].eq ) { return 0x820B0800;  }
		/* 820B07A8h case    0:*/		return 0x820B07AC;
		  /* 820B07ACh */ case    1:  		/* lwz R10, <#[R31 + 144]> */
		/* 820B07ACh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000090) );
		/* 820B07ACh case    1:*/		return 0x820B07B0;
		  /* 820B07B0h */ case    2:  		/* mr R11, R3 */
		/* 820B07B0h case    2:*/		regs.R11 = regs.R3;
		/* 820B07B0h case    2:*/		return 0x820B07B4;
		  /* 820B07B4h */ case    3:  		/* stw R10, <#[R3]> */
		/* 820B07B4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820B07B4h case    3:*/		return 0x820B07B8;
		  /* 820B07B8h */ case    4:  		/* lwz R10, <#[R31 + 148]> */
		/* 820B07B8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000094) );
		/* 820B07B8h case    4:*/		return 0x820B07BC;
		  /* 820B07BCh */ case    5:  		/* neg R10, R10 */
		/* 820B07BCh case    5:*/		cpu::op::neg<0>(regs,&regs.R10,regs.R10);
		/* 820B07BCh case    5:*/		return 0x820B07C0;
		  /* 820B07C0h */ case    6:  		/* stw R10, <#[R3 + 4]> */
		/* 820B07C0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820B07C0h case    6:*/		return 0x820B07C4;
		  /* 820B07C4h */ case    7:  		/* stw R3, <#[R31 + 144]> */
		/* 820B07C4h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000090) );
		/* 820B07C4h case    7:*/		return 0x820B07C8;
		  /* 820B07C8h */ case    8:  		/* stw R29, <#[R31 + 148]> */
		/* 820B07C8h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000094) );
		/* 820B07C8h case    8:*/		return 0x820B07CC;
		  /* 820B07CCh */ case    9:  		/* b 20 */
		/* 820B07CCh case    9:*/		return 0x820B07E0;
		/* 820B07CCh case    9:*/		return 0x820B07D0;
	}
	return 0x820B07D0;
} // Block from 820B07A8h-820B07D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B07D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B07D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B07D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B07D0);
		  /* 820B07D0h */ case    0:  		/* lwz R11, <#[R31 + 144]> */
		/* 820B07D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 820B07D0h case    0:*/		return 0x820B07D4;
		  /* 820B07D4h */ case    1:  		/* stw R11, <#[R11]> */
		/* 820B07D4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820B07D4h case    1:*/		return 0x820B07D8;
		  /* 820B07D8h */ case    2:  		/* lwz R10, <#[R31 + 148]> */
		/* 820B07D8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000094) );
		/* 820B07D8h case    2:*/		return 0x820B07DC;
		  /* 820B07DCh */ case    3:  		/* stw R10, <#[R11 + 4]> */
		/* 820B07DCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B07DCh case    3:*/		return 0x820B07E0;
	}
	return 0x820B07E0;
} // Block from 820B07D0h-820B07E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B07E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B07E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B07E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B07E0);
		  /* 820B07E0h */ case    0:  		/* lwz R9, <#[R31 + 144]> */
		/* 820B07E0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000090) );
		/* 820B07E0h case    0:*/		return 0x820B07E4;
		  /* 820B07E4h */ case    1:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 820B07E4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 820B07E4h case    1:*/		return 0x820B07E8;
		  /* 820B07E8h */ case    2:  		/* lwz R8, <#[R31 + 148]> */
		/* 820B07E8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000094) );
		/* 820B07E8h case    2:*/		return 0x820B07EC;
		  /* 820B07ECh */ case    3:  		/* addi R3, R11, 8 */
		/* 820B07ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x8);
		/* 820B07ECh case    3:*/		return 0x820B07F0;
		  /* 820B07F0h */ case    4:  		/* add R11, R10, R9 */
		/* 820B07F0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 820B07F0h case    4:*/		return 0x820B07F4;
		  /* 820B07F4h */ case    5:  		/* subf R10, R30, R8 */
		/* 820B07F4h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R8);
		/* 820B07F4h case    5:*/		return 0x820B07F8;
		  /* 820B07F8h */ case    6:  		/* stw R11, <#[R31 + 144]> */
		/* 820B07F8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 820B07F8h case    6:*/		return 0x820B07FC;
		  /* 820B07FCh */ case    7:  		/* stw R10, <#[R31 + 148]> */
		/* 820B07FCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000094) );
		/* 820B07FCh case    7:*/		return 0x820B0800;
	}
	return 0x820B0800;
} // Block from 820B07E0h-820B0800h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B0800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0800);
		  /* 820B0800h */ case    0:  		/* addi R1, R1, 112 */
		/* 820B0800h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820B0800h case    0:*/		return 0x820B0804;
		  /* 820B0804h */ case    1:  		/* b -128344 */
		/* 820B0804h case    1:*/		return 0x820912AC;
		/* 820B0804h case    1:*/		return 0x820B0808;
	}
	return 0x820B0808;
} // Block from 820B0800h-820B0808h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B0808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0808);
		  /* 820B0808h */ case    0:  		/* mfspr R12, LR */
		/* 820B0808h case    0:*/		regs.R12 = regs.LR;
		/* 820B0808h case    0:*/		return 0x820B080C;
		  /* 820B080Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820B080Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B080Ch case    1:*/		return 0x820B0810;
		  /* 820B0810h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820B0810h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820B0810h case    2:*/		return 0x820B0814;
		  /* 820B0814h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820B0814h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B0814h case    3:*/		return 0x820B0818;
		  /* 820B0818h */ case    4:  		/* stfd FR31, <#[R1 - 32]> */
		/* 820B0818h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 820B0818h case    4:*/		return 0x820B081C;
		  /* 820B081Ch */ case    5:  		/* stwu R1, <#[R1 - 128]> */
		/* 820B081Ch case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820B081Ch case    5:*/		return 0x820B0820;
		  /* 820B0820h */ case    6:  		/* lwz R11, <#[R3 + 8]> */
		/* 820B0820h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820B0820h case    6:*/		return 0x820B0824;
		  /* 820B0824h */ case    7:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820B0824h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820B0824h case    7:*/		return 0x820B0828;
		  /* 820B0828h */ case    8:  		/* mr R30, R5 */
		/* 820B0828h case    8:*/		regs.R30 = regs.R5;
		/* 820B0828h case    8:*/		return 0x820B082C;
		  /* 820B082Ch */ case    9:  		/* lwz R11, <#[R11 + 20]> */
		/* 820B082Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820B082Ch case    9:*/		return 0x820B0830;
		  /* 820B0830h */ case   10:  		/* lwzx R31, <#[R11 + R10]> */
		/* 820B0830h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B0830h case   10:*/		return 0x820B0834;
		  /* 820B0834h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 820B0834h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B0834h case   11:*/		return 0x820B0838;
		  /* 820B0838h */ case   12:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 820B0838h case   12:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 820B0838h case   12:*/		return 0x820B083C;
		  /* 820B083Ch */ case   13:  		/* bc 12, CR0_EQ, 40 */
		/* 820B083Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x820B0864;  }
		/* 820B083Ch case   13:*/		return 0x820B0840;
		  /* 820B0840h */ case   14:  		/* lfd FR1, <#[R31 + 32]> */
		/* 820B0840h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000020) );
		/* 820B0840h case   14:*/		return 0x820B0844;
		  /* 820B0844h */ case   15:  		/* bl -100468 */
		/* 820B0844h case   15:*/		regs.LR = 0x820B0848; return 0x82097FD0;
		/* 820B0844h case   15:*/		return 0x820B0848;
		  /* 820B0848h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820B0848h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0848h case   16:*/		return 0x820B084C;
		  /* 820B084Ch */ case   17:  		/* bc 12, CR0_EQ, 92 */
		/* 820B084Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x820B08A8;  }
		/* 820B084Ch case   17:*/		return 0x820B0850;
		  /* 820B0850h */ case   18:  		/* cmplwi CR6, R30, 0 */
		/* 820B0850h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B0850h case   18:*/		return 0x820B0854;
		  /* 820B0854h */ case   19:  		/* bc 12, CR6_EQ, 76 */
		/* 820B0854h case   19:*/		if ( regs.CR[6].eq ) { return 0x820B08A0;  }
		/* 820B0854h case   19:*/		return 0x820B0858;
		  /* 820B0858h */ case   20:  		/* lfd FR0, <#[R31 + 32]> */
		/* 820B0858h case   20:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820B0858h case   20:*/		return 0x820B085C;
		  /* 820B085Ch */ case   21:  		/* stfd FR0, <#[R30]> */
		/* 820B085Ch case   21:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 820B085Ch case   21:*/		return 0x820B0860;
		  /* 820B0860h */ case   22:  		/* b 64 */
		/* 820B0860h case   22:*/		return 0x820B08A0;
		/* 820B0860h case   22:*/		return 0x820B0864;
	}
	return 0x820B0864;
} // Block from 820B0808h-820B0864h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820B0864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0864);
		  /* 820B0864h */ case    0:  		/* addi R5, R1, 80 */
		/* 820B0864h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B0864h case    0:*/		return 0x820B0868;
		  /* 820B0868h */ case    1:  		/* bl -6728 */
		/* 820B0868h case    1:*/		regs.LR = 0x820B086C; return 0x820AEE20;
		/* 820B0868h case    1:*/		return 0x820B086C;
		  /* 820B086Ch */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820B086Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B086Ch case    2:*/		return 0x820B0870;
		  /* 820B0870h */ case    3:  		/* bc 12, CR0_LT, 64 */
		/* 820B0870h case    3:*/		if ( regs.CR[0].lt ) { return 0x820B08B0;  }
		/* 820B0870h case    3:*/		return 0x820B0874;
		  /* 820B0874h */ case    4:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820B0874h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820B0874h case    4:*/		return 0x820B0878;
		  /* 820B0878h */ case    5:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820B0878h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820B0878h case    5:*/		return 0x820B087C;
		  /* 820B087Ch */ case    6:  		/* fcmpu CR6, FR31, FR0 */
		/* 820B087Ch case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 820B087Ch case    6:*/		return 0x820B0880;
		  /* 820B0880h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 820B0880h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820B08A8;  }
		/* 820B0880h case    7:*/		return 0x820B0884;
		  /* 820B0884h */ case    8:  		/* fmr FR1, FR31 */
		/* 820B0884h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820B0884h case    8:*/		return 0x820B0888;
		  /* 820B0888h */ case    9:  		/* bl -100536 */
		/* 820B0888h case    9:*/		regs.LR = 0x820B088C; return 0x82097FD0;
		/* 820B0888h case    9:*/		return 0x820B088C;
		  /* 820B088Ch */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820B088Ch case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B088Ch case   10:*/		return 0x820B0890;
		  /* 820B0890h */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 820B0890h case   11:*/		if ( regs.CR[0].eq ) { return 0x820B08A8;  }
		/* 820B0890h case   11:*/		return 0x820B0894;
		  /* 820B0894h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 820B0894h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B0894h case   12:*/		return 0x820B0898;
		  /* 820B0898h */ case   13:  		/* bc 12, CR6_EQ, 8 */
		/* 820B0898h case   13:*/		if ( regs.CR[6].eq ) { return 0x820B08A0;  }
		/* 820B0898h case   13:*/		return 0x820B089C;
		  /* 820B089Ch */ case   14:  		/* stfd FR31, <#[R30]> */
		/* 820B089Ch case   14:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R30 + 0x00000000) );
		/* 820B089Ch case   14:*/		return 0x820B08A0;
	}
	return 0x820B08A0;
} // Block from 820B0864h-820B08A0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B08A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B08A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B08A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B08A0);
		  /* 820B08A0h */ case    0:  		/* li R3, 0 */
		/* 820B08A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B08A0h case    0:*/		return 0x820B08A4;
		  /* 820B08A4h */ case    1:  		/* b 12 */
		/* 820B08A4h case    1:*/		return 0x820B08B0;
		/* 820B08A4h case    1:*/		return 0x820B08A8;
	}
	return 0x820B08A8;
} // Block from 820B08A0h-820B08A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B08A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B08A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B08A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B08A8);
		  /* 820B08A8h */ case    0:  		/* lis R3, -32768 */
		/* 820B08A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820B08A8h case    0:*/		return 0x820B08AC;
		  /* 820B08ACh */ case    1:  		/* ori R3, R3, 16389 */
		/* 820B08ACh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820B08ACh case    1:*/		return 0x820B08B0;
	}
	return 0x820B08B0;
} // Block from 820B08A8h-820B08B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B08B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B08B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B08B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B08B0);
		  /* 820B08B0h */ case    0:  		/* addi R1, R1, 128 */
		/* 820B08B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820B08B0h case    0:*/		return 0x820B08B4;
		  /* 820B08B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820B08B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820B08B4h case    1:*/		return 0x820B08B8;
		  /* 820B08B8h */ case    2:  		/* mtspr LR, R12 */
		/* 820B08B8h case    2:*/		regs.LR = regs.R12;
		/* 820B08B8h case    2:*/		return 0x820B08BC;
		  /* 820B08BCh */ case    3:  		/* lfd FR31, <#[R1 - 32]> */
		/* 820B08BCh case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 820B08BCh case    3:*/		return 0x820B08C0;
		  /* 820B08C0h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820B08C0h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820B08C0h case    4:*/		return 0x820B08C4;
		  /* 820B08C4h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820B08C4h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820B08C4h case    5:*/		return 0x820B08C8;
		  /* 820B08C8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820B08C8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820B08C8h case    6:*/		return 0x820B08CC;
	}
	return 0x820B08CC;
} // Block from 820B08B0h-820B08CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B08CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B08CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B08CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B08CC);
		  /* 820B08CCh */ case    0:  		/* nop */
		/* 820B08CCh case    0:*/		cpu::op::nop();
		/* 820B08CCh case    0:*/		return 0x820B08D0;
	}
	return 0x820B08D0;
} // Block from 820B08CCh-820B08D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B08D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B08D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B08D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B08D0);
		  /* 820B08D0h */ case    0:  		/* mfspr R12, LR */
		/* 820B08D0h case    0:*/		regs.R12 = regs.LR;
		/* 820B08D0h case    0:*/		return 0x820B08D4;
		  /* 820B08D4h */ case    1:  		/* bl -128652 */
		/* 820B08D4h case    1:*/		regs.LR = 0x820B08D8; return 0x82091248;
		/* 820B08D4h case    1:*/		return 0x820B08D8;
		  /* 820B08D8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820B08D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820B08D8h case    2:*/		return 0x820B08DC;
		  /* 820B08DCh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820B08DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820B08DCh case    3:*/		return 0x820B08E0;
		  /* 820B08E0h */ case    4:  		/* mr R31, R3 */
		/* 820B08E0h case    4:*/		regs.R31 = regs.R3;
		/* 820B08E0h case    4:*/		return 0x820B08E4;
		  /* 820B08E4h */ case    5:  		/* mr R30, R4 */
		/* 820B08E4h case    5:*/		regs.R30 = regs.R4;
		/* 820B08E4h case    5:*/		return 0x820B08E8;
		  /* 820B08E8h */ case    6:  		/* mr R26, R5 */
		/* 820B08E8h case    6:*/		regs.R26 = regs.R5;
		/* 820B08E8h case    6:*/		return 0x820B08EC;
		  /* 820B08ECh */ case    7:  		/* mr R24, R6 */
		/* 820B08ECh case    7:*/		regs.R24 = regs.R6;
		/* 820B08ECh case    7:*/		return 0x820B08F0;
		  /* 820B08F0h */ case    8:  		/* li R25, 0 */
		/* 820B08F0h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820B08F0h case    8:*/		return 0x820B08F4;
		  /* 820B08F4h */ case    9:  		/* lwz R10, <#[R11 + 8]> */
		/* 820B08F4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B08F4h case    9:*/		return 0x820B08F8;
		  /* 820B08F8h */ case   10:  		/* mr R28, R4 */
		/* 820B08F8h case   10:*/		regs.R28 = regs.R4;
		/* 820B08F8h case   10:*/		return 0x820B08FC;
		  /* 820B08FCh */ case   11:  		/* cmplw CR6, R4, R10 */
		/* 820B08FCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 820B08FCh case   11:*/		return 0x820B0900;
		  /* 820B0900h */ case   12:  		/* bc 4, CR6_LT, 76 */
		/* 820B0900h case   12:*/		if ( !regs.CR[6].lt ) { return 0x820B094C;  }
		/* 820B0900h case   12:*/		return 0x820B0904;
		  /* 820B0904h */ case   13:  		/* rlwinm R29, R4, 2, 0, 29 */
		/* 820B0904h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R4);
		/* 820B0904h case   13:*/		return 0x820B0908;
		  /* 820B0908h */ case   14:  		/* lwz R11, <#[R11 + 20]> */
		/* 820B0908h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820B0908h case   14:*/		return 0x820B090C;
		  /* 820B090Ch */ case   15:  		/* lwzx R27, <#[R11 + R29]> */
		/* 820B090Ch case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820B090Ch case   15:*/		return 0x820B0910;
		  /* 820B0910h */ case   16:  		/* cmplwi CR6, R27, 0 */
		/* 820B0910h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820B0910h case   16:*/		return 0x820B0914;
		  /* 820B0914h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 820B0914h case   17:*/		if ( regs.CR[6].eq ) { return 0x820B0928;  }
		/* 820B0914h case   17:*/		return 0x820B0918;
		  /* 820B0918h */ case   18:  		/* mr R3, R27 */
		/* 820B0918h case   18:*/		regs.R3 = regs.R27;
		/* 820B0918h case   18:*/		return 0x820B091C;
		  /* 820B091Ch */ case   19:  		/* bl 1493668 */
		/* 820B091Ch case   19:*/		regs.LR = 0x820B0920; return 0x8221D3C0;
		/* 820B091Ch case   19:*/		return 0x820B0920;
		  /* 820B0920h */ case   20:  		/* mr R3, R27 */
		/* 820B0920h case   20:*/		regs.R3 = regs.R27;
		/* 820B0920h case   20:*/		return 0x820B0924;
		  /* 820B0924h */ case   21:  		/* bl 312412 */
		/* 820B0924h case   21:*/		regs.LR = 0x820B0928; return 0x820FCD80;
		/* 820B0924h case   21:*/		return 0x820B0928;
	}
	return 0x820B0928;
} // Block from 820B08D0h-820B0928h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B0928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0928);
		  /* 820B0928h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B0928h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0928h case    0:*/		return 0x820B092C;
		  /* 820B092Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 820B092Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820B092Ch case    1:*/		return 0x820B0930;
		  /* 820B0930h */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 820B0930h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820B0930h case    2:*/		return 0x820B0934;
		  /* 820B0934h */ case    3:  		/* stwx R25, <#[R11 + R29]> */
		/* 820B0934h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820B0934h case    3:*/		return 0x820B0938;
		  /* 820B0938h */ case    4:  		/* addi R29, R29, 4 */
		/* 820B0938h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820B0938h case    4:*/		return 0x820B093C;
		  /* 820B093Ch */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B093Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B093Ch case    5:*/		return 0x820B0940;
		  /* 820B0940h */ case    6:  		/* lwz R10, <#[R11 + 8]> */
		/* 820B0940h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B0940h case    6:*/		return 0x820B0944;
		  /* 820B0944h */ case    7:  		/* cmplw CR6, R28, R10 */
		/* 820B0944h case    7:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820B0944h case    7:*/		return 0x820B0948;
		  /* 820B0948h */ case    8:  		/* bc 12, CR6_LT, -64 */
		/* 820B0948h case    8:*/		if ( regs.CR[6].lt ) { return 0x820B0908;  }
		/* 820B0948h case    8:*/		return 0x820B094C;
	}
	return 0x820B094C;
} // Block from 820B0928h-820B094Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B094Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B094C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B094C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B094C);
		  /* 820B094Ch */ case    0:  		/* stw R30, <#[R11 + 8]> */
		/* 820B094Ch case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 820B094Ch case    0:*/		return 0x820B0950;
		  /* 820B0950h */ case    1:  		/* mr R29, R26 */
		/* 820B0950h case    1:*/		regs.R29 = regs.R26;
		/* 820B0950h case    1:*/		return 0x820B0954;
		  /* 820B0954h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B0954h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0954h case    2:*/		return 0x820B0958;
		  /* 820B0958h */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 820B0958h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820B0958h case    3:*/		return 0x820B095C;
		  /* 820B095Ch */ case    4:  		/* cmplw CR6, R26, R10 */
		/* 820B095Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 820B095Ch case    4:*/		return 0x820B0960;
		  /* 820B0960h */ case    5:  		/* bc 4, CR6_LT, 76 */
		/* 820B0960h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820B09AC;  }
		/* 820B0960h case    5:*/		return 0x820B0964;
		  /* 820B0964h */ case    6:  		/* rlwinm R30, R26, 2, 0, 29 */
		/* 820B0964h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R26);
		/* 820B0964h case    6:*/		return 0x820B0968;
		  /* 820B0968h */ case    7:  		/* lwz R11, <#[R11 + 24]> */
		/* 820B0968h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820B0968h case    7:*/		return 0x820B096C;
		  /* 820B096Ch */ case    8:  		/* lwzx R28, <#[R11 + R30]> */
		/* 820B096Ch case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820B096Ch case    8:*/		return 0x820B0970;
		  /* 820B0970h */ case    9:  		/* cmplwi CR6, R28, 0 */
		/* 820B0970h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820B0970h case    9:*/		return 0x820B0974;
		  /* 820B0974h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 820B0974h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B0988;  }
		/* 820B0974h case   10:*/		return 0x820B0978;
		  /* 820B0978h */ case   11:  		/* mr R3, R28 */
		/* 820B0978h case   11:*/		regs.R3 = regs.R28;
		/* 820B0978h case   11:*/		return 0x820B097C;
		  /* 820B097Ch */ case   12:  		/* bl 1493572 */
		/* 820B097Ch case   12:*/		regs.LR = 0x820B0980; return 0x8221D3C0;
		/* 820B097Ch case   12:*/		return 0x820B0980;
		  /* 820B0980h */ case   13:  		/* mr R3, R28 */
		/* 820B0980h case   13:*/		regs.R3 = regs.R28;
		/* 820B0980h case   13:*/		return 0x820B0984;
		  /* 820B0984h */ case   14:  		/* bl 310380 */
		/* 820B0984h case   14:*/		regs.LR = 0x820B0988; return 0x820FC5F0;
		/* 820B0984h case   14:*/		return 0x820B0988;
	}
	return 0x820B0988;
} // Block from 820B094Ch-820B0988h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B0988h
// Function '?FindFunction@CCompiler@D3DXShader@@IAAPAVCNode@2@PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0988);
		  /* 820B0988h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B0988h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0988h case    0:*/		return 0x820B098C;
		  /* 820B098Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 820B098Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820B098Ch case    1:*/		return 0x820B0990;
		  /* 820B0990h */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 820B0990h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820B0990h case    2:*/		return 0x820B0994;
		  /* 820B0994h */ case    3:  		/* stwx R25, <#[R11 + R30]> */
		/* 820B0994h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820B0994h case    3:*/		return 0x820B0998;
		  /* 820B0998h */ case    4:  		/* addi R30, R30, 4 */
		/* 820B0998h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820B0998h case    4:*/		return 0x820B099C;
		  /* 820B099Ch */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B099Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B099Ch case    5:*/		return 0x820B09A0;
		  /* 820B09A0h */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 820B09A0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820B09A0h case    6:*/		return 0x820B09A4;
		  /* 820B09A4h */ case    7:  		/* cmplw CR6, R29, R10 */
		/* 820B09A4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 820B09A4h case    7:*/		return 0x820B09A8;
		  /* 820B09A8h */ case    8:  		/* bc 12, CR6_LT, -64 */
		/* 820B09A8h case    8:*/		if ( regs.CR[6].lt ) { return 0x820B0968;  }
		/* 820B09A8h case    8:*/		return 0x820B09AC;
	}
	return 0x820B09AC;
} // Block from 820B0988h-820B09ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B09ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B09AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B09AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B09AC);
		  /* 820B09ACh */ case    0:  		/* stw R26, <#[R11 + 12]> */
		/* 820B09ACh case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 820B09ACh case    0:*/		return 0x820B09B0;
		  /* 820B09B0h */ case    1:  		/* mr R4, R24 */
		/* 820B09B0h case    1:*/		regs.R4 = regs.R24;
		/* 820B09B0h case    1:*/		return 0x820B09B4;
		  /* 820B09B4h */ case    2:  		/* lwz R3, <#[R31 + 24]> */
		/* 820B09B4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820B09B4h case    2:*/		return 0x820B09B8;
		  /* 820B09B8h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 820B09B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B09B8h case    3:*/		return 0x820B09BC;
		  /* 820B09BCh */ case    4:  		/* lwz R11, <#[R11 + 28]> */
		/* 820B09BCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 820B09BCh case    4:*/		return 0x820B09C0;
		  /* 820B09C0h */ case    5:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820B09C0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820B09C0h case    5:*/		return 0x820B09C4;
		  /* 820B09C4h */ case    6:  		/* bl -126996 */
		/* 820B09C4h case    6:*/		regs.LR = 0x820B09C8; return 0x820919B0;
		/* 820B09C4h case    6:*/		return 0x820B09C8;
		  /* 820B09C8h */ case    7:  		/* li R3, 0 */
		/* 820B09C8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B09C8h case    7:*/		return 0x820B09CC;
		  /* 820B09CCh */ case    8:  		/* addi R1, R1, 160 */
		/* 820B09CCh case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820B09CCh case    8:*/		return 0x820B09D0;
		  /* 820B09D0h */ case    9:  		/* b -128824 */
		/* 820B09D0h case    9:*/		return 0x82091298;
		/* 820B09D0h case    9:*/		return 0x820B09D4;
		  /* 820B09D4h */ case   10:  		/* nop */
		/* 820B09D4h case   10:*/		cpu::op::nop();
		/* 820B09D4h case   10:*/		return 0x820B09D8;
		  /* 820B09D8h */ case   11:  		/* mr R7, R6 */
		/* 820B09D8h case   11:*/		regs.R7 = regs.R6;
		/* 820B09D8h case   11:*/		return 0x820B09DC;
		  /* 820B09DCh */ case   12:  		/* mr R6, R5 */
		/* 820B09DCh case   12:*/		regs.R6 = regs.R5;
		/* 820B09DCh case   12:*/		return 0x820B09E0;
		  /* 820B09E0h */ case   13:  		/* li R5, 0 */
		/* 820B09E0h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B09E0h case   13:*/		return 0x820B09E4;
		  /* 820B09E4h */ case   14:  		/* b -876 */
		/* 820B09E4h case   14:*/		return 0x820B0678;
		/* 820B09E4h case   14:*/		return 0x820B09E8;
		  /* 820B09E8h */ case   15:  		/* b -880 */
		/* 820B09E8h case   15:*/		return 0x820B0678;
		/* 820B09E8h case   15:*/		return 0x820B09EC;
		  /* 820B09ECh */ case   16:  		/* nop */
		/* 820B09ECh case   16:*/		cpu::op::nop();
		/* 820B09ECh case   16:*/		return 0x820B09F0;
	}
	return 0x820B09F0;
} // Block from 820B09ACh-820B09F0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B09F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B09F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B09F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B09F0);
		  /* 820B09F0h */ case    0:  		/* mfspr R12, LR */
		/* 820B09F0h case    0:*/		regs.R12 = regs.LR;
		/* 820B09F0h case    0:*/		return 0x820B09F4;
		  /* 820B09F4h */ case    1:  		/* bl -128920 */
		/* 820B09F4h case    1:*/		regs.LR = 0x820B09F8; return 0x8209125C;
		/* 820B09F4h case    1:*/		return 0x820B09F8;
		  /* 820B09F8h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 820B09F8h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820B09F8h case    2:*/		return 0x820B09FC;
		  /* 820B09FCh */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 820B09FCh case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820B09FCh case    3:*/		return 0x820B0A00;
		  /* 820B0A00h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 820B0A00h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820B0A00h case    4:*/		return 0x820B0A04;
		  /* 820B0A04h */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 820B0A04h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820B0A04h case    5:*/		return 0x820B0A08;
		  /* 820B0A08h */ case    6:  		/* stwu R1, <#[R1 - 384]> */
		/* 820B0A08h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE80);
		/* 820B0A08h case    6:*/		return 0x820B0A0C;
		  /* 820B0A0Ch */ case    7:  		/* li R11, 1 */
		/* 820B0A0Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820B0A0Ch case    7:*/		return 0x820B0A10;
		  /* 820B0A10h */ case    8:  		/* stw R6, <#[R1 + 428]> */
		/* 820B0A10h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001AC) );
		/* 820B0A10h case    8:*/		return 0x820B0A14;
		  /* 820B0A14h */ case    9:  		/* addi R10, R1, 80 */
		/* 820B0A14h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820B0A14h case    9:*/		return 0x820B0A18;
		  /* 820B0A18h */ case   10:  		/* stw R11, <#[R3 + 76]> */
		/* 820B0A18h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 820B0A18h case   10:*/		return 0x820B0A1C;
		  /* 820B0A1Ch */ case   11:  		/* addi R11, R1, 432 */
		/* 820B0A1Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x1B0);
		/* 820B0A1Ch case   11:*/		return 0x820B0A20;
		  /* 820B0A20h */ case   12:  		/* mr R31, R3 */
		/* 820B0A20h case   12:*/		regs.R31 = regs.R3;
		/* 820B0A20h case   12:*/		return 0x820B0A24;
		  /* 820B0A24h */ case   13:  		/* mr R30, R4 */
		/* 820B0A24h case   13:*/		regs.R30 = regs.R4;
		/* 820B0A24h case   13:*/		return 0x820B0A28;
		  /* 820B0A28h */ case   14:  		/* mr R29, R5 */
		/* 820B0A28h case   14:*/		regs.R29 = regs.R5;
		/* 820B0A28h case   14:*/		return 0x820B0A2C;
		  /* 820B0A2Ch */ case   15:  		/* mr R5, R6 */
		/* 820B0A2Ch case   15:*/		regs.R5 = regs.R6;
		/* 820B0A2Ch case   15:*/		return 0x820B0A30;
		  /* 820B0A30h */ case   16:  		/* stw R11, <#[R10]> */
		/* 820B0A30h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820B0A30h case   16:*/		return 0x820B0A34;
		  /* 820B0A34h */ case   17:  		/* li R4, 256 */
		/* 820B0A34h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820B0A34h case   17:*/		return 0x820B0A38;
		  /* 820B0A38h */ case   18:  		/* lwz R6, <#[R1 + 80]> */
		/* 820B0A38h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820B0A38h case   18:*/		return 0x820B0A3C;
		  /* 820B0A3Ch */ case   19:  		/* addi R3, R1, 96 */
		/* 820B0A3Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820B0A3Ch case   19:*/		return 0x820B0A40;
		  /* 820B0A40h */ case   20:  		/* bl -72536 */
		/* 820B0A40h case   20:*/		regs.LR = 0x820B0A44; return 0x8209EEE8;
		/* 820B0A40h case   20:*/		return 0x820B0A44;
		  /* 820B0A44h */ case   21:  		/* lis R11, -32255 */
		/* 820B0A44h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B0A44h case   21:*/		return 0x820B0A48;
		  /* 820B0A48h */ case   22:  		/* li R10, 0 */
		/* 820B0A48h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B0A48h case   22:*/		return 0x820B0A4C;
		  /* 820B0A4Ch */ case   23:  		/* mr R3, R30 */
		/* 820B0A4Ch case   23:*/		regs.R3 = regs.R30;
		/* 820B0A4Ch case   23:*/		return 0x820B0A50;
		  /* 820B0A50h */ case   24:  		/* addi R6, R11, -10432 */
		/* 820B0A50h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD740);
		/* 820B0A50h case   24:*/		return 0x820B0A54;
		  /* 820B0A54h */ case   25:  		/* stb R10, <#[R1 + 351]> */
		/* 820B0A54h case   25:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x0000015F) );
		/* 820B0A54h case   25:*/		return 0x820B0A58;
		  /* 820B0A58h */ case   26:  		/* addi R7, R1, 96 */
		/* 820B0A58h case   26:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820B0A58h case   26:*/		return 0x820B0A5C;
		  /* 820B0A5Ch */ case   27:  		/* mr R5, R29 */
		/* 820B0A5Ch case   27:*/		regs.R5 = regs.R29;
		/* 820B0A5Ch case   27:*/		return 0x820B0A60;
		  /* 820B0A60h */ case   28:  		/* bl -1856 */
		/* 820B0A60h case   28:*/		regs.LR = 0x820B0A64; return 0x820B0320;
		/* 820B0A60h case   28:*/		return 0x820B0A64;
		  /* 820B0A64h */ case   29:  		/* lwz R11, <#[R31]> */
		/* 820B0A64h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B0A64h case   29:*/		return 0x820B0A68;
		  /* 820B0A68h */ case   30:  		/* mr R4, R3 */
		/* 820B0A68h case   30:*/		regs.R4 = regs.R3;
		/* 820B0A68h case   30:*/		return 0x820B0A6C;
		  /* 820B0A6Ch */ case   31:  		/* addi R3, R11, 24 */
		/* 820B0A6Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820B0A6Ch case   31:*/		return 0x820B0A70;
		  /* 820B0A70h */ case   32:  		/* bl -39136 */
		/* 820B0A70h case   32:*/		regs.LR = 0x820B0A74; return 0x820A7190;
		/* 820B0A70h case   32:*/		return 0x820B0A74;
		  /* 820B0A74h */ case   33:  		/* li R3, 0 */
		/* 820B0A74h case   33:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B0A74h case   33:*/		return 0x820B0A78;
		  /* 820B0A78h */ case   34:  		/* addi R1, R1, 384 */
		/* 820B0A78h case   34:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x180);
		/* 820B0A78h case   34:*/		return 0x820B0A7C;
		  /* 820B0A7Ch */ case   35:  		/* b -128976 */
		/* 820B0A7Ch case   35:*/		return 0x820912AC;
		/* 820B0A7Ch case   35:*/		return 0x820B0A80;
	}
	return 0x820B0A80;
} // Block from 820B09F0h-820B0A80h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820B0A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0A80);
		  /* 820B0A80h */ case    0:  		/* mfspr R12, LR */
		/* 820B0A80h case    0:*/		regs.R12 = regs.LR;
		/* 820B0A80h case    0:*/		return 0x820B0A84;
		  /* 820B0A84h */ case    1:  		/* bl -129064 */
		/* 820B0A84h case    1:*/		regs.LR = 0x820B0A88; return 0x8209125C;
		/* 820B0A84h case    1:*/		return 0x820B0A88;
		  /* 820B0A88h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 820B0A88h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820B0A88h case    2:*/		return 0x820B0A8C;
		  /* 820B0A8Ch */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 820B0A8Ch case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820B0A8Ch case    3:*/		return 0x820B0A90;
		  /* 820B0A90h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 820B0A90h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820B0A90h case    4:*/		return 0x820B0A94;
		  /* 820B0A94h */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 820B0A94h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820B0A94h case    5:*/		return 0x820B0A98;
		  /* 820B0A98h */ case    6:  		/* stwu R1, <#[R1 - 384]> */
		/* 820B0A98h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE80);
		/* 820B0A98h case    6:*/		return 0x820B0A9C;
		  /* 820B0A9Ch */ case    7:  		/* stw R6, <#[R1 + 428]> */
		/* 820B0A9Ch case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001AC) );
		/* 820B0A9Ch case    7:*/		return 0x820B0AA0;
		  /* 820B0AA0h */ case    8:  		/* addi R11, R1, 80 */
		/* 820B0AA0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B0AA0h case    8:*/		return 0x820B0AA4;
		  /* 820B0AA4h */ case    9:  		/* addi R10, R1, 432 */
		/* 820B0AA4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x1B0);
		/* 820B0AA4h case    9:*/		return 0x820B0AA8;
		  /* 820B0AA8h */ case   10:  		/* mr R31, R3 */
		/* 820B0AA8h case   10:*/		regs.R31 = regs.R3;
		/* 820B0AA8h case   10:*/		return 0x820B0AAC;
		  /* 820B0AACh */ case   11:  		/* mr R30, R4 */
		/* 820B0AACh case   11:*/		regs.R30 = regs.R4;
		/* 820B0AACh case   11:*/		return 0x820B0AB0;
		  /* 820B0AB0h */ case   12:  		/* mr R29, R5 */
		/* 820B0AB0h case   12:*/		regs.R29 = regs.R5;
		/* 820B0AB0h case   12:*/		return 0x820B0AB4;
		  /* 820B0AB4h */ case   13:  		/* mr R5, R6 */
		/* 820B0AB4h case   13:*/		regs.R5 = regs.R6;
		/* 820B0AB4h case   13:*/		return 0x820B0AB8;
		  /* 820B0AB8h */ case   14:  		/* stw R10, <#[R11]> */
		/* 820B0AB8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820B0AB8h case   14:*/		return 0x820B0ABC;
		  /* 820B0ABCh */ case   15:  		/* li R4, 256 */
		/* 820B0ABCh case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 820B0ABCh case   15:*/		return 0x820B0AC0;
		  /* 820B0AC0h */ case   16:  		/* lwz R6, <#[R1 + 80]> */
		/* 820B0AC0h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820B0AC0h case   16:*/		return 0x820B0AC4;
		  /* 820B0AC4h */ case   17:  		/* addi R3, R1, 96 */
		/* 820B0AC4h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 820B0AC4h case   17:*/		return 0x820B0AC8;
		  /* 820B0AC8h */ case   18:  		/* bl -72672 */
		/* 820B0AC8h case   18:*/		regs.LR = 0x820B0ACC; return 0x8209EEE8;
		/* 820B0AC8h case   18:*/		return 0x820B0ACC;
		  /* 820B0ACCh */ case   19:  		/* lis R11, -32255 */
		/* 820B0ACCh case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B0ACCh case   19:*/		return 0x820B0AD0;
		  /* 820B0AD0h */ case   20:  		/* li R10, 0 */
		/* 820B0AD0h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B0AD0h case   20:*/		return 0x820B0AD4;
		  /* 820B0AD4h */ case   21:  		/* mr R3, R30 */
		/* 820B0AD4h case   21:*/		regs.R3 = regs.R30;
		/* 820B0AD4h case   21:*/		return 0x820B0AD8;
	}
	return 0x820B0AD8;
} // Block from 820B0A80h-820B0AD8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B0AD8h
// Function '?FindFunction@CCompiler@D3DXShader@@IAAPAVCNode@2@PAV32@PAPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0AD8);
		  /* 820B0AD8h */ case    0:  		/* addi R6, R11, -10432 */
		/* 820B0AD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD740);
		/* 820B0AD8h case    0:*/		return 0x820B0ADC;
		  /* 820B0ADCh */ case    1:  		/* stb R10, <#[R1 + 351]> */
		/* 820B0ADCh case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x0000015F) );
		/* 820B0ADCh case    1:*/		return 0x820B0AE0;
		  /* 820B0AE0h */ case    2:  		/* addi R7, R1, 96 */
		/* 820B0AE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820B0AE0h case    2:*/		return 0x820B0AE4;
		  /* 820B0AE4h */ case    3:  		/* mr R5, R29 */
		/* 820B0AE4h case    3:*/		regs.R5 = regs.R29;
		/* 820B0AE4h case    3:*/		return 0x820B0AE8;
		  /* 820B0AE8h */ case    4:  		/* bl -1992 */
		/* 820B0AE8h case    4:*/		regs.LR = 0x820B0AEC; return 0x820B0320;
		/* 820B0AE8h case    4:*/		return 0x820B0AEC;
		  /* 820B0AECh */ case    5:  		/* lwz R11, <#[R31]> */
		/* 820B0AECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B0AECh case    5:*/		return 0x820B0AF0;
		  /* 820B0AF0h */ case    6:  		/* mr R4, R3 */
		/* 820B0AF0h case    6:*/		regs.R4 = regs.R3;
		/* 820B0AF0h case    6:*/		return 0x820B0AF4;
		  /* 820B0AF4h */ case    7:  		/* addi R3, R11, 24 */
		/* 820B0AF4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820B0AF4h case    7:*/		return 0x820B0AF8;
		  /* 820B0AF8h */ case    8:  		/* bl -38816 */
		/* 820B0AF8h case    8:*/		regs.LR = 0x820B0AFC; return 0x820A7358;
		/* 820B0AF8h case    8:*/		return 0x820B0AFC;
		  /* 820B0AFCh */ case    9:  		/* li R3, 0 */
		/* 820B0AFCh case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B0AFCh case    9:*/		return 0x820B0B00;
		  /* 820B0B00h */ case   10:  		/* addi R1, R1, 384 */
		/* 820B0B00h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x180);
		/* 820B0B00h case   10:*/		return 0x820B0B04;
		  /* 820B0B04h */ case   11:  		/* b -129112 */
		/* 820B0B04h case   11:*/		return 0x820912AC;
		/* 820B0B04h case   11:*/		return 0x820B0B08;
	}
	return 0x820B0B08;
} // Block from 820B0AD8h-820B0B08h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B0B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0B08);
		  /* 820B0B08h */ case    0:  		/* mfspr R12, LR */
		/* 820B0B08h case    0:*/		regs.R12 = regs.LR;
		/* 820B0B08h case    0:*/		return 0x820B0B0C;
		  /* 820B0B0Ch */ case    1:  		/* bl -129252 */
		/* 820B0B0Ch case    1:*/		regs.LR = 0x820B0B10; return 0x82091228;
		/* 820B0B0Ch case    1:*/		return 0x820B0B10;
		  /* 820B0B10h */ case    2:  		/* stfd FR31, <#[R1 - 144]> */
		/* 820B0B10h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 820B0B10h case    2:*/		return 0x820B0B14;
		  /* 820B0B14h */ case    3:  		/* stwu R1, <#[R1 - 320]> */
		/* 820B0B14h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 820B0B14h case    3:*/		return 0x820B0B18;
		  /* 820B0B18h */ case    4:  		/* lis R20, 8272 */
		/* 820B0B18h case    4:*/		cpu::op::lis<0>(regs,&regs.R20,0x2050);
		/* 820B0B18h case    4:*/		return 0x820B0B1C;
		  /* 820B0B1Ch */ case    5:  		/* rlwinm R10, R5, 0, 0, 11 */
		/* 820B0B1Ch case    5:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R5);
		/* 820B0B1Ch case    5:*/		return 0x820B0B20;
		  /* 820B0B20h */ case    6:  		/* mr R23, R3 */
		/* 820B0B20h case    6:*/		regs.R23 = regs.R3;
		/* 820B0B20h case    6:*/		return 0x820B0B24;
		  /* 820B0B24h */ case    7:  		/* mr R16, R4 */
		/* 820B0B24h case    7:*/		regs.R16 = regs.R4;
		/* 820B0B24h case    7:*/		return 0x820B0B28;
		  /* 820B0B28h */ case    8:  		/* mr R11, R5 */
		/* 820B0B28h case    8:*/		regs.R11 = regs.R5;
		/* 820B0B28h case    8:*/		return 0x820B0B2C;
		  /* 820B0B2Ch */ case    9:  		/* mr R19, R6 */
		/* 820B0B2Ch case    9:*/		regs.R19 = regs.R6;
		/* 820B0B2Ch case    9:*/		return 0x820B0B30;
		  /* 820B0B30h */ case   10:  		/* mr R24, R7 */
		/* 820B0B30h case   10:*/		regs.R24 = regs.R7;
		/* 820B0B30h case   10:*/		return 0x820B0B34;
		  /* 820B0B34h */ case   11:  		/* mr R26, R8 */
		/* 820B0B34h case   11:*/		regs.R26 = regs.R8;
		/* 820B0B34h case   11:*/		return 0x820B0B38;
		  /* 820B0B38h */ case   12:  		/* mr R21, R9 */
		/* 820B0B38h case   12:*/		regs.R21 = regs.R9;
		/* 820B0B38h case   12:*/		return 0x820B0B3C;
		  /* 820B0B3Ch */ case   13:  		/* cmplw CR6, R10, R20 */
		/* 820B0B3Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R20);
		/* 820B0B3Ch case   13:*/		return 0x820B0B40;
		  /* 820B0B40h */ case   14:  		/* bc 4, CR6_EQ, 108 */
		/* 820B0B40h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820B0BAC;  }
		/* 820B0B40h case   14:*/		return 0x820B0B44;
		  /* 820B0B44h */ case   15:  		/* rlwinm. R10, R9, 0, 29, 29 */
		/* 820B0B44h case   15:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R9);
		/* 820B0B44h case   15:*/		return 0x820B0B48;
		  /* 820B0B48h */ case   16:  		/* bc 12, CR0_EQ, 100 */
		/* 820B0B48h case   16:*/		if ( regs.CR[0].eq ) { return 0x820B0BAC;  }
		/* 820B0B48h case   16:*/		return 0x820B0B4C;
		  /* 820B0B4Ch */ case   17:  		/* rlwinm. R7, R5, 0, 12, 31 */
		/* 820B0B4Ch case   17:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R7,regs.R5);
		/* 820B0B4Ch case   17:*/		return 0x820B0B50;
		  /* 820B0B50h */ case   18:  		/* li R8, 0 */
		/* 820B0B50h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B0B50h case   18:*/		return 0x820B0B54;
		  /* 820B0B54h */ case   19:  		/* bc 12, CR0_EQ, 72 */
		/* 820B0B54h case   19:*/		if ( regs.CR[0].eq ) { return 0x820B0B9C;  }
		/* 820B0B54h case   19:*/		return 0x820B0B58;
		  /* 820B0B58h */ case   20:  		/* mr R10, R24 */
		/* 820B0B58h case   20:*/		regs.R10 = regs.R24;
		/* 820B0B58h case   20:*/		return 0x820B0B5C;
		  /* 820B0B5Ch */ case   21:  		/* subf R6, R24, R26 */
		/* 820B0B5Ch case   21:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R24,regs.R26);
		/* 820B0B5Ch case   21:*/		return 0x820B0B60;
		  /* 820B0B60h */ case   22:  		/* lwz R9, <#[R10]> */
		/* 820B0B60h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820B0B60h case   22:*/		return 0x820B0B64;
		  /* 820B0B64h */ case   23:  		/* lwzx R5, <#[R6 + R10]> */
		/* 820B0B64h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 820B0B64h case   23:*/		return 0x820B0B68;
		  /* 820B0B68h */ case   24:  		/* cmplw CR6, R9, R5 */
		/* 820B0B68h case   24:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 820B0B68h case   24:*/		return 0x820B0B6C;
		  /* 820B0B6Ch */ case   25:  		/* bc 4, CR6_EQ, 48 */
		/* 820B0B6Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x820B0B9C;  }
		/* 820B0B6Ch case   25:*/		return 0x820B0B70;
		  /* 820B0B70h */ case   26:  		/* lwz R5, <#[R23 + 8]> */
		/* 820B0B70h case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000008) );
		/* 820B0B70h case   26:*/		return 0x820B0B74;
		  /* 820B0B74h */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B0B74h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B0B74h case   27:*/		return 0x820B0B78;
		  /* 820B0B78h */ case   28:  		/* lwz R5, <#[R5 + 20]> */
		/* 820B0B78h case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000014) );
		/* 820B0B78h case   28:*/		return 0x820B0B7C;
		  /* 820B0B7Ch */ case   29:  		/* lwzx R9, <#[R5 + R9]> */
		/* 820B0B7Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 820B0B7Ch case   29:*/		return 0x820B0B80;
		  /* 820B0B80h */ case   30:  		/* lwz R9, <#[R9]> */
		/* 820B0B80h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820B0B80h case   30:*/		return 0x820B0B84;
		  /* 820B0B84h */ case   31:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 820B0B84h case   31:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 820B0B84h case   31:*/		return 0x820B0B88;
		  /* 820B0B88h */ case   32:  		/* bc 12, CR0_EQ, 20 */
		/* 820B0B88h case   32:*/		if ( regs.CR[0].eq ) { return 0x820B0B9C;  }
		/* 820B0B88h case   32:*/		return 0x820B0B8C;
		  /* 820B0B8Ch */ case   33:  		/* addi R8, R8, 1 */
		/* 820B0B8Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820B0B8Ch case   33:*/		return 0x820B0B90;
		  /* 820B0B90h */ case   34:  		/* addi R10, R10, 4 */
		/* 820B0B90h case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820B0B90h case   34:*/		return 0x820B0B94;
		  /* 820B0B94h */ case   35:  		/* cmplw CR6, R8, R7 */
		/* 820B0B94h case   35:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820B0B94h case   35:*/		return 0x820B0B98;
		  /* 820B0B98h */ case   36:  		/* bc 12, CR6_LT, -56 */
		/* 820B0B98h case   36:*/		if ( regs.CR[6].lt ) { return 0x820B0B60;  }
		/* 820B0B98h case   36:*/		return 0x820B0B9C;
	}
	return 0x820B0B9C;
} // Block from 820B0B08h-820B0B9Ch (37 instructions)

//////////////////////////////////////////////////////
// Block at 820B0B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0B9C);
		  /* 820B0B9Ch */ case    0:  		/* cmplw CR6, R8, R7 */
		/* 820B0B9Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820B0B9Ch case    0:*/		return 0x820B0BA0;
		  /* 820B0BA0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820B0BA0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B0BAC;  }
		/* 820B0BA0h case    1:*/		return 0x820B0BA4;
		  /* 820B0BA4h */ case    2:  		/* rlwinm R11, R7, 0, 12, 31 */
		/* 820B0BA4h case    2:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R7);
		/* 820B0BA4h case    2:*/		return 0x820B0BA8;
		  /* 820B0BA8h */ case    3:  		/* oris R11, R11, 4096 */
		/* 820B0BA8h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 820B0BA8h case    3:*/		return 0x820B0BAC;
	}
	return 0x820B0BAC;
} // Block from 820B0B9Ch-820B0BACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B0BACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0BAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0BAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0BAC);
		  /* 820B0BACh */ case    0:  		/* lis R10, 20480 */
		/* 820B0BACh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x5000);
		/* 820B0BACh case    0:*/		return 0x820B0BB0;
		  /* 820B0BB0h */ case    1:  		/* ori R10, R10, 1 */
		/* 820B0BB0h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B0BB0h case    1:*/		return 0x820B0BB4;
		  /* 820B0BB4h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820B0BB4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B0BB4h case    2:*/		return 0x820B0BB8;
		  /* 820B0BB8h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 820B0BB8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B0BEC;  }
		/* 820B0BB8h case    3:*/		return 0x820B0BBC;
		  /* 820B0BBCh */ case    4:  		/* lis R5, 8272 */
		/* 820B0BBCh case    4:*/		cpu::op::lis<0>(regs,&regs.R5,0x2050);
		/* 820B0BBCh case    4:*/		return 0x820B0BC0;
		  /* 820B0BC0h */ case    5:  		/* mr R8, R26 */
		/* 820B0BC0h case    5:*/		regs.R8 = regs.R26;
		/* 820B0BC0h case    5:*/		return 0x820B0BC4;
		  /* 820B0BC4h */ case    6:  		/* mr R7, R24 */
		/* 820B0BC4h case    6:*/		regs.R7 = regs.R24;
		/* 820B0BC4h case    6:*/		return 0x820B0BC8;
		  /* 820B0BC8h */ case    7:  		/* mr R9, R21 */
		/* 820B0BC8h case    7:*/		regs.R9 = regs.R21;
		/* 820B0BC8h case    7:*/		return 0x820B0BCC;
		  /* 820B0BCCh */ case    8:  		/* mr R6, R19 */
		/* 820B0BCCh case    8:*/		regs.R6 = regs.R19;
		/* 820B0BCCh case    8:*/		return 0x820B0BD0;
		  /* 820B0BD0h */ case    9:  		/* ori R5, R5, 1 */
		/* 820B0BD0h case    9:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B0BD0h case    9:*/		return 0x820B0BD4;
		  /* 820B0BD4h */ case   10:  		/* mr R4, R16 */
		/* 820B0BD4h case   10:*/		regs.R4 = regs.R16;
		/* 820B0BD4h case   10:*/		return 0x820B0BD8;
		  /* 820B0BD8h */ case   11:  		/* mr R3, R23 */
		/* 820B0BD8h case   11:*/		regs.R3 = regs.R23;
		/* 820B0BD8h case   11:*/		return 0x820B0BDC;
		  /* 820B0BDCh */ case   12:  		/* bl -212 */
		/* 820B0BDCh case   12:*/		regs.LR = 0x820B0BE0; return 0x820B0B08;
		/* 820B0BDCh case   12:*/		return 0x820B0BE0;
		  /* 820B0BE0h */ case   13:  		/* srawi R11, R3, 31 */
		/* 820B0BE0h case   13:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820B0BE0h case   13:*/		return 0x820B0BE4;
		  /* 820B0BE4h */ case   14:  		/* and R3, R11, R3 */
		/* 820B0BE4h case   14:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820B0BE4h case   14:*/		return 0x820B0BE8;
		  /* 820B0BE8h */ case   15:  		/* b 2728 */
		/* 820B0BE8h case   15:*/		return 0x820B1690;
		/* 820B0BE8h case   15:*/		return 0x820B0BEC;
	}
	return 0x820B0BEC;
} // Block from 820B0BACh-820B0BECh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B0BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0BEC);
		  /* 820B0BECh */ case    0:  		/* lis R10, 20480 */
		/* 820B0BECh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x5000);
		/* 820B0BECh case    0:*/		return 0x820B0BF0;
		  /* 820B0BF0h */ case    1:  		/* ori R10, R10, 2 */
		/* 820B0BF0h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820B0BF0h case    1:*/		return 0x820B0BF4;
		  /* 820B0BF4h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820B0BF4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B0BF4h case    2:*/		return 0x820B0BF8;
		  /* 820B0BF8h */ case    3:  		/* bc 4, CR6_EQ, 144 */
		/* 820B0BF8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B0C88;  }
		/* 820B0BF8h case    3:*/		return 0x820B0BFC;
		  /* 820B0BFCh */ case    4:  		/* lwz R10, <#[R23 + 8]> */
		/* 820B0BFCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 820B0BFCh case    4:*/		return 0x820B0C00;
		  /* 820B0C00h */ case    5:  		/* lwz R10, <#[R10 + 108]> */
		/* 820B0C00h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000006C) );
		/* 820B0C00h case    5:*/		return 0x820B0C04;
		  /* 820B0C04h */ case    6:  		/* rlwinm. R10, R10, 0, 6, 6 */
		/* 820B0C04h case    6:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R10,regs.R10);
		/* 820B0C04h case    6:*/		return 0x820B0C08;
		  /* 820B0C08h */ case    7:  		/* bc 4, CR0_EQ, 128 */
		/* 820B0C08h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820B0C88;  }
		/* 820B0C08h case    7:*/		return 0x820B0C0C;
		  /* 820B0C0Ch */ case    8:  		/* addi R10, R1, 144 */
		/* 820B0C0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 820B0C0Ch case    8:*/		return 0x820B0C10;
		  /* 820B0C10h */ case    9:  		/* li R11, -1 */
		/* 820B0C10h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820B0C10h case    9:*/		return 0x820B0C14;
		  /* 820B0C14h */ case   10:  		/* rlwinm R31, R21, 0, 25, 25 */
		/* 820B0C14h case   10:*/		cpu::op::rlwinm<0,0,25,25>(regs,&regs.R31,regs.R21);
		/* 820B0C14h case   10:*/		return 0x820B0C18;
		  /* 820B0C18h */ case   11:  		/* lis R5, 8272 */
		/* 820B0C18h case   11:*/		cpu::op::lis<0>(regs,&regs.R5,0x2050);
		/* 820B0C18h case   11:*/		return 0x820B0C1C;
		  /* 820B0C1Ch */ case   12:  		/* mr R8, R26 */
		/* 820B0C1Ch case   12:*/		regs.R8 = regs.R26;
		/* 820B0C1Ch case   12:*/		return 0x820B0C20;
		  /* 820B0C20h */ case   13:  		/* stw R11, <#[R10]> */
		/* 820B0C20h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820B0C20h case   13:*/		return 0x820B0C24;
		  /* 820B0C24h */ case   14:  		/* mr R9, R31 */
		/* 820B0C24h case   14:*/		regs.R9 = regs.R31;
		/* 820B0C24h case   14:*/		return 0x820B0C28;
		  /* 820B0C28h */ case   15:  		/* stw R11, <#[R10 + 4]> */
		/* 820B0C28h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820B0C28h case   15:*/		return 0x820B0C2C;
		  /* 820B0C2Ch */ case   16:  		/* mr R7, R24 */
		/* 820B0C2Ch case   16:*/		regs.R7 = regs.R24;
		/* 820B0C2Ch case   16:*/		return 0x820B0C30;
	}
	return 0x820B0C30;
} // Block from 820B0BECh-820B0C30h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B0C30h
// Function '?PragmaDef@CCompiler@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0C30);
		  /* 820B0C30h */ case    0:  		/* addi R6, R1, 144 */
		/* 820B0C30h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 820B0C30h case    0:*/		return 0x820B0C34;
		  /* 820B0C34h */ case    1:  		/* ori R5, R5, 1 */
		/* 820B0C34h case    1:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B0C34h case    1:*/		return 0x820B0C38;
		  /* 820B0C38h */ case    2:  		/* mr R4, R16 */
		/* 820B0C38h case    2:*/		regs.R4 = regs.R16;
		/* 820B0C38h case    2:*/		return 0x820B0C3C;
		  /* 820B0C3Ch */ case    3:  		/* mr R3, R23 */
		/* 820B0C3Ch case    3:*/		regs.R3 = regs.R23;
		/* 820B0C3Ch case    3:*/		return 0x820B0C40;
		  /* 820B0C40h */ case    4:  		/* bl -312 */
		/* 820B0C40h case    4:*/		regs.LR = 0x820B0C44; return 0x820B0B08;
		/* 820B0C40h case    4:*/		return 0x820B0C44;
		  /* 820B0C44h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820B0C44h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0C44h case    5:*/		return 0x820B0C48;
		  /* 820B0C48h */ case    6:  		/* bc 12, CR0_LT, 2632 */
		/* 820B0C48h case    6:*/		if ( regs.CR[0].lt ) { return 0x820B1690;  }
		/* 820B0C48h case    6:*/		return 0x820B0C4C;
		  /* 820B0C4Ch */ case    7:  		/* lis R5, 8272 */
		/* 820B0C4Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R5,0x2050);
		/* 820B0C4Ch case    7:*/		return 0x820B0C50;
		  /* 820B0C50h */ case    8:  		/* mr R9, R31 */
		/* 820B0C50h case    8:*/		regs.R9 = regs.R31;
		/* 820B0C50h case    8:*/		return 0x820B0C54;
		  /* 820B0C54h */ case    9:  		/* addi R8, R26, 4 */
		/* 820B0C54h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R26,0x4);
		/* 820B0C54h case    9:*/		return 0x820B0C58;
		  /* 820B0C58h */ case   10:  		/* addi R7, R24, 4 */
		/* 820B0C58h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R24,0x4);
		/* 820B0C58h case   10:*/		return 0x820B0C5C;
		  /* 820B0C5Ch */ case   11:  		/* addi R6, R1, 148 */
		/* 820B0C5Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x94);
		/* 820B0C5Ch case   11:*/		return 0x820B0C60;
		  /* 820B0C60h */ case   12:  		/* ori R5, R5, 1 */
		/* 820B0C60h case   12:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B0C60h case   12:*/		return 0x820B0C64;
		  /* 820B0C64h */ case   13:  		/* mr R4, R16 */
		/* 820B0C64h case   13:*/		regs.R4 = regs.R16;
		/* 820B0C64h case   13:*/		return 0x820B0C68;
		  /* 820B0C68h */ case   14:  		/* mr R3, R23 */
		/* 820B0C68h case   14:*/		regs.R3 = regs.R23;
		/* 820B0C68h case   14:*/		return 0x820B0C6C;
		  /* 820B0C6Ch */ case   15:  		/* bl -356 */
		/* 820B0C6Ch case   15:*/		regs.LR = 0x820B0C70; return 0x820B0B08;
		/* 820B0C6Ch case   15:*/		return 0x820B0C70;
		  /* 820B0C70h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820B0C70h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0C70h case   16:*/		return 0x820B0C74;
		  /* 820B0C74h */ case   17:  		/* bc 12, CR0_LT, 2588 */
		/* 820B0C74h case   17:*/		if ( regs.CR[0].lt ) { return 0x820B1690;  }
		/* 820B0C74h case   17:*/		return 0x820B0C78;
		  /* 820B0C78h */ case   18:  		/* lis R5, 8256 */
		/* 820B0C78h case   18:*/		cpu::op::lis<0>(regs,&regs.R5,0x2040);
		/* 820B0C78h case   18:*/		return 0x820B0C7C;
		  /* 820B0C7Ch */ case   19:  		/* addi R8, R1, 148 */
		/* 820B0C7Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x94);
		/* 820B0C7Ch case   19:*/		return 0x820B0C80;
		  /* 820B0C80h */ case   20:  		/* addi R7, R1, 144 */
		/* 820B0C80h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820B0C80h case   20:*/		return 0x820B0C84;
		  /* 820B0C84h */ case   21:  		/* b -188 */
		/* 820B0C84h case   21:*/		return 0x820B0BC8;
		/* 820B0C84h case   21:*/		return 0x820B0C88;
	}
	return 0x820B0C88;
} // Block from 820B0C30h-820B0C88h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B0C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0C88);
		  /* 820B0C88h */ case    0:  		/* lwz R3, <#[R23 + 8]> */
		/* 820B0C88h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000008) );
		/* 820B0C88h case    0:*/		return 0x820B0C8C;
		  /* 820B0C8Ch */ case    1:  		/* lis R18, 8192 */
		/* 820B0C8Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R18,0x2000);
		/* 820B0C8Ch case    1:*/		return 0x820B0C90;
		  /* 820B0C90h */ case    2:  		/* lis R17, 8208 */
		/* 820B0C90h case    2:*/		cpu::op::lis<0>(regs,&regs.R17,0x2010);
		/* 820B0C90h case    2:*/		return 0x820B0C94;
		  /* 820B0C94h */ case    3:  		/* lwz R10, <#[R3 + 108]> */
		/* 820B0C94h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000006C) );
		/* 820B0C94h case    3:*/		return 0x820B0C98;
		  /* 820B0C98h */ case    4:  		/* rlwinm. R10, R10, 0, 8, 8 */
		/* 820B0C98h case    4:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R10,regs.R10);
		/* 820B0C98h case    4:*/		return 0x820B0C9C;
		  /* 820B0C9Ch */ case    5:  		/* bc 12, CR0_EQ, 496 */
		/* 820B0C9Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820B0E8C;  }
		/* 820B0C9Ch case    5:*/		return 0x820B0CA0;
		  /* 820B0CA0h */ case    6:  		/* rlwinm R31, R11, 0, 0, 11 */
		/* 820B0CA0h case    6:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R31,regs.R11);
		/* 820B0CA0h case    6:*/		return 0x820B0CA4;
		  /* 820B0CA4h */ case    7:  		/* lis R28, 8224 */
		/* 820B0CA4h case    7:*/		cpu::op::lis<0>(regs,&regs.R28,0x2020);
		/* 820B0CA4h case    7:*/		return 0x820B0CA8;
		  /* 820B0CA8h */ case    8:  		/* lis R30, 8240 */
		/* 820B0CA8h case    8:*/		cpu::op::lis<0>(regs,&regs.R30,0x2030);
		/* 820B0CA8h case    8:*/		return 0x820B0CAC;
		  /* 820B0CACh */ case    9:  		/* cmplw CR6, R31, R18 */
		/* 820B0CACh case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R18);
		/* 820B0CACh case    9:*/		return 0x820B0CB0;
		  /* 820B0CB0h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 820B0CB0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B0CCC;  }
		/* 820B0CB0h case   10:*/		return 0x820B0CB4;
		  /* 820B0CB4h */ case   11:  		/* cmplw CR6, R31, R17 */
		/* 820B0CB4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R17);
		/* 820B0CB4h case   11:*/		return 0x820B0CB8;
		  /* 820B0CB8h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 820B0CB8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820B0CCC;  }
		/* 820B0CB8h case   12:*/		return 0x820B0CBC;
		  /* 820B0CBCh */ case   13:  		/* cmplw CR6, R31, R28 */
		/* 820B0CBCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 820B0CBCh case   13:*/		return 0x820B0CC0;
		  /* 820B0CC0h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 820B0CC0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820B0CCC;  }
		/* 820B0CC0h case   14:*/		return 0x820B0CC4;
		  /* 820B0CC4h */ case   15:  		/* cmplw CR6, R31, R30 */
		/* 820B0CC4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 820B0CC4h case   15:*/		return 0x820B0CC8;
		  /* 820B0CC8h */ case   16:  		/* bc 4, CR6_EQ, 452 */
		/* 820B0CC8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820B0E8C;  }
		/* 820B0CC8h case   16:*/		return 0x820B0CCC;
	}
	return 0x820B0CCC;
} // Block from 820B0C88h-820B0CCCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B0CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0CCC);
		  /* 820B0CCCh */ case    0:  		/* lis R4, 9345 */
		/* 820B0CCCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B0CCCh case    0:*/		return 0x820B0CD0;
		  /* 820B0CD0h */ case    1:  		/* rlwinm R3, R11, 4, 8, 27 */
		/* 820B0CD0h case    1:*/		cpu::op::rlwinm<0,4,8,27>(regs,&regs.R3,regs.R11);
		/* 820B0CD0h case    1:*/		return 0x820B0CD4;
		  /* 820B0CD4h */ case    2:  		/* rlwinm R29, R11, 0, 12, 31 */
		/* 820B0CD4h case    2:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R11);
		/* 820B0CD4h case    2:*/		return 0x820B0CD8;
		  /* 820B0CD8h */ case    3:  		/* bl -166616 */
		/* 820B0CD8h case    3:*/		regs.LR = 0x820B0CDC; return 0x82088200;
		/* 820B0CD8h case    3:*/		return 0x820B0CDC;
		  /* 820B0CDCh */ case    4:  		/* or. R25, R3, R3 */
		/* 820B0CDCh case    4:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820B0CDCh case    4:*/		return 0x820B0CE0;
		  /* 820B0CE0h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 820B0CE0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820B0CF0;  }
		/* 820B0CE0h case    5:*/		return 0x820B0CE4;
		  /* 820B0CE4h */ case    6:  		/* lis R3, -32761 */
		/* 820B0CE4h case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820B0CE4h case    6:*/		return 0x820B0CE8;
		  /* 820B0CE8h */ case    7:  		/* ori R3, R3, 14 */
		/* 820B0CE8h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820B0CE8h case    7:*/		return 0x820B0CEC;
		  /* 820B0CECh */ case    8:  		/* b 2468 */
		/* 820B0CECh case    8:*/		return 0x820B1690;
		/* 820B0CECh case    8:*/		return 0x820B0CF0;
	}
	return 0x820B0CF0;
} // Block from 820B0CCCh-820B0CF0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B0CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0CF0);
		  /* 820B0CF0h */ case    0:  		/* li R10, 4 */
		/* 820B0CF0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820B0CF0h case    0:*/		return 0x820B0CF4;
		  /* 820B0CF4h */ case    1:  		/* addi R11, R1, 160 */
		/* 820B0CF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 820B0CF4h case    1:*/		return 0x820B0CF8;
		  /* 820B0CF8h */ case    2:  		/* rlwinm R8, R29, 2, 0, 29 */
		/* 820B0CF8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R29);
		/* 820B0CF8h case    2:*/		return 0x820B0CFC;
		  /* 820B0CFCh */ case    3:  		/* addi R9, R11, -4 */
		/* 820B0CFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B0CFCh case    3:*/		return 0x820B0D00;
		  /* 820B0D00h */ case    4:  		/* mr R11, R25 */
		/* 820B0D00h case    4:*/		regs.R11 = regs.R25;
		/* 820B0D00h case    4:*/		return 0x820B0D04;
		  /* 820B0D04h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B0D04h case    5:*/		regs.CTR = regs.R10;
		/* 820B0D04h case    5:*/		return 0x820B0D08;
		  /* 820B0D08h */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B0D08h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B0D08h case    6:*/		return 0x820B0D0C;
		  /* 820B0D0Ch */ case    7:  		/* add R11, R8, R11 */
		/* 820B0D0Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820B0D0Ch case    7:*/		return 0x820B0D10;
		  /* 820B0D10h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B0D10h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B0D08;  }
		/* 820B0D10h case    8:*/		return 0x820B0D14;
		  /* 820B0D14h */ case    9:  		/* cmplwi CR6, R29, 0 */
		/* 820B0D14h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820B0D14h case    9:*/		return 0x820B0D18;
		  /* 820B0D18h */ case   10:  		/* bc 12, CR6_EQ, 132 */
		/* 820B0D18h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B0D9C;  }
		/* 820B0D18h case   10:*/		return 0x820B0D1C;
		  /* 820B0D1Ch */ case   11:  		/* lwz R11, <#[R1 + 168]> */
		/* 820B0D1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 820B0D1Ch case   11:*/		return 0x820B0D20;
		  /* 820B0D20h */ case   12:  		/* mtspr CTR, R29 */
		/* 820B0D20h case   12:*/		regs.CTR = regs.R29;
		/* 820B0D20h case   12:*/		return 0x820B0D24;
		  /* 820B0D24h */ case   13:  		/* lwz R10, <#[R1 + 172]> */
		/* 820B0D24h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000AC) );
		/* 820B0D24h case   13:*/		return 0x820B0D28;
		  /* 820B0D28h */ case   14:  		/* subf R9, R11, R26 */
		/* 820B0D28h case   14:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R26);
		/* 820B0D28h case   14:*/		return 0x820B0D2C;
		  /* 820B0D2Ch */ case   15:  		/* subf R8, R11, R24 */
		/* 820B0D2Ch case   15:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R24);
		/* 820B0D2Ch case   15:*/		return 0x820B0D30;
		  /* 820B0D30h */ case   16:  		/* subf R10, R11, R10 */
		/* 820B0D30h case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820B0D30h case   16:*/		return 0x820B0D34;
		  /* 820B0D34h */ case   17:  		/* cmplw CR6, R31, R18 */
		/* 820B0D34h case   17:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R18);
		/* 820B0D34h case   17:*/		return 0x820B0D38;
		  /* 820B0D38h */ case   18:  		/* bc 12, CR6_EQ, 76 */
		/* 820B0D38h case   18:*/		if ( regs.CR[6].eq ) { return 0x820B0D84;  }
		/* 820B0D38h case   18:*/		return 0x820B0D3C;
		  /* 820B0D3Ch */ case   19:  		/* cmplw CR6, R31, R17 */
		/* 820B0D3Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R17);
		/* 820B0D3Ch case   19:*/		return 0x820B0D40;
		  /* 820B0D40h */ case   20:  		/* bc 12, CR6_EQ, 52 */
		/* 820B0D40h case   20:*/		if ( regs.CR[6].eq ) { return 0x820B0D74;  }
		/* 820B0D40h case   20:*/		return 0x820B0D44;
		  /* 820B0D44h */ case   21:  		/* cmplw CR6, R31, R28 */
		/* 820B0D44h case   21:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 820B0D44h case   21:*/		return 0x820B0D48;
		  /* 820B0D48h */ case   22:  		/* bc 12, CR6_EQ, 28 */
		/* 820B0D48h case   22:*/		if ( regs.CR[6].eq ) { return 0x820B0D64;  }
		/* 820B0D48h case   22:*/		return 0x820B0D4C;
		  /* 820B0D4Ch */ case   23:  		/* cmplw CR6, R31, R30 */
		/* 820B0D4Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 820B0D4Ch case   23:*/		return 0x820B0D50;
		  /* 820B0D50h */ case   24:  		/* bc 4, CR6_EQ, 68 */
		/* 820B0D50h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820B0D94;  }
		/* 820B0D50h case   24:*/		return 0x820B0D54;
		  /* 820B0D54h */ case   25:  		/* lwz R7, <#[R23 + 32]> */
		/* 820B0D54h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000020) );
		/* 820B0D54h case   25:*/		return 0x820B0D58;
	}
	return 0x820B0D58;
} // Block from 820B0CF0h-820B0D58h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820B0D58h
// Function '?GetToken@CCompiler@D3DXShader@@SAPAUD3DXTOKEN@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0D58);
		  /* 820B0D58h */ case    0:  		/* stw R7, <#[R11]> */
		/* 820B0D58h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820B0D58h case    0:*/		return 0x820B0D5C;
		  /* 820B0D5Ch */ case    1:  		/* lwz R7, <#[R23 + 36]> */
		/* 820B0D5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000024) );
		/* 820B0D5Ch case    1:*/		return 0x820B0D60;
		  /* 820B0D60h */ case    2:  		/* b 48 */
		/* 820B0D60h case    2:*/		return 0x820B0D90;
		/* 820B0D60h case    2:*/		return 0x820B0D64;
	}
	return 0x820B0D64;
} // Block from 820B0D58h-820B0D64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B0D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0D64);
		  /* 820B0D64h */ case    0:  		/* lwz R7, <#[R23 + 36]> */
		/* 820B0D64h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000024) );
		/* 820B0D64h case    0:*/		return 0x820B0D68;
		  /* 820B0D68h */ case    1:  		/* stw R7, <#[R11]> */
		/* 820B0D68h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820B0D68h case    1:*/		return 0x820B0D6C;
		  /* 820B0D6Ch */ case    2:  		/* lwz R7, <#[R23 + 32]> */
		/* 820B0D6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000020) );
		/* 820B0D6Ch case    2:*/		return 0x820B0D70;
		  /* 820B0D70h */ case    3:  		/* b 32 */
		/* 820B0D70h case    3:*/		return 0x820B0D90;
		/* 820B0D70h case    3:*/		return 0x820B0D74;
	}
	return 0x820B0D74;
} // Block from 820B0D64h-820B0D74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B0D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0D74);
		  /* 820B0D74h */ case    0:  		/* lwzx R7, <#[R8 + R11]> */
		/* 820B0D74h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820B0D74h case    0:*/		return 0x820B0D78;
		  /* 820B0D78h */ case    1:  		/* stw R7, <#[R11]> */
		/* 820B0D78h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820B0D78h case    1:*/		return 0x820B0D7C;
		  /* 820B0D7Ch */ case    2:  		/* lwzx R7, <#[R9 + R11]> */
		/* 820B0D7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B0D7Ch case    2:*/		return 0x820B0D80;
		  /* 820B0D80h */ case    3:  		/* b 16 */
		/* 820B0D80h case    3:*/		return 0x820B0D90;
		/* 820B0D80h case    3:*/		return 0x820B0D84;
	}
	return 0x820B0D84;
} // Block from 820B0D74h-820B0D84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B0D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0D84);
		  /* 820B0D84h */ case    0:  		/* lwzx R7, <#[R9 + R11]> */
		/* 820B0D84h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B0D84h case    0:*/		return 0x820B0D88;
		  /* 820B0D88h */ case    1:  		/* stw R7, <#[R11]> */
		/* 820B0D88h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820B0D88h case    1:*/		return 0x820B0D8C;
		  /* 820B0D8Ch */ case    2:  		/* lwzx R7, <#[R8 + R11]> */
		/* 820B0D8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820B0D8Ch case    2:*/		return 0x820B0D90;
	}
	return 0x820B0D90;
} // Block from 820B0D84h-820B0D90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B0D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0D90);
		  /* 820B0D90h */ case    0:  		/* stwx R7, <#[R10 + R11]> */
		/* 820B0D90h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B0D90h case    0:*/		return 0x820B0D94;
	}
	return 0x820B0D94;
} // Block from 820B0D90h-820B0D94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0D94);
		  /* 820B0D94h */ case    0:  		/* addi R11, R11, 4 */
		/* 820B0D94h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B0D94h case    0:*/		return 0x820B0D98;
		  /* 820B0D98h */ case    1:  		/* bc 16, CR0_LT, -100 */
		/* 820B0D98h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B0D34;  }
		/* 820B0D98h case    1:*/		return 0x820B0D9C;
	}
	return 0x820B0D9C;
} // Block from 820B0D94h-820B0D9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B0D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0D9C);
		  /* 820B0D9Ch */ case    0:  		/* lwz R27, <#[R1 + 160]> */
		/* 820B0D9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B0D9Ch case    0:*/		return 0x820B0DA0;
		  /* 820B0DA0h */ case    1:  		/* li R6, -1 */
		/* 820B0DA0h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820B0DA0h case    1:*/		return 0x820B0DA4;
		  /* 820B0DA4h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 820B0DA4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820B0DA4h case    2:*/		return 0x820B0DA8;
		  /* 820B0DA8h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 820B0DA8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B0DC8;  }
		/* 820B0DA8h case    3:*/		return 0x820B0DAC;
		  /* 820B0DACh */ case    4:  		/* addi R11, R27, -4 */
		/* 820B0DACh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFFC);
		/* 820B0DACh case    4:*/		return 0x820B0DB0;
		  /* 820B0DB0h */ case    5:  		/* mr R10, R6 */
		/* 820B0DB0h case    5:*/		regs.R10 = regs.R6;
		/* 820B0DB0h case    5:*/		return 0x820B0DB4;
		  /* 820B0DB4h */ case    6:  		/* cmplwi CR0, R29, 0 */
		/* 820B0DB4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 820B0DB4h case    6:*/		return 0x820B0DB8;
		  /* 820B0DB8h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820B0DB8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820B0DC8;  }
		/* 820B0DB8h case    7:*/		return 0x820B0DBC;
		  /* 820B0DBCh */ case    8:  		/* mtspr CTR, R29 */
		/* 820B0DBCh case    8:*/		regs.CTR = regs.R29;
		/* 820B0DBCh case    8:*/		return 0x820B0DC0;
		  /* 820B0DC0h */ case    9:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B0DC0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B0DC0h case    9:*/		return 0x820B0DC4;
		  /* 820B0DC4h */ case   10:  		/* bc 16, CR0_LT, -4 */
		/* 820B0DC4h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B0DC0;  }
		/* 820B0DC4h case   10:*/		return 0x820B0DC8;
	}
	return 0x820B0DC8;
} // Block from 820B0D9Ch-820B0DC8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B0DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0DC8);
		  /* 820B0DC8h */ case    0:  		/* lwz R28, <#[R1 + 164]> */
		/* 820B0DC8h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B0DC8h case    0:*/		return 0x820B0DCC;
		  /* 820B0DCCh */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 820B0DCCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820B0DCCh case    1:*/		return 0x820B0DD0;
		  /* 820B0DD0h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820B0DD0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B0DEC;  }
		/* 820B0DD0h case    2:*/		return 0x820B0DD4;
		  /* 820B0DD4h */ case    3:  		/* addi R11, R28, -4 */
		/* 820B0DD4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFC);
		/* 820B0DD4h case    3:*/		return 0x820B0DD8;
		  /* 820B0DD8h */ case    4:  		/* cmplwi CR0, R29, 0 */
		/* 820B0DD8h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 820B0DD8h case    4:*/		return 0x820B0DDC;
		  /* 820B0DDCh */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B0DDCh case    5:*/		if ( regs.CR[0].eq ) { return 0x820B0DEC;  }
		/* 820B0DDCh case    5:*/		return 0x820B0DE0;
		  /* 820B0DE0h */ case    6:  		/* mtspr CTR, R29 */
		/* 820B0DE0h case    6:*/		regs.CTR = regs.R29;
		/* 820B0DE0h case    6:*/		return 0x820B0DE4;
		  /* 820B0DE4h */ case    7:  		/* stwu R6, <#[R11 + 4]> */
		/* 820B0DE4h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B0DE4h case    7:*/		return 0x820B0DE8;
		  /* 820B0DE8h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B0DE8h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B0DE4;  }
		/* 820B0DE8h case    8:*/		return 0x820B0DEC;
	}
	return 0x820B0DEC;
} // Block from 820B0DC8h-820B0DECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B0DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0DEC);
		  /* 820B0DECh */ case    0:  		/* rlwinm R30, R21, 0, 25, 25 */
		/* 820B0DECh case    0:*/		cpu::op::rlwinm<0,0,25,25>(regs,&regs.R30,regs.R21);
		/* 820B0DECh case    0:*/		return 0x820B0DF0;
		  /* 820B0DF0h */ case    1:  		/* rlwinm R31, R29, 0, 12, 31 */
		/* 820B0DF0h case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R31,regs.R29);
		/* 820B0DF0h case    1:*/		return 0x820B0DF4;
		  /* 820B0DF4h */ case    2:  		/* mr R9, R30 */
		/* 820B0DF4h case    2:*/		regs.R9 = regs.R30;
		/* 820B0DF4h case    2:*/		return 0x820B0DF8;
		  /* 820B0DF8h */ case    3:  		/* li R8, 0 */
		/* 820B0DF8h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B0DF8h case    3:*/		return 0x820B0DFC;
		  /* 820B0DFCh */ case    4:  		/* mr R7, R26 */
		/* 820B0DFCh case    4:*/		regs.R7 = regs.R26;
		/* 820B0DFCh case    4:*/		return 0x820B0E00;
		  /* 820B0E00h */ case    5:  		/* mr R6, R27 */
		/* 820B0E00h case    5:*/		regs.R6 = regs.R27;
		/* 820B0E00h case    5:*/		return 0x820B0E04;
		  /* 820B0E04h */ case    6:  		/* oris R5, R31, 4112 */
		/* 820B0E04h case    6:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R31,0x1010);
		/* 820B0E04h case    6:*/		return 0x820B0E08;
		  /* 820B0E08h */ case    7:  		/* mr R4, R16 */
		/* 820B0E08h case    7:*/		regs.R4 = regs.R16;
		/* 820B0E08h case    7:*/		return 0x820B0E0C;
		  /* 820B0E0Ch */ case    8:  		/* mr R3, R23 */
		/* 820B0E0Ch case    8:*/		regs.R3 = regs.R23;
		/* 820B0E0Ch case    8:*/		return 0x820B0E10;
		  /* 820B0E10h */ case    9:  		/* bl -776 */
		/* 820B0E10h case    9:*/		regs.LR = 0x820B0E14; return 0x820B0B08;
		/* 820B0E10h case    9:*/		return 0x820B0E14;
		  /* 820B0E14h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820B0E14h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0E14h case   10:*/		return 0x820B0E18;
		  /* 820B0E18h */ case   11:  		/* bc 12, CR0_LT, 92 */
		/* 820B0E18h case   11:*/		if ( regs.CR[0].lt ) { return 0x820B0E74;  }
		/* 820B0E18h case   11:*/		return 0x820B0E1C;
		  /* 820B0E1Ch */ case   12:  		/* mr R9, R30 */
		/* 820B0E1Ch case   12:*/		regs.R9 = regs.R30;
		/* 820B0E1Ch case   12:*/		return 0x820B0E20;
		  /* 820B0E20h */ case   13:  		/* mr R8, R27 */
		/* 820B0E20h case   13:*/		regs.R8 = regs.R27;
		/* 820B0E20h case   13:*/		return 0x820B0E24;
		  /* 820B0E24h */ case   14:  		/* mr R7, R24 */
		/* 820B0E24h case   14:*/		regs.R7 = regs.R24;
		/* 820B0E24h case   14:*/		return 0x820B0E28;
		  /* 820B0E28h */ case   15:  		/* mr R6, R28 */
		/* 820B0E28h case   15:*/		regs.R6 = regs.R28;
		/* 820B0E28h case   15:*/		return 0x820B0E2C;
		  /* 820B0E2Ch */ case   16:  		/* oris R5, R31, 8256 */
		/* 820B0E2Ch case   16:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R31,0x2040);
		/* 820B0E2Ch case   16:*/		return 0x820B0E30;
		  /* 820B0E30h */ case   17:  		/* mr R4, R16 */
		/* 820B0E30h case   17:*/		regs.R4 = regs.R16;
		/* 820B0E30h case   17:*/		return 0x820B0E34;
		  /* 820B0E34h */ case   18:  		/* mr R3, R23 */
		/* 820B0E34h case   18:*/		regs.R3 = regs.R23;
		/* 820B0E34h case   18:*/		return 0x820B0E38;
		  /* 820B0E38h */ case   19:  		/* bl -816 */
		/* 820B0E38h case   19:*/		regs.LR = 0x820B0E3C; return 0x820B0B08;
		/* 820B0E38h case   19:*/		return 0x820B0E3C;
		  /* 820B0E3Ch */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 820B0E3Ch case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0E3Ch case   20:*/		return 0x820B0E40;
	}
	return 0x820B0E40;
} // Block from 820B0DECh-820B0E40h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820B0E40h
// Function 'D3DX_CCompiler_GetToken'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0E40);
		  /* 820B0E40h */ case    0:  		/* bc 12, CR0_LT, 52 */
		/* 820B0E40h case    0:*/		if ( regs.CR[0].lt ) { return 0x820B0E74;  }
		/* 820B0E40h case    0:*/		return 0x820B0E44;
		  /* 820B0E44h */ case    1:  		/* rlwinm R11, R29, 3, 0, 28 */
		/* 820B0E44h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R29);
		/* 820B0E44h case    1:*/		return 0x820B0E48;
	}
	return 0x820B0E48;
} // Block from 820B0E40h-820B0E48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B0E48h
// Function '?CompareSemantic@CCompiler@D3DXShader@@KAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0E48);
		  /* 820B0E48h */ case    0:  		/* mr R9, R21 */
		/* 820B0E48h case    0:*/		regs.R9 = regs.R21;
		/* 820B0E48h case    0:*/		return 0x820B0E4C;
		  /* 820B0E4Ch */ case    1:  		/* add R8, R11, R25 */
		/* 820B0E4Ch case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R25);
		/* 820B0E4Ch case    1:*/		return 0x820B0E50;
		  /* 820B0E50h */ case    2:  		/* mr R7, R28 */
		/* 820B0E50h case    2:*/		regs.R7 = regs.R28;
		/* 820B0E50h case    2:*/		return 0x820B0E54;
		  /* 820B0E54h */ case    3:  		/* mr R6, R19 */
		/* 820B0E54h case    3:*/		regs.R6 = regs.R19;
		/* 820B0E54h case    3:*/		return 0x820B0E58;
		  /* 820B0E58h */ case    4:  		/* oris R5, R31, 12288 */
		/* 820B0E58h case    4:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R31,0x3000);
		/* 820B0E58h case    4:*/		return 0x820B0E5C;
		  /* 820B0E5Ch */ case    5:  		/* mr R4, R16 */
		/* 820B0E5Ch case    5:*/		regs.R4 = regs.R16;
		/* 820B0E5Ch case    5:*/		return 0x820B0E60;
		  /* 820B0E60h */ case    6:  		/* mr R3, R23 */
		/* 820B0E60h case    6:*/		regs.R3 = regs.R23;
		/* 820B0E60h case    6:*/		return 0x820B0E64;
		  /* 820B0E64h */ case    7:  		/* bl -860 */
		/* 820B0E64h case    7:*/		regs.LR = 0x820B0E68; return 0x820B0B08;
		/* 820B0E64h case    7:*/		return 0x820B0E68;
		  /* 820B0E68h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820B0E68h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B0E68h case    8:*/		return 0x820B0E6C;
		  /* 820B0E6Ch */ case    9:  		/* li R31, 0 */
		/* 820B0E6Ch case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B0E6Ch case    9:*/		return 0x820B0E70;
		  /* 820B0E70h */ case   10:  		/* bc 4, CR0_LT, 8 */
		/* 820B0E70h case   10:*/		if ( !regs.CR[0].lt ) { return 0x820B0E78;  }
		/* 820B0E70h case   10:*/		return 0x820B0E74;
	}
	return 0x820B0E74;
} // Block from 820B0E48h-820B0E74h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B0E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0E74);
		  /* 820B0E74h */ case    0:  		/* mr R31, R3 */
		/* 820B0E74h case    0:*/		regs.R31 = regs.R3;
		/* 820B0E74h case    0:*/		return 0x820B0E78;
	}
	return 0x820B0E78;
} // Block from 820B0E74h-820B0E78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0E78);
		  /* 820B0E78h */ case    0:  		/* lis R4, 9345 */
		/* 820B0E78h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B0E78h case    0:*/		return 0x820B0E7C;
		  /* 820B0E7Ch */ case    1:  		/* mr R3, R25 */
		/* 820B0E7Ch case    1:*/		regs.R3 = regs.R25;
		/* 820B0E7Ch case    1:*/		return 0x820B0E80;
		  /* 820B0E80h */ case    2:  		/* bl -166728 */
		/* 820B0E80h case    2:*/		regs.LR = 0x820B0E84; return 0x82088338;
		/* 820B0E80h case    2:*/		return 0x820B0E84;
		  /* 820B0E84h */ case    3:  		/* mr R3, R31 */
		/* 820B0E84h case    3:*/		regs.R3 = regs.R31;
		/* 820B0E84h case    3:*/		return 0x820B0E88;
		  /* 820B0E88h */ case    4:  		/* b 2056 */
		/* 820B0E88h case    4:*/		return 0x820B1690;
		/* 820B0E88h case    4:*/		return 0x820B0E8C;
	}
	return 0x820B0E8C;
} // Block from 820B0E78h-820B0E8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B0E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0E8C);
		  /* 820B0E8Ch */ case    0:  		/* li R6, -1 */
		/* 820B0E8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820B0E8Ch case    0:*/		return 0x820B0E90;
		  /* 820B0E90h */ case    1:  		/* mr R4, R11 */
		/* 820B0E90h case    1:*/		regs.R4 = regs.R11;
		/* 820B0E90h case    1:*/		return 0x820B0E94;
		  /* 820B0E94h */ case    2:  		/* mr R5, R6 */
		/* 820B0E94h case    2:*/		regs.R5 = regs.R6;
		/* 820B0E94h case    2:*/		return 0x820B0E98;
		  /* 820B0E98h */ case    3:  		/* bl 312368 */
		/* 820B0E98h case    3:*/		regs.LR = 0x820B0E9C; return 0x820FD2C8;
		/* 820B0E98h case    3:*/		return 0x820B0E9C;
		  /* 820B0E9Ch */ case    4:  		/* lwz R11, <#[R23 + 8]> */
		/* 820B0E9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 820B0E9Ch case    4:*/		return 0x820B0EA0;
		  /* 820B0EA0h */ case    5:  		/* mr R22, R3 */
		/* 820B0EA0h case    5:*/		regs.R22 = regs.R3;
		/* 820B0EA0h case    5:*/		return 0x820B0EA4;
		  /* 820B0EA4h */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 820B0EA4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820B0EA4h case    6:*/		return 0x820B0EA8;
		  /* 820B0EA8h */ case    7:  		/* cmplw CR6, R3, R10 */
		/* 820B0EA8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820B0EA8h case    7:*/		return 0x820B0EAC;
		  /* 820B0EACh */ case    8:  		/* bc 4, CR6_LT, 20 */
		/* 820B0EACh case    8:*/		if ( !regs.CR[6].lt ) { return 0x820B0EC0;  }
		/* 820B0EACh case    8:*/		return 0x820B0EB0;
		  /* 820B0EB0h */ case    9:  		/* lwz R11, <#[R11 + 24]> */
		/* 820B0EB0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820B0EB0h case    9:*/		return 0x820B0EB4;
		  /* 820B0EB4h */ case   10:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820B0EB4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820B0EB4h case   10:*/		return 0x820B0EB8;
		  /* 820B0EB8h */ case   11:  		/* lwzx R31, <#[R11 + R10]> */
		/* 820B0EB8h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B0EB8h case   11:*/		return 0x820B0EBC;
		  /* 820B0EBCh */ case   12:  		/* b 8 */
		/* 820B0EBCh case   12:*/		return 0x820B0EC4;
		/* 820B0EBCh case   12:*/		return 0x820B0EC0;
	}
	return 0x820B0EC0;
} // Block from 820B0E8Ch-820B0EC0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820B0EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0EC0);
		  /* 820B0EC0h */ case    0:  		/* li R31, 0 */
		/* 820B0EC0h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B0EC0h case    0:*/		return 0x820B0EC4;
	}
	return 0x820B0EC4;
} // Block from 820B0EC0h-820B0EC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0EC4);
		  /* 820B0EC4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820B0EC4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B0EC4h case    0:*/		return 0x820B0EC8;
	}
	return 0x820B0EC8;
} // Block from 820B0EC4h-820B0EC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0EC8h
// Function '??_GC30SWProgramCI@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0EC8);
		  /* 820B0EC8h */ case    0:  		/* bc 12, CR6_EQ, -484 */
		/* 820B0EC8h case    0:*/		if ( regs.CR[6].eq ) { return 0x820B0CE4;  }
		/* 820B0EC8h case    0:*/		return 0x820B0ECC;
		  /* 820B0ECCh */ case    1:  		/* lwz R11, <#[R31 + 12]> */
		/* 820B0ECCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B0ECCh case    1:*/		return 0x820B0ED0;
		  /* 820B0ED0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820B0ED0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B0ED0h case    2:*/		return 0x820B0ED4;
		  /* 820B0ED4h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 820B0ED4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B0EEC;  }
		/* 820B0ED4h case    3:*/		return 0x820B0ED8;
		  /* 820B0ED8h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 820B0ED8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B0ED8h case    4:*/		return 0x820B0EDC;
		  /* 820B0EDCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820B0EDCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B0EDCh case    5:*/		return 0x820B0EE0;
		  /* 820B0EE0h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 820B0EE0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820B0EEC;  }
		/* 820B0EE0h case    6:*/		return 0x820B0EE4;
		  /* 820B0EE4h */ case    7:  		/* stw R11, <#[R31]> */
		/* 820B0EE4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B0EE4h case    7:*/		return 0x820B0EE8;
		  /* 820B0EE8h */ case    8:  		/* b 1956 */
		/* 820B0EE8h case    8:*/		return 0x820B168C;
		/* 820B0EE8h case    8:*/		return 0x820B0EEC;
	}
	return 0x820B0EEC;
} // Block from 820B0EC8h-820B0EECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B0EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0EEC);
		  /* 820B0EECh */ case    0:  		/* li R5, 0 */
		/* 820B0EECh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B0EECh case    0:*/		return 0x820B0EF0;
		  /* 820B0EF0h */ case    1:  		/* li R4, 0 */
		/* 820B0EF0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B0EF0h case    1:*/		return 0x820B0EF4;
		  /* 820B0EF4h */ case    2:  		/* mr R3, R31 */
		/* 820B0EF4h case    2:*/		regs.R3 = regs.R31;
		/* 820B0EF4h case    2:*/		return 0x820B0EF8;
		  /* 820B0EF8h */ case    3:  		/* bl 310136 */
		/* 820B0EF8h case    3:*/		regs.LR = 0x820B0EFC; return 0x820FCA70;
		/* 820B0EF8h case    3:*/		return 0x820B0EFC;
		  /* 820B0EFCh */ case    4:  		/* mr R25, R3 */
		/* 820B0EFCh case    4:*/		regs.R25 = regs.R3;
		/* 820B0EFCh case    4:*/		return 0x820B0F00;
		  /* 820B0F00h */ case    5:  		/* li R5, 0 */
		/* 820B0F00h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B0F00h case    5:*/		return 0x820B0F04;
		  /* 820B0F04h */ case    6:  		/* li R4, 0 */
		/* 820B0F04h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B0F04h case    6:*/		return 0x820B0F08;
		  /* 820B0F08h */ case    7:  		/* mr R3, R31 */
		/* 820B0F08h case    7:*/		regs.R3 = regs.R31;
		/* 820B0F08h case    7:*/		return 0x820B0F0C;
		  /* 820B0F0Ch */ case    8:  		/* bl 307212 */
		/* 820B0F0Ch case    8:*/		regs.LR = 0x820B0F10; return 0x820FBF18;
		/* 820B0F0Ch case    8:*/		return 0x820B0F10;
		  /* 820B0F10h */ case    9:  		/* rlwinm R30, R3, 2, 0, 29 */
		/* 820B0F10h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R3);
		/* 820B0F10h case    9:*/		return 0x820B0F14;
		  /* 820B0F14h */ case   10:  		/* lwz R10, <#[R31 + 4]> */
		/* 820B0F14h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820B0F14h case   10:*/		return 0x820B0F18;
		  /* 820B0F18h */ case   11:  		/* mr R11, R3 */
		/* 820B0F18h case   11:*/		regs.R11 = regs.R3;
		/* 820B0F18h case   11:*/		return 0x820B0F1C;
		  /* 820B0F1Ch */ case   12:  		/* mr R4, R24 */
		/* 820B0F1Ch case   12:*/		regs.R4 = regs.R24;
		/* 820B0F1Ch case   12:*/		return 0x820B0F20;
		  /* 820B0F20h */ case   13:  		/* lwz R3, <#[R31 + 8]> */
		/* 820B0F20h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0F20h case   13:*/		return 0x820B0F24;
		  /* 820B0F24h */ case   14:  		/* mr R5, R30 */
		/* 820B0F24h case   14:*/		regs.R5 = regs.R30;
		/* 820B0F24h case   14:*/		return 0x820B0F28;
	}
	return 0x820B0F28;
} // Block from 820B0EECh-820B0F28h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B0F28h
// Function '??_GC30SWProgramML@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0F28);
		  /* 820B0F28h */ case    0:  		/* subf R29, R11, R10 */
		/* 820B0F28h case    0:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 820B0F28h case    0:*/		return 0x820B0F2C;
		  /* 820B0F2Ch */ case    1:  		/* bl -128380 */
		/* 820B0F2Ch case    1:*/		regs.LR = 0x820B0F30; return 0x820919B0;
		/* 820B0F2Ch case    1:*/		return 0x820B0F30;
		  /* 820B0F30h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B0F30h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0F30h case    2:*/		return 0x820B0F34;
		  /* 820B0F34h */ case    3:  		/* rlwinm R5, R29, 2, 0, 29 */
		/* 820B0F34h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R29);
		/* 820B0F34h case    3:*/		return 0x820B0F38;
		  /* 820B0F38h */ case    4:  		/* mr R4, R26 */
		/* 820B0F38h case    4:*/		regs.R4 = regs.R26;
		/* 820B0F38h case    4:*/		return 0x820B0F3C;
		  /* 820B0F3Ch */ case    5:  		/* add R3, R11, R30 */
		/* 820B0F3Ch case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 820B0F3Ch case    5:*/		return 0x820B0F40;
		  /* 820B0F40h */ case    6:  		/* bl -128400 */
		/* 820B0F40h case    6:*/		regs.LR = 0x820B0F44; return 0x820919B0;
		/* 820B0F40h case    6:*/		return 0x820B0F44;
		  /* 820B0F44h */ case    7:  		/* lwz R11, <#[R31 + 4]> */
		/* 820B0F44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B0F44h case    7:*/		return 0x820B0F48;
		  /* 820B0F48h */ case    8:  		/* li R28, 0 */
		/* 820B0F48h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820B0F48h case    8:*/		return 0x820B0F4C;
		  /* 820B0F4Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820B0F4Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B0F4Ch case    9:*/		return 0x820B0F50;
		  /* 820B0F50h */ case   10:  		/* bc 4, CR6_GT, 252 */
		/* 820B0F50h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820B104C;  }
		/* 820B0F50h case   10:*/		return 0x820B0F54;
		  /* 820B0F54h */ case   11:  		/* li R29, 0 */
		/* 820B0F54h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B0F54h case   11:*/		return 0x820B0F58;
		  /* 820B0F58h */ case   12:  		/* lwz R10, <#[R23 + 8]> */
		/* 820B0F58h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 820B0F58h case   12:*/		return 0x820B0F5C;
		  /* 820B0F5Ch */ case   13:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B0F5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0F5Ch case   13:*/		return 0x820B0F60;
		  /* 820B0F60h */ case   14:  		/* lwz R9, <#[R10 + 8]> */
		/* 820B0F60h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820B0F60h case   14:*/		return 0x820B0F64;
		  /* 820B0F64h */ case   15:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820B0F64h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820B0F64h case   15:*/		return 0x820B0F68;
		  /* 820B0F68h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 820B0F68h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B0F68h case   16:*/		return 0x820B0F6C;
		  /* 820B0F6Ch */ case   17:  		/* bc 4, CR6_LT, 20 */
		/* 820B0F6Ch case   17:*/		if ( !regs.CR[6].lt ) { return 0x820B0F80;  }
		/* 820B0F6Ch case   17:*/		return 0x820B0F70;
		  /* 820B0F70h */ case   18:  		/* lwz R9, <#[R10 + 20]> */
		/* 820B0F70h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 820B0F70h case   18:*/		return 0x820B0F74;
		  /* 820B0F74h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B0F74h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B0F74h case   19:*/		return 0x820B0F78;
		  /* 820B0F78h */ case   20:  		/* lwzx R30, <#[R11 + R9]> */
		/* 820B0F78h case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820B0F78h case   20:*/		return 0x820B0F7C;
		  /* 820B0F7Ch */ case   21:  		/* b 8 */
		/* 820B0F7Ch case   21:*/		return 0x820B0F84;
		/* 820B0F7Ch case   21:*/		return 0x820B0F80;
	}
	return 0x820B0F80;
} // Block from 820B0F28h-820B0F80h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B0F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0F80);
		  /* 820B0F80h */ case    0:  		/* li R30, 0 */
		/* 820B0F80h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B0F80h case    0:*/		return 0x820B0F84;
	}
	return 0x820B0F84;
} // Block from 820B0F80h-820B0F84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0F84);
		  /* 820B0F84h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820B0F84h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B0F84h case    0:*/		return 0x820B0F88;
	}
	return 0x820B0F88;
} // Block from 820B0F84h-820B0F88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B0F88h
// Function '??1CCompiler@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B0F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B0F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B0F88);
		  /* 820B0F88h */ case    0:  		/* bc 12, CR6_EQ, 176 */
		/* 820B0F88h case    0:*/		if ( regs.CR[6].eq ) { return 0x820B1038;  }
		/* 820B0F88h case    0:*/		return 0x820B0F8C;
		  /* 820B0F8Ch */ case    1:  		/* lwz R11, <#[R30 + 4]> */
		/* 820B0F8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820B0F8Ch case    1:*/		return 0x820B0F90;
		  /* 820B0F90h */ case    2:  		/* lwz R10, <#[R10 + 136]> */
		/* 820B0F90h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000088) );
		/* 820B0F90h case    2:*/		return 0x820B0F94;
		  /* 820B0F94h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820B0F94h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B0F94h case    3:*/		return 0x820B0F98;
		  /* 820B0F98h */ case    4:  		/* bc 4, CR6_EQ, 148 */
		/* 820B0F98h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820B102C;  }
		/* 820B0F98h case    4:*/		return 0x820B0F9C;
		  /* 820B0F9Ch */ case    5:  		/* lwz R11, <#[R30]> */
		/* 820B0F9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820B0F9Ch case    5:*/		return 0x820B0FA0;
		  /* 820B0FA0h */ case    6:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 820B0FA0h case    6:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 820B0FA0h case    6:*/		return 0x820B0FA4;
		  /* 820B0FA4h */ case    7:  		/* bc 12, CR0_EQ, 136 */
		/* 820B0FA4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820B102C;  }
		/* 820B0FA4h case    7:*/		return 0x820B0FA8;
		  /* 820B0FA8h */ case    8:  		/* lwz R11, <#[R23 + 104]> */
		/* 820B0FA8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000068) );
		/* 820B0FA8h case    8:*/		return 0x820B0FAC;
		  /* 820B0FACh */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 820B0FACh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820B0FACh case    9:*/		return 0x820B0FB0;
		  /* 820B0FB0h */ case   10:  		/* bc 4, CR6_EQ, 124 */
		/* 820B0FB0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820B102C;  }
		/* 820B0FB0h case   10:*/		return 0x820B0FB4;
		  /* 820B0FB4h */ case   11:  		/* lwz R11, <#[R30 + 92]> */
		/* 820B0FB4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000005C) );
		/* 820B0FB4h case   11:*/		return 0x820B0FB8;
		  /* 820B0FB8h */ case   12:  		/* li R6, 0 */
		/* 820B0FB8h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B0FB8h case   12:*/		return 0x820B0FBC;
		  /* 820B0FBCh */ case   13:  		/* li R5, 0 */
		/* 820B0FBCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B0FBCh case   13:*/		return 0x820B0FC0;
		  /* 820B0FC0h */ case   14:  		/* lfd FR1, <#[R30 + 32]> */
		/* 820B0FC0h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R30 + 0x00000020) );
		/* 820B0FC0h case   14:*/		return 0x820B0FC4;
		  /* 820B0FC4h */ case   15:  		/* addi R11, R11, 1 */
		/* 820B0FC4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B0FC4h case   15:*/		return 0x820B0FC8;
		  /* 820B0FC8h */ case   16:  		/* stw R11, <#[R30 + 92]> */
		/* 820B0FC8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000005C) );
		/* 820B0FC8h case   16:*/		return 0x820B0FCC;
		  /* 820B0FCCh */ case   17:  		/* lwz R3, <#[R23 + 8]> */
		/* 820B0FCCh case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000008) );
		/* 820B0FCCh case   17:*/		return 0x820B0FD0;
		  /* 820B0FD0h */ case   18:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B0FD0h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B0FD0h case   18:*/		return 0x820B0FD4;
		  /* 820B0FD4h */ case   19:  		/* bl 311892 */
		/* 820B0FD4h case   19:*/		regs.LR = 0x820B0FD8; return 0x820FD228;
		/* 820B0FD4h case   19:*/		return 0x820B0FD8;
		  /* 820B0FD8h */ case   20:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B0FD8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0FD8h case   20:*/		return 0x820B0FDC;
		  /* 820B0FDCh */ case   21:  		/* stwx R3, <#[R11 + R29]> */
		/* 820B0FDCh case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820B0FDCh case   21:*/		return 0x820B0FE0;
		  /* 820B0FE0h */ case   22:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B0FE0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B0FE0h case   22:*/		return 0x820B0FE4;
		  /* 820B0FE4h */ case   23:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820B0FE4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820B0FE4h case   23:*/		return 0x820B0FE8;
		  /* 820B0FE8h */ case   24:  		/* cmpwi CR6, R11, -1 */
		/* 820B0FE8h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B0FE8h case   24:*/		return 0x820B0FEC;
		  /* 820B0FECh */ case   25:  		/* bc 12, CR6_EQ, -776 */
		/* 820B0FECh case   25:*/		if ( regs.CR[6].eq ) { return 0x820B0CE4;  }
		/* 820B0FECh case   25:*/		return 0x820B0FF0;
		  /* 820B0FF0h */ case   26:  		/* lwz R10, <#[R23 + 8]> */
		/* 820B0FF0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 820B0FF0h case   26:*/		return 0x820B0FF4;
		  /* 820B0FF4h */ case   27:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B0FF4h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B0FF4h case   27:*/		return 0x820B0FF8;
		  /* 820B0FF8h */ case   28:  		/* mr R4, R30 */
		/* 820B0FF8h case   28:*/		regs.R4 = regs.R30;
		/* 820B0FF8h case   28:*/		return 0x820B0FFC;
		  /* 820B0FFCh */ case   29:  		/* lwz R10, <#[R10 + 20]> */
		/* 820B0FFCh case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820B0FFCh case   29:*/		return 0x820B1000;
	}
	return 0x820B1000;
} // Block from 820B0F88h-820B1000h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820B1000h
// Function '?CheckForNewBackEndExtensions@D3DXShader@@YAHPAUID3DXBuffer@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1000);
		  /* 820B1000h */ case    0:  		/* lwzx R3, <#[R10 + R11]> */
		/* 820B1000h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B1000h case    0:*/		return 0x820B1004;
		  /* 820B1004h */ case    1:  		/* bl 310428 */
		/* 820B1004h case    1:*/		regs.LR = 0x820B1008; return 0x820FCCA0;
		/* 820B1004h case    1:*/		return 0x820B1008;
		  /* 820B1008h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B1008h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B1008h case    2:*/		return 0x820B100C;
		  /* 820B100Ch */ case    3:  		/* lwz R10, <#[R23 + 8]> */
		/* 820B100Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 820B100Ch case    3:*/		return 0x820B1010;
		  /* 820B1010h */ case    4:  		/* lwz R9, <#[R30 + 48]> */
		/* 820B1010h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000030) );
		/* 820B1010h case    4:*/		return 0x820B1014;
		  /* 820B1014h */ case    5:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820B1014h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820B1014h case    5:*/		return 0x820B1018;
		  /* 820B1018h */ case    6:  		/* lwz R10, <#[R10 + 20]> */
		/* 820B1018h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820B1018h case    6:*/		return 0x820B101C;
		  /* 820B101Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B101Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B101Ch case    7:*/		return 0x820B1020;
		  /* 820B1020h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B1020h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B1020h case    8:*/		return 0x820B1024;
		  /* 820B1024h */ case    9:  		/* stw R9, <#[R11 + 48]> */
		/* 820B1024h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 820B1024h case    9:*/		return 0x820B1028;
		  /* 820B1028h */ case   10:  		/* b 16 */
		/* 820B1028h case   10:*/		return 0x820B1038;
		/* 820B1028h case   10:*/		return 0x820B102C;
	}
	return 0x820B102C;
} // Block from 820B1000h-820B102Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B102Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B102C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B102C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B102C);
		  /* 820B102Ch */ case    0:  		/* lwz R11, <#[R30 + 92]> */
		/* 820B102Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000005C) );
		/* 820B102Ch case    0:*/		return 0x820B1030;
		  /* 820B1030h */ case    1:  		/* addi R11, R11, 1 */
		/* 820B1030h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B1030h case    1:*/		return 0x820B1034;
		  /* 820B1034h */ case    2:  		/* stw R11, <#[R30 + 92]> */
		/* 820B1034h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000005C) );
		/* 820B1034h case    2:*/		return 0x820B1038;
	}
	return 0x820B1038;
} // Block from 820B102Ch-820B1038h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B1038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1038);
		  /* 820B1038h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820B1038h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B1038h case    0:*/		return 0x820B103C;
		  /* 820B103Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 820B103Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820B103Ch case    1:*/		return 0x820B1040;
		  /* 820B1040h */ case    2:  		/* addi R29, R29, 4 */
		/* 820B1040h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820B1040h case    2:*/		return 0x820B1044;
		  /* 820B1044h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820B1044h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820B1044h case    3:*/		return 0x820B1048;
		  /* 820B1048h */ case    4:  		/* bc 12, CR6_LT, -240 */
		/* 820B1048h case    4:*/		if ( regs.CR[6].lt ) { return 0x820B0F58;  }
		/* 820B1048h case    4:*/		return 0x820B104C;
	}
	return 0x820B104C;
} // Block from 820B1038h-820B104Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B104Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B104C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B104C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B104C);
		  /* 820B104Ch */ case    0:  		/* li R28, 0 */
		/* 820B104Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820B104Ch case    0:*/		return 0x820B1050;
		  /* 820B1050h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 820B1050h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B1050h case    1:*/		return 0x820B1054;
		  /* 820B1054h */ case    2:  		/* bc 12, CR6_EQ, 400 */
		/* 820B1054h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B11E4;  }
		/* 820B1054h case    2:*/		return 0x820B1058;
		  /* 820B1058h */ case    3:  		/* lis R10, -32256 */
		/* 820B1058h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820B1058h case    3:*/		return 0x820B105C;
		  /* 820B105Ch */ case    4:  		/* lis R11, -32255 */
		/* 820B105Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B105Ch case    4:*/		return 0x820B1060;
		  /* 820B1060h */ case    5:  		/* li R29, 0 */
		/* 820B1060h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B1060h case    5:*/		return 0x820B1064;
		  /* 820B1064h */ case    6:  		/* addi R27, R11, 8152 */
		/* 820B1064h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x1FD8);
		/* 820B1064h case    6:*/		return 0x820B1068;
		  /* 820B1068h */ case    7:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 820B1068h case    7:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 820B1068h case    7:*/		return 0x820B106C;
		  /* 820B106Ch */ case    8:  		/* li R30, 0 */
		/* 820B106Ch case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B106Ch case    8:*/		return 0x820B1070;
		  /* 820B1070h */ case    9:  		/* cmplwi CR6, R19, 0 */
		/* 820B1070h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820B1070h case    9:*/		return 0x820B1074;
		  /* 820B1074h */ case   10:  		/* bc 12, CR6_EQ, 60 */
		/* 820B1074h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B10B0;  }
		/* 820B1074h case   10:*/		return 0x820B1078;
		  /* 820B1078h */ case   11:  		/* lwzx R11, <#[R29 + R19]> */
		/* 820B1078h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R19 + 0x00000000) );
		/* 820B1078h case   11:*/		return 0x820B107C;
		  /* 820B107Ch */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 820B107Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B107Ch case   12:*/		return 0x820B1080;
		  /* 820B1080h */ case   13:  		/* bc 12, CR6_EQ, 48 */
		/* 820B1080h case   13:*/		if ( regs.CR[6].eq ) { return 0x820B10B0;  }
		/* 820B1080h case   13:*/		return 0x820B1084;
		  /* 820B1084h */ case   14:  		/* lwz R10, <#[R23 + 8]> */
		/* 820B1084h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 820B1084h case   14:*/		return 0x820B1088;
		  /* 820B1088h */ case   15:  		/* lwz R9, <#[R10 + 8]> */
		/* 820B1088h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820B1088h case   15:*/		return 0x820B108C;
		  /* 820B108Ch */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 820B108Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B108Ch case   16:*/		return 0x820B1090;
		  /* 820B1090h */ case   17:  		/* bc 4, CR6_LT, 20 */
		/* 820B1090h case   17:*/		if ( !regs.CR[6].lt ) { return 0x820B10A4;  }
		/* 820B1090h case   17:*/		return 0x820B1094;
		  /* 820B1094h */ case   18:  		/* lwz R10, <#[R10 + 20]> */
		/* 820B1094h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820B1094h case   18:*/		return 0x820B1098;
		  /* 820B1098h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B1098h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B1098h case   19:*/		return 0x820B109C;
		  /* 820B109Ch */ case   20:  		/* lwzx R30, <#[R11 + R10]> */
		/* 820B109Ch case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B109Ch case   20:*/		return 0x820B10A0;
		  /* 820B10A0h */ case   21:  		/* b 8 */
		/* 820B10A0h case   21:*/		return 0x820B10A8;
		/* 820B10A0h case   21:*/		return 0x820B10A4;
	}
	return 0x820B10A4;
} // Block from 820B104Ch-820B10A4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B10A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B10A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B10A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B10A4);
		  /* 820B10A4h */ case    0:  		/* li R30, 0 */
		/* 820B10A4h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B10A4h case    0:*/		return 0x820B10A8;
	}
	return 0x820B10A8;
} // Block from 820B10A4h-820B10A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B10A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B10A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B10A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B10A8);
		  /* 820B10A8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820B10A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B10A8h case    0:*/		return 0x820B10AC;
		  /* 820B10ACh */ case    1:  		/* bc 12, CR6_EQ, 760 */
		/* 820B10ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820B13A4;  }
		/* 820B10ACh case    1:*/		return 0x820B10B0;
	}
	return 0x820B10B0;
} // Block from 820B10A8h-820B10B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B10B0h
// Function '?ErrorMessageCallback@CCompiler@D3DXShader@@QAAXHPAVCNode@2@KPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B10B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B10B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B10B0);
		  /* 820B10B0h */ case    0:  		/* lwz R3, <#[R23 + 8]> */
		/* 820B10B0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000008) );
		/* 820B10B0h case    0:*/		return 0x820B10B4;
		  /* 820B10B4h */ case    1:  		/* li R6, 0 */
		/* 820B10B4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B10B4h case    1:*/		return 0x820B10B8;
		  /* 820B10B8h */ case    2:  		/* li R5, 0 */
		/* 820B10B8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B10B8h case    2:*/		return 0x820B10BC;
		  /* 820B10BCh */ case    3:  		/* fmr FR1, FR31 */
		/* 820B10BCh case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820B10BCh case    3:*/		return 0x820B10C0;
		  /* 820B10C0h */ case    4:  		/* lwz R4, <#[R3 + 136]> */
		/* 820B10C0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000088) );
		/* 820B10C0h case    4:*/		return 0x820B10C4;
		  /* 820B10C4h */ case    5:  		/* bl 311652 */
		/* 820B10C4h case    5:*/		regs.LR = 0x820B10C8; return 0x820FD228;
		/* 820B10C4h case    5:*/		return 0x820B10C8;
		  /* 820B10C8h */ case    6:  		/* mr R7, R3 */
		/* 820B10C8h case    6:*/		regs.R7 = regs.R3;
		/* 820B10C8h case    6:*/		return 0x820B10CC;
		  /* 820B10CCh */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 820B10CCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820B10CCh case    7:*/		return 0x820B10D0;
		  /* 820B10D0h */ case    8:  		/* bc 12, CR6_EQ, -1004 */
		/* 820B10D0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820B0CE4;  }
		/* 820B10D0h case    8:*/		return 0x820B10D4;
		  /* 820B10D4h */ case    9:  		/* lwz R11, <#[R23 + 8]> */
		/* 820B10D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 820B10D4h case    9:*/		return 0x820B10D8;
		  /* 820B10D8h */ case   10:  		/* lwz R10, <#[R11 + 8]> */
		/* 820B10D8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B10D8h case   10:*/		return 0x820B10DC;
		  /* 820B10DCh */ case   11:  		/* cmplw CR6, R3, R10 */
		/* 820B10DCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820B10DCh case   11:*/		return 0x820B10E0;
		  /* 820B10E0h */ case   12:  		/* bc 4, CR6_LT, 20 */
		/* 820B10E0h case   12:*/		if ( !regs.CR[6].lt ) { return 0x820B10F4;  }
		/* 820B10E0h case   12:*/		return 0x820B10E4;
		  /* 820B10E4h */ case   13:  		/* lwz R11, <#[R11 + 20]> */
		/* 820B10E4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820B10E4h case   13:*/		return 0x820B10E8;
		  /* 820B10E8h */ case   14:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820B10E8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820B10E8h case   14:*/		return 0x820B10EC;
		  /* 820B10ECh */ case   15:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B10ECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B10ECh case   15:*/		return 0x820B10F0;
		  /* 820B10F0h */ case   16:  		/* b 8 */
		/* 820B10F0h case   16:*/		return 0x820B10F8;
		/* 820B10F0h case   16:*/		return 0x820B10F4;
	}
	return 0x820B10F4;
} // Block from 820B10B0h-820B10F4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B10F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B10F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B10F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B10F4);
		  /* 820B10F4h */ case    0:  		/* li R11, 0 */
		/* 820B10F4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B10F4h case    0:*/		return 0x820B10F8;
	}
	return 0x820B10F8;
} // Block from 820B10F4h-820B10F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B10F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B10F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B10F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B10F8);
		  /* 820B10F8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820B10F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B10F8h case    0:*/		return 0x820B10FC;
		  /* 820B10FCh */ case    1:  		/* bc 12, CR6_EQ, -1048 */
		/* 820B10FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820B0CE4;  }
		/* 820B10FCh case    1:*/		return 0x820B1100;
		  /* 820B1100h */ case    2:  		/* rlwinm. R10, R21, 0, 4, 6 */
		/* 820B1100h case    2:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R21);
		/* 820B1100h case    2:*/		return 0x820B1104;
		  /* 820B1104h */ case    3:  		/* stw R21, <#[R11]> */
		/* 820B1104h case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000000) );
		/* 820B1104h case    3:*/		return 0x820B1108;
		  /* 820B1108h */ case    4:  		/* stw R22, <#[R11 + 72]> */
		/* 820B1108h case    4:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000048) );
		/* 820B1108h case    4:*/		return 0x820B110C;
		  /* 820B110Ch */ case    5:  		/* stw R28, <#[R11 + 16]> */
		/* 820B110Ch case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000010) );
		/* 820B110Ch case    5:*/		return 0x820B1110;
		  /* 820B1110h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 820B1110h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820B1120;  }
		/* 820B1110h case    6:*/		return 0x820B1114;
		  /* 820B1114h */ case    7:  		/* lwz R10, <#[R23 + 100]> */
		/* 820B1114h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000064) );
		/* 820B1114h case    7:*/		return 0x820B1118;
		  /* 820B1118h */ case    8:  		/* or R10, R10, R21 */
		/* 820B1118h case    8:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R21);
		/* 820B1118h case    8:*/		return 0x820B111C;
		  /* 820B111Ch */ case    9:  		/* stw R10, <#[R11]> */
		/* 820B111Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820B111Ch case    9:*/		return 0x820B1120;
	}
	return 0x820B1120;
} // Block from 820B10F8h-820B1120h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B1120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1120);
		  /* 820B1120h */ case    0:  		/* lwz R10, <#[R23 + 48]> */
		/* 820B1120h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000030) );
		/* 820B1120h case    0:*/		return 0x820B1124;
		  /* 820B1124h */ case    1:  		/* cmplwi CR6, R19, 0 */
		/* 820B1124h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820B1124h case    1:*/		return 0x820B1128;
	}
	return 0x820B1128;
} // Block from 820B1120h-820B1128h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B1128h
// Function '?Scratch@CCompiler@D3DXShader@@IAAPAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1128);
		  /* 820B1128h */ case    0:  		/* stw R10, <#[R11 + 20]> */
		/* 820B1128h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820B1128h case    0:*/		return 0x820B112C;
		  /* 820B112Ch */ case    1:  		/* lwz R10, <#[R23 + 52]> */
		/* 820B112Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000034) );
		/* 820B112Ch case    1:*/		return 0x820B1130;
		  /* 820B1130h */ case    2:  		/* stw R10, <#[R11 + 24]> */
		/* 820B1130h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820B1130h case    2:*/		return 0x820B1134;
		  /* 820B1134h */ case    3:  		/* lwz R10, <#[R31 + 16]> */
		/* 820B1134h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1134h case    3:*/		return 0x820B1138;
		  /* 820B1138h */ case    4:  		/* stwx R7, <#[R29 + R10]> */
		/* 820B1138h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 820B1138h case    4:*/		return 0x820B113C;
		  /* 820B113Ch */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 820B113Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820B1144;  }
		/* 820B113Ch case    5:*/		return 0x820B1140;
		  /* 820B1140h */ case    6:  		/* stwx R7, <#[R29 + R19]> */
		/* 820B1140h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R29 + regs.R19 + 0x00000000) );
		/* 820B1140h case    6:*/		return 0x820B1144;
	}
	return 0x820B1144;
} // Block from 820B1128h-820B1144h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B1144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1144);
		  /* 820B1144h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820B1144h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B1144h case    0:*/		return 0x820B1148;
		  /* 820B1148h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820B1148h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B1164;  }
		/* 820B1148h case    1:*/		return 0x820B114C;
		  /* 820B114Ch */ case    2:  		/* lwz R10, <#[R30 + 48]> */
		/* 820B114Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 820B114Ch case    2:*/		return 0x820B1150;
		  /* 820B1150h */ case    3:  		/* stw R10, <#[R11 + 48]> */
		/* 820B1150h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 820B1150h case    3:*/		return 0x820B1154;
		  /* 820B1154h */ case    4:  		/* lwz R10, <#[R30 + 96]> */
		/* 820B1154h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000060) );
		/* 820B1154h case    4:*/		return 0x820B1158;
		  /* 820B1158h */ case    5:  		/* stw R10, <#[R11 + 96]> */
		/* 820B1158h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 820B1158h case    5:*/		return 0x820B115C;
		  /* 820B115Ch */ case    6:  		/* lwz R10, <#[R30 + 100]> */
		/* 820B115Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000064) );
		/* 820B115Ch case    6:*/		return 0x820B1160;
		  /* 820B1160h */ case    7:  		/* stw R10, <#[R11 + 100]> */
		/* 820B1160h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000064) );
		/* 820B1160h case    7:*/		return 0x820B1164;
	}
	return 0x820B1164;
} // Block from 820B1144h-820B1164h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B1164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1164);
		  /* 820B1164h */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 820B1164h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 820B1164h case    0:*/		return 0x820B1168;
		  /* 820B1168h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 820B1168h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B1168h case    1:*/		return 0x820B116C;
		  /* 820B116Ch */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 820B116Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820B11A4;  }
		/* 820B116Ch case    2:*/		return 0x820B1170;
		  /* 820B1170h */ case    3:  		/* lwz R9, <#[R31 + 16]> */
		/* 820B1170h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1170h case    3:*/		return 0x820B1174;
		  /* 820B1174h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B1174h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B1174h case    4:*/		return 0x820B1178;
		  /* 820B1178h */ case    5:  		/* lwz R8, <#[R23 + 24]> */
		/* 820B1178h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000018) );
		/* 820B1178h case    5:*/		return 0x820B117C;
		  /* 820B117Ch */ case    6:  		/* lwzx R9, <#[R29 + R9]> */
		/* 820B117Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 820B117Ch case    6:*/		return 0x820B1180;
		  /* 820B1180h */ case    7:  		/* stwx R9, <#[R10 + R8]> */
		/* 820B1180h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820B1180h case    7:*/		return 0x820B1184;
		  /* 820B1184h */ case    8:  		/* lwz R11, <#[R11 + 96]> */
		/* 820B1184h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 820B1184h case    8:*/		return 0x820B1188;
		  /* 820B1188h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820B1188h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B1188h case    9:*/		return 0x820B118C;
		  /* 820B118Ch */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 820B118Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x820B11A4;  }
		/* 820B118Ch case   10:*/		return 0x820B1190;
		  /* 820B1190h */ case   11:  		/* mr R6, R27 */
		/* 820B1190h case   11:*/		regs.R6 = regs.R27;
		/* 820B1190h case   11:*/		return 0x820B1194;
		  /* 820B1194h */ case   12:  		/* li R5, 0 */
		/* 820B1194h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1194h case   12:*/		return 0x820B1198;
		  /* 820B1198h */ case   13:  		/* li R4, 0 */
		/* 820B1198h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B1198h case   13:*/		return 0x820B119C;
		  /* 820B119Ch */ case   14:  		/* mr R3, R23 */
		/* 820B119Ch case   14:*/		regs.R3 = regs.R23;
		/* 820B119Ch case   14:*/		return 0x820B11A0;
	}
	return 0x820B11A0;
} // Block from 820B1164h-820B11A0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B11A0h
// Function '?StackAlloc@CCompiler@D3DXShader@@IAAPAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B11A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B11A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B11A0);
		  /* 820B11A0h */ case    0:  		/* bl -1968 */
		/* 820B11A0h case    0:*/		regs.LR = 0x820B11A4; return 0x820B09F0;
		/* 820B11A0h case    0:*/		return 0x820B11A4;
	}
	return 0x820B11A4;
} // Block from 820B11A0h-820B11A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B11A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B11A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B11A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B11A4);
		  /* 820B11A4h */ case    0:  		/* addi R28, R28, 1 */
		/* 820B11A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820B11A4h case    0:*/		return 0x820B11A8;
		  /* 820B11A8h */ case    1:  		/* addi R29, R29, 4 */
		/* 820B11A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820B11A8h case    1:*/		return 0x820B11AC;
		  /* 820B11ACh */ case    2:  		/* cmplw CR6, R28, R25 */
		/* 820B11ACh case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R25);
		/* 820B11ACh case    2:*/		return 0x820B11B0;
		  /* 820B11B0h */ case    3:  		/* bc 12, CR6_LT, -324 */
		/* 820B11B0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820B106C;  }
		/* 820B11B0h case    3:*/		return 0x820B11B4;
		  /* 820B11B4h */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 820B11B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B11B4h case    4:*/		return 0x820B11B8;
		  /* 820B11B8h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 820B11B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820B11E4;  }
		/* 820B11B8h case    5:*/		return 0x820B11BC;
		  /* 820B11BCh */ case    6:  		/* li R29, 0 */
		/* 820B11BCh case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B11BCh case    6:*/		return 0x820B11C0;
		  /* 820B11C0h */ case    7:  		/* mr R30, R25 */
		/* 820B11C0h case    7:*/		regs.R30 = regs.R25;
		/* 820B11C0h case    7:*/		return 0x820B11C4;
		  /* 820B11C4h */ case    8:  		/* lwz R11, <#[R31 + 16]> */
		/* 820B11C4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820B11C4h case    8:*/		return 0x820B11C8;
		  /* 820B11C8h */ case    9:  		/* li R5, 0 */
		/* 820B11C8h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B11C8h case    9:*/		return 0x820B11CC;
		  /* 820B11CCh */ case   10:  		/* mr R3, R23 */
		/* 820B11CCh case   10:*/		regs.R3 = regs.R23;
		/* 820B11CCh case   10:*/		return 0x820B11D0;
		  /* 820B11D0h */ case   11:  		/* lwzx R4, <#[R29 + R11]> */
		/* 820B11D0h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820B11D0h case   11:*/		return 0x820B11D4;
		  /* 820B11D4h */ case   12:  		/* bl -9140 */
		/* 820B11D4h case   12:*/		regs.LR = 0x820B11D8; return 0x820AEE20;
		/* 820B11D4h case   12:*/		return 0x820B11D8;
		  /* 820B11D8h */ case   13:  		/* addic. R30, R30, -1 */
		/* 820B11D8h case   13:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 820B11D8h case   13:*/		return 0x820B11DC;
		  /* 820B11DCh */ case   14:  		/* addi R29, R29, 4 */
		/* 820B11DCh case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820B11DCh case   14:*/		return 0x820B11E0;
		  /* 820B11E0h */ case   15:  		/* bc 4, CR0_EQ, -28 */
		/* 820B11E0h case   15:*/		if ( !regs.CR[0].eq ) { return 0x820B11C4;  }
		/* 820B11E0h case   15:*/		return 0x820B11E4;
	}
	return 0x820B11E4;
} // Block from 820B11A4h-820B11E4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B11E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B11E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B11E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B11E4);
		  /* 820B11E4h */ case    0:  		/* lwz R11, <#[R23 + 20]> */
		/* 820B11E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 820B11E4h case    0:*/		return 0x820B11E8;
		  /* 820B11E8h */ case    1:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 820B11E8h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 820B11E8h case    1:*/		return 0x820B11EC;
		  /* 820B11ECh */ case    2:  		/* bc 4, CR0_EQ, 240 */
		/* 820B11ECh case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B12DC;  }
		/* 820B11ECh case    2:*/		return 0x820B11F0;
		  /* 820B11F0h */ case    3:  		/* mr R3, R31 */
		/* 820B11F0h case    3:*/		regs.R3 = regs.R31;
		/* 820B11F0h case    3:*/		return 0x820B11F4;
		  /* 820B11F4h */ case    4:  		/* bl 307380 */
		/* 820B11F4h case    4:*/		regs.LR = 0x820B11F8; return 0x820FC2A8;
		/* 820B11F4h case    4:*/		return 0x820B11F8;
		  /* 820B11F8h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820B11F8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B11F8h case    5:*/		return 0x820B11FC;
		  /* 820B11FCh */ case    6:  		/* bc 4, CR0_EQ, 224 */
		/* 820B11FCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x820B12DC;  }
		/* 820B11FCh case    6:*/		return 0x820B1200;
		  /* 820B1200h */ case    7:  		/* li R29, 0 */
		/* 820B1200h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B1200h case    7:*/		return 0x820B1204;
		  /* 820B1204h */ case    8:  		/* cmplwi CR6, R25, 0 */
		/* 820B1204h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B1204h case    8:*/		return 0x820B1208;
		  /* 820B1208h */ case    9:  		/* bc 12, CR6_EQ, 80 */
		/* 820B1208h case    9:*/		if ( regs.CR[6].eq ) { return 0x820B1258;  }
		/* 820B1208h case    9:*/		return 0x820B120C;
		  /* 820B120Ch */ case   10:  		/* li R30, 0 */
		/* 820B120Ch case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B120Ch case   10:*/		return 0x820B1210;
		  /* 820B1210h */ case   11:  		/* lwz R11, <#[R31 + 16]> */
		/* 820B1210h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1210h case   11:*/		return 0x820B1214;
		  /* 820B1214h */ case   12:  		/* lwz R10, <#[R23 + 8]> */
		/* 820B1214h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 820B1214h case   12:*/		return 0x820B1218;
		  /* 820B1218h */ case   13:  		/* lwzx R4, <#[R30 + R11]> */
		/* 820B1218h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820B1218h case   13:*/		return 0x820B121C;
		  /* 820B121Ch */ case   14:  		/* lwz R11, <#[R10 + 20]> */
		/* 820B121Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 820B121Ch case   14:*/		return 0x820B1220;
		  /* 820B1220h */ case   15:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820B1220h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820B1220h case   15:*/		return 0x820B1224;
		  /* 820B1224h */ case   16:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B1224h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B1224h case   16:*/		return 0x820B1228;
		  /* 820B1228h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 820B1228h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820B1228h case   17:*/		return 0x820B122C;
		  /* 820B122Ch */ case   18:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820B122Ch case   18:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820B122Ch case   18:*/		return 0x820B1230;
		  /* 820B1230h */ case   19:  		/* bc 4, CR0_EQ, 40 */
		/* 820B1230h case   19:*/		if ( !regs.CR[0].eq ) { return 0x820B1258;  }
		/* 820B1230h case   19:*/		return 0x820B1234;
		  /* 820B1234h */ case   20:  		/* addi R5, R1, 160 */
		/* 820B1234h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xA0);
		/* 820B1234h case   20:*/		return 0x820B1238;
		  /* 820B1238h */ case   21:  		/* mr R3, R23 */
		/* 820B1238h case   21:*/		regs.R3 = regs.R23;
		/* 820B1238h case   21:*/		return 0x820B123C;
		  /* 820B123Ch */ case   22:  		/* bl -2612 */
		/* 820B123Ch case   22:*/		regs.LR = 0x820B1240; return 0x820B0808;
		/* 820B123Ch case   22:*/		return 0x820B1240;
	}
	return 0x820B1240;
} // Block from 820B11E4h-820B1240h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820B1240h
// Function '?EvalValue@CCompiler@D3DXShader@@IAAJIPAN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1240);
		  /* 820B1240h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820B1240h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B1240h case    0:*/		return 0x820B1244;
		  /* 820B1244h */ case    1:  		/* bc 12, CR0_LT, 20 */
		/* 820B1244h case    1:*/		if ( regs.CR[0].lt ) { return 0x820B1258;  }
		/* 820B1244h case    1:*/		return 0x820B1248;
		  /* 820B1248h */ case    2:  		/* addi R29, R29, 1 */
		/* 820B1248h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820B1248h case    2:*/		return 0x820B124C;
		  /* 820B124Ch */ case    3:  		/* addi R30, R30, 4 */
		/* 820B124Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820B124Ch case    3:*/		return 0x820B1250;
		  /* 820B1250h */ case    4:  		/* cmplw CR6, R29, R25 */
		/* 820B1250h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 820B1250h case    4:*/		return 0x820B1254;
		  /* 820B1254h */ case    5:  		/* bc 12, CR6_LT, -68 */
		/* 820B1254h case    5:*/		if ( regs.CR[6].lt ) { return 0x820B1210;  }
		/* 820B1254h case    5:*/		return 0x820B1258;
	}
	return 0x820B1258;
} // Block from 820B1240h-820B1258h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B1258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1258);
		  /* 820B1258h */ case    0:  		/* cmplw CR6, R29, R25 */
		/* 820B1258h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 820B1258h case    0:*/		return 0x820B125C;
		  /* 820B125Ch */ case    1:  		/* bc 4, CR6_EQ, 128 */
		/* 820B125Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B12DC;  }
		/* 820B125Ch case    1:*/		return 0x820B1260;
		  /* 820B1260h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 820B1260h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B1260h case    2:*/		return 0x820B1264;
		  /* 820B1264h */ case    3:  		/* mr R10, R25 */
		/* 820B1264h case    3:*/		regs.R10 = regs.R25;
		/* 820B1264h case    3:*/		return 0x820B1268;
		  /* 820B1268h */ case    4:  		/* li R9, 1 */
		/* 820B1268h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820B1268h case    4:*/		return 0x820B126C;
		  /* 820B126Ch */ case    5:  		/* li R29, 0 */
		/* 820B126Ch case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B126Ch case    5:*/		return 0x820B1270;
		  /* 820B1270h */ case    6:  		/* rlwimi R10, R9, 28, 0, 11 */
		/* 820B1270h case    6:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R10,regs.R9);
		/* 820B1270h case    6:*/		return 0x820B1274;
		  /* 820B1274h */ case    7:  		/* cmplwi CR6, R25, 0 */
		/* 820B1274h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B1274h case    7:*/		return 0x820B1278;
		  /* 820B1278h */ case    8:  		/* stw R11, <#[R31 + 4]> */
		/* 820B1278h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B1278h case    8:*/		return 0x820B127C;
		  /* 820B127Ch */ case    9:  		/* stw R10, <#[R31]> */
		/* 820B127Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820B127Ch case    9:*/		return 0x820B1280;
		  /* 820B1280h */ case   10:  		/* bc 12, CR6_EQ, 92 */
		/* 820B1280h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B12DC;  }
		/* 820B1280h case   10:*/		return 0x820B1284;
		  /* 820B1284h */ case   11:  		/* li R30, 0 */
		/* 820B1284h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B1284h case   11:*/		return 0x820B1288;
		  /* 820B1288h */ case   12:  		/* lwz R11, <#[R31 + 16]> */
		/* 820B1288h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1288h case   12:*/		return 0x820B128C;
		  /* 820B128Ch */ case   13:  		/* li R6, 0 */
		/* 820B128Ch case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B128Ch case   13:*/		return 0x820B1290;
		  /* 820B1290h */ case   14:  		/* lwz R3, <#[R23 + 8]> */
		/* 820B1290h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000008) );
		/* 820B1290h case   14:*/		return 0x820B1294;
		  /* 820B1294h */ case   15:  		/* li R5, 0 */
		/* 820B1294h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1294h case   15:*/		return 0x820B1298;
		  /* 820B1298h */ case   16:  		/* lwzx R11, <#[R30 + R11]> */
		/* 820B1298h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820B1298h case   16:*/		return 0x820B129C;
		  /* 820B129Ch */ case   17:  		/* lwz R10, <#[R3 + 20]> */
		/* 820B129Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820B129Ch case   17:*/		return 0x820B12A0;
		  /* 820B12A0h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B12A0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B12A0h case   18:*/		return 0x820B12A4;
		  /* 820B12A4h */ case   19:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B12A4h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B12A4h case   19:*/		return 0x820B12A8;
		  /* 820B12A8h */ case   20:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B12A8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B12A8h case   20:*/		return 0x820B12AC;
		  /* 820B12ACh */ case   21:  		/* lfd FR1, <#[R11 + 32]> */
		/* 820B12ACh case   21:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000020) );
		/* 820B12ACh case   21:*/		return 0x820B12B0;
		  /* 820B12B0h */ case   22:  		/* bl 311160 */
		/* 820B12B0h case   22:*/		regs.LR = 0x820B12B4; return 0x820FD228;
		/* 820B12B0h case   22:*/		return 0x820B12B4;
		  /* 820B12B4h */ case   23:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B12B4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B12B4h case   23:*/		return 0x820B12B8;
		  /* 820B12B8h */ case   24:  		/* stwx R3, <#[R11 + R30]> */
		/* 820B12B8h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820B12B8h case   24:*/		return 0x820B12BC;
		  /* 820B12BCh */ case   25:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B12BCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B12BCh case   25:*/		return 0x820B12C0;
		  /* 820B12C0h */ case   26:  		/* lwzx R11, <#[R11 + R30]> */
		/* 820B12C0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820B12C0h case   26:*/		return 0x820B12C4;
		  /* 820B12C4h */ case   27:  		/* cmpwi CR6, R11, -1 */
		/* 820B12C4h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B12C4h case   27:*/		return 0x820B12C8;
		  /* 820B12C8h */ case   28:  		/* bc 12, CR6_EQ, -1508 */
		/* 820B12C8h case   28:*/		if ( regs.CR[6].eq ) { return 0x820B0CE4;  }
		/* 820B12C8h case   28:*/		return 0x820B12CC;
		  /* 820B12CCh */ case   29:  		/* addi R29, R29, 1 */
		/* 820B12CCh case   29:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820B12CCh case   29:*/		return 0x820B12D0;
		  /* 820B12D0h */ case   30:  		/* addi R30, R30, 4 */
		/* 820B12D0h case   30:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820B12D0h case   30:*/		return 0x820B12D4;
		  /* 820B12D4h */ case   31:  		/* cmplw CR6, R29, R25 */
		/* 820B12D4h case   31:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 820B12D4h case   31:*/		return 0x820B12D8;
		  /* 820B12D8h */ case   32:  		/* bc 12, CR6_LT, -80 */
		/* 820B12D8h case   32:*/		if ( regs.CR[6].lt ) { return 0x820B1288;  }
		/* 820B12D8h case   32:*/		return 0x820B12DC;
	}
	return 0x820B12DC;
} // Block from 820B1258h-820B12DCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 820B12DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B12DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B12DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B12DC);
		  /* 820B12DCh */ case    0:  		/* lwz R10, <#[R31]> */
		/* 820B12DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820B12DCh case    0:*/		return 0x820B12E0;
		  /* 820B12E0h */ case    1:  		/* rlwinm R11, R10, 0, 0, 11 */
		/* 820B12E0h case    1:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R10);
		/* 820B12E0h case    1:*/		return 0x820B12E4;
		  /* 820B12E4h */ case    2:  		/* cmplw CR6, R11, R20 */
		/* 820B12E4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 820B12E4h case    2:*/		return 0x820B12E8;
		  /* 820B12E8h */ case    3:  		/* bc 12, CR6_GT, 416 */
		/* 820B12E8h case    3:*/		if ( regs.CR[6].gt ) { return 0x820B1488;  }
		/* 820B12E8h case    3:*/		return 0x820B12EC;
		  /* 820B12ECh */ case    4:  		/* bc 12, CR6_EQ, 768 */
		/* 820B12ECh case    4:*/		if ( regs.CR[6].eq ) { return 0x820B15EC;  }
		/* 820B12ECh case    4:*/		return 0x820B12F0;
		  /* 820B12F0h */ case    5:  		/* lis R10, 4096 */
		/* 820B12F0h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 820B12F0h case    5:*/		return 0x820B12F4;
		  /* 820B12F4h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820B12F4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B12F4h case    6:*/		return 0x820B12F8;
		  /* 820B12F8h */ case    7:  		/* bc 12, CR6_EQ, 296 */
		/* 820B12F8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820B1420;  }
		/* 820B12F8h case    7:*/		return 0x820B12FC;
		  /* 820B12FCh */ case    8:  		/* lis R10, 4112 */
		/* 820B12FCh case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x1010);
		/* 820B12FCh case    8:*/		return 0x820B1300;
		  /* 820B1300h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820B1300h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B1300h case    9:*/		return 0x820B1304;
		  /* 820B1304h */ case   10:  		/* bc 12, CR6_EQ, 196 */
		/* 820B1304h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B13C8;  }
		/* 820B1304h case   10:*/		return 0x820B1308;
	}
	return 0x820B1308;
} // Block from 820B12DCh-820B1308h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B1308h
// Function '?Reset@CCompiler@D3DXShader@@IAAJIIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1308);
		  /* 820B1308h */ case    0:  		/* cmplw CR6, R11, R18 */
		/* 820B1308h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 820B1308h case    0:*/		return 0x820B130C;
		  /* 820B130Ch */ case    1:  		/* bc 12, CR6_EQ, 736 */
		/* 820B130Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820B15EC;  }
		/* 820B130Ch case    1:*/		return 0x820B1310;
		  /* 820B1310h */ case    2:  		/* cmplw CR6, R11, R17 */
		/* 820B1310h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 820B1310h case    2:*/		return 0x820B1314;
		  /* 820B1314h */ case    3:  		/* bc 12, CR6_EQ, 728 */
		/* 820B1314h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B15EC;  }
		/* 820B1314h case    3:*/		return 0x820B1318;
		  /* 820B1318h */ case    4:  		/* lis R10, 8256 */
		/* 820B1318h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820B1318h case    4:*/		return 0x820B131C;
		  /* 820B131Ch */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820B131Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B131Ch case    5:*/		return 0x820B1320;
		  /* 820B1320h */ case    6:  		/* bc 4, CR6_EQ, 864 */
		/* 820B1320h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B1320h case    6:*/		return 0x820B1324;
		  /* 820B1324h */ case    7:  		/* li R10, 0 */
		/* 820B1324h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B1324h case    7:*/		return 0x820B1328;
		  /* 820B1328h */ case    8:  		/* cmplwi CR6, R25, 0 */
		/* 820B1328h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B1328h case    8:*/		return 0x820B132C;
		  /* 820B132Ch */ case    9:  		/* bc 12, CR6_EQ, 852 */
		/* 820B132Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B132Ch case    9:*/		return 0x820B1330;
		  /* 820B1330h */ case   10:  		/* mtspr CTR, R25 */
		/* 820B1330h case   10:*/		regs.CTR = regs.R25;
		/* 820B1330h case   10:*/		return 0x820B1334;
		  /* 820B1334h */ case   11:  		/* li R11, 0 */
		/* 820B1334h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B1334h case   11:*/		return 0x820B1338;
		  /* 820B1338h */ case   12:  		/* lwz R9, <#[R31 + 12]> */
		/* 820B1338h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B1338h case   12:*/		return 0x820B133C;
		  /* 820B133Ch */ case   13:  		/* lwz R8, <#[R31 + 8]> */
		/* 820B133Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820B133Ch case   13:*/		return 0x820B1340;
		  /* 820B1340h */ case   14:  		/* add R9, R10, R9 */
		/* 820B1340h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820B1340h case   14:*/		return 0x820B1344;
		  /* 820B1344h */ case   15:  		/* lwz R7, <#[R23 + 8]> */
		/* 820B1344h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000008) );
		/* 820B1344h case   15:*/		return 0x820B1348;
		  /* 820B1348h */ case   16:  		/* lwz R6, <#[R31 + 16]> */
		/* 820B1348h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1348h case   16:*/		return 0x820B134C;
		  /* 820B134Ch */ case   17:  		/* addi R10, R10, 1 */
		/* 820B134Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B134Ch case   17:*/		return 0x820B1350;
		  /* 820B1350h */ case   18:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B1350h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B1350h case   18:*/		return 0x820B1354;
		  /* 820B1354h */ case   19:  		/* lwzx R5, <#[R11 + R8]> */
		/* 820B1354h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820B1354h case   19:*/		return 0x820B1358;
		  /* 820B1358h */ case   20:  		/* lwz R7, <#[R7 + 20]> */
		/* 820B1358h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 820B1358h case   20:*/		return 0x820B135C;
		  /* 820B135Ch */ case   21:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820B135Ch case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820B135Ch case   21:*/		return 0x820B1360;
		  /* 820B1360h */ case   22:  		/* lwzx R6, <#[R11 + R6]> */
		/* 820B1360h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820B1360h case   22:*/		return 0x820B1364;
		  /* 820B1364h */ case   23:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820B1364h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820B1364h case   23:*/		return 0x820B1368;
		  /* 820B1368h */ case   24:  		/* addi R11, R11, 4 */
		/* 820B1368h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B1368h case   24:*/		return 0x820B136C;
		  /* 820B136Ch */ case   25:  		/* rlwinm R8, R6, 2, 0, 29 */
		/* 820B136Ch case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R6);
		/* 820B136Ch case   25:*/		return 0x820B1370;
		  /* 820B1370h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B1370h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B1370h case   26:*/		return 0x820B1374;
		  /* 820B1374h */ case   27:  		/* lwzx R6, <#[R5 + R7]> */
		/* 820B1374h case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 820B1374h case   27:*/		return 0x820B1378;
		  /* 820B1378h */ case   28:  		/* lwzx R8, <#[R8 + R7]> */
		/* 820B1378h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820B1378h case   28:*/		return 0x820B137C;
		  /* 820B137Ch */ case   29:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820B137Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820B137Ch case   29:*/		return 0x820B1380;
		  /* 820B1380h */ case   30:  		/* lwz R7, <#[R6]> */
		/* 820B1380h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 820B1380h case   30:*/		return 0x820B1384;
		  /* 820B1384h */ case   31:  		/* lwz R6, <#[R8]> */
		/* 820B1384h case   31:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 820B1384h case   31:*/		return 0x820B1388;
		  /* 820B1388h */ case   32:  		/* lwz R9, <#[R9]> */
		/* 820B1388h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820B1388h case   32:*/		return 0x820B138C;
		  /* 820B138Ch */ case   33:  		/* and R9, R9, R7 */
		/* 820B138Ch case   33:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820B138Ch case   33:*/		return 0x820B1390;
		  /* 820B1390h */ case   34:  		/* rlwinm R9, R9, 0, 30, 30 */
		/* 820B1390h case   34:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R9,regs.R9);
		/* 820B1390h case   34:*/		return 0x820B1394;
		  /* 820B1394h */ case   35:  		/* or R9, R9, R6 */
		/* 820B1394h case   35:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 820B1394h case   35:*/		return 0x820B1398;
		  /* 820B1398h */ case   36:  		/* stw R9, <#[R8]> */
		/* 820B1398h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 820B1398h case   36:*/		return 0x820B139C;
		  /* 820B139Ch */ case   37:  		/* bc 16, CR0_LT, -100 */
		/* 820B139Ch case   37:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B1338;  }
		/* 820B139Ch case   37:*/		return 0x820B13A0;
		  /* 820B13A0h */ case   38:  		/* b 736 */
		/* 820B13A0h case   38:*/		return 0x820B1680;
		/* 820B13A0h case   38:*/		return 0x820B13A4;
	}
	return 0x820B13A4;
} // Block from 820B1308h-820B13A4h (39 instructions)

//////////////////////////////////////////////////////
// Block at 820B13A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B13A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B13A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B13A4);
		  /* 820B13A4h */ case    0:  		/* lis R11, -32255 */
		/* 820B13A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B13A4h case    0:*/		return 0x820B13A8;
		  /* 820B13A8h */ case    1:  		/* li R5, 0 */
		/* 820B13A8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B13A8h case    1:*/		return 0x820B13AC;
		  /* 820B13ACh */ case    2:  		/* addi R6, R11, 8112 */
		/* 820B13ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1FB0);
		/* 820B13ACh case    2:*/		return 0x820B13B0;
		  /* 820B13B0h */ case    3:  		/* li R4, 0 */
		/* 820B13B0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B13B0h case    3:*/		return 0x820B13B4;
		  /* 820B13B4h */ case    4:  		/* mr R3, R23 */
		/* 820B13B4h case    4:*/		regs.R3 = regs.R23;
		/* 820B13B4h case    4:*/		return 0x820B13B8;
		  /* 820B13B8h */ case    5:  		/* bl -2504 */
		/* 820B13B8h case    5:*/		regs.LR = 0x820B13BC; return 0x820B09F0;
		/* 820B13B8h case    5:*/		return 0x820B13BC;
		  /* 820B13BCh */ case    6:  		/* lis R3, -32768 */
		/* 820B13BCh case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820B13BCh case    6:*/		return 0x820B13C0;
		  /* 820B13C0h */ case    7:  		/* ori R3, R3, 16389 */
		/* 820B13C0h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820B13C0h case    7:*/		return 0x820B13C4;
		  /* 820B13C4h */ case    8:  		/* b 716 */
		/* 820B13C4h case    8:*/		return 0x820B1690;
		/* 820B13C4h case    8:*/		return 0x820B13C8;
	}
	return 0x820B13C8;
} // Block from 820B13A4h-820B13C8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B13C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B13C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B13C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B13C8);
		  /* 820B13C8h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820B13C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B13C8h case    0:*/		return 0x820B13CC;
		  /* 820B13CCh */ case    1:  		/* bc 12, CR6_EQ, 692 */
		/* 820B13CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B13CCh case    1:*/		return 0x820B13D0;
		  /* 820B13D0h */ case    2:  		/* mtspr CTR, R25 */
		/* 820B13D0h case    2:*/		regs.CTR = regs.R25;
		/* 820B13D0h case    2:*/		return 0x820B13D4;
		  /* 820B13D4h */ case    3:  		/* li R11, 0 */
		/* 820B13D4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B13D4h case    3:*/		return 0x820B13D8;
		  /* 820B13D8h */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 820B13D8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820B13D8h case    4:*/		return 0x820B13DC;
		  /* 820B13DCh */ case    5:  		/* lwz R9, <#[R23 + 8]> */
		/* 820B13DCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000008) );
		/* 820B13DCh case    5:*/		return 0x820B13E0;
		  /* 820B13E0h */ case    6:  		/* lwz R8, <#[R31 + 16]> */
		/* 820B13E0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 820B13E0h case    6:*/		return 0x820B13E4;
		  /* 820B13E4h */ case    7:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820B13E4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B13E4h case    7:*/		return 0x820B13E8;
		  /* 820B13E8h */ case    8:  		/* lwz R9, <#[R9 + 20]> */
		/* 820B13E8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 820B13E8h case    8:*/		return 0x820B13EC;
		  /* 820B13ECh */ case    9:  		/* lwzx R8, <#[R11 + R8]> */
		/* 820B13ECh case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820B13ECh case    9:*/		return 0x820B13F0;
		  /* 820B13F0h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B13F0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B13F0h case   10:*/		return 0x820B13F4;
		  /* 820B13F4h */ case   11:  		/* addi R11, R11, 4 */
		/* 820B13F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B13F4h case   11:*/		return 0x820B13F8;
		  /* 820B13F8h */ case   12:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B13F8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B13F8h case   12:*/		return 0x820B13FC;
		  /* 820B13FCh */ case   13:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820B13FCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820B13FCh case   13:*/		return 0x820B1400;
		  /* 820B1400h */ case   14:  		/* lwzx R9, <#[R8 + R9]> */
		/* 820B1400h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820B1400h case   14:*/		return 0x820B1404;
		  /* 820B1404h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 820B1404h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820B1404h case   15:*/		return 0x820B1408;
		  /* 820B1408h */ case   16:  		/* lwz R8, <#[R9]> */
		/* 820B1408h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820B1408h case   16:*/		return 0x820B140C;
		  /* 820B140Ch */ case   17:  		/* rlwinm R10, R10, 0, 30, 30 */
		/* 820B140Ch case   17:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820B140Ch case   17:*/		return 0x820B1410;
	}
	return 0x820B1410;
} // Block from 820B13C8h-820B1410h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820B1410h
// Function '?StaticCompilerErrorMessageCallback@D3DXShader@@YAXPAXHKPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1410);
		  /* 820B1410h */ case    0:  		/* or R10, R10, R8 */
		/* 820B1410h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820B1410h case    0:*/		return 0x820B1414;
		  /* 820B1414h */ case    1:  		/* stw R10, <#[R9]> */
		/* 820B1414h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820B1414h case    1:*/		return 0x820B1418;
		  /* 820B1418h */ case    2:  		/* bc 16, CR0_LT, -64 */
		/* 820B1418h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B13D8;  }
		/* 820B1418h case    2:*/		return 0x820B141C;
		  /* 820B141Ch */ case    3:  		/* b 612 */
		/* 820B141Ch case    3:*/		return 0x820B1680;
		/* 820B141Ch case    3:*/		return 0x820B1420;
	}
	return 0x820B1420;
} // Block from 820B1410h-820B1420h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B1420h
// Function '?StaticCompilerErrorMessageCallbackWithNode@D3DXShader@@YAXPAXHPAVCNode@1@KPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1420);
		  /* 820B1420h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820B1420h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B1420h case    0:*/		return 0x820B1424;
		  /* 820B1424h */ case    1:  		/* bc 12, CR6_EQ, 604 */
		/* 820B1424h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B1424h case    1:*/		return 0x820B1428;
	}
	return 0x820B1428;
} // Block from 820B1420h-820B1428h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B1428h
// Function '?Error@CCompiler@D3DXShader@@IAAJPAVCNode@2@IPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1428);
		  /* 820B1428h */ case    0:  		/* mtspr CTR, R25 */
		/* 820B1428h case    0:*/		regs.CTR = regs.R25;
		/* 820B1428h case    0:*/		return 0x820B142C;
		  /* 820B142Ch */ case    1:  		/* li R11, 0 */
		/* 820B142Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B142Ch case    1:*/		return 0x820B1430;
		  /* 820B1430h */ case    2:  		/* lwz R10, <#[R31 + 16]> */
		/* 820B1430h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1430h case    2:*/		return 0x820B1434;
		  /* 820B1434h */ case    3:  		/* lwz R8, <#[R23 + 8]> */
		/* 820B1434h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000008) );
		/* 820B1434h case    3:*/		return 0x820B1438;
		  /* 820B1438h */ case    4:  		/* lwz R9, <#[R31 + 8]> */
		/* 820B1438h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820B1438h case    4:*/		return 0x820B143C;
		  /* 820B143Ch */ case    5:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820B143Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B143Ch case    5:*/		return 0x820B1440;
		  /* 820B1440h */ case    6:  		/* lwz R8, <#[R8 + 20]> */
		/* 820B1440h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000014) );
		/* 820B1440h case    6:*/		return 0x820B1444;
		  /* 820B1444h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B1444h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B1444h case    7:*/		return 0x820B1448;
		  /* 820B1448h */ case    8:  		/* lwzx R9, <#[R9 + R11]> */
		/* 820B1448h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B1448h case    8:*/		return 0x820B144C;
		  /* 820B144Ch */ case    9:  		/* addi R11, R11, 4 */
		/* 820B144Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B144Ch case    9:*/		return 0x820B1450;
		  /* 820B1450h */ case   10:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 820B1450h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 820B1450h case   10:*/		return 0x820B1454;
		  /* 820B1454h */ case   11:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820B1454h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820B1454h case   11:*/		return 0x820B1458;
		  /* 820B1458h */ case   12:  		/* lwzx R8, <#[R7 + R8]> */
		/* 820B1458h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820B1458h case   12:*/		return 0x820B145C;
		  /* 820B145Ch */ case   13:  		/* stw R9, <#[R10 + 52]> */
		/* 820B145Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000034) );
		/* 820B145Ch case   13:*/		return 0x820B1460;
		  /* 820B1460h */ case   14:  		/* lwz R7, <#[R10]> */
		/* 820B1460h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820B1460h case   14:*/		return 0x820B1464;
		  /* 820B1464h */ case   15:  		/* lwz R9, <#[R8]> */
		/* 820B1464h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 820B1464h case   15:*/		return 0x820B1468;
		  /* 820B1468h */ case   16:  		/* or R9, R9, R7 */
		/* 820B1468h case   16:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820B1468h case   16:*/		return 0x820B146C;
		  /* 820B146Ch */ case   17:  		/* stw R9, <#[R10]> */
		/* 820B146Ch case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820B146Ch case   17:*/		return 0x820B1470;
		  /* 820B1470h */ case   18:  		/* lfd FR0, <#[R8 + 32]> */
		/* 820B1470h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000020) );
		/* 820B1470h case   18:*/		return 0x820B1474;
		  /* 820B1474h */ case   19:  		/* stfd FR0, <#[R10 + 32]> */
		/* 820B1474h case   19:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820B1474h case   19:*/		return 0x820B1478;
		  /* 820B1478h */ case   20:  		/* lfd FR0, <#[R8 + 40]> */
		/* 820B1478h case   20:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000028) );
		/* 820B1478h case   20:*/		return 0x820B147C;
		  /* 820B147Ch */ case   21:  		/* stfd FR0, <#[R10 + 40]> */
		/* 820B147Ch case   21:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000028) );
		/* 820B147Ch case   21:*/		return 0x820B1480;
		  /* 820B1480h */ case   22:  		/* bc 16, CR0_LT, -80 */
		/* 820B1480h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B1430;  }
		/* 820B1480h case   22:*/		return 0x820B1484;
		  /* 820B1484h */ case   23:  		/* b 508 */
		/* 820B1484h case   23:*/		return 0x820B1680;
		/* 820B1484h case   23:*/		return 0x820B1488;
	}
	return 0x820B1488;
} // Block from 820B1428h-820B1488h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820B1488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1488);
		  /* 820B1488h */ case    0:  		/* lis R9, 8304 */
		/* 820B1488h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x2070);
		/* 820B1488h case    0:*/		return 0x820B148C;
		  /* 820B148Ch */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 820B148Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B148Ch case    1:*/		return 0x820B1490;
		  /* 820B1490h */ case    2:  		/* bc 12, CR6_EQ, 348 */
		/* 820B1490h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B15EC;  }
		/* 820B1490h case    2:*/		return 0x820B1494;
		  /* 820B1494h */ case    3:  		/* lis R9, 8320 */
		/* 820B1494h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x2080);
		/* 820B1494h case    3:*/		return 0x820B1498;
		  /* 820B1498h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 820B1498h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B1498h case    4:*/		return 0x820B149C;
		  /* 820B149Ch */ case    5:  		/* bc 12, CR6_EQ, 336 */
		/* 820B149Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820B15EC;  }
		/* 820B149Ch case    5:*/		return 0x820B14A0;
		  /* 820B14A0h */ case    6:  		/* lis R9, 12288 */
		/* 820B14A0h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0x3000);
		/* 820B14A0h case    6:*/		return 0x820B14A4;
		  /* 820B14A4h */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820B14A4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B14A4h case    7:*/		return 0x820B14A8;
		  /* 820B14A8h */ case    8:  		/* bc 12, CR6_EQ, 160 */
		/* 820B14A8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820B1548;  }
		/* 820B14A8h case    8:*/		return 0x820B14AC;
		  /* 820B14ACh */ case    9:  		/* lis R9, 20480 */
		/* 820B14ACh case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x5000);
		/* 820B14ACh case    9:*/		return 0x820B14B0;
		  /* 820B14B0h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 820B14B0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B14B0h case   10:*/		return 0x820B14B4;
		  /* 820B14B4h */ case   11:  		/* bc 4, CR6_EQ, 460 */
		/* 820B14B4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B14B4h case   11:*/		return 0x820B14B8;
	}
	return 0x820B14B8;
} // Block from 820B1488h-820B14B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B14B8h
// Function '?Warning@CCompiler@D3DXShader@@IAAJPAVCNode@2@IPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B14B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B14B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B14B8);
		  /* 820B14B8h */ case    0:  		/* lwz R9, <#[R31 + 16]> */
		/* 820B14B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 820B14B8h case    0:*/		return 0x820B14BC;
		  /* 820B14BCh */ case    1:  		/* rlwinm. R11, R10, 0, 12, 31 */
		/* 820B14BCh case    1:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R11,regs.R10);
		/* 820B14BCh case    1:*/		return 0x820B14C0;
		  /* 820B14C0h */ case    2:  		/* lwz R10, <#[R23 + 8]> */
		/* 820B14C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 820B14C0h case    2:*/		return 0x820B14C4;
		  /* 820B14C4h */ case    3:  		/* li R6, 0 */
		/* 820B14C4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B14C4h case    3:*/		return 0x820B14C8;
		  /* 820B14C8h */ case    4:  		/* lwz R9, <#[R9]> */
		/* 820B14C8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820B14C8h case    4:*/		return 0x820B14CC;
		  /* 820B14CCh */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B14CCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B14CCh case    5:*/		return 0x820B14D0;
		  /* 820B14D0h */ case    6:  		/* lwz R10, <#[R10 + 20]> */
		/* 820B14D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820B14D0h case    6:*/		return 0x820B14D4;
		  /* 820B14D4h */ case    7:  		/* lwzx R5, <#[R9 + R10]> */
		/* 820B14D4h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820B14D4h case    7:*/		return 0x820B14D8;
		  /* 820B14D8h */ case    8:  		/* bc 12, CR0_EQ, 88 */
		/* 820B14D8h case    8:*/		if ( regs.CR[0].eq ) { return 0x820B1530;  }
		/* 820B14D8h case    8:*/		return 0x820B14DC;
		  /* 820B14DCh */ case    9:  		/* lwz R7, <#[R23 + 8]> */
		/* 820B14DCh case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000008) );
		/* 820B14DCh case    9:*/		return 0x820B14E0;
		  /* 820B14E0h */ case   10:  		/* li R10, 0 */
		/* 820B14E0h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B14E0h case   10:*/		return 0x820B14E4;
		  /* 820B14E4h */ case   11:  		/* lwz R8, <#[R31 + 8]> */
		/* 820B14E4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 820B14E4h case   11:*/		return 0x820B14E8;
		  /* 820B14E8h */ case   12:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820B14E8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820B14E8h case   12:*/		return 0x820B14EC;
		  /* 820B14ECh */ case   13:  		/* lwz R7, <#[R7 + 20]> */
		/* 820B14ECh case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 820B14ECh case   13:*/		return 0x820B14F0;
		  /* 820B14F0h */ case   14:  		/* lwzx R4, <#[R9 + R8]> */
		/* 820B14F0h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820B14F0h case   14:*/		return 0x820B14F4;
		  /* 820B14F4h */ case   15:  		/* lwzx R3, <#[R10 + R8]> */
		/* 820B14F4h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820B14F4h case   15:*/		return 0x820B14F8;
		  /* 820B14F8h */ case   16:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 820B14F8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 820B14F8h case   16:*/		return 0x820B14FC;
		  /* 820B14FCh */ case   17:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 820B14FCh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 820B14FCh case   17:*/		return 0x820B1500;
		  /* 820B1500h */ case   18:  		/* lwzx R4, <#[R4 + R7]> */
		/* 820B1500h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R7 + 0x00000000) );
		/* 820B1500h case   18:*/		return 0x820B1504;
		  /* 820B1504h */ case   19:  		/* lwzx R3, <#[R3 + R7]> */
		/* 820B1504h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 820B1504h case   19:*/		return 0x820B1508;
		  /* 820B1508h */ case   20:  		/* lwz R4, <#[R4]> */
		/* 820B1508h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000000) );
		/* 820B1508h case   20:*/		return 0x820B150C;
		  /* 820B150Ch */ case   21:  		/* lwz R3, <#[R3]> */
		/* 820B150Ch case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820B150Ch case   21:*/		return 0x820B1510;
		  /* 820B1510h */ case   22:  		/* and R4, R4, R3 */
		/* 820B1510h case   22:*/		cpu::op::and<0>(regs,&regs.R4,regs.R4,regs.R3);
		/* 820B1510h case   22:*/		return 0x820B1514;
		  /* 820B1514h */ case   23:  		/* rlwinm. R4, R4, 0, 30, 30 */
		/* 820B1514h case   23:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R4,regs.R4);
		/* 820B1514h case   23:*/		return 0x820B1518;
		  /* 820B1518h */ case   24:  		/* bc 12, CR0_EQ, 24 */
		/* 820B1518h case   24:*/		if ( regs.CR[0].eq ) { return 0x820B1530;  }
		/* 820B1518h case   24:*/		return 0x820B151C;
		  /* 820B151Ch */ case   25:  		/* addi R6, R6, 1 */
		/* 820B151Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820B151Ch case   25:*/		return 0x820B1520;
		  /* 820B1520h */ case   26:  		/* addi R10, R10, 4 */
		/* 820B1520h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820B1520h case   26:*/		return 0x820B1524;
		  /* 820B1524h */ case   27:  		/* addi R9, R9, 4 */
		/* 820B1524h case   27:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820B1524h case   27:*/		return 0x820B1528;
		  /* 820B1528h */ case   28:  		/* cmplw CR6, R6, R11 */
		/* 820B1528h case   28:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820B1528h case   28:*/		return 0x820B152C;
		  /* 820B152Ch */ case   29:  		/* bc 12, CR6_LT, -60 */
		/* 820B152Ch case   29:*/		if ( regs.CR[6].lt ) { return 0x820B14F0;  }
		/* 820B152Ch case   29:*/		return 0x820B1530;
	}
	return 0x820B1530;
} // Block from 820B14B8h-820B1530h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820B1530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1530);
		  /* 820B1530h */ case    0:  		/* cmplw CR6, R6, R11 */
		/* 820B1530h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820B1530h case    0:*/		return 0x820B1534;
		  /* 820B1534h */ case    1:  		/* bc 4, CR6_EQ, 332 */
		/* 820B1534h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B1534h case    1:*/		return 0x820B1538;
		  /* 820B1538h */ case    2:  		/* lwz R11, <#[R5]> */
		/* 820B1538h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820B1538h case    2:*/		return 0x820B153C;
		  /* 820B153Ch */ case    3:  		/* ori R11, R11, 2 */
		/* 820B153Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820B153Ch case    3:*/		return 0x820B1540;
	}
	return 0x820B1540;
} // Block from 820B1530h-820B1540h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B1540h
// Function '?EmitInst@CCompiler@D3DXShader@@IAAJPAVCNode@2@KPAI11K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1540);
		  /* 820B1540h */ case    0:  		/* stw R11, <#[R5]> */
		/* 820B1540h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820B1540h case    0:*/		return 0x820B1544;
		  /* 820B1544h */ case    1:  		/* b 316 */
		/* 820B1544h case    1:*/		return 0x820B1680;
		/* 820B1544h case    1:*/		return 0x820B1548;
	}
	return 0x820B1548;
} // Block from 820B1540h-820B1548h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B1548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1548);
		  /* 820B1548h */ case    0:  		/* li R10, 0 */
		/* 820B1548h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B1548h case    0:*/		return 0x820B154C;
		  /* 820B154Ch */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 820B154Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B154Ch case    1:*/		return 0x820B1550;
		  /* 820B1550h */ case    2:  		/* bc 12, CR6_EQ, 304 */
		/* 820B1550h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B1550h case    2:*/		return 0x820B1554;
		  /* 820B1554h */ case    3:  		/* mtspr CTR, R25 */
		/* 820B1554h case    3:*/		regs.CTR = regs.R25;
		/* 820B1554h case    3:*/		return 0x820B1558;
		  /* 820B1558h */ case    4:  		/* li R8, 0 */
		/* 820B1558h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B1558h case    4:*/		return 0x820B155C;
		  /* 820B155Ch */ case    5:  		/* lwz R11, <#[R31 + 12]> */
		/* 820B155Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B155Ch case    5:*/		return 0x820B1560;
		  /* 820B1560h */ case    6:  		/* lwz R7, <#[R31 + 8]> */
		/* 820B1560h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 820B1560h case    6:*/		return 0x820B1564;
		  /* 820B1564h */ case    7:  		/* rlwinm R9, R11, 1, 0, 30 */
		/* 820B1564h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R11);
		/* 820B1564h case    7:*/		return 0x820B1568;
		  /* 820B1568h */ case    8:  		/* lwz R6, <#[R23 + 8]> */
		/* 820B1568h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000008) );
		/* 820B1568h case    8:*/		return 0x820B156C;
		  /* 820B156Ch */ case    9:  		/* add R11, R11, R10 */
		/* 820B156Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820B156Ch case    9:*/		return 0x820B1570;
		  /* 820B1570h */ case   10:  		/* lwz R5, <#[R31 + 16]> */
		/* 820B1570h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1570h case   10:*/		return 0x820B1574;
		  /* 820B1574h */ case   11:  		/* add R9, R9, R10 */
		/* 820B1574h case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 820B1574h case   11:*/		return 0x820B1578;
		  /* 820B1578h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B1578h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B1578h case   12:*/		return 0x820B157C;
		  /* 820B157Ch */ case   13:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B157Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B157Ch case   13:*/		return 0x820B1580;
		  /* 820B1580h */ case   14:  		/* lwz R6, <#[R6 + 20]> */
		/* 820B1580h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000014) );
		/* 820B1580h case   14:*/		return 0x820B1584;
		  /* 820B1584h */ case   15:  		/* lwzx R5, <#[R8 + R5]> */
		/* 820B1584h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + regs.R5 + 0x00000000) );
		/* 820B1584h case   15:*/		return 0x820B1588;
		  /* 820B1588h */ case   16:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820B1588h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820B1588h case   16:*/		return 0x820B158C;
		  /* 820B158Ch */ case   17:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820B158Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820B158Ch case   17:*/		return 0x820B1590;
		  /* 820B1590h */ case   18:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820B1590h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820B1590h case   18:*/		return 0x820B1594;
		  /* 820B1594h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B1594h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B1594h case   19:*/		return 0x820B1598;
		  /* 820B1598h */ case   20:  		/* rlwinm R7, R9, 2, 0, 29 */
		/* 820B1598h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 820B1598h case   20:*/		return 0x820B159C;
		  /* 820B159Ch */ case   21:  		/* lwzx R9, <#[R5 + R6]> */
		/* 820B159Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 820B159Ch case   21:*/		return 0x820B15A0;
		  /* 820B15A0h */ case   22:  		/* lwzx R11, <#[R11 + R6]> */
		/* 820B15A0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820B15A0h case   22:*/		return 0x820B15A4;
		  /* 820B15A4h */ case   23:  		/* lwzx R7, <#[R7 + R6]> */
		/* 820B15A4h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 820B15A4h case   23:*/		return 0x820B15A8;
		  /* 820B15A8h */ case   24:  		/* lwz R11, <#[R11]> */
		/* 820B15A8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820B15A8h case   24:*/		return 0x820B15AC;
		  /* 820B15ACh */ case   25:  		/* lwz R7, <#[R7]> */
		/* 820B15ACh case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 820B15ACh case   25:*/		return 0x820B15B0;
		  /* 820B15B0h */ case   26:  		/* and R11, R7, R11 */
		/* 820B15B0h case   26:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 820B15B0h case   26:*/		return 0x820B15B4;
		  /* 820B15B4h */ case   27:  		/* rlwinm. R7, R11, 0, 31, 31 */
		/* 820B15B4h case   27:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R11);
		/* 820B15B4h case   27:*/		return 0x820B15B8;
		  /* 820B15B8h */ case   28:  		/* bc 12, CR0_EQ, 16 */
		/* 820B15B8h case   28:*/		if ( regs.CR[0].eq ) { return 0x820B15C8;  }
		/* 820B15B8h case   28:*/		return 0x820B15BC;
		  /* 820B15BCh */ case   29:  		/* lwz R11, <#[R9]> */
		/* 820B15BCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820B15BCh case   29:*/		return 0x820B15C0;
		  /* 820B15C0h */ case   30:  		/* ori R11, R11, 23 */
		/* 820B15C0h case   30:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x17);
		/* 820B15C0h case   30:*/		return 0x820B15C4;
		  /* 820B15C4h */ case   31:  		/* b 20 */
		/* 820B15C4h case   31:*/		return 0x820B15D8;
		/* 820B15C4h case   31:*/		return 0x820B15C8;
	}
	return 0x820B15C8;
} // Block from 820B1548h-820B15C8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820B15C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B15C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B15C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B15C8);
		  /* 820B15C8h */ case    0:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820B15C8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820B15C8h case    0:*/		return 0x820B15CC;
		  /* 820B15CCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820B15CCh case    1:*/		if ( regs.CR[0].eq ) { return 0x820B15DC;  }
		/* 820B15CCh case    1:*/		return 0x820B15D0;
		  /* 820B15D0h */ case    2:  		/* lwz R11, <#[R9]> */
		/* 820B15D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820B15D0h case    2:*/		return 0x820B15D4;
		  /* 820B15D4h */ case    3:  		/* ori R11, R11, 2 */
		/* 820B15D4h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820B15D4h case    3:*/		return 0x820B15D8;
	}
	return 0x820B15D8;
} // Block from 820B15C8h-820B15D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B15D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B15D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B15D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B15D8);
		  /* 820B15D8h */ case    0:  		/* stw R11, <#[R9]> */
		/* 820B15D8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820B15D8h case    0:*/		return 0x820B15DC;
	}
	return 0x820B15DC;
} // Block from 820B15D8h-820B15DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B15DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B15DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B15DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B15DC);
		  /* 820B15DCh */ case    0:  		/* addi R10, R10, 1 */
		/* 820B15DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B15DCh case    0:*/		return 0x820B15E0;
		  /* 820B15E0h */ case    1:  		/* addi R8, R8, 4 */
		/* 820B15E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820B15E0h case    1:*/		return 0x820B15E4;
		  /* 820B15E4h */ case    2:  		/* bc 16, CR0_LT, -136 */
		/* 820B15E4h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B155C;  }
		/* 820B15E4h case    2:*/		return 0x820B15E8;
		  /* 820B15E8h */ case    3:  		/* b 152 */
		/* 820B15E8h case    3:*/		return 0x820B1680;
		/* 820B15E8h case    3:*/		return 0x820B15EC;
	}
	return 0x820B15EC;
} // Block from 820B15DCh-820B15ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B15ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B15EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B15EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B15EC);
		  /* 820B15ECh */ case    0:  		/* li R8, 0 */
		/* 820B15ECh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B15ECh case    0:*/		return 0x820B15F0;
		  /* 820B15F0h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 820B15F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B15F0h case    1:*/		return 0x820B15F4;
		  /* 820B15F4h */ case    2:  		/* bc 12, CR6_EQ, 140 */
		/* 820B15F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B1680;  }
		/* 820B15F4h case    2:*/		return 0x820B15F8;
		  /* 820B15F8h */ case    3:  		/* mtspr CTR, R25 */
		/* 820B15F8h case    3:*/		regs.CTR = regs.R25;
		/* 820B15F8h case    3:*/		return 0x820B15FC;
		  /* 820B15FCh */ case    4:  		/* li R11, 0 */
		/* 820B15FCh case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B15FCh case    4:*/		return 0x820B1600;
		  /* 820B1600h */ case    5:  		/* lwz R10, <#[R31 + 12]> */
		/* 820B1600h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B1600h case    5:*/		return 0x820B1604;
		  /* 820B1604h */ case    6:  		/* lwz R9, <#[R31 + 8]> */
		/* 820B1604h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820B1604h case    6:*/		return 0x820B1608;
		  /* 820B1608h */ case    7:  		/* add R10, R8, R10 */
		/* 820B1608h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820B1608h case    7:*/		return 0x820B160C;
		  /* 820B160Ch */ case    8:  		/* lwz R7, <#[R23 + 8]> */
		/* 820B160Ch case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + 0x00000008) );
		/* 820B160Ch case    8:*/		return 0x820B1610;
		  /* 820B1610h */ case    9:  		/* lwz R6, <#[R31 + 16]> */
		/* 820B1610h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1610h case    9:*/		return 0x820B1614;
		  /* 820B1614h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B1614h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B1614h case   10:*/		return 0x820B1618;
		  /* 820B1618h */ case   11:  		/* lwzx R5, <#[R11 + R9]> */
		/* 820B1618h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820B1618h case   11:*/		return 0x820B161C;
		  /* 820B161Ch */ case   12:  		/* lwz R7, <#[R7 + 20]> */
		/* 820B161Ch case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 820B161Ch case   12:*/		return 0x820B1620;
		  /* 820B1620h */ case   13:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820B1620h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820B1620h case   13:*/		return 0x820B1624;
		  /* 820B1624h */ case   14:  		/* lwzx R6, <#[R11 + R6]> */
		/* 820B1624h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 820B1624h case   14:*/		return 0x820B1628;
		  /* 820B1628h */ case   15:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820B1628h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820B1628h case   15:*/		return 0x820B162C;
		  /* 820B162Ch */ case   16:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 820B162Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 820B162Ch case   16:*/		return 0x820B1630;
		  /* 820B1630h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B1630h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B1630h case   17:*/		return 0x820B1634;
		  /* 820B1634h */ case   18:  		/* lwzx R6, <#[R5 + R7]> */
		/* 820B1634h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 820B1634h case   18:*/		return 0x820B1638;
		  /* 820B1638h */ case   19:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820B1638h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820B1638h case   19:*/		return 0x820B163C;
		  /* 820B163Ch */ case   20:  		/* lwzx R10, <#[R10 + R7]> */
		/* 820B163Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 820B163Ch case   20:*/		return 0x820B1640;
		  /* 820B1640h */ case   21:  		/* lwz R7, <#[R6]> */
		/* 820B1640h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 820B1640h case   21:*/		return 0x820B1644;
		  /* 820B1644h */ case   22:  		/* lwz R10, <#[R10]> */
		/* 820B1644h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 820B1644h case   22:*/		return 0x820B1648;
		  /* 820B1648h */ case   23:  		/* and R10, R10, R7 */
		/* 820B1648h case   23:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820B1648h case   23:*/		return 0x820B164C;
		  /* 820B164Ch */ case   24:  		/* rlwinm. R7, R10, 0, 31, 31 */
		/* 820B164Ch case   24:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R10);
		/* 820B164Ch case   24:*/		return 0x820B1650;
		  /* 820B1650h */ case   25:  		/* bc 12, CR0_EQ, 16 */
		/* 820B1650h case   25:*/		if ( regs.CR[0].eq ) { return 0x820B1660;  }
		/* 820B1650h case   25:*/		return 0x820B1654;
		  /* 820B1654h */ case   26:  		/* lwz R10, <#[R9]> */
		/* 820B1654h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820B1654h case   26:*/		return 0x820B1658;
		  /* 820B1658h */ case   27:  		/* ori R10, R10, 23 */
		/* 820B1658h case   27:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x17);
		/* 820B1658h case   27:*/		return 0x820B165C;
		  /* 820B165Ch */ case   28:  		/* b 20 */
		/* 820B165Ch case   28:*/		return 0x820B1670;
		/* 820B165Ch case   28:*/		return 0x820B1660;
	}
	return 0x820B1660;
} // Block from 820B15ECh-820B1660h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820B1660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1660);
		  /* 820B1660h */ case    0:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820B1660h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820B1660h case    0:*/		return 0x820B1664;
		  /* 820B1664h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820B1664h case    1:*/		if ( regs.CR[0].eq ) { return 0x820B1674;  }
		/* 820B1664h case    1:*/		return 0x820B1668;
		  /* 820B1668h */ case    2:  		/* lwz R10, <#[R9]> */
		/* 820B1668h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820B1668h case    2:*/		return 0x820B166C;
		  /* 820B166Ch */ case    3:  		/* ori R10, R10, 2 */
		/* 820B166Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820B166Ch case    3:*/		return 0x820B1670;
	}
	return 0x820B1670;
} // Block from 820B1660h-820B1670h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B1670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1670);
		  /* 820B1670h */ case    0:  		/* stw R10, <#[R9]> */
		/* 820B1670h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820B1670h case    0:*/		return 0x820B1674;
	}
	return 0x820B1674;
} // Block from 820B1670h-820B1674h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B1674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1674);
		  /* 820B1674h */ case    0:  		/* addi R8, R8, 1 */
		/* 820B1674h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820B1674h case    0:*/		return 0x820B1678;
		  /* 820B1678h */ case    1:  		/* addi R11, R11, 4 */
		/* 820B1678h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B1678h case    1:*/		return 0x820B167C;
		  /* 820B167Ch */ case    2:  		/* bc 16, CR0_LT, -124 */
		/* 820B167Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B1600;  }
		/* 820B167Ch case    2:*/		return 0x820B1680;
	}
	return 0x820B1680;
} // Block from 820B1674h-820B1680h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B1680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1680);
		  /* 820B1680h */ case    0:  		/* stw R16, <#[R31 + 60]> */
		/* 820B1680h case    0:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R31 + 0x0000003C) );
		/* 820B1680h case    0:*/		return 0x820B1684;
		  /* 820B1684h */ case    1:  		/* lwz R11, <#[R23 + 56]> */
		/* 820B1684h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000038) );
		/* 820B1684h case    1:*/		return 0x820B1688;
		  /* 820B1688h */ case    2:  		/* stw R11, <#[R31 + 56]> */
		/* 820B1688h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820B1688h case    2:*/		return 0x820B168C;
	}
	return 0x820B168C;
} // Block from 820B1680h-820B168Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B168Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B168C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B168C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B168C);
		  /* 820B168Ch */ case    0:  		/* li R3, 0 */
		/* 820B168Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B168Ch case    0:*/		return 0x820B1690;
	}
	return 0x820B1690;
} // Block from 820B168Ch-820B1690h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B1690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1690);
		  /* 820B1690h */ case    0:  		/* addi R1, R1, 320 */
		/* 820B1690h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 820B1690h case    0:*/		return 0x820B1694;
		  /* 820B1694h */ case    1:  		/* lfd FR31, <#[R1 - 144]> */
		/* 820B1694h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 820B1694h case    1:*/		return 0x820B1698;
		  /* 820B1698h */ case    2:  		/* b -132128 */
		/* 820B1698h case    2:*/		return 0x82091278;
		/* 820B1698h case    2:*/		return 0x820B169C;
		  /* 820B169Ch */ case    3:  		/* nop */
		/* 820B169Ch case    3:*/		cpu::op::nop();
		/* 820B169Ch case    3:*/		return 0x820B16A0;
	}
	return 0x820B16A0;
} // Block from 820B1690h-820B16A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B16A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B16A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B16A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B16A0);
		  /* 820B16A0h */ case    0:  		/* mfspr R12, LR */
		/* 820B16A0h case    0:*/		regs.R12 = regs.LR;
		/* 820B16A0h case    0:*/		return 0x820B16A4;
		  /* 820B16A4h */ case    1:  		/* bl -132176 */
		/* 820B16A4h case    1:*/		regs.LR = 0x820B16A8; return 0x82091254;
		/* 820B16A4h case    1:*/		return 0x820B16A8;
		  /* 820B16A8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820B16A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820B16A8h case    2:*/		return 0x820B16AC;
		  /* 820B16ACh */ case    3:  		/* mr R28, R3 */
		/* 820B16ACh case    3:*/		regs.R28 = regs.R3;
		/* 820B16ACh case    3:*/		return 0x820B16B0;
		  /* 820B16B0h */ case    4:  		/* mr R31, R4 */
		/* 820B16B0h case    4:*/		regs.R31 = regs.R4;
		/* 820B16B0h case    4:*/		return 0x820B16B4;
		  /* 820B16B4h */ case    5:  		/* mr R27, R5 */
		/* 820B16B4h case    5:*/		regs.R27 = regs.R5;
		/* 820B16B4h case    5:*/		return 0x820B16B8;
		  /* 820B16B8h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 820B16B8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820B16B8h case    6:*/		return 0x820B16BC;
		  /* 820B16BCh */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 820B16BCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820B16C8;  }
		/* 820B16BCh case    7:*/		return 0x820B16C0;
		  /* 820B16C0h */ case    8:  		/* li R3, 0 */
		/* 820B16C0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B16C0h case    8:*/		return 0x820B16C4;
		  /* 820B16C4h */ case    9:  		/* b 444 */
		/* 820B16C4h case    9:*/		return 0x820B1880;
		/* 820B16C4h case    9:*/		return 0x820B16C8;
	}
	return 0x820B16C8;
} // Block from 820B16A0h-820B16C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B16C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B16C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B16C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B16C8);
		  /* 820B16C8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820B16C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B16C8h case    0:*/		return 0x820B16CC;
		  /* 820B16CCh */ case    1:  		/* li R30, 0 */
		/* 820B16CCh case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B16CCh case    1:*/		return 0x820B16D0;
		  /* 820B16D0h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 820B16D0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820B16D0h case    2:*/		return 0x820B16D4;
		  /* 820B16D4h */ case    3:  		/* bc 12, CR6_EQ, 344 */
		/* 820B16D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B182C;  }
		/* 820B16D4h case    3:*/		return 0x820B16D8;
		  /* 820B16D8h */ case    4:  		/* cmpwi CR6, R11, 6 */
		/* 820B16D8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820B16D8h case    4:*/		return 0x820B16DC;
		  /* 820B16DCh */ case    5:  		/* bc 12, CR6_EQ, 312 */
		/* 820B16DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820B1814;  }
		/* 820B16DCh case    5:*/		return 0x820B16E0;
		  /* 820B16E0h */ case    6:  		/* cmpwi CR6, R11, 8 */
		/* 820B16E0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 820B16E0h case    6:*/		return 0x820B16E4;
		  /* 820B16E4h */ case    7:  		/* bc 12, CR6_EQ, 244 */
		/* 820B16E4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820B17D8;  }
		/* 820B16E4h case    7:*/		return 0x820B16E8;
		  /* 820B16E8h */ case    8:  		/* cmpwi CR6, R11, 9 */
		/* 820B16E8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 820B16E8h case    8:*/		return 0x820B16EC;
		  /* 820B16ECh */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 820B16ECh case    9:*/		if ( regs.CR[6].eq ) { return 0x820B171C;  }
		/* 820B16ECh case    9:*/		return 0x820B16F0;
		  /* 820B16F0h */ case   10:  		/* cmpwi CR6, R11, 11 */
		/* 820B16F0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820B16F0h case   10:*/		return 0x820B16F4;
		  /* 820B16F4h */ case   11:  		/* mr R3, R28 */
		/* 820B16F4h case   11:*/		regs.R3 = regs.R28;
		/* 820B16F4h case   11:*/		return 0x820B16F8;
		  /* 820B16F8h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 820B16F8h case   12:*/		if ( regs.CR[6].eq ) { return 0x820B1714;  }
		/* 820B16F8h case   12:*/		return 0x820B16FC;
		  /* 820B16FCh */ case   13:  		/* lis R11, -32255 */
		/* 820B16FCh case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B16FCh case   13:*/		return 0x820B1700;
		  /* 820B1700h */ case   14:  		/* li R5, 0 */
		/* 820B1700h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1700h case   14:*/		return 0x820B1704;
		  /* 820B1704h */ case   15:  		/* addi R6, R11, 8564 */
		/* 820B1704h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2174);
		/* 820B1704h case   15:*/		return 0x820B1708;
		  /* 820B1708h */ case   16:  		/* li R4, 0 */
		/* 820B1708h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B1708h case   16:*/		return 0x820B170C;
		  /* 820B170Ch */ case   17:  		/* bl -3356 */
		/* 820B170Ch case   17:*/		regs.LR = 0x820B1710; return 0x820B09F0;
		/* 820B170Ch case   17:*/		return 0x820B1710;
		  /* 820B1710h */ case   18:  		/* b 364 */
		/* 820B1710h case   18:*/		return 0x820B187C;
		/* 820B1710h case   18:*/		return 0x820B1714;
	}
	return 0x820B1714;
} // Block from 820B16C8h-820B1714h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820B1714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1714);
		  /* 820B1714h */ case    0:  		/* lwz R4, <#[R31 + 48]> */
		/* 820B1714h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000030) );
		/* 820B1714h case    0:*/		return 0x820B1718;
		  /* 820B1718h */ case    1:  		/* b 260 */
		/* 820B1718h case    1:*/		return 0x820B181C;
		/* 820B1718h case    1:*/		return 0x820B171C;
	}
	return 0x820B171C;
} // Block from 820B1714h-820B171Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B171Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B171C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B171C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B171C);
		  /* 820B171Ch */ case    0:  		/* lwz R9, <#[R31 + 32]> */
		/* 820B171Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 820B171Ch case    0:*/		return 0x820B1720;
		  /* 820B1720h */ case    1:  		/* li R10, 0 */
		/* 820B1720h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B1720h case    1:*/		return 0x820B1724;
		  /* 820B1724h */ case    2:  		/* lwz R8, <#[R31 + 28]> */
		/* 820B1724h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000001C) );
		/* 820B1724h case    2:*/		return 0x820B1728;
		  /* 820B1728h */ case    3:  		/* lwz R11, <#[R31 + 20]> */
		/* 820B1728h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820B1728h case    3:*/		return 0x820B172C;
		  /* 820B172Ch */ case    4:  		/* mullw R30, R9, R8 */
		/* 820B172Ch case    4:*/		cpu::op::mullw<0>(regs,&regs.R30,regs.R9,regs.R8);
		/* 820B172Ch case    4:*/		return 0x820B1730;
		  /* 820B1730h */ case    5:  		/* cmplwi CR6, R11, 13 */
		/* 820B1730h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000D);
		/* 820B1730h case    5:*/		return 0x820B1734;
		  /* 820B1734h */ case    6:  		/* bc 12, CR6_GT, 108 */
		/* 820B1734h case    6:*/		if ( regs.CR[6].gt ) { return 0x820B17A0;  }
		/* 820B1734h case    6:*/		return 0x820B1738;
		  /* 820B1738h */ case    7:  		/* lis R12, -32255 */
		/* 820B1738h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820B1738h case    7:*/		return 0x820B173C;
		  /* 820B173Ch */ case    8:  		/* addi R12, R12, 8200 */
		/* 820B173Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x2008);
		/* 820B173Ch case    8:*/		return 0x820B1740;
		  /* 820B1740h */ case    9:  		/* lbzx R0, <#[R12 + R11]> */
		/* 820B1740h case    9:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 820B1740h case    9:*/		return 0x820B1744;
		  /* 820B1744h */ case   10:  		/* lis R12, -32245 */
		/* 820B1744h case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820B);
		/* 820B1744h case   10:*/		return 0x820B1748;
		  /* 820B1748h */ case   11:  		/* ori R0, R0, 0 */
		/* 820B1748h case   11:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820B1748h case   11:*/		return 0x820B174C;
		  /* 820B174Ch */ case   12:  		/* addi R12, R12, 5984 */
		/* 820B174Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x1760);
		/* 820B174Ch case   12:*/		return 0x820B1750;
		  /* 820B1750h */ case   13:  		/* ori R0, R0, 0 */
		/* 820B1750h case   13:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820B1750h case   13:*/		return 0x820B1754;
		  /* 820B1754h */ case   14:  		/* add R12, R12, R0 */
		/* 820B1754h case   14:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820B1754h case   14:*/		return 0x820B1758;
		  /* 820B1758h */ case   15:  		/* mtspr CTR, R12 */
		/* 820B1758h case   15:*/		regs.CTR = regs.R12;
		/* 820B1758h case   15:*/		return 0x820B175C;
		  /* 820B175Ch */ case   16:  		/* bcctr 20, CR0_LT */
		/* 820B175Ch case   16:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820B175Ch case   16:*/		return 0x820B1760;
		  /* 820B1760h */ case   17:  		/* li R10, 23 */
		/* 820B1760h case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x17);
		/* 820B1760h case   17:*/		return 0x820B1764;
		  /* 820B1764h */ case   18:  		/* b 60 */
		/* 820B1764h case   18:*/		return 0x820B17A0;
		/* 820B1764h case   18:*/		return 0x820B1768;
		  /* 820B1768h */ case   19:  		/* li R10, 2 */
		/* 820B1768h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820B1768h case   19:*/		return 0x820B176C;
		  /* 820B176Ch */ case   20:  		/* b 52 */
		/* 820B176Ch case   20:*/		return 0x820B17A0;
		/* 820B176Ch case   20:*/		return 0x820B1770;
		  /* 820B1770h */ case   21:  		/* lis R10, 512 */
		/* 820B1770h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 820B1770h case   21:*/		return 0x820B1774;
		  /* 820B1774h */ case   22:  		/* ori R10, R10, 2 */
		/* 820B1774h case   22:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820B1774h case   22:*/		return 0x820B1778;
		  /* 820B1778h */ case   23:  		/* b 40 */
		/* 820B1778h case   23:*/		return 0x820B17A0;
		/* 820B1778h case   23:*/		return 0x820B177C;
		  /* 820B177Ch */ case   24:  		/* lis R10, 1024 */
		/* 820B177Ch case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0x400);
		/* 820B177Ch case   24:*/		return 0x820B1780;
		  /* 820B1780h */ case   25:  		/* b -12 */
		/* 820B1780h case   25:*/		return 0x820B1774;
		/* 820B1780h case   25:*/		return 0x820B1784;
		  /* 820B1784h */ case   26:  		/* lis R10, 2048 */
		/* 820B1784h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x800);
		/* 820B1784h case   26:*/		return 0x820B1788;
		  /* 820B1788h */ case   27:  		/* b -20 */
		/* 820B1788h case   27:*/		return 0x820B1774;
		/* 820B1788h case   27:*/		return 0x820B178C;
		  /* 820B178Ch */ case   28:  		/* lis R10, 512 */
		/* 820B178Ch case   28:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 820B178Ch case   28:*/		return 0x820B1790;
		  /* 820B1790h */ case   29:  		/* b 16 */
		/* 820B1790h case   29:*/		return 0x820B17A0;
		/* 820B1790h case   29:*/		return 0x820B1794;
		  /* 820B1794h */ case   30:  		/* lis R10, 1024 */
		/* 820B1794h case   30:*/		cpu::op::lis<0>(regs,&regs.R10,0x400);
		/* 820B1794h case   30:*/		return 0x820B1798;
		  /* 820B1798h */ case   31:  		/* b 8 */
		/* 820B1798h case   31:*/		return 0x820B17A0;
		/* 820B1798h case   31:*/		return 0x820B179C;
		  /* 820B179Ch */ case   32:  		/* lis R10, 2048 */
		/* 820B179Ch case   32:*/		cpu::op::lis<0>(regs,&regs.R10,0x800);
		/* 820B179Ch case   32:*/		return 0x820B17A0;
	}
	return 0x820B17A0;
} // Block from 820B171Ch-820B17A0h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820B17A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B17A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B17A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B17A0);
		  /* 820B17A0h */ case    0:  		/* lwz R11, <#[R28 + 20]> */
		/* 820B17A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 820B17A0h case    0:*/		return 0x820B17A4;
		  /* 820B17A4h */ case    1:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820B17A4h case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820B17A4h case    1:*/		return 0x820B17A8;
		  /* 820B17A8h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 820B17A8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820B17B4;  }
		/* 820B17A8h case    2:*/		return 0x820B17AC;
		  /* 820B17ACh */ case    3:  		/* li R11, 1 */
		/* 820B17ACh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820B17ACh case    3:*/		return 0x820B17B0;
		  /* 820B17B0h */ case    4:  		/* rlwimi R10, R11, 25, 4, 6 */
		/* 820B17B0h case    4:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R11);
		/* 820B17B0h case    4:*/		return 0x820B17B4;
	}
	return 0x820B17B4;
} // Block from 820B17A0h-820B17B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B17B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B17B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B17B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B17B4);
		  /* 820B17B4h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820B17B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B17B4h case    0:*/		return 0x820B17B8;
		  /* 820B17B8h */ case    1:  		/* bc 12, CR6_EQ, 196 */
		/* 820B17B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B187C;  }
		/* 820B17B8h case    1:*/		return 0x820B17BC;
		  /* 820B17BCh */ case    2:  		/* addi R11, R27, -4 */
		/* 820B17BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFFC);
		/* 820B17BCh case    2:*/		return 0x820B17C0;
		  /* 820B17C0h */ case    3:  		/* cmplwi CR0, R30, 0 */
		/* 820B17C0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B17C0h case    3:*/		return 0x820B17C4;
		  /* 820B17C4h */ case    4:  		/* bc 12, CR0_EQ, 184 */
		/* 820B17C4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820B187C;  }
		/* 820B17C4h case    4:*/		return 0x820B17C8;
		  /* 820B17C8h */ case    5:  		/* mtspr CTR, R30 */
		/* 820B17C8h case    5:*/		regs.CTR = regs.R30;
		/* 820B17C8h case    5:*/		return 0x820B17CC;
		  /* 820B17CCh */ case    6:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B17CCh case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B17CCh case    6:*/		return 0x820B17D0;
		  /* 820B17D0h */ case    7:  		/* bc 16, CR0_LT, -4 */
		/* 820B17D0h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B17CC;  }
		/* 820B17D0h case    7:*/		return 0x820B17D4;
		  /* 820B17D4h */ case    8:  		/* b 168 */
		/* 820B17D4h case    8:*/		return 0x820B187C;
		/* 820B17D4h case    8:*/		return 0x820B17D8;
	}
	return 0x820B17D8;
} // Block from 820B17B4h-820B17D8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B17D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B17D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B17D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B17D8);
		  /* 820B17D8h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820B17D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820B17D8h case    0:*/		return 0x820B17DC;
		  /* 820B17DCh */ case    1:  		/* li R29, 0 */
		/* 820B17DCh case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B17DCh case    1:*/		return 0x820B17E0;
		  /* 820B17E0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820B17E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B17E0h case    2:*/		return 0x820B17E4;
		  /* 820B17E4h */ case    3:  		/* bc 4, CR6_GT, 152 */
		/* 820B17E4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820B187C;  }
		/* 820B17E4h case    3:*/		return 0x820B17E8;
		  /* 820B17E8h */ case    4:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820B17E8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820B17E8h case    4:*/		return 0x820B17EC;
		  /* 820B17ECh */ case    5:  		/* lwz R4, <#[R31 + 16]> */
		/* 820B17ECh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 820B17ECh case    5:*/		return 0x820B17F0;
		  /* 820B17F0h */ case    6:  		/* mr R3, R28 */
		/* 820B17F0h case    6:*/		regs.R3 = regs.R28;
		/* 820B17F0h case    6:*/		return 0x820B17F4;
		  /* 820B17F4h */ case    7:  		/* add R5, R11, R27 */
		/* 820B17F4h case    7:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R27);
		/* 820B17F4h case    7:*/		return 0x820B17F8;
		  /* 820B17F8h */ case    8:  		/* bl -344 */
		/* 820B17F8h case    8:*/		regs.LR = 0x820B17FC; return 0x820B16A0;
		/* 820B17F8h case    8:*/		return 0x820B17FC;
		  /* 820B17FCh */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 820B17FCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820B17FCh case    9:*/		return 0x820B1800;
		  /* 820B1800h */ case   10:  		/* addi R29, R29, 1 */
		/* 820B1800h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820B1800h case   10:*/		return 0x820B1804;
		  /* 820B1804h */ case   11:  		/* add R30, R3, R30 */
		/* 820B1804h case   11:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820B1804h case   11:*/		return 0x820B1808;
		  /* 820B1808h */ case   12:  		/* cmplw CR6, R29, R11 */
		/* 820B1808h case   12:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820B1808h case   12:*/		return 0x820B180C;
		  /* 820B180Ch */ case   13:  		/* bc 12, CR6_LT, -36 */
		/* 820B180Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x820B17E8;  }
		/* 820B180Ch case   13:*/		return 0x820B1810;
		  /* 820B1810h */ case   14:  		/* b 108 */
		/* 820B1810h case   14:*/		return 0x820B187C;
		/* 820B1810h case   14:*/		return 0x820B1814;
	}
	return 0x820B1814;
} // Block from 820B17D8h-820B1814h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B1814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1814);
		  /* 820B1814h */ case    0:  		/* lwz R4, <#[R31 + 24]> */
		/* 820B1814h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820B1814h case    0:*/		return 0x820B1818;
		  /* 820B1818h */ case    1:  		/* mr R3, R28 */
		/* 820B1818h case    1:*/		regs.R3 = regs.R28;
		/* 820B1818h case    1:*/		return 0x820B181C;
	}
	return 0x820B181C;
} // Block from 820B1814h-820B181Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B181Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B181C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B181C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B181C);
		  /* 820B181Ch */ case    0:  		/* mr R5, R27 */
		/* 820B181Ch case    0:*/		regs.R5 = regs.R27;
		/* 820B181Ch case    0:*/		return 0x820B1820;
		  /* 820B1820h */ case    1:  		/* bl -384 */
		/* 820B1820h case    1:*/		regs.LR = 0x820B1824; return 0x820B16A0;
		/* 820B1820h case    1:*/		return 0x820B1824;
		  /* 820B1824h */ case    2:  		/* mr R30, R3 */
		/* 820B1824h case    2:*/		regs.R30 = regs.R3;
		/* 820B1824h case    2:*/		return 0x820B1828;
		  /* 820B1828h */ case    3:  		/* b 84 */
		/* 820B1828h case    3:*/		return 0x820B187C;
		/* 820B1828h case    3:*/		return 0x820B182C;
	}
	return 0x820B182C;
} // Block from 820B181Ch-820B182Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B182Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B182C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B182C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B182C);
		  /* 820B182Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820B182Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B182Ch case    0:*/		return 0x820B1830;
		  /* 820B1830h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 820B1830h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820B1830h case    1:*/		return 0x820B1834;
		  /* 820B1834h */ case    2:  		/* bc 4, CR6_EQ, 40 */
		/* 820B1834h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B185C;  }
		/* 820B1834h case    2:*/		return 0x820B1838;
		  /* 820B1838h */ case    3:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820B1838h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820B1838h case    3:*/		return 0x820B183C;
		  /* 820B183Ch */ case    4:  		/* lwz R4, <#[R31 + 8]> */
		/* 820B183Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 820B183Ch case    4:*/		return 0x820B1840;
		  /* 820B1840h */ case    5:  		/* mr R3, R28 */
		/* 820B1840h case    5:*/		regs.R3 = regs.R28;
		/* 820B1840h case    5:*/		return 0x820B1844;
		  /* 820B1844h */ case    6:  		/* add R5, R11, R27 */
		/* 820B1844h case    6:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R27);
		/* 820B1844h case    6:*/		return 0x820B1848;
		  /* 820B1848h */ case    7:  		/* bl -424 */
		/* 820B1848h case    7:*/		regs.LR = 0x820B184C; return 0x820B16A0;
		/* 820B1848h case    7:*/		return 0x820B184C;
		  /* 820B184Ch */ case    8:  		/* lwz R31, <#[R31 + 12]> */
		/* 820B184Ch case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B184Ch case    8:*/		return 0x820B1850;
		  /* 820B1850h */ case    9:  		/* add R30, R3, R30 */
		/* 820B1850h case    9:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820B1850h case    9:*/		return 0x820B1854;
		  /* 820B1854h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820B1854h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B1854h case   10:*/		return 0x820B1858;
		  /* 820B1858h */ case   11:  		/* bc 4, CR6_EQ, -44 */
		/* 820B1858h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820B182C;  }
		/* 820B1858h case   11:*/		return 0x820B185C;
	}
	return 0x820B185C;
} // Block from 820B182Ch-820B185Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B185Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B185C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B185C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B185C);
		  /* 820B185Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820B185Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B185Ch case    0:*/		return 0x820B1860;
		  /* 820B1860h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820B1860h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B187C;  }
		/* 820B1860h case    1:*/		return 0x820B1864;
		  /* 820B1864h */ case    2:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820B1864h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820B1864h case    2:*/		return 0x820B1868;
		  /* 820B1868h */ case    3:  		/* mr R4, R31 */
		/* 820B1868h case    3:*/		regs.R4 = regs.R31;
		/* 820B1868h case    3:*/		return 0x820B186C;
		  /* 820B186Ch */ case    4:  		/* add R5, R11, R27 */
		/* 820B186Ch case    4:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R27);
		/* 820B186Ch case    4:*/		return 0x820B1870;
		  /* 820B1870h */ case    5:  		/* mr R3, R28 */
		/* 820B1870h case    5:*/		regs.R3 = regs.R28;
		/* 820B1870h case    5:*/		return 0x820B1874;
		  /* 820B1874h */ case    6:  		/* bl -468 */
		/* 820B1874h case    6:*/		regs.LR = 0x820B1878; return 0x820B16A0;
		/* 820B1874h case    6:*/		return 0x820B1878;
		  /* 820B1878h */ case    7:  		/* add R30, R3, R30 */
		/* 820B1878h case    7:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 820B1878h case    7:*/		return 0x820B187C;
	}
	return 0x820B187C;
} // Block from 820B185Ch-820B187Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B187Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B187C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B187C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B187C);
		  /* 820B187Ch */ case    0:  		/* mr R3, R30 */
		/* 820B187Ch case    0:*/		regs.R3 = regs.R30;
		/* 820B187Ch case    0:*/		return 0x820B1880;
	}
	return 0x820B1880;
} // Block from 820B187Ch-820B1880h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B1880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1880);
		  /* 820B1880h */ case    0:  		/* addi R1, R1, 160 */
		/* 820B1880h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820B1880h case    0:*/		return 0x820B1884;
		  /* 820B1884h */ case    1:  		/* b -132576 */
		/* 820B1884h case    1:*/		return 0x820912A4;
		/* 820B1884h case    1:*/		return 0x820B1888;
	}
	return 0x820B1888;
} // Block from 820B1880h-820B1888h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B1888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1888);
		  /* 820B1888h */ case    0:  		/* mfspr R12, LR */
		/* 820B1888h case    0:*/		regs.R12 = regs.LR;
		/* 820B1888h case    0:*/		return 0x820B188C;
		  /* 820B188Ch */ case    1:  		/* bl -132680 */
		/* 820B188Ch case    1:*/		regs.LR = 0x820B1890; return 0x82091244;
		/* 820B188Ch case    1:*/		return 0x820B1890;
		  /* 820B1890h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 820B1890h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 820B1890h case    2:*/		return 0x820B1894;
		  /* 820B1894h */ case    3:  		/* li R23, 0 */
		/* 820B1894h case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820B1894h case    3:*/		return 0x820B1898;
		  /* 820B1898h */ case    4:  		/* mr R30, R3 */
		/* 820B1898h case    4:*/		regs.R30 = regs.R3;
		/* 820B1898h case    4:*/		return 0x820B189C;
		  /* 820B189Ch */ case    5:  		/* mr R31, R4 */
		/* 820B189Ch case    5:*/		regs.R31 = regs.R4;
		/* 820B189Ch case    5:*/		return 0x820B18A0;
		  /* 820B18A0h */ case    6:  		/* stw R23, <#[R1 + 160]> */
		/* 820B18A0h case    6:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B18A0h case    6:*/		return 0x820B18A4;
		  /* 820B18A4h */ case    7:  		/* mr R26, R5 */
		/* 820B18A4h case    7:*/		regs.R26 = regs.R5;
		/* 820B18A4h case    7:*/		return 0x820B18A8;
		  /* 820B18A8h */ case    8:  		/* stw R23, <#[R1 + 168]> */
		/* 820B18A8h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000A8) );
		/* 820B18A8h case    8:*/		return 0x820B18AC;
		  /* 820B18ACh */ case    9:  		/* mr R29, R6 */
		/* 820B18ACh case    9:*/		regs.R29 = regs.R6;
		/* 820B18ACh case    9:*/		return 0x820B18B0;
		  /* 820B18B0h */ case   10:  		/* mr R25, R7 */
		/* 820B18B0h case   10:*/		regs.R25 = regs.R7;
		/* 820B18B0h case   10:*/		return 0x820B18B4;
		  /* 820B18B4h */ case   11:  		/* mr R27, R8 */
		/* 820B18B4h case   11:*/		regs.R27 = regs.R8;
		/* 820B18B4h case   11:*/		return 0x820B18B8;
		  /* 820B18B8h */ case   12:  		/* mr R24, R9 */
		/* 820B18B8h case   12:*/		regs.R24 = regs.R9;
		/* 820B18B8h case   12:*/		return 0x820B18BC;
		  /* 820B18BCh */ case   13:  		/* mr R28, R10 */
		/* 820B18BCh case   13:*/		regs.R28 = regs.R10;
		/* 820B18BCh case   13:*/		return 0x820B18C0;
		  /* 820B18C0h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 820B18C0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B18C0h case   14:*/		return 0x820B18C4;
		  /* 820B18C4h */ case   15:  		/* bc 4, CR6_EQ, 8 */
		/* 820B18C4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820B18CC;  }
		/* 820B18C4h case   15:*/		return 0x820B18C8;
		  /* 820B18C8h */ case   16:  		/* addi R28, R1, 168 */
		/* 820B18C8h case   16:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0xA8);
		/* 820B18C8h case   16:*/		return 0x820B18CC;
	}
	return 0x820B18CC;
} // Block from 820B1888h-820B18CCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B18CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B18CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B18CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B18CC);
		  /* 820B18CCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820B18CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B18CCh case    0:*/		return 0x820B18D0;
		  /* 820B18D0h */ case    1:  		/* bc 12, CR6_EQ, 672 */
		/* 820B18D0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B1B70;  }
		/* 820B18D0h case    1:*/		return 0x820B18D4;
		  /* 820B18D4h */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 820B18D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820B18D4h case    2:*/		return 0x820B18D8;
		  /* 820B18D8h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 820B18D8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820B18D8h case    3:*/		return 0x820B18DC;
		  /* 820B18DCh */ case    4:  		/* bc 12, CR6_EQ, 532 */
		/* 820B18DCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820B1AF0;  }
		/* 820B18DCh case    4:*/		return 0x820B18E0;
		  /* 820B18E0h */ case    5:  		/* cmpwi CR6, R11, 6 */
		/* 820B18E0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820B18E0h case    5:*/		return 0x820B18E4;
		  /* 820B18E4h */ case    6:  		/* bc 12, CR6_EQ, 476 */
		/* 820B18E4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820B1AC0;  }
		/* 820B18E4h case    6:*/		return 0x820B18E8;
		  /* 820B18E8h */ case    7:  		/* cmpwi CR6, R11, 8 */
		/* 820B18E8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 820B18E8h case    7:*/		return 0x820B18EC;
		  /* 820B18ECh */ case    8:  		/* bc 12, CR6_EQ, 256 */
		/* 820B18ECh case    8:*/		if ( regs.CR[6].eq ) { return 0x820B19EC;  }
		/* 820B18ECh case    8:*/		return 0x820B18F0;
		  /* 820B18F0h */ case    9:  		/* cmpwi CR6, R11, 9 */
		/* 820B18F0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 820B18F0h case    9:*/		return 0x820B18F4;
		  /* 820B18F4h */ case   10:  		/* bc 12, CR6_EQ, 104 */
		/* 820B18F4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B195C;  }
		/* 820B18F4h case   10:*/		return 0x820B18F8;
		  /* 820B18F8h */ case   11:  		/* cmpwi CR6, R11, 11 */
		/* 820B18F8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820B18F8h case   11:*/		return 0x820B18FC;
		  /* 820B18FCh */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 820B18FCh case   12:*/		if ( regs.CR[6].eq ) { return 0x820B191C;  }
		/* 820B18FCh case   12:*/		return 0x820B1900;
		  /* 820B1900h */ case   13:  		/* lis R11, -32255 */
		/* 820B1900h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B1900h case   13:*/		return 0x820B1904;
		  /* 820B1904h */ case   14:  		/* li R5, 0 */
		/* 820B1904h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1904h case   14:*/		return 0x820B1908;
		  /* 820B1908h */ case   15:  		/* addi R6, R11, 8564 */
		/* 820B1908h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2174);
		/* 820B1908h case   15:*/		return 0x820B190C;
		  /* 820B190Ch */ case   16:  		/* li R4, 0 */
		/* 820B190Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B190Ch case   16:*/		return 0x820B1910;
		  /* 820B1910h */ case   17:  		/* mr R3, R30 */
		/* 820B1910h case   17:*/		regs.R3 = regs.R30;
		/* 820B1910h case   17:*/		return 0x820B1914;
		  /* 820B1914h */ case   18:  		/* bl -3876 */
		/* 820B1914h case   18:*/		regs.LR = 0x820B1918; return 0x820B09F0;
		/* 820B1914h case   18:*/		return 0x820B1918;
		  /* 820B1918h */ case   19:  		/* b 600 */
		/* 820B1918h case   19:*/		return 0x820B1B70;
		/* 820B1918h case   19:*/		return 0x820B191C;
	}
	return 0x820B191C;
} // Block from 820B18CCh-820B191Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820B191Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B191C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B191C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B191C);
		  /* 820B191Ch */ case    0:  		/* lwz R3, <#[R31 + 60]> */
		/* 820B191Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 820B191Ch case    0:*/		return 0x820B1920;
		  /* 820B1920h */ case    1:  		/* addi R7, R1, 160 */
		/* 820B1920h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xA0);
		/* 820B1920h case    1:*/		return 0x820B1924;
		  /* 820B1924h */ case    2:  		/* lwz R11, <#[R31 + 64]> */
		/* 820B1924h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820B1924h case    2:*/		return 0x820B1928;
		  /* 820B1928h */ case    3:  		/* mr R10, R28 */
		/* 820B1928h case    3:*/		regs.R10 = regs.R28;
		/* 820B1928h case    3:*/		return 0x820B192C;
		  /* 820B192Ch */ case    4:  		/* stw R7, <#[R1 + 100]> */
		/* 820B192Ch case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000064) );
		/* 820B192Ch case    4:*/		return 0x820B1930;
		  /* 820B1930h */ case    5:  		/* mr R9, R24 */
		/* 820B1930h case    5:*/		regs.R9 = regs.R24;
		/* 820B1930h case    5:*/		return 0x820B1934;
		  /* 820B1934h */ case    6:  		/* mr R8, R27 */
		/* 820B1934h case    6:*/		regs.R8 = regs.R27;
		/* 820B1934h case    6:*/		return 0x820B1938;
		  /* 820B1938h */ case    7:  		/* lwz R4, <#[R31 + 48]> */
		/* 820B1938h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000030) );
		/* 820B1938h case    7:*/		return 0x820B193C;
		  /* 820B193Ch */ case    8:  		/* mr R7, R25 */
		/* 820B193Ch case    8:*/		regs.R7 = regs.R25;
		/* 820B193Ch case    8:*/		return 0x820B1940;
		  /* 820B1940h */ case    9:  		/* stw R3, <#[R1 + 84]> */
		/* 820B1940h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820B1940h case    9:*/		return 0x820B1944;
		  /* 820B1944h */ case   10:  		/* mr R6, R29 */
		/* 820B1944h case   10:*/		regs.R6 = regs.R29;
		/* 820B1944h case   10:*/		return 0x820B1948;
		  /* 820B1948h */ case   11:  		/* mr R5, R26 */
		/* 820B1948h case   11:*/		regs.R5 = regs.R26;
		/* 820B1948h case   11:*/		return 0x820B194C;
		  /* 820B194Ch */ case   12:  		/* stw R11, <#[R1 + 92]> */
		/* 820B194Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B194Ch case   12:*/		return 0x820B1950;
		  /* 820B1950h */ case   13:  		/* mr R3, R30 */
		/* 820B1950h case   13:*/		regs.R3 = regs.R30;
		/* 820B1950h case   13:*/		return 0x820B1954;
		  /* 820B1954h */ case   14:  		/* bl 11308 */
		/* 820B1954h case   14:*/		regs.LR = 0x820B1958; return 0x820B4580;
		/* 820B1954h case   14:*/		return 0x820B1958;
		  /* 820B1958h */ case   15:  		/* b 136 */
		/* 820B1958h case   15:*/		return 0x820B19E0;
		/* 820B1958h case   15:*/		return 0x820B195C;
	}
	return 0x820B195C;
} // Block from 820B191Ch-820B195Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B195Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B195C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B195C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B195C);
		  /* 820B195Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 820B195Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820B195Ch case    0:*/		return 0x820B1960;
		  /* 820B1960h */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 820B1960h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820B1960h case    1:*/		return 0x820B1964;
		  /* 820B1964h */ case    2:  		/* bc 4, CR6_EQ, 76 */
		/* 820B1964h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B19B0;  }
		/* 820B1964h case    2:*/		return 0x820B1968;
		  /* 820B1968h */ case    3:  		/* cmpwi CR6, R27, 0 */
		/* 820B1968h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820B1968h case    3:*/		return 0x820B196C;
		  /* 820B196Ch */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 820B196Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820B1994;  }
		/* 820B196Ch case    4:*/		return 0x820B1970;
		  /* 820B1970h */ case    5:  		/* lis R11, -32255 */
		/* 820B1970h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B1970h case    5:*/		return 0x820B1974;
		  /* 820B1974h */ case    6:  		/* lwz R3, <#[R30 + 8]> */
		/* 820B1974h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820B1974h case    6:*/		return 0x820B1978;
		  /* 820B1978h */ case    7:  		/* li R7, 4 */
		/* 820B1978h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820B1978h case    7:*/		return 0x820B197C;
		  /* 820B197Ch */ case    8:  		/* addi R4, R11, -8796 */
		/* 820B197Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDA4);
		/* 820B197Ch case    8:*/		return 0x820B1980;
		  /* 820B1980h */ case    9:  		/* li R6, -1 */
		/* 820B1980h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820B1980h case    9:*/		return 0x820B1984;
		  /* 820B1984h */ case   10:  		/* li R5, 721 */
		/* 820B1984h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x2D1);
		/* 820B1984h case   10:*/		return 0x820B1988;
		  /* 820B1988h */ case   11:  		/* bl 309248 */
		/* 820B1988h case   11:*/		regs.LR = 0x820B198C; return 0x820FD188;
		/* 820B1988h case   11:*/		return 0x820B198C;
		  /* 820B198Ch */ case   12:  		/* mr R29, R3 */
		/* 820B198Ch case   12:*/		regs.R29 = regs.R3;
		/* 820B198Ch case   12:*/		return 0x820B1990;
		  /* 820B1990h */ case   13:  		/* b 32 */
		/* 820B1990h case   13:*/		return 0x820B19B0;
		/* 820B1990h case   13:*/		return 0x820B1994;
	}
	return 0x820B1994;
} // Block from 820B195Ch-820B1994h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820B1994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1994);
		  /* 820B1994h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B1994h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B1994h case    0:*/		return 0x820B1998;
		  /* 820B1998h */ case    1:  		/* rlwinm R10, R29, 2, 0, 29 */
		/* 820B1998h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R29);
		/* 820B1998h case    1:*/		return 0x820B199C;
		  /* 820B199Ch */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B199Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B199Ch case    2:*/		return 0x820B19A0;
		  /* 820B19A0h */ case    3:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B19A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B19A0h case    3:*/		return 0x820B19A4;
		  /* 820B19A4h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B19A4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B19A4h case    4:*/		return 0x820B19A8;
		  /* 820B19A8h */ case    5:  		/* ori R10, R10, 128 */
		/* 820B19A8h case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x80);
		/* 820B19A8h case    5:*/		return 0x820B19AC;
		  /* 820B19ACh */ case    6:  		/* stw R10, <#[R11 + 4]> */
		/* 820B19ACh case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B19ACh case    6:*/		return 0x820B19B0;
	}
	return 0x820B19B0;
} // Block from 820B1994h-820B19B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B19B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B19B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B19B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B19B0);
		  /* 820B19B0h */ case    0:  		/* addi R11, R1, 160 */
		/* 820B19B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 820B19B0h case    0:*/		return 0x820B19B4;
		  /* 820B19B4h */ case    1:  		/* stw R24, <#[R1 + 84]> */
		/* 820B19B4h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 820B19B4h case    1:*/		return 0x820B19B8;
		  /* 820B19B8h */ case    2:  		/* mr R10, R28 */
		/* 820B19B8h case    2:*/		regs.R10 = regs.R28;
		/* 820B19B8h case    2:*/		return 0x820B19BC;
		  /* 820B19BCh */ case    3:  		/* lwz R7, <#[R31 + 36]> */
		/* 820B19BCh case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000024) );
		/* 820B19BCh case    3:*/		return 0x820B19C0;
		  /* 820B19C0h */ case    4:  		/* stw R11, <#[R1 + 92]> */
		/* 820B19C0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B19C0h case    4:*/		return 0x820B19C4;
		  /* 820B19C4h */ case    5:  		/* mr R9, R29 */
		/* 820B19C4h case    5:*/		regs.R9 = regs.R29;
		/* 820B19C4h case    5:*/		return 0x820B19C8;
		  /* 820B19C8h */ case    6:  		/* mr R8, R26 */
		/* 820B19C8h case    6:*/		regs.R8 = regs.R26;
		/* 820B19C8h case    6:*/		return 0x820B19CC;
		  /* 820B19CCh */ case    7:  		/* lwz R6, <#[R31 + 32]> */
		/* 820B19CCh case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000020) );
		/* 820B19CCh case    7:*/		return 0x820B19D0;
		  /* 820B19D0h */ case    8:  		/* mr R3, R30 */
		/* 820B19D0h case    8:*/		regs.R3 = regs.R30;
		/* 820B19D0h case    8:*/		return 0x820B19D4;
		  /* 820B19D4h */ case    9:  		/* lwz R5, <#[R31 + 28]> */
		/* 820B19D4h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000001C) );
		/* 820B19D4h case    9:*/		return 0x820B19D8;
		  /* 820B19D8h */ case   10:  		/* lwz R4, <#[R31 + 16]> */
		/* 820B19D8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 820B19D8h case   10:*/		return 0x820B19DC;
		  /* 820B19DCh */ case   11:  		/* bl -13092 */
		/* 820B19DCh case   11:*/		regs.LR = 0x820B19E0; return 0x820AE6B8;
		/* 820B19DCh case   11:*/		return 0x820B19E0;
	}
	return 0x820B19E0;
} // Block from 820B19B0h-820B19E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B19E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B19E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B19E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B19E0);
		  /* 820B19E0h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820B19E0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B19E0h case    0:*/		return 0x820B19E4;
		  /* 820B19E4h */ case    1:  		/* bc 4, CR0_LT, 396 */
		/* 820B19E4h case    1:*/		if ( !regs.CR[0].lt ) { return 0x820B1B70;  }
		/* 820B19E4h case    1:*/		return 0x820B19E8;
		  /* 820B19E8h */ case    2:  		/* b 416 */
		/* 820B19E8h case    2:*/		return 0x820B1B88;
		/* 820B19E8h case    2:*/		return 0x820B19EC;
	}
	return 0x820B19EC;
} // Block from 820B19E0h-820B19ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B19ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B19EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B19EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B19EC);
		  /* 820B19ECh */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 820B19ECh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820B19ECh case    0:*/		return 0x820B19F0;
		  /* 820B19F0h */ case    1:  		/* bc 4, CR6_EQ, 100 */
		/* 820B19F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B1A54;  }
		/* 820B19F0h case    1:*/		return 0x820B19F4;
		  /* 820B19F4h */ case    2:  		/* mr R11, R31 */
		/* 820B19F4h case    2:*/		regs.R11 = regs.R31;
		/* 820B19F4h case    2:*/		return 0x820B19F8;
		  /* 820B19F8h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B19F8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B19F8h case    3:*/		return 0x820B19FC;
		  /* 820B19FCh */ case    4:  		/* cmpwi CR6, R10, 8 */
		/* 820B19FCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000008);
		/* 820B19FCh case    4:*/		return 0x820B1A00;
		  /* 820B1A00h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 820B1A00h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820B1A10;  }
		/* 820B1A00h case    5:*/		return 0x820B1A04;
		  /* 820B1A04h */ case    6:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B1A04h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B1A04h case    6:*/		return 0x820B1A08;
		  /* 820B1A08h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820B1A08h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B1A08h case    7:*/		return 0x820B1A0C;
		  /* 820B1A0Ch */ case    8:  		/* bc 4, CR6_EQ, -20 */
		/* 820B1A0Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820B19F8;  }
		/* 820B1A0Ch case    8:*/		return 0x820B1A10;
	}
	return 0x820B1A10;
} // Block from 820B19ECh-820B1A10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B1A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1A10);
		  /* 820B1A10h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820B1A10h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B1A10h case    0:*/		return 0x820B1A14;
		  /* 820B1A14h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820B1A14h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B1A54;  }
		/* 820B1A14h case    1:*/		return 0x820B1A18;
		  /* 820B1A18h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B1A18h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B1A18h case    2:*/		return 0x820B1A1C;
		  /* 820B1A1Ch */ case    3:  		/* cmpwi CR6, R10, 9 */
		/* 820B1A1Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 820B1A1Ch case    3:*/		return 0x820B1A20;
		  /* 820B1A20h */ case    4:  		/* bc 4, CR6_EQ, 52 */
		/* 820B1A20h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820B1A54;  }
		/* 820B1A20h case    4:*/		return 0x820B1A24;
		  /* 820B1A24h */ case    5:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B1A24h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B1A24h case    5:*/		return 0x820B1A28;
		  /* 820B1A28h */ case    6:  		/* cmpwi CR6, R11, 3 */
		/* 820B1A28h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820B1A28h case    6:*/		return 0x820B1A2C;
		  /* 820B1A2Ch */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 820B1A2Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820B1A54;  }
		/* 820B1A2Ch case    7:*/		return 0x820B1A30;
		  /* 820B1A30h */ case    8:  		/* lis R11, -32255 */
		/* 820B1A30h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B1A30h case    8:*/		return 0x820B1A34;
		  /* 820B1A34h */ case    9:  		/* lwz R3, <#[R30 + 8]> */
		/* 820B1A34h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820B1A34h case    9:*/		return 0x820B1A38;
		  /* 820B1A38h */ case   10:  		/* li R7, 4 */
		/* 820B1A38h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 820B1A38h case   10:*/		return 0x820B1A3C;
		  /* 820B1A3Ch */ case   11:  		/* addi R4, R11, -8796 */
		/* 820B1A3Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDA4);
		/* 820B1A3Ch case   11:*/		return 0x820B1A40;
		  /* 820B1A40h */ case   12:  		/* li R6, -1 */
		/* 820B1A40h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820B1A40h case   12:*/		return 0x820B1A44;
		  /* 820B1A44h */ case   13:  		/* li R5, 721 */
		/* 820B1A44h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x2D1);
		/* 820B1A44h case   13:*/		return 0x820B1A48;
		  /* 820B1A48h */ case   14:  		/* bl 309056 */
		/* 820B1A48h case   14:*/		regs.LR = 0x820B1A4C; return 0x820FD188;
		/* 820B1A48h case   14:*/		return 0x820B1A4C;
		  /* 820B1A4Ch */ case   15:  		/* mr R29, R3 */
		/* 820B1A4Ch case   15:*/		regs.R29 = regs.R3;
		/* 820B1A4Ch case   15:*/		return 0x820B1A50;
		  /* 820B1A50h */ case   16:  		/* li R27, 1 */
		/* 820B1A50h case   16:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820B1A50h case   16:*/		return 0x820B1A54;
	}
	return 0x820B1A54;
} // Block from 820B1A10h-820B1A54h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B1A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1A54);
		  /* 820B1A54h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 820B1A54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820B1A54h case    0:*/		return 0x820B1A58;
		  /* 820B1A58h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820B1A58h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B1A58h case    1:*/		return 0x820B1A5C;
		  /* 820B1A5Ch */ case    2:  		/* bc 4, CR6_GT, 276 */
		/* 820B1A5Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x820B1B70;  }
		/* 820B1A5Ch case    2:*/		return 0x820B1A60;
		  /* 820B1A60h */ case    3:  		/* lwz R11, <#[R1 + 160]> */
		/* 820B1A60h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B1A60h case    3:*/		return 0x820B1A64;
		  /* 820B1A64h */ case    4:  		/* addi R9, R1, 164 */
		/* 820B1A64h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xA4);
		/* 820B1A64h case    4:*/		return 0x820B1A68;
		  /* 820B1A68h */ case    5:  		/* mr R10, R28 */
		/* 820B1A68h case    5:*/		regs.R10 = regs.R28;
		/* 820B1A68h case    5:*/		return 0x820B1A6C;
		  /* 820B1A6Ch */ case    6:  		/* lwz R4, <#[R31 + 16]> */
		/* 820B1A6Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 820B1A6Ch case    6:*/		return 0x820B1A70;
		  /* 820B1A70h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B1A70h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B1A70h case    7:*/		return 0x820B1A74;
		  /* 820B1A74h */ case    8:  		/* stw R9, <#[R1 + 84]> */
		/* 820B1A74h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 820B1A74h case    8:*/		return 0x820B1A78;
		  /* 820B1A78h */ case    9:  		/* mr R9, R24 */
		/* 820B1A78h case    9:*/		regs.R9 = regs.R24;
		/* 820B1A78h case    9:*/		return 0x820B1A7C;
		  /* 820B1A7Ch */ case   10:  		/* mr R8, R27 */
		/* 820B1A7Ch case   10:*/		regs.R8 = regs.R27;
		/* 820B1A7Ch case   10:*/		return 0x820B1A80;
		  /* 820B1A80h */ case   11:  		/* mr R7, R25 */
		/* 820B1A80h case   11:*/		regs.R7 = regs.R25;
		/* 820B1A80h case   11:*/		return 0x820B1A84;
		  /* 820B1A84h */ case   12:  		/* mr R6, R29 */
		/* 820B1A84h case   12:*/		regs.R6 = regs.R29;
		/* 820B1A84h case   12:*/		return 0x820B1A88;
		  /* 820B1A88h */ case   13:  		/* add R5, R11, R26 */
		/* 820B1A88h case   13:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R26);
		/* 820B1A88h case   13:*/		return 0x820B1A8C;
		  /* 820B1A8Ch */ case   14:  		/* mr R3, R30 */
		/* 820B1A8Ch case   14:*/		regs.R3 = regs.R30;
		/* 820B1A8Ch case   14:*/		return 0x820B1A90;
		  /* 820B1A90h */ case   15:  		/* bl -520 */
		/* 820B1A90h case   15:*/		regs.LR = 0x820B1A94; return 0x820B1888;
		/* 820B1A90h case   15:*/		return 0x820B1A94;
		  /* 820B1A94h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820B1A94h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B1A94h case   16:*/		return 0x820B1A98;
		  /* 820B1A98h */ case   17:  		/* bc 12, CR0_LT, 240 */
		/* 820B1A98h case   17:*/		if ( regs.CR[0].lt ) { return 0x820B1B88;  }
		/* 820B1A98h case   17:*/		return 0x820B1A9C;
		  /* 820B1A9Ch */ case   18:  		/* lwz R10, <#[R1 + 160]> */
		/* 820B1A9Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B1A9Ch case   18:*/		return 0x820B1AA0;
		  /* 820B1AA0h */ case   19:  		/* addi R23, R23, 1 */
		/* 820B1AA0h case   19:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820B1AA0h case   19:*/		return 0x820B1AA4;
		  /* 820B1AA4h */ case   20:  		/* lwz R11, <#[R1 + 164]> */
		/* 820B1AA4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B1AA4h case   20:*/		return 0x820B1AA8;
		  /* 820B1AA8h */ case   21:  		/* lwz R9, <#[R31 + 20]> */
		/* 820B1AA8h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 820B1AA8h case   21:*/		return 0x820B1AAC;
		  /* 820B1AACh */ case   22:  		/* add R11, R11, R10 */
		/* 820B1AACh case   22:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820B1AACh case   22:*/		return 0x820B1AB0;
		  /* 820B1AB0h */ case   23:  		/* cmplw CR6, R23, R9 */
		/* 820B1AB0h case   23:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R9);
		/* 820B1AB0h case   23:*/		return 0x820B1AB4;
		  /* 820B1AB4h */ case   24:  		/* stw R11, <#[R1 + 160]> */
		/* 820B1AB4h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B1AB4h case   24:*/		return 0x820B1AB8;
		  /* 820B1AB8h */ case   25:  		/* bc 12, CR6_LT, -88 */
		/* 820B1AB8h case   25:*/		if ( regs.CR[6].lt ) { return 0x820B1A60;  }
		/* 820B1AB8h case   25:*/		return 0x820B1ABC;
		  /* 820B1ABCh */ case   26:  		/* b 180 */
		/* 820B1ABCh case   26:*/		return 0x820B1B70;
		/* 820B1ABCh case   26:*/		return 0x820B1AC0;
	}
	return 0x820B1AC0;
} // Block from 820B1A54h-820B1AC0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820B1AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1AC0);
		  /* 820B1AC0h */ case    0:  		/* addi R11, R1, 160 */
		/* 820B1AC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 820B1AC0h case    0:*/		return 0x820B1AC4;
		  /* 820B1AC4h */ case    1:  		/* lwz R4, <#[R31 + 24]> */
		/* 820B1AC4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820B1AC4h case    1:*/		return 0x820B1AC8;
		  /* 820B1AC8h */ case    2:  		/* mr R10, R28 */
		/* 820B1AC8h case    2:*/		regs.R10 = regs.R28;
		/* 820B1AC8h case    2:*/		return 0x820B1ACC;
		  /* 820B1ACCh */ case    3:  		/* mr R9, R24 */
		/* 820B1ACCh case    3:*/		regs.R9 = regs.R24;
		/* 820B1ACCh case    3:*/		return 0x820B1AD0;
		  /* 820B1AD0h */ case    4:  		/* stw R11, <#[R1 + 84]> */
		/* 820B1AD0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820B1AD0h case    4:*/		return 0x820B1AD4;
		  /* 820B1AD4h */ case    5:  		/* mr R8, R27 */
		/* 820B1AD4h case    5:*/		regs.R8 = regs.R27;
		/* 820B1AD4h case    5:*/		return 0x820B1AD8;
		  /* 820B1AD8h */ case    6:  		/* mr R7, R25 */
		/* 820B1AD8h case    6:*/		regs.R7 = regs.R25;
		/* 820B1AD8h case    6:*/		return 0x820B1ADC;
		  /* 820B1ADCh */ case    7:  		/* mr R6, R29 */
		/* 820B1ADCh case    7:*/		regs.R6 = regs.R29;
		/* 820B1ADCh case    7:*/		return 0x820B1AE0;
		  /* 820B1AE0h */ case    8:  		/* mr R5, R26 */
		/* 820B1AE0h case    8:*/		regs.R5 = regs.R26;
		/* 820B1AE0h case    8:*/		return 0x820B1AE4;
		  /* 820B1AE4h */ case    9:  		/* mr R3, R30 */
		/* 820B1AE4h case    9:*/		regs.R3 = regs.R30;
		/* 820B1AE4h case    9:*/		return 0x820B1AE8;
		  /* 820B1AE8h */ case   10:  		/* bl -608 */
		/* 820B1AE8h case   10:*/		regs.LR = 0x820B1AEC; return 0x820B1888;
		/* 820B1AE8h case   10:*/		return 0x820B1AEC;
		  /* 820B1AECh */ case   11:  		/* b -268 */
		/* 820B1AECh case   11:*/		return 0x820B19E0;
		/* 820B1AECh case   11:*/		return 0x820B1AF0;
	}
	return 0x820B1AF0;
} // Block from 820B1AC0h-820B1AF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B1AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1AF0);
		  /* 820B1AF0h */ case    0:  		/* addi R11, R1, 164 */
		/* 820B1AF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA4);
		/* 820B1AF0h case    0:*/		return 0x820B1AF4;
		  /* 820B1AF4h */ case    1:  		/* lwz R4, <#[R31 + 8]> */
		/* 820B1AF4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 820B1AF4h case    1:*/		return 0x820B1AF8;
		  /* 820B1AF8h */ case    2:  		/* mr R10, R28 */
		/* 820B1AF8h case    2:*/		regs.R10 = regs.R28;
		/* 820B1AF8h case    2:*/		return 0x820B1AFC;
		  /* 820B1AFCh */ case    3:  		/* mr R9, R24 */
		/* 820B1AFCh case    3:*/		regs.R9 = regs.R24;
		/* 820B1AFCh case    3:*/		return 0x820B1B00;
		  /* 820B1B00h */ case    4:  		/* stw R11, <#[R1 + 84]> */
		/* 820B1B00h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820B1B00h case    4:*/		return 0x820B1B04;
		  /* 820B1B04h */ case    5:  		/* mr R8, R27 */
		/* 820B1B04h case    5:*/		regs.R8 = regs.R27;
		/* 820B1B04h case    5:*/		return 0x820B1B08;
		  /* 820B1B08h */ case    6:  		/* mr R7, R25 */
		/* 820B1B08h case    6:*/		regs.R7 = regs.R25;
		/* 820B1B08h case    6:*/		return 0x820B1B0C;
		  /* 820B1B0Ch */ case    7:  		/* mr R6, R29 */
		/* 820B1B0Ch case    7:*/		regs.R6 = regs.R29;
		/* 820B1B0Ch case    7:*/		return 0x820B1B10;
		  /* 820B1B10h */ case    8:  		/* mr R5, R26 */
		/* 820B1B10h case    8:*/		regs.R5 = regs.R26;
		/* 820B1B10h case    8:*/		return 0x820B1B14;
		  /* 820B1B14h */ case    9:  		/* mr R3, R30 */
		/* 820B1B14h case    9:*/		regs.R3 = regs.R30;
		/* 820B1B14h case    9:*/		return 0x820B1B18;
		  /* 820B1B18h */ case   10:  		/* bl -656 */
		/* 820B1B18h case   10:*/		regs.LR = 0x820B1B1C; return 0x820B1888;
		/* 820B1B18h case   10:*/		return 0x820B1B1C;
		  /* 820B1B1Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820B1B1Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B1B1Ch case   11:*/		return 0x820B1B20;
		  /* 820B1B20h */ case   12:  		/* bc 12, CR0_LT, 104 */
		/* 820B1B20h case   12:*/		if ( regs.CR[0].lt ) { return 0x820B1B88;  }
		/* 820B1B20h case   12:*/		return 0x820B1B24;
		  /* 820B1B24h */ case   13:  		/* addi R11, R1, 172 */
		/* 820B1B24h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xAC);
		/* 820B1B24h case   13:*/		return 0x820B1B28;
		  /* 820B1B28h */ case   14:  		/* lwz R9, <#[R1 + 164]> */
		/* 820B1B28h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B1B28h case   14:*/		return 0x820B1B2C;
		  /* 820B1B2Ch */ case   15:  		/* mr R10, R28 */
		/* 820B1B2Ch case   15:*/		regs.R10 = regs.R28;
		/* 820B1B2Ch case   15:*/		return 0x820B1B30;
		  /* 820B1B30h */ case   16:  		/* lwz R4, <#[R31 + 12]> */
		/* 820B1B30h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 820B1B30h case   16:*/		return 0x820B1B34;
		  /* 820B1B34h */ case   17:  		/* stw R11, <#[R1 + 84]> */
		/* 820B1B34h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820B1B34h case   17:*/		return 0x820B1B38;
		  /* 820B1B38h */ case   18:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 820B1B38h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 820B1B38h case   18:*/		return 0x820B1B3C;
		  /* 820B1B3Ch */ case   19:  		/* mr R9, R24 */
		/* 820B1B3Ch case   19:*/		regs.R9 = regs.R24;
		/* 820B1B3Ch case   19:*/		return 0x820B1B40;
		  /* 820B1B40h */ case   20:  		/* mr R8, R27 */
		/* 820B1B40h case   20:*/		regs.R8 = regs.R27;
		/* 820B1B40h case   20:*/		return 0x820B1B44;
		  /* 820B1B44h */ case   21:  		/* mr R7, R25 */
		/* 820B1B44h case   21:*/		regs.R7 = regs.R25;
		/* 820B1B44h case   21:*/		return 0x820B1B48;
		  /* 820B1B48h */ case   22:  		/* mr R6, R29 */
		/* 820B1B48h case   22:*/		regs.R6 = regs.R29;
		/* 820B1B48h case   22:*/		return 0x820B1B4C;
		  /* 820B1B4Ch */ case   23:  		/* add R5, R11, R26 */
		/* 820B1B4Ch case   23:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R26);
		/* 820B1B4Ch case   23:*/		return 0x820B1B50;
		  /* 820B1B50h */ case   24:  		/* mr R3, R30 */
		/* 820B1B50h case   24:*/		regs.R3 = regs.R30;
		/* 820B1B50h case   24:*/		return 0x820B1B54;
		  /* 820B1B54h */ case   25:  		/* bl -716 */
		/* 820B1B54h case   25:*/		regs.LR = 0x820B1B58; return 0x820B1888;
		/* 820B1B54h case   25:*/		return 0x820B1B58;
		  /* 820B1B58h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 820B1B58h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B1B58h case   26:*/		return 0x820B1B5C;
		  /* 820B1B5Ch */ case   27:  		/* bc 12, CR0_LT, 44 */
		/* 820B1B5Ch case   27:*/		if ( regs.CR[0].lt ) { return 0x820B1B88;  }
		/* 820B1B5Ch case   27:*/		return 0x820B1B60;
		  /* 820B1B60h */ case   28:  		/* lwz R10, <#[R1 + 164]> */
		/* 820B1B60h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B1B60h case   28:*/		return 0x820B1B64;
		  /* 820B1B64h */ case   29:  		/* lwz R11, <#[R1 + 172]> */
		/* 820B1B64h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000AC) );
		/* 820B1B64h case   29:*/		return 0x820B1B68;
		  /* 820B1B68h */ case   30:  		/* add R11, R11, R10 */
		/* 820B1B68h case   30:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820B1B68h case   30:*/		return 0x820B1B6C;
		  /* 820B1B6Ch */ case   31:  		/* stw R11, <#[R1 + 160]> */
		/* 820B1B6Ch case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B1B6Ch case   31:*/		return 0x820B1B70;
	}
	return 0x820B1B70;
} // Block from 820B1AF0h-820B1B70h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820B1B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1B70);
		  /* 820B1B70h */ case    0:  		/* lwz R11, <#[R1 + 340]> */
		/* 820B1B70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000154) );
		/* 820B1B70h case    0:*/		return 0x820B1B74;
		  /* 820B1B74h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820B1B74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B1B74h case    1:*/		return 0x820B1B78;
		  /* 820B1B78h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820B1B78h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B1B84;  }
		/* 820B1B78h case    2:*/		return 0x820B1B7C;
		  /* 820B1B7Ch */ case    3:  		/* lwz R10, <#[R1 + 160]> */
		/* 820B1B7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B1B7Ch case    3:*/		return 0x820B1B80;
		  /* 820B1B80h */ case    4:  		/* stw R10, <#[R11]> */
		/* 820B1B80h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820B1B80h case    4:*/		return 0x820B1B84;
	}
	return 0x820B1B84;
} // Block from 820B1B70h-820B1B84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B1B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1B84);
		  /* 820B1B84h */ case    0:  		/* li R3, 0 */
		/* 820B1B84h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B1B84h case    0:*/		return 0x820B1B88;
	}
	return 0x820B1B88;
} // Block from 820B1B84h-820B1B88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B1B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1B88);
		  /* 820B1B88h */ case    0:  		/* addi R1, R1, 256 */
		/* 820B1B88h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 820B1B88h case    0:*/		return 0x820B1B8C;
		  /* 820B1B8Ch */ case    1:  		/* b -133368 */
		/* 820B1B8Ch case    1:*/		return 0x82091294;
		/* 820B1B8Ch case    1:*/		return 0x820B1B90;
	}
	return 0x820B1B90;
} // Block from 820B1B88h-820B1B90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B1B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1B90);
		  /* 820B1B90h */ case    0:  		/* mfspr R12, LR */
		/* 820B1B90h case    0:*/		regs.R12 = regs.LR;
		/* 820B1B90h case    0:*/		return 0x820B1B94;
		  /* 820B1B94h */ case    1:  		/* bl -133492 */
		/* 820B1B94h case    1:*/		regs.LR = 0x820B1B98; return 0x82091220;
		/* 820B1B94h case    1:*/		return 0x820B1B98;
		  /* 820B1B98h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 820B1B98h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820B1B98h case    2:*/		return 0x820B1B9C;
		  /* 820B1B9Ch */ case    3:  		/* stwu R1, <#[R1 - 528]> */
		/* 820B1B9Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFDF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFDF0);
		/* 820B1B9Ch case    3:*/		return 0x820B1BA0;
		  /* 820B1BA0h */ case    4:  		/* li R23, 0 */
		/* 820B1BA0h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 820B1BA0h case    4:*/		return 0x820B1BA4;
		  /* 820B1BA4h */ case    5:  		/* stw R6, <#[R1 + 572]> */
		/* 820B1BA4h case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000023C) );
		/* 820B1BA4h case    5:*/		return 0x820B1BA8;
		  /* 820B1BA8h */ case    6:  		/* mr R29, R3 */
		/* 820B1BA8h case    6:*/		regs.R29 = regs.R3;
		/* 820B1BA8h case    6:*/		return 0x820B1BAC;
		  /* 820B1BACh */ case    7:  		/* stw R7, <#[R1 + 580]> */
		/* 820B1BACh case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000244) );
		/* 820B1BACh case    7:*/		return 0x820B1BB0;
		  /* 820B1BB0h */ case    8:  		/* mr R22, R4 */
		/* 820B1BB0h case    8:*/		regs.R22 = regs.R4;
		/* 820B1BB0h case    8:*/		return 0x820B1BB4;
		  /* 820B1BB4h */ case    9:  		/* stw R23, <#[R1 + 96]> */
		/* 820B1BB4h case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000060) );
		/* 820B1BB4h case    9:*/		return 0x820B1BB8;
		  /* 820B1BB8h */ case   10:  		/* mr R28, R5 */
		/* 820B1BB8h case   10:*/		regs.R28 = regs.R5;
		/* 820B1BB8h case   10:*/		return 0x820B1BBC;
		  /* 820B1BBCh */ case   11:  		/* mr R18, R6 */
		/* 820B1BBCh case   11:*/		regs.R18 = regs.R6;
		/* 820B1BBCh case   11:*/		return 0x820B1BC0;
		  /* 820B1BC0h */ case   12:  		/* mr R19, R7 */
		/* 820B1BC0h case   12:*/		regs.R19 = regs.R7;
		/* 820B1BC0h case   12:*/		return 0x820B1BC4;
		  /* 820B1BC4h */ case   13:  		/* mr R31, R8 */
		/* 820B1BC4h case   13:*/		regs.R31 = regs.R8;
		/* 820B1BC4h case   13:*/		return 0x820B1BC8;
		  /* 820B1BC8h */ case   14:  		/* li R9, 1 */
		/* 820B1BC8h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820B1BC8h case   14:*/		return 0x820B1BCC;
		  /* 820B1BCCh */ case   15:  		/* li R11, 1 */
		/* 820B1BCCh case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820B1BCCh case   15:*/		return 0x820B1BD0;
		  /* 820B1BD0h */ case   16:  		/* cmplwi CR6, R8, 1 */
		/* 820B1BD0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 820B1BD0h case   16:*/		return 0x820B1BD4;
		  /* 820B1BD4h */ case   17:  		/* bc 4, CR6_GT, 48 */
		/* 820B1BD4h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820B1C04;  }
		/* 820B1BD4h case   17:*/		return 0x820B1BD8;
		  /* 820B1BD8h */ case   18:  		/* lwz R8, <#[R5]> */
		/* 820B1BD8h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 820B1BD8h case   18:*/		return 0x820B1BDC;
		  /* 820B1BDCh */ case   19:  		/* addi R10, R5, 4 */
		/* 820B1BDCh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x4);
		/* 820B1BDCh case   19:*/		return 0x820B1BE0;
		  /* 820B1BE0h */ case   20:  		/* lwz R7, <#[R10]> */
		/* 820B1BE0h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820B1BE0h case   20:*/		return 0x820B1BE4;
		  /* 820B1BE4h */ case   21:  		/* cmplw CR6, R7, R8 */
		/* 820B1BE4h case   21:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820B1BE4h case   21:*/		return 0x820B1BE8;
		  /* 820B1BE8h */ case   22:  		/* bc 4, CR6_EQ, 24 */
		/* 820B1BE8h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820B1C00;  }
		/* 820B1BE8h case   22:*/		return 0x820B1BEC;
		  /* 820B1BECh */ case   23:  		/* addi R11, R11, 1 */
		/* 820B1BECh case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B1BECh case   23:*/		return 0x820B1BF0;
		  /* 820B1BF0h */ case   24:  		/* addi R10, R10, 4 */
		/* 820B1BF0h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820B1BF0h case   24:*/		return 0x820B1BF4;
		  /* 820B1BF4h */ case   25:  		/* cmplw CR6, R11, R31 */
		/* 820B1BF4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820B1BF4h case   25:*/		return 0x820B1BF8;
		  /* 820B1BF8h */ case   26:  		/* bc 12, CR6_LT, -24 */
		/* 820B1BF8h case   26:*/		if ( regs.CR[6].lt ) { return 0x820B1BE0;  }
		/* 820B1BF8h case   26:*/		return 0x820B1BFC;
		  /* 820B1BFCh */ case   27:  		/* b 8 */
		/* 820B1BFCh case   27:*/		return 0x820B1C04;
		/* 820B1BFCh case   27:*/		return 0x820B1C00;
	}
	return 0x820B1C00;
} // Block from 820B1B90h-820B1C00h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820B1C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1C00);
		  /* 820B1C00h */ case    0:  		/* mr R9, R23 */
		/* 820B1C00h case    0:*/		regs.R9 = regs.R23;
		/* 820B1C00h case    0:*/		return 0x820B1C04;
	}
	return 0x820B1C04;
} // Block from 820B1C00h-820B1C04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B1C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1C04);
		  /* 820B1C04h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B1C04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1C04h case    0:*/		return 0x820B1C08;
		  /* 820B1C08h */ case    1:  		/* lwz R11, <#[R11 + 108]> */
		/* 820B1C08h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000006C) );
		/* 820B1C08h case    1:*/		return 0x820B1C0C;
		  /* 820B1C0Ch */ case    2:  		/* rlwinm. R10, R11, 0, 10, 10 */
		/* 820B1C0Ch case    2:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R10,regs.R11);
		/* 820B1C0Ch case    2:*/		return 0x820B1C10;
		  /* 820B1C10h */ case    3:  		/* bc 12, CR0_EQ, 124 */
		/* 820B1C10h case    3:*/		if ( regs.CR[0].eq ) { return 0x820B1C8C;  }
		/* 820B1C10h case    3:*/		return 0x820B1C14;
		  /* 820B1C14h */ case    4:  		/* cmplwi CR6, R18, 0 */
		/* 820B1C14h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 820B1C14h case    4:*/		return 0x820B1C18;
		  /* 820B1C18h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 820B1C18h case    5:*/		if ( regs.CR[6].eq ) { return 0x820B1C4C;  }
		/* 820B1C18h case    5:*/		return 0x820B1C1C;
		  /* 820B1C1Ch */ case    6:  		/* li R11, 33 */
		/* 820B1C1Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x21);
		/* 820B1C1Ch case    6:*/		return 0x820B1C20;
		  /* 820B1C20h */ case    7:  		/* mr R5, R31 */
		/* 820B1C20h case    7:*/		regs.R5 = regs.R31;
		/* 820B1C20h case    7:*/		return 0x820B1C24;
		  /* 820B1C24h */ case    8:  		/* li R9, 16 */
		/* 820B1C24h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820B1C24h case    8:*/		return 0x820B1C28;
		  /* 820B1C28h */ case    9:  		/* rlwimi R5, R11, 23, 0, 11 */
		/* 820B1C28h case    9:*/		cpu::op::rlwimi<0,23,0,11>(regs,&regs.R5,regs.R11);
		/* 820B1C28h case    9:*/		return 0x820B1C2C;
		  /* 820B1C2Ch */ case   10:  		/* li R8, 0 */
		/* 820B1C2Ch case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B1C2Ch case   10:*/		return 0x820B1C30;
		  /* 820B1C30h */ case   11:  		/* mr R7, R28 */
		/* 820B1C30h case   11:*/		regs.R7 = regs.R28;
		/* 820B1C30h case   11:*/		return 0x820B1C34;
		  /* 820B1C34h */ case   12:  		/* mr R6, R18 */
		/* 820B1C34h case   12:*/		regs.R6 = regs.R18;
		/* 820B1C34h case   12:*/		return 0x820B1C38;
		  /* 820B1C38h */ case   13:  		/* mr R4, R22 */
		/* 820B1C38h case   13:*/		regs.R4 = regs.R22;
		/* 820B1C38h case   13:*/		return 0x820B1C3C;
		  /* 820B1C3Ch */ case   14:  		/* mr R3, R29 */
		/* 820B1C3Ch case   14:*/		regs.R3 = regs.R29;
		/* 820B1C3Ch case   14:*/		return 0x820B1C40;
		  /* 820B1C40h */ case   15:  		/* bl -4408 */
		/* 820B1C40h case   15:*/		regs.LR = 0x820B1C44; return 0x820B0B08;
		/* 820B1C40h case   15:*/		return 0x820B1C44;
		  /* 820B1C44h */ case   16:  		/* or. R30, R3, R3 */
		/* 820B1C44h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1C44h case   16:*/		return 0x820B1C48;
		  /* 820B1C48h */ case   17:  		/* bc 12, CR0_LT, 2360 */
		/* 820B1C48h case   17:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1C48h case   17:*/		return 0x820B1C4C;
	}
	return 0x820B1C4C;
} // Block from 820B1C04h-820B1C4Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820B1C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1C4C);
		  /* 820B1C4Ch */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 820B1C4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820B1C4Ch case    0:*/		return 0x820B1C50;
		  /* 820B1C50h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 820B1C50h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B1C84;  }
		/* 820B1C50h case    1:*/		return 0x820B1C54;
		  /* 820B1C54h */ case    2:  		/* li R11, 265 */
		/* 820B1C54h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x109);
		/* 820B1C54h case    2:*/		return 0x820B1C58;
		  /* 820B1C58h */ case    3:  		/* mr R5, R31 */
		/* 820B1C58h case    3:*/		regs.R5 = regs.R31;
		/* 820B1C58h case    3:*/		return 0x820B1C5C;
		  /* 820B1C5Ch */ case    4:  		/* li R9, 16 */
		/* 820B1C5Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820B1C5Ch case    4:*/		return 0x820B1C60;
		  /* 820B1C60h */ case    5:  		/* rlwimi R5, R11, 20, 0, 11 */
		/* 820B1C60h case    5:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R5,regs.R11);
		/* 820B1C60h case    5:*/		return 0x820B1C64;
		  /* 820B1C64h */ case    6:  		/* li R8, 0 */
		/* 820B1C64h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B1C64h case    6:*/		return 0x820B1C68;
		  /* 820B1C68h */ case    7:  		/* mr R7, R28 */
		/* 820B1C68h case    7:*/		regs.R7 = regs.R28;
		/* 820B1C68h case    7:*/		return 0x820B1C6C;
		  /* 820B1C6Ch */ case    8:  		/* mr R6, R19 */
		/* 820B1C6Ch case    8:*/		regs.R6 = regs.R19;
		/* 820B1C6Ch case    8:*/		return 0x820B1C70;
		  /* 820B1C70h */ case    9:  		/* mr R4, R22 */
		/* 820B1C70h case    9:*/		regs.R4 = regs.R22;
		/* 820B1C70h case    9:*/		return 0x820B1C74;
		  /* 820B1C74h */ case   10:  		/* mr R3, R29 */
		/* 820B1C74h case   10:*/		regs.R3 = regs.R29;
		/* 820B1C74h case   10:*/		return 0x820B1C78;
		  /* 820B1C78h */ case   11:  		/* bl -4464 */
		/* 820B1C78h case   11:*/		regs.LR = 0x820B1C7C; return 0x820B0B08;
		/* 820B1C78h case   11:*/		return 0x820B1C7C;
		  /* 820B1C7Ch */ case   12:  		/* or. R30, R3, R3 */
		/* 820B1C7Ch case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1C7Ch case   12:*/		return 0x820B1C80;
		  /* 820B1C80h */ case   13:  		/* bc 12, CR0_LT, 2304 */
		/* 820B1C80h case   13:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1C80h case   13:*/		return 0x820B1C84;
	}
	return 0x820B1C84;
} // Block from 820B1C4Ch-820B1C84h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820B1C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1C84);
		  /* 820B1C84h */ case    0:  		/* mr R30, R23 */
		/* 820B1C84h case    0:*/		regs.R30 = regs.R23;
		/* 820B1C84h case    0:*/		return 0x820B1C88;
		  /* 820B1C88h */ case    1:  		/* b 2296 */
		/* 820B1C88h case    1:*/		return 0x820B2580;
		/* 820B1C88h case    1:*/		return 0x820B1C8C;
	}
	return 0x820B1C8C;
} // Block from 820B1C84h-820B1C8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B1C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1C8C);
		  /* 820B1C8Ch */ case    0:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 820B1C8Ch case    0:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 820B1C8Ch case    0:*/		return 0x820B1C90;
		  /* 820B1C90h */ case    1:  		/* bc 12, CR0_EQ, 648 */
		/* 820B1C90h case    1:*/		if ( regs.CR[0].eq ) { return 0x820B1F18;  }
		/* 820B1C90h case    1:*/		return 0x820B1C94;
		  /* 820B1C94h */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 820B1C94h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820B1C94h case    2:*/		return 0x820B1C98;
		  /* 820B1C98h */ case    3:  		/* bc 12, CR6_EQ, 640 */
		/* 820B1C98h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B1F18;  }
		/* 820B1C98h case    3:*/		return 0x820B1C9C;
		  /* 820B1C9Ch */ case    4:  		/* lwz R3, <#[R29 + 8]> */
		/* 820B1C9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1C9Ch case    4:*/		return 0x820B1CA0;
		  /* 820B1CA0h */ case    5:  		/* lis R11, -32255 */
		/* 820B1CA0h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B1CA0h case    5:*/		return 0x820B1CA4;
		  /* 820B1CA4h */ case    6:  		/* li R6, 0 */
		/* 820B1CA4h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1CA4h case    6:*/		return 0x820B1CA8;
		  /* 820B1CA8h */ case    7:  		/* li R5, 0 */
		/* 820B1CA8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1CA8h case    7:*/		return 0x820B1CAC;
		  /* 820B1CACh */ case    8:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B1CACh case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B1CACh case    8:*/		return 0x820B1CB0;
		  /* 820B1CB0h */ case    9:  		/* lfd FR1, <#[R11 + 8656]> */
		/* 820B1CB0h case    9:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x000021D0) );
		/* 820B1CB0h case    9:*/		return 0x820B1CB4;
		  /* 820B1CB4h */ case   10:  		/* bl 308596 */
		/* 820B1CB4h case   10:*/		regs.LR = 0x820B1CB8; return 0x820FD228;
		/* 820B1CB4h case   10:*/		return 0x820B1CB8;
		  /* 820B1CB8h */ case   11:  		/* stw R3, <#[R1 + 80]> */
		/* 820B1CB8h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820B1CB8h case   11:*/		return 0x820B1CBC;
		  /* 820B1CBCh */ case   12:  		/* lwz R3, <#[R29 + 8]> */
		/* 820B1CBCh case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1CBCh case   12:*/		return 0x820B1CC0;
		  /* 820B1CC0h */ case   13:  		/* lis R11, -32256 */
		/* 820B1CC0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820B1CC0h case   13:*/		return 0x820B1CC4;
		  /* 820B1CC4h */ case   14:  		/* li R6, 0 */
		/* 820B1CC4h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1CC4h case   14:*/		return 0x820B1CC8;
		  /* 820B1CC8h */ case   15:  		/* li R5, 0 */
		/* 820B1CC8h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1CC8h case   15:*/		return 0x820B1CCC;
		  /* 820B1CCCh */ case   16:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B1CCCh case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B1CCCh case   16:*/		return 0x820B1CD0;
		  /* 820B1CD0h */ case   17:  		/* lfd FR1, <#[R11 + 4736]> */
		/* 820B1CD0h case   17:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00001280) );
		/* 820B1CD0h case   17:*/		return 0x820B1CD4;
		  /* 820B1CD4h */ case   18:  		/* bl 308564 */
		/* 820B1CD4h case   18:*/		regs.LR = 0x820B1CD8; return 0x820FD228;
		/* 820B1CD4h case   18:*/		return 0x820B1CD8;
		  /* 820B1CD8h */ case   19:  		/* stw R3, <#[R1 + 84]> */
		/* 820B1CD8h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820B1CD8h case   19:*/		return 0x820B1CDC;
		  /* 820B1CDCh */ case   20:  		/* lwz R3, <#[R29 + 8]> */
		/* 820B1CDCh case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1CDCh case   20:*/		return 0x820B1CE0;
		  /* 820B1CE0h */ case   21:  		/* lis R11, -32255 */
		/* 820B1CE0h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B1CE0h case   21:*/		return 0x820B1CE4;
		  /* 820B1CE4h */ case   22:  		/* li R6, 0 */
		/* 820B1CE4h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1CE4h case   22:*/		return 0x820B1CE8;
		  /* 820B1CE8h */ case   23:  		/* li R5, 0 */
		/* 820B1CE8h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1CE8h case   23:*/		return 0x820B1CEC;
		  /* 820B1CECh */ case   24:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B1CECh case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B1CECh case   24:*/		return 0x820B1CF0;
		  /* 820B1CF0h */ case   25:  		/* lfd FR1, <#[R11 + 8648]> */
		/* 820B1CF0h case   25:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x000021C8) );
		/* 820B1CF0h case   25:*/		return 0x820B1CF4;
		  /* 820B1CF4h */ case   26:  		/* bl 308532 */
		/* 820B1CF4h case   26:*/		regs.LR = 0x820B1CF8; return 0x820FD228;
		/* 820B1CF4h case   26:*/		return 0x820B1CF8;
		  /* 820B1CF8h */ case   27:  		/* stw R3, <#[R1 + 88]> */
		/* 820B1CF8h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 820B1CF8h case   27:*/		return 0x820B1CFC;
		  /* 820B1CFCh */ case   28:  		/* lis R11, -32255 */
		/* 820B1CFCh case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B1CFCh case   28:*/		return 0x820B1D00;
		  /* 820B1D00h */ case   29:  		/* lwz R3, <#[R29 + 8]> */
		/* 820B1D00h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1D00h case   29:*/		return 0x820B1D04;
		  /* 820B1D04h */ case   30:  		/* li R6, 0 */
		/* 820B1D04h case   30:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1D04h case   30:*/		return 0x820B1D08;
		  /* 820B1D08h */ case   31:  		/* li R5, 0 */
		/* 820B1D08h case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1D08h case   31:*/		return 0x820B1D0C;
		  /* 820B1D0Ch */ case   32:  		/* lfd FR31, <#[R11 + 8080]> */
		/* 820B1D0Ch case   32:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00001F90) );
		/* 820B1D0Ch case   32:*/		return 0x820B1D10;
		  /* 820B1D10h */ case   33:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B1D10h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B1D10h case   33:*/		return 0x820B1D14;
		  /* 820B1D14h */ case   34:  		/* fmr FR1, FR31 */
		/* 820B1D14h case   34:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820B1D14h case   34:*/		return 0x820B1D18;
		  /* 820B1D18h */ case   35:  		/* bl 308496 */
		/* 820B1D18h case   35:*/		regs.LR = 0x820B1D1C; return 0x820FD228;
		/* 820B1D18h case   35:*/		return 0x820B1D1C;
		  /* 820B1D1Ch */ case   36:  		/* stw R3, <#[R1 + 92]> */
		/* 820B1D1Ch case   36:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B1D1Ch case   36:*/		return 0x820B1D20;
		  /* 820B1D20h */ case   37:  		/* addi R5, R1, 304 */
		/* 820B1D20h case   37:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x130);
		/* 820B1D20h case   37:*/		return 0x820B1D24;
		  /* 820B1D24h */ case   38:  		/* mr R3, R29 */
		/* 820B1D24h case   38:*/		regs.R3 = regs.R29;
		/* 820B1D24h case   38:*/		return 0x820B1D28;
		  /* 820B1D28h */ case   39:  		/* lwz R4, <#[R28]> */
		/* 820B1D28h case   39:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820B1D28h case   39:*/		return 0x820B1D2C;
		  /* 820B1D2Ch */ case   40:  		/* bl -12044 */
		/* 820B1D2Ch case   40:*/		regs.LR = 0x820B1D30; return 0x820AEE20;
		/* 820B1D2Ch case   40:*/		return 0x820B1D30;
		  /* 820B1D30h */ case   41:  		/* or. R30, R3, R3 */
		/* 820B1D30h case   41:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1D30h case   41:*/		return 0x820B1D34;
		  /* 820B1D34h */ case   42:  		/* bc 12, CR0_LT, 2124 */
		/* 820B1D34h case   42:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1D34h case   42:*/		return 0x820B1D38;
		  /* 820B1D38h */ case   43:  		/* lfd FR0, <#[R1 + 304]> */
		/* 820B1D38h case   43:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000130) );
		/* 820B1D38h case   43:*/		return 0x820B1D3C;
		  /* 820B1D3Ch */ case   44:  		/* li R27, -1 */
		/* 820B1D3Ch case   44:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 820B1D3Ch case   44:*/		return 0x820B1D40;
		  /* 820B1D40h */ case   45:  		/* fcmpu CR6, FR0, FR31 */
		/* 820B1D40h case   45:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820B1D40h case   45:*/		return 0x820B1D44;
		  /* 820B1D44h */ case   46:  		/* bc 12, CR6_LT, 36 */
		/* 820B1D44h case   46:*/		if ( regs.CR[6].lt ) { return 0x820B1D68;  }
		/* 820B1D44h case   46:*/		return 0x820B1D48;
		  /* 820B1D48h */ case   47:  		/* lis R11, -32255 */
		/* 820B1D48h case   47:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B1D48h case   47:*/		return 0x820B1D4C;
		  /* 820B1D4Ch */ case   48:  		/* lfd FR13, <#[R1 + 312]> */
		/* 820B1D4Ch case   48:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000138) );
		/* 820B1D4Ch case   48:*/		return 0x820B1D50;
		  /* 820B1D50h */ case   49:  		/* lfd FR0, <#[R11 + 8088]> */
		/* 820B1D50h case   49:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001F98) );
		/* 820B1D50h case   49:*/		return 0x820B1D54;
		  /* 820B1D54h */ case   50:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B1D54h case   50:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B1D54h case   50:*/		return 0x820B1D58;
		  /* 820B1D58h */ case   51:  		/* bc 12, CR6_GT, 16 */
		/* 820B1D58h case   51:*/		if ( regs.CR[6].gt ) { return 0x820B1D68;  }
		/* 820B1D58h case   51:*/		return 0x820B1D5C;
		  /* 820B1D5Ch */ case   52:  		/* lwz R10, <#[R28]> */
		/* 820B1D5Ch case   52:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820B1D5Ch case   52:*/		return 0x820B1D60;
		  /* 820B1D60h */ case   53:  		/* stw R10, <#[R1 + 128]> */
		/* 820B1D60h case   53:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820B1D60h case   53:*/		return 0x820B1D64;
		  /* 820B1D64h */ case   54:  		/* b 256 */
		/* 820B1D64h case   54:*/		return 0x820B1E64;
		/* 820B1D64h case   54:*/		return 0x820B1D68;
	}
	return 0x820B1D68;
} // Block from 820B1C8Ch-820B1D68h (55 instructions)

//////////////////////////////////////////////////////
// Block at 820B1D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1D68);
		  /* 820B1D68h */ case    0:  		/* addi R10, R1, 112 */
		/* 820B1D68h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 820B1D68h case    0:*/		return 0x820B1D6C;
		  /* 820B1D6Ch */ case    1:  		/* lis R5, 8272 */
		/* 820B1D6Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R5,0x2050);
		/* 820B1D6Ch case    1:*/		return 0x820B1D70;
		  /* 820B1D70h */ case    2:  		/* li R9, 0 */
		/* 820B1D70h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B1D70h case    2:*/		return 0x820B1D74;
		  /* 820B1D74h */ case    3:  		/* addi R8, R1, 80 */
		/* 820B1D74h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 820B1D74h case    3:*/		return 0x820B1D78;
		  /* 820B1D78h */ case    4:  		/* mr R7, R28 */
		/* 820B1D78h case    4:*/		regs.R7 = regs.R28;
		/* 820B1D78h case    4:*/		return 0x820B1D7C;
		  /* 820B1D7Ch */ case    5:  		/* stw R27, <#[R10]> */
		/* 820B1D7Ch case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x00000000) );
		/* 820B1D7Ch case    5:*/		return 0x820B1D80;
		  /* 820B1D80h */ case    6:  		/* addi R6, R1, 112 */
		/* 820B1D80h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 820B1D80h case    6:*/		return 0x820B1D84;
		  /* 820B1D84h */ case    7:  		/* stw R27, <#[R10 + 4]> */
		/* 820B1D84h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x00000004) );
		/* 820B1D84h case    7:*/		return 0x820B1D88;
		  /* 820B1D88h */ case    8:  		/* ori R5, R5, 1 */
		/* 820B1D88h case    8:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B1D88h case    8:*/		return 0x820B1D8C;
		  /* 820B1D8Ch */ case    9:  		/* stw R27, <#[R10 + 8]> */
		/* 820B1D8Ch case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x00000008) );
		/* 820B1D8Ch case    9:*/		return 0x820B1D90;
		  /* 820B1D90h */ case   10:  		/* mr R4, R22 */
		/* 820B1D90h case   10:*/		regs.R4 = regs.R22;
		/* 820B1D90h case   10:*/		return 0x820B1D94;
		  /* 820B1D94h */ case   11:  		/* stw R27, <#[R10 + 12]> */
		/* 820B1D94h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x0000000C) );
		/* 820B1D94h case   11:*/		return 0x820B1D98;
		  /* 820B1D98h */ case   12:  		/* mr R3, R29 */
		/* 820B1D98h case   12:*/		regs.R3 = regs.R29;
		/* 820B1D98h case   12:*/		return 0x820B1D9C;
		  /* 820B1D9Ch */ case   13:  		/* stw R27, <#[R10 + 16]> */
		/* 820B1D9Ch case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x00000010) );
		/* 820B1D9Ch case   13:*/		return 0x820B1DA0;
		  /* 820B1DA0h */ case   14:  		/* mr R11, R27 */
		/* 820B1DA0h case   14:*/		regs.R11 = regs.R27;
		/* 820B1DA0h case   14:*/		return 0x820B1DA4;
		  /* 820B1DA4h */ case   15:  		/* bl -4764 */
		/* 820B1DA4h case   15:*/		regs.LR = 0x820B1DA8; return 0x820B0B08;
		/* 820B1DA4h case   15:*/		return 0x820B1DA8;
		  /* 820B1DA8h */ case   16:  		/* or. R30, R3, R3 */
		/* 820B1DA8h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1DA8h case   16:*/		return 0x820B1DAC;
		  /* 820B1DACh */ case   17:  		/* bc 12, CR0_LT, 2004 */
		/* 820B1DACh case   17:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1DACh case   17:*/		return 0x820B1DB0;
		  /* 820B1DB0h */ case   18:  		/* lis R5, 8256 */
		/* 820B1DB0h case   18:*/		cpu::op::lis<0>(regs,&regs.R5,0x2040);
		/* 820B1DB0h case   18:*/		return 0x820B1DB4;
		  /* 820B1DB4h */ case   19:  		/* li R9, 0 */
		/* 820B1DB4h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B1DB4h case   19:*/		return 0x820B1DB8;
		  /* 820B1DB8h */ case   20:  		/* addi R8, R1, 84 */
		/* 820B1DB8h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x54);
		/* 820B1DB8h case   20:*/		return 0x820B1DBC;
		  /* 820B1DBCh */ case   21:  		/* addi R7, R1, 112 */
		/* 820B1DBCh case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 820B1DBCh case   21:*/		return 0x820B1DC0;
		  /* 820B1DC0h */ case   22:  		/* addi R6, R1, 116 */
		/* 820B1DC0h case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x74);
		/* 820B1DC0h case   22:*/		return 0x820B1DC4;
		  /* 820B1DC4h */ case   23:  		/* ori R5, R5, 1 */
		/* 820B1DC4h case   23:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B1DC4h case   23:*/		return 0x820B1DC8;
		  /* 820B1DC8h */ case   24:  		/* mr R4, R22 */
		/* 820B1DC8h case   24:*/		regs.R4 = regs.R22;
		/* 820B1DC8h case   24:*/		return 0x820B1DCC;
		  /* 820B1DCCh */ case   25:  		/* mr R3, R29 */
		/* 820B1DCCh case   25:*/		regs.R3 = regs.R29;
		/* 820B1DCCh case   25:*/		return 0x820B1DD0;
		  /* 820B1DD0h */ case   26:  		/* bl -4808 */
		/* 820B1DD0h case   26:*/		regs.LR = 0x820B1DD4; return 0x820B0B08;
		/* 820B1DD0h case   26:*/		return 0x820B1DD4;
		  /* 820B1DD4h */ case   27:  		/* or. R30, R3, R3 */
		/* 820B1DD4h case   27:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1DD4h case   27:*/		return 0x820B1DD8;
		  /* 820B1DD8h */ case   28:  		/* bc 12, CR0_LT, 1960 */
		/* 820B1DD8h case   28:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1DD8h case   28:*/		return 0x820B1DDC;
		  /* 820B1DDCh */ case   29:  		/* lis R5, 4160 */
		/* 820B1DDCh case   29:*/		cpu::op::lis<0>(regs,&regs.R5,0x1040);
		/* 820B1DDCh case   29:*/		return 0x820B1DE0;
		  /* 820B1DE0h */ case   30:  		/* li R9, 20 */
		/* 820B1DE0h case   30:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820B1DE0h case   30:*/		return 0x820B1DE4;
		  /* 820B1DE4h */ case   31:  		/* li R8, 0 */
		/* 820B1DE4h case   31:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B1DE4h case   31:*/		return 0x820B1DE8;
		  /* 820B1DE8h */ case   32:  		/* addi R7, R1, 116 */
		/* 820B1DE8h case   32:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 820B1DE8h case   32:*/		return 0x820B1DEC;
		  /* 820B1DECh */ case   33:  		/* addi R6, R1, 120 */
		/* 820B1DECh case   33:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x78);
		/* 820B1DECh case   33:*/		return 0x820B1DF0;
		  /* 820B1DF0h */ case   34:  		/* ori R5, R5, 1 */
		/* 820B1DF0h case   34:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B1DF0h case   34:*/		return 0x820B1DF4;
		  /* 820B1DF4h */ case   35:  		/* mr R4, R22 */
		/* 820B1DF4h case   35:*/		regs.R4 = regs.R22;
		/* 820B1DF4h case   35:*/		return 0x820B1DF8;
		  /* 820B1DF8h */ case   36:  		/* mr R3, R29 */
		/* 820B1DF8h case   36:*/		regs.R3 = regs.R29;
		/* 820B1DF8h case   36:*/		return 0x820B1DFC;
		  /* 820B1DFCh */ case   37:  		/* bl -4852 */
		/* 820B1DFCh case   37:*/		regs.LR = 0x820B1E00; return 0x820B0B08;
		/* 820B1DFCh case   37:*/		return 0x820B1E00;
		  /* 820B1E00h */ case   38:  		/* or. R30, R3, R3 */
		/* 820B1E00h case   38:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1E00h case   38:*/		return 0x820B1E04;
		  /* 820B1E04h */ case   39:  		/* bc 12, CR0_LT, 1916 */
		/* 820B1E04h case   39:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1E04h case   39:*/		return 0x820B1E08;
		  /* 820B1E08h */ case   40:  		/* lis R5, 8272 */
		/* 820B1E08h case   40:*/		cpu::op::lis<0>(regs,&regs.R5,0x2050);
		/* 820B1E08h case   40:*/		return 0x820B1E0C;
		  /* 820B1E0Ch */ case   41:  		/* li R9, 4 */
		/* 820B1E0Ch case   41:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B1E0Ch case   41:*/		return 0x820B1E10;
		  /* 820B1E10h */ case   42:  		/* addi R8, R1, 88 */
		/* 820B1E10h case   42:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x58);
		/* 820B1E10h case   42:*/		return 0x820B1E14;
		  /* 820B1E14h */ case   43:  		/* addi R7, R1, 120 */
		/* 820B1E14h case   43:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 820B1E14h case   43:*/		return 0x820B1E18;
		  /* 820B1E18h */ case   44:  		/* addi R6, R1, 124 */
		/* 820B1E18h case   44:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x7C);
		/* 820B1E18h case   44:*/		return 0x820B1E1C;
		  /* 820B1E1Ch */ case   45:  		/* ori R5, R5, 1 */
		/* 820B1E1Ch case   45:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B1E1Ch case   45:*/		return 0x820B1E20;
		  /* 820B1E20h */ case   46:  		/* mr R4, R22 */
		/* 820B1E20h case   46:*/		regs.R4 = regs.R22;
		/* 820B1E20h case   46:*/		return 0x820B1E24;
		  /* 820B1E24h */ case   47:  		/* mr R3, R29 */
		/* 820B1E24h case   47:*/		regs.R3 = regs.R29;
		/* 820B1E24h case   47:*/		return 0x820B1E28;
		  /* 820B1E28h */ case   48:  		/* bl -4896 */
		/* 820B1E28h case   48:*/		regs.LR = 0x820B1E2C; return 0x820B0B08;
		/* 820B1E28h case   48:*/		return 0x820B1E2C;
		  /* 820B1E2Ch */ case   49:  		/* or. R30, R3, R3 */
		/* 820B1E2Ch case   49:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1E2Ch case   49:*/		return 0x820B1E30;
		  /* 820B1E30h */ case   50:  		/* bc 12, CR0_LT, 1872 */
		/* 820B1E30h case   50:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1E30h case   50:*/		return 0x820B1E34;
		  /* 820B1E34h */ case   51:  		/* lis R5, 8256 */
		/* 820B1E34h case   51:*/		cpu::op::lis<0>(regs,&regs.R5,0x2040);
		/* 820B1E34h case   51:*/		return 0x820B1E38;
		  /* 820B1E38h */ case   52:  		/* li R9, 0 */
		/* 820B1E38h case   52:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B1E38h case   52:*/		return 0x820B1E3C;
		  /* 820B1E3Ch */ case   53:  		/* addi R8, R1, 92 */
		/* 820B1E3Ch case   53:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x5C);
		/* 820B1E3Ch case   53:*/		return 0x820B1E40;
		  /* 820B1E40h */ case   54:  		/* addi R7, R1, 124 */
		/* 820B1E40h case   54:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x7C);
		/* 820B1E40h case   54:*/		return 0x820B1E44;
		  /* 820B1E44h */ case   55:  		/* addi R6, R1, 128 */
		/* 820B1E44h case   55:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820B1E44h case   55:*/		return 0x820B1E48;
		  /* 820B1E48h */ case   56:  		/* ori R5, R5, 1 */
		/* 820B1E48h case   56:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B1E48h case   56:*/		return 0x820B1E4C;
		  /* 820B1E4Ch */ case   57:  		/* mr R4, R22 */
		/* 820B1E4Ch case   57:*/		regs.R4 = regs.R22;
		/* 820B1E4Ch case   57:*/		return 0x820B1E50;
		  /* 820B1E50h */ case   58:  		/* mr R3, R29 */
		/* 820B1E50h case   58:*/		regs.R3 = regs.R29;
		/* 820B1E50h case   58:*/		return 0x820B1E54;
		  /* 820B1E54h */ case   59:  		/* bl -4940 */
		/* 820B1E54h case   59:*/		regs.LR = 0x820B1E58; return 0x820B0B08;
		/* 820B1E54h case   59:*/		return 0x820B1E58;
		  /* 820B1E58h */ case   60:  		/* or. R30, R3, R3 */
		/* 820B1E58h case   60:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1E58h case   60:*/		return 0x820B1E5C;
		  /* 820B1E5Ch */ case   61:  		/* bc 12, CR0_LT, 1828 */
		/* 820B1E5Ch case   61:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1E5Ch case   61:*/		return 0x820B1E60;
		  /* 820B1E60h */ case   62:  		/* lwz R10, <#[R1 + 128]> */
		/* 820B1E60h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820B1E60h case   62:*/		return 0x820B1E64;
	}
	return 0x820B1E64;
} // Block from 820B1D68h-820B1E64h (63 instructions)

//////////////////////////////////////////////////////
// Block at 820B1E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1E64);
		  /* 820B1E64h */ case    0:  		/* addi R30, R1, 352 */
		/* 820B1E64h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x160);
		/* 820B1E64h case    0:*/		return 0x820B1E68;
		  /* 820B1E68h */ case    1:  		/* addi R28, R1, 336 */
		/* 820B1E68h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x150);
		/* 820B1E68h case    1:*/		return 0x820B1E6C;
		  /* 820B1E6Ch */ case    2:  		/* lis R5, 20528 */
		/* 820B1E6Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R5,0x5030);
		/* 820B1E6Ch case    2:*/		return 0x820B1E70;
		  /* 820B1E70h */ case    3:  		/* li R9, 16 */
		/* 820B1E70h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820B1E70h case    3:*/		return 0x820B1E74;
		  /* 820B1E74h */ case    4:  		/* li R8, 0 */
		/* 820B1E74h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B1E74h case    4:*/		return 0x820B1E78;
		  /* 820B1E78h */ case    5:  		/* stw R27, <#[R30]> */
		/* 820B1E78h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000000) );
		/* 820B1E78h case    5:*/		return 0x820B1E7C;
		  /* 820B1E7Ch */ case    6:  		/* addi R7, R1, 336 */
		/* 820B1E7Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x150);
		/* 820B1E7Ch case    6:*/		return 0x820B1E80;
		  /* 820B1E80h */ case    7:  		/* stw R10, <#[R28]> */
		/* 820B1E80h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820B1E80h case    7:*/		return 0x820B1E84;
		  /* 820B1E84h */ case    8:  		/* addi R6, R1, 352 */
		/* 820B1E84h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x160);
		/* 820B1E84h case    8:*/		return 0x820B1E88;
		  /* 820B1E88h */ case    9:  		/* stw R27, <#[R30 + 4]> */
		/* 820B1E88h case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000004) );
		/* 820B1E88h case    9:*/		return 0x820B1E8C;
		  /* 820B1E8Ch */ case   10:  		/* ori R5, R5, 4 */
		/* 820B1E8Ch case   10:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820B1E8Ch case   10:*/		return 0x820B1E90;
		  /* 820B1E90h */ case   11:  		/* stw R10, <#[R28 + 4]> */
		/* 820B1E90h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 820B1E90h case   11:*/		return 0x820B1E94;
		  /* 820B1E94h */ case   12:  		/* mr R4, R22 */
		/* 820B1E94h case   12:*/		regs.R4 = regs.R22;
		/* 820B1E94h case   12:*/		return 0x820B1E98;
		  /* 820B1E98h */ case   13:  		/* stw R27, <#[R30 + 8]> */
		/* 820B1E98h case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000008) );
		/* 820B1E98h case   13:*/		return 0x820B1E9C;
		  /* 820B1E9Ch */ case   14:  		/* mr R3, R29 */
		/* 820B1E9Ch case   14:*/		regs.R3 = regs.R29;
		/* 820B1E9Ch case   14:*/		return 0x820B1EA0;
		  /* 820B1EA0h */ case   15:  		/* stw R10, <#[R28 + 8]> */
		/* 820B1EA0h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 820B1EA0h case   15:*/		return 0x820B1EA4;
		  /* 820B1EA4h */ case   16:  		/* mr R11, R27 */
		/* 820B1EA4h case   16:*/		regs.R11 = regs.R27;
		/* 820B1EA4h case   16:*/		return 0x820B1EA8;
		  /* 820B1EA8h */ case   17:  		/* stw R27, <#[R30 + 12]> */
		/* 820B1EA8h case   17:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x0000000C) );
		/* 820B1EA8h case   17:*/		return 0x820B1EAC;
		  /* 820B1EACh */ case   18:  		/* stw R10, <#[R28 + 12]> */
		/* 820B1EACh case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x0000000C) );
		/* 820B1EACh case   18:*/		return 0x820B1EB0;
		  /* 820B1EB0h */ case   19:  		/* bl -5032 */
		/* 820B1EB0h case   19:*/		regs.LR = 0x820B1EB4; return 0x820B0B08;
		/* 820B1EB0h case   19:*/		return 0x820B1EB4;
		  /* 820B1EB4h */ case   20:  		/* or. R30, R3, R3 */
		/* 820B1EB4h case   20:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B1EB4h case   20:*/		return 0x820B1EB8;
		  /* 820B1EB8h */ case   21:  		/* bc 12, CR0_LT, 1736 */
		/* 820B1EB8h case   21:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B1EB8h case   21:*/		return 0x820B1EBC;
		  /* 820B1EBCh */ case   22:  		/* cmplwi CR6, R19, 0 */
		/* 820B1EBCh case   22:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820B1EBCh case   22:*/		return 0x820B1EC0;
		  /* 820B1EC0h */ case   23:  		/* bc 12, CR6_EQ, 40 */
		/* 820B1EC0h case   23:*/		if ( regs.CR[6].eq ) { return 0x820B1EE8;  }
		/* 820B1EC0h case   23:*/		return 0x820B1EC4;
		  /* 820B1EC4h */ case   24:  		/* cmplwi CR6, R31, 0 */
		/* 820B1EC4h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B1EC4h case   24:*/		return 0x820B1EC8;
		  /* 820B1EC8h */ case   25:  		/* bc 12, CR6_EQ, 32 */
		/* 820B1EC8h case   25:*/		if ( regs.CR[6].eq ) { return 0x820B1EE8;  }
		/* 820B1EC8h case   25:*/		return 0x820B1ECC;
		  /* 820B1ECCh */ case   26:  		/* lwz R10, <#[R1 + 352]> */
		/* 820B1ECCh case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000160) );
		/* 820B1ECCh case   26:*/		return 0x820B1ED0;
		  /* 820B1ED0h */ case   27:  		/* addi R11, R19, -4 */
		/* 820B1ED0h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R19,0xFFFFFFFC);
		/* 820B1ED0h case   27:*/		return 0x820B1ED4;
		  /* 820B1ED4h */ case   28:  		/* cmplwi CR0, R31, 0 */
		/* 820B1ED4h case   28:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B1ED4h case   28:*/		return 0x820B1ED8;
		  /* 820B1ED8h */ case   29:  		/* bc 12, CR0_EQ, 16 */
		/* 820B1ED8h case   29:*/		if ( regs.CR[0].eq ) { return 0x820B1EE8;  }
		/* 820B1ED8h case   29:*/		return 0x820B1EDC;
		  /* 820B1EDCh */ case   30:  		/* mtspr CTR, R31 */
		/* 820B1EDCh case   30:*/		regs.CTR = regs.R31;
		/* 820B1EDCh case   30:*/		return 0x820B1EE0;
		  /* 820B1EE0h */ case   31:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B1EE0h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B1EE0h case   31:*/		return 0x820B1EE4;
		  /* 820B1EE4h */ case   32:  		/* bc 16, CR0_LT, -4 */
		/* 820B1EE4h case   32:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B1EE0;  }
		/* 820B1EE4h case   32:*/		return 0x820B1EE8;
	}
	return 0x820B1EE8;
} // Block from 820B1E64h-820B1EE8h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820B1EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1EE8);
		  /* 820B1EE8h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 820B1EE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 820B1EE8h case    0:*/		return 0x820B1EEC;
		  /* 820B1EECh */ case    1:  		/* bc 12, CR6_EQ, 1680 */
		/* 820B1EECh case    1:*/		if ( regs.CR[6].eq ) { return 0x820B257C;  }
		/* 820B1EECh case    1:*/		return 0x820B1EF0;
		  /* 820B1EF0h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820B1EF0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B1EF0h case    2:*/		return 0x820B1EF4;
		  /* 820B1EF4h */ case    3:  		/* bc 12, CR6_EQ, 1672 */
		/* 820B1EF4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B257C;  }
		/* 820B1EF4h case    3:*/		return 0x820B1EF8;
		  /* 820B1EF8h */ case    4:  		/* lwz R10, <#[R1 + 356]> */
		/* 820B1EF8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000164) );
		/* 820B1EF8h case    4:*/		return 0x820B1EFC;
		  /* 820B1EFCh */ case    5:  		/* addi R11, R18, -4 */
		/* 820B1EFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R18,0xFFFFFFFC);
		/* 820B1EFCh case    5:*/		return 0x820B1F00;
		  /* 820B1F00h */ case    6:  		/* cmplwi CR0, R31, 0 */
		/* 820B1F00h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B1F00h case    6:*/		return 0x820B1F04;
		  /* 820B1F04h */ case    7:  		/* bc 12, CR0_EQ, 1656 */
		/* 820B1F04h case    7:*/		if ( regs.CR[0].eq ) { return 0x820B257C;  }
		/* 820B1F04h case    7:*/		return 0x820B1F08;
		  /* 820B1F08h */ case    8:  		/* mtspr CTR, R31 */
		/* 820B1F08h case    8:*/		regs.CTR = regs.R31;
		/* 820B1F08h case    8:*/		return 0x820B1F0C;
		  /* 820B1F0Ch */ case    9:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B1F0Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B1F0Ch case    9:*/		return 0x820B1F10;
		  /* 820B1F10h */ case   10:  		/* bc 16, CR0_LT, -4 */
		/* 820B1F10h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B1F0C;  }
		/* 820B1F10h case   10:*/		return 0x820B1F14;
		  /* 820B1F14h */ case   11:  		/* b 1640 */
		/* 820B1F14h case   11:*/		return 0x820B257C;
		/* 820B1F14h case   11:*/		return 0x820B1F18;
	}
	return 0x820B1F18;
} // Block from 820B1EE8h-820B1F18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B1F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B1F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B1F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B1F18);
		  /* 820B1F18h */ case    0:  		/* subfic R11, R18, 0 */
		/* 820B1F18h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R18,0x0);
		/* 820B1F18h case    0:*/		return 0x820B1F1C;
		  /* 820B1F1Ch */ case    1:  		/* lwz R3, <#[R29 + 8]> */
		/* 820B1F1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1F1Ch case    1:*/		return 0x820B1F20;
		  /* 820B1F20h */ case    2:  		/* lis R10, -32255 */
		/* 820B1F20h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B1F20h case    2:*/		return 0x820B1F24;
		  /* 820B1F24h */ case    3:  		/* subfe R11, R11, R11 */
		/* 820B1F24h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820B1F24h case    3:*/		return 0x820B1F28;
		  /* 820B1F28h */ case    4:  		/* subfic R9, R19, 0 */
		/* 820B1F28h case    4:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R19,0x0);
		/* 820B1F28h case    4:*/		return 0x820B1F2C;
		  /* 820B1F2Ch */ case    5:  		/* and R21, R11, R31 */
		/* 820B1F2Ch case    5:*/		cpu::op::and<0>(regs,&regs.R21,regs.R11,regs.R31);
		/* 820B1F2Ch case    5:*/		return 0x820B1F30;
		  /* 820B1F30h */ case    6:  		/* subfe R11, R9, R9 */
		/* 820B1F30h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R9);
		/* 820B1F30h case    6:*/		return 0x820B1F34;
		  /* 820B1F34h */ case    7:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B1F34h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B1F34h case    7:*/		return 0x820B1F38;
		  /* 820B1F38h */ case    8:  		/* li R6, 0 */
		/* 820B1F38h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1F38h case    8:*/		return 0x820B1F3C;
		  /* 820B1F3Ch */ case    9:  		/* lfd FR1, <#[R10 + 8656]> */
		/* 820B1F3Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021D0) );
		/* 820B1F3Ch case    9:*/		return 0x820B1F40;
		  /* 820B1F40h */ case   10:  		/* and R20, R11, R31 */
		/* 820B1F40h case   10:*/		cpu::op::and<0>(regs,&regs.R20,regs.R11,regs.R31);
		/* 820B1F40h case   10:*/		return 0x820B1F44;
		  /* 820B1F44h */ case   11:  		/* stw R21, <#[R1 + 80]> */
		/* 820B1F44h case   11:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 820B1F44h case   11:*/		return 0x820B1F48;
		  /* 820B1F48h */ case   12:  		/* li R5, 0 */
		/* 820B1F48h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1F48h case   12:*/		return 0x820B1F4C;
		  /* 820B1F4Ch */ case   13:  		/* stw R20, <#[R1 + 176]> */
		/* 820B1F4Ch case   13:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x000000B0) );
		/* 820B1F4Ch case   13:*/		return 0x820B1F50;
		  /* 820B1F50h */ case   14:  		/* add R30, R20, R21 */
		/* 820B1F50h case   14:*/		cpu::op::add<0>(regs,&regs.R30,regs.R20,regs.R21);
		/* 820B1F50h case   14:*/		return 0x820B1F54;
		  /* 820B1F54h */ case   15:  		/* bl 307924 */
		/* 820B1F54h case   15:*/		regs.LR = 0x820B1F58; return 0x820FD228;
		/* 820B1F54h case   15:*/		return 0x820B1F58;
		  /* 820B1F58h */ case   16:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B1F58h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1F58h case   16:*/		return 0x820B1F5C;
		  /* 820B1F5Ch */ case   17:  		/* lis R10, -32255 */
		/* 820B1F5Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B1F5Ch case   17:*/		return 0x820B1F60;
		  /* 820B1F60h */ case   18:  		/* stw R3, <#[R1 + 92]> */
		/* 820B1F60h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B1F60h case   18:*/		return 0x820B1F64;
		  /* 820B1F64h */ case   19:  		/* li R6, 0 */
		/* 820B1F64h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1F64h case   19:*/		return 0x820B1F68;
		  /* 820B1F68h */ case   20:  		/* li R5, 0 */
		/* 820B1F68h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1F68h case   20:*/		return 0x820B1F6C;
		  /* 820B1F6Ch */ case   21:  		/* mr R3, R11 */
		/* 820B1F6Ch case   21:*/		regs.R3 = regs.R11;
		/* 820B1F6Ch case   21:*/		return 0x820B1F70;
		  /* 820B1F70h */ case   22:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B1F70h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B1F70h case   22:*/		return 0x820B1F74;
		  /* 820B1F74h */ case   23:  		/* lfd FR1, <#[R10 + 8640]> */
		/* 820B1F74h case   23:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021C0) );
		/* 820B1F74h case   23:*/		return 0x820B1F78;
		  /* 820B1F78h */ case   24:  		/* bl 307888 */
		/* 820B1F78h case   24:*/		regs.LR = 0x820B1F7C; return 0x820FD228;
		/* 820B1F78h case   24:*/		return 0x820B1F7C;
		  /* 820B1F7Ch */ case   25:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B1F7Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1F7Ch case   25:*/		return 0x820B1F80;
		  /* 820B1F80h */ case   26:  		/* lis R10, -32256 */
		/* 820B1F80h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820B1F80h case   26:*/		return 0x820B1F84;
		  /* 820B1F84h */ case   27:  		/* stw R3, <#[R1 + 88]> */
		/* 820B1F84h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 820B1F84h case   27:*/		return 0x820B1F88;
		  /* 820B1F88h */ case   28:  		/* li R6, 0 */
		/* 820B1F88h case   28:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1F88h case   28:*/		return 0x820B1F8C;
		  /* 820B1F8Ch */ case   29:  		/* li R5, 0 */
		/* 820B1F8Ch case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1F8Ch case   29:*/		return 0x820B1F90;
		  /* 820B1F90h */ case   30:  		/* mr R3, R11 */
		/* 820B1F90h case   30:*/		regs.R3 = regs.R11;
		/* 820B1F90h case   30:*/		return 0x820B1F94;
		  /* 820B1F94h */ case   31:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B1F94h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B1F94h case   31:*/		return 0x820B1F98;
		  /* 820B1F98h */ case   32:  		/* lfd FR1, <#[R10 + 4736]> */
		/* 820B1F98h case   32:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00001280) );
		/* 820B1F98h case   32:*/		return 0x820B1F9C;
		  /* 820B1F9Ch */ case   33:  		/* bl 307852 */
		/* 820B1F9Ch case   33:*/		regs.LR = 0x820B1FA0; return 0x820FD228;
		/* 820B1F9Ch case   33:*/		return 0x820B1FA0;
		  /* 820B1FA0h */ case   34:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B1FA0h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1FA0h case   34:*/		return 0x820B1FA4;
		  /* 820B1FA4h */ case   35:  		/* lis R10, -32255 */
		/* 820B1FA4h case   35:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B1FA4h case   35:*/		return 0x820B1FA8;
		  /* 820B1FA8h */ case   36:  		/* stw R3, <#[R1 + 84]> */
		/* 820B1FA8h case   36:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 820B1FA8h case   36:*/		return 0x820B1FAC;
		  /* 820B1FACh */ case   37:  		/* li R6, 0 */
		/* 820B1FACh case   37:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1FACh case   37:*/		return 0x820B1FB0;
		  /* 820B1FB0h */ case   38:  		/* li R5, 0 */
		/* 820B1FB0h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1FB0h case   38:*/		return 0x820B1FB4;
		  /* 820B1FB4h */ case   39:  		/* mr R3, R11 */
		/* 820B1FB4h case   39:*/		regs.R3 = regs.R11;
		/* 820B1FB4h case   39:*/		return 0x820B1FB8;
		  /* 820B1FB8h */ case   40:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B1FB8h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B1FB8h case   40:*/		return 0x820B1FBC;
		  /* 820B1FBCh */ case   41:  		/* lfd FR1, <#[R10 + 8648]> */
		/* 820B1FBCh case   41:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021C8) );
		/* 820B1FBCh case   41:*/		return 0x820B1FC0;
		  /* 820B1FC0h */ case   42:  		/* bl 307816 */
		/* 820B1FC0h case   42:*/		regs.LR = 0x820B1FC4; return 0x820FD228;
		/* 820B1FC0h case   42:*/		return 0x820B1FC4;
		  /* 820B1FC4h */ case   43:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B1FC4h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1FC4h case   43:*/		return 0x820B1FC8;
		  /* 820B1FC8h */ case   44:  		/* lis R10, -32255 */
		/* 820B1FC8h case   44:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B1FC8h case   44:*/		return 0x820B1FCC;
		  /* 820B1FCCh */ case   45:  		/* stw R3, <#[R1 + 168]> */
		/* 820B1FCCh case   45:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000A8) );
		/* 820B1FCCh case   45:*/		return 0x820B1FD0;
		  /* 820B1FD0h */ case   46:  		/* li R6, 0 */
		/* 820B1FD0h case   46:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1FD0h case   46:*/		return 0x820B1FD4;
		  /* 820B1FD4h */ case   47:  		/* li R5, 0 */
		/* 820B1FD4h case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1FD4h case   47:*/		return 0x820B1FD8;
		  /* 820B1FD8h */ case   48:  		/* mr R3, R11 */
		/* 820B1FD8h case   48:*/		regs.R3 = regs.R11;
		/* 820B1FD8h case   48:*/		return 0x820B1FDC;
		  /* 820B1FDCh */ case   49:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B1FDCh case   49:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B1FDCh case   49:*/		return 0x820B1FE0;
		  /* 820B1FE0h */ case   50:  		/* lfd FR1, <#[R10 + 8080]> */
		/* 820B1FE0h case   50:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00001F90) );
		/* 820B1FE0h case   50:*/		return 0x820B1FE4;
		  /* 820B1FE4h */ case   51:  		/* bl 307780 */
		/* 820B1FE4h case   51:*/		regs.LR = 0x820B1FE8; return 0x820FD228;
		/* 820B1FE4h case   51:*/		return 0x820B1FE8;
		  /* 820B1FE8h */ case   52:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B1FE8h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B1FE8h case   52:*/		return 0x820B1FEC;
		  /* 820B1FECh */ case   53:  		/* lis R10, -32255 */
		/* 820B1FECh case   53:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B1FECh case   53:*/		return 0x820B1FF0;
		  /* 820B1FF0h */ case   54:  		/* stw R3, <#[R1 + 172]> */
		/* 820B1FF0h case   54:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000AC) );
		/* 820B1FF0h case   54:*/		return 0x820B1FF4;
		  /* 820B1FF4h */ case   55:  		/* li R6, 0 */
		/* 820B1FF4h case   55:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B1FF4h case   55:*/		return 0x820B1FF8;
		  /* 820B1FF8h */ case   56:  		/* li R5, 0 */
		/* 820B1FF8h case   56:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B1FF8h case   56:*/		return 0x820B1FFC;
		  /* 820B1FFCh */ case   57:  		/* mr R3, R11 */
		/* 820B1FFCh case   57:*/		regs.R3 = regs.R11;
		/* 820B1FFCh case   57:*/		return 0x820B2000;
		  /* 820B2000h */ case   58:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2000h case   58:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2000h case   58:*/		return 0x820B2004;
		  /* 820B2004h */ case   59:  		/* lfd FR1, <#[R10 + 8632]> */
		/* 820B2004h case   59:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021B8) );
		/* 820B2004h case   59:*/		return 0x820B2008;
		  /* 820B2008h */ case   60:  		/* bl 307744 */
		/* 820B2008h case   60:*/		regs.LR = 0x820B200C; return 0x820FD228;
		/* 820B2008h case   60:*/		return 0x820B200C;
		  /* 820B200Ch */ case   61:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B200Ch case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B200Ch case   61:*/		return 0x820B2010;
		  /* 820B2010h */ case   62:  		/* lis R10, -32255 */
		/* 820B2010h case   62:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2010h case   62:*/		return 0x820B2014;
		  /* 820B2014h */ case   63:  		/* stw R3, <#[R1 + 156]> */
		/* 820B2014h case   63:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000009C) );
		/* 820B2014h case   63:*/		return 0x820B2018;
		  /* 820B2018h */ case   64:  		/* li R6, 0 */
		/* 820B2018h case   64:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2018h case   64:*/		return 0x820B201C;
		  /* 820B201Ch */ case   65:  		/* li R5, 0 */
		/* 820B201Ch case   65:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B201Ch case   65:*/		return 0x820B2020;
		  /* 820B2020h */ case   66:  		/* mr R3, R11 */
		/* 820B2020h case   66:*/		regs.R3 = regs.R11;
		/* 820B2020h case   66:*/		return 0x820B2024;
		  /* 820B2024h */ case   67:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2024h case   67:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2024h case   67:*/		return 0x820B2028;
		  /* 820B2028h */ case   68:  		/* lfd FR1, <#[R10 + 8624]> */
		/* 820B2028h case   68:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021B0) );
		/* 820B2028h case   68:*/		return 0x820B202C;
		  /* 820B202Ch */ case   69:  		/* bl 307708 */
		/* 820B202Ch case   69:*/		regs.LR = 0x820B2030; return 0x820FD228;
		/* 820B202Ch case   69:*/		return 0x820B2030;
		  /* 820B2030h */ case   70:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B2030h case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B2030h case   70:*/		return 0x820B2034;
		  /* 820B2034h */ case   71:  		/* lis R10, -32255 */
		/* 820B2034h case   71:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2034h case   71:*/		return 0x820B2038;
		  /* 820B2038h */ case   72:  		/* stw R3, <#[R1 + 152]> */
		/* 820B2038h case   72:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000098) );
		/* 820B2038h case   72:*/		return 0x820B203C;
		  /* 820B203Ch */ case   73:  		/* li R6, 0 */
		/* 820B203Ch case   73:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B203Ch case   73:*/		return 0x820B2040;
		  /* 820B2040h */ case   74:  		/* li R5, 0 */
		/* 820B2040h case   74:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2040h case   74:*/		return 0x820B2044;
		  /* 820B2044h */ case   75:  		/* mr R3, R11 */
		/* 820B2044h case   75:*/		regs.R3 = regs.R11;
		/* 820B2044h case   75:*/		return 0x820B2048;
		  /* 820B2048h */ case   76:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2048h case   76:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2048h case   76:*/		return 0x820B204C;
		  /* 820B204Ch */ case   77:  		/* lfd FR1, <#[R10 + 8616]> */
		/* 820B204Ch case   77:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021A8) );
		/* 820B204Ch case   77:*/		return 0x820B2050;
		  /* 820B2050h */ case   78:  		/* bl 307672 */
		/* 820B2050h case   78:*/		regs.LR = 0x820B2054; return 0x820FD228;
		/* 820B2050h case   78:*/		return 0x820B2054;
		  /* 820B2054h */ case   79:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B2054h case   79:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B2054h case   79:*/		return 0x820B2058;
		  /* 820B2058h */ case   80:  		/* lis R10, -32255 */
		/* 820B2058h case   80:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2058h case   80:*/		return 0x820B205C;
		  /* 820B205Ch */ case   81:  		/* stw R3, <#[R1 + 160]> */
		/* 820B205Ch case   81:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B205Ch case   81:*/		return 0x820B2060;
		  /* 820B2060h */ case   82:  		/* li R6, 0 */
		/* 820B2060h case   82:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2060h case   82:*/		return 0x820B2064;
		  /* 820B2064h */ case   83:  		/* li R5, 0 */
		/* 820B2064h case   83:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2064h case   83:*/		return 0x820B2068;
		  /* 820B2068h */ case   84:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2068h case   84:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2068h case   84:*/		return 0x820B206C;
		  /* 820B206Ch */ case   85:  		/* mr R3, R11 */
		/* 820B206Ch case   85:*/		regs.R3 = regs.R11;
		/* 820B206Ch case   85:*/		return 0x820B2070;
		  /* 820B2070h */ case   86:  		/* lfd FR1, <#[R10 + 8608]> */
		/* 820B2070h case   86:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021A0) );
		/* 820B2070h case   86:*/		return 0x820B2074;
		  /* 820B2074h */ case   87:  		/* bl 307636 */
		/* 820B2074h case   87:*/		regs.LR = 0x820B2078; return 0x820FD228;
		/* 820B2074h case   87:*/		return 0x820B2078;
		  /* 820B2078h */ case   88:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B2078h case   88:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B2078h case   88:*/		return 0x820B207C;
		  /* 820B207Ch */ case   89:  		/* lis R10, -32255 */
		/* 820B207Ch case   89:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B207Ch case   89:*/		return 0x820B2080;
		  /* 820B2080h */ case   90:  		/* stw R3, <#[R1 + 132]> */
		/* 820B2080h case   90:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000084) );
		/* 820B2080h case   90:*/		return 0x820B2084;
		  /* 820B2084h */ case   91:  		/* li R6, 0 */
		/* 820B2084h case   91:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2084h case   91:*/		return 0x820B2088;
		  /* 820B2088h */ case   92:  		/* li R5, 0 */
		/* 820B2088h case   92:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2088h case   92:*/		return 0x820B208C;
		  /* 820B208Ch */ case   93:  		/* mr R3, R11 */
		/* 820B208Ch case   93:*/		regs.R3 = regs.R11;
		/* 820B208Ch case   93:*/		return 0x820B2090;
		  /* 820B2090h */ case   94:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2090h case   94:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2090h case   94:*/		return 0x820B2094;
		  /* 820B2094h */ case   95:  		/* lfd FR1, <#[R10 + 8600]> */
		/* 820B2094h case   95:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00002198) );
		/* 820B2094h case   95:*/		return 0x820B2098;
		  /* 820B2098h */ case   96:  		/* bl 307600 */
		/* 820B2098h case   96:*/		regs.LR = 0x820B209C; return 0x820FD228;
		/* 820B2098h case   96:*/		return 0x820B209C;
		  /* 820B209Ch */ case   97:  		/* stw R3, <#[R1 + 164]> */
		/* 820B209Ch case   97:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B209Ch case   97:*/		return 0x820B20A0;
		  /* 820B20A0h */ case   98:  		/* lis R4, 9345 */
		/* 820B20A0h case   98:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B20A0h case   98:*/		return 0x820B20A4;
		  /* 820B20A4h */ case   99:  		/* mulli R3, R30, 108 */
		/* 820B20A4h case   99:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R30,0x6C);
		/* 820B20A4h case   99:*/		return 0x820B20A8;
		  /* 820B20A8h */ case  100:  		/* bl -171688 */
		/* 820B20A8h case  100:*/		regs.LR = 0x820B20AC; return 0x82088200;
		/* 820B20A8h case  100:*/		return 0x820B20AC;
		  /* 820B20ACh */ case  101:  		/* stw R3, <#[R1 + 96]> */
		/* 820B20ACh case  101:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 820B20ACh case  101:*/		return 0x820B20B0;
		  /* 820B20B0h */ case  102:  		/* cmplwi CR0, R3, 0 */
		/* 820B20B0h case  102:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B20B0h case  102:*/		return 0x820B20B4;
		  /* 820B20B4h */ case  103:  		/* bc 4, CR0_EQ, 16 */
		/* 820B20B4h case  103:*/		if ( !regs.CR[0].eq ) { return 0x820B20C4;  }
		/* 820B20B4h case  103:*/		return 0x820B20B8;
		  /* 820B20B8h */ case  104:  		/* lis R30, -32761 */
		/* 820B20B8h case  104:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820B20B8h case  104:*/		return 0x820B20BC;
		  /* 820B20BCh */ case  105:  		/* ori R30, R30, 14 */
		/* 820B20BCh case  105:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820B20BCh case  105:*/		return 0x820B20C0;
		  /* 820B20C0h */ case  106:  		/* b 1216 */
		/* 820B20C0h case  106:*/		return 0x820B2580;
		/* 820B20C0h case  106:*/		return 0x820B20C4;
	}
	return 0x820B20C4;
} // Block from 820B1F18h-820B20C4h (107 instructions)

//////////////////////////////////////////////////////
// Block at 820B20C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B20C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B20C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B20C4);
		  /* 820B20C4h */ case    0:  		/* li R10, 27 */
		/* 820B20C4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1B);
		/* 820B20C4h case    0:*/		return 0x820B20C8;
		  /* 820B20C8h */ case    1:  		/* addi R11, R1, 192 */
		/* 820B20C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 820B20C8h case    1:*/		return 0x820B20CC;
		  /* 820B20CCh */ case    2:  		/* rlwinm R8, R30, 2, 0, 29 */
		/* 820B20CCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R30);
		/* 820B20CCh case    2:*/		return 0x820B20D0;
		  /* 820B20D0h */ case    3:  		/* addi R9, R11, -4 */
		/* 820B20D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B20D0h case    3:*/		return 0x820B20D4;
		  /* 820B20D4h */ case    4:  		/* mr R11, R3 */
		/* 820B20D4h case    4:*/		regs.R11 = regs.R3;
		/* 820B20D4h case    4:*/		return 0x820B20D8;
	}
	return 0x820B20D8;
} // Block from 820B20C4h-820B20D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B20D8h
// Function '?GetTypeFlags@CCompiler@D3DXShader@@IAAIPAVCNode@2@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B20D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B20D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B20D8);
		  /* 820B20D8h */ case    0:  		/* mtspr CTR, R10 */
		/* 820B20D8h case    0:*/		regs.CTR = regs.R10;
		/* 820B20D8h case    0:*/		return 0x820B20DC;
		  /* 820B20DCh */ case    1:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B20DCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B20DCh case    1:*/		return 0x820B20E0;
		  /* 820B20E0h */ case    2:  		/* add R11, R8, R11 */
		/* 820B20E0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820B20E0h case    2:*/		return 0x820B20E4;
		  /* 820B20E4h */ case    3:  		/* bc 16, CR0_LT, -8 */
		/* 820B20E4h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B20DC;  }
		/* 820B20E4h case    3:*/		return 0x820B20E8;
		  /* 820B20E8h */ case    4:  		/* addi R9, R1, 192 */
		/* 820B20E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xC0);
		/* 820B20E8h case    4:*/		return 0x820B20EC;
		  /* 820B20ECh */ case    5:  		/* li R8, 15 */
		/* 820B20ECh case    5:*/		cpu::op::li<0>(regs,&regs.R8,0xF);
		/* 820B20ECh case    5:*/		return 0x820B20F0;
		  /* 820B20F0h */ case    6:  		/* li R27, -1 */
		/* 820B20F0h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 820B20F0h case    6:*/		return 0x820B20F4;
		  /* 820B20F4h */ case    7:  		/* lwz R11, <#[R9]> */
		/* 820B20F4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820B20F4h case    7:*/		return 0x820B20F8;
		  /* 820B20F8h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 820B20F8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B20F8h case    8:*/		return 0x820B20FC;
		  /* 820B20FCh */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 820B20FCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820B211C;  }
		/* 820B20FCh case    9:*/		return 0x820B2100;
		  /* 820B2100h */ case   10:  		/* addi R11, R11, -4 */
		/* 820B2100h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820B2100h case   10:*/		return 0x820B2104;
		  /* 820B2104h */ case   11:  		/* mr R10, R27 */
		/* 820B2104h case   11:*/		regs.R10 = regs.R27;
		/* 820B2104h case   11:*/		return 0x820B2108;
		  /* 820B2108h */ case   12:  		/* cmplwi CR0, R30, 0 */
		/* 820B2108h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B2108h case   12:*/		return 0x820B210C;
		  /* 820B210Ch */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 820B210Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x820B211C;  }
		/* 820B210Ch case   13:*/		return 0x820B2110;
		  /* 820B2110h */ case   14:  		/* mtspr CTR, R30 */
		/* 820B2110h case   14:*/		regs.CTR = regs.R30;
		/* 820B2110h case   14:*/		return 0x820B2114;
		  /* 820B2114h */ case   15:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B2114h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B2114h case   15:*/		return 0x820B2118;
		  /* 820B2118h */ case   16:  		/* bc 16, CR0_LT, -4 */
		/* 820B2118h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B2114;  }
		/* 820B2118h case   16:*/		return 0x820B211C;
	}
	return 0x820B211C;
} // Block from 820B20D8h-820B211Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B211Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B211C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B211C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B211C);
		  /* 820B211Ch */ case    0:  		/* addic. R8, R8, -1 */
		/* 820B211Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820B211Ch case    0:*/		return 0x820B2120;
		  /* 820B2120h */ case    1:  		/* addi R9, R9, 4 */
		/* 820B2120h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820B2120h case    1:*/		return 0x820B2124;
		  /* 820B2124h */ case    2:  		/* bc 4, CR0_EQ, -48 */
		/* 820B2124h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B20F4;  }
		/* 820B2124h case    2:*/		return 0x820B2128;
		  /* 820B2128h */ case    3:  		/* lwz R7, <#[R1 + 296]> */
		/* 820B2128h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000128) );
		/* 820B2128h case    3:*/		return 0x820B212C;
		  /* 820B212Ch */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 820B212Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B212Ch case    4:*/		return 0x820B2130;
		  /* 820B2130h */ case    5:  		/* lwz R14, <#[R1 + 268]> */
		/* 820B2130h case    5:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x0000010C) );
		/* 820B2130h case    5:*/		return 0x820B2134;
		  /* 820B2134h */ case    6:  		/* lwz R15, <#[R1 + 264]> */
		/* 820B2134h case    6:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000108) );
		/* 820B2134h case    6:*/		return 0x820B2138;
		  /* 820B2138h */ case    7:  		/* lwz R16, <#[R1 + 260]> */
		/* 820B2138h case    7:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x00000104) );
		/* 820B2138h case    7:*/		return 0x820B213C;
		  /* 820B213Ch */ case    8:  		/* lwz R8, <#[R1 + 256]> */
		/* 820B213Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000100) );
		/* 820B213Ch case    8:*/		return 0x820B2140;
		  /* 820B2140h */ case    9:  		/* lwz R31, <#[R1 + 252]> */
		/* 820B2140h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x000000FC) );
		/* 820B2140h case    9:*/		return 0x820B2144;
		  /* 820B2144h */ case   10:  		/* bc 12, CR6_EQ, 340 */
		/* 820B2144h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B2298;  }
		/* 820B2144h case   10:*/		return 0x820B2148;
		  /* 820B2148h */ case   11:  		/* rlwinm R10, R21, 2, 0, 29 */
		/* 820B2148h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R21);
		/* 820B2148h case   11:*/		return 0x820B214C;
		  /* 820B214Ch */ case   12:  		/* lwz R5, <#[R1 + 272]> */
		/* 820B214Ch case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000110) );
		/* 820B214Ch case   12:*/		return 0x820B2150;
		  /* 820B2150h */ case   13:  		/* lwz R4, <#[R1 + 276]> */
		/* 820B2150h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000114) );
		/* 820B2150h case   13:*/		return 0x820B2154;
		  /* 820B2154h */ case   14:  		/* mtspr CTR, R30 */
		/* 820B2154h case   14:*/		regs.CTR = regs.R30;
		/* 820B2154h case   14:*/		return 0x820B2158;
		  /* 820B2158h */ case   15:  		/* lwz R3, <#[R1 + 280]> */
		/* 820B2158h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000118) );
		/* 820B2158h case   15:*/		return 0x820B215C;
		  /* 820B215Ch */ case   16:  		/* subf R24, R10, R28 */
		/* 820B215Ch case   16:*/		cpu::op::subf<0>(regs,&regs.R24,regs.R10,regs.R28);
		/* 820B215Ch case   16:*/		return 0x820B2160;
		  /* 820B2160h */ case   17:  		/* lwz R27, <#[R1 + 284]> */
		/* 820B2160h case   17:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000011C) );
		/* 820B2160h case   17:*/		return 0x820B2164;
		  /* 820B2164h */ case   18:  		/* mr R11, R31 */
		/* 820B2164h case   18:*/		regs.R11 = regs.R31;
		/* 820B2164h case   18:*/		return 0x820B2168;
		  /* 820B2168h */ case   19:  		/* lwz R26, <#[R1 + 288]> */
		/* 820B2168h case   19:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000120) );
		/* 820B2168h case   19:*/		return 0x820B216C;
		  /* 820B216Ch */ case   20:  		/* subf R19, R28, R19 */
		/* 820B216Ch case   20:*/		cpu::op::subf<0>(regs,&regs.R19,regs.R28,regs.R19);
		/* 820B216Ch case   20:*/		return 0x820B2170;
		  /* 820B2170h */ case   21:  		/* lwz R25, <#[R1 + 292]> */
		/* 820B2170h case   21:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000124) );
		/* 820B2170h case   21:*/		return 0x820B2174;
		  /* 820B2174h */ case   22:  		/* subf R18, R31, R18 */
		/* 820B2174h case   22:*/		cpu::op::subf<0>(regs,&regs.R18,regs.R31,regs.R18);
		/* 820B2174h case   22:*/		return 0x820B2178;
		  /* 820B2178h */ case   23:  		/* subf R21, R31, R8 */
		/* 820B2178h case   23:*/		cpu::op::subf<0>(regs,&regs.R21,regs.R31,regs.R8);
		/* 820B2178h case   23:*/		return 0x820B217C;
		  /* 820B217Ch */ case   24:  		/* subf R10, R31, R16 */
		/* 820B217Ch case   24:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R16);
		/* 820B217Ch case   24:*/		return 0x820B2180;
		  /* 820B2180h */ case   25:  		/* subf R9, R31, R15 */
		/* 820B2180h case   25:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R31,regs.R15);
		/* 820B2180h case   25:*/		return 0x820B2184;
		  /* 820B2184h */ case   26:  		/* subf R6, R31, R14 */
		/* 820B2184h case   26:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R31,regs.R14);
		/* 820B2184h case   26:*/		return 0x820B2188;
		  /* 820B2188h */ case   27:  		/* subf R5, R31, R5 */
		/* 820B2188h case   27:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R31,regs.R5);
		/* 820B2188h case   27:*/		return 0x820B218C;
		  /* 820B218Ch */ case   28:  		/* subf R4, R31, R4 */
		/* 820B218Ch case   28:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R31,regs.R4);
		/* 820B218Ch case   28:*/		return 0x820B2190;
		  /* 820B2190h */ case   29:  		/* subf R3, R31, R3 */
		/* 820B2190h case   29:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R31,regs.R3);
		/* 820B2190h case   29:*/		return 0x820B2194;
		  /* 820B2194h */ case   30:  		/* subf R27, R31, R27 */
		/* 820B2194h case   30:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R31,regs.R27);
		/* 820B2194h case   30:*/		return 0x820B2198;
		  /* 820B2198h */ case   31:  		/* subf R26, R31, R26 */
		/* 820B2198h case   31:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R31,regs.R26);
		/* 820B2198h case   31:*/		return 0x820B219C;
		  /* 820B219Ch */ case   32:  		/* subf R25, R31, R25 */
		/* 820B219Ch case   32:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R31,regs.R25);
		/* 820B219Ch case   32:*/		return 0x820B21A0;
		  /* 820B21A0h */ case   33:  		/* subf R17, R31, R28 */
		/* 820B21A0h case   33:*/		cpu::op::subf<0>(regs,&regs.R17,regs.R31,regs.R28);
		/* 820B21A0h case   33:*/		return 0x820B21A4;
		  /* 820B21A4h */ case   34:  		/* subf R20, R31, R7 */
		/* 820B21A4h case   34:*/		cpu::op::subf<0>(regs,&regs.R20,regs.R31,regs.R7);
		/* 820B21A4h case   34:*/		return 0x820B21A8;
		  /* 820B21A8h */ case   35:  		/* lwz R28, <#[R1 + 80]> */
		/* 820B21A8h case   35:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820B21A8h case   35:*/		return 0x820B21AC;
		  /* 820B21ACh */ case   36:  		/* cmplw CR6, R23, R28 */
		/* 820B21ACh case   36:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R28);
		/* 820B21ACh case   36:*/		return 0x820B21B0;
		  /* 820B21B0h */ case   37:  		/* bc 4, CR6_LT, 12 */
		/* 820B21B0h case   37:*/		if ( !regs.CR[6].lt ) { return 0x820B21BC;  }
		/* 820B21B0h case   37:*/		return 0x820B21B4;
		  /* 820B21B4h */ case   38:  		/* lwzx R28, <#[R18 + R11]> */
		/* 820B21B4h case   38:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R18 + regs.R11 + 0x00000000) );
		/* 820B21B4h case   38:*/		return 0x820B21B8;
		  /* 820B21B8h */ case   39:  		/* b 8 */
		/* 820B21B8h case   39:*/		return 0x820B21C0;
		/* 820B21B8h case   39:*/		return 0x820B21BC;
	}
	return 0x820B21BC;
} // Block from 820B211Ch-820B21BCh (40 instructions)

//////////////////////////////////////////////////////
// Block at 820B21BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B21BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B21BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B21BC);
		  /* 820B21BCh */ case    0:  		/* lwzx R28, <#[R19 + R24]> */
		/* 820B21BCh case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R19 + regs.R24 + 0x00000000) );
		/* 820B21BCh case    0:*/		return 0x820B21C0;
	}
	return 0x820B21C0;
} // Block from 820B21BCh-820B21C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B21C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B21C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B21C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B21C0);
		  /* 820B21C0h */ case    0:  		/* std R10, <#[R1 + 136]> */
		/* 820B21C0h case    0:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 820B21C0h case    0:*/		return 0x820B21C4;
		  /* 820B21C4h */ case    1:  		/* lwz R10, <#[R1 + 92]> */
		/* 820B21C4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B21C4h case    1:*/		return 0x820B21C8;
		  /* 820B21C8h */ case    2:  		/* std R9, <#[R1 + 144]> */
		/* 820B21C8h case    2:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000090) );
		/* 820B21C8h case    2:*/		return 0x820B21CC;
		  /* 820B21CCh */ case    3:  		/* lwz R9, <#[R1 + 80]> */
		/* 820B21CCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820B21CCh case    3:*/		return 0x820B21D0;
		  /* 820B21D0h */ case    4:  		/* stw R28, <#[R11]> */
		/* 820B21D0h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 820B21D0h case    4:*/		return 0x820B21D4;
		  /* 820B21D4h */ case    5:  		/* cmplw CR6, R23, R9 */
		/* 820B21D4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R9);
		/* 820B21D4h case    5:*/		return 0x820B21D8;
		  /* 820B21D8h */ case    6:  		/* ld R9, <#[R1 + 144]> */
		/* 820B21D8h case    6:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000090) );
		/* 820B21D8h case    6:*/		return 0x820B21DC;
		  /* 820B21DCh */ case    7:  		/* stwx R10, <#[R21 + R11]> */
		/* 820B21DCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R21 + regs.R11 + 0x00000000) );
		/* 820B21DCh case    7:*/		return 0x820B21E0;
		  /* 820B21E0h */ case    8:  		/* ld R10, <#[R1 + 136]> */
		/* 820B21E0h case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 820B21E0h case    8:*/		return 0x820B21E4;
		  /* 820B21E4h */ case    9:  		/* lwz R28, <#[R1 + 88]> */
		/* 820B21E4h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000058) );
		/* 820B21E4h case    9:*/		return 0x820B21E8;
		  /* 820B21E8h */ case   10:  		/* bc 12, CR6_LT, 8 */
		/* 820B21E8h case   10:*/		if ( regs.CR[6].lt ) { return 0x820B21F0;  }
		/* 820B21E8h case   10:*/		return 0x820B21EC;
		  /* 820B21ECh */ case   11:  		/* lwz R28, <#[R1 + 84]> */
		/* 820B21ECh case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820B21ECh case   11:*/		return 0x820B21F0;
	}
	return 0x820B21F0;
} // Block from 820B21C0h-820B21F0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B21F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B21F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B21F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B21F0);
		  /* 820B21F0h */ case    0:  		/* std R8, <#[R1 + 144]> */
		/* 820B21F0h case    0:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000090) );
		/* 820B21F0h case    0:*/		return 0x820B21F4;
		  /* 820B21F4h */ case    1:  		/* lwz R8, <#[R1 + 168]> */
		/* 820B21F4h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000A8) );
		/* 820B21F4h case    1:*/		return 0x820B21F8;
		  /* 820B21F8h */ case    2:  		/* std R7, <#[R1 + 136]> */
		/* 820B21F8h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000088) );
		/* 820B21F8h case    2:*/		return 0x820B21FC;
		  /* 820B21FCh */ case    3:  		/* lwz R7, <#[R1 + 172]> */
		/* 820B21FCh case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000AC) );
		/* 820B21FCh case    3:*/		return 0x820B2200;
		  /* 820B2200h */ case    4:  		/* std R31, <#[R1 + 320]> */
		/* 820B2200h case    4:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0x00000140) );
		/* 820B2200h case    4:*/		return 0x820B2204;
		  /* 820B2204h */ case    5:  		/* lwz R31, <#[R1 + 156]> */
		/* 820B2204h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x0000009C) );
		/* 820B2204h case    5:*/		return 0x820B2208;
		  /* 820B2208h */ case    6:  		/* stwx R28, <#[R10 + R11]> */
		/* 820B2208h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B2208h case    6:*/		return 0x820B220C;
		  /* 820B220Ch */ case    7:  		/* stwx R8, <#[R9 + R11]> */
		/* 820B220Ch case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B220Ch case    7:*/		return 0x820B2210;
		  /* 820B2210h */ case    8:  		/* stwx R7, <#[R6 + R11]> */
		/* 820B2210h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820B2210h case    8:*/		return 0x820B2214;
		  /* 820B2214h */ case    9:  		/* std R30, <#[R1 + 336]> */
		/* 820B2214h case    9:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0x00000150) );
		/* 820B2214h case    9:*/		return 0x820B2218;
		  /* 820B2218h */ case   10:  		/* stwx R31, <#[R5 + R11]> */
		/* 820B2218h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820B2218h case   10:*/		return 0x820B221C;
		  /* 820B221Ch */ case   11:  		/* lwz R30, <#[R1 + 152]> */
		/* 820B221Ch case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000098) );
		/* 820B221Ch case   11:*/		return 0x820B2220;
		  /* 820B2220h */ case   12:  		/* std R24, <#[R1 + 304]> */
		/* 820B2220h case   12:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R1 + 0x00000130) );
		/* 820B2220h case   12:*/		return 0x820B2224;
		  /* 820B2224h */ case   13:  		/* lwz R24, <#[R1 + 160]> */
		/* 820B2224h case   13:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B2224h case   13:*/		return 0x820B2228;
		  /* 820B2228h */ case   14:  		/* lwz R28, <#[R1 + 132]> */
		/* 820B2228h case   14:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000084) );
		/* 820B2228h case   14:*/		return 0x820B222C;
		  /* 820B222Ch */ case   15:  		/* lwz R8, <#[R1 + 164]> */
		/* 820B222Ch case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B222Ch case   15:*/		return 0x820B2230;
		  /* 820B2230h */ case   16:  		/* stwx R30, <#[R4 + R11]> */
		/* 820B2230h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 820B2230h case   16:*/		return 0x820B2234;
		  /* 820B2234h */ case   17:  		/* lwz R7, <#[R1 + 80]> */
		/* 820B2234h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 820B2234h case   17:*/		return 0x820B2238;
		  /* 820B2238h */ case   18:  		/* stwx R24, <#[R3 + R11]> */
		/* 820B2238h case   18:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 820B2238h case   18:*/		return 0x820B223C;
		  /* 820B223Ch */ case   19:  		/* stwx R28, <#[R27 + R11]> */
		/* 820B223Ch case   19:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 820B223Ch case   19:*/		return 0x820B2240;
		  /* 820B2240h */ case   20:  		/* cmplw CR6, R23, R7 */
		/* 820B2240h case   20:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R7);
		/* 820B2240h case   20:*/		return 0x820B2244;
		  /* 820B2244h */ case   21:  		/* stwx R8, <#[R26 + R11]> */
		/* 820B2244h case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 820B2244h case   21:*/		return 0x820B2248;
		  /* 820B2248h */ case   22:  		/* ld R8, <#[R1 + 144]> */
		/* 820B2248h case   22:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x00000090) );
		/* 820B2248h case   22:*/		return 0x820B224C;
		  /* 820B224Ch */ case   23:  		/* ld R7, <#[R1 + 136]> */
		/* 820B224Ch case   23:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R1 + 0x00000088) );
		/* 820B224Ch case   23:*/		return 0x820B2250;
		  /* 820B2250h */ case   24:  		/* ld R31, <#[R1 + 320]> */
		/* 820B2250h case   24:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0x00000140) );
		/* 820B2250h case   24:*/		return 0x820B2254;
		  /* 820B2254h */ case   25:  		/* ld R30, <#[R1 + 336]> */
		/* 820B2254h case   25:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0x00000150) );
		/* 820B2254h case   25:*/		return 0x820B2258;
		  /* 820B2258h */ case   26:  		/* ld R24, <#[R1 + 304]> */
		/* 820B2258h case   26:*/		cpu::mem::load64( regs, &regs.R24, (uint32)(regs.R1 + 0x00000130) );
		/* 820B2258h case   26:*/		return 0x820B225C;
		  /* 820B225Ch */ case   27:  		/* lwz R28, <#[R29 + 32]> */
		/* 820B225Ch case   27:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000020) );
		/* 820B225Ch case   27:*/		return 0x820B2260;
		  /* 820B2260h */ case   28:  		/* stwx R28, <#[R25 + R11]> */
		/* 820B2260h case   28:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 820B2260h case   28:*/		return 0x820B2264;
		  /* 820B2264h */ case   29:  		/* bc 4, CR6_LT, 12 */
		/* 820B2264h case   29:*/		if ( !regs.CR[6].lt ) { return 0x820B2270;  }
		/* 820B2264h case   29:*/		return 0x820B2268;
		  /* 820B2268h */ case   30:  		/* lwzx R28, <#[R17 + R11]> */
		/* 820B2268h case   30:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 820B2268h case   30:*/		return 0x820B226C;
		  /* 820B226Ch */ case   31:  		/* b 8 */
		/* 820B226Ch case   31:*/		return 0x820B2274;
		/* 820B226Ch case   31:*/		return 0x820B2270;
	}
	return 0x820B2270;
} // Block from 820B21F0h-820B2270h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820B2270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2270);
		  /* 820B2270h */ case    0:  		/* lwz R28, <#[R24]> */
		/* 820B2270h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R24 + 0x00000000) );
		/* 820B2270h case    0:*/		return 0x820B2274;
	}
	return 0x820B2274;
} // Block from 820B2270h-820B2274h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B2274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2274);
		  /* 820B2274h */ case    0:  		/* stwx R28, <#[R20 + R11]> */
		/* 820B2274h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R20 + regs.R11 + 0x00000000) );
		/* 820B2274h case    0:*/		return 0x820B2278;
		  /* 820B2278h */ case    1:  		/* addi R23, R23, 1 */
		/* 820B2278h case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 820B2278h case    1:*/		return 0x820B227C;
		  /* 820B227Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 820B227Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B227Ch case    2:*/		return 0x820B2280;
		  /* 820B2280h */ case    3:  		/* addi R24, R24, 4 */
		/* 820B2280h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 820B2280h case    3:*/		return 0x820B2284;
		  /* 820B2284h */ case    4:  		/* bc 16, CR0_LT, -220 */
		/* 820B2284h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B21A8;  }
		/* 820B2284h case    4:*/		return 0x820B2288;
		  /* 820B2288h */ case    5:  		/* lwz R19, <#[R1 + 580]> */
		/* 820B2288h case    5:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x00000244) );
		/* 820B2288h case    5:*/		return 0x820B228C;
		  /* 820B228Ch */ case    6:  		/* lwz R18, <#[R1 + 572]> */
		/* 820B228Ch case    6:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x0000023C) );
		/* 820B228Ch case    6:*/		return 0x820B2290;
		  /* 820B2290h */ case    7:  		/* lwz R20, <#[R1 + 176]> */
		/* 820B2290h case    7:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x000000B0) );
		/* 820B2290h case    7:*/		return 0x820B2294;
		  /* 820B2294h */ case    8:  		/* lwz R21, <#[R1 + 80]> */
		/* 820B2294h case    8:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 820B2294h case    8:*/		return 0x820B2298;
	}
	return 0x820B2298;
} // Block from 820B2274h-820B2298h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B2298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2298);
		  /* 820B2298h */ case    0:  		/* rlwinm R28, R30, 0, 12, 31 */
		/* 820B2298h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R30);
		/* 820B2298h case    0:*/		return 0x820B229C;
		  /* 820B229Ch */ case    1:  		/* lwz R26, <#[R1 + 192]> */
		/* 820B229Ch case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000C0) );
		/* 820B229Ch case    1:*/		return 0x820B22A0;
		  /* 820B22A0h */ case    2:  		/* li R9, 0 */
		/* 820B22A0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B22A0h case    2:*/		return 0x820B22A4;
		  /* 820B22A4h */ case    3:  		/* oris R27, R28, 8272 */
		/* 820B22A4h case    3:*/		cpu::op::oris<0>(regs,&regs.R27,regs.R28,0x2050);
		/* 820B22A4h case    3:*/		return 0x820B22A8;
		  /* 820B22A8h */ case    4:  		/* mr R6, R26 */
		/* 820B22A8h case    4:*/		regs.R6 = regs.R26;
		/* 820B22A8h case    4:*/		return 0x820B22AC;
		  /* 820B22ACh */ case    5:  		/* mr R5, R27 */
		/* 820B22ACh case    5:*/		regs.R5 = regs.R27;
		/* 820B22ACh case    5:*/		return 0x820B22B0;
		  /* 820B22B0h */ case    6:  		/* mr R4, R22 */
		/* 820B22B0h case    6:*/		regs.R4 = regs.R22;
		/* 820B22B0h case    6:*/		return 0x820B22B4;
		  /* 820B22B4h */ case    7:  		/* mr R3, R29 */
		/* 820B22B4h case    7:*/		regs.R3 = regs.R29;
		/* 820B22B4h case    7:*/		return 0x820B22B8;
		  /* 820B22B8h */ case    8:  		/* bl -6064 */
		/* 820B22B8h case    8:*/		regs.LR = 0x820B22BC; return 0x820B0B08;
		/* 820B22B8h case    8:*/		return 0x820B22BC;
		  /* 820B22BCh */ case    9:  		/* or. R30, R3, R3 */
		/* 820B22BCh case    9:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B22BCh case    9:*/		return 0x820B22C0;
	}
	return 0x820B22C0;
} // Block from 820B2298h-820B22C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B22C0h
// Function '?VectorizeType@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAIIHH011@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B22C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B22C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B22C0);
		  /* 820B22C0h */ case    0:  		/* bc 12, CR0_LT, 704 */
		/* 820B22C0h case    0:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B22C0h case    0:*/		return 0x820B22C4;
		  /* 820B22C4h */ case    1:  		/* lwz R25, <#[R1 + 196]> */
		/* 820B22C4h case    1:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000C4) );
		/* 820B22C4h case    1:*/		return 0x820B22C8;
		  /* 820B22C8h */ case    2:  		/* oris R23, R28, 8256 */
		/* 820B22C8h case    2:*/		cpu::op::oris<0>(regs,&regs.R23,regs.R28,0x2040);
		/* 820B22C8h case    2:*/		return 0x820B22CC;
		  /* 820B22CCh */ case    3:  		/* li R9, 0 */
		/* 820B22CCh case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B22CCh case    3:*/		return 0x820B22D0;
		  /* 820B22D0h */ case    4:  		/* mr R8, R16 */
		/* 820B22D0h case    4:*/		regs.R8 = regs.R16;
		/* 820B22D0h case    4:*/		return 0x820B22D4;
		  /* 820B22D4h */ case    5:  		/* mr R7, R26 */
		/* 820B22D4h case    5:*/		regs.R7 = regs.R26;
		/* 820B22D4h case    5:*/		return 0x820B22D8;
		  /* 820B22D8h */ case    6:  		/* mr R6, R25 */
		/* 820B22D8h case    6:*/		regs.R6 = regs.R25;
		/* 820B22D8h case    6:*/		return 0x820B22DC;
		  /* 820B22DCh */ case    7:  		/* mr R5, R23 */
		/* 820B22DCh case    7:*/		regs.R5 = regs.R23;
		/* 820B22DCh case    7:*/		return 0x820B22E0;
		  /* 820B22E0h */ case    8:  		/* mr R4, R22 */
		/* 820B22E0h case    8:*/		regs.R4 = regs.R22;
		/* 820B22E0h case    8:*/		return 0x820B22E4;
		  /* 820B22E4h */ case    9:  		/* mr R3, R29 */
		/* 820B22E4h case    9:*/		regs.R3 = regs.R29;
		/* 820B22E4h case    9:*/		return 0x820B22E8;
		  /* 820B22E8h */ case   10:  		/* bl -6112 */
		/* 820B22E8h case   10:*/		regs.LR = 0x820B22EC; return 0x820B0B08;
		/* 820B22E8h case   10:*/		return 0x820B22EC;
		  /* 820B22ECh */ case   11:  		/* or. R30, R3, R3 */
		/* 820B22ECh case   11:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B22ECh case   11:*/		return 0x820B22F0;
		  /* 820B22F0h */ case   12:  		/* bc 12, CR0_LT, 656 */
		/* 820B22F0h case   12:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B22F0h case   12:*/		return 0x820B22F4;
		  /* 820B22F4h */ case   13:  		/* lwz R24, <#[R1 + 200]> */
		/* 820B22F4h case   13:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x000000C8) );
		/* 820B22F4h case   13:*/		return 0x820B22F8;
		  /* 820B22F8h */ case   14:  		/* li R9, 20 */
		/* 820B22F8h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820B22F8h case   14:*/		return 0x820B22FC;
		  /* 820B22FCh */ case   15:  		/* li R8, 0 */
		/* 820B22FCh case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B22FCh case   15:*/		return 0x820B2300;
		  /* 820B2300h */ case   16:  		/* mr R7, R25 */
		/* 820B2300h case   16:*/		regs.R7 = regs.R25;
		/* 820B2300h case   16:*/		return 0x820B2304;
		  /* 820B2304h */ case   17:  		/* mr R6, R24 */
		/* 820B2304h case   17:*/		regs.R6 = regs.R24;
		/* 820B2304h case   17:*/		return 0x820B2308;
		  /* 820B2308h */ case   18:  		/* oris R5, R28, 4160 */
		/* 820B2308h case   18:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R28,0x1040);
		/* 820B2308h case   18:*/		return 0x820B230C;
		  /* 820B230Ch */ case   19:  		/* mr R4, R22 */
		/* 820B230Ch case   19:*/		regs.R4 = regs.R22;
		/* 820B230Ch case   19:*/		return 0x820B2310;
		  /* 820B2310h */ case   20:  		/* mr R3, R29 */
		/* 820B2310h case   20:*/		regs.R3 = regs.R29;
		/* 820B2310h case   20:*/		return 0x820B2314;
		  /* 820B2314h */ case   21:  		/* bl -6156 */
		/* 820B2314h case   21:*/		regs.LR = 0x820B2318; return 0x820B0B08;
		/* 820B2314h case   21:*/		return 0x820B2318;
		  /* 820B2318h */ case   22:  		/* or. R30, R3, R3 */
		/* 820B2318h case   22:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B2318h case   22:*/		return 0x820B231C;
		  /* 820B231Ch */ case   23:  		/* bc 12, CR0_LT, 612 */
		/* 820B231Ch case   23:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B231Ch case   23:*/		return 0x820B2320;
		  /* 820B2320h */ case   24:  		/* lwz R26, <#[R1 + 204]> */
		/* 820B2320h case   24:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000CC) );
		/* 820B2320h case   24:*/		return 0x820B2324;
		  /* 820B2324h */ case   25:  		/* li R9, 4 */
		/* 820B2324h case   25:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2324h case   25:*/		return 0x820B2328;
		  /* 820B2328h */ case   26:  		/* mr R8, R15 */
		/* 820B2328h case   26:*/		regs.R8 = regs.R15;
		/* 820B2328h case   26:*/		return 0x820B232C;
		  /* 820B232Ch */ case   27:  		/* mr R7, R24 */
		/* 820B232Ch case   27:*/		regs.R7 = regs.R24;
		/* 820B232Ch case   27:*/		return 0x820B2330;
		  /* 820B2330h */ case   28:  		/* mr R6, R26 */
		/* 820B2330h case   28:*/		regs.R6 = regs.R26;
		/* 820B2330h case   28:*/		return 0x820B2334;
		  /* 820B2334h */ case   29:  		/* mr R5, R27 */
		/* 820B2334h case   29:*/		regs.R5 = regs.R27;
		/* 820B2334h case   29:*/		return 0x820B2338;
		  /* 820B2338h */ case   30:  		/* mr R4, R22 */
		/* 820B2338h case   30:*/		regs.R4 = regs.R22;
		/* 820B2338h case   30:*/		return 0x820B233C;
		  /* 820B233Ch */ case   31:  		/* mr R3, R29 */
		/* 820B233Ch case   31:*/		regs.R3 = regs.R29;
		/* 820B233Ch case   31:*/		return 0x820B2340;
		  /* 820B2340h */ case   32:  		/* bl -6200 */
		/* 820B2340h case   32:*/		regs.LR = 0x820B2344; return 0x820B0B08;
		/* 820B2340h case   32:*/		return 0x820B2344;
		  /* 820B2344h */ case   33:  		/* or. R30, R3, R3 */
		/* 820B2344h case   33:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B2344h case   33:*/		return 0x820B2348;
		  /* 820B2348h */ case   34:  		/* bc 12, CR0_LT, 568 */
		/* 820B2348h case   34:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B2348h case   34:*/		return 0x820B234C;
		  /* 820B234Ch */ case   35:  		/* lwz R28, <#[R1 + 208]> */
		/* 820B234Ch case   35:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000D0) );
		/* 820B234Ch case   35:*/		return 0x820B2350;
		  /* 820B2350h */ case   36:  		/* li R9, 0 */
		/* 820B2350h case   36:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2350h case   36:*/		return 0x820B2354;
		  /* 820B2354h */ case   37:  		/* mr R8, R14 */
		/* 820B2354h case   37:*/		regs.R8 = regs.R14;
		/* 820B2354h case   37:*/		return 0x820B2358;
		  /* 820B2358h */ case   38:  		/* mr R7, R26 */
		/* 820B2358h case   38:*/		regs.R7 = regs.R26;
		/* 820B2358h case   38:*/		return 0x820B235C;
		  /* 820B235Ch */ case   39:  		/* mr R6, R28 */
		/* 820B235Ch case   39:*/		regs.R6 = regs.R28;
		/* 820B235Ch case   39:*/		return 0x820B2360;
		  /* 820B2360h */ case   40:  		/* mr R5, R23 */
		/* 820B2360h case   40:*/		regs.R5 = regs.R23;
		/* 820B2360h case   40:*/		return 0x820B2364;
		  /* 820B2364h */ case   41:  		/* mr R4, R22 */
		/* 820B2364h case   41:*/		regs.R4 = regs.R22;
		/* 820B2364h case   41:*/		return 0x820B2368;
		  /* 820B2368h */ case   42:  		/* mr R3, R29 */
		/* 820B2368h case   42:*/		regs.R3 = regs.R29;
		/* 820B2368h case   42:*/		return 0x820B236C;
		  /* 820B236Ch */ case   43:  		/* bl -6244 */
		/* 820B236Ch case   43:*/		regs.LR = 0x820B2370; return 0x820B0B08;
		/* 820B236Ch case   43:*/		return 0x820B2370;
		  /* 820B2370h */ case   44:  		/* or. R30, R3, R3 */
		/* 820B2370h case   44:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B2370h case   44:*/		return 0x820B2374;
		  /* 820B2374h */ case   45:  		/* bc 12, CR0_LT, 524 */
		/* 820B2374h case   45:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B2374h case   45:*/		return 0x820B2378;
		  /* 820B2378h */ case   46:  		/* lwz R25, <#[R1 + 212]> */
		/* 820B2378h case   46:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000D4) );
		/* 820B2378h case   46:*/		return 0x820B237C;
		  /* 820B237Ch */ case   47:  		/* li R9, 4 */
		/* 820B237Ch case   47:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B237Ch case   47:*/		return 0x820B2380;
		  /* 820B2380h */ case   48:  		/* mr R8, R28 */
		/* 820B2380h case   48:*/		regs.R8 = regs.R28;
		/* 820B2380h case   48:*/		return 0x820B2384;
		  /* 820B2384h */ case   49:  		/* mr R7, R28 */
		/* 820B2384h case   49:*/		regs.R7 = regs.R28;
		/* 820B2384h case   49:*/		return 0x820B2388;
		  /* 820B2388h */ case   50:  		/* mr R6, R25 */
		/* 820B2388h case   50:*/		regs.R6 = regs.R25;
		/* 820B2388h case   50:*/		return 0x820B238C;
		  /* 820B238Ch */ case   51:  		/* mr R5, R27 */
		/* 820B238Ch case   51:*/		regs.R5 = regs.R27;
		/* 820B238Ch case   51:*/		return 0x820B2390;
		  /* 820B2390h */ case   52:  		/* mr R4, R22 */
		/* 820B2390h case   52:*/		regs.R4 = regs.R22;
		/* 820B2390h case   52:*/		return 0x820B2394;
		  /* 820B2394h */ case   53:  		/* mr R3, R29 */
		/* 820B2394h case   53:*/		regs.R3 = regs.R29;
		/* 820B2394h case   53:*/		return 0x820B2398;
		  /* 820B2398h */ case   54:  		/* bl -6288 */
		/* 820B2398h case   54:*/		regs.LR = 0x820B239C; return 0x820B0B08;
		/* 820B2398h case   54:*/		return 0x820B239C;
		  /* 820B239Ch */ case   55:  		/* or. R30, R3, R3 */
		/* 820B239Ch case   55:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B239Ch case   55:*/		return 0x820B23A0;
		  /* 820B23A0h */ case   56:  		/* bc 12, CR0_LT, 480 */
		/* 820B23A0h case   56:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B23A0h case   56:*/		return 0x820B23A4;
		  /* 820B23A4h */ case   57:  		/* lwz R28, <#[R1 + 216]> */
		/* 820B23A4h case   57:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000D8) );
		/* 820B23A4h case   57:*/		return 0x820B23A8;
		  /* 820B23A8h */ case   58:  		/* li R9, 0 */
		/* 820B23A8h case   58:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B23A8h case   58:*/		return 0x820B23AC;
		  /* 820B23ACh */ case   59:  		/* mr R7, R25 */
		/* 820B23ACh case   59:*/		regs.R7 = regs.R25;
		/* 820B23ACh case   59:*/		return 0x820B23B0;
		  /* 820B23B0h */ case   60:  		/* lwz R8, <#[R1 + 272]> */
		/* 820B23B0h case   60:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000110) );
		/* 820B23B0h case   60:*/		return 0x820B23B4;
		  /* 820B23B4h */ case   61:  		/* mr R6, R28 */
		/* 820B23B4h case   61:*/		regs.R6 = regs.R28;
		/* 820B23B4h case   61:*/		return 0x820B23B8;
		  /* 820B23B8h */ case   62:  		/* mr R5, R27 */
		/* 820B23B8h case   62:*/		regs.R5 = regs.R27;
		/* 820B23B8h case   62:*/		return 0x820B23BC;
		  /* 820B23BCh */ case   63:  		/* mr R4, R22 */
		/* 820B23BCh case   63:*/		regs.R4 = regs.R22;
		/* 820B23BCh case   63:*/		return 0x820B23C0;
		  /* 820B23C0h */ case   64:  		/* mr R3, R29 */
		/* 820B23C0h case   64:*/		regs.R3 = regs.R29;
		/* 820B23C0h case   64:*/		return 0x820B23C4;
		  /* 820B23C4h */ case   65:  		/* bl -6332 */
		/* 820B23C4h case   65:*/		regs.LR = 0x820B23C8; return 0x820B0B08;
		/* 820B23C4h case   65:*/		return 0x820B23C8;
		  /* 820B23C8h */ case   66:  		/* or. R30, R3, R3 */
		/* 820B23C8h case   66:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B23C8h case   66:*/		return 0x820B23CC;
		  /* 820B23CCh */ case   67:  		/* bc 12, CR0_LT, 436 */
		/* 820B23CCh case   67:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B23CCh case   67:*/		return 0x820B23D0;
		  /* 820B23D0h */ case   68:  		/* lwz R26, <#[R1 + 220]> */
		/* 820B23D0h case   68:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000DC) );
		/* 820B23D0h case   68:*/		return 0x820B23D4;
		  /* 820B23D4h */ case   69:  		/* li R9, 0 */
		/* 820B23D4h case   69:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B23D4h case   69:*/		return 0x820B23D8;
		  /* 820B23D8h */ case   70:  		/* mr R7, R28 */
		/* 820B23D8h case   70:*/		regs.R7 = regs.R28;
		/* 820B23D8h case   70:*/		return 0x820B23DC;
		  /* 820B23DCh */ case   71:  		/* lwz R8, <#[R1 + 276]> */
		/* 820B23DCh case   71:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000114) );
		/* 820B23DCh case   71:*/		return 0x820B23E0;
		  /* 820B23E0h */ case   72:  		/* mr R6, R26 */
		/* 820B23E0h case   72:*/		regs.R6 = regs.R26;
		/* 820B23E0h case   72:*/		return 0x820B23E4;
		  /* 820B23E4h */ case   73:  		/* mr R5, R23 */
		/* 820B23E4h case   73:*/		regs.R5 = regs.R23;
		/* 820B23E4h case   73:*/		return 0x820B23E8;
		  /* 820B23E8h */ case   74:  		/* mr R4, R22 */
		/* 820B23E8h case   74:*/		regs.R4 = regs.R22;
		/* 820B23E8h case   74:*/		return 0x820B23EC;
		  /* 820B23ECh */ case   75:  		/* mr R3, R29 */
		/* 820B23ECh case   75:*/		regs.R3 = regs.R29;
		/* 820B23ECh case   75:*/		return 0x820B23F0;
		  /* 820B23F0h */ case   76:  		/* bl -6376 */
		/* 820B23F0h case   76:*/		regs.LR = 0x820B23F4; return 0x820B0B08;
		/* 820B23F0h case   76:*/		return 0x820B23F4;
		  /* 820B23F4h */ case   77:  		/* or. R30, R3, R3 */
		/* 820B23F4h case   77:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B23F4h case   77:*/		return 0x820B23F8;
		  /* 820B23F8h */ case   78:  		/* bc 12, CR0_LT, 392 */
		/* 820B23F8h case   78:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B23F8h case   78:*/		return 0x820B23FC;
		  /* 820B23FCh */ case   79:  		/* lwz R28, <#[R1 + 224]> */
		/* 820B23FCh case   79:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000E0) );
		/* 820B23FCh case   79:*/		return 0x820B2400;
		  /* 820B2400h */ case   80:  		/* li R9, 0 */
		/* 820B2400h case   80:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2400h case   80:*/		return 0x820B2404;
		  /* 820B2404h */ case   81:  		/* mr R8, R26 */
		/* 820B2404h case   81:*/		regs.R8 = regs.R26;
		/* 820B2404h case   81:*/		return 0x820B2408;
		  /* 820B2408h */ case   82:  		/* mr R7, R25 */
		/* 820B2408h case   82:*/		regs.R7 = regs.R25;
		/* 820B2408h case   82:*/		return 0x820B240C;
		  /* 820B240Ch */ case   83:  		/* mr R6, R28 */
		/* 820B240Ch case   83:*/		regs.R6 = regs.R28;
		/* 820B240Ch case   83:*/		return 0x820B2410;
		  /* 820B2410h */ case   84:  		/* mr R5, R27 */
		/* 820B2410h case   84:*/		regs.R5 = regs.R27;
		/* 820B2410h case   84:*/		return 0x820B2414;
		  /* 820B2414h */ case   85:  		/* mr R4, R22 */
		/* 820B2414h case   85:*/		regs.R4 = regs.R22;
		/* 820B2414h case   85:*/		return 0x820B2418;
		  /* 820B2418h */ case   86:  		/* mr R3, R29 */
		/* 820B2418h case   86:*/		regs.R3 = regs.R29;
		/* 820B2418h case   86:*/		return 0x820B241C;
		  /* 820B241Ch */ case   87:  		/* bl -6420 */
		/* 820B241Ch case   87:*/		regs.LR = 0x820B2420; return 0x820B0B08;
		/* 820B241Ch case   87:*/		return 0x820B2420;
		  /* 820B2420h */ case   88:  		/* or. R30, R3, R3 */
		/* 820B2420h case   88:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B2420h case   88:*/		return 0x820B2424;
		  /* 820B2424h */ case   89:  		/* bc 12, CR0_LT, 348 */
		/* 820B2424h case   89:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B2424h case   89:*/		return 0x820B2428;
		  /* 820B2428h */ case   90:  		/* lwz R26, <#[R1 + 228]> */
		/* 820B2428h case   90:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000E4) );
		/* 820B2428h case   90:*/		return 0x820B242C;
		  /* 820B242Ch */ case   91:  		/* li R9, 0 */
		/* 820B242Ch case   91:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B242Ch case   91:*/		return 0x820B2430;
		  /* 820B2430h */ case   92:  		/* mr R7, R28 */
		/* 820B2430h case   92:*/		regs.R7 = regs.R28;
		/* 820B2430h case   92:*/		return 0x820B2434;
		  /* 820B2434h */ case   93:  		/* lwz R8, <#[R1 + 280]> */
		/* 820B2434h case   93:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000118) );
		/* 820B2434h case   93:*/		return 0x820B2438;
		  /* 820B2438h */ case   94:  		/* mr R6, R26 */
		/* 820B2438h case   94:*/		regs.R6 = regs.R26;
		/* 820B2438h case   94:*/		return 0x820B243C;
		  /* 820B243Ch */ case   95:  		/* mr R5, R23 */
		/* 820B243Ch case   95:*/		regs.R5 = regs.R23;
		/* 820B243Ch case   95:*/		return 0x820B2440;
		  /* 820B2440h */ case   96:  		/* mr R4, R22 */
		/* 820B2440h case   96:*/		regs.R4 = regs.R22;
		/* 820B2440h case   96:*/		return 0x820B2444;
		  /* 820B2444h */ case   97:  		/* mr R3, R29 */
		/* 820B2444h case   97:*/		regs.R3 = regs.R29;
		/* 820B2444h case   97:*/		return 0x820B2448;
		  /* 820B2448h */ case   98:  		/* bl -6464 */
		/* 820B2448h case   98:*/		regs.LR = 0x820B244C; return 0x820B0B08;
		/* 820B2448h case   98:*/		return 0x820B244C;
		  /* 820B244Ch */ case   99:  		/* or. R30, R3, R3 */
		/* 820B244Ch case   99:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B244Ch case   99:*/		return 0x820B2450;
		  /* 820B2450h */ case  100:  		/* bc 12, CR0_LT, 304 */
		/* 820B2450h case  100:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B2450h case  100:*/		return 0x820B2454;
		  /* 820B2454h */ case  101:  		/* lwz R28, <#[R1 + 232]> */
		/* 820B2454h case  101:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000E8) );
		/* 820B2454h case  101:*/		return 0x820B2458;
		  /* 820B2458h */ case  102:  		/* li R9, 0 */
		/* 820B2458h case  102:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2458h case  102:*/		return 0x820B245C;
		  /* 820B245Ch */ case  103:  		/* mr R8, R26 */
		/* 820B245Ch case  103:*/		regs.R8 = regs.R26;
		/* 820B245Ch case  103:*/		return 0x820B2460;
		  /* 820B2460h */ case  104:  		/* mr R7, R25 */
		/* 820B2460h case  104:*/		regs.R7 = regs.R25;
		/* 820B2460h case  104:*/		return 0x820B2464;
		  /* 820B2464h */ case  105:  		/* mr R6, R28 */
		/* 820B2464h case  105:*/		regs.R6 = regs.R28;
		/* 820B2464h case  105:*/		return 0x820B2468;
		  /* 820B2468h */ case  106:  		/* mr R5, R27 */
		/* 820B2468h case  106:*/		regs.R5 = regs.R27;
		/* 820B2468h case  106:*/		return 0x820B246C;
		  /* 820B246Ch */ case  107:  		/* mr R4, R22 */
		/* 820B246Ch case  107:*/		regs.R4 = regs.R22;
		/* 820B246Ch case  107:*/		return 0x820B2470;
		  /* 820B2470h */ case  108:  		/* mr R3, R29 */
		/* 820B2470h case  108:*/		regs.R3 = regs.R29;
		/* 820B2470h case  108:*/		return 0x820B2474;
		  /* 820B2474h */ case  109:  		/* bl -6508 */
		/* 820B2474h case  109:*/		regs.LR = 0x820B2478; return 0x820B0B08;
		/* 820B2474h case  109:*/		return 0x820B2478;
		  /* 820B2478h */ case  110:  		/* or. R30, R3, R3 */
		/* 820B2478h case  110:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B2478h case  110:*/		return 0x820B247C;
		  /* 820B247Ch */ case  111:  		/* bc 12, CR0_LT, 260 */
		/* 820B247Ch case  111:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B247Ch case  111:*/		return 0x820B2480;
		  /* 820B2480h */ case  112:  		/* lwz R26, <#[R1 + 236]> */
		/* 820B2480h case  112:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000EC) );
		/* 820B2480h case  112:*/		return 0x820B2484;
		  /* 820B2484h */ case  113:  		/* li R9, 0 */
		/* 820B2484h case  113:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2484h case  113:*/		return 0x820B2488;
		  /* 820B2488h */ case  114:  		/* mr R7, R28 */
		/* 820B2488h case  114:*/		regs.R7 = regs.R28;
		/* 820B2488h case  114:*/		return 0x820B248C;
		  /* 820B248Ch */ case  115:  		/* lwz R8, <#[R1 + 284]> */
		/* 820B248Ch case  115:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000011C) );
		/* 820B248Ch case  115:*/		return 0x820B2490;
		  /* 820B2490h */ case  116:  		/* mr R6, R26 */
		/* 820B2490h case  116:*/		regs.R6 = regs.R26;
		/* 820B2490h case  116:*/		return 0x820B2494;
		  /* 820B2494h */ case  117:  		/* mr R5, R23 */
		/* 820B2494h case  117:*/		regs.R5 = regs.R23;
		/* 820B2494h case  117:*/		return 0x820B2498;
		  /* 820B2498h */ case  118:  		/* mr R4, R22 */
		/* 820B2498h case  118:*/		regs.R4 = regs.R22;
		/* 820B2498h case  118:*/		return 0x820B249C;
		  /* 820B249Ch */ case  119:  		/* mr R3, R29 */
		/* 820B249Ch case  119:*/		regs.R3 = regs.R29;
		/* 820B249Ch case  119:*/		return 0x820B24A0;
		  /* 820B24A0h */ case  120:  		/* bl -6552 */
		/* 820B24A0h case  120:*/		regs.LR = 0x820B24A4; return 0x820B0B08;
		/* 820B24A0h case  120:*/		return 0x820B24A4;
		  /* 820B24A4h */ case  121:  		/* or. R30, R3, R3 */
		/* 820B24A4h case  121:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B24A4h case  121:*/		return 0x820B24A8;
		  /* 820B24A8h */ case  122:  		/* bc 12, CR0_LT, 216 */
		/* 820B24A8h case  122:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B24A8h case  122:*/		return 0x820B24AC;
		  /* 820B24ACh */ case  123:  		/* lwz R28, <#[R1 + 240]> */
		/* 820B24ACh case  123:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000F0) );
		/* 820B24ACh case  123:*/		return 0x820B24B0;
		  /* 820B24B0h */ case  124:  		/* li R9, 0 */
		/* 820B24B0h case  124:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B24B0h case  124:*/		return 0x820B24B4;
		  /* 820B24B4h */ case  125:  		/* mr R8, R26 */
		/* 820B24B4h case  125:*/		regs.R8 = regs.R26;
		/* 820B24B4h case  125:*/		return 0x820B24B8;
		  /* 820B24B8h */ case  126:  		/* mr R7, R25 */
		/* 820B24B8h case  126:*/		regs.R7 = regs.R25;
		/* 820B24B8h case  126:*/		return 0x820B24BC;
		  /* 820B24BCh */ case  127:  		/* mr R6, R28 */
		/* 820B24BCh case  127:*/		regs.R6 = regs.R28;
		/* 820B24BCh case  127:*/		return 0x820B24C0;
		  /* 820B24C0h */ case  128:  		/* mr R5, R27 */
		/* 820B24C0h case  128:*/		regs.R5 = regs.R27;
		/* 820B24C0h case  128:*/		return 0x820B24C4;
		  /* 820B24C4h */ case  129:  		/* mr R4, R22 */
		/* 820B24C4h case  129:*/		regs.R4 = regs.R22;
		/* 820B24C4h case  129:*/		return 0x820B24C8;
		  /* 820B24C8h */ case  130:  		/* mr R3, R29 */
		/* 820B24C8h case  130:*/		regs.R3 = regs.R29;
		/* 820B24C8h case  130:*/		return 0x820B24CC;
		  /* 820B24CCh */ case  131:  		/* bl -6596 */
		/* 820B24CCh case  131:*/		regs.LR = 0x820B24D0; return 0x820B0B08;
		/* 820B24CCh case  131:*/		return 0x820B24D0;
		  /* 820B24D0h */ case  132:  		/* or. R30, R3, R3 */
		/* 820B24D0h case  132:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B24D0h case  132:*/		return 0x820B24D4;
		  /* 820B24D4h */ case  133:  		/* bc 12, CR0_LT, 172 */
		/* 820B24D4h case  133:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B24D4h case  133:*/		return 0x820B24D8;
		  /* 820B24D8h */ case  134:  		/* lwz R26, <#[R1 + 244]> */
		/* 820B24D8h case  134:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000F4) );
		/* 820B24D8h case  134:*/		return 0x820B24DC;
		  /* 820B24DCh */ case  135:  		/* li R9, 0 */
		/* 820B24DCh case  135:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B24DCh case  135:*/		return 0x820B24E0;
		  /* 820B24E0h */ case  136:  		/* mr R7, R28 */
		/* 820B24E0h case  136:*/		regs.R7 = regs.R28;
		/* 820B24E0h case  136:*/		return 0x820B24E4;
		  /* 820B24E4h */ case  137:  		/* lwz R8, <#[R1 + 288]> */
		/* 820B24E4h case  137:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000120) );
		/* 820B24E4h case  137:*/		return 0x820B24E8;
		  /* 820B24E8h */ case  138:  		/* mr R6, R26 */
		/* 820B24E8h case  138:*/		regs.R6 = regs.R26;
		/* 820B24E8h case  138:*/		return 0x820B24EC;
		  /* 820B24ECh */ case  139:  		/* mr R5, R23 */
		/* 820B24ECh case  139:*/		regs.R5 = regs.R23;
		/* 820B24ECh case  139:*/		return 0x820B24F0;
		  /* 820B24F0h */ case  140:  		/* mr R4, R22 */
		/* 820B24F0h case  140:*/		regs.R4 = regs.R22;
		/* 820B24F0h case  140:*/		return 0x820B24F4;
		  /* 820B24F4h */ case  141:  		/* mr R3, R29 */
		/* 820B24F4h case  141:*/		regs.R3 = regs.R29;
		/* 820B24F4h case  141:*/		return 0x820B24F8;
		  /* 820B24F8h */ case  142:  		/* bl -6640 */
		/* 820B24F8h case  142:*/		regs.LR = 0x820B24FC; return 0x820B0B08;
		/* 820B24F8h case  142:*/		return 0x820B24FC;
		  /* 820B24FCh */ case  143:  		/* or. R30, R3, R3 */
		/* 820B24FCh case  143:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B24FCh case  143:*/		return 0x820B2500;
		  /* 820B2500h */ case  144:  		/* bc 12, CR0_LT, 128 */
		/* 820B2500h case  144:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B2500h case  144:*/		return 0x820B2504;
		  /* 820B2504h */ case  145:  		/* lwz R28, <#[R1 + 248]> */
		/* 820B2504h case  145:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000F8) );
		/* 820B2504h case  145:*/		return 0x820B2508;
		  /* 820B2508h */ case  146:  		/* li R9, 0 */
		/* 820B2508h case  146:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2508h case  146:*/		return 0x820B250C;
		  /* 820B250Ch */ case  147:  		/* mr R8, R26 */
		/* 820B250Ch case  147:*/		regs.R8 = regs.R26;
		/* 820B250Ch case  147:*/		return 0x820B2510;
		  /* 820B2510h */ case  148:  		/* mr R7, R25 */
		/* 820B2510h case  148:*/		regs.R7 = regs.R25;
		/* 820B2510h case  148:*/		return 0x820B2514;
		  /* 820B2514h */ case  149:  		/* mr R6, R28 */
		/* 820B2514h case  149:*/		regs.R6 = regs.R28;
		/* 820B2514h case  149:*/		return 0x820B2518;
		  /* 820B2518h */ case  150:  		/* mr R5, R27 */
		/* 820B2518h case  150:*/		regs.R5 = regs.R27;
		/* 820B2518h case  150:*/		return 0x820B251C;
		  /* 820B251Ch */ case  151:  		/* mr R4, R22 */
		/* 820B251Ch case  151:*/		regs.R4 = regs.R22;
		/* 820B251Ch case  151:*/		return 0x820B2520;
		  /* 820B2520h */ case  152:  		/* mr R3, R29 */
		/* 820B2520h case  152:*/		regs.R3 = regs.R29;
		/* 820B2520h case  152:*/		return 0x820B2524;
		  /* 820B2524h */ case  153:  		/* bl -6684 */
		/* 820B2524h case  153:*/		regs.LR = 0x820B2528; return 0x820B0B08;
		/* 820B2524h case  153:*/		return 0x820B2528;
		  /* 820B2528h */ case  154:  		/* or. R30, R3, R3 */
		/* 820B2528h case  154:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B2528h case  154:*/		return 0x820B252C;
		  /* 820B252Ch */ case  155:  		/* bc 12, CR0_LT, 84 */
		/* 820B252Ch case  155:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B252Ch case  155:*/		return 0x820B2530;
		  /* 820B2530h */ case  156:  		/* li R9, 16 */
		/* 820B2530h case  156:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820B2530h case  156:*/		return 0x820B2534;
		  /* 820B2534h */ case  157:  		/* lwz R8, <#[R1 + 292]> */
		/* 820B2534h case  157:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000124) );
		/* 820B2534h case  157:*/		return 0x820B2538;
		  /* 820B2538h */ case  158:  		/* mr R7, R28 */
		/* 820B2538h case  158:*/		regs.R7 = regs.R28;
		/* 820B2538h case  158:*/		return 0x820B253C;
		  /* 820B253Ch */ case  159:  		/* mr R6, R31 */
		/* 820B253Ch case  159:*/		regs.R6 = regs.R31;
		/* 820B253Ch case  159:*/		return 0x820B2540;
		  /* 820B2540h */ case  160:  		/* mr R5, R23 */
		/* 820B2540h case  160:*/		regs.R5 = regs.R23;
		/* 820B2540h case  160:*/		return 0x820B2544;
		  /* 820B2544h */ case  161:  		/* mr R4, R22 */
		/* 820B2544h case  161:*/		regs.R4 = regs.R22;
		/* 820B2544h case  161:*/		return 0x820B2548;
		  /* 820B2548h */ case  162:  		/* mr R3, R29 */
		/* 820B2548h case  162:*/		regs.R3 = regs.R29;
		/* 820B2548h case  162:*/		return 0x820B254C;
		  /* 820B254Ch */ case  163:  		/* bl -6724 */
		/* 820B254Ch case  163:*/		regs.LR = 0x820B2550; return 0x820B0B08;
		/* 820B254Ch case  163:*/		return 0x820B2550;
		  /* 820B2550h */ case  164:  		/* or. R30, R3, R3 */
		/* 820B2550h case  164:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B2550h case  164:*/		return 0x820B2554;
		  /* 820B2554h */ case  165:  		/* bc 12, CR0_LT, 44 */
		/* 820B2554h case  165:*/		if ( regs.CR[0].lt ) { return 0x820B2580;  }
		/* 820B2554h case  165:*/		return 0x820B2558;
		  /* 820B2558h */ case  166:  		/* rlwinm R30, R21, 2, 0, 29 */
		/* 820B2558h case  166:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R21);
		/* 820B2558h case  166:*/		return 0x820B255C;
		  /* 820B255Ch */ case  167:  		/* mr R4, R31 */
		/* 820B255Ch case  167:*/		regs.R4 = regs.R31;
		/* 820B255Ch case  167:*/		return 0x820B2560;
		  /* 820B2560h */ case  168:  		/* mr R5, R30 */
		/* 820B2560h case  168:*/		regs.R5 = regs.R30;
		/* 820B2560h case  168:*/		return 0x820B2564;
		  /* 820B2564h */ case  169:  		/* mr R3, R18 */
		/* 820B2564h case  169:*/		regs.R3 = regs.R18;
		/* 820B2564h case  169:*/		return 0x820B2568;
		  /* 820B2568h */ case  170:  		/* bl -134072 */
		/* 820B2568h case  170:*/		regs.LR = 0x820B256C; return 0x820919B0;
		/* 820B2568h case  170:*/		return 0x820B256C;
		  /* 820B256Ch */ case  171:  		/* rlwinm R5, R20, 2, 0, 29 */
		/* 820B256Ch case  171:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R20);
		/* 820B256Ch case  171:*/		return 0x820B2570;
		  /* 820B2570h */ case  172:  		/* add R4, R31, R30 */
		/* 820B2570h case  172:*/		cpu::op::add<0>(regs,&regs.R4,regs.R31,regs.R30);
		/* 820B2570h case  172:*/		return 0x820B2574;
		  /* 820B2574h */ case  173:  		/* mr R3, R19 */
		/* 820B2574h case  173:*/		regs.R3 = regs.R19;
		/* 820B2574h case  173:*/		return 0x820B2578;
		  /* 820B2578h */ case  174:  		/* bl -134088 */
		/* 820B2578h case  174:*/		regs.LR = 0x820B257C; return 0x820919B0;
		/* 820B2578h case  174:*/		return 0x820B257C;
	}
	return 0x820B257C;
} // Block from 820B22C0h-820B257Ch (175 instructions)

//////////////////////////////////////////////////////
// Block at 820B257Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B257C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B257C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B257C);
		  /* 820B257Ch */ case    0:  		/* li R30, 0 */
		/* 820B257Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B257Ch case    0:*/		return 0x820B2580;
	}
	return 0x820B2580;
} // Block from 820B257Ch-820B2580h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B2580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2580);
		  /* 820B2580h */ case    0:  		/* lis R4, 9345 */
		/* 820B2580h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B2580h case    0:*/		return 0x820B2584;
		  /* 820B2584h */ case    1:  		/* lwz R3, <#[R1 + 96]> */
		/* 820B2584h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 820B2584h case    1:*/		return 0x820B2588;
		  /* 820B2588h */ case    2:  		/* bl -172624 */
		/* 820B2588h case    2:*/		regs.LR = 0x820B258C; return 0x82088338;
		/* 820B2588h case    2:*/		return 0x820B258C;
		  /* 820B258Ch */ case    3:  		/* mr R3, R30 */
		/* 820B258Ch case    3:*/		regs.R3 = regs.R30;
		/* 820B258Ch case    3:*/		return 0x820B2590;
		  /* 820B2590h */ case    4:  		/* addi R1, R1, 528 */
		/* 820B2590h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x210);
		/* 820B2590h case    4:*/		return 0x820B2594;
		  /* 820B2594h */ case    5:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820B2594h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820B2594h case    5:*/		return 0x820B2598;
		  /* 820B2598h */ case    6:  		/* b -135976 */
		/* 820B2598h case    6:*/		return 0x82091270;
		/* 820B2598h case    6:*/		return 0x820B259C;
		  /* 820B259Ch */ case    7:  		/* nop */
		/* 820B259Ch case    7:*/		cpu::op::nop();
		/* 820B259Ch case    7:*/		return 0x820B25A0;
	}
	return 0x820B25A0;
} // Block from 820B2580h-820B25A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B25A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B25A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B25A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B25A0);
		  /* 820B25A0h */ case    0:  		/* mfspr R12, LR */
		/* 820B25A0h case    0:*/		regs.R12 = regs.LR;
		/* 820B25A0h case    0:*/		return 0x820B25A4;
		  /* 820B25A4h */ case    1:  		/* bl -136068 */
		/* 820B25A4h case    1:*/		regs.LR = 0x820B25A8; return 0x82091220;
		/* 820B25A4h case    1:*/		return 0x820B25A8;
		  /* 820B25A8h */ case    2:  		/* stwu R1, <#[R1 - 368]> */
		/* 820B25A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE90);
		/* 820B25A8h case    2:*/		return 0x820B25AC;
		  /* 820B25ACh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820B25ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820B25ACh case    3:*/		return 0x820B25B0;
		  /* 820B25B0h */ case    4:  		/* li R10, 0 */
		/* 820B25B0h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B25B0h case    4:*/		return 0x820B25B4;
		  /* 820B25B4h */ case    5:  		/* mr R30, R3 */
		/* 820B25B4h case    5:*/		regs.R30 = regs.R3;
		/* 820B25B4h case    5:*/		return 0x820B25B8;
		  /* 820B25B8h */ case    6:  		/* stw R5, <#[R1 + 404]> */
		/* 820B25B8h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000194) );
		/* 820B25B8h case    6:*/		return 0x820B25BC;
		  /* 820B25BCh */ case    7:  		/* mr R29, R4 */
		/* 820B25BCh case    7:*/		regs.R29 = regs.R4;
		/* 820B25BCh case    7:*/		return 0x820B25C0;
		  /* 820B25C0h */ case    8:  		/* stw R6, <#[R1 + 412]> */
		/* 820B25C0h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000019C) );
		/* 820B25C0h case    8:*/		return 0x820B25C4;
		  /* 820B25C4h */ case    9:  		/* mr R28, R5 */
		/* 820B25C4h case    9:*/		regs.R28 = regs.R5;
		/* 820B25C4h case    9:*/		return 0x820B25C8;
	}
	return 0x820B25C8;
} // Block from 820B25A0h-820B25C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B25C8h
// Function '?EmitSinCos@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAI11I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B25C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B25C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B25C8);
		  /* 820B25C8h */ case    0:  		/* stw R7, <#[R1 + 420]> */
		/* 820B25C8h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x000001A4) );
		/* 820B25C8h case    0:*/		return 0x820B25CC;
		  /* 820B25CCh */ case    1:  		/* mr R26, R7 */
		/* 820B25CCh case    1:*/		regs.R26 = regs.R7;
		/* 820B25CCh case    1:*/		return 0x820B25D0;
		  /* 820B25D0h */ case    2:  		/* stw R10, <#[R1 + 80]> */
		/* 820B25D0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820B25D0h case    2:*/		return 0x820B25D4;
		  /* 820B25D4h */ case    3:  		/* lwz R11, <#[R11 + 108]> */
		/* 820B25D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000006C) );
		/* 820B25D4h case    3:*/		return 0x820B25D8;
		  /* 820B25D8h */ case    4:  		/* mr R27, R8 */
		/* 820B25D8h case    4:*/		regs.R27 = regs.R8;
		/* 820B25D8h case    4:*/		return 0x820B25DC;
		  /* 820B25DCh */ case    5:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 820B25DCh case    5:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 820B25DCh case    5:*/		return 0x820B25E0;
		  /* 820B25E0h */ case    6:  		/* bc 12, CR0_EQ, 132 */
		/* 820B25E0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B2664;  }
		/* 820B25E0h case    6:*/		return 0x820B25E4;
		  /* 820B25E4h */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 820B25E4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820B25E4h case    7:*/		return 0x820B25E8;
		  /* 820B25E8h */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 820B25E8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820B2610;  }
		/* 820B25E8h case    8:*/		return 0x820B25EC;
		  /* 820B25ECh */ case    9:  		/* mr R5, R8 */
		/* 820B25ECh case    9:*/		regs.R5 = regs.R8;
		/* 820B25ECh case    9:*/		return 0x820B25F0;
		  /* 820B25F0h */ case   10:  		/* li R11, 133 */
		/* 820B25F0h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x85);
		/* 820B25F0h case   10:*/		return 0x820B25F4;
		  /* 820B25F4h */ case   11:  		/* li R9, 0 */
		/* 820B25F4h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B25F4h case   11:*/		return 0x820B25F8;
		  /* 820B25F8h */ case   12:  		/* rlwimi R5, R11, 21, 0, 11 */
		/* 820B25F8h case   12:*/		cpu::op::rlwimi<0,21,0,11>(regs,&regs.R5,regs.R11);
		/* 820B25F8h case   12:*/		return 0x820B25FC;
		  /* 820B25FCh */ case   13:  		/* li R8, 0 */
		/* 820B25FCh case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B25FCh case   13:*/		return 0x820B2600;
		  /* 820B2600h */ case   14:  		/* mr R7, R28 */
		/* 820B2600h case   14:*/		regs.R7 = regs.R28;
		/* 820B2600h case   14:*/		return 0x820B2604;
		  /* 820B2604h */ case   15:  		/* bl -6908 */
		/* 820B2604h case   15:*/		regs.LR = 0x820B2608; return 0x820B0B08;
		/* 820B2604h case   15:*/		return 0x820B2608;
		  /* 820B2608h */ case   16:  		/* or. R31, R3, R3 */
		/* 820B2608h case   16:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2608h case   16:*/		return 0x820B260C;
		  /* 820B260Ch */ case   17:  		/* bc 12, CR0_LT, 64 */
		/* 820B260Ch case   17:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B260Ch case   17:*/		return 0x820B2610;
	}
	return 0x820B2610;
} // Block from 820B25C8h-820B2610h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820B2610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2610);
		  /* 820B2610h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820B2610h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820B2610h case    0:*/		return 0x820B2614;
		  /* 820B2614h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 820B2614h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B2648;  }
		/* 820B2614h case    1:*/		return 0x820B2618;
		  /* 820B2618h */ case    2:  		/* mr R5, R27 */
		/* 820B2618h case    2:*/		regs.R5 = regs.R27;
		/* 820B2618h case    2:*/		return 0x820B261C;
		  /* 820B261Ch */ case    3:  		/* li R11, 267 */
		/* 820B261Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x10B);
		/* 820B261Ch case    3:*/		return 0x820B2620;
		  /* 820B2620h */ case    4:  		/* mr R7, R28 */
		/* 820B2620h case    4:*/		regs.R7 = regs.R28;
		/* 820B2620h case    4:*/		return 0x820B2624;
		  /* 820B2624h */ case    5:  		/* rlwimi R5, R11, 20, 0, 11 */
		/* 820B2624h case    5:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R5,regs.R11);
		/* 820B2624h case    5:*/		return 0x820B2628;
		  /* 820B2628h */ case    6:  		/* mr R6, R26 */
		/* 820B2628h case    6:*/		regs.R6 = regs.R26;
		/* 820B2628h case    6:*/		return 0x820B262C;
		  /* 820B262Ch */ case    7:  		/* li R9, 4 */
		/* 820B262Ch case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B262Ch case    7:*/		return 0x820B2630;
		  /* 820B2630h */ case    8:  		/* li R8, 0 */
		/* 820B2630h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B2630h case    8:*/		return 0x820B2634;
		  /* 820B2634h */ case    9:  		/* mr R4, R29 */
		/* 820B2634h case    9:*/		regs.R4 = regs.R29;
		/* 820B2634h case    9:*/		return 0x820B2638;
		  /* 820B2638h */ case   10:  		/* mr R3, R30 */
		/* 820B2638h case   10:*/		regs.R3 = regs.R30;
		/* 820B2638h case   10:*/		return 0x820B263C;
		  /* 820B263Ch */ case   11:  		/* bl -6964 */
		/* 820B263Ch case   11:*/		regs.LR = 0x820B2640; return 0x820B0B08;
		/* 820B263Ch case   11:*/		return 0x820B2640;
		  /* 820B2640h */ case   12:  		/* or. R31, R3, R3 */
		/* 820B2640h case   12:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2640h case   12:*/		return 0x820B2644;
		  /* 820B2644h */ case   13:  		/* bc 12, CR0_LT, 8 */
		/* 820B2644h case   13:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2644h case   13:*/		return 0x820B2648;
	}
	return 0x820B2648;
} // Block from 820B2610h-820B2648h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820B2648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2648);
		  /* 820B2648h */ case    0:  		/* li R31, 0 */
		/* 820B2648h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B2648h case    0:*/		return 0x820B264C;
	}
	return 0x820B264C;
} // Block from 820B2648h-820B264Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B264Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B264C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B264C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B264C);
		  /* 820B264Ch */ case    0:  		/* lis R4, 9345 */
		/* 820B264Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B264Ch case    0:*/		return 0x820B2650;
		  /* 820B2650h */ case    1:  		/* lwz R3, <#[R1 + 80]> */
		/* 820B2650h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820B2650h case    1:*/		return 0x820B2654;
		  /* 820B2654h */ case    2:  		/* bl -172828 */
		/* 820B2654h case    2:*/		regs.LR = 0x820B2658; return 0x82088338;
		/* 820B2654h case    2:*/		return 0x820B2658;
		  /* 820B2658h */ case    3:  		/* mr R3, R31 */
		/* 820B2658h case    3:*/		regs.R3 = regs.R31;
		/* 820B2658h case    3:*/		return 0x820B265C;
		  /* 820B265Ch */ case    4:  		/* addi R1, R1, 368 */
		/* 820B265Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x170);
		/* 820B265Ch case    4:*/		return 0x820B2660;
		  /* 820B2660h */ case    5:  		/* b -136176 */
		/* 820B2660h case    5:*/		return 0x82091270;
		/* 820B2660h case    5:*/		return 0x820B2664;
	}
	return 0x820B2664;
} // Block from 820B264Ch-820B2664h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B2664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2664);
		  /* 820B2664h */ case    0:  		/* lwz R3, <#[R30 + 8]> */
		/* 820B2664h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2664h case    0:*/		return 0x820B2668;
		  /* 820B2668h */ case    1:  		/* lis R11, -32255 */
		/* 820B2668h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B2668h case    1:*/		return 0x820B266C;
		  /* 820B266Ch */ case    2:  		/* li R6, 0 */
		/* 820B266Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B266Ch case    2:*/		return 0x820B2670;
		  /* 820B2670h */ case    3:  		/* li R5, 0 */
		/* 820B2670h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2670h case    3:*/		return 0x820B2674;
		  /* 820B2674h */ case    4:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B2674h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B2674h case    4:*/		return 0x820B2678;
		  /* 820B2678h */ case    5:  		/* lfd FR1, <#[R11 + 8696]> */
		/* 820B2678h case    5:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x000021F8) );
		/* 820B2678h case    5:*/		return 0x820B267C;
		  /* 820B267Ch */ case    6:  		/* bl 306092 */
		/* 820B267Ch case    6:*/		regs.LR = 0x820B2680; return 0x820FD228;
		/* 820B267Ch case    6:*/		return 0x820B2680;
		  /* 820B2680h */ case    7:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2680h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2680h case    7:*/		return 0x820B2684;
		  /* 820B2684h */ case    8:  		/* lis R10, -32255 */
		/* 820B2684h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2684h case    8:*/		return 0x820B2688;
		  /* 820B2688h */ case    9:  		/* mr R31, R3 */
		/* 820B2688h case    9:*/		regs.R31 = regs.R3;
		/* 820B2688h case    9:*/		return 0x820B268C;
		  /* 820B268Ch */ case   10:  		/* li R6, 0 */
		/* 820B268Ch case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B268Ch case   10:*/		return 0x820B2690;
		  /* 820B2690h */ case   11:  		/* li R5, 0 */
		/* 820B2690h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2690h case   11:*/		return 0x820B2694;
		  /* 820B2694h */ case   12:  		/* mr R3, R11 */
		/* 820B2694h case   12:*/		regs.R3 = regs.R11;
		/* 820B2694h case   12:*/		return 0x820B2698;
		  /* 820B2698h */ case   13:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2698h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2698h case   13:*/		return 0x820B269C;
		  /* 820B269Ch */ case   14:  		/* lfd FR1, <#[R10 + 8688]> */
		/* 820B269Ch case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021F0) );
		/* 820B269Ch case   14:*/		return 0x820B26A0;
		  /* 820B26A0h */ case   15:  		/* bl 306056 */
		/* 820B26A0h case   15:*/		regs.LR = 0x820B26A4; return 0x820FD228;
		/* 820B26A0h case   15:*/		return 0x820B26A4;
		  /* 820B26A4h */ case   16:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B26A4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B26A4h case   16:*/		return 0x820B26A8;
		  /* 820B26A8h */ case   17:  		/* lis R10, -32255 */
		/* 820B26A8h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B26A8h case   17:*/		return 0x820B26AC;
		  /* 820B26ACh */ case   18:  		/* mr R26, R3 */
		/* 820B26ACh case   18:*/		regs.R26 = regs.R3;
		/* 820B26ACh case   18:*/		return 0x820B26B0;
		  /* 820B26B0h */ case   19:  		/* li R6, 0 */
		/* 820B26B0h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B26B0h case   19:*/		return 0x820B26B4;
		  /* 820B26B4h */ case   20:  		/* li R5, 0 */
		/* 820B26B4h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B26B4h case   20:*/		return 0x820B26B8;
		  /* 820B26B8h */ case   21:  		/* mr R3, R11 */
		/* 820B26B8h case   21:*/		regs.R3 = regs.R11;
		/* 820B26B8h case   21:*/		return 0x820B26BC;
		  /* 820B26BCh */ case   22:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B26BCh case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B26BCh case   22:*/		return 0x820B26C0;
		  /* 820B26C0h */ case   23:  		/* lfd FR1, <#[R10 + 8680]> */
		/* 820B26C0h case   23:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021E8) );
		/* 820B26C0h case   23:*/		return 0x820B26C4;
		  /* 820B26C4h */ case   24:  		/* bl 306020 */
		/* 820B26C4h case   24:*/		regs.LR = 0x820B26C8; return 0x820FD228;
		/* 820B26C4h case   24:*/		return 0x820B26C8;
		  /* 820B26C8h */ case   25:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B26C8h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B26C8h case   25:*/		return 0x820B26CC;
		  /* 820B26CCh */ case   26:  		/* lis R10, -32255 */
		/* 820B26CCh case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B26CCh case   26:*/		return 0x820B26D0;
		  /* 820B26D0h */ case   27:  		/* mr R25, R3 */
		/* 820B26D0h case   27:*/		regs.R25 = regs.R3;
		/* 820B26D0h case   27:*/		return 0x820B26D4;
		  /* 820B26D4h */ case   28:  		/* li R6, 0 */
		/* 820B26D4h case   28:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B26D4h case   28:*/		return 0x820B26D8;
		  /* 820B26D8h */ case   29:  		/* li R5, 0 */
		/* 820B26D8h case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B26D8h case   29:*/		return 0x820B26DC;
		  /* 820B26DCh */ case   30:  		/* mr R3, R11 */
		/* 820B26DCh case   30:*/		regs.R3 = regs.R11;
		/* 820B26DCh case   30:*/		return 0x820B26E0;
		  /* 820B26E0h */ case   31:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B26E0h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B26E0h case   31:*/		return 0x820B26E4;
		  /* 820B26E4h */ case   32:  		/* lfd FR1, <#[R10 + 8672]> */
		/* 820B26E4h case   32:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021E0) );
		/* 820B26E4h case   32:*/		return 0x820B26E8;
		  /* 820B26E8h */ case   33:  		/* bl 305984 */
		/* 820B26E8h case   33:*/		regs.LR = 0x820B26EC; return 0x820FD228;
		/* 820B26E8h case   33:*/		return 0x820B26EC;
		  /* 820B26ECh */ case   34:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B26ECh case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B26ECh case   34:*/		return 0x820B26F0;
		  /* 820B26F0h */ case   35:  		/* lis R10, -32255 */
		/* 820B26F0h case   35:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B26F0h case   35:*/		return 0x820B26F4;
		  /* 820B26F4h */ case   36:  		/* mr R23, R3 */
		/* 820B26F4h case   36:*/		regs.R23 = regs.R3;
		/* 820B26F4h case   36:*/		return 0x820B26F8;
		  /* 820B26F8h */ case   37:  		/* li R6, 0 */
		/* 820B26F8h case   37:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B26F8h case   37:*/		return 0x820B26FC;
		  /* 820B26FCh */ case   38:  		/* li R5, 0 */
		/* 820B26FCh case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B26FCh case   38:*/		return 0x820B2700;
		  /* 820B2700h */ case   39:  		/* mr R3, R11 */
		/* 820B2700h case   39:*/		regs.R3 = regs.R11;
		/* 820B2700h case   39:*/		return 0x820B2704;
		  /* 820B2704h */ case   40:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2704h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2704h case   40:*/		return 0x820B2708;
		  /* 820B2708h */ case   41:  		/* lfd FR1, <#[R10 + 8664]> */
		/* 820B2708h case   41:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021D8) );
		/* 820B2708h case   41:*/		return 0x820B270C;
		  /* 820B270Ch */ case   42:  		/* bl 305948 */
		/* 820B270Ch case   42:*/		regs.LR = 0x820B2710; return 0x820FD228;
		/* 820B270Ch case   42:*/		return 0x820B2710;
		  /* 820B2710h */ case   43:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2710h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2710h case   43:*/		return 0x820B2714;
		  /* 820B2714h */ case   44:  		/* lis R10, -32255 */
		/* 820B2714h case   44:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2714h case   44:*/		return 0x820B2718;
		  /* 820B2718h */ case   45:  		/* mr R22, R3 */
		/* 820B2718h case   45:*/		regs.R22 = regs.R3;
		/* 820B2718h case   45:*/		return 0x820B271C;
		  /* 820B271Ch */ case   46:  		/* li R6, 0 */
		/* 820B271Ch case   46:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B271Ch case   46:*/		return 0x820B2720;
		  /* 820B2720h */ case   47:  		/* li R5, 0 */
		/* 820B2720h case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2720h case   47:*/		return 0x820B2724;
		  /* 820B2724h */ case   48:  		/* mr R3, R11 */
		/* 820B2724h case   48:*/		regs.R3 = regs.R11;
		/* 820B2724h case   48:*/		return 0x820B2728;
		  /* 820B2728h */ case   49:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2728h case   49:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2728h case   49:*/		return 0x820B272C;
		  /* 820B272Ch */ case   50:  		/* lfd FR1, <#[R10 + 8088]> */
		/* 820B272Ch case   50:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00001F98) );
		/* 820B272Ch case   50:*/		return 0x820B2730;
		  /* 820B2730h */ case   51:  		/* bl 305912 */
		/* 820B2730h case   51:*/		regs.LR = 0x820B2734; return 0x820FD228;
		/* 820B2730h case   51:*/		return 0x820B2734;
		  /* 820B2734h */ case   52:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2734h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2734h case   52:*/		return 0x820B2738;
		  /* 820B2738h */ case   53:  		/* lis R10, -32255 */
		/* 820B2738h case   53:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2738h case   53:*/		return 0x820B273C;
		  /* 820B273Ch */ case   54:  		/* mr R21, R3 */
		/* 820B273Ch case   54:*/		regs.R21 = regs.R3;
		/* 820B273Ch case   54:*/		return 0x820B2740;
		  /* 820B2740h */ case   55:  		/* li R6, 0 */
		/* 820B2740h case   55:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2740h case   55:*/		return 0x820B2744;
		  /* 820B2744h */ case   56:  		/* li R5, 0 */
		/* 820B2744h case   56:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2744h case   56:*/		return 0x820B2748;
		  /* 820B2748h */ case   57:  		/* mr R3, R11 */
		/* 820B2748h case   57:*/		regs.R3 = regs.R11;
		/* 820B2748h case   57:*/		return 0x820B274C;
		  /* 820B274Ch */ case   58:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B274Ch case   58:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B274Ch case   58:*/		return 0x820B2750;
		  /* 820B2750h */ case   59:  		/* lfd FR1, <#[R10 + 8096]> */
		/* 820B2750h case   59:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00001FA0) );
		/* 820B2750h case   59:*/		return 0x820B2754;
		  /* 820B2754h */ case   60:  		/* bl 305876 */
		/* 820B2754h case   60:*/		regs.LR = 0x820B2758; return 0x820FD228;
		/* 820B2754h case   60:*/		return 0x820B2758;
		  /* 820B2758h */ case   61:  		/* mr R20, R3 */
		/* 820B2758h case   61:*/		regs.R20 = regs.R3;
		/* 820B2758h case   61:*/		return 0x820B275C;
		  /* 820B275Ch */ case   62:  		/* lis R4, 9345 */
		/* 820B275Ch case   62:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B275Ch case   62:*/		return 0x820B2760;
		  /* 820B2760h */ case   63:  		/* mulli R3, R27, 112 */
		/* 820B2760h case   63:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R27,0x70);
		/* 820B2760h case   63:*/		return 0x820B2764;
		  /* 820B2764h */ case   64:  		/* bl -173412 */
		/* 820B2764h case   64:*/		regs.LR = 0x820B2768; return 0x82088200;
		/* 820B2764h case   64:*/		return 0x820B2768;
		  /* 820B2768h */ case   65:  		/* stw R3, <#[R1 + 80]> */
		/* 820B2768h case   65:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820B2768h case   65:*/		return 0x820B276C;
		  /* 820B276Ch */ case   66:  		/* cmplwi CR0, R3, 0 */
		/* 820B276Ch case   66:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B276Ch case   66:*/		return 0x820B2770;
		  /* 820B2770h */ case   67:  		/* bc 4, CR0_EQ, 16 */
		/* 820B2770h case   67:*/		if ( !regs.CR[0].eq ) { return 0x820B2780;  }
		/* 820B2770h case   67:*/		return 0x820B2774;
		  /* 820B2774h */ case   68:  		/* lis R31, -32761 */
		/* 820B2774h case   68:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820B2774h case   68:*/		return 0x820B2778;
		  /* 820B2778h */ case   69:  		/* ori R31, R31, 14 */
		/* 820B2778h case   69:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820B2778h case   69:*/		return 0x820B277C;
		  /* 820B277Ch */ case   70:  		/* b -304 */
		/* 820B277Ch case   70:*/		return 0x820B264C;
		/* 820B277Ch case   70:*/		return 0x820B2780;
	}
	return 0x820B2780;
} // Block from 820B2664h-820B2780h (71 instructions)

//////////////////////////////////////////////////////
// Block at 820B2780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2780);
		  /* 820B2780h */ case    0:  		/* li R10, 28 */
		/* 820B2780h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1C);
		/* 820B2780h case    0:*/		return 0x820B2784;
		  /* 820B2784h */ case    1:  		/* addi R11, R1, 96 */
		/* 820B2784h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820B2784h case    1:*/		return 0x820B2788;
		  /* 820B2788h */ case    2:  		/* rlwinm R8, R27, 2, 0, 29 */
		/* 820B2788h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R27);
		/* 820B2788h case    2:*/		return 0x820B278C;
		  /* 820B278Ch */ case    3:  		/* addi R9, R11, -4 */
		/* 820B278Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B278Ch case    3:*/		return 0x820B2790;
		  /* 820B2790h */ case    4:  		/* mr R11, R3 */
		/* 820B2790h case    4:*/		regs.R11 = regs.R3;
		/* 820B2790h case    4:*/		return 0x820B2794;
		  /* 820B2794h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B2794h case    5:*/		regs.CTR = regs.R10;
		/* 820B2794h case    5:*/		return 0x820B2798;
		  /* 820B2798h */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B2798h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B2798h case    6:*/		return 0x820B279C;
		  /* 820B279Ch */ case    7:  		/* add R11, R8, R11 */
		/* 820B279Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820B279Ch case    7:*/		return 0x820B27A0;
		  /* 820B27A0h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B27A0h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B2798;  }
		/* 820B27A0h case    8:*/		return 0x820B27A4;
		  /* 820B27A4h */ case    9:  		/* addi R9, R1, 96 */
		/* 820B27A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 820B27A4h case    9:*/		return 0x820B27A8;
		  /* 820B27A8h */ case   10:  		/* li R8, 20 */
		/* 820B27A8h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x14);
		/* 820B27A8h case   10:*/		return 0x820B27AC;
		  /* 820B27ACh */ case   11:  		/* lwz R11, <#[R9]> */
		/* 820B27ACh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820B27ACh case   11:*/		return 0x820B27B0;
		  /* 820B27B0h */ case   12:  		/* cmplwi CR6, R27, 0 */
		/* 820B27B0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820B27B0h case   12:*/		return 0x820B27B4;
		  /* 820B27B4h */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 820B27B4h case   13:*/		if ( regs.CR[6].eq ) { return 0x820B27D4;  }
		/* 820B27B4h case   13:*/		return 0x820B27B8;
		  /* 820B27B8h */ case   14:  		/* addi R11, R11, -4 */
		/* 820B27B8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820B27B8h case   14:*/		return 0x820B27BC;
		  /* 820B27BCh */ case   15:  		/* li R10, -1 */
		/* 820B27BCh case   15:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820B27BCh case   15:*/		return 0x820B27C0;
		  /* 820B27C0h */ case   16:  		/* cmplwi CR0, R27, 0 */
		/* 820B27C0h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R27,0x00000000);
		/* 820B27C0h case   16:*/		return 0x820B27C4;
		  /* 820B27C4h */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 820B27C4h case   17:*/		if ( regs.CR[0].eq ) { return 0x820B27D4;  }
		/* 820B27C4h case   17:*/		return 0x820B27C8;
		  /* 820B27C8h */ case   18:  		/* mtspr CTR, R27 */
		/* 820B27C8h case   18:*/		regs.CTR = regs.R27;
		/* 820B27C8h case   18:*/		return 0x820B27CC;
		  /* 820B27CCh */ case   19:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B27CCh case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B27CCh case   19:*/		return 0x820B27D0;
		  /* 820B27D0h */ case   20:  		/* bc 16, CR0_LT, -4 */
		/* 820B27D0h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B27CC;  }
		/* 820B27D0h case   20:*/		return 0x820B27D4;
	}
	return 0x820B27D4;
} // Block from 820B2780h-820B27D4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820B27D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B27D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B27D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B27D4);
		  /* 820B27D4h */ case    0:  		/* addic. R8, R8, -1 */
		/* 820B27D4h case    0:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820B27D4h case    0:*/		return 0x820B27D8;
		  /* 820B27D8h */ case    1:  		/* addi R9, R9, 4 */
		/* 820B27D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820B27D8h case    1:*/		return 0x820B27DC;
		  /* 820B27DCh */ case    2:  		/* bc 4, CR0_EQ, -48 */
		/* 820B27DCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B27AC;  }
		/* 820B27DCh case    2:*/		return 0x820B27E0;
		  /* 820B27E0h */ case    3:  		/* lwz R14, <#[R1 + 200]> */
		/* 820B27E0h case    3:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x000000C8) );
		/* 820B27E0h case    3:*/		return 0x820B27E4;
		  /* 820B27E4h */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 820B27E4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820B27E4h case    4:*/		return 0x820B27E8;
		  /* 820B27E8h */ case    5:  		/* lwz R16, <#[R1 + 196]> */
		/* 820B27E8h case    5:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x000000C4) );
		/* 820B27E8h case    5:*/		return 0x820B27EC;
		  /* 820B27ECh */ case    6:  		/* lwz R17, <#[R1 + 192]> */
		/* 820B27ECh case    6:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x000000C0) );
		/* 820B27ECh case    6:*/		return 0x820B27F0;
		  /* 820B27F0h */ case    7:  		/* lwz R18, <#[R1 + 188]> */
		/* 820B27F0h case    7:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x000000BC) );
		/* 820B27F0h case    7:*/		return 0x820B27F4;
		  /* 820B27F4h */ case    8:  		/* lwz R19, <#[R1 + 184]> */
		/* 820B27F4h case    8:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x000000B8) );
		/* 820B27F4h case    8:*/		return 0x820B27F8;
		  /* 820B27F8h */ case    9:  		/* lwz R28, <#[R1 + 180]> */
		/* 820B27F8h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000B4) );
		/* 820B27F8h case    9:*/		return 0x820B27FC;
		  /* 820B27FCh */ case   10:  		/* lwz R24, <#[R1 + 176]> */
		/* 820B27FCh case   10:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x000000B0) );
		/* 820B27FCh case   10:*/		return 0x820B2800;
		  /* 820B2800h */ case   11:  		/* bc 12, CR6_EQ, 88 */
		/* 820B2800h case   11:*/		if ( regs.CR[6].eq ) { return 0x820B2858;  }
		/* 820B2800h case   11:*/		return 0x820B2804;
		  /* 820B2804h */ case   12:  		/* lwz R4, <#[R1 + 204]> */
		/* 820B2804h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000CC) );
		/* 820B2804h case   12:*/		return 0x820B2808;
		  /* 820B2808h */ case   13:  		/* mtspr CTR, R27 */
		/* 820B2808h case   13:*/		regs.CTR = regs.R27;
		/* 820B2808h case   13:*/		return 0x820B280C;
		  /* 820B280Ch */ case   14:  		/* mr R11, R28 */
		/* 820B280Ch case   14:*/		regs.R11 = regs.R28;
		/* 820B280Ch case   14:*/		return 0x820B2810;
		  /* 820B2810h */ case   15:  		/* subf R10, R28, R24 */
		/* 820B2810h case   15:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R24);
		/* 820B2810h case   15:*/		return 0x820B2814;
		  /* 820B2814h */ case   16:  		/* subf R9, R28, R19 */
		/* 820B2814h case   16:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R28,regs.R19);
		/* 820B2814h case   16:*/		return 0x820B2818;
		  /* 820B2818h */ case   17:  		/* subf R8, R28, R18 */
		/* 820B2818h case   17:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R28,regs.R18);
		/* 820B2818h case   17:*/		return 0x820B281C;
		  /* 820B281Ch */ case   18:  		/* subf R7, R28, R17 */
		/* 820B281Ch case   18:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R28,regs.R17);
		/* 820B281Ch case   18:*/		return 0x820B2820;
		  /* 820B2820h */ case   19:  		/* subf R6, R28, R16 */
		/* 820B2820h case   19:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R28,regs.R16);
		/* 820B2820h case   19:*/		return 0x820B2824;
		  /* 820B2824h */ case   20:  		/* subf R5, R28, R14 */
		/* 820B2824h case   20:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R28,regs.R14);
		/* 820B2824h case   20:*/		return 0x820B2828;
		  /* 820B2828h */ case   21:  		/* subf R4, R28, R4 */
		/* 820B2828h case   21:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R28,regs.R4);
		/* 820B2828h case   21:*/		return 0x820B282C;
		  /* 820B282Ch */ case   22:  		/* lwz R3, <#[R30 + 32]> */
		/* 820B282Ch case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000020) );
		/* 820B282Ch case   22:*/		return 0x820B2830;
		  /* 820B2830h */ case   23:  		/* stwx R3, <#[R10 + R11]> */
		/* 820B2830h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B2830h case   23:*/		return 0x820B2834;
		  /* 820B2834h */ case   24:  		/* stw R31, <#[R11]> */
		/* 820B2834h case   24:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 820B2834h case   24:*/		return 0x820B2838;
		  /* 820B2838h */ case   25:  		/* stwx R26, <#[R9 + R11]> */
		/* 820B2838h case   25:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B2838h case   25:*/		return 0x820B283C;
		  /* 820B283Ch */ case   26:  		/* stwx R25, <#[R8 + R11]> */
		/* 820B283Ch case   26:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820B283Ch case   26:*/		return 0x820B2840;
		  /* 820B2840h */ case   27:  		/* stwx R23, <#[R7 + R11]> */
		/* 820B2840h case   27:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820B2840h case   27:*/		return 0x820B2844;
		  /* 820B2844h */ case   28:  		/* stwx R22, <#[R6 + R11]> */
		/* 820B2844h case   28:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820B2844h case   28:*/		return 0x820B2848;
		  /* 820B2848h */ case   29:  		/* stwx R21, <#[R5 + R11]> */
		/* 820B2848h case   29:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820B2848h case   29:*/		return 0x820B284C;
		  /* 820B284Ch */ case   30:  		/* stwx R20, <#[R4 + R11]> */
		/* 820B284Ch case   30:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 820B284Ch case   30:*/		return 0x820B2850;
		  /* 820B2850h */ case   31:  		/* addi R11, R11, 4 */
		/* 820B2850h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B2850h case   31:*/		return 0x820B2854;
		  /* 820B2854h */ case   32:  		/* bc 16, CR0_LT, -40 */
		/* 820B2854h case   32:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B282C;  }
		/* 820B2854h case   32:*/		return 0x820B2858;
	}
	return 0x820B2858;
} // Block from 820B27D4h-820B2858h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820B2858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2858);
		  /* 820B2858h */ case    0:  		/* rlwinm R22, R27, 0, 12, 31 */
		/* 820B2858h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R22,regs.R27);
		/* 820B2858h case    0:*/		return 0x820B285C;
		  /* 820B285Ch */ case    1:  		/* lwz R20, <#[R1 + 96]> */
		/* 820B285Ch case    1:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000060) );
		/* 820B285Ch case    1:*/		return 0x820B2860;
		  /* 820B2860h */ case    2:  		/* lwz R27, <#[R1 + 404]> */
		/* 820B2860h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000194) );
		/* 820B2860h case    2:*/		return 0x820B2864;
		  /* 820B2864h */ case    3:  		/* li R9, 0 */
		/* 820B2864h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2864h case    3:*/		return 0x820B2868;
		  /* 820B2868h */ case    4:  		/* oris R15, R22, 4112 */
		/* 820B2868h case    4:*/		cpu::op::oris<0>(regs,&regs.R15,regs.R22,0x1010);
		/* 820B2868h case    4:*/		return 0x820B286C;
		  /* 820B286Ch */ case    5:  		/* li R8, 0 */
		/* 820B286Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B286Ch case    5:*/		return 0x820B2870;
		  /* 820B2870h */ case    6:  		/* mr R7, R27 */
		/* 820B2870h case    6:*/		regs.R7 = regs.R27;
		/* 820B2870h case    6:*/		return 0x820B2874;
		  /* 820B2874h */ case    7:  		/* mr R6, R20 */
		/* 820B2874h case    7:*/		regs.R6 = regs.R20;
		/* 820B2874h case    7:*/		return 0x820B2878;
		  /* 820B2878h */ case    8:  		/* mr R5, R15 */
		/* 820B2878h case    8:*/		regs.R5 = regs.R15;
		/* 820B2878h case    8:*/		return 0x820B287C;
		  /* 820B287Ch */ case    9:  		/* mr R4, R29 */
		/* 820B287Ch case    9:*/		regs.R4 = regs.R29;
		/* 820B287Ch case    9:*/		return 0x820B2880;
		  /* 820B2880h */ case   10:  		/* mr R3, R30 */
		/* 820B2880h case   10:*/		regs.R3 = regs.R30;
		/* 820B2880h case   10:*/		return 0x820B2884;
		  /* 820B2884h */ case   11:  		/* bl -7548 */
		/* 820B2884h case   11:*/		regs.LR = 0x820B2888; return 0x820B0B08;
		/* 820B2884h case   11:*/		return 0x820B2888;
		  /* 820B2888h */ case   12:  		/* or. R31, R3, R3 */
		/* 820B2888h case   12:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2888h case   12:*/		return 0x820B288C;
		  /* 820B288Ch */ case   13:  		/* bc 12, CR0_LT, -576 */
		/* 820B288Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B288Ch case   13:*/		return 0x820B2890;
		  /* 820B2890h */ case   14:  		/* lwz R25, <#[R1 + 100]> */
		/* 820B2890h case   14:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000064) );
		/* 820B2890h case   14:*/		return 0x820B2894;
		  /* 820B2894h */ case   15:  		/* li R9, 4 */
		/* 820B2894h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2894h case   15:*/		return 0x820B2898;
		  /* 820B2898h */ case   16:  		/* mr R8, R20 */
		/* 820B2898h case   16:*/		regs.R8 = regs.R20;
		/* 820B2898h case   16:*/		return 0x820B289C;
		  /* 820B289Ch */ case   17:  		/* mr R7, R27 */
		/* 820B289Ch case   17:*/		regs.R7 = regs.R27;
		/* 820B289Ch case   17:*/		return 0x820B28A0;
		  /* 820B28A0h */ case   18:  		/* mr R6, R25 */
		/* 820B28A0h case   18:*/		regs.R6 = regs.R25;
		/* 820B28A0h case   18:*/		return 0x820B28A4;
		  /* 820B28A4h */ case   19:  		/* oris R5, R22, 8208 */
		/* 820B28A4h case   19:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R22,0x2010);
		/* 820B28A4h case   19:*/		return 0x820B28A8;
		  /* 820B28A8h */ case   20:  		/* mr R4, R29 */
		/* 820B28A8h case   20:*/		regs.R4 = regs.R29;
		/* 820B28A8h case   20:*/		return 0x820B28AC;
		  /* 820B28ACh */ case   21:  		/* mr R3, R30 */
		/* 820B28ACh case   21:*/		regs.R3 = regs.R30;
		/* 820B28ACh case   21:*/		return 0x820B28B0;
		  /* 820B28B0h */ case   22:  		/* bl -7592 */
		/* 820B28B0h case   22:*/		regs.LR = 0x820B28B4; return 0x820B0B08;
		/* 820B28B0h case   22:*/		return 0x820B28B4;
		  /* 820B28B4h */ case   23:  		/* or. R31, R3, R3 */
		/* 820B28B4h case   23:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B28B4h case   23:*/		return 0x820B28B8;
		  /* 820B28B8h */ case   24:  		/* bc 12, CR0_LT, -620 */
		/* 820B28B8h case   24:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B28B8h case   24:*/		return 0x820B28BC;
		  /* 820B28BCh */ case   25:  		/* lwz R26, <#[R1 + 104]> */
		/* 820B28BCh case   25:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000068) );
		/* 820B28BCh case   25:*/		return 0x820B28C0;
		  /* 820B28C0h */ case   26:  		/* li R9, 8 */
		/* 820B28C0h case   26:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820B28C0h case   26:*/		return 0x820B28C4;
		  /* 820B28C4h */ case   27:  		/* li R8, 0 */
		/* 820B28C4h case   27:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B28C4h case   27:*/		return 0x820B28C8;
		  /* 820B28C8h */ case   28:  		/* mr R7, R25 */
		/* 820B28C8h case   28:*/		regs.R7 = regs.R25;
		/* 820B28C8h case   28:*/		return 0x820B28CC;
		  /* 820B28CCh */ case   29:  		/* mr R6, R26 */
		/* 820B28CCh case   29:*/		regs.R6 = regs.R26;
		/* 820B28CCh case   29:*/		return 0x820B28D0;
		  /* 820B28D0h */ case   30:  		/* mr R5, R15 */
		/* 820B28D0h case   30:*/		regs.R5 = regs.R15;
		/* 820B28D0h case   30:*/		return 0x820B28D4;
		  /* 820B28D4h */ case   31:  		/* mr R4, R29 */
		/* 820B28D4h case   31:*/		regs.R4 = regs.R29;
		/* 820B28D4h case   31:*/		return 0x820B28D8;
		  /* 820B28D8h */ case   32:  		/* mr R3, R30 */
		/* 820B28D8h case   32:*/		regs.R3 = regs.R30;
		/* 820B28D8h case   32:*/		return 0x820B28DC;
		  /* 820B28DCh */ case   33:  		/* bl -7636 */
		/* 820B28DCh case   33:*/		regs.LR = 0x820B28E0; return 0x820B0B08;
		/* 820B28DCh case   33:*/		return 0x820B28E0;
		  /* 820B28E0h */ case   34:  		/* or. R31, R3, R3 */
		/* 820B28E0h case   34:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B28E0h case   34:*/		return 0x820B28E4;
		  /* 820B28E4h */ case   35:  		/* bc 12, CR0_LT, -664 */
		/* 820B28E4h case   35:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B28E4h case   35:*/		return 0x820B28E8;
		  /* 820B28E8h */ case   36:  		/* lwz R27, <#[R1 + 108]> */
		/* 820B28E8h case   36:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000006C) );
		/* 820B28E8h case   36:*/		return 0x820B28EC;
		  /* 820B28ECh */ case   37:  		/* oris R23, R22, 8256 */
		/* 820B28ECh case   37:*/		cpu::op::oris<0>(regs,&regs.R23,regs.R22,0x2040);
		/* 820B28ECh case   37:*/		return 0x820B28F0;
		  /* 820B28F0h */ case   38:  		/* li R9, 0 */
		/* 820B28F0h case   38:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B28F0h case   38:*/		return 0x820B28F4;
		  /* 820B28F4h */ case   39:  		/* mr R8, R24 */
		/* 820B28F4h case   39:*/		regs.R8 = regs.R24;
		/* 820B28F4h case   39:*/		return 0x820B28F8;
		  /* 820B28F8h */ case   40:  		/* mr R7, R26 */
		/* 820B28F8h case   40:*/		regs.R7 = regs.R26;
		/* 820B28F8h case   40:*/		return 0x820B28FC;
		  /* 820B28FCh */ case   41:  		/* mr R6, R27 */
		/* 820B28FCh case   41:*/		regs.R6 = regs.R27;
		/* 820B28FCh case   41:*/		return 0x820B2900;
		  /* 820B2900h */ case   42:  		/* mr R5, R23 */
		/* 820B2900h case   42:*/		regs.R5 = regs.R23;
		/* 820B2900h case   42:*/		return 0x820B2904;
		  /* 820B2904h */ case   43:  		/* mr R4, R29 */
		/* 820B2904h case   43:*/		regs.R4 = regs.R29;
		/* 820B2904h case   43:*/		return 0x820B2908;
		  /* 820B2908h */ case   44:  		/* mr R3, R30 */
		/* 820B2908h case   44:*/		regs.R3 = regs.R30;
		/* 820B2908h case   44:*/		return 0x820B290C;
		  /* 820B290Ch */ case   45:  		/* bl -7684 */
		/* 820B290Ch case   45:*/		regs.LR = 0x820B2910; return 0x820B0B08;
		/* 820B290Ch case   45:*/		return 0x820B2910;
		  /* 820B2910h */ case   46:  		/* or. R31, R3, R3 */
		/* 820B2910h case   46:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2910h case   46:*/		return 0x820B2914;
		  /* 820B2914h */ case   47:  		/* bc 12, CR0_LT, -712 */
		/* 820B2914h case   47:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2914h case   47:*/		return 0x820B2918;
		  /* 820B2918h */ case   48:  		/* lwz R26, <#[R1 + 112]> */
		/* 820B2918h case   48:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000070) );
		/* 820B2918h case   48:*/		return 0x820B291C;
		  /* 820B291Ch */ case   49:  		/* li R9, 4 */
		/* 820B291Ch case   49:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B291Ch case   49:*/		return 0x820B2920;
		  /* 820B2920h */ case   50:  		/* li R8, 0 */
		/* 820B2920h case   50:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B2920h case   50:*/		return 0x820B2924;
		  /* 820B2924h */ case   51:  		/* mr R7, R27 */
		/* 820B2924h case   51:*/		regs.R7 = regs.R27;
		/* 820B2924h case   51:*/		return 0x820B2928;
		  /* 820B2928h */ case   52:  		/* mr R6, R26 */
		/* 820B2928h case   52:*/		regs.R6 = regs.R26;
		/* 820B2928h case   52:*/		return 0x820B292C;
		  /* 820B292Ch */ case   53:  		/* oris R5, R22, 4208 */
		/* 820B292Ch case   53:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R22,0x1070);
		/* 820B292Ch case   53:*/		return 0x820B2930;
		  /* 820B2930h */ case   54:  		/* mr R4, R29 */
		/* 820B2930h case   54:*/		regs.R4 = regs.R29;
		/* 820B2930h case   54:*/		return 0x820B2934;
		  /* 820B2934h */ case   55:  		/* mr R3, R30 */
		/* 820B2934h case   55:*/		regs.R3 = regs.R30;
		/* 820B2934h case   55:*/		return 0x820B2938;
		  /* 820B2938h */ case   56:  		/* bl -7728 */
		/* 820B2938h case   56:*/		regs.LR = 0x820B293C; return 0x820B0B08;
		/* 820B2938h case   56:*/		return 0x820B293C;
		  /* 820B293Ch */ case   57:  		/* or. R31, R3, R3 */
		/* 820B293Ch case   57:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B293Ch case   57:*/		return 0x820B2940;
		  /* 820B2940h */ case   58:  		/* bc 12, CR0_LT, -756 */
		/* 820B2940h case   58:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2940h case   58:*/		return 0x820B2944;
		  /* 820B2944h */ case   59:  		/* lwz R21, <#[R1 + 116]> */
		/* 820B2944h case   59:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000074) );
		/* 820B2944h case   59:*/		return 0x820B2948;
		  /* 820B2948h */ case   60:  		/* li R9, 4 */
		/* 820B2948h case   60:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2948h case   60:*/		return 0x820B294C;
		  /* 820B294Ch */ case   61:  		/* li R8, 0 */
		/* 820B294Ch case   61:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B294Ch case   61:*/		return 0x820B2950;
		  /* 820B2950h */ case   62:  		/* mr R7, R26 */
		/* 820B2950h case   62:*/		regs.R7 = regs.R26;
		/* 820B2950h case   62:*/		return 0x820B2954;
		  /* 820B2954h */ case   63:  		/* mr R6, R21 */
		/* 820B2954h case   63:*/		regs.R6 = regs.R21;
		/* 820B2954h case   63:*/		return 0x820B2958;
		  /* 820B2958h */ case   64:  		/* oris R5, R22, 4144 */
		/* 820B2958h case   64:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R22,0x1030);
		/* 820B2958h case   64:*/		return 0x820B295C;
		  /* 820B295Ch */ case   65:  		/* mr R4, R29 */
		/* 820B295Ch case   65:*/		regs.R4 = regs.R29;
		/* 820B295Ch case   65:*/		return 0x820B2960;
		  /* 820B2960h */ case   66:  		/* mr R3, R30 */
		/* 820B2960h case   66:*/		regs.R3 = regs.R30;
		/* 820B2960h case   66:*/		return 0x820B2964;
		  /* 820B2964h */ case   67:  		/* bl -7772 */
		/* 820B2964h case   67:*/		regs.LR = 0x820B2968; return 0x820B0B08;
		/* 820B2964h case   67:*/		return 0x820B2968;
		  /* 820B2968h */ case   68:  		/* or. R31, R3, R3 */
		/* 820B2968h case   68:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2968h case   68:*/		return 0x820B296C;
		  /* 820B296Ch */ case   69:  		/* bc 12, CR0_LT, -800 */
		/* 820B296Ch case   69:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B296Ch case   69:*/		return 0x820B2970;
		  /* 820B2970h */ case   70:  		/* lwz R26, <#[R1 + 120]> */
		/* 820B2970h case   70:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000078) );
		/* 820B2970h case   70:*/		return 0x820B2974;
		  /* 820B2974h */ case   71:  		/* oris R27, R22, 8272 */
		/* 820B2974h case   71:*/		cpu::op::oris<0>(regs,&regs.R27,regs.R22,0x2050);
		/* 820B2974h case   71:*/		return 0x820B2978;
		  /* 820B2978h */ case   72:  		/* li R9, 0 */
		/* 820B2978h case   72:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2978h case   72:*/		return 0x820B297C;
		  /* 820B297Ch */ case   73:  		/* mr R8, R25 */
		/* 820B297Ch case   73:*/		regs.R8 = regs.R25;
		/* 820B297Ch case   73:*/		return 0x820B2980;
		  /* 820B2980h */ case   74:  		/* mr R7, R28 */
		/* 820B2980h case   74:*/		regs.R7 = regs.R28;
		/* 820B2980h case   74:*/		return 0x820B2984;
		  /* 820B2984h */ case   75:  		/* mr R6, R26 */
		/* 820B2984h case   75:*/		regs.R6 = regs.R26;
		/* 820B2984h case   75:*/		return 0x820B2988;
		  /* 820B2988h */ case   76:  		/* mr R5, R27 */
		/* 820B2988h case   76:*/		regs.R5 = regs.R27;
		/* 820B2988h case   76:*/		return 0x820B298C;
		  /* 820B298Ch */ case   77:  		/* mr R4, R29 */
		/* 820B298Ch case   77:*/		regs.R4 = regs.R29;
		/* 820B298Ch case   77:*/		return 0x820B2990;
		  /* 820B2990h */ case   78:  		/* mr R3, R30 */
		/* 820B2990h case   78:*/		regs.R3 = regs.R30;
		/* 820B2990h case   78:*/		return 0x820B2994;
		  /* 820B2994h */ case   79:  		/* bl -7820 */
		/* 820B2994h case   79:*/		regs.LR = 0x820B2998; return 0x820B0B08;
		/* 820B2994h case   79:*/		return 0x820B2998;
		  /* 820B2998h */ case   80:  		/* or. R31, R3, R3 */
		/* 820B2998h case   80:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2998h case   80:*/		return 0x820B299C;
		  /* 820B299Ch */ case   81:  		/* bc 12, CR0_LT, -848 */
		/* 820B299Ch case   81:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B299Ch case   81:*/		return 0x820B29A0;
		  /* 820B29A0h */ case   82:  		/* lwz R28, <#[R1 + 124]> */
		/* 820B29A0h case   82:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000007C) );
		/* 820B29A0h case   82:*/		return 0x820B29A4;
		  /* 820B29A4h */ case   83:  		/* li R9, 0 */
		/* 820B29A4h case   83:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B29A4h case   83:*/		return 0x820B29A8;
		  /* 820B29A8h */ case   84:  		/* mr R8, R19 */
		/* 820B29A8h case   84:*/		regs.R8 = regs.R19;
		/* 820B29A8h case   84:*/		return 0x820B29AC;
		  /* 820B29ACh */ case   85:  		/* mr R7, R26 */
		/* 820B29ACh case   85:*/		regs.R7 = regs.R26;
		/* 820B29ACh case   85:*/		return 0x820B29B0;
		  /* 820B29B0h */ case   86:  		/* mr R6, R28 */
		/* 820B29B0h case   86:*/		regs.R6 = regs.R28;
		/* 820B29B0h case   86:*/		return 0x820B29B4;
		  /* 820B29B4h */ case   87:  		/* mr R5, R23 */
		/* 820B29B4h case   87:*/		regs.R5 = regs.R23;
		/* 820B29B4h case   87:*/		return 0x820B29B8;
		  /* 820B29B8h */ case   88:  		/* mr R4, R29 */
		/* 820B29B8h case   88:*/		regs.R4 = regs.R29;
		/* 820B29B8h case   88:*/		return 0x820B29BC;
		  /* 820B29BCh */ case   89:  		/* mr R3, R30 */
		/* 820B29BCh case   89:*/		regs.R3 = regs.R30;
		/* 820B29BCh case   89:*/		return 0x820B29C0;
		  /* 820B29C0h */ case   90:  		/* bl -7864 */
		/* 820B29C0h case   90:*/		regs.LR = 0x820B29C4; return 0x820B0B08;
		/* 820B29C0h case   90:*/		return 0x820B29C4;
		  /* 820B29C4h */ case   91:  		/* or. R31, R3, R3 */
		/* 820B29C4h case   91:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B29C4h case   91:*/		return 0x820B29C8;
		  /* 820B29C8h */ case   92:  		/* bc 12, CR0_LT, -892 */
		/* 820B29C8h case   92:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B29C8h case   92:*/		return 0x820B29CC;
		  /* 820B29CCh */ case   93:  		/* lwz R26, <#[R1 + 128]> */
		/* 820B29CCh case   93:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000080) );
		/* 820B29CCh case   93:*/		return 0x820B29D0;
		  /* 820B29D0h */ case   94:  		/* li R9, 0 */
		/* 820B29D0h case   94:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B29D0h case   94:*/		return 0x820B29D4;
		  /* 820B29D4h */ case   95:  		/* mr R8, R25 */
		/* 820B29D4h case   95:*/		regs.R8 = regs.R25;
		/* 820B29D4h case   95:*/		return 0x820B29D8;
		  /* 820B29D8h */ case   96:  		/* mr R7, R28 */
		/* 820B29D8h case   96:*/		regs.R7 = regs.R28;
		/* 820B29D8h case   96:*/		return 0x820B29DC;
		  /* 820B29DCh */ case   97:  		/* mr R6, R26 */
		/* 820B29DCh case   97:*/		regs.R6 = regs.R26;
		/* 820B29DCh case   97:*/		return 0x820B29E0;
		  /* 820B29E0h */ case   98:  		/* mr R5, R27 */
		/* 820B29E0h case   98:*/		regs.R5 = regs.R27;
		/* 820B29E0h case   98:*/		return 0x820B29E4;
		  /* 820B29E4h */ case   99:  		/* mr R4, R29 */
		/* 820B29E4h case   99:*/		regs.R4 = regs.R29;
		/* 820B29E4h case   99:*/		return 0x820B29E8;
		  /* 820B29E8h */ case  100:  		/* mr R3, R30 */
		/* 820B29E8h case  100:*/		regs.R3 = regs.R30;
		/* 820B29E8h case  100:*/		return 0x820B29EC;
		  /* 820B29ECh */ case  101:  		/* bl -7908 */
		/* 820B29ECh case  101:*/		regs.LR = 0x820B29F0; return 0x820B0B08;
		/* 820B29ECh case  101:*/		return 0x820B29F0;
		  /* 820B29F0h */ case  102:  		/* or. R31, R3, R3 */
		/* 820B29F0h case  102:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B29F0h case  102:*/		return 0x820B29F4;
		  /* 820B29F4h */ case  103:  		/* bc 12, CR0_LT, -936 */
		/* 820B29F4h case  103:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B29F4h case  103:*/		return 0x820B29F8;
		  /* 820B29F8h */ case  104:  		/* lwz R28, <#[R1 + 132]> */
		/* 820B29F8h case  104:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000084) );
		/* 820B29F8h case  104:*/		return 0x820B29FC;
		  /* 820B29FCh */ case  105:  		/* li R9, 0 */
		/* 820B29FCh case  105:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B29FCh case  105:*/		return 0x820B2A00;
		  /* 820B2A00h */ case  106:  		/* mr R8, R18 */
		/* 820B2A00h case  106:*/		regs.R8 = regs.R18;
		/* 820B2A00h case  106:*/		return 0x820B2A04;
		  /* 820B2A04h */ case  107:  		/* mr R7, R26 */
		/* 820B2A04h case  107:*/		regs.R7 = regs.R26;
		/* 820B2A04h case  107:*/		return 0x820B2A08;
		  /* 820B2A08h */ case  108:  		/* mr R6, R28 */
		/* 820B2A08h case  108:*/		regs.R6 = regs.R28;
		/* 820B2A08h case  108:*/		return 0x820B2A0C;
		  /* 820B2A0Ch */ case  109:  		/* mr R5, R23 */
		/* 820B2A0Ch case  109:*/		regs.R5 = regs.R23;
		/* 820B2A0Ch case  109:*/		return 0x820B2A10;
		  /* 820B2A10h */ case  110:  		/* mr R4, R29 */
		/* 820B2A10h case  110:*/		regs.R4 = regs.R29;
		/* 820B2A10h case  110:*/		return 0x820B2A14;
		  /* 820B2A14h */ case  111:  		/* mr R3, R30 */
		/* 820B2A14h case  111:*/		regs.R3 = regs.R30;
		/* 820B2A14h case  111:*/		return 0x820B2A18;
		  /* 820B2A18h */ case  112:  		/* bl -7952 */
		/* 820B2A18h case  112:*/		regs.LR = 0x820B2A1C; return 0x820B0B08;
		/* 820B2A18h case  112:*/		return 0x820B2A1C;
		  /* 820B2A1Ch */ case  113:  		/* or. R31, R3, R3 */
		/* 820B2A1Ch case  113:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2A1Ch case  113:*/		return 0x820B2A20;
		  /* 820B2A20h */ case  114:  		/* bc 12, CR0_LT, -980 */
		/* 820B2A20h case  114:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2A20h case  114:*/		return 0x820B2A24;
		  /* 820B2A24h */ case  115:  		/* lwz R26, <#[R1 + 136]> */
		/* 820B2A24h case  115:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000088) );
		/* 820B2A24h case  115:*/		return 0x820B2A28;
		  /* 820B2A28h */ case  116:  		/* li R9, 0 */
		/* 820B2A28h case  116:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2A28h case  116:*/		return 0x820B2A2C;
		  /* 820B2A2Ch */ case  117:  		/* mr R8, R25 */
		/* 820B2A2Ch case  117:*/		regs.R8 = regs.R25;
		/* 820B2A2Ch case  117:*/		return 0x820B2A30;
		  /* 820B2A30h */ case  118:  		/* mr R7, R28 */
		/* 820B2A30h case  118:*/		regs.R7 = regs.R28;
		/* 820B2A30h case  118:*/		return 0x820B2A34;
		  /* 820B2A34h */ case  119:  		/* mr R6, R26 */
		/* 820B2A34h case  119:*/		regs.R6 = regs.R26;
		/* 820B2A34h case  119:*/		return 0x820B2A38;
		  /* 820B2A38h */ case  120:  		/* mr R5, R27 */
		/* 820B2A38h case  120:*/		regs.R5 = regs.R27;
		/* 820B2A38h case  120:*/		return 0x820B2A3C;
		  /* 820B2A3Ch */ case  121:  		/* mr R4, R29 */
		/* 820B2A3Ch case  121:*/		regs.R4 = regs.R29;
		/* 820B2A3Ch case  121:*/		return 0x820B2A40;
		  /* 820B2A40h */ case  122:  		/* mr R3, R30 */
		/* 820B2A40h case  122:*/		regs.R3 = regs.R30;
		/* 820B2A40h case  122:*/		return 0x820B2A44;
		  /* 820B2A44h */ case  123:  		/* bl -7996 */
		/* 820B2A44h case  123:*/		regs.LR = 0x820B2A48; return 0x820B0B08;
		/* 820B2A44h case  123:*/		return 0x820B2A48;
		  /* 820B2A48h */ case  124:  		/* or. R31, R3, R3 */
		/* 820B2A48h case  124:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2A48h case  124:*/		return 0x820B2A4C;
		  /* 820B2A4Ch */ case  125:  		/* bc 12, CR0_LT, -1024 */
		/* 820B2A4Ch case  125:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2A4Ch case  125:*/		return 0x820B2A50;
		  /* 820B2A50h */ case  126:  		/* lwz R28, <#[R1 + 140]> */
		/* 820B2A50h case  126:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000008C) );
		/* 820B2A50h case  126:*/		return 0x820B2A54;
		  /* 820B2A54h */ case  127:  		/* li R9, 0 */
		/* 820B2A54h case  127:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2A54h case  127:*/		return 0x820B2A58;
		  /* 820B2A58h */ case  128:  		/* mr R8, R17 */
		/* 820B2A58h case  128:*/		regs.R8 = regs.R17;
		/* 820B2A58h case  128:*/		return 0x820B2A5C;
		  /* 820B2A5Ch */ case  129:  		/* mr R7, R26 */
		/* 820B2A5Ch case  129:*/		regs.R7 = regs.R26;
		/* 820B2A5Ch case  129:*/		return 0x820B2A60;
		  /* 820B2A60h */ case  130:  		/* mr R6, R28 */
		/* 820B2A60h case  130:*/		regs.R6 = regs.R28;
		/* 820B2A60h case  130:*/		return 0x820B2A64;
		  /* 820B2A64h */ case  131:  		/* mr R5, R23 */
		/* 820B2A64h case  131:*/		regs.R5 = regs.R23;
		/* 820B2A64h case  131:*/		return 0x820B2A68;
		  /* 820B2A68h */ case  132:  		/* mr R4, R29 */
		/* 820B2A68h case  132:*/		regs.R4 = regs.R29;
		/* 820B2A68h case  132:*/		return 0x820B2A6C;
		  /* 820B2A6Ch */ case  133:  		/* mr R3, R30 */
		/* 820B2A6Ch case  133:*/		regs.R3 = regs.R30;
		/* 820B2A6Ch case  133:*/		return 0x820B2A70;
		  /* 820B2A70h */ case  134:  		/* bl -8040 */
		/* 820B2A70h case  134:*/		regs.LR = 0x820B2A74; return 0x820B0B08;
		/* 820B2A70h case  134:*/		return 0x820B2A74;
		  /* 820B2A74h */ case  135:  		/* or. R31, R3, R3 */
		/* 820B2A74h case  135:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2A74h case  135:*/		return 0x820B2A78;
		  /* 820B2A78h */ case  136:  		/* bc 12, CR0_LT, -1068 */
		/* 820B2A78h case  136:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2A78h case  136:*/		return 0x820B2A7C;
		  /* 820B2A7Ch */ case  137:  		/* lwz R24, <#[R1 + 144]> */
		/* 820B2A7Ch case  137:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000090) );
		/* 820B2A7Ch case  137:*/		return 0x820B2A80;
		  /* 820B2A80h */ case  138:  		/* li R9, 0 */
		/* 820B2A80h case  138:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2A80h case  138:*/		return 0x820B2A84;
		  /* 820B2A84h */ case  139:  		/* mr R8, R21 */
		/* 820B2A84h case  139:*/		regs.R8 = regs.R21;
		/* 820B2A84h case  139:*/		return 0x820B2A88;
		  /* 820B2A88h */ case  140:  		/* mr R7, R28 */
		/* 820B2A88h case  140:*/		regs.R7 = regs.R28;
		/* 820B2A88h case  140:*/		return 0x820B2A8C;
		  /* 820B2A8Ch */ case  141:  		/* mr R6, R24 */
		/* 820B2A8Ch case  141:*/		regs.R6 = regs.R24;
		/* 820B2A8Ch case  141:*/		return 0x820B2A90;
		  /* 820B2A90h */ case  142:  		/* mr R5, R27 */
		/* 820B2A90h case  142:*/		regs.R5 = regs.R27;
		/* 820B2A90h case  142:*/		return 0x820B2A94;
		  /* 820B2A94h */ case  143:  		/* mr R4, R29 */
		/* 820B2A94h case  143:*/		regs.R4 = regs.R29;
		/* 820B2A94h case  143:*/		return 0x820B2A98;
		  /* 820B2A98h */ case  144:  		/* mr R3, R30 */
		/* 820B2A98h case  144:*/		regs.R3 = regs.R30;
		/* 820B2A98h case  144:*/		return 0x820B2A9C;
		  /* 820B2A9Ch */ case  145:  		/* bl -8084 */
		/* 820B2A9Ch case  145:*/		regs.LR = 0x820B2AA0; return 0x820B0B08;
		/* 820B2A9Ch case  145:*/		return 0x820B2AA0;
		  /* 820B2AA0h */ case  146:  		/* or. R31, R3, R3 */
		/* 820B2AA0h case  146:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2AA0h case  146:*/		return 0x820B2AA4;
		  /* 820B2AA4h */ case  147:  		/* bc 12, CR0_LT, -1112 */
		/* 820B2AA4h case  147:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2AA4h case  147:*/		return 0x820B2AA8;
		  /* 820B2AA8h */ case  148:  		/* lwz R28, <#[R1 + 148]> */
		/* 820B2AA8h case  148:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000094) );
		/* 820B2AA8h case  148:*/		return 0x820B2AAC;
		  /* 820B2AACh */ case  149:  		/* li R9, 0 */
		/* 820B2AACh case  149:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2AACh case  149:*/		return 0x820B2AB0;
		  /* 820B2AB0h */ case  150:  		/* mr R8, R16 */
		/* 820B2AB0h case  150:*/		regs.R8 = regs.R16;
		/* 820B2AB0h case  150:*/		return 0x820B2AB4;
		  /* 820B2AB4h */ case  151:  		/* mr R7, R24 */
		/* 820B2AB4h case  151:*/		regs.R7 = regs.R24;
		/* 820B2AB4h case  151:*/		return 0x820B2AB8;
		  /* 820B2AB8h */ case  152:  		/* mr R6, R28 */
		/* 820B2AB8h case  152:*/		regs.R6 = regs.R28;
		/* 820B2AB8h case  152:*/		return 0x820B2ABC;
		  /* 820B2ABCh */ case  153:  		/* mr R5, R27 */
		/* 820B2ABCh case  153:*/		regs.R5 = regs.R27;
		/* 820B2ABCh case  153:*/		return 0x820B2AC0;
		  /* 820B2AC0h */ case  154:  		/* mr R4, R29 */
		/* 820B2AC0h case  154:*/		regs.R4 = regs.R29;
		/* 820B2AC0h case  154:*/		return 0x820B2AC4;
		  /* 820B2AC4h */ case  155:  		/* mr R3, R30 */
		/* 820B2AC4h case  155:*/		regs.R3 = regs.R30;
		/* 820B2AC4h case  155:*/		return 0x820B2AC8;
		  /* 820B2AC8h */ case  156:  		/* bl -8128 */
		/* 820B2AC8h case  156:*/		regs.LR = 0x820B2ACC; return 0x820B0B08;
		/* 820B2AC8h case  156:*/		return 0x820B2ACC;
		  /* 820B2ACCh */ case  157:  		/* or. R31, R3, R3 */
		/* 820B2ACCh case  157:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2ACCh case  157:*/		return 0x820B2AD0;
		  /* 820B2AD0h */ case  158:  		/* bc 12, CR0_LT, -1156 */
		/* 820B2AD0h case  158:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2AD0h case  158:*/		return 0x820B2AD4;
		  /* 820B2AD4h */ case  159:  		/* lwz R25, <#[R1 + 152]> */
		/* 820B2AD4h case  159:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000098) );
		/* 820B2AD4h case  159:*/		return 0x820B2AD8;
		  /* 820B2AD8h */ case  160:  		/* li R9, 0 */
		/* 820B2AD8h case  160:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2AD8h case  160:*/		return 0x820B2ADC;
		  /* 820B2ADCh */ case  161:  		/* mr R8, R14 */
		/* 820B2ADCh case  161:*/		regs.R8 = regs.R14;
		/* 820B2ADCh case  161:*/		return 0x820B2AE0;
		  /* 820B2AE0h */ case  162:  		/* mr R7, R28 */
		/* 820B2AE0h case  162:*/		regs.R7 = regs.R28;
		/* 820B2AE0h case  162:*/		return 0x820B2AE4;
		  /* 820B2AE4h */ case  163:  		/* mr R6, R25 */
		/* 820B2AE4h case  163:*/		regs.R6 = regs.R25;
		/* 820B2AE4h case  163:*/		return 0x820B2AE8;
		  /* 820B2AE8h */ case  164:  		/* mr R5, R23 */
		/* 820B2AE8h case  164:*/		regs.R5 = regs.R23;
		/* 820B2AE8h case  164:*/		return 0x820B2AEC;
		  /* 820B2AECh */ case  165:  		/* mr R4, R29 */
		/* 820B2AECh case  165:*/		regs.R4 = regs.R29;
		/* 820B2AECh case  165:*/		return 0x820B2AF0;
		  /* 820B2AF0h */ case  166:  		/* mr R3, R30 */
		/* 820B2AF0h case  166:*/		regs.R3 = regs.R30;
		/* 820B2AF0h case  166:*/		return 0x820B2AF4;
		  /* 820B2AF4h */ case  167:  		/* bl -8172 */
		/* 820B2AF4h case  167:*/		regs.LR = 0x820B2AF8; return 0x820B0B08;
		/* 820B2AF4h case  167:*/		return 0x820B2AF8;
		  /* 820B2AF8h */ case  168:  		/* or. R31, R3, R3 */
		/* 820B2AF8h case  168:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2AF8h case  168:*/		return 0x820B2AFC;
		  /* 820B2AFCh */ case  169:  		/* bc 12, CR0_LT, -1200 */
		/* 820B2AFCh case  169:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2AFCh case  169:*/		return 0x820B2B00;
		  /* 820B2B00h */ case  170:  		/* lwz R26, <#[R1 + 156]> */
		/* 820B2B00h case  170:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x0000009C) );
		/* 820B2B00h case  170:*/		return 0x820B2B04;
		  /* 820B2B04h */ case  171:  		/* li R9, 23 */
		/* 820B2B04h case  171:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B2B04h case  171:*/		return 0x820B2B08;
		  /* 820B2B08h */ case  172:  		/* mr R8, R20 */
		/* 820B2B08h case  172:*/		regs.R8 = regs.R20;
		/* 820B2B08h case  172:*/		return 0x820B2B0C;
		  /* 820B2B0Ch */ case  173:  		/* lwz R7, <#[R1 + 404]> */
		/* 820B2B0Ch case  173:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000194) );
		/* 820B2B0Ch case  173:*/		return 0x820B2B10;
		  /* 820B2B10h */ case  174:  		/* mr R6, R26 */
		/* 820B2B10h case  174:*/		regs.R6 = regs.R26;
		/* 820B2B10h case  174:*/		return 0x820B2B14;
		  /* 820B2B14h */ case  175:  		/* oris R5, R22, 8224 */
		/* 820B2B14h case  175:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R22,0x2020);
		/* 820B2B14h case  175:*/		return 0x820B2B18;
		  /* 820B2B18h */ case  176:  		/* mr R4, R29 */
		/* 820B2B18h case  176:*/		regs.R4 = regs.R29;
		/* 820B2B18h case  176:*/		return 0x820B2B1C;
		  /* 820B2B1Ch */ case  177:  		/* mr R3, R30 */
		/* 820B2B1Ch case  177:*/		regs.R3 = regs.R30;
		/* 820B2B1Ch case  177:*/		return 0x820B2B20;
		  /* 820B2B20h */ case  178:  		/* bl -8216 */
		/* 820B2B20h case  178:*/		regs.LR = 0x820B2B24; return 0x820B0B08;
		/* 820B2B20h case  178:*/		return 0x820B2B24;
		  /* 820B2B24h */ case  179:  		/* or. R31, R3, R3 */
		/* 820B2B24h case  179:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2B24h case  179:*/		return 0x820B2B28;
		  /* 820B2B28h */ case  180:  		/* bc 12, CR0_LT, -1244 */
		/* 820B2B28h case  180:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2B28h case  180:*/		return 0x820B2B2C;
		  /* 820B2B2Ch */ case  181:  		/* lwz R28, <#[R1 + 160]> */
		/* 820B2B2Ch case  181:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B2B2Ch case  181:*/		return 0x820B2B30;
		  /* 820B2B30h */ case  182:  		/* li R9, 0 */
		/* 820B2B30h case  182:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2B30h case  182:*/		return 0x820B2B34;
		  /* 820B2B34h */ case  183:  		/* mr R8, R26 */
		/* 820B2B34h case  183:*/		regs.R8 = regs.R26;
		/* 820B2B34h case  183:*/		return 0x820B2B38;
		  /* 820B2B38h */ case  184:  		/* mr R7, R25 */
		/* 820B2B38h case  184:*/		regs.R7 = regs.R25;
		/* 820B2B38h case  184:*/		return 0x820B2B3C;
		  /* 820B2B3Ch */ case  185:  		/* mr R6, R28 */
		/* 820B2B3Ch case  185:*/		regs.R6 = regs.R28;
		/* 820B2B3Ch case  185:*/		return 0x820B2B40;
		  /* 820B2B40h */ case  186:  		/* mr R5, R27 */
		/* 820B2B40h case  186:*/		regs.R5 = regs.R27;
		/* 820B2B40h case  186:*/		return 0x820B2B44;
		  /* 820B2B44h */ case  187:  		/* mr R4, R29 */
		/* 820B2B44h case  187:*/		regs.R4 = regs.R29;
		/* 820B2B44h case  187:*/		return 0x820B2B48;
		  /* 820B2B48h */ case  188:  		/* mr R3, R30 */
		/* 820B2B48h case  188:*/		regs.R3 = regs.R30;
		/* 820B2B48h case  188:*/		return 0x820B2B4C;
		  /* 820B2B4Ch */ case  189:  		/* bl -8260 */
		/* 820B2B4Ch case  189:*/		regs.LR = 0x820B2B50; return 0x820B0B08;
		/* 820B2B4Ch case  189:*/		return 0x820B2B50;
		  /* 820B2B50h */ case  190:  		/* or. R31, R3, R3 */
		/* 820B2B50h case  190:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2B50h case  190:*/		return 0x820B2B54;
		  /* 820B2B54h */ case  191:  		/* bc 12, CR0_LT, -1288 */
		/* 820B2B54h case  191:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2B54h case  191:*/		return 0x820B2B58;
		  /* 820B2B58h */ case  192:  		/* lwz R26, <#[R1 + 164]> */
		/* 820B2B58h case  192:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B2B58h case  192:*/		return 0x820B2B5C;
		  /* 820B2B5Ch */ case  193:  		/* li R9, 4 */
		/* 820B2B5Ch case  193:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2B5Ch case  193:*/		return 0x820B2B60;
		  /* 820B2B60h */ case  194:  		/* mr R8, R28 */
		/* 820B2B60h case  194:*/		regs.R8 = regs.R28;
		/* 820B2B60h case  194:*/		return 0x820B2B64;
		  /* 820B2B64h */ case  195:  		/* mr R7, R24 */
		/* 820B2B64h case  195:*/		regs.R7 = regs.R24;
		/* 820B2B64h case  195:*/		return 0x820B2B68;
		  /* 820B2B68h */ case  196:  		/* mr R6, R26 */
		/* 820B2B68h case  196:*/		regs.R6 = regs.R26;
		/* 820B2B68h case  196:*/		return 0x820B2B6C;
		  /* 820B2B6Ch */ case  197:  		/* mr R5, R23 */
		/* 820B2B6Ch case  197:*/		regs.R5 = regs.R23;
		/* 820B2B6Ch case  197:*/		return 0x820B2B70;
		  /* 820B2B70h */ case  198:  		/* mr R4, R29 */
		/* 820B2B70h case  198:*/		regs.R4 = regs.R29;
		/* 820B2B70h case  198:*/		return 0x820B2B74;
		  /* 820B2B74h */ case  199:  		/* mr R3, R30 */
		/* 820B2B74h case  199:*/		regs.R3 = regs.R30;
		/* 820B2B74h case  199:*/		return 0x820B2B78;
		  /* 820B2B78h */ case  200:  		/* bl -8304 */
		/* 820B2B78h case  200:*/		regs.LR = 0x820B2B7C; return 0x820B0B08;
		/* 820B2B78h case  200:*/		return 0x820B2B7C;
		  /* 820B2B7Ch */ case  201:  		/* or. R31, R3, R3 */
		/* 820B2B7Ch case  201:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2B7Ch case  201:*/		return 0x820B2B80;
		  /* 820B2B80h */ case  202:  		/* bc 12, CR0_LT, -1332 */
		/* 820B2B80h case  202:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2B80h case  202:*/		return 0x820B2B84;
		  /* 820B2B84h */ case  203:  		/* lwz R28, <#[R1 + 168]> */
		/* 820B2B84h case  203:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A8) );
		/* 820B2B84h case  203:*/		return 0x820B2B88;
		  /* 820B2B88h */ case  204:  		/* li R9, 8 */
		/* 820B2B88h case  204:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820B2B88h case  204:*/		return 0x820B2B8C;
		  /* 820B2B8Ch */ case  205:  		/* li R8, 0 */
		/* 820B2B8Ch case  205:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B2B8Ch case  205:*/		return 0x820B2B90;
		  /* 820B2B90h */ case  206:  		/* mr R7, R26 */
		/* 820B2B90h case  206:*/		regs.R7 = regs.R26;
		/* 820B2B90h case  206:*/		return 0x820B2B94;
		  /* 820B2B94h */ case  207:  		/* mr R6, R28 */
		/* 820B2B94h case  207:*/		regs.R6 = regs.R28;
		/* 820B2B94h case  207:*/		return 0x820B2B98;
		  /* 820B2B98h */ case  208:  		/* mr R5, R15 */
		/* 820B2B98h case  208:*/		regs.R5 = regs.R15;
		/* 820B2B98h case  208:*/		return 0x820B2B9C;
		  /* 820B2B9Ch */ case  209:  		/* mr R4, R29 */
		/* 820B2B9Ch case  209:*/		regs.R4 = regs.R29;
		/* 820B2B9Ch case  209:*/		return 0x820B2BA0;
		  /* 820B2BA0h */ case  210:  		/* mr R3, R30 */
		/* 820B2BA0h case  210:*/		regs.R3 = regs.R30;
		/* 820B2BA0h case  210:*/		return 0x820B2BA4;
		  /* 820B2BA4h */ case  211:  		/* bl -8348 */
		/* 820B2BA4h case  211:*/		regs.LR = 0x820B2BA8; return 0x820B0B08;
		/* 820B2BA4h case  211:*/		return 0x820B2BA8;
		  /* 820B2BA8h */ case  212:  		/* or. R31, R3, R3 */
		/* 820B2BA8h case  212:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2BA8h case  212:*/		return 0x820B2BAC;
		  /* 820B2BACh */ case  213:  		/* bc 12, CR0_LT, -1376 */
		/* 820B2BACh case  213:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2BACh case  213:*/		return 0x820B2BB0;
		  /* 820B2BB0h */ case  214:  		/* lwz R27, <#[R1 + 172]> */
		/* 820B2BB0h case  214:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000AC) );
		/* 820B2BB0h case  214:*/		return 0x820B2BB4;
		  /* 820B2BB4h */ case  215:  		/* li R9, 0 */
		/* 820B2BB4h case  215:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2BB4h case  215:*/		return 0x820B2BB8;
		  /* 820B2BB8h */ case  216:  		/* mr R7, R28 */
		/* 820B2BB8h case  216:*/		regs.R7 = regs.R28;
		/* 820B2BB8h case  216:*/		return 0x820B2BBC;
		  /* 820B2BBCh */ case  217:  		/* lwz R8, <#[R1 + 204]> */
		/* 820B2BBCh case  217:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000CC) );
		/* 820B2BBCh case  217:*/		return 0x820B2BC0;
		  /* 820B2BC0h */ case  218:  		/* mr R6, R27 */
		/* 820B2BC0h case  218:*/		regs.R6 = regs.R27;
		/* 820B2BC0h case  218:*/		return 0x820B2BC4;
		  /* 820B2BC4h */ case  219:  		/* mr R5, R23 */
		/* 820B2BC4h case  219:*/		regs.R5 = regs.R23;
		/* 820B2BC4h case  219:*/		return 0x820B2BC8;
		  /* 820B2BC8h */ case  220:  		/* mr R4, R29 */
		/* 820B2BC8h case  220:*/		regs.R4 = regs.R29;
		/* 820B2BC8h case  220:*/		return 0x820B2BCC;
		  /* 820B2BCCh */ case  221:  		/* mr R3, R30 */
		/* 820B2BCCh case  221:*/		regs.R3 = regs.R30;
		/* 820B2BCCh case  221:*/		return 0x820B2BD0;
		  /* 820B2BD0h */ case  222:  		/* bl -8392 */
		/* 820B2BD0h case  222:*/		regs.LR = 0x820B2BD4; return 0x820B0B08;
		/* 820B2BD0h case  222:*/		return 0x820B2BD4;
		  /* 820B2BD4h */ case  223:  		/* or. R31, R3, R3 */
		/* 820B2BD4h case  223:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2BD4h case  223:*/		return 0x820B2BD8;
		  /* 820B2BD8h */ case  224:  		/* bc 12, CR0_LT, -1420 */
		/* 820B2BD8h case  224:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2BD8h case  224:*/		return 0x820B2BDC;
		  /* 820B2BDCh */ case  225:  		/* lwz R6, <#[R1 + 412]> */
		/* 820B2BDCh case  225:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000019C) );
		/* 820B2BDCh case  225:*/		return 0x820B2BE0;
		  /* 820B2BE0h */ case  226:  		/* cmplwi CR6, R6, 0 */
		/* 820B2BE0h case  226:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820B2BE0h case  226:*/		return 0x820B2BE4;
		  /* 820B2BE4h */ case  227:  		/* bc 12, CR6_EQ, 40 */
		/* 820B2BE4h case  227:*/		if ( regs.CR[6].eq ) { return 0x820B2C0C;  }
		/* 820B2BE4h case  227:*/		return 0x820B2BE8;
		  /* 820B2BE8h */ case  228:  		/* li R9, 0 */
		/* 820B2BE8h case  228:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2BE8h case  228:*/		return 0x820B2BEC;
		  /* 820B2BECh */ case  229:  		/* li R8, 0 */
		/* 820B2BECh case  229:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B2BECh case  229:*/		return 0x820B2BF0;
		  /* 820B2BF0h */ case  230:  		/* mr R7, R27 */
		/* 820B2BF0h case  230:*/		regs.R7 = regs.R27;
		/* 820B2BF0h case  230:*/		return 0x820B2BF4;
		  /* 820B2BF4h */ case  231:  		/* oris R5, R22, 4096 */
		/* 820B2BF4h case  231:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R22,0x1000);
		/* 820B2BF4h case  231:*/		return 0x820B2BF8;
		  /* 820B2BF8h */ case  232:  		/* mr R4, R29 */
		/* 820B2BF8h case  232:*/		regs.R4 = regs.R29;
		/* 820B2BF8h case  232:*/		return 0x820B2BFC;
		  /* 820B2BFCh */ case  233:  		/* mr R3, R30 */
		/* 820B2BFCh case  233:*/		regs.R3 = regs.R30;
		/* 820B2BFCh case  233:*/		return 0x820B2C00;
		  /* 820B2C00h */ case  234:  		/* bl -8440 */
		/* 820B2C00h case  234:*/		regs.LR = 0x820B2C04; return 0x820B0B08;
		/* 820B2C00h case  234:*/		return 0x820B2C04;
		  /* 820B2C04h */ case  235:  		/* or. R31, R3, R3 */
		/* 820B2C04h case  235:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2C04h case  235:*/		return 0x820B2C08;
		  /* 820B2C08h */ case  236:  		/* bc 12, CR0_LT, -1468 */
		/* 820B2C08h case  236:*/		if ( regs.CR[0].lt ) { return 0x820B264C;  }
		/* 820B2C08h case  236:*/		return 0x820B2C0C;
	}
	return 0x820B2C0C;
} // Block from 820B2858h-820B2C0Ch (237 instructions)

//////////////////////////////////////////////////////
// Block at 820B2C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2C0C);
		  /* 820B2C0Ch */ case    0:  		/* lwz R6, <#[R1 + 420]> */
		/* 820B2C0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000001A4) );
		/* 820B2C0Ch case    0:*/		return 0x820B2C10;
		  /* 820B2C10h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 820B2C10h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820B2C10h case    1:*/		return 0x820B2C14;
		  /* 820B2C14h */ case    2:  		/* bc 12, CR6_EQ, -1484 */
		/* 820B2C14h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B2648;  }
		/* 820B2C14h case    2:*/		return 0x820B2C18;
		  /* 820B2C18h */ case    3:  		/* mr R7, R26 */
		/* 820B2C18h case    3:*/		regs.R7 = regs.R26;
		/* 820B2C18h case    3:*/		return 0x820B2C1C;
		  /* 820B2C1Ch */ case    4:  		/* oris R5, R22, 4096 */
		/* 820B2C1Ch case    4:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R22,0x1000);
		/* 820B2C1Ch case    4:*/		return 0x820B2C20;
		  /* 820B2C20h */ case    5:  		/* b -1524 */
		/* 820B2C20h case    5:*/		return 0x820B262C;
		/* 820B2C20h case    5:*/		return 0x820B2C24;
		  /* 820B2C24h */ case    6:  		/* nop */
		/* 820B2C24h case    6:*/		cpu::op::nop();
		/* 820B2C24h case    6:*/		return 0x820B2C28;
	}
	return 0x820B2C28;
} // Block from 820B2C0Ch-820B2C28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B2C28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2C28);
		  /* 820B2C28h */ case    0:  		/* mfspr R12, LR */
		/* 820B2C28h case    0:*/		regs.R12 = regs.LR;
		/* 820B2C28h case    0:*/		return 0x820B2C2C;
		  /* 820B2C2Ch */ case    1:  		/* bl -137740 */
		/* 820B2C2Ch case    1:*/		regs.LR = 0x820B2C30; return 0x82091220;
		/* 820B2C2Ch case    1:*/		return 0x820B2C30;
		  /* 820B2C30h */ case    2:  		/* stwu R1, <#[R1 - 448]> */
		/* 820B2C30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE40);
		/* 820B2C30h case    2:*/		return 0x820B2C34;
		  /* 820B2C34h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 820B2C34h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820B2C34h case    3:*/		return 0x820B2C38;
		  /* 820B2C38h */ case    4:  		/* li R9, 0 */
		/* 820B2C38h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2C38h case    4:*/		return 0x820B2C3C;
		  /* 820B2C3Ch */ case    5:  		/* mr R11, R6 */
		/* 820B2C3Ch case    5:*/		regs.R11 = regs.R6;
		/* 820B2C3Ch case    5:*/		return 0x820B2C40;
		  /* 820B2C40h */ case    6:  		/* stw R6, <#[R1 + 492]> */
		/* 820B2C40h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001EC) );
		/* 820B2C40h case    6:*/		return 0x820B2C44;
		  /* 820B2C44h */ case    7:  		/* mr R30, R3 */
		/* 820B2C44h case    7:*/		regs.R30 = regs.R3;
		/* 820B2C44h case    7:*/		return 0x820B2C48;
		  /* 820B2C48h */ case    8:  		/* stw R5, <#[R1 + 484]> */
		/* 820B2C48h case    8:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000001E4) );
		/* 820B2C48h case    8:*/		return 0x820B2C4C;
		  /* 820B2C4Ch */ case    9:  		/* mr R29, R4 */
		/* 820B2C4Ch case    9:*/		regs.R29 = regs.R4;
		/* 820B2C4Ch case    9:*/		return 0x820B2C50;
		  /* 820B2C50h */ case   10:  		/* stw R7, <#[R1 + 500]> */
		/* 820B2C50h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x000001F4) );
		/* 820B2C50h case   10:*/		return 0x820B2C54;
		  /* 820B2C54h */ case   11:  		/* mr R14, R5 */
		/* 820B2C54h case   11:*/		regs.R14 = regs.R5;
		/* 820B2C54h case   11:*/		return 0x820B2C58;
		  /* 820B2C58h */ case   12:  		/* stw R9, <#[R1 + 80]> */
		/* 820B2C58h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820B2C58h case   12:*/		return 0x820B2C5C;
		  /* 820B2C5Ch */ case   13:  		/* lwz R10, <#[R10 + 108]> */
		/* 820B2C5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000006C) );
		/* 820B2C5Ch case   13:*/		return 0x820B2C60;
		  /* 820B2C60h */ case   14:  		/* mr R6, R7 */
		/* 820B2C60h case   14:*/		regs.R6 = regs.R7;
		/* 820B2C60h case   14:*/		return 0x820B2C64;
		  /* 820B2C64h */ case   15:  		/* mr R31, R8 */
		/* 820B2C64h case   15:*/		regs.R31 = regs.R8;
		/* 820B2C64h case   15:*/		return 0x820B2C68;
		  /* 820B2C68h */ case   16:  		/* rlwinm. R10, R10, 0, 10, 10 */
		/* 820B2C68h case   16:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R10,regs.R10);
		/* 820B2C68h case   16:*/		return 0x820B2C6C;
		  /* 820B2C6Ch */ case   17:  		/* bc 12, CR0_EQ, 52 */
		/* 820B2C6Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x820B2CA0;  }
		/* 820B2C6Ch case   17:*/		return 0x820B2C70;
		  /* 820B2C70h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820B2C70h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B2C70h case   18:*/		return 0x820B2C74;
		  /* 820B2C74h */ case   19:  		/* mr R5, R8 */
		/* 820B2C74h case   19:*/		regs.R5 = regs.R8;
		/* 820B2C74h case   19:*/		return 0x820B2C78;
		  /* 820B2C78h */ case   20:  		/* mr R7, R14 */
		/* 820B2C78h case   20:*/		regs.R7 = regs.R14;
		/* 820B2C78h case   20:*/		return 0x820B2C7C;
		  /* 820B2C7Ch */ case   21:  		/* bc 12, CR6_EQ, 20 */
		/* 820B2C7Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x820B2C90;  }
		/* 820B2C7Ch case   21:*/		return 0x820B2C80;
		  /* 820B2C80h */ case   22:  		/* li R10, 259 */
		/* 820B2C80h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x103);
		/* 820B2C80h case   22:*/		return 0x820B2C84;
		  /* 820B2C84h */ case   23:  		/* mr R8, R11 */
		/* 820B2C84h case   23:*/		regs.R8 = regs.R11;
		/* 820B2C84h case   23:*/		return 0x820B2C88;
		  /* 820B2C88h */ case   24:  		/* rlwimi R5, R10, 21, 0, 11 */
		/* 820B2C88h case   24:*/		cpu::op::rlwimi<0,21,0,11>(regs,&regs.R5,regs.R10);
		/* 820B2C88h case   24:*/		return 0x820B2C8C;
		  /* 820B2C8Ch */ case   25:  		/* b 2252 */
		/* 820B2C8Ch case   25:*/		return 0x820B3558;
		/* 820B2C8Ch case   25:*/		return 0x820B2C90;
	}
	return 0x820B2C90;
} // Block from 820B2C28h-820B2C90h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820B2C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2C90);
		  /* 820B2C90h */ case    0:  		/* li R11, 67 */
		/* 820B2C90h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x43);
		/* 820B2C90h case    0:*/		return 0x820B2C94;
		  /* 820B2C94h */ case    1:  		/* li R8, 0 */
		/* 820B2C94h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B2C94h case    1:*/		return 0x820B2C98;
		  /* 820B2C98h */ case    2:  		/* rlwimi R5, R11, 22, 0, 11 */
		/* 820B2C98h case    2:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R5,regs.R11);
		/* 820B2C98h case    2:*/		return 0x820B2C9C;
		  /* 820B2C9Ch */ case    3:  		/* b 2236 */
		/* 820B2C9Ch case    3:*/		return 0x820B3558;
		/* 820B2C9Ch case    3:*/		return 0x820B2CA0;
	}
	return 0x820B2CA0;
} // Block from 820B2C90h-820B2CA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B2CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2CA0);
		  /* 820B2CA0h */ case    0:  		/* lwz R3, <#[R30 + 8]> */
		/* 820B2CA0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2CA0h case    0:*/		return 0x820B2CA4;
		  /* 820B2CA4h */ case    1:  		/* lis R11, -32255 */
		/* 820B2CA4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B2CA4h case    1:*/		return 0x820B2CA8;
		  /* 820B2CA8h */ case    2:  		/* li R6, 0 */
		/* 820B2CA8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2CA8h case    2:*/		return 0x820B2CAC;
		  /* 820B2CACh */ case    3:  		/* li R5, 0 */
		/* 820B2CACh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2CACh case    3:*/		return 0x820B2CB0;
		  /* 820B2CB0h */ case    4:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B2CB0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B2CB0h case    4:*/		return 0x820B2CB4;
		  /* 820B2CB4h */ case    5:  		/* lfd FR1, <#[R11 + 8736]> */
		/* 820B2CB4h case    5:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00002220) );
		/* 820B2CB4h case    5:*/		return 0x820B2CB8;
		  /* 820B2CB8h */ case    6:  		/* bl 304496 */
		/* 820B2CB8h case    6:*/		regs.LR = 0x820B2CBC; return 0x820FD228;
		/* 820B2CB8h case    6:*/		return 0x820B2CBC;
		  /* 820B2CBCh */ case    7:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2CBCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2CBCh case    7:*/		return 0x820B2CC0;
		  /* 820B2CC0h */ case    8:  		/* lis R10, -32255 */
		/* 820B2CC0h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2CC0h case    8:*/		return 0x820B2CC4;
		  /* 820B2CC4h */ case    9:  		/* mr R26, R3 */
		/* 820B2CC4h case    9:*/		regs.R26 = regs.R3;
		/* 820B2CC4h case    9:*/		return 0x820B2CC8;
		  /* 820B2CC8h */ case   10:  		/* li R6, 0 */
		/* 820B2CC8h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2CC8h case   10:*/		return 0x820B2CCC;
		  /* 820B2CCCh */ case   11:  		/* li R5, 0 */
		/* 820B2CCCh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2CCCh case   11:*/		return 0x820B2CD0;
		  /* 820B2CD0h */ case   12:  		/* mr R3, R11 */
		/* 820B2CD0h case   12:*/		regs.R3 = regs.R11;
		/* 820B2CD0h case   12:*/		return 0x820B2CD4;
		  /* 820B2CD4h */ case   13:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2CD4h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2CD4h case   13:*/		return 0x820B2CD8;
		  /* 820B2CD8h */ case   14:  		/* lfd FR1, <#[R10 + 8728]> */
		/* 820B2CD8h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00002218) );
		/* 820B2CD8h case   14:*/		return 0x820B2CDC;
		  /* 820B2CDCh */ case   15:  		/* bl 304460 */
		/* 820B2CDCh case   15:*/		regs.LR = 0x820B2CE0; return 0x820FD228;
		/* 820B2CDCh case   15:*/		return 0x820B2CE0;
		  /* 820B2CE0h */ case   16:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2CE0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2CE0h case   16:*/		return 0x820B2CE4;
		  /* 820B2CE4h */ case   17:  		/* lis R10, -32255 */
		/* 820B2CE4h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2CE4h case   17:*/		return 0x820B2CE8;
		  /* 820B2CE8h */ case   18:  		/* mr R25, R3 */
		/* 820B2CE8h case   18:*/		regs.R25 = regs.R3;
		/* 820B2CE8h case   18:*/		return 0x820B2CEC;
		  /* 820B2CECh */ case   19:  		/* li R6, 0 */
		/* 820B2CECh case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2CECh case   19:*/		return 0x820B2CF0;
		  /* 820B2CF0h */ case   20:  		/* li R5, 0 */
		/* 820B2CF0h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2CF0h case   20:*/		return 0x820B2CF4;
		  /* 820B2CF4h */ case   21:  		/* mr R3, R11 */
		/* 820B2CF4h case   21:*/		regs.R3 = regs.R11;
		/* 820B2CF4h case   21:*/		return 0x820B2CF8;
		  /* 820B2CF8h */ case   22:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2CF8h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2CF8h case   22:*/		return 0x820B2CFC;
		  /* 820B2CFCh */ case   23:  		/* lfd FR1, <#[R10 + 8720]> */
		/* 820B2CFCh case   23:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00002210) );
		/* 820B2CFCh case   23:*/		return 0x820B2D00;
		  /* 820B2D00h */ case   24:  		/* bl 304424 */
		/* 820B2D00h case   24:*/		regs.LR = 0x820B2D04; return 0x820FD228;
		/* 820B2D00h case   24:*/		return 0x820B2D04;
		  /* 820B2D04h */ case   25:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2D04h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2D04h case   25:*/		return 0x820B2D08;
		  /* 820B2D08h */ case   26:  		/* lis R10, -32255 */
		/* 820B2D08h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2D08h case   26:*/		return 0x820B2D0C;
		  /* 820B2D0Ch */ case   27:  		/* mr R24, R3 */
		/* 820B2D0Ch case   27:*/		regs.R24 = regs.R3;
		/* 820B2D0Ch case   27:*/		return 0x820B2D10;
		  /* 820B2D10h */ case   28:  		/* li R6, 0 */
		/* 820B2D10h case   28:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2D10h case   28:*/		return 0x820B2D14;
		  /* 820B2D14h */ case   29:  		/* li R5, 0 */
		/* 820B2D14h case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2D14h case   29:*/		return 0x820B2D18;
		  /* 820B2D18h */ case   30:  		/* mr R3, R11 */
		/* 820B2D18h case   30:*/		regs.R3 = regs.R11;
		/* 820B2D18h case   30:*/		return 0x820B2D1C;
		  /* 820B2D1Ch */ case   31:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2D1Ch case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2D1Ch case   31:*/		return 0x820B2D20;
		  /* 820B2D20h */ case   32:  		/* lfd FR1, <#[R10 + 8712]> */
		/* 820B2D20h case   32:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00002208) );
		/* 820B2D20h case   32:*/		return 0x820B2D24;
		  /* 820B2D24h */ case   33:  		/* bl 304388 */
		/* 820B2D24h case   33:*/		regs.LR = 0x820B2D28; return 0x820FD228;
		/* 820B2D24h case   33:*/		return 0x820B2D28;
		  /* 820B2D28h */ case   34:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2D28h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2D28h case   34:*/		return 0x820B2D2C;
		  /* 820B2D2Ch */ case   35:  		/* lis R10, -32255 */
		/* 820B2D2Ch case   35:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2D2Ch case   35:*/		return 0x820B2D30;
		  /* 820B2D30h */ case   36:  		/* mr R23, R3 */
		/* 820B2D30h case   36:*/		regs.R23 = regs.R3;
		/* 820B2D30h case   36:*/		return 0x820B2D34;
		  /* 820B2D34h */ case   37:  		/* li R6, 0 */
		/* 820B2D34h case   37:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2D34h case   37:*/		return 0x820B2D38;
		  /* 820B2D38h */ case   38:  		/* li R5, 0 */
		/* 820B2D38h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2D38h case   38:*/		return 0x820B2D3C;
		  /* 820B2D3Ch */ case   39:  		/* mr R3, R11 */
		/* 820B2D3Ch case   39:*/		regs.R3 = regs.R11;
		/* 820B2D3Ch case   39:*/		return 0x820B2D40;
		  /* 820B2D40h */ case   40:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2D40h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2D40h case   40:*/		return 0x820B2D44;
		  /* 820B2D44h */ case   41:  		/* lfd FR1, <#[R10 + 8704]> */
		/* 820B2D44h case   41:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00002200) );
		/* 820B2D44h case   41:*/		return 0x820B2D48;
		  /* 820B2D48h */ case   42:  		/* bl 304352 */
		/* 820B2D48h case   42:*/		regs.LR = 0x820B2D4C; return 0x820FD228;
		/* 820B2D48h case   42:*/		return 0x820B2D4C;
		  /* 820B2D4Ch */ case   43:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2D4Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2D4Ch case   43:*/		return 0x820B2D50;
		  /* 820B2D50h */ case   44:  		/* lis R10, -32255 */
		/* 820B2D50h case   44:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2D50h case   44:*/		return 0x820B2D54;
		  /* 820B2D54h */ case   45:  		/* mr R22, R3 */
		/* 820B2D54h case   45:*/		regs.R22 = regs.R3;
		/* 820B2D54h case   45:*/		return 0x820B2D58;
		  /* 820B2D58h */ case   46:  		/* li R6, 0 */
		/* 820B2D58h case   46:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2D58h case   46:*/		return 0x820B2D5C;
		  /* 820B2D5Ch */ case   47:  		/* li R5, 0 */
		/* 820B2D5Ch case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2D5Ch case   47:*/		return 0x820B2D60;
		  /* 820B2D60h */ case   48:  		/* mr R3, R11 */
		/* 820B2D60h case   48:*/		regs.R3 = regs.R11;
		/* 820B2D60h case   48:*/		return 0x820B2D64;
		  /* 820B2D64h */ case   49:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2D64h case   49:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2D64h case   49:*/		return 0x820B2D68;
		  /* 820B2D68h */ case   50:  		/* lfd FR1, <#[R10 + 8664]> */
		/* 820B2D68h case   50:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x000021D8) );
		/* 820B2D68h case   50:*/		return 0x820B2D6C;
		  /* 820B2D6Ch */ case   51:  		/* bl 304316 */
		/* 820B2D6Ch case   51:*/		regs.LR = 0x820B2D70; return 0x820FD228;
		/* 820B2D6Ch case   51:*/		return 0x820B2D70;
		  /* 820B2D70h */ case   52:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2D70h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2D70h case   52:*/		return 0x820B2D74;
		  /* 820B2D74h */ case   53:  		/* lis R10, -32255 */
		/* 820B2D74h case   53:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2D74h case   53:*/		return 0x820B2D78;
		  /* 820B2D78h */ case   54:  		/* mr R21, R3 */
		/* 820B2D78h case   54:*/		regs.R21 = regs.R3;
		/* 820B2D78h case   54:*/		return 0x820B2D7C;
		  /* 820B2D7Ch */ case   55:  		/* li R6, 0 */
		/* 820B2D7Ch case   55:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2D7Ch case   55:*/		return 0x820B2D80;
		  /* 820B2D80h */ case   56:  		/* li R5, 0 */
		/* 820B2D80h case   56:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2D80h case   56:*/		return 0x820B2D84;
		  /* 820B2D84h */ case   57:  		/* mr R3, R11 */
		/* 820B2D84h case   57:*/		regs.R3 = regs.R11;
		/* 820B2D84h case   57:*/		return 0x820B2D88;
		  /* 820B2D88h */ case   58:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2D88h case   58:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2D88h case   58:*/		return 0x820B2D8C;
		  /* 820B2D8Ch */ case   59:  		/* lfd FR1, <#[R10 + 8096]> */
		/* 820B2D8Ch case   59:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00001FA0) );
		/* 820B2D8Ch case   59:*/		return 0x820B2D90;
		  /* 820B2D90h */ case   60:  		/* bl 304280 */
		/* 820B2D90h case   60:*/		regs.LR = 0x820B2D94; return 0x820FD228;
		/* 820B2D90h case   60:*/		return 0x820B2D94;
		  /* 820B2D94h */ case   61:  		/* lwz R11, <#[R30 + 8]> */
		/* 820B2D94h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820B2D94h case   61:*/		return 0x820B2D98;
		  /* 820B2D98h */ case   62:  		/* lis R10, -32255 */
		/* 820B2D98h case   62:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820B2D98h case   62:*/		return 0x820B2D9C;
		  /* 820B2D9Ch */ case   63:  		/* mr R20, R3 */
		/* 820B2D9Ch case   63:*/		regs.R20 = regs.R3;
		/* 820B2D9Ch case   63:*/		return 0x820B2DA0;
		  /* 820B2DA0h */ case   64:  		/* li R6, 0 */
		/* 820B2DA0h case   64:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B2DA0h case   64:*/		return 0x820B2DA4;
		  /* 820B2DA4h */ case   65:  		/* li R5, 0 */
		/* 820B2DA4h case   65:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B2DA4h case   65:*/		return 0x820B2DA8;
		  /* 820B2DA8h */ case   66:  		/* mr R3, R11 */
		/* 820B2DA8h case   66:*/		regs.R3 = regs.R11;
		/* 820B2DA8h case   66:*/		return 0x820B2DAC;
		  /* 820B2DACh */ case   67:  		/* lwz R4, <#[R11 + 120]> */
		/* 820B2DACh case   67:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 820B2DACh case   67:*/		return 0x820B2DB0;
		  /* 820B2DB0h */ case   68:  		/* lfd FR1, <#[R10 + 8080]> */
		/* 820B2DB0h case   68:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00001F90) );
		/* 820B2DB0h case   68:*/		return 0x820B2DB4;
		  /* 820B2DB4h */ case   69:  		/* bl 304244 */
		/* 820B2DB4h case   69:*/		regs.LR = 0x820B2DB8; return 0x820FD228;
		/* 820B2DB4h case   69:*/		return 0x820B2DB8;
		  /* 820B2DB8h */ case   70:  		/* mr R19, R3 */
		/* 820B2DB8h case   70:*/		regs.R19 = regs.R3;
		/* 820B2DB8h case   70:*/		return 0x820B2DBC;
		  /* 820B2DBCh */ case   71:  		/* lis R4, 9345 */
		/* 820B2DBCh case   71:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B2DBCh case   71:*/		return 0x820B2DC0;
		  /* 820B2DC0h */ case   72:  		/* mulli R3, R31, 192 */
		/* 820B2DC0h case   72:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R31,0xC0);
		/* 820B2DC0h case   72:*/		return 0x820B2DC4;
		  /* 820B2DC4h */ case   73:  		/* bl -175044 */
		/* 820B2DC4h case   73:*/		regs.LR = 0x820B2DC8; return 0x82088200;
		/* 820B2DC4h case   73:*/		return 0x820B2DC8;
		  /* 820B2DC8h */ case   74:  		/* stw R3, <#[R1 + 80]> */
		/* 820B2DC8h case   74:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820B2DC8h case   74:*/		return 0x820B2DCC;
		  /* 820B2DCCh */ case   75:  		/* cmplwi CR0, R3, 0 */
		/* 820B2DCCh case   75:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B2DCCh case   75:*/		return 0x820B2DD0;
		  /* 820B2DD0h */ case   76:  		/* bc 4, CR0_EQ, 16 */
		/* 820B2DD0h case   76:*/		if ( !regs.CR[0].eq ) { return 0x820B2DE0;  }
		/* 820B2DD0h case   76:*/		return 0x820B2DD4;
		  /* 820B2DD4h */ case   77:  		/* lis R31, -32761 */
		/* 820B2DD4h case   77:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820B2DD4h case   77:*/		return 0x820B2DD8;
		  /* 820B2DD8h */ case   78:  		/* ori R31, R31, 14 */
		/* 820B2DD8h case   78:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820B2DD8h case   78:*/		return 0x820B2DDC;
		  /* 820B2DDCh */ case   79:  		/* b 1932 */
		/* 820B2DDCh case   79:*/		return 0x820B3568;
		/* 820B2DDCh case   79:*/		return 0x820B2DE0;
	}
	return 0x820B2DE0;
} // Block from 820B2CA0h-820B2DE0h (80 instructions)

//////////////////////////////////////////////////////
// Block at 820B2DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2DE0);
		  /* 820B2DE0h */ case    0:  		/* li R10, 48 */
		/* 820B2DE0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x30);
		/* 820B2DE0h case    0:*/		return 0x820B2DE4;
		  /* 820B2DE4h */ case    1:  		/* addi R11, R1, 96 */
		/* 820B2DE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820B2DE4h case    1:*/		return 0x820B2DE8;
		  /* 820B2DE8h */ case    2:  		/* rlwinm R8, R31, 2, 0, 29 */
		/* 820B2DE8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R31);
		/* 820B2DE8h case    2:*/		return 0x820B2DEC;
		  /* 820B2DECh */ case    3:  		/* addi R9, R11, -4 */
		/* 820B2DECh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B2DECh case    3:*/		return 0x820B2DF0;
		  /* 820B2DF0h */ case    4:  		/* mr R11, R3 */
		/* 820B2DF0h case    4:*/		regs.R11 = regs.R3;
		/* 820B2DF0h case    4:*/		return 0x820B2DF4;
		  /* 820B2DF4h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B2DF4h case    5:*/		regs.CTR = regs.R10;
		/* 820B2DF4h case    5:*/		return 0x820B2DF8;
		  /* 820B2DF8h */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B2DF8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B2DF8h case    6:*/		return 0x820B2DFC;
		  /* 820B2DFCh */ case    7:  		/* add R11, R8, R11 */
		/* 820B2DFCh case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820B2DFCh case    7:*/		return 0x820B2E00;
		  /* 820B2E00h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B2E00h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B2DF8;  }
		/* 820B2E00h case    8:*/		return 0x820B2E04;
		  /* 820B2E04h */ case    9:  		/* addi R9, R1, 96 */
		/* 820B2E04h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 820B2E04h case    9:*/		return 0x820B2E08;
		  /* 820B2E08h */ case   10:  		/* li R8, 39 */
		/* 820B2E08h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x27);
		/* 820B2E08h case   10:*/		return 0x820B2E0C;
		  /* 820B2E0Ch */ case   11:  		/* lwz R11, <#[R9]> */
		/* 820B2E0Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820B2E0Ch case   11:*/		return 0x820B2E10;
		  /* 820B2E10h */ case   12:  		/* cmplwi CR6, R31, 0 */
		/* 820B2E10h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B2E10h case   12:*/		return 0x820B2E14;
		  /* 820B2E14h */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 820B2E14h case   13:*/		if ( regs.CR[6].eq ) { return 0x820B2E34;  }
		/* 820B2E14h case   13:*/		return 0x820B2E18;
		  /* 820B2E18h */ case   14:  		/* addi R11, R11, -4 */
		/* 820B2E18h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820B2E18h case   14:*/		return 0x820B2E1C;
		  /* 820B2E1Ch */ case   15:  		/* li R10, -1 */
		/* 820B2E1Ch case   15:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820B2E1Ch case   15:*/		return 0x820B2E20;
		  /* 820B2E20h */ case   16:  		/* cmplwi CR0, R31, 0 */
		/* 820B2E20h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B2E20h case   16:*/		return 0x820B2E24;
		  /* 820B2E24h */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 820B2E24h case   17:*/		if ( regs.CR[0].eq ) { return 0x820B2E34;  }
		/* 820B2E24h case   17:*/		return 0x820B2E28;
		  /* 820B2E28h */ case   18:  		/* mtspr CTR, R31 */
		/* 820B2E28h case   18:*/		regs.CTR = regs.R31;
		/* 820B2E28h case   18:*/		return 0x820B2E2C;
		  /* 820B2E2Ch */ case   19:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B2E2Ch case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B2E2Ch case   19:*/		return 0x820B2E30;
		  /* 820B2E30h */ case   20:  		/* bc 16, CR0_LT, -4 */
		/* 820B2E30h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B2E2C;  }
		/* 820B2E30h case   20:*/		return 0x820B2E34;
	}
	return 0x820B2E34;
} // Block from 820B2DE0h-820B2E34h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820B2E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2E34);
		  /* 820B2E34h */ case    0:  		/* addic. R8, R8, -1 */
		/* 820B2E34h case    0:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820B2E34h case    0:*/		return 0x820B2E38;
		  /* 820B2E38h */ case    1:  		/* addi R9, R9, 4 */
		/* 820B2E38h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820B2E38h case    1:*/		return 0x820B2E3C;
		  /* 820B2E3Ch */ case    2:  		/* bc 4, CR0_EQ, -48 */
		/* 820B2E3Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B2E0C;  }
		/* 820B2E3Ch case    2:*/		return 0x820B2E40;
		  /* 820B2E40h */ case    3:  		/* lwz R27, <#[R1 + 284]> */
		/* 820B2E40h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000011C) );
		/* 820B2E40h case    3:*/		return 0x820B2E44;
		  /* 820B2E44h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 820B2E44h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B2E44h case    4:*/		return 0x820B2E48;
		  /* 820B2E48h */ case    5:  		/* lwz R15, <#[R1 + 268]> */
		/* 820B2E48h case    5:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x0000010C) );
		/* 820B2E48h case    5:*/		return 0x820B2E4C;
		  /* 820B2E4Ch */ case    6:  		/* lwz R16, <#[R1 + 264]> */
		/* 820B2E4Ch case    6:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x00000108) );
		/* 820B2E4Ch case    6:*/		return 0x820B2E50;
		  /* 820B2E50h */ case    7:  		/* lwz R17, <#[R1 + 260]> */
		/* 820B2E50h case    7:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000104) );
		/* 820B2E50h case    7:*/		return 0x820B2E54;
		  /* 820B2E54h */ case    8:  		/* lwz R28, <#[R1 + 256]> */
		/* 820B2E54h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000100) );
		/* 820B2E54h case    8:*/		return 0x820B2E58;
		  /* 820B2E58h */ case    9:  		/* lwz R18, <#[R1 + 252]> */
		/* 820B2E58h case    9:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x000000FC) );
		/* 820B2E58h case    9:*/		return 0x820B2E5C;
		  /* 820B2E5Ch */ case   10:  		/* bc 12, CR6_EQ, 108 */
		/* 820B2E5Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820B2EC8;  }
		/* 820B2E5Ch case   10:*/		return 0x820B2E60;
		  /* 820B2E60h */ case   11:  		/* lwz R6, <#[R1 + 272]> */
		/* 820B2E60h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000110) );
		/* 820B2E60h case   11:*/		return 0x820B2E64;
		  /* 820B2E64h */ case   12:  		/* mtspr CTR, R31 */
		/* 820B2E64h case   12:*/		regs.CTR = regs.R31;
		/* 820B2E64h case   12:*/		return 0x820B2E68;
		  /* 820B2E68h */ case   13:  		/* lwz R5, <#[R1 + 276]> */
		/* 820B2E68h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000114) );
		/* 820B2E68h case   13:*/		return 0x820B2E6C;
		  /* 820B2E6Ch */ case   14:  		/* mr R11, R28 */
		/* 820B2E6Ch case   14:*/		regs.R11 = regs.R28;
		/* 820B2E6Ch case   14:*/		return 0x820B2E70;
		  /* 820B2E70h */ case   15:  		/* lwz R4, <#[R1 + 280]> */
		/* 820B2E70h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000118) );
		/* 820B2E70h case   15:*/		return 0x820B2E74;
		  /* 820B2E74h */ case   16:  		/* subf R10, R28, R18 */
		/* 820B2E74h case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R18);
		/* 820B2E74h case   16:*/		return 0x820B2E78;
		  /* 820B2E78h */ case   17:  		/* subf R9, R28, R17 */
		/* 820B2E78h case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R28,regs.R17);
		/* 820B2E78h case   17:*/		return 0x820B2E7C;
		  /* 820B2E7Ch */ case   18:  		/* subf R8, R28, R16 */
		/* 820B2E7Ch case   18:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R28,regs.R16);
		/* 820B2E7Ch case   18:*/		return 0x820B2E80;
		  /* 820B2E80h */ case   19:  		/* subf R7, R28, R15 */
		/* 820B2E80h case   19:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R28,regs.R15);
		/* 820B2E80h case   19:*/		return 0x820B2E84;
		  /* 820B2E84h */ case   20:  		/* subf R6, R28, R6 */
		/* 820B2E84h case   20:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R28,regs.R6);
		/* 820B2E84h case   20:*/		return 0x820B2E88;
		  /* 820B2E88h */ case   21:  		/* subf R5, R28, R5 */
		/* 820B2E88h case   21:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R28,regs.R5);
		/* 820B2E88h case   21:*/		return 0x820B2E8C;
		  /* 820B2E8Ch */ case   22:  		/* subf R4, R28, R4 */
		/* 820B2E8Ch case   22:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R28,regs.R4);
		/* 820B2E8Ch case   22:*/		return 0x820B2E90;
		  /* 820B2E90h */ case   23:  		/* subf R3, R28, R27 */
		/* 820B2E90h case   23:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R28,regs.R27);
		/* 820B2E90h case   23:*/		return 0x820B2E94;
		  /* 820B2E94h */ case   24:  		/* stwx R26, <#[R10 + R11]> */
		/* 820B2E94h case   24:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B2E94h case   24:*/		return 0x820B2E98;
		  /* 820B2E98h */ case   25:  		/* stw R25, <#[R11]> */
		/* 820B2E98h case   25:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 820B2E98h case   25:*/		return 0x820B2E9C;
		  /* 820B2E9Ch */ case   26:  		/* stwx R24, <#[R9 + R11]> */
		/* 820B2E9Ch case   26:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B2E9Ch case   26:*/		return 0x820B2EA0;
		  /* 820B2EA0h */ case   27:  		/* stwx R23, <#[R8 + R11]> */
		/* 820B2EA0h case   27:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820B2EA0h case   27:*/		return 0x820B2EA4;
		  /* 820B2EA4h */ case   28:  		/* stwx R22, <#[R7 + R11]> */
		/* 820B2EA4h case   28:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820B2EA4h case   28:*/		return 0x820B2EA8;
		  /* 820B2EA8h */ case   29:  		/* stwx R21, <#[R6 + R11]> */
		/* 820B2EA8h case   29:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820B2EA8h case   29:*/		return 0x820B2EAC;
		  /* 820B2EACh */ case   30:  		/* stwx R20, <#[R5 + R11]> */
		/* 820B2EACh case   30:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820B2EACh case   30:*/		return 0x820B2EB0;
		  /* 820B2EB0h */ case   31:  		/* stwx R19, <#[R4 + R11]> */
		/* 820B2EB0h case   31:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 820B2EB0h case   31:*/		return 0x820B2EB4;
		  /* 820B2EB4h */ case   32:  		/* lwz R14, <#[R30 + 32]> */
		/* 820B2EB4h case   32:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R30 + 0x00000020) );
		/* 820B2EB4h case   32:*/		return 0x820B2EB8;
		  /* 820B2EB8h */ case   33:  		/* stwx R14, <#[R3 + R11]> */
		/* 820B2EB8h case   33:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 820B2EB8h case   33:*/		return 0x820B2EBC;
		  /* 820B2EBCh */ case   34:  		/* addi R11, R11, 4 */
		/* 820B2EBCh case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B2EBCh case   34:*/		return 0x820B2EC0;
		  /* 820B2EC0h */ case   35:  		/* bc 16, CR0_LT, -44 */
		/* 820B2EC0h case   35:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B2E94;  }
		/* 820B2EC0h case   35:*/		return 0x820B2EC4;
		  /* 820B2EC4h */ case   36:  		/* lwz R14, <#[R1 + 484]> */
		/* 820B2EC4h case   36:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x000001E4) );
		/* 820B2EC4h case   36:*/		return 0x820B2EC8;
	}
	return 0x820B2EC8;
} // Block from 820B2E34h-820B2EC8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820B2EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2EC8);
		  /* 820B2EC8h */ case    0:  		/* lwz R11, <#[R1 + 492]> */
		/* 820B2EC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000001EC) );
		/* 820B2EC8h case    0:*/		return 0x820B2ECC;
		  /* 820B2ECCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820B2ECCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B2ECCh case    1:*/		return 0x820B2ED0;
		  /* 820B2ED0h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820B2ED0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B2ED8;  }
		/* 820B2ED0h case    2:*/		return 0x820B2ED4;
		  /* 820B2ED4h */ case    3:  		/* stw R27, <#[R1 + 492]> */
		/* 820B2ED4h case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x000001EC) );
		/* 820B2ED4h case    3:*/		return 0x820B2ED8;
	}
	return 0x820B2ED8;
} // Block from 820B2EC8h-820B2ED8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B2ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2ED8);
		  /* 820B2ED8h */ case    0:  		/* rlwinm R19, R31, 0, 12, 31 */
		/* 820B2ED8h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R19,regs.R31);
		/* 820B2ED8h case    0:*/		return 0x820B2EDC;
		  /* 820B2EDCh */ case    1:  		/* lwz R27, <#[R1 + 96]> */
		/* 820B2EDCh case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 820B2EDCh case    1:*/		return 0x820B2EE0;
		  /* 820B2EE0h */ case    2:  		/* li R9, 0 */
		/* 820B2EE0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2EE0h case    2:*/		return 0x820B2EE4;
		  /* 820B2EE4h */ case    3:  		/* oris R26, R19, 4112 */
		/* 820B2EE4h case    3:*/		cpu::op::oris<0>(regs,&regs.R26,regs.R19,0x1010);
		/* 820B2EE4h case    3:*/		return 0x820B2EE8;
		  /* 820B2EE8h */ case    4:  		/* li R8, 0 */
		/* 820B2EE8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B2EE8h case    4:*/		return 0x820B2EEC;
		  /* 820B2EECh */ case    5:  		/* mr R7, R14 */
		/* 820B2EECh case    5:*/		regs.R7 = regs.R14;
		/* 820B2EECh case    5:*/		return 0x820B2EF0;
		  /* 820B2EF0h */ case    6:  		/* stw R26, <#[R1 + 88]> */
		/* 820B2EF0h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000058) );
		/* 820B2EF0h case    6:*/		return 0x820B2EF4;
		  /* 820B2EF4h */ case    7:  		/* mr R6, R27 */
		/* 820B2EF4h case    7:*/		regs.R6 = regs.R27;
		/* 820B2EF4h case    7:*/		return 0x820B2EF8;
		  /* 820B2EF8h */ case    8:  		/* mr R5, R26 */
		/* 820B2EF8h case    8:*/		regs.R5 = regs.R26;
		/* 820B2EF8h case    8:*/		return 0x820B2EFC;
		  /* 820B2EFCh */ case    9:  		/* mr R4, R29 */
		/* 820B2EFCh case    9:*/		regs.R4 = regs.R29;
		/* 820B2EFCh case    9:*/		return 0x820B2F00;
		  /* 820B2F00h */ case   10:  		/* mr R3, R30 */
		/* 820B2F00h case   10:*/		regs.R3 = regs.R30;
		/* 820B2F00h case   10:*/		return 0x820B2F04;
		  /* 820B2F04h */ case   11:  		/* bl -9212 */
		/* 820B2F04h case   11:*/		regs.LR = 0x820B2F08; return 0x820B0B08;
		/* 820B2F04h case   11:*/		return 0x820B2F08;
		  /* 820B2F08h */ case   12:  		/* or. R31, R3, R3 */
		/* 820B2F08h case   12:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2F08h case   12:*/		return 0x820B2F0C;
		  /* 820B2F0Ch */ case   13:  		/* bc 12, CR0_LT, 1628 */
		/* 820B2F0Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B2F0Ch case   13:*/		return 0x820B2F10;
		  /* 820B2F10h */ case   14:  		/* lwz R20, <#[R1 + 100]> */
		/* 820B2F10h case   14:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000064) );
		/* 820B2F10h case   14:*/		return 0x820B2F14;
		  /* 820B2F14h */ case   15:  		/* oris R24, R19, 8208 */
		/* 820B2F14h case   15:*/		cpu::op::oris<0>(regs,&regs.R24,regs.R19,0x2010);
		/* 820B2F14h case   15:*/		return 0x820B2F18;
		  /* 820B2F18h */ case   16:  		/* li R9, 4 */
		/* 820B2F18h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2F18h case   16:*/		return 0x820B2F1C;
		  /* 820B2F1Ch */ case   17:  		/* mr R8, R27 */
		/* 820B2F1Ch case   17:*/		regs.R8 = regs.R27;
		/* 820B2F1Ch case   17:*/		return 0x820B2F20;
		  /* 820B2F20h */ case   18:  		/* stw R24, <#[R1 + 84]> */
		/* 820B2F20h case   18:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 820B2F20h case   18:*/		return 0x820B2F24;
		  /* 820B2F24h */ case   19:  		/* mr R7, R14 */
		/* 820B2F24h case   19:*/		regs.R7 = regs.R14;
		/* 820B2F24h case   19:*/		return 0x820B2F28;
		  /* 820B2F28h */ case   20:  		/* mr R6, R20 */
		/* 820B2F28h case   20:*/		regs.R6 = regs.R20;
		/* 820B2F28h case   20:*/		return 0x820B2F2C;
		  /* 820B2F2Ch */ case   21:  		/* mr R5, R24 */
		/* 820B2F2Ch case   21:*/		regs.R5 = regs.R24;
		/* 820B2F2Ch case   21:*/		return 0x820B2F30;
		  /* 820B2F30h */ case   22:  		/* mr R4, R29 */
		/* 820B2F30h case   22:*/		regs.R4 = regs.R29;
		/* 820B2F30h case   22:*/		return 0x820B2F34;
		  /* 820B2F34h */ case   23:  		/* mr R3, R30 */
		/* 820B2F34h case   23:*/		regs.R3 = regs.R30;
		/* 820B2F34h case   23:*/		return 0x820B2F38;
		  /* 820B2F38h */ case   24:  		/* bl -9264 */
		/* 820B2F38h case   24:*/		regs.LR = 0x820B2F3C; return 0x820B0B08;
		/* 820B2F38h case   24:*/		return 0x820B2F3C;
		  /* 820B2F3Ch */ case   25:  		/* or. R31, R3, R3 */
		/* 820B2F3Ch case   25:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2F3Ch case   25:*/		return 0x820B2F40;
		  /* 820B2F40h */ case   26:  		/* bc 12, CR0_LT, 1576 */
		/* 820B2F40h case   26:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B2F40h case   26:*/		return 0x820B2F44;
		  /* 820B2F44h */ case   27:  		/* lwz R14, <#[R1 + 104]> */
		/* 820B2F44h case   27:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000068) );
		/* 820B2F44h case   27:*/		return 0x820B2F48;
		  /* 820B2F48h */ case   28:  		/* li R9, 0 */
		/* 820B2F48h case   28:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B2F48h case   28:*/		return 0x820B2F4C;
		  /* 820B2F4Ch */ case   29:  		/* lwz R27, <#[R1 + 492]> */
		/* 820B2F4Ch case   29:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000001EC) );
		/* 820B2F4Ch case   29:*/		return 0x820B2F50;
		  /* 820B2F50h */ case   30:  		/* li R8, 0 */
		/* 820B2F50h case   30:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B2F50h case   30:*/		return 0x820B2F54;
		  /* 820B2F54h */ case   31:  		/* mr R6, R14 */
		/* 820B2F54h case   31:*/		regs.R6 = regs.R14;
		/* 820B2F54h case   31:*/		return 0x820B2F58;
		  /* 820B2F58h */ case   32:  		/* mr R7, R27 */
		/* 820B2F58h case   32:*/		regs.R7 = regs.R27;
		/* 820B2F58h case   32:*/		return 0x820B2F5C;
		  /* 820B2F5Ch */ case   33:  		/* mr R5, R26 */
		/* 820B2F5Ch case   33:*/		regs.R5 = regs.R26;
		/* 820B2F5Ch case   33:*/		return 0x820B2F60;
		  /* 820B2F60h */ case   34:  		/* mr R4, R29 */
		/* 820B2F60h case   34:*/		regs.R4 = regs.R29;
		/* 820B2F60h case   34:*/		return 0x820B2F64;
		  /* 820B2F64h */ case   35:  		/* mr R3, R30 */
		/* 820B2F64h case   35:*/		regs.R3 = regs.R30;
		/* 820B2F64h case   35:*/		return 0x820B2F68;
		  /* 820B2F68h */ case   36:  		/* bl -9312 */
		/* 820B2F68h case   36:*/		regs.LR = 0x820B2F6C; return 0x820B0B08;
		/* 820B2F68h case   36:*/		return 0x820B2F6C;
		  /* 820B2F6Ch */ case   37:  		/* or. R31, R3, R3 */
		/* 820B2F6Ch case   37:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2F6Ch case   37:*/		return 0x820B2F70;
		  /* 820B2F70h */ case   38:  		/* bc 12, CR0_LT, 1528 */
		/* 820B2F70h case   38:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B2F70h case   38:*/		return 0x820B2F74;
		  /* 820B2F74h */ case   39:  		/* lwz R22, <#[R1 + 108]> */
		/* 820B2F74h case   39:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x0000006C) );
		/* 820B2F74h case   39:*/		return 0x820B2F78;
		  /* 820B2F78h */ case   40:  		/* li R9, 4 */
		/* 820B2F78h case   40:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2F78h case   40:*/		return 0x820B2F7C;
		  /* 820B2F7Ch */ case   41:  		/* mr R8, R14 */
		/* 820B2F7Ch case   41:*/		regs.R8 = regs.R14;
		/* 820B2F7Ch case   41:*/		return 0x820B2F80;
		  /* 820B2F80h */ case   42:  		/* mr R7, R27 */
		/* 820B2F80h case   42:*/		regs.R7 = regs.R27;
		/* 820B2F80h case   42:*/		return 0x820B2F84;
		  /* 820B2F84h */ case   43:  		/* mr R6, R22 */
		/* 820B2F84h case   43:*/		regs.R6 = regs.R22;
		/* 820B2F84h case   43:*/		return 0x820B2F88;
		  /* 820B2F88h */ case   44:  		/* mr R5, R24 */
		/* 820B2F88h case   44:*/		regs.R5 = regs.R24;
		/* 820B2F88h case   44:*/		return 0x820B2F8C;
		  /* 820B2F8Ch */ case   45:  		/* mr R4, R29 */
		/* 820B2F8Ch case   45:*/		regs.R4 = regs.R29;
		/* 820B2F8Ch case   45:*/		return 0x820B2F90;
		  /* 820B2F90h */ case   46:  		/* mr R3, R30 */
		/* 820B2F90h case   46:*/		regs.R3 = regs.R30;
		/* 820B2F90h case   46:*/		return 0x820B2F94;
		  /* 820B2F94h */ case   47:  		/* bl -9356 */
		/* 820B2F94h case   47:*/		regs.LR = 0x820B2F98; return 0x820B0B08;
		/* 820B2F94h case   47:*/		return 0x820B2F98;
		  /* 820B2F98h */ case   48:  		/* or. R31, R3, R3 */
		/* 820B2F98h case   48:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2F98h case   48:*/		return 0x820B2F9C;
		  /* 820B2F9Ch */ case   49:  		/* bc 12, CR0_LT, 1484 */
		/* 820B2F9Ch case   49:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B2F9Ch case   49:*/		return 0x820B2FA0;
		  /* 820B2FA0h */ case   50:  		/* lwz R25, <#[R1 + 112]> */
		/* 820B2FA0h case   50:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 820B2FA0h case   50:*/		return 0x820B2FA4;
		  /* 820B2FA4h */ case   51:  		/* oris R5, R19, 8192 */
		/* 820B2FA4h case   51:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R19,0x2000);
		/* 820B2FA4h case   51:*/		return 0x820B2FA8;
		  /* 820B2FA8h */ case   52:  		/* li R9, 4 */
		/* 820B2FA8h case   52:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2FA8h case   52:*/		return 0x820B2FAC;
		  /* 820B2FACh */ case   53:  		/* mr R8, R22 */
		/* 820B2FACh case   53:*/		regs.R8 = regs.R22;
		/* 820B2FACh case   53:*/		return 0x820B2FB0;
		  /* 820B2FB0h */ case   54:  		/* stw R5, <#[R1 + 92]> */
		/* 820B2FB0h case   54:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B2FB0h case   54:*/		return 0x820B2FB4;
		  /* 820B2FB4h */ case   55:  		/* mr R7, R20 */
		/* 820B2FB4h case   55:*/		regs.R7 = regs.R20;
		/* 820B2FB4h case   55:*/		return 0x820B2FB8;
		  /* 820B2FB8h */ case   56:  		/* mr R6, R25 */
		/* 820B2FB8h case   56:*/		regs.R6 = regs.R25;
		/* 820B2FB8h case   56:*/		return 0x820B2FBC;
		  /* 820B2FBCh */ case   57:  		/* mr R4, R29 */
		/* 820B2FBCh case   57:*/		regs.R4 = regs.R29;
		/* 820B2FBCh case   57:*/		return 0x820B2FC0;
		  /* 820B2FC0h */ case   58:  		/* mr R3, R30 */
		/* 820B2FC0h case   58:*/		regs.R3 = regs.R30;
		/* 820B2FC0h case   58:*/		return 0x820B2FC4;
		  /* 820B2FC4h */ case   59:  		/* bl -9404 */
		/* 820B2FC4h case   59:*/		regs.LR = 0x820B2FC8; return 0x820B0B08;
		/* 820B2FC4h case   59:*/		return 0x820B2FC8;
		  /* 820B2FC8h */ case   60:  		/* or. R31, R3, R3 */
		/* 820B2FC8h case   60:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2FC8h case   60:*/		return 0x820B2FCC;
		  /* 820B2FCCh */ case   61:  		/* bc 12, CR0_LT, 1436 */
		/* 820B2FCCh case   61:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B2FCCh case   61:*/		return 0x820B2FD0;
		  /* 820B2FD0h */ case   62:  		/* lwz R26, <#[R1 + 116]> */
		/* 820B2FD0h case   62:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000074) );
		/* 820B2FD0h case   62:*/		return 0x820B2FD4;
		  /* 820B2FD4h */ case   63:  		/* li R9, 4 */
		/* 820B2FD4h case   63:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B2FD4h case   63:*/		return 0x820B2FD8;
	}
	return 0x820B2FD8;
} // Block from 820B2ED8h-820B2FD8h (64 instructions)

//////////////////////////////////////////////////////
// Block at 820B2FD8h
// Function '?EmitASinACos@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAI11I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B2FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B2FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B2FD8);
		  /* 820B2FD8h */ case    0:  		/* mr R8, R22 */
		/* 820B2FD8h case    0:*/		regs.R8 = regs.R22;
		/* 820B2FD8h case    0:*/		return 0x820B2FDC;
		  /* 820B2FDCh */ case    1:  		/* mr R7, R20 */
		/* 820B2FDCh case    1:*/		regs.R7 = regs.R20;
		/* 820B2FDCh case    1:*/		return 0x820B2FE0;
		  /* 820B2FE0h */ case    2:  		/* mr R6, R26 */
		/* 820B2FE0h case    2:*/		regs.R6 = regs.R26;
		/* 820B2FE0h case    2:*/		return 0x820B2FE4;
		  /* 820B2FE4h */ case    3:  		/* mr R5, R24 */
		/* 820B2FE4h case    3:*/		regs.R5 = regs.R24;
		/* 820B2FE4h case    3:*/		return 0x820B2FE8;
		  /* 820B2FE8h */ case    4:  		/* mr R4, R29 */
		/* 820B2FE8h case    4:*/		regs.R4 = regs.R29;
		/* 820B2FE8h case    4:*/		return 0x820B2FEC;
		  /* 820B2FECh */ case    5:  		/* mr R3, R30 */
		/* 820B2FECh case    5:*/		regs.R3 = regs.R30;
		/* 820B2FECh case    5:*/		return 0x820B2FF0;
		  /* 820B2FF0h */ case    6:  		/* bl -9448 */
		/* 820B2FF0h case    6:*/		regs.LR = 0x820B2FF4; return 0x820B0B08;
		/* 820B2FF0h case    6:*/		return 0x820B2FF4;
		  /* 820B2FF4h */ case    7:  		/* or. R31, R3, R3 */
		/* 820B2FF4h case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B2FF4h case    7:*/		return 0x820B2FF8;
		  /* 820B2FF8h */ case    8:  		/* bc 12, CR0_LT, 1392 */
		/* 820B2FF8h case    8:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B2FF8h case    8:*/		return 0x820B2FFC;
		  /* 820B2FFCh */ case    9:  		/* lwz R27, <#[R1 + 120]> */
		/* 820B2FFCh case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000078) );
		/* 820B2FFCh case    9:*/		return 0x820B3000;
		  /* 820B3000h */ case   10:  		/* li R9, 4 */
		/* 820B3000h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B3000h case   10:*/		return 0x820B3004;
		  /* 820B3004h */ case   11:  		/* li R8, 0 */
		/* 820B3004h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B3004h case   11:*/		return 0x820B3008;
		  /* 820B3008h */ case   12:  		/* mr R7, R26 */
		/* 820B3008h case   12:*/		regs.R7 = regs.R26;
		/* 820B3008h case   12:*/		return 0x820B300C;
		  /* 820B300Ch */ case   13:  		/* mr R6, R27 */
		/* 820B300Ch case   13:*/		regs.R6 = regs.R27;
		/* 820B300Ch case   13:*/		return 0x820B3010;
		  /* 820B3010h */ case   14:  		/* oris R5, R19, 4144 */
		/* 820B3010h case   14:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R19,0x1030);
		/* 820B3010h case   14:*/		return 0x820B3014;
		  /* 820B3014h */ case   15:  		/* mr R4, R29 */
		/* 820B3014h case   15:*/		regs.R4 = regs.R29;
		/* 820B3014h case   15:*/		return 0x820B3018;
		  /* 820B3018h */ case   16:  		/* mr R3, R30 */
		/* 820B3018h case   16:*/		regs.R3 = regs.R30;
		/* 820B3018h case   16:*/		return 0x820B301C;
		  /* 820B301Ch */ case   17:  		/* bl -9492 */
		/* 820B301Ch case   17:*/		regs.LR = 0x820B3020; return 0x820B0B08;
		/* 820B301Ch case   17:*/		return 0x820B3020;
		  /* 820B3020h */ case   18:  		/* or. R31, R3, R3 */
		/* 820B3020h case   18:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3020h case   18:*/		return 0x820B3024;
		  /* 820B3024h */ case   19:  		/* bc 12, CR0_LT, 1348 */
		/* 820B3024h case   19:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3024h case   19:*/		return 0x820B3028;
		  /* 820B3028h */ case   20:  		/* lwz R23, <#[R1 + 124]> */
		/* 820B3028h case   20:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000007C) );
		/* 820B3028h case   20:*/		return 0x820B302C;
		  /* 820B302Ch */ case   21:  		/* oris R24, R19, 8272 */
		/* 820B302Ch case   21:*/		cpu::op::oris<0>(regs,&regs.R24,regs.R19,0x2050);
		/* 820B302Ch case   21:*/		return 0x820B3030;
		  /* 820B3030h */ case   22:  		/* li R9, 20 */
		/* 820B3030h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820B3030h case   22:*/		return 0x820B3034;
		  /* 820B3034h */ case   23:  		/* mr R8, R27 */
		/* 820B3034h case   23:*/		regs.R8 = regs.R27;
		/* 820B3034h case   23:*/		return 0x820B3038;
		  /* 820B3038h */ case   24:  		/* mr R7, R25 */
		/* 820B3038h case   24:*/		regs.R7 = regs.R25;
		/* 820B3038h case   24:*/		return 0x820B303C;
		  /* 820B303Ch */ case   25:  		/* mr R6, R23 */
		/* 820B303Ch case   25:*/		regs.R6 = regs.R23;
		/* 820B303Ch case   25:*/		return 0x820B3040;
		  /* 820B3040h */ case   26:  		/* mr R5, R24 */
		/* 820B3040h case   26:*/		regs.R5 = regs.R24;
		/* 820B3040h case   26:*/		return 0x820B3044;
		  /* 820B3044h */ case   27:  		/* mr R4, R29 */
		/* 820B3044h case   27:*/		regs.R4 = regs.R29;
		/* 820B3044h case   27:*/		return 0x820B3048;
		  /* 820B3048h */ case   28:  		/* mr R3, R30 */
		/* 820B3048h case   28:*/		regs.R3 = regs.R30;
		/* 820B3048h case   28:*/		return 0x820B304C;
		  /* 820B304Ch */ case   29:  		/* bl -9540 */
		/* 820B304Ch case   29:*/		regs.LR = 0x820B3050; return 0x820B0B08;
		/* 820B304Ch case   29:*/		return 0x820B3050;
		  /* 820B3050h */ case   30:  		/* or. R31, R3, R3 */
		/* 820B3050h case   30:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3050h case   30:*/		return 0x820B3054;
		  /* 820B3054h */ case   31:  		/* bc 12, CR0_LT, 1300 */
		/* 820B3054h case   31:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3054h case   31:*/		return 0x820B3058;
		  /* 820B3058h */ case   32:  		/* lwz R25, <#[R1 + 128]> */
		/* 820B3058h case   32:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000080) );
		/* 820B3058h case   32:*/		return 0x820B305C;
		  /* 820B305Ch */ case   33:  		/* li R9, 20 */
		/* 820B305Ch case   33:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820B305Ch case   33:*/		return 0x820B3060;
		  /* 820B3060h */ case   34:  		/* mr R8, R23 */
		/* 820B3060h case   34:*/		regs.R8 = regs.R23;
		/* 820B3060h case   34:*/		return 0x820B3064;
		  /* 820B3064h */ case   35:  		/* mr R7, R23 */
		/* 820B3064h case   35:*/		regs.R7 = regs.R23;
		/* 820B3064h case   35:*/		return 0x820B3068;
		  /* 820B3068h */ case   36:  		/* mr R6, R25 */
		/* 820B3068h case   36:*/		regs.R6 = regs.R25;
		/* 820B3068h case   36:*/		return 0x820B306C;
		  /* 820B306Ch */ case   37:  		/* mr R5, R24 */
		/* 820B306Ch case   37:*/		regs.R5 = regs.R24;
		/* 820B306Ch case   37:*/		return 0x820B3070;
		  /* 820B3070h */ case   38:  		/* mr R4, R29 */
		/* 820B3070h case   38:*/		regs.R4 = regs.R29;
		/* 820B3070h case   38:*/		return 0x820B3074;
		  /* 820B3074h */ case   39:  		/* mr R3, R30 */
		/* 820B3074h case   39:*/		regs.R3 = regs.R30;
		/* 820B3074h case   39:*/		return 0x820B3078;
		  /* 820B3078h */ case   40:  		/* bl -9584 */
		/* 820B3078h case   40:*/		regs.LR = 0x820B307C; return 0x820B0B08;
		/* 820B3078h case   40:*/		return 0x820B307C;
		  /* 820B307Ch */ case   41:  		/* or. R31, R3, R3 */
		/* 820B307Ch case   41:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B307Ch case   41:*/		return 0x820B3080;
		  /* 820B3080h */ case   42:  		/* bc 12, CR0_LT, 1256 */
		/* 820B3080h case   42:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3080h case   42:*/		return 0x820B3084;
		  /* 820B3084h */ case   43:  		/* lwz R26, <#[R1 + 132]> */
		/* 820B3084h case   43:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000084) );
		/* 820B3084h case   43:*/		return 0x820B3088;
		  /* 820B3088h */ case   44:  		/* li R9, 0 */
		/* 820B3088h case   44:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3088h case   44:*/		return 0x820B308C;
		  /* 820B308Ch */ case   45:  		/* mr R8, R18 */
		/* 820B308Ch case   45:*/		regs.R8 = regs.R18;
		/* 820B308Ch case   45:*/		return 0x820B3090;
		  /* 820B3090h */ case   46:  		/* mr R7, R25 */
		/* 820B3090h case   46:*/		regs.R7 = regs.R25;
		/* 820B3090h case   46:*/		return 0x820B3094;
		  /* 820B3094h */ case   47:  		/* mr R6, R26 */
		/* 820B3094h case   47:*/		regs.R6 = regs.R26;
		/* 820B3094h case   47:*/		return 0x820B3098;
		  /* 820B3098h */ case   48:  		/* mr R5, R24 */
		/* 820B3098h case   48:*/		regs.R5 = regs.R24;
		/* 820B3098h case   48:*/		return 0x820B309C;
		  /* 820B309Ch */ case   49:  		/* mr R4, R29 */
		/* 820B309Ch case   49:*/		regs.R4 = regs.R29;
		/* 820B309Ch case   49:*/		return 0x820B30A0;
		  /* 820B30A0h */ case   50:  		/* mr R3, R30 */
		/* 820B30A0h case   50:*/		regs.R3 = regs.R30;
		/* 820B30A0h case   50:*/		return 0x820B30A4;
		  /* 820B30A4h */ case   51:  		/* bl -9628 */
		/* 820B30A4h case   51:*/		regs.LR = 0x820B30A8; return 0x820B0B08;
		/* 820B30A4h case   51:*/		return 0x820B30A8;
		  /* 820B30A8h */ case   52:  		/* or. R31, R3, R3 */
		/* 820B30A8h case   52:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B30A8h case   52:*/		return 0x820B30AC;
		  /* 820B30ACh */ case   53:  		/* bc 12, CR0_LT, 1212 */
		/* 820B30ACh case   53:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B30ACh case   53:*/		return 0x820B30B0;
		  /* 820B30B0h */ case   54:  		/* lwz R27, <#[R1 + 136]> */
		/* 820B30B0h case   54:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000088) );
		/* 820B30B0h case   54:*/		return 0x820B30B4;
		  /* 820B30B4h */ case   55:  		/* oris R21, R19, 8256 */
		/* 820B30B4h case   55:*/		cpu::op::oris<0>(regs,&regs.R21,regs.R19,0x2040);
		/* 820B30B4h case   55:*/		return 0x820B30B8;
		  /* 820B30B8h */ case   56:  		/* li R9, 0 */
		/* 820B30B8h case   56:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B30B8h case   56:*/		return 0x820B30BC;
		  /* 820B30BCh */ case   57:  		/* mr R8, R28 */
		/* 820B30BCh case   57:*/		regs.R8 = regs.R28;
		/* 820B30BCh case   57:*/		return 0x820B30C0;
		  /* 820B30C0h */ case   58:  		/* mr R7, R26 */
		/* 820B30C0h case   58:*/		regs.R7 = regs.R26;
		/* 820B30C0h case   58:*/		return 0x820B30C4;
		  /* 820B30C4h */ case   59:  		/* mr R6, R27 */
		/* 820B30C4h case   59:*/		regs.R6 = regs.R27;
		/* 820B30C4h case   59:*/		return 0x820B30C8;
		  /* 820B30C8h */ case   60:  		/* mr R5, R21 */
		/* 820B30C8h case   60:*/		regs.R5 = regs.R21;
		/* 820B30C8h case   60:*/		return 0x820B30CC;
		  /* 820B30CCh */ case   61:  		/* mr R4, R29 */
		/* 820B30CCh case   61:*/		regs.R4 = regs.R29;
		/* 820B30CCh case   61:*/		return 0x820B30D0;
		  /* 820B30D0h */ case   62:  		/* mr R3, R30 */
		/* 820B30D0h case   62:*/		regs.R3 = regs.R30;
		/* 820B30D0h case   62:*/		return 0x820B30D4;
		  /* 820B30D4h */ case   63:  		/* bl -9676 */
		/* 820B30D4h case   63:*/		regs.LR = 0x820B30D8; return 0x820B0B08;
		/* 820B30D4h case   63:*/		return 0x820B30D8;
		  /* 820B30D8h */ case   64:  		/* or. R31, R3, R3 */
		/* 820B30D8h case   64:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B30D8h case   64:*/		return 0x820B30DC;
		  /* 820B30DCh */ case   65:  		/* bc 12, CR0_LT, 1164 */
		/* 820B30DCh case   65:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B30DCh case   65:*/		return 0x820B30E0;
		  /* 820B30E0h */ case   66:  		/* lwz R26, <#[R1 + 140]> */
		/* 820B30E0h case   66:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x0000008C) );
		/* 820B30E0h case   66:*/		return 0x820B30E4;
		  /* 820B30E4h */ case   67:  		/* li R9, 0 */
		/* 820B30E4h case   67:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B30E4h case   67:*/		return 0x820B30E8;
		  /* 820B30E8h */ case   68:  		/* mr R8, R27 */
		/* 820B30E8h case   68:*/		regs.R8 = regs.R27;
		/* 820B30E8h case   68:*/		return 0x820B30EC;
		  /* 820B30ECh */ case   69:  		/* mr R7, R25 */
		/* 820B30ECh case   69:*/		regs.R7 = regs.R25;
		/* 820B30ECh case   69:*/		return 0x820B30F0;
		  /* 820B30F0h */ case   70:  		/* mr R6, R26 */
		/* 820B30F0h case   70:*/		regs.R6 = regs.R26;
		/* 820B30F0h case   70:*/		return 0x820B30F4;
		  /* 820B30F4h */ case   71:  		/* mr R5, R24 */
		/* 820B30F4h case   71:*/		regs.R5 = regs.R24;
		/* 820B30F4h case   71:*/		return 0x820B30F8;
		  /* 820B30F8h */ case   72:  		/* mr R4, R29 */
		/* 820B30F8h case   72:*/		regs.R4 = regs.R29;
		/* 820B30F8h case   72:*/		return 0x820B30FC;
		  /* 820B30FCh */ case   73:  		/* mr R3, R30 */
		/* 820B30FCh case   73:*/		regs.R3 = regs.R30;
		/* 820B30FCh case   73:*/		return 0x820B3100;
		  /* 820B3100h */ case   74:  		/* bl -9720 */
		/* 820B3100h case   74:*/		regs.LR = 0x820B3104; return 0x820B0B08;
		/* 820B3100h case   74:*/		return 0x820B3104;
		  /* 820B3104h */ case   75:  		/* or. R31, R3, R3 */
		/* 820B3104h case   75:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3104h case   75:*/		return 0x820B3108;
		  /* 820B3108h */ case   76:  		/* bc 12, CR0_LT, 1120 */
		/* 820B3108h case   76:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3108h case   76:*/		return 0x820B310C;
		  /* 820B310Ch */ case   77:  		/* lwz R28, <#[R1 + 144]> */
		/* 820B310Ch case   77:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000090) );
		/* 820B310Ch case   77:*/		return 0x820B3110;
		  /* 820B3110h */ case   78:  		/* li R9, 0 */
		/* 820B3110h case   78:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3110h case   78:*/		return 0x820B3114;
		  /* 820B3114h */ case   79:  		/* mr R8, R17 */
		/* 820B3114h case   79:*/		regs.R8 = regs.R17;
		/* 820B3114h case   79:*/		return 0x820B3118;
		  /* 820B3118h */ case   80:  		/* mr R7, R26 */
		/* 820B3118h case   80:*/		regs.R7 = regs.R26;
		/* 820B3118h case   80:*/		return 0x820B311C;
		  /* 820B311Ch */ case   81:  		/* mr R6, R28 */
		/* 820B311Ch case   81:*/		regs.R6 = regs.R28;
		/* 820B311Ch case   81:*/		return 0x820B3120;
		  /* 820B3120h */ case   82:  		/* mr R5, R21 */
		/* 820B3120h case   82:*/		regs.R5 = regs.R21;
		/* 820B3120h case   82:*/		return 0x820B3124;
		  /* 820B3124h */ case   83:  		/* mr R4, R29 */
		/* 820B3124h case   83:*/		regs.R4 = regs.R29;
		/* 820B3124h case   83:*/		return 0x820B3128;
		  /* 820B3128h */ case   84:  		/* mr R3, R30 */
		/* 820B3128h case   84:*/		regs.R3 = regs.R30;
		/* 820B3128h case   84:*/		return 0x820B312C;
		  /* 820B312Ch */ case   85:  		/* bl -9764 */
		/* 820B312Ch case   85:*/		regs.LR = 0x820B3130; return 0x820B0B08;
		/* 820B312Ch case   85:*/		return 0x820B3130;
		  /* 820B3130h */ case   86:  		/* or. R31, R3, R3 */
		/* 820B3130h case   86:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3130h case   86:*/		return 0x820B3134;
		  /* 820B3134h */ case   87:  		/* bc 12, CR0_LT, 1076 */
		/* 820B3134h case   87:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3134h case   87:*/		return 0x820B3138;
		  /* 820B3138h */ case   88:  		/* lwz R27, <#[R1 + 148]> */
		/* 820B3138h case   88:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000094) );
		/* 820B3138h case   88:*/		return 0x820B313C;
		  /* 820B313Ch */ case   89:  		/* li R9, 0 */
		/* 820B313Ch case   89:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B313Ch case   89:*/		return 0x820B3140;
		  /* 820B3140h */ case   90:  		/* mr R8, R28 */
		/* 820B3140h case   90:*/		regs.R8 = regs.R28;
		/* 820B3140h case   90:*/		return 0x820B3144;
		  /* 820B3144h */ case   91:  		/* mr R7, R25 */
		/* 820B3144h case   91:*/		regs.R7 = regs.R25;
		/* 820B3144h case   91:*/		return 0x820B3148;
		  /* 820B3148h */ case   92:  		/* mr R6, R27 */
		/* 820B3148h case   92:*/		regs.R6 = regs.R27;
		/* 820B3148h case   92:*/		return 0x820B314C;
		  /* 820B314Ch */ case   93:  		/* mr R5, R24 */
		/* 820B314Ch case   93:*/		regs.R5 = regs.R24;
		/* 820B314Ch case   93:*/		return 0x820B3150;
		  /* 820B3150h */ case   94:  		/* mr R4, R29 */
		/* 820B3150h case   94:*/		regs.R4 = regs.R29;
		/* 820B3150h case   94:*/		return 0x820B3154;
		  /* 820B3154h */ case   95:  		/* mr R3, R30 */
		/* 820B3154h case   95:*/		regs.R3 = regs.R30;
		/* 820B3154h case   95:*/		return 0x820B3158;
		  /* 820B3158h */ case   96:  		/* bl -9808 */
		/* 820B3158h case   96:*/		regs.LR = 0x820B315C; return 0x820B0B08;
		/* 820B3158h case   96:*/		return 0x820B315C;
		  /* 820B315Ch */ case   97:  		/* or. R31, R3, R3 */
		/* 820B315Ch case   97:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B315Ch case   97:*/		return 0x820B3160;
		  /* 820B3160h */ case   98:  		/* bc 12, CR0_LT, 1032 */
		/* 820B3160h case   98:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3160h case   98:*/		return 0x820B3164;
		  /* 820B3164h */ case   99:  		/* lwz R28, <#[R1 + 152]> */
		/* 820B3164h case   99:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000098) );
		/* 820B3164h case   99:*/		return 0x820B3168;
		  /* 820B3168h */ case  100:  		/* li R9, 0 */
		/* 820B3168h case  100:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3168h case  100:*/		return 0x820B316C;
		  /* 820B316Ch */ case  101:  		/* mr R8, R16 */
		/* 820B316Ch case  101:*/		regs.R8 = regs.R16;
		/* 820B316Ch case  101:*/		return 0x820B3170;
		  /* 820B3170h */ case  102:  		/* mr R7, R27 */
		/* 820B3170h case  102:*/		regs.R7 = regs.R27;
		/* 820B3170h case  102:*/		return 0x820B3174;
		  /* 820B3174h */ case  103:  		/* mr R6, R28 */
		/* 820B3174h case  103:*/		regs.R6 = regs.R28;
		/* 820B3174h case  103:*/		return 0x820B3178;
		  /* 820B3178h */ case  104:  		/* mr R5, R21 */
		/* 820B3178h case  104:*/		regs.R5 = regs.R21;
		/* 820B3178h case  104:*/		return 0x820B317C;
		  /* 820B317Ch */ case  105:  		/* mr R4, R29 */
		/* 820B317Ch case  105:*/		regs.R4 = regs.R29;
		/* 820B317Ch case  105:*/		return 0x820B3180;
		  /* 820B3180h */ case  106:  		/* mr R3, R30 */
		/* 820B3180h case  106:*/		regs.R3 = regs.R30;
		/* 820B3180h case  106:*/		return 0x820B3184;
		  /* 820B3184h */ case  107:  		/* bl -9852 */
		/* 820B3184h case  107:*/		regs.LR = 0x820B3188; return 0x820B0B08;
		/* 820B3184h case  107:*/		return 0x820B3188;
		  /* 820B3188h */ case  108:  		/* or. R31, R3, R3 */
		/* 820B3188h case  108:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3188h case  108:*/		return 0x820B318C;
		  /* 820B318Ch */ case  109:  		/* bc 12, CR0_LT, 988 */
		/* 820B318Ch case  109:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B318Ch case  109:*/		return 0x820B3190;
		  /* 820B3190h */ case  110:  		/* lwz R27, <#[R1 + 156]> */
		/* 820B3190h case  110:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000009C) );
		/* 820B3190h case  110:*/		return 0x820B3194;
		  /* 820B3194h */ case  111:  		/* li R9, 0 */
		/* 820B3194h case  111:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3194h case  111:*/		return 0x820B3198;
		  /* 820B3198h */ case  112:  		/* mr R8, R28 */
		/* 820B3198h case  112:*/		regs.R8 = regs.R28;
		/* 820B3198h case  112:*/		return 0x820B319C;
		  /* 820B319Ch */ case  113:  		/* mr R7, R25 */
		/* 820B319Ch case  113:*/		regs.R7 = regs.R25;
		/* 820B319Ch case  113:*/		return 0x820B31A0;
		  /* 820B31A0h */ case  114:  		/* mr R6, R27 */
		/* 820B31A0h case  114:*/		regs.R6 = regs.R27;
		/* 820B31A0h case  114:*/		return 0x820B31A4;
		  /* 820B31A4h */ case  115:  		/* mr R5, R24 */
		/* 820B31A4h case  115:*/		regs.R5 = regs.R24;
		/* 820B31A4h case  115:*/		return 0x820B31A8;
		  /* 820B31A8h */ case  116:  		/* mr R4, R29 */
		/* 820B31A8h case  116:*/		regs.R4 = regs.R29;
		/* 820B31A8h case  116:*/		return 0x820B31AC;
		  /* 820B31ACh */ case  117:  		/* mr R3, R30 */
		/* 820B31ACh case  117:*/		regs.R3 = regs.R30;
		/* 820B31ACh case  117:*/		return 0x820B31B0;
		  /* 820B31B0h */ case  118:  		/* bl -9896 */
		/* 820B31B0h case  118:*/		regs.LR = 0x820B31B4; return 0x820B0B08;
		/* 820B31B0h case  118:*/		return 0x820B31B4;
		  /* 820B31B4h */ case  119:  		/* or. R31, R3, R3 */
		/* 820B31B4h case  119:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B31B4h case  119:*/		return 0x820B31B8;
		  /* 820B31B8h */ case  120:  		/* bc 12, CR0_LT, 944 */
		/* 820B31B8h case  120:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B31B8h case  120:*/		return 0x820B31BC;
		  /* 820B31BCh */ case  121:  		/* lwz R28, <#[R1 + 160]> */
		/* 820B31BCh case  121:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B31BCh case  121:*/		return 0x820B31C0;
		  /* 820B31C0h */ case  122:  		/* li R9, 0 */
		/* 820B31C0h case  122:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B31C0h case  122:*/		return 0x820B31C4;
		  /* 820B31C4h */ case  123:  		/* mr R8, R15 */
		/* 820B31C4h case  123:*/		regs.R8 = regs.R15;
		/* 820B31C4h case  123:*/		return 0x820B31C8;
		  /* 820B31C8h */ case  124:  		/* mr R7, R27 */
		/* 820B31C8h case  124:*/		regs.R7 = regs.R27;
		/* 820B31C8h case  124:*/		return 0x820B31CC;
		  /* 820B31CCh */ case  125:  		/* mr R6, R28 */
		/* 820B31CCh case  125:*/		regs.R6 = regs.R28;
		/* 820B31CCh case  125:*/		return 0x820B31D0;
		  /* 820B31D0h */ case  126:  		/* mr R5, R21 */
		/* 820B31D0h case  126:*/		regs.R5 = regs.R21;
		/* 820B31D0h case  126:*/		return 0x820B31D4;
		  /* 820B31D4h */ case  127:  		/* mr R4, R29 */
		/* 820B31D4h case  127:*/		regs.R4 = regs.R29;
		/* 820B31D4h case  127:*/		return 0x820B31D8;
		  /* 820B31D8h */ case  128:  		/* mr R3, R30 */
		/* 820B31D8h case  128:*/		regs.R3 = regs.R30;
		/* 820B31D8h case  128:*/		return 0x820B31DC;
		  /* 820B31DCh */ case  129:  		/* bl -9940 */
		/* 820B31DCh case  129:*/		regs.LR = 0x820B31E0; return 0x820B0B08;
		/* 820B31DCh case  129:*/		return 0x820B31E0;
		  /* 820B31E0h */ case  130:  		/* or. R31, R3, R3 */
		/* 820B31E0h case  130:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B31E0h case  130:*/		return 0x820B31E4;
		  /* 820B31E4h */ case  131:  		/* bc 12, CR0_LT, 900 */
		/* 820B31E4h case  131:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B31E4h case  131:*/		return 0x820B31E8;
		  /* 820B31E8h */ case  132:  		/* lwz R25, <#[R1 + 164]> */
		/* 820B31E8h case  132:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B31E8h case  132:*/		return 0x820B31EC;
		  /* 820B31ECh */ case  133:  		/* li R9, 0 */
		/* 820B31ECh case  133:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B31ECh case  133:*/		return 0x820B31F0;
		  /* 820B31F0h */ case  134:  		/* mr R8, R28 */
		/* 820B31F0h case  134:*/		regs.R8 = regs.R28;
		/* 820B31F0h case  134:*/		return 0x820B31F4;
		  /* 820B31F4h */ case  135:  		/* mr R7, R23 */
		/* 820B31F4h case  135:*/		regs.R7 = regs.R23;
		/* 820B31F4h case  135:*/		return 0x820B31F8;
		  /* 820B31F8h */ case  136:  		/* mr R6, R25 */
		/* 820B31F8h case  136:*/		regs.R6 = regs.R25;
		/* 820B31F8h case  136:*/		return 0x820B31FC;
		  /* 820B31FCh */ case  137:  		/* mr R5, R24 */
		/* 820B31FCh case  137:*/		regs.R5 = regs.R24;
		/* 820B31FCh case  137:*/		return 0x820B3200;
		  /* 820B3200h */ case  138:  		/* mr R4, R29 */
		/* 820B3200h case  138:*/		regs.R4 = regs.R29;
		/* 820B3200h case  138:*/		return 0x820B3204;
		  /* 820B3204h */ case  139:  		/* mr R3, R30 */
		/* 820B3204h case  139:*/		regs.R3 = regs.R30;
		/* 820B3204h case  139:*/		return 0x820B3208;
		  /* 820B3208h */ case  140:  		/* bl -9984 */
		/* 820B3208h case  140:*/		regs.LR = 0x820B320C; return 0x820B0B08;
		/* 820B3208h case  140:*/		return 0x820B320C;
		  /* 820B320Ch */ case  141:  		/* or. R31, R3, R3 */
		/* 820B320Ch case  141:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B320Ch case  141:*/		return 0x820B3210;
		  /* 820B3210h */ case  142:  		/* bc 12, CR0_LT, 856 */
		/* 820B3210h case  142:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3210h case  142:*/		return 0x820B3214;
		  /* 820B3214h */ case  143:  		/* lwz R26, <#[R1 + 168]> */
		/* 820B3214h case  143:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000A8) );
		/* 820B3214h case  143:*/		return 0x820B3218;
		  /* 820B3218h */ case  144:  		/* oris R23, R19, 8224 */
		/* 820B3218h case  144:*/		cpu::op::oris<0>(regs,&regs.R23,regs.R19,0x2020);
		/* 820B3218h case  144:*/		return 0x820B321C;
		  /* 820B321Ch */ case  145:  		/* li R9, 23 */
		/* 820B321Ch case  145:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B321Ch case  145:*/		return 0x820B3220;
		  /* 820B3220h */ case  146:  		/* mr R8, R20 */
		/* 820B3220h case  146:*/		regs.R8 = regs.R20;
		/* 820B3220h case  146:*/		return 0x820B3224;
		  /* 820B3224h */ case  147:  		/* mr R7, R22 */
		/* 820B3224h case  147:*/		regs.R7 = regs.R22;
		/* 820B3224h case  147:*/		return 0x820B3228;
		  /* 820B3228h */ case  148:  		/* mr R6, R26 */
		/* 820B3228h case  148:*/		regs.R6 = regs.R26;
		/* 820B3228h case  148:*/		return 0x820B322C;
		  /* 820B322Ch */ case  149:  		/* mr R5, R23 */
		/* 820B322Ch case  149:*/		regs.R5 = regs.R23;
		/* 820B322Ch case  149:*/		return 0x820B3230;
		  /* 820B3230h */ case  150:  		/* mr R4, R29 */
		/* 820B3230h case  150:*/		regs.R4 = regs.R29;
		/* 820B3230h case  150:*/		return 0x820B3234;
		  /* 820B3234h */ case  151:  		/* mr R3, R30 */
		/* 820B3234h case  151:*/		regs.R3 = regs.R30;
		/* 820B3234h case  151:*/		return 0x820B3238;
		  /* 820B3238h */ case  152:  		/* bl -10032 */
		/* 820B3238h case  152:*/		regs.LR = 0x820B323C; return 0x820B0B08;
		/* 820B3238h case  152:*/		return 0x820B323C;
		  /* 820B323Ch */ case  153:  		/* or. R31, R3, R3 */
		/* 820B323Ch case  153:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B323Ch case  153:*/		return 0x820B3240;
		  /* 820B3240h */ case  154:  		/* bc 12, CR0_LT, 808 */
		/* 820B3240h case  154:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3240h case  154:*/		return 0x820B3244;
		  /* 820B3244h */ case  155:  		/* lwz R28, <#[R1 + 172]> */
		/* 820B3244h case  155:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000AC) );
		/* 820B3244h case  155:*/		return 0x820B3248;
		  /* 820B3248h */ case  156:  		/* li R9, 0 */
		/* 820B3248h case  156:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3248h case  156:*/		return 0x820B324C;
		  /* 820B324Ch */ case  157:  		/* mr R7, R25 */
		/* 820B324Ch case  157:*/		regs.R7 = regs.R25;
		/* 820B324Ch case  157:*/		return 0x820B3250;
		  /* 820B3250h */ case  158:  		/* lwz R8, <#[R1 + 272]> */
		/* 820B3250h case  158:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000110) );
		/* 820B3250h case  158:*/		return 0x820B3254;
		  /* 820B3254h */ case  159:  		/* mr R6, R28 */
		/* 820B3254h case  159:*/		regs.R6 = regs.R28;
		/* 820B3254h case  159:*/		return 0x820B3258;
		  /* 820B3258h */ case  160:  		/* mr R5, R24 */
		/* 820B3258h case  160:*/		regs.R5 = regs.R24;
		/* 820B3258h case  160:*/		return 0x820B325C;
		  /* 820B325Ch */ case  161:  		/* mr R4, R29 */
		/* 820B325Ch case  161:*/		regs.R4 = regs.R29;
		/* 820B325Ch case  161:*/		return 0x820B3260;
		  /* 820B3260h */ case  162:  		/* mr R3, R30 */
		/* 820B3260h case  162:*/		regs.R3 = regs.R30;
		/* 820B3260h case  162:*/		return 0x820B3264;
		  /* 820B3264h */ case  163:  		/* bl -10076 */
		/* 820B3264h case  163:*/		regs.LR = 0x820B3268; return 0x820B0B08;
		/* 820B3264h case  163:*/		return 0x820B3268;
		  /* 820B3268h */ case  164:  		/* or. R31, R3, R3 */
		/* 820B3268h case  164:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3268h case  164:*/		return 0x820B326C;
		  /* 820B326Ch */ case  165:  		/* bc 12, CR0_LT, 764 */
		/* 820B326Ch case  165:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B326Ch case  165:*/		return 0x820B3270;
		  /* 820B3270h */ case  166:  		/* lwz R27, <#[R1 + 176]> */
		/* 820B3270h case  166:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000B0) );
		/* 820B3270h case  166:*/		return 0x820B3274;
		  /* 820B3274h */ case  167:  		/* li R9, 0 */
		/* 820B3274h case  167:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3274h case  167:*/		return 0x820B3278;
		  /* 820B3278h */ case  168:  		/* mr R7, R28 */
		/* 820B3278h case  168:*/		regs.R7 = regs.R28;
		/* 820B3278h case  168:*/		return 0x820B327C;
		  /* 820B327Ch */ case  169:  		/* lwz R8, <#[R1 + 276]> */
		/* 820B327Ch case  169:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000114) );
		/* 820B327Ch case  169:*/		return 0x820B3280;
		  /* 820B3280h */ case  170:  		/* mr R6, R27 */
		/* 820B3280h case  170:*/		regs.R6 = regs.R27;
		/* 820B3280h case  170:*/		return 0x820B3284;
		  /* 820B3284h */ case  171:  		/* mr R5, R21 */
		/* 820B3284h case  171:*/		regs.R5 = regs.R21;
		/* 820B3284h case  171:*/		return 0x820B3288;
		  /* 820B3288h */ case  172:  		/* mr R4, R29 */
		/* 820B3288h case  172:*/		regs.R4 = regs.R29;
		/* 820B3288h case  172:*/		return 0x820B328C;
		  /* 820B328Ch */ case  173:  		/* mr R3, R30 */
		/* 820B328Ch case  173:*/		regs.R3 = regs.R30;
		/* 820B328Ch case  173:*/		return 0x820B3290;
		  /* 820B3290h */ case  174:  		/* bl -10120 */
		/* 820B3290h case  174:*/		regs.LR = 0x820B3294; return 0x820B0B08;
		/* 820B3290h case  174:*/		return 0x820B3294;
		  /* 820B3294h */ case  175:  		/* or. R31, R3, R3 */
		/* 820B3294h case  175:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3294h case  175:*/		return 0x820B3298;
		  /* 820B3298h */ case  176:  		/* bc 12, CR0_LT, 720 */
		/* 820B3298h case  176:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3298h case  176:*/		return 0x820B329C;
		  /* 820B329Ch */ case  177:  		/* lwz R28, <#[R1 + 180]> */
		/* 820B329Ch case  177:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000B4) );
		/* 820B329Ch case  177:*/		return 0x820B32A0;
		  /* 820B32A0h */ case  178:  		/* li R9, 0 */
		/* 820B32A0h case  178:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B32A0h case  178:*/		return 0x820B32A4;
		  /* 820B32A4h */ case  179:  		/* mr R8, R26 */
		/* 820B32A4h case  179:*/		regs.R8 = regs.R26;
		/* 820B32A4h case  179:*/		return 0x820B32A8;
		  /* 820B32A8h */ case  180:  		/* mr R7, R27 */
		/* 820B32A8h case  180:*/		regs.R7 = regs.R27;
		/* 820B32A8h case  180:*/		return 0x820B32AC;
		  /* 820B32ACh */ case  181:  		/* mr R6, R28 */
		/* 820B32ACh case  181:*/		regs.R6 = regs.R28;
		/* 820B32ACh case  181:*/		return 0x820B32B0;
		  /* 820B32B0h */ case  182:  		/* mr R5, R24 */
		/* 820B32B0h case  182:*/		regs.R5 = regs.R24;
		/* 820B32B0h case  182:*/		return 0x820B32B4;
		  /* 820B32B4h */ case  183:  		/* mr R4, R29 */
		/* 820B32B4h case  183:*/		regs.R4 = regs.R29;
		/* 820B32B4h case  183:*/		return 0x820B32B8;
		  /* 820B32B8h */ case  184:  		/* mr R3, R30 */
		/* 820B32B8h case  184:*/		regs.R3 = regs.R30;
		/* 820B32B8h case  184:*/		return 0x820B32BC;
		  /* 820B32BCh */ case  185:  		/* bl -10164 */
		/* 820B32BCh case  185:*/		regs.LR = 0x820B32C0; return 0x820B0B08;
		/* 820B32BCh case  185:*/		return 0x820B32C0;
		  /* 820B32C0h */ case  186:  		/* or. R31, R3, R3 */
		/* 820B32C0h case  186:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B32C0h case  186:*/		return 0x820B32C4;
		  /* 820B32C4h */ case  187:  		/* bc 12, CR0_LT, 676 */
		/* 820B32C4h case  187:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B32C4h case  187:*/		return 0x820B32C8;
		  /* 820B32C8h */ case  188:  		/* lwz R26, <#[R1 + 184]> */
		/* 820B32C8h case  188:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000B8) );
		/* 820B32C8h case  188:*/		return 0x820B32CC;
		  /* 820B32CCh */ case  189:  		/* li R9, 0 */
		/* 820B32CCh case  189:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B32CCh case  189:*/		return 0x820B32D0;
		  /* 820B32D0h */ case  190:  		/* mr R8, R25 */
		/* 820B32D0h case  190:*/		regs.R8 = regs.R25;
		/* 820B32D0h case  190:*/		return 0x820B32D4;
		  /* 820B32D4h */ case  191:  		/* mr R7, R28 */
		/* 820B32D4h case  191:*/		regs.R7 = regs.R28;
		/* 820B32D4h case  191:*/		return 0x820B32D8;
		  /* 820B32D8h */ case  192:  		/* mr R6, R26 */
		/* 820B32D8h case  192:*/		regs.R6 = regs.R26;
		/* 820B32D8h case  192:*/		return 0x820B32DC;
		  /* 820B32DCh */ case  193:  		/* mr R5, R21 */
		/* 820B32DCh case  193:*/		regs.R5 = regs.R21;
		/* 820B32DCh case  193:*/		return 0x820B32E0;
		  /* 820B32E0h */ case  194:  		/* mr R4, R29 */
		/* 820B32E0h case  194:*/		regs.R4 = regs.R29;
		/* 820B32E0h case  194:*/		return 0x820B32E4;
		  /* 820B32E4h */ case  195:  		/* mr R3, R30 */
		/* 820B32E4h case  195:*/		regs.R3 = regs.R30;
		/* 820B32E4h case  195:*/		return 0x820B32E8;
		  /* 820B32E8h */ case  196:  		/* bl -10208 */
		/* 820B32E8h case  196:*/		regs.LR = 0x820B32EC; return 0x820B0B08;
		/* 820B32E8h case  196:*/		return 0x820B32EC;
		  /* 820B32ECh */ case  197:  		/* or. R31, R3, R3 */
		/* 820B32ECh case  197:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B32ECh case  197:*/		return 0x820B32F0;
		  /* 820B32F0h */ case  198:  		/* bc 12, CR0_LT, 632 */
		/* 820B32F0h case  198:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B32F0h case  198:*/		return 0x820B32F4;
		  /* 820B32F4h */ case  199:  		/* lwz R27, <#[R1 + 200]> */
		/* 820B32F4h case  199:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000C8) );
		/* 820B32F4h case  199:*/		return 0x820B32F8;
		  /* 820B32F8h */ case  200:  		/* li R9, 23 */
		/* 820B32F8h case  200:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B32F8h case  200:*/		return 0x820B32FC;
		  /* 820B32FCh */ case  201:  		/* lwz R25, <#[R1 + 492]> */
		/* 820B32FCh case  201:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000001EC) );
		/* 820B32FCh case  201:*/		return 0x820B3300;
		  /* 820B3300h */ case  202:  		/* mr R8, R14 */
		/* 820B3300h case  202:*/		regs.R8 = regs.R14;
		/* 820B3300h case  202:*/		return 0x820B3304;
		  /* 820B3304h */ case  203:  		/* mr R6, R27 */
		/* 820B3304h case  203:*/		regs.R6 = regs.R27;
		/* 820B3304h case  203:*/		return 0x820B3308;
		  /* 820B3308h */ case  204:  		/* mr R7, R25 */
		/* 820B3308h case  204:*/		regs.R7 = regs.R25;
		/* 820B3308h case  204:*/		return 0x820B330C;
		  /* 820B330Ch */ case  205:  		/* mr R5, R23 */
		/* 820B330Ch case  205:*/		regs.R5 = regs.R23;
		/* 820B330Ch case  205:*/		return 0x820B3310;
		  /* 820B3310h */ case  206:  		/* mr R4, R29 */
		/* 820B3310h case  206:*/		regs.R4 = regs.R29;
		/* 820B3310h case  206:*/		return 0x820B3314;
		  /* 820B3314h */ case  207:  		/* mr R3, R30 */
		/* 820B3314h case  207:*/		regs.R3 = regs.R30;
		/* 820B3314h case  207:*/		return 0x820B3318;
		  /* 820B3318h */ case  208:  		/* bl -10256 */
		/* 820B3318h case  208:*/		regs.LR = 0x820B331C; return 0x820B0B08;
		/* 820B3318h case  208:*/		return 0x820B331C;
		  /* 820B331Ch */ case  209:  		/* or. R31, R3, R3 */
		/* 820B331Ch case  209:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B331Ch case  209:*/		return 0x820B3320;
		  /* 820B3320h */ case  210:  		/* bc 12, CR0_LT, 584 */
		/* 820B3320h case  210:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3320h case  210:*/		return 0x820B3324;
		  /* 820B3324h */ case  211:  		/* lwz R28, <#[R1 + 204]> */
		/* 820B3324h case  211:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000CC) );
		/* 820B3324h case  211:*/		return 0x820B3328;
		  /* 820B3328h */ case  212:  		/* li R9, 0 */
		/* 820B3328h case  212:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3328h case  212:*/		return 0x820B332C;
		  /* 820B332Ch */ case  213:  		/* mr R7, R27 */
		/* 820B332Ch case  213:*/		regs.R7 = regs.R27;
		/* 820B332Ch case  213:*/		return 0x820B3330;
		  /* 820B3330h */ case  214:  		/* lwz R8, <#[R1 + 280]> */
		/* 820B3330h case  214:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000118) );
		/* 820B3330h case  214:*/		return 0x820B3334;
		  /* 820B3334h */ case  215:  		/* mr R6, R28 */
		/* 820B3334h case  215:*/		regs.R6 = regs.R28;
		/* 820B3334h case  215:*/		return 0x820B3338;
		  /* 820B3338h */ case  216:  		/* mr R5, R24 */
		/* 820B3338h case  216:*/		regs.R5 = regs.R24;
		/* 820B3338h case  216:*/		return 0x820B333C;
		  /* 820B333Ch */ case  217:  		/* mr R4, R29 */
		/* 820B333Ch case  217:*/		regs.R4 = regs.R29;
		/* 820B333Ch case  217:*/		return 0x820B3340;
		  /* 820B3340h */ case  218:  		/* mr R3, R30 */
		/* 820B3340h case  218:*/		regs.R3 = regs.R30;
		/* 820B3340h case  218:*/		return 0x820B3344;
		  /* 820B3344h */ case  219:  		/* bl -10300 */
		/* 820B3344h case  219:*/		regs.LR = 0x820B3348; return 0x820B0B08;
		/* 820B3344h case  219:*/		return 0x820B3348;
		  /* 820B3348h */ case  220:  		/* or. R31, R3, R3 */
		/* 820B3348h case  220:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3348h case  220:*/		return 0x820B334C;
		  /* 820B334Ch */ case  221:  		/* bc 12, CR0_LT, 540 */
		/* 820B334Ch case  221:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B334Ch case  221:*/		return 0x820B3350;
		  /* 820B3350h */ case  222:  		/* lwz R22, <#[R1 + 208]> */
		/* 820B3350h case  222:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x000000D0) );
		/* 820B3350h case  222:*/		return 0x820B3354;
		  /* 820B3354h */ case  223:  		/* li R9, 0 */
		/* 820B3354h case  223:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3354h case  223:*/		return 0x820B3358;
		  /* 820B3358h */ case  224:  		/* mr R8, R28 */
		/* 820B3358h case  224:*/		regs.R8 = regs.R28;
		/* 820B3358h case  224:*/		return 0x820B335C;
		  /* 820B335Ch */ case  225:  		/* mr R7, R26 */
		/* 820B335Ch case  225:*/		regs.R7 = regs.R26;
		/* 820B335Ch case  225:*/		return 0x820B3360;
		  /* 820B3360h */ case  226:  		/* mr R6, R22 */
		/* 820B3360h case  226:*/		regs.R6 = regs.R22;
		/* 820B3360h case  226:*/		return 0x820B3364;
		  /* 820B3364h */ case  227:  		/* mr R5, R21 */
		/* 820B3364h case  227:*/		regs.R5 = regs.R21;
		/* 820B3364h case  227:*/		return 0x820B3368;
		  /* 820B3368h */ case  228:  		/* mr R4, R29 */
		/* 820B3368h case  228:*/		regs.R4 = regs.R29;
		/* 820B3368h case  228:*/		return 0x820B336C;
		  /* 820B336Ch */ case  229:  		/* mr R3, R30 */
		/* 820B336Ch case  229:*/		regs.R3 = regs.R30;
		/* 820B336Ch case  229:*/		return 0x820B3370;
		  /* 820B3370h */ case  230:  		/* bl -10344 */
		/* 820B3370h case  230:*/		regs.LR = 0x820B3374; return 0x820B0B08;
		/* 820B3370h case  230:*/		return 0x820B3374;
		  /* 820B3374h */ case  231:  		/* or. R31, R3, R3 */
		/* 820B3374h case  231:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3374h case  231:*/		return 0x820B3378;
		  /* 820B3378h */ case  232:  		/* bc 12, CR0_LT, 496 */
		/* 820B3378h case  232:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3378h case  232:*/		return 0x820B337C;
		  /* 820B337Ch */ case  233:  		/* lwz R27, <#[R1 + 212]> */
		/* 820B337Ch case  233:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000D4) );
		/* 820B337Ch case  233:*/		return 0x820B3380;
		  /* 820B3380h */ case  234:  		/* li R9, 0 */
		/* 820B3380h case  234:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3380h case  234:*/		return 0x820B3384;
		  /* 820B3384h */ case  235:  		/* lwz R28, <#[R1 + 484]> */
		/* 820B3384h case  235:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000001E4) );
		/* 820B3384h case  235:*/		return 0x820B3388;
		  /* 820B3388h */ case  236:  		/* mr R8, R25 */
		/* 820B3388h case  236:*/		regs.R8 = regs.R25;
		/* 820B3388h case  236:*/		return 0x820B338C;
		  /* 820B338Ch */ case  237:  		/* mr R6, R27 */
		/* 820B338Ch case  237:*/		regs.R6 = regs.R27;
		/* 820B338Ch case  237:*/		return 0x820B3390;
		  /* 820B3390h */ case  238:  		/* lwz R5, <#[R1 + 92]> */
		/* 820B3390h case  238:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B3390h case  238:*/		return 0x820B3394;
		  /* 820B3394h */ case  239:  		/* mr R7, R28 */
		/* 820B3394h case  239:*/		regs.R7 = regs.R28;
		/* 820B3394h case  239:*/		return 0x820B3398;
		  /* 820B3398h */ case  240:  		/* mr R4, R29 */
		/* 820B3398h case  240:*/		regs.R4 = regs.R29;
		/* 820B3398h case  240:*/		return 0x820B339C;
		  /* 820B339Ch */ case  241:  		/* mr R3, R30 */
		/* 820B339Ch case  241:*/		regs.R3 = regs.R30;
		/* 820B339Ch case  241:*/		return 0x820B33A0;
		  /* 820B33A0h */ case  242:  		/* bl -10392 */
		/* 820B33A0h case  242:*/		regs.LR = 0x820B33A4; return 0x820B0B08;
		/* 820B33A0h case  242:*/		return 0x820B33A4;
		  /* 820B33A4h */ case  243:  		/* or. R31, R3, R3 */
		/* 820B33A4h case  243:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B33A4h case  243:*/		return 0x820B33A8;
		  /* 820B33A8h */ case  244:  		/* bc 12, CR0_LT, 448 */
		/* 820B33A8h case  244:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B33A8h case  244:*/		return 0x820B33AC;
		  /* 820B33ACh */ case  245:  		/* lwz R26, <#[R1 + 216]> */
		/* 820B33ACh case  245:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000D8) );
		/* 820B33ACh case  245:*/		return 0x820B33B0;
		  /* 820B33B0h */ case  246:  		/* li R9, 0 */
		/* 820B33B0h case  246:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B33B0h case  246:*/		return 0x820B33B4;
		  /* 820B33B4h */ case  247:  		/* mr R8, R25 */
		/* 820B33B4h case  247:*/		regs.R8 = regs.R25;
		/* 820B33B4h case  247:*/		return 0x820B33B8;
		  /* 820B33B8h */ case  248:  		/* lwz R5, <#[R1 + 84]> */
		/* 820B33B8h case  248:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820B33B8h case  248:*/		return 0x820B33BC;
		  /* 820B33BCh */ case  249:  		/* mr R7, R28 */
		/* 820B33BCh case  249:*/		regs.R7 = regs.R28;
		/* 820B33BCh case  249:*/		return 0x820B33C0;
		  /* 820B33C0h */ case  250:  		/* mr R6, R26 */
		/* 820B33C0h case  250:*/		regs.R6 = regs.R26;
		/* 820B33C0h case  250:*/		return 0x820B33C4;
		  /* 820B33C4h */ case  251:  		/* mr R4, R29 */
		/* 820B33C4h case  251:*/		regs.R4 = regs.R29;
		/* 820B33C4h case  251:*/		return 0x820B33C8;
		  /* 820B33C8h */ case  252:  		/* mr R3, R30 */
		/* 820B33C8h case  252:*/		regs.R3 = regs.R30;
		/* 820B33C8h case  252:*/		return 0x820B33CC;
		  /* 820B33CCh */ case  253:  		/* bl -10436 */
		/* 820B33CCh case  253:*/		regs.LR = 0x820B33D0; return 0x820B0B08;
		/* 820B33CCh case  253:*/		return 0x820B33D0;
		  /* 820B33D0h */ case  254:  		/* or. R31, R3, R3 */
		/* 820B33D0h case  254:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B33D0h case  254:*/		return 0x820B33D4;
		  /* 820B33D4h */ case  255:  		/* bc 12, CR0_LT, 404 */
		/* 820B33D4h case  255:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B33D4h case  255:*/		return 0x820B33D8;
		  /* 820B33D8h */ case  256:  		/* lwz R28, <#[R1 + 220]> */
		/* 820B33D8h case  256:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000DC) );
		/* 820B33D8h case  256:*/		return 0x820B33DC;
		  /* 820B33DCh */ case  257:  		/* li R9, 0 */
		/* 820B33DCh case  257:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B33DCh case  257:*/		return 0x820B33E0;
		  /* 820B33E0h */ case  258:  		/* lwz R20, <#[R1 + 88]> */
		/* 820B33E0h case  258:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000058) );
		/* 820B33E0h case  258:*/		return 0x820B33E4;
		  /* 820B33E4h */ case  259:  		/* li R8, 0 */
		/* 820B33E4h case  259:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B33E4h case  259:*/		return 0x820B33E8;
		  /* 820B33E8h */ case  260:  		/* mr R7, R27 */
		/* 820B33E8h case  260:*/		regs.R7 = regs.R27;
		/* 820B33E8h case  260:*/		return 0x820B33EC;
		  /* 820B33ECh */ case  261:  		/* mr R6, R28 */
		/* 820B33ECh case  261:*/		regs.R6 = regs.R28;
		/* 820B33ECh case  261:*/		return 0x820B33F0;
		  /* 820B33F0h */ case  262:  		/* mr R5, R20 */
		/* 820B33F0h case  262:*/		regs.R5 = regs.R20;
		/* 820B33F0h case  262:*/		return 0x820B33F4;
		  /* 820B33F4h */ case  263:  		/* mr R4, R29 */
		/* 820B33F4h case  263:*/		regs.R4 = regs.R29;
		/* 820B33F4h case  263:*/		return 0x820B33F8;
		  /* 820B33F8h */ case  264:  		/* mr R3, R30 */
		/* 820B33F8h case  264:*/		regs.R3 = regs.R30;
		/* 820B33F8h case  264:*/		return 0x820B33FC;
		  /* 820B33FCh */ case  265:  		/* bl -10484 */
		/* 820B33FCh case  265:*/		regs.LR = 0x820B3400; return 0x820B0B08;
		/* 820B33FCh case  265:*/		return 0x820B3400;
		  /* 820B3400h */ case  266:  		/* or. R31, R3, R3 */
		/* 820B3400h case  266:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3400h case  266:*/		return 0x820B3404;
		  /* 820B3404h */ case  267:  		/* bc 12, CR0_LT, 356 */
		/* 820B3404h case  267:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3404h case  267:*/		return 0x820B3408;
		  /* 820B3408h */ case  268:  		/* lwz R25, <#[R1 + 224]> */
		/* 820B3408h case  268:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000E0) );
		/* 820B3408h case  268:*/		return 0x820B340C;
		  /* 820B340Ch */ case  269:  		/* li R9, 23 */
		/* 820B340Ch case  269:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B340Ch case  269:*/		return 0x820B3410;
		  /* 820B3410h */ case  270:  		/* mr R8, R28 */
		/* 820B3410h case  270:*/		regs.R8 = regs.R28;
		/* 820B3410h case  270:*/		return 0x820B3414;
		  /* 820B3414h */ case  271:  		/* mr R7, R27 */
		/* 820B3414h case  271:*/		regs.R7 = regs.R27;
		/* 820B3414h case  271:*/		return 0x820B3418;
		  /* 820B3418h */ case  272:  		/* mr R6, R25 */
		/* 820B3418h case  272:*/		regs.R6 = regs.R25;
		/* 820B3418h case  272:*/		return 0x820B341C;
		  /* 820B341Ch */ case  273:  		/* mr R5, R23 */
		/* 820B341Ch case  273:*/		regs.R5 = regs.R23;
		/* 820B341Ch case  273:*/		return 0x820B3420;
		  /* 820B3420h */ case  274:  		/* mr R4, R29 */
		/* 820B3420h case  274:*/		regs.R4 = regs.R29;
		/* 820B3420h case  274:*/		return 0x820B3424;
		  /* 820B3424h */ case  275:  		/* mr R3, R30 */
		/* 820B3424h case  275:*/		regs.R3 = regs.R30;
		/* 820B3424h case  275:*/		return 0x820B3428;
		  /* 820B3428h */ case  276:  		/* bl -10528 */
		/* 820B3428h case  276:*/		regs.LR = 0x820B342C; return 0x820B0B08;
		/* 820B3428h case  276:*/		return 0x820B342C;
		  /* 820B342Ch */ case  277:  		/* or. R31, R3, R3 */
		/* 820B342Ch case  277:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B342Ch case  277:*/		return 0x820B3430;
		  /* 820B3430h */ case  278:  		/* bc 12, CR0_LT, 312 */
		/* 820B3430h case  278:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3430h case  278:*/		return 0x820B3434;
		  /* 820B3434h */ case  279:  		/* lwz R27, <#[R1 + 228]> */
		/* 820B3434h case  279:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000E4) );
		/* 820B3434h case  279:*/		return 0x820B3438;
		  /* 820B3438h */ case  280:  		/* li R9, 0 */
		/* 820B3438h case  280:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3438h case  280:*/		return 0x820B343C;
		  /* 820B343Ch */ case  281:  		/* li R8, 0 */
		/* 820B343Ch case  281:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B343Ch case  281:*/		return 0x820B3440;
		  /* 820B3440h */ case  282:  		/* mr R7, R26 */
		/* 820B3440h case  282:*/		regs.R7 = regs.R26;
		/* 820B3440h case  282:*/		return 0x820B3444;
		  /* 820B3444h */ case  283:  		/* mr R6, R27 */
		/* 820B3444h case  283:*/		regs.R6 = regs.R27;
		/* 820B3444h case  283:*/		return 0x820B3448;
		  /* 820B3448h */ case  284:  		/* mr R5, R20 */
		/* 820B3448h case  284:*/		regs.R5 = regs.R20;
		/* 820B3448h case  284:*/		return 0x820B344C;
		  /* 820B344Ch */ case  285:  		/* mr R4, R29 */
		/* 820B344Ch case  285:*/		regs.R4 = regs.R29;
		/* 820B344Ch case  285:*/		return 0x820B3450;
		  /* 820B3450h */ case  286:  		/* mr R3, R30 */
		/* 820B3450h case  286:*/		regs.R3 = regs.R30;
		/* 820B3450h case  286:*/		return 0x820B3454;
		  /* 820B3454h */ case  287:  		/* bl -10572 */
		/* 820B3454h case  287:*/		regs.LR = 0x820B3458; return 0x820B0B08;
		/* 820B3454h case  287:*/		return 0x820B3458;
		  /* 820B3458h */ case  288:  		/* or. R31, R3, R3 */
		/* 820B3458h case  288:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3458h case  288:*/		return 0x820B345C;
		  /* 820B345Ch */ case  289:  		/* bc 12, CR0_LT, 268 */
		/* 820B345Ch case  289:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B345Ch case  289:*/		return 0x820B3460;
		  /* 820B3460h */ case  290:  		/* lwz R28, <#[R1 + 232]> */
		/* 820B3460h case  290:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000E8) );
		/* 820B3460h case  290:*/		return 0x820B3464;
		  /* 820B3464h */ case  291:  		/* li R9, 23 */
		/* 820B3464h case  291:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B3464h case  291:*/		return 0x820B3468;
		  /* 820B3468h */ case  292:  		/* mr R8, R27 */
		/* 820B3468h case  292:*/		regs.R8 = regs.R27;
		/* 820B3468h case  292:*/		return 0x820B346C;
		  /* 820B346Ch */ case  293:  		/* mr R7, R26 */
		/* 820B346Ch case  293:*/		regs.R7 = regs.R26;
		/* 820B346Ch case  293:*/		return 0x820B3470;
		  /* 820B3470h */ case  294:  		/* mr R6, R28 */
		/* 820B3470h case  294:*/		regs.R6 = regs.R28;
		/* 820B3470h case  294:*/		return 0x820B3474;
		  /* 820B3474h */ case  295:  		/* oris R5, R19, 8240 */
		/* 820B3474h case  295:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R19,0x2030);
		/* 820B3474h case  295:*/		return 0x820B3478;
		  /* 820B3478h */ case  296:  		/* mr R4, R29 */
		/* 820B3478h case  296:*/		regs.R4 = regs.R29;
		/* 820B3478h case  296:*/		return 0x820B347C;
		  /* 820B347Ch */ case  297:  		/* mr R3, R30 */
		/* 820B347Ch case  297:*/		regs.R3 = regs.R30;
		/* 820B347Ch case  297:*/		return 0x820B3480;
		  /* 820B3480h */ case  298:  		/* bl -10616 */
		/* 820B3480h case  298:*/		regs.LR = 0x820B3484; return 0x820B0B08;
		/* 820B3480h case  298:*/		return 0x820B3484;
		  /* 820B3484h */ case  299:  		/* or. R31, R3, R3 */
		/* 820B3484h case  299:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3484h case  299:*/		return 0x820B3488;
		  /* 820B3488h */ case  300:  		/* bc 12, CR0_LT, 224 */
		/* 820B3488h case  300:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3488h case  300:*/		return 0x820B348C;
		  /* 820B348Ch */ case  301:  		/* lwz R26, <#[R1 + 236]> */
		/* 820B348Ch case  301:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000EC) );
		/* 820B348Ch case  301:*/		return 0x820B3490;
		  /* 820B3490h */ case  302:  		/* li R9, 23 */
		/* 820B3490h case  302:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B3490h case  302:*/		return 0x820B3494;
		  /* 820B3494h */ case  303:  		/* mr R8, R28 */
		/* 820B3494h case  303:*/		regs.R8 = regs.R28;
		/* 820B3494h case  303:*/		return 0x820B3498;
		  /* 820B3498h */ case  304:  		/* mr R7, R25 */
		/* 820B3498h case  304:*/		regs.R7 = regs.R25;
		/* 820B3498h case  304:*/		return 0x820B349C;
		  /* 820B349Ch */ case  305:  		/* mr R6, R26 */
		/* 820B349Ch case  305:*/		regs.R6 = regs.R26;
		/* 820B349Ch case  305:*/		return 0x820B34A0;
		  /* 820B34A0h */ case  306:  		/* mr R5, R24 */
		/* 820B34A0h case  306:*/		regs.R5 = regs.R24;
		/* 820B34A0h case  306:*/		return 0x820B34A4;
		  /* 820B34A4h */ case  307:  		/* mr R4, R29 */
		/* 820B34A4h case  307:*/		regs.R4 = regs.R29;
		/* 820B34A4h case  307:*/		return 0x820B34A8;
		  /* 820B34A8h */ case  308:  		/* mr R3, R30 */
		/* 820B34A8h case  308:*/		regs.R3 = regs.R30;
		/* 820B34A8h case  308:*/		return 0x820B34AC;
		  /* 820B34ACh */ case  309:  		/* bl -10660 */
		/* 820B34ACh case  309:*/		regs.LR = 0x820B34B0; return 0x820B0B08;
		/* 820B34ACh case  309:*/		return 0x820B34B0;
		  /* 820B34B0h */ case  310:  		/* or. R31, R3, R3 */
		/* 820B34B0h case  310:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B34B0h case  310:*/		return 0x820B34B4;
		  /* 820B34B4h */ case  311:  		/* bc 12, CR0_LT, 180 */
		/* 820B34B4h case  311:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B34B4h case  311:*/		return 0x820B34B8;
		  /* 820B34B8h */ case  312:  		/* lwz R28, <#[R1 + 240]> */
		/* 820B34B8h case  312:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000F0) );
		/* 820B34B8h case  312:*/		return 0x820B34BC;
		  /* 820B34BCh */ case  313:  		/* li R9, 0 */
		/* 820B34BCh case  313:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B34BCh case  313:*/		return 0x820B34C0;
		  /* 820B34C0h */ case  314:  		/* mr R8, R22 */
		/* 820B34C0h case  314:*/		regs.R8 = regs.R22;
		/* 820B34C0h case  314:*/		return 0x820B34C4;
		  /* 820B34C4h */ case  315:  		/* mr R7, R22 */
		/* 820B34C4h case  315:*/		regs.R7 = regs.R22;
		/* 820B34C4h case  315:*/		return 0x820B34C8;
		  /* 820B34C8h */ case  316:  		/* mr R6, R28 */
		/* 820B34C8h case  316:*/		regs.R6 = regs.R28;
		/* 820B34C8h case  316:*/		return 0x820B34CC;
		  /* 820B34CCh */ case  317:  		/* mr R5, R21 */
		/* 820B34CCh case  317:*/		regs.R5 = regs.R21;
		/* 820B34CCh case  317:*/		return 0x820B34D0;
		  /* 820B34D0h */ case  318:  		/* mr R4, R29 */
		/* 820B34D0h case  318:*/		regs.R4 = regs.R29;
		/* 820B34D0h case  318:*/		return 0x820B34D4;
		  /* 820B34D4h */ case  319:  		/* mr R3, R30 */
		/* 820B34D4h case  319:*/		regs.R3 = regs.R30;
		/* 820B34D4h case  319:*/		return 0x820B34D8;
		  /* 820B34D8h */ case  320:  		/* bl -10704 */
		/* 820B34D8h case  320:*/		regs.LR = 0x820B34DC; return 0x820B0B08;
		/* 820B34D8h case  320:*/		return 0x820B34DC;
		  /* 820B34DCh */ case  321:  		/* or. R31, R3, R3 */
		/* 820B34DCh case  321:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B34DCh case  321:*/		return 0x820B34E0;
		  /* 820B34E0h */ case  322:  		/* bc 12, CR0_LT, 136 */
		/* 820B34E0h case  322:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B34E0h case  322:*/		return 0x820B34E4;
		  /* 820B34E4h */ case  323:  		/* lwz R27, <#[R1 + 244]> */
		/* 820B34E4h case  323:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000F4) );
		/* 820B34E4h case  323:*/		return 0x820B34E8;
		  /* 820B34E8h */ case  324:  		/* li R9, 0 */
		/* 820B34E8h case  324:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B34E8h case  324:*/		return 0x820B34EC;
		  /* 820B34ECh */ case  325:  		/* li R8, 0 */
		/* 820B34ECh case  325:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B34ECh case  325:*/		return 0x820B34F0;
		  /* 820B34F0h */ case  326:  		/* mr R7, R28 */
		/* 820B34F0h case  326:*/		regs.R7 = regs.R28;
		/* 820B34F0h case  326:*/		return 0x820B34F4;
		  /* 820B34F4h */ case  327:  		/* mr R6, R27 */
		/* 820B34F4h case  327:*/		regs.R6 = regs.R27;
		/* 820B34F4h case  327:*/		return 0x820B34F8;
		  /* 820B34F8h */ case  328:  		/* mr R5, R20 */
		/* 820B34F8h case  328:*/		regs.R5 = regs.R20;
		/* 820B34F8h case  328:*/		return 0x820B34FC;
		  /* 820B34FCh */ case  329:  		/* mr R4, R29 */
		/* 820B34FCh case  329:*/		regs.R4 = regs.R29;
		/* 820B34FCh case  329:*/		return 0x820B3500;
		  /* 820B3500h */ case  330:  		/* mr R3, R30 */
		/* 820B3500h case  330:*/		regs.R3 = regs.R30;
		/* 820B3500h case  330:*/		return 0x820B3504;
		  /* 820B3504h */ case  331:  		/* bl -10748 */
		/* 820B3504h case  331:*/		regs.LR = 0x820B3508; return 0x820B0B08;
		/* 820B3504h case  331:*/		return 0x820B3508;
		  /* 820B3508h */ case  332:  		/* or. R31, R3, R3 */
		/* 820B3508h case  332:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3508h case  332:*/		return 0x820B350C;
		  /* 820B350Ch */ case  333:  		/* bc 12, CR0_LT, 92 */
		/* 820B350Ch case  333:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B350Ch case  333:*/		return 0x820B3510;
		  /* 820B3510h */ case  334:  		/* lwz R28, <#[R1 + 248]> */
		/* 820B3510h case  334:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000F8) );
		/* 820B3510h case  334:*/		return 0x820B3514;
		  /* 820B3514h */ case  335:  		/* li R9, 0 */
		/* 820B3514h case  335:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3514h case  335:*/		return 0x820B3518;
		  /* 820B3518h */ case  336:  		/* mr R8, R27 */
		/* 820B3518h case  336:*/		regs.R8 = regs.R27;
		/* 820B3518h case  336:*/		return 0x820B351C;
		  /* 820B351Ch */ case  337:  		/* mr R7, R26 */
		/* 820B351Ch case  337:*/		regs.R7 = regs.R26;
		/* 820B351Ch case  337:*/		return 0x820B3520;
		  /* 820B3520h */ case  338:  		/* mr R6, R28 */
		/* 820B3520h case  338:*/		regs.R6 = regs.R28;
		/* 820B3520h case  338:*/		return 0x820B3524;
		  /* 820B3524h */ case  339:  		/* mr R5, R24 */
		/* 820B3524h case  339:*/		regs.R5 = regs.R24;
		/* 820B3524h case  339:*/		return 0x820B3528;
		  /* 820B3528h */ case  340:  		/* mr R4, R29 */
		/* 820B3528h case  340:*/		regs.R4 = regs.R29;
		/* 820B3528h case  340:*/		return 0x820B352C;
		  /* 820B352Ch */ case  341:  		/* mr R3, R30 */
		/* 820B352Ch case  341:*/		regs.R3 = regs.R30;
		/* 820B352Ch case  341:*/		return 0x820B3530;
		  /* 820B3530h */ case  342:  		/* bl -10792 */
		/* 820B3530h case  342:*/		regs.LR = 0x820B3534; return 0x820B0B08;
		/* 820B3530h case  342:*/		return 0x820B3534;
		  /* 820B3534h */ case  343:  		/* or. R31, R3, R3 */
		/* 820B3534h case  343:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3534h case  343:*/		return 0x820B3538;
		  /* 820B3538h */ case  344:  		/* bc 12, CR0_LT, 48 */
		/* 820B3538h case  344:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3538h case  344:*/		return 0x820B353C;
		  /* 820B353Ch */ case  345:  		/* lwz R6, <#[R1 + 500]> */
		/* 820B353Ch case  345:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000001F4) );
		/* 820B353Ch case  345:*/		return 0x820B3540;
		  /* 820B3540h */ case  346:  		/* li R9, 0 */
		/* 820B3540h case  346:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3540h case  346:*/		return 0x820B3544;
		  /* 820B3544h */ case  347:  		/* mr R8, R28 */
		/* 820B3544h case  347:*/		regs.R8 = regs.R28;
		/* 820B3544h case  347:*/		return 0x820B3548;
		  /* 820B3548h */ case  348:  		/* mr R7, R22 */
		/* 820B3548h case  348:*/		regs.R7 = regs.R22;
		/* 820B3548h case  348:*/		return 0x820B354C;
		  /* 820B354Ch */ case  349:  		/* mr R5, R21 */
		/* 820B354Ch case  349:*/		regs.R5 = regs.R21;
		/* 820B354Ch case  349:*/		return 0x820B3550;
		  /* 820B3550h */ case  350:  		/* mr R4, R29 */
		/* 820B3550h case  350:*/		regs.R4 = regs.R29;
		/* 820B3550h case  350:*/		return 0x820B3554;
		  /* 820B3554h */ case  351:  		/* mr R3, R30 */
		/* 820B3554h case  351:*/		regs.R3 = regs.R30;
		/* 820B3554h case  351:*/		return 0x820B3558;
	}
	return 0x820B3558;
} // Block from 820B2FD8h-820B3558h (352 instructions)

//////////////////////////////////////////////////////
// Block at 820B3558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3558);
		  /* 820B3558h */ case    0:  		/* bl -10832 */
		/* 820B3558h case    0:*/		regs.LR = 0x820B355C; return 0x820B0B08;
		/* 820B3558h case    0:*/		return 0x820B355C;
		  /* 820B355Ch */ case    1:  		/* or. R31, R3, R3 */
		/* 820B355Ch case    1:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B355Ch case    1:*/		return 0x820B3560;
		  /* 820B3560h */ case    2:  		/* bc 12, CR0_LT, 8 */
		/* 820B3560h case    2:*/		if ( regs.CR[0].lt ) { return 0x820B3568;  }
		/* 820B3560h case    2:*/		return 0x820B3564;
		  /* 820B3564h */ case    3:  		/* li R31, 0 */
		/* 820B3564h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B3564h case    3:*/		return 0x820B3568;
	}
	return 0x820B3568;
} // Block from 820B3558h-820B3568h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B3568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3568);
		  /* 820B3568h */ case    0:  		/* lis R4, 9345 */
		/* 820B3568h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3568h case    0:*/		return 0x820B356C;
		  /* 820B356Ch */ case    1:  		/* lwz R3, <#[R1 + 80]> */
		/* 820B356Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820B356Ch case    1:*/		return 0x820B3570;
		  /* 820B3570h */ case    2:  		/* bl -176696 */
		/* 820B3570h case    2:*/		regs.LR = 0x820B3574; return 0x82088338;
		/* 820B3570h case    2:*/		return 0x820B3574;
		  /* 820B3574h */ case    3:  		/* mr R3, R31 */
		/* 820B3574h case    3:*/		regs.R3 = regs.R31;
		/* 820B3574h case    3:*/		return 0x820B3578;
		  /* 820B3578h */ case    4:  		/* addi R1, R1, 448 */
		/* 820B3578h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1C0);
		/* 820B3578h case    4:*/		return 0x820B357C;
		  /* 820B357Ch */ case    5:  		/* b -140044 */
		/* 820B357Ch case    5:*/		return 0x82091270;
		/* 820B357Ch case    5:*/		return 0x820B3580;
	}
	return 0x820B3580;
} // Block from 820B3568h-820B3580h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B3580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3580);
		  /* 820B3580h */ case    0:  		/* mfspr R12, LR */
		/* 820B3580h case    0:*/		regs.R12 = regs.LR;
		/* 820B3580h case    0:*/		return 0x820B3584;
		  /* 820B3584h */ case    1:  		/* bl -140120 */
		/* 820B3584h case    1:*/		regs.LR = 0x820B3588; return 0x8209122C;
		/* 820B3584h case    1:*/		return 0x820B3588;
		  /* 820B3588h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820B3588h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820B3588h case    2:*/		return 0x820B358C;
		  /* 820B358Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820B358Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820B358Ch case    3:*/		return 0x820B3590;
		  /* 820B3590h */ case    4:  		/* mr R19, R8 */
		/* 820B3590h case    4:*/		regs.R19 = regs.R8;
		/* 820B3590h case    4:*/		return 0x820B3594;
		  /* 820B3594h */ case    5:  		/* mr R23, R3 */
		/* 820B3594h case    5:*/		regs.R23 = regs.R3;
		/* 820B3594h case    5:*/		return 0x820B3598;
		  /* 820B3598h */ case    6:  		/* mr R22, R4 */
		/* 820B3598h case    6:*/		regs.R22 = regs.R4;
		/* 820B3598h case    6:*/		return 0x820B359C;
		  /* 820B359Ch */ case    7:  		/* mr R17, R5 */
		/* 820B359Ch case    7:*/		regs.R17 = regs.R5;
		/* 820B359Ch case    7:*/		return 0x820B35A0;
		  /* 820B35A0h */ case    8:  		/* mr R21, R6 */
		/* 820B35A0h case    8:*/		regs.R21 = regs.R6;
		/* 820B35A0h case    8:*/		return 0x820B35A4;
		  /* 820B35A4h */ case    9:  		/* lwz R8, <#[R11 + 108]> */
		/* 820B35A4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000006C) );
		/* 820B35A4h case    9:*/		return 0x820B35A8;
		  /* 820B35A8h */ case   10:  		/* mr R20, R7 */
		/* 820B35A8h case   10:*/		regs.R20 = regs.R7;
		/* 820B35A8h case   10:*/		return 0x820B35AC;
		  /* 820B35ACh */ case   11:  		/* mr R31, R9 */
		/* 820B35ACh case   11:*/		regs.R31 = regs.R9;
		/* 820B35ACh case   11:*/		return 0x820B35B0;
		  /* 820B35B0h */ case   12:  		/* rlwinm. R10, R8, 0, 8, 8 */
		/* 820B35B0h case   12:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R10,regs.R8);
		/* 820B35B0h case   12:*/		return 0x820B35B4;
		  /* 820B35B4h */ case   13:  		/* bc 12, CR0_EQ, 336 */
		/* 820B35B4h case   13:*/		if ( regs.CR[0].eq ) { return 0x820B3704;  }
		/* 820B35B4h case   13:*/		return 0x820B35B8;
		  /* 820B35B8h */ case   14:  		/* li R7, 0 */
		/* 820B35B8h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820B35B8h case   14:*/		return 0x820B35BC;
		  /* 820B35BCh */ case   15:  		/* cmplwi CR6, R9, 0 */
		/* 820B35BCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820B35BCh case   15:*/		return 0x820B35C0;
		  /* 820B35C0h */ case   16:  		/* bc 12, CR6_EQ, 72 */
		/* 820B35C0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820B3608;  }
		/* 820B35C0h case   16:*/		return 0x820B35C4;
		  /* 820B35C4h */ case   17:  		/* mr R10, R19 */
		/* 820B35C4h case   17:*/		regs.R10 = regs.R19;
		/* 820B35C4h case   17:*/		return 0x820B35C8;
		  /* 820B35C8h */ case   18:  		/* lwz R9, <#[R10]> */
		/* 820B35C8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820B35C8h case   18:*/		return 0x820B35CC;
		  /* 820B35CCh */ case   19:  		/* lwz R6, <#[R11 + 20]> */
		/* 820B35CCh case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000014) );
		/* 820B35CCh case   19:*/		return 0x820B35D0;
		  /* 820B35D0h */ case   20:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 820B35D0h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 820B35D0h case   20:*/		return 0x820B35D4;
		  /* 820B35D4h */ case   21:  		/* lwzx R6, <#[R5 + R6]> */
		/* 820B35D4h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 820B35D4h case   21:*/		return 0x820B35D8;
		  /* 820B35D8h */ case   22:  		/* lwz R6, <#[R6]> */
		/* 820B35D8h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000000) );
		/* 820B35D8h case   22:*/		return 0x820B35DC;
		  /* 820B35DCh */ case   23:  		/* rlwinm. R6, R6, 0, 31, 31 */
		/* 820B35DCh case   23:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R6,regs.R6);
		/* 820B35DCh case   23:*/		return 0x820B35E0;
		  /* 820B35E0h */ case   24:  		/* bc 12, CR0_EQ, 40 */
		/* 820B35E0h case   24:*/		if ( regs.CR[0].eq ) { return 0x820B3608;  }
		/* 820B35E0h case   24:*/		return 0x820B35E4;
		  /* 820B35E4h */ case   25:  		/* rlwinm. R6, R8, 0, 3, 3 */
		/* 820B35E4h case   25:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R6,regs.R8);
		/* 820B35E4h case   25:*/		return 0x820B35E8;
		  /* 820B35E8h */ case   26:  		/* bc 12, CR0_EQ, 16 */
		/* 820B35E8h case   26:*/		if ( regs.CR[0].eq ) { return 0x820B35F8;  }
		/* 820B35E8h case   26:*/		return 0x820B35EC;
		  /* 820B35ECh */ case   27:  		/* lwz R6, <#[R19]> */
		/* 820B35ECh case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R19 + 0x00000000) );
		/* 820B35ECh case   27:*/		return 0x820B35F0;
		  /* 820B35F0h */ case   28:  		/* cmplw CR6, R9, R6 */
		/* 820B35F0h case   28:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820B35F0h case   28:*/		return 0x820B35F4;
		  /* 820B35F4h */ case   29:  		/* bc 4, CR6_EQ, 20 */
		/* 820B35F4h case   29:*/		if ( !regs.CR[6].eq ) { return 0x820B3608;  }
		/* 820B35F4h case   29:*/		return 0x820B35F8;
	}
	return 0x820B35F8;
} // Block from 820B3580h-820B35F8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820B35F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B35F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B35F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B35F8);
		  /* 820B35F8h */ case    0:  		/* addi R7, R7, 1 */
		/* 820B35F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820B35F8h case    0:*/		return 0x820B35FC;
		  /* 820B35FCh */ case    1:  		/* addi R10, R10, 4 */
		/* 820B35FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820B35FCh case    1:*/		return 0x820B3600;
		  /* 820B3600h */ case    2:  		/* cmplw CR6, R7, R31 */
		/* 820B3600h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R31);
		/* 820B3600h case    2:*/		return 0x820B3604;
		  /* 820B3604h */ case    3:  		/* bc 12, CR6_LT, -60 */
		/* 820B3604h case    3:*/		if ( regs.CR[6].lt ) { return 0x820B35C8;  }
		/* 820B3604h case    3:*/		return 0x820B3608;
	}
	return 0x820B3608;
} // Block from 820B35F8h-820B3608h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B3608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3608);
		  /* 820B3608h */ case    0:  		/* cmplw CR6, R7, R31 */
		/* 820B3608h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R31);
		/* 820B3608h case    0:*/		return 0x820B360C;
		  /* 820B360Ch */ case    1:  		/* bc 4, CR6_EQ, 248 */
		/* 820B360Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B3704;  }
		/* 820B360Ch case    1:*/		return 0x820B3610;
		  /* 820B3610h */ case    2:  		/* lis R4, 9345 */
		/* 820B3610h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3610h case    2:*/		return 0x820B3614;
		  /* 820B3614h */ case    3:  		/* mulli R3, R31, 12 */
		/* 820B3614h case    3:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R31,0xC);
		/* 820B3614h case    3:*/		return 0x820B3618;
		  /* 820B3618h */ case    4:  		/* bl -177176 */
		/* 820B3618h case    4:*/		regs.LR = 0x820B361C; return 0x82088200;
		/* 820B3618h case    4:*/		return 0x820B361C;
		  /* 820B361Ch */ case    5:  		/* or. R18, R3, R3 */
		/* 820B361Ch case    5:*/		cpu::op::or<1>(regs,&regs.R18,regs.R3,regs.R3);
		/* 820B361Ch case    5:*/		return 0x820B3620;
		  /* 820B3620h */ case    6:  		/* bc 12, CR0_EQ, 648 */
		/* 820B3620h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B38A8;  }
		/* 820B3620h case    6:*/		return 0x820B3624;
		  /* 820B3624h */ case    7:  		/* li R10, 3 */
		/* 820B3624h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820B3624h case    7:*/		return 0x820B3628;
		  /* 820B3628h */ case    8:  		/* addi R11, R1, 80 */
		/* 820B3628h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B3628h case    8:*/		return 0x820B362C;
		  /* 820B362Ch */ case    9:  		/* rlwinm R28, R31, 2, 0, 29 */
		/* 820B362Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R31);
		/* 820B362Ch case    9:*/		return 0x820B3630;
		  /* 820B3630h */ case   10:  		/* addi R9, R11, -4 */
		/* 820B3630h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B3630h case   10:*/		return 0x820B3634;
		  /* 820B3634h */ case   11:  		/* mr R11, R18 */
		/* 820B3634h case   11:*/		regs.R11 = regs.R18;
		/* 820B3634h case   11:*/		return 0x820B3638;
		  /* 820B3638h */ case   12:  		/* mtspr CTR, R10 */
		/* 820B3638h case   12:*/		regs.CTR = regs.R10;
		/* 820B3638h case   12:*/		return 0x820B363C;
		  /* 820B363Ch */ case   13:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B363Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B363Ch case   13:*/		return 0x820B3640;
		  /* 820B3640h */ case   14:  		/* add R11, R11, R28 */
		/* 820B3640h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 820B3640h case   14:*/		return 0x820B3644;
		  /* 820B3644h */ case   15:  		/* bc 16, CR0_LT, -8 */
		/* 820B3644h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B363C;  }
		/* 820B3644h case   15:*/		return 0x820B3648;
		  /* 820B3648h */ case   16:  		/* cmplwi CR6, R31, 0 */
		/* 820B3648h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B3648h case   16:*/		return 0x820B364C;
		  /* 820B364Ch */ case   17:  		/* bc 12, CR6_EQ, 52 */
		/* 820B364Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820B3680;  }
		/* 820B364Ch case   17:*/		return 0x820B3650;
		  /* 820B3650h */ case   18:  		/* lwz R11, <#[R1 + 84]> */
		/* 820B3650h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820B3650h case   18:*/		return 0x820B3654;
		  /* 820B3654h */ case   19:  		/* mtspr CTR, R31 */
		/* 820B3654h case   19:*/		regs.CTR = regs.R31;
		/* 820B3654h case   19:*/		return 0x820B3658;
		  /* 820B3658h */ case   20:  		/* lwz R8, <#[R1 + 88]> */
		/* 820B3658h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 820B3658h case   20:*/		return 0x820B365C;
		  /* 820B365Ch */ case   21:  		/* subf R10, R11, R21 */
		/* 820B365Ch case   21:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R21);
		/* 820B365Ch case   21:*/		return 0x820B3660;
	}
	return 0x820B3660;
} // Block from 820B3608h-820B3660h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B3660h
// Function '?EmitATan2@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAI11I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3660);
		  /* 820B3660h */ case    0:  		/* subf R9, R11, R20 */
		/* 820B3660h case    0:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R20);
		/* 820B3660h case    0:*/		return 0x820B3664;
		  /* 820B3664h */ case    1:  		/* subf R8, R11, R8 */
		/* 820B3664h case    1:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 820B3664h case    1:*/		return 0x820B3668;
		  /* 820B3668h */ case    2:  		/* lwzx R7, <#[R10 + R11]> */
		/* 820B3668h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B3668h case    2:*/		return 0x820B366C;
		  /* 820B366Ch */ case    3:  		/* stw R7, <#[R11]> */
		/* 820B366Ch case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820B366Ch case    3:*/		return 0x820B3670;
		  /* 820B3670h */ case    4:  		/* lwzx R7, <#[R11 + R9]> */
		/* 820B3670h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820B3670h case    4:*/		return 0x820B3674;
		  /* 820B3674h */ case    5:  		/* stwx R7, <#[R11 + R8]> */
		/* 820B3674h case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820B3674h case    5:*/		return 0x820B3678;
		  /* 820B3678h */ case    6:  		/* addi R11, R11, 4 */
		/* 820B3678h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B3678h case    6:*/		return 0x820B367C;
		  /* 820B367Ch */ case    7:  		/* bc 16, CR0_LT, -20 */
		/* 820B367Ch case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3668;  }
		/* 820B367Ch case    7:*/		return 0x820B3680;
	}
	return 0x820B3680;
} // Block from 820B3660h-820B3680h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B3680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3680);
		  /* 820B3680h */ case    0:  		/* lwz R29, <#[R1 + 80]> */
		/* 820B3680h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3680h case    0:*/		return 0x820B3684;
		  /* 820B3684h */ case    1:  		/* li R11, -1 */
		/* 820B3684h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820B3684h case    1:*/		return 0x820B3688;
		  /* 820B3688h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820B3688h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B3688h case    2:*/		return 0x820B368C;
		  /* 820B368Ch */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 820B368Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820B36C8;  }
		/* 820B368Ch case    3:*/		return 0x820B3690;
		  /* 820B3690h */ case    4:  		/* addi R10, R29, -4 */
		/* 820B3690h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFFFFC);
		/* 820B3690h case    4:*/		return 0x820B3694;
		  /* 820B3694h */ case    5:  		/* cmplwi CR0, R31, 0 */
		/* 820B3694h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B3694h case    5:*/		return 0x820B3698;
		  /* 820B3698h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3698h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B36A8;  }
		/* 820B3698h case    6:*/		return 0x820B369C;
		  /* 820B369Ch */ case    7:  		/* mtspr CTR, R31 */
		/* 820B369Ch case    7:*/		regs.CTR = regs.R31;
		/* 820B369Ch case    7:*/		return 0x820B36A0;
		  /* 820B36A0h */ case    8:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B36A0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B36A0h case    8:*/		return 0x820B36A4;
		  /* 820B36A4h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820B36A4h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B36A0;  }
		/* 820B36A4h case    9:*/		return 0x820B36A8;
	}
	return 0x820B36A8;
} // Block from 820B3680h-820B36A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B36A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B36A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B36A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B36A8);
		  /* 820B36A8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820B36A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B36A8h case    0:*/		return 0x820B36AC;
		  /* 820B36ACh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820B36ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820B36C8;  }
		/* 820B36ACh case    1:*/		return 0x820B36B0;
		  /* 820B36B0h */ case    2:  		/* addi R10, R17, -4 */
		/* 820B36B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R17,0xFFFFFFFC);
		/* 820B36B0h case    2:*/		return 0x820B36B4;
		  /* 820B36B4h */ case    3:  		/* cmplwi CR0, R31, 0 */
		/* 820B36B4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B36B4h case    3:*/		return 0x820B36B8;
		  /* 820B36B8h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820B36B8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820B36C8;  }
		/* 820B36B8h case    4:*/		return 0x820B36BC;
		  /* 820B36BCh */ case    5:  		/* mtspr CTR, R31 */
		/* 820B36BCh case    5:*/		regs.CTR = regs.R31;
		/* 820B36BCh case    5:*/		return 0x820B36C0;
		  /* 820B36C0h */ case    6:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B36C0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B36C0h case    6:*/		return 0x820B36C4;
		  /* 820B36C4h */ case    7:  		/* bc 16, CR0_LT, -4 */
		/* 820B36C4h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B36C0;  }
		/* 820B36C4h case    7:*/		return 0x820B36C8;
	}
	return 0x820B36C8;
} // Block from 820B36A8h-820B36C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B36C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B36C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B36C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B36C8);
		  /* 820B36C8h */ case    0:  		/* rlwinm R30, R31, 0, 12, 31 */
		/* 820B36C8h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R31);
		/* 820B36C8h case    0:*/		return 0x820B36CC;
		  /* 820B36CCh */ case    1:  		/* li R9, 26 */
		/* 820B36CCh case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1A);
		/* 820B36CCh case    1:*/		return 0x820B36D0;
		  /* 820B36D0h */ case    2:  		/* li R8, 0 */
		/* 820B36D0h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B36D0h case    2:*/		return 0x820B36D4;
		  /* 820B36D4h */ case    3:  		/* mr R7, R19 */
		/* 820B36D4h case    3:*/		regs.R7 = regs.R19;
		/* 820B36D4h case    3:*/		return 0x820B36D8;
		  /* 820B36D8h */ case    4:  		/* mr R6, R29 */
		/* 820B36D8h case    4:*/		regs.R6 = regs.R29;
		/* 820B36D8h case    4:*/		return 0x820B36DC;
		  /* 820B36DCh */ case    5:  		/* oris R5, R30, 4112 */
		/* 820B36DCh case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820B36DCh case    5:*/		return 0x820B36E0;
		  /* 820B36E0h */ case    6:  		/* mr R4, R22 */
		/* 820B36E0h case    6:*/		regs.R4 = regs.R22;
		/* 820B36E0h case    6:*/		return 0x820B36E4;
		  /* 820B36E4h */ case    7:  		/* mr R3, R23 */
		/* 820B36E4h case    7:*/		regs.R3 = regs.R23;
		/* 820B36E4h case    7:*/		return 0x820B36E8;
		  /* 820B36E8h */ case    8:  		/* bl -11232 */
		/* 820B36E8h case    8:*/		regs.LR = 0x820B36EC; return 0x820B0B08;
		/* 820B36E8h case    8:*/		return 0x820B36EC;
		  /* 820B36ECh */ case    9:  		/* or. R31, R3, R3 */
		/* 820B36ECh case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B36ECh case    9:*/		return 0x820B36F0;
		  /* 820B36F0h */ case   10:  		/* bc 12, CR0_LT, 400 */
		/* 820B36F0h case   10:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B36F0h case   10:*/		return 0x820B36F4;
		  /* 820B36F4h */ case   11:  		/* add R8, R28, R18 */
		/* 820B36F4h case   11:*/		cpu::op::add<0>(regs,&regs.R8,regs.R28,regs.R18);
		/* 820B36F4h case   11:*/		return 0x820B36F8;
		  /* 820B36F8h */ case   12:  		/* mr R7, R29 */
		/* 820B36F8h case   12:*/		regs.R7 = regs.R29;
		/* 820B36F8h case   12:*/		return 0x820B36FC;
		  /* 820B36FCh */ case   13:  		/* oris R5, R30, 12288 */
		/* 820B36FCh case   13:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x3000);
		/* 820B36FCh case   13:*/		return 0x820B3700;
		  /* 820B3700h */ case   14:  		/* b 352 */
		/* 820B3700h case   14:*/		return 0x820B3860;
		/* 820B3700h case   14:*/		return 0x820B3704;
	}
	return 0x820B3704;
} // Block from 820B36C8h-820B3704h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B3704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3704);
		  /* 820B3704h */ case    0:  		/* rlwinm. R11, R8, 0, 26, 26 */
		/* 820B3704h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R8);
		/* 820B3704h case    0:*/		return 0x820B3708;
		  /* 820B3708h */ case    1:  		/* lis R4, 9345 */
		/* 820B3708h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3708h case    1:*/		return 0x820B370C;
		  /* 820B370Ch */ case    2:  		/* bc 4, CR0_EQ, 396 */
		/* 820B370Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B3898;  }
		/* 820B370Ch case    2:*/		return 0x820B3710;
		  /* 820B3710h */ case    3:  		/* mulli R3, R31, 12 */
		/* 820B3710h case    3:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R31,0xC);
		/* 820B3710h case    3:*/		return 0x820B3714;
		  /* 820B3714h */ case    4:  		/* bl -177428 */
		/* 820B3714h case    4:*/		regs.LR = 0x820B3718; return 0x82088200;
		/* 820B3714h case    4:*/		return 0x820B3718;
		  /* 820B3718h */ case    5:  		/* or. R18, R3, R3 */
		/* 820B3718h case    5:*/		cpu::op::or<1>(regs,&regs.R18,regs.R3,regs.R3);
		/* 820B3718h case    5:*/		return 0x820B371C;
		  /* 820B371Ch */ case    6:  		/* bc 12, CR0_EQ, 396 */
		/* 820B371Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820B38A8;  }
		/* 820B371Ch case    6:*/		return 0x820B3720;
		  /* 820B3720h */ case    7:  		/* li R10, 3 */
		/* 820B3720h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820B3720h case    7:*/		return 0x820B3724;
		  /* 820B3724h */ case    8:  		/* addi R11, R1, 80 */
		/* 820B3724h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B3724h case    8:*/		return 0x820B3728;
		  /* 820B3728h */ case    9:  		/* rlwinm R8, R31, 2, 0, 29 */
		/* 820B3728h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R31);
		/* 820B3728h case    9:*/		return 0x820B372C;
		  /* 820B372Ch */ case   10:  		/* addi R9, R11, -4 */
		/* 820B372Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B372Ch case   10:*/		return 0x820B3730;
		  /* 820B3730h */ case   11:  		/* mr R11, R18 */
		/* 820B3730h case   11:*/		regs.R11 = regs.R18;
		/* 820B3730h case   11:*/		return 0x820B3734;
		  /* 820B3734h */ case   12:  		/* mtspr CTR, R10 */
		/* 820B3734h case   12:*/		regs.CTR = regs.R10;
		/* 820B3734h case   12:*/		return 0x820B3738;
		  /* 820B3738h */ case   13:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B3738h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B3738h case   13:*/		return 0x820B373C;
		  /* 820B373Ch */ case   14:  		/* add R11, R8, R11 */
		/* 820B373Ch case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820B373Ch case   14:*/		return 0x820B3740;
		  /* 820B3740h */ case   15:  		/* bc 16, CR0_LT, -8 */
		/* 820B3740h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3738;  }
		/* 820B3740h case   15:*/		return 0x820B3744;
		  /* 820B3744h */ case   16:  		/* lwz R26, <#[R1 + 80]> */
		/* 820B3744h case   16:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3744h case   16:*/		return 0x820B3748;
		  /* 820B3748h */ case   17:  		/* li R11, -1 */
		/* 820B3748h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820B3748h case   17:*/		return 0x820B374C;
		  /* 820B374Ch */ case   18:  		/* cmplwi CR6, R31, 0 */
		/* 820B374Ch case   18:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B374Ch case   18:*/		return 0x820B3750;
		  /* 820B3750h */ case   19:  		/* bc 12, CR6_EQ, 28 */
		/* 820B3750h case   19:*/		if ( regs.CR[6].eq ) { return 0x820B376C;  }
		/* 820B3750h case   19:*/		return 0x820B3754;
		  /* 820B3754h */ case   20:  		/* addi R10, R26, -4 */
		/* 820B3754h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0xFFFFFFFC);
		/* 820B3754h case   20:*/		return 0x820B3758;
		  /* 820B3758h */ case   21:  		/* cmplwi CR0, R31, 0 */
		/* 820B3758h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B3758h case   21:*/		return 0x820B375C;
		  /* 820B375Ch */ case   22:  		/* bc 12, CR0_EQ, 16 */
		/* 820B375Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x820B376C;  }
		/* 820B375Ch case   22:*/		return 0x820B3760;
		  /* 820B3760h */ case   23:  		/* mtspr CTR, R31 */
		/* 820B3760h case   23:*/		regs.CTR = regs.R31;
		/* 820B3760h case   23:*/		return 0x820B3764;
		  /* 820B3764h */ case   24:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B3764h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B3764h case   24:*/		return 0x820B3768;
		  /* 820B3768h */ case   25:  		/* bc 16, CR0_LT, -4 */
		/* 820B3768h case   25:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3764;  }
		/* 820B3768h case   25:*/		return 0x820B376C;
	}
	return 0x820B376C;
} // Block from 820B3704h-820B376Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 820B376Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B376C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B376C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B376C);
		  /* 820B376Ch */ case    0:  		/* lwz R27, <#[R1 + 84]> */
		/* 820B376Ch case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 820B376Ch case    0:*/		return 0x820B3770;
		  /* 820B3770h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820B3770h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B3770h case    1:*/		return 0x820B3774;
		  /* 820B3774h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820B3774h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B3790;  }
		/* 820B3774h case    2:*/		return 0x820B3778;
		  /* 820B3778h */ case    3:  		/* addi R10, R27, -4 */
		/* 820B3778h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFC);
		/* 820B3778h case    3:*/		return 0x820B377C;
		  /* 820B377Ch */ case    4:  		/* cmplwi CR0, R31, 0 */
		/* 820B377Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B377Ch case    4:*/		return 0x820B3780;
		  /* 820B3780h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3780h case    5:*/		if ( regs.CR[0].eq ) { return 0x820B3790;  }
		/* 820B3780h case    5:*/		return 0x820B3784;
		  /* 820B3784h */ case    6:  		/* mtspr CTR, R31 */
		/* 820B3784h case    6:*/		regs.CTR = regs.R31;
		/* 820B3784h case    6:*/		return 0x820B3788;
		  /* 820B3788h */ case    7:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B3788h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B3788h case    7:*/		return 0x820B378C;
		  /* 820B378Ch */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B378Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3788;  }
		/* 820B378Ch case    8:*/		return 0x820B3790;
	}
	return 0x820B3790;
} // Block from 820B376Ch-820B3790h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B3790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3790);
		  /* 820B3790h */ case    0:  		/* lwz R28, <#[R1 + 88]> */
		/* 820B3790h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000058) );
		/* 820B3790h case    0:*/		return 0x820B3794;
		  /* 820B3794h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820B3794h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B3794h case    1:*/		return 0x820B3798;
		  /* 820B3798h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820B3798h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B37D4;  }
		/* 820B3798h case    2:*/		return 0x820B379C;
		  /* 820B379Ch */ case    3:  		/* addi R10, R28, -4 */
		/* 820B379Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 820B379Ch case    3:*/		return 0x820B37A0;
		  /* 820B37A0h */ case    4:  		/* cmplwi CR0, R31, 0 */
		/* 820B37A0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B37A0h case    4:*/		return 0x820B37A4;
		  /* 820B37A4h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B37A4h case    5:*/		if ( regs.CR[0].eq ) { return 0x820B37B4;  }
		/* 820B37A4h case    5:*/		return 0x820B37A8;
		  /* 820B37A8h */ case    6:  		/* mtspr CTR, R31 */
		/* 820B37A8h case    6:*/		regs.CTR = regs.R31;
		/* 820B37A8h case    6:*/		return 0x820B37AC;
		  /* 820B37ACh */ case    7:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B37ACh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B37ACh case    7:*/		return 0x820B37B0;
		  /* 820B37B0h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B37B0h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B37AC;  }
		/* 820B37B0h case    8:*/		return 0x820B37B4;
	}
	return 0x820B37B4;
} // Block from 820B3790h-820B37B4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B37B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B37B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B37B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B37B4);
		  /* 820B37B4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820B37B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B37B4h case    0:*/		return 0x820B37B8;
		  /* 820B37B8h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820B37B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B37D4;  }
		/* 820B37B8h case    1:*/		return 0x820B37BC;
		  /* 820B37BCh */ case    2:  		/* addi R10, R17, -4 */
		/* 820B37BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R17,0xFFFFFFFC);
		/* 820B37BCh case    2:*/		return 0x820B37C0;
		  /* 820B37C0h */ case    3:  		/* cmplwi CR0, R31, 0 */
		/* 820B37C0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B37C0h case    3:*/		return 0x820B37C4;
		  /* 820B37C4h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820B37C4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820B37D4;  }
		/* 820B37C4h case    4:*/		return 0x820B37C8;
		  /* 820B37C8h */ case    5:  		/* mtspr CTR, R31 */
		/* 820B37C8h case    5:*/		regs.CTR = regs.R31;
		/* 820B37C8h case    5:*/		return 0x820B37CC;
		  /* 820B37CCh */ case    6:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B37CCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B37CCh case    6:*/		return 0x820B37D0;
		  /* 820B37D0h */ case    7:  		/* bc 16, CR0_LT, -4 */
		/* 820B37D0h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B37CC;  }
		/* 820B37D0h case    7:*/		return 0x820B37D4;
	}
	return 0x820B37D4;
} // Block from 820B37B4h-820B37D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B37D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B37D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B37D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B37D4);
		  /* 820B37D4h */ case    0:  		/* rlwinm R30, R31, 0, 12, 31 */
		/* 820B37D4h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R31);
		/* 820B37D4h case    0:*/		return 0x820B37D8;
		  /* 820B37D8h */ case    1:  		/* li R9, 0 */
		/* 820B37D8h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B37D8h case    1:*/		return 0x820B37DC;
		  /* 820B37DCh */ case    2:  		/* li R8, 0 */
		/* 820B37DCh case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B37DCh case    2:*/		return 0x820B37E0;
		  /* 820B37E0h */ case    3:  		/* mr R7, R21 */
		/* 820B37E0h case    3:*/		regs.R7 = regs.R21;
		/* 820B37E0h case    3:*/		return 0x820B37E4;
		  /* 820B37E4h */ case    4:  		/* mr R6, R26 */
		/* 820B37E4h case    4:*/		regs.R6 = regs.R26;
		/* 820B37E4h case    4:*/		return 0x820B37E8;
		  /* 820B37E8h */ case    5:  		/* oris R5, R30, 4112 */
		/* 820B37E8h case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820B37E8h case    5:*/		return 0x820B37EC;
		  /* 820B37ECh */ case    6:  		/* mr R4, R22 */
		/* 820B37ECh case    6:*/		regs.R4 = regs.R22;
		/* 820B37ECh case    6:*/		return 0x820B37F0;
		  /* 820B37F0h */ case    7:  		/* mr R3, R23 */
		/* 820B37F0h case    7:*/		regs.R3 = regs.R23;
		/* 820B37F0h case    7:*/		return 0x820B37F4;
		  /* 820B37F4h */ case    8:  		/* bl -11500 */
		/* 820B37F4h case    8:*/		regs.LR = 0x820B37F8; return 0x820B0B08;
		/* 820B37F4h case    8:*/		return 0x820B37F8;
		  /* 820B37F8h */ case    9:  		/* or. R31, R3, R3 */
		/* 820B37F8h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B37F8h case    9:*/		return 0x820B37FC;
		  /* 820B37FCh */ case   10:  		/* bc 12, CR0_LT, 132 */
		/* 820B37FCh case   10:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B37FCh case   10:*/		return 0x820B3800;
		  /* 820B3800h */ case   11:  		/* oris R29, R30, 8256 */
		/* 820B3800h case   11:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R30,0x2040);
		/* 820B3800h case   11:*/		return 0x820B3804;
		  /* 820B3804h */ case   12:  		/* li R9, 0 */
		/* 820B3804h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3804h case   12:*/		return 0x820B3808;
		  /* 820B3808h */ case   13:  		/* mr R8, R26 */
		/* 820B3808h case   13:*/		regs.R8 = regs.R26;
		/* 820B3808h case   13:*/		return 0x820B380C;
		  /* 820B380Ch */ case   14:  		/* mr R7, R20 */
		/* 820B380Ch case   14:*/		regs.R7 = regs.R20;
		/* 820B380Ch case   14:*/		return 0x820B3810;
		  /* 820B3810h */ case   15:  		/* mr R6, R27 */
		/* 820B3810h case   15:*/		regs.R6 = regs.R27;
		/* 820B3810h case   15:*/		return 0x820B3814;
		  /* 820B3814h */ case   16:  		/* mr R5, R29 */
		/* 820B3814h case   16:*/		regs.R5 = regs.R29;
		/* 820B3814h case   16:*/		return 0x820B3818;
		  /* 820B3818h */ case   17:  		/* mr R4, R22 */
		/* 820B3818h case   17:*/		regs.R4 = regs.R22;
		/* 820B3818h case   17:*/		return 0x820B381C;
		  /* 820B381Ch */ case   18:  		/* mr R3, R23 */
		/* 820B381Ch case   18:*/		regs.R3 = regs.R23;
		/* 820B381Ch case   18:*/		return 0x820B3820;
		  /* 820B3820h */ case   19:  		/* bl -11544 */
		/* 820B3820h case   19:*/		regs.LR = 0x820B3824; return 0x820B0B08;
		/* 820B3820h case   19:*/		return 0x820B3824;
		  /* 820B3824h */ case   20:  		/* or. R31, R3, R3 */
		/* 820B3824h case   20:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3824h case   20:*/		return 0x820B3828;
		  /* 820B3828h */ case   21:  		/* bc 12, CR0_LT, 88 */
		/* 820B3828h case   21:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B3828h case   21:*/		return 0x820B382C;
		  /* 820B382Ch */ case   22:  		/* li R9, 0 */
		/* 820B382Ch case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B382Ch case   22:*/		return 0x820B3830;
		  /* 820B3830h */ case   23:  		/* mr R8, R27 */
		/* 820B3830h case   23:*/		regs.R8 = regs.R27;
		/* 820B3830h case   23:*/		return 0x820B3834;
		  /* 820B3834h */ case   24:  		/* mr R7, R19 */
		/* 820B3834h case   24:*/		regs.R7 = regs.R19;
		/* 820B3834h case   24:*/		return 0x820B3838;
		  /* 820B3838h */ case   25:  		/* mr R6, R28 */
		/* 820B3838h case   25:*/		regs.R6 = regs.R28;
		/* 820B3838h case   25:*/		return 0x820B383C;
		  /* 820B383Ch */ case   26:  		/* oris R5, R30, 8272 */
		/* 820B383Ch case   26:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2050);
		/* 820B383Ch case   26:*/		return 0x820B3840;
		  /* 820B3840h */ case   27:  		/* mr R4, R22 */
		/* 820B3840h case   27:*/		regs.R4 = regs.R22;
		/* 820B3840h case   27:*/		return 0x820B3844;
		  /* 820B3844h */ case   28:  		/* mr R3, R23 */
		/* 820B3844h case   28:*/		regs.R3 = regs.R23;
		/* 820B3844h case   28:*/		return 0x820B3848;
		  /* 820B3848h */ case   29:  		/* bl -11584 */
		/* 820B3848h case   29:*/		regs.LR = 0x820B384C; return 0x820B0B08;
		/* 820B3848h case   29:*/		return 0x820B384C;
		  /* 820B384Ch */ case   30:  		/* or. R31, R3, R3 */
		/* 820B384Ch case   30:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B384Ch case   30:*/		return 0x820B3850;
		  /* 820B3850h */ case   31:  		/* bc 12, CR0_LT, 48 */
		/* 820B3850h case   31:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B3850h case   31:*/		return 0x820B3854;
		  /* 820B3854h */ case   32:  		/* mr R7, R21 */
		/* 820B3854h case   32:*/		regs.R7 = regs.R21;
		/* 820B3854h case   32:*/		return 0x820B3858;
		  /* 820B3858h */ case   33:  		/* mr R5, R29 */
		/* 820B3858h case   33:*/		regs.R5 = regs.R29;
		/* 820B3858h case   33:*/		return 0x820B385C;
		  /* 820B385Ch */ case   34:  		/* mr R8, R28 */
		/* 820B385Ch case   34:*/		regs.R8 = regs.R28;
		/* 820B385Ch case   34:*/		return 0x820B3860;
	}
	return 0x820B3860;
} // Block from 820B37D4h-820B3860h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820B3860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3860);
		  /* 820B3860h */ case    0:  		/* li R9, 0 */
		/* 820B3860h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3860h case    0:*/		return 0x820B3864;
		  /* 820B3864h */ case    1:  		/* mr R6, R17 */
		/* 820B3864h case    1:*/		regs.R6 = regs.R17;
		/* 820B3864h case    1:*/		return 0x820B3868;
		  /* 820B3868h */ case    2:  		/* mr R4, R22 */
		/* 820B3868h case    2:*/		regs.R4 = regs.R22;
		/* 820B3868h case    2:*/		return 0x820B386C;
		  /* 820B386Ch */ case    3:  		/* mr R3, R23 */
		/* 820B386Ch case    3:*/		regs.R3 = regs.R23;
		/* 820B386Ch case    3:*/		return 0x820B3870;
		  /* 820B3870h */ case    4:  		/* bl -11624 */
		/* 820B3870h case    4:*/		regs.LR = 0x820B3874; return 0x820B0B08;
		/* 820B3870h case    4:*/		return 0x820B3874;
		  /* 820B3874h */ case    5:  		/* or. R31, R3, R3 */
		/* 820B3874h case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3874h case    5:*/		return 0x820B3878;
		  /* 820B3878h */ case    6:  		/* bc 12, CR0_LT, 8 */
		/* 820B3878h case    6:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B3878h case    6:*/		return 0x820B387C;
		  /* 820B387Ch */ case    7:  		/* li R31, 0 */
		/* 820B387Ch case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B387Ch case    7:*/		return 0x820B3880;
	}
	return 0x820B3880;
} // Block from 820B3860h-820B3880h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B3880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3880);
		  /* 820B3880h */ case    0:  		/* lis R4, 9345 */
		/* 820B3880h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3880h case    0:*/		return 0x820B3884;
		  /* 820B3884h */ case    1:  		/* mr R3, R18 */
		/* 820B3884h case    1:*/		regs.R3 = regs.R18;
		/* 820B3884h case    1:*/		return 0x820B3888;
		  /* 820B3888h */ case    2:  		/* bl -177488 */
		/* 820B3888h case    2:*/		regs.LR = 0x820B388C; return 0x82088338;
		/* 820B3888h case    2:*/		return 0x820B388C;
		  /* 820B388Ch */ case    3:  		/* mr R3, R31 */
		/* 820B388Ch case    3:*/		regs.R3 = regs.R31;
		/* 820B388Ch case    3:*/		return 0x820B3890;
		  /* 820B3890h */ case    4:  		/* addi R1, R1, 240 */
		/* 820B3890h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820B3890h case    4:*/		return 0x820B3894;
		  /* 820B3894h */ case    5:  		/* b -140824 */
		/* 820B3894h case    5:*/		return 0x8209127C;
		/* 820B3894h case    5:*/		return 0x820B3898;
	}
	return 0x820B3898;
} // Block from 820B3880h-820B3898h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B3898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3898);
		  /* 820B3898h */ case    0:  		/* mulli R3, R31, 20 */
		/* 820B3898h case    0:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R31,0x14);
		/* 820B3898h case    0:*/		return 0x820B389C;
		  /* 820B389Ch */ case    1:  		/* bl -177820 */
		/* 820B389Ch case    1:*/		regs.LR = 0x820B38A0; return 0x82088200;
		/* 820B389Ch case    1:*/		return 0x820B38A0;
		  /* 820B38A0h */ case    2:  		/* or. R18, R3, R3 */
		/* 820B38A0h case    2:*/		cpu::op::or<1>(regs,&regs.R18,regs.R3,regs.R3);
		/* 820B38A0h case    2:*/		return 0x820B38A4;
		  /* 820B38A4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 820B38A4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820B38B4;  }
		/* 820B38A4h case    3:*/		return 0x820B38A8;
	}
	return 0x820B38A8;
} // Block from 820B3898h-820B38A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B38A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B38A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B38A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B38A8);
		  /* 820B38A8h */ case    0:  		/* lis R31, -32761 */
		/* 820B38A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820B38A8h case    0:*/		return 0x820B38AC;
		  /* 820B38ACh */ case    1:  		/* ori R31, R31, 14 */
		/* 820B38ACh case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820B38ACh case    1:*/		return 0x820B38B0;
		  /* 820B38B0h */ case    2:  		/* b -48 */
		/* 820B38B0h case    2:*/		return 0x820B3880;
		/* 820B38B0h case    2:*/		return 0x820B38B4;
	}
	return 0x820B38B4;
} // Block from 820B38A8h-820B38B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B38B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B38B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B38B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B38B4);
		  /* 820B38B4h */ case    0:  		/* li R10, 5 */
		/* 820B38B4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 820B38B4h case    0:*/		return 0x820B38B8;
		  /* 820B38B8h */ case    1:  		/* addi R11, R1, 80 */
		/* 820B38B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B38B8h case    1:*/		return 0x820B38BC;
		  /* 820B38BCh */ case    2:  		/* rlwinm R8, R31, 2, 0, 29 */
		/* 820B38BCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R31);
		/* 820B38BCh case    2:*/		return 0x820B38C0;
		  /* 820B38C0h */ case    3:  		/* addi R9, R11, -4 */
		/* 820B38C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B38C0h case    3:*/		return 0x820B38C4;
		  /* 820B38C4h */ case    4:  		/* mr R11, R18 */
		/* 820B38C4h case    4:*/		regs.R11 = regs.R18;
		/* 820B38C4h case    4:*/		return 0x820B38C8;
		  /* 820B38C8h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B38C8h case    5:*/		regs.CTR = regs.R10;
		/* 820B38C8h case    5:*/		return 0x820B38CC;
		  /* 820B38CCh */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B38CCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B38CCh case    6:*/		return 0x820B38D0;
		  /* 820B38D0h */ case    7:  		/* add R11, R8, R11 */
		/* 820B38D0h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820B38D0h case    7:*/		return 0x820B38D4;
		  /* 820B38D4h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B38D4h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B38CC;  }
		/* 820B38D4h case    8:*/		return 0x820B38D8;
		  /* 820B38D8h */ case    9:  		/* lwz R24, <#[R1 + 96]> */
		/* 820B38D8h case    9:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000060) );
		/* 820B38D8h case    9:*/		return 0x820B38DC;
		  /* 820B38DCh */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820B38DCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B38DCh case   10:*/		return 0x820B38E0;
		  /* 820B38E0h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 820B38E0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820B38F8;  }
		/* 820B38E0h case   11:*/		return 0x820B38E4;
		  /* 820B38E4h */ case   12:  		/* mtspr CTR, R31 */
		/* 820B38E4h case   12:*/		regs.CTR = regs.R31;
		/* 820B38E4h case   12:*/		return 0x820B38E8;
		  /* 820B38E8h */ case   13:  		/* addi R11, R24, -4 */
		/* 820B38E8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xFFFFFFFC);
		/* 820B38E8h case   13:*/		return 0x820B38EC;
		  /* 820B38ECh */ case   14:  		/* lwz R10, <#[R23 + 32]> */
		/* 820B38ECh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000020) );
		/* 820B38ECh case   14:*/		return 0x820B38F0;
		  /* 820B38F0h */ case   15:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B38F0h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B38F0h case   15:*/		return 0x820B38F4;
		  /* 820B38F4h */ case   16:  		/* bc 16, CR0_LT, -8 */
		/* 820B38F4h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B38EC;  }
		/* 820B38F4h case   16:*/		return 0x820B38F8;
	}
	return 0x820B38F8;
} // Block from 820B38B4h-820B38F8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B38F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B38F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B38F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B38F8);
		  /* 820B38F8h */ case    0:  		/* lwz R26, <#[R1 + 80]> */
		/* 820B38F8h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 820B38F8h case    0:*/		return 0x820B38FC;
		  /* 820B38FCh */ case    1:  		/* li R11, -1 */
		/* 820B38FCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820B38FCh case    1:*/		return 0x820B3900;
		  /* 820B3900h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820B3900h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B3900h case    2:*/		return 0x820B3904;
		  /* 820B3904h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820B3904h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B3920;  }
		/* 820B3904h case    3:*/		return 0x820B3908;
		  /* 820B3908h */ case    4:  		/* addi R10, R26, -4 */
		/* 820B3908h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0xFFFFFFFC);
		/* 820B3908h case    4:*/		return 0x820B390C;
		  /* 820B390Ch */ case    5:  		/* cmplwi CR0, R31, 0 */
		/* 820B390Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B390Ch case    5:*/		return 0x820B3910;
		  /* 820B3910h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3910h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B3920;  }
		/* 820B3910h case    6:*/		return 0x820B3914;
		  /* 820B3914h */ case    7:  		/* mtspr CTR, R31 */
		/* 820B3914h case    7:*/		regs.CTR = regs.R31;
		/* 820B3914h case    7:*/		return 0x820B3918;
		  /* 820B3918h */ case    8:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B3918h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B3918h case    8:*/		return 0x820B391C;
		  /* 820B391Ch */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820B391Ch case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3918;  }
		/* 820B391Ch case    9:*/		return 0x820B3920;
	}
	return 0x820B3920;
} // Block from 820B38F8h-820B3920h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B3920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3920);
		  /* 820B3920h */ case    0:  		/* lwz R27, <#[R1 + 84]> */
		/* 820B3920h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 820B3920h case    0:*/		return 0x820B3924;
		  /* 820B3924h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820B3924h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B3924h case    1:*/		return 0x820B3928;
		  /* 820B3928h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820B3928h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B3944;  }
		/* 820B3928h case    2:*/		return 0x820B392C;
		  /* 820B392Ch */ case    3:  		/* addi R10, R27, -4 */
		/* 820B392Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFC);
		/* 820B392Ch case    3:*/		return 0x820B3930;
		  /* 820B3930h */ case    4:  		/* cmplwi CR0, R31, 0 */
		/* 820B3930h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B3930h case    4:*/		return 0x820B3934;
		  /* 820B3934h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3934h case    5:*/		if ( regs.CR[0].eq ) { return 0x820B3944;  }
		/* 820B3934h case    5:*/		return 0x820B3938;
		  /* 820B3938h */ case    6:  		/* mtspr CTR, R31 */
		/* 820B3938h case    6:*/		regs.CTR = regs.R31;
		/* 820B3938h case    6:*/		return 0x820B393C;
		  /* 820B393Ch */ case    7:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B393Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B393Ch case    7:*/		return 0x820B3940;
		  /* 820B3940h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B3940h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B393C;  }
		/* 820B3940h case    8:*/		return 0x820B3944;
	}
	return 0x820B3944;
} // Block from 820B3920h-820B3944h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B3944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3944);
		  /* 820B3944h */ case    0:  		/* lwz R25, <#[R1 + 88]> */
		/* 820B3944h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000058) );
		/* 820B3944h case    0:*/		return 0x820B3948;
		  /* 820B3948h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820B3948h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B3948h case    1:*/		return 0x820B394C;
		  /* 820B394Ch */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820B394Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820B3968;  }
		/* 820B394Ch case    2:*/		return 0x820B3950;
		  /* 820B3950h */ case    3:  		/* addi R10, R25, -4 */
		/* 820B3950h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0xFFFFFFFC);
		/* 820B3950h case    3:*/		return 0x820B3954;
		  /* 820B3954h */ case    4:  		/* cmplwi CR0, R31, 0 */
		/* 820B3954h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B3954h case    4:*/		return 0x820B3958;
		  /* 820B3958h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3958h case    5:*/		if ( regs.CR[0].eq ) { return 0x820B3968;  }
		/* 820B3958h case    5:*/		return 0x820B395C;
		  /* 820B395Ch */ case    6:  		/* mtspr CTR, R31 */
		/* 820B395Ch case    6:*/		regs.CTR = regs.R31;
		/* 820B395Ch case    6:*/		return 0x820B3960;
		  /* 820B3960h */ case    7:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B3960h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B3960h case    7:*/		return 0x820B3964;
		  /* 820B3964h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B3964h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3960;  }
		/* 820B3964h case    8:*/		return 0x820B3968;
	}
	return 0x820B3968;
} // Block from 820B3944h-820B3968h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B3968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3968);
		  /* 820B3968h */ case    0:  		/* lwz R28, <#[R1 + 92]> */
		/* 820B3968h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B3968h case    0:*/		return 0x820B396C;
		  /* 820B396Ch */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820B396Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B396Ch case    1:*/		return 0x820B3970;
		  /* 820B3970h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 820B3970h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B39AC;  }
		/* 820B3970h case    2:*/		return 0x820B3974;
		  /* 820B3974h */ case    3:  		/* addi R10, R28, -4 */
		/* 820B3974h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 820B3974h case    3:*/		return 0x820B3978;
		  /* 820B3978h */ case    4:  		/* cmplwi CR0, R31, 0 */
		/* 820B3978h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B3978h case    4:*/		return 0x820B397C;
		  /* 820B397Ch */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B397Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820B398C;  }
		/* 820B397Ch case    5:*/		return 0x820B3980;
		  /* 820B3980h */ case    6:  		/* mtspr CTR, R31 */
		/* 820B3980h case    6:*/		regs.CTR = regs.R31;
		/* 820B3980h case    6:*/		return 0x820B3984;
		  /* 820B3984h */ case    7:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B3984h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B3984h case    7:*/		return 0x820B3988;
		  /* 820B3988h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B3988h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3984;  }
		/* 820B3988h case    8:*/		return 0x820B398C;
	}
	return 0x820B398C;
} // Block from 820B3968h-820B398Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B398Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B398C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B398C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B398C);
		  /* 820B398Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820B398Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B398Ch case    0:*/		return 0x820B3990;
		  /* 820B3990h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820B3990h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B39AC;  }
		/* 820B3990h case    1:*/		return 0x820B3994;
		  /* 820B3994h */ case    2:  		/* addi R10, R17, -4 */
		/* 820B3994h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R17,0xFFFFFFFC);
		/* 820B3994h case    2:*/		return 0x820B3998;
		  /* 820B3998h */ case    3:  		/* cmplwi CR0, R31, 0 */
		/* 820B3998h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B3998h case    3:*/		return 0x820B399C;
		  /* 820B399Ch */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820B399Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820B39AC;  }
		/* 820B399Ch case    4:*/		return 0x820B39A0;
		  /* 820B39A0h */ case    5:  		/* mtspr CTR, R31 */
		/* 820B39A0h case    5:*/		regs.CTR = regs.R31;
		/* 820B39A0h case    5:*/		return 0x820B39A4;
		  /* 820B39A4h */ case    6:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B39A4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B39A4h case    6:*/		return 0x820B39A8;
		  /* 820B39A8h */ case    7:  		/* bc 16, CR0_LT, -4 */
		/* 820B39A8h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B39A4;  }
		/* 820B39A8h case    7:*/		return 0x820B39AC;
	}
	return 0x820B39AC;
} // Block from 820B398Ch-820B39ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B39ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B39AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B39AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B39AC);
		  /* 820B39ACh */ case    0:  		/* rlwinm R30, R31, 0, 12, 31 */
		/* 820B39ACh case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R31);
		/* 820B39ACh case    0:*/		return 0x820B39B0;
		  /* 820B39B0h */ case    1:  		/* li R9, 0 */
		/* 820B39B0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B39B0h case    1:*/		return 0x820B39B4;
		  /* 820B39B4h */ case    2:  		/* li R8, 0 */
		/* 820B39B4h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B39B4h case    2:*/		return 0x820B39B8;
		  /* 820B39B8h */ case    3:  		/* mr R7, R19 */
		/* 820B39B8h case    3:*/		regs.R7 = regs.R19;
		/* 820B39B8h case    3:*/		return 0x820B39BC;
		  /* 820B39BCh */ case    4:  		/* mr R6, R26 */
		/* 820B39BCh case    4:*/		regs.R6 = regs.R26;
		/* 820B39BCh case    4:*/		return 0x820B39C0;
		  /* 820B39C0h */ case    5:  		/* oris R5, R30, 4112 */
		/* 820B39C0h case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820B39C0h case    5:*/		return 0x820B39C4;
		  /* 820B39C4h */ case    6:  		/* mr R4, R22 */
		/* 820B39C4h case    6:*/		regs.R4 = regs.R22;
		/* 820B39C4h case    6:*/		return 0x820B39C8;
		  /* 820B39C8h */ case    7:  		/* mr R3, R23 */
		/* 820B39C8h case    7:*/		regs.R3 = regs.R23;
		/* 820B39C8h case    7:*/		return 0x820B39CC;
		  /* 820B39CCh */ case    8:  		/* bl -11972 */
		/* 820B39CCh case    8:*/		regs.LR = 0x820B39D0; return 0x820B0B08;
		/* 820B39CCh case    8:*/		return 0x820B39D0;
		  /* 820B39D0h */ case    9:  		/* or. R31, R3, R3 */
		/* 820B39D0h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B39D0h case    9:*/		return 0x820B39D4;
		  /* 820B39D4h */ case   10:  		/* bc 12, CR0_LT, -340 */
		/* 820B39D4h case   10:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B39D4h case   10:*/		return 0x820B39D8;
		  /* 820B39D8h */ case   11:  		/* oris R29, R30, 8256 */
		/* 820B39D8h case   11:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R30,0x2040);
		/* 820B39D8h case   11:*/		return 0x820B39DC;
		  /* 820B39DCh */ case   12:  		/* li R9, 0 */
		/* 820B39DCh case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B39DCh case   12:*/		return 0x820B39E0;
		  /* 820B39E0h */ case   13:  		/* mr R8, R24 */
		/* 820B39E0h case   13:*/		regs.R8 = regs.R24;
		/* 820B39E0h case   13:*/		return 0x820B39E4;
		  /* 820B39E4h */ case   14:  		/* mr R7, R26 */
		/* 820B39E4h case   14:*/		regs.R7 = regs.R26;
		/* 820B39E4h case   14:*/		return 0x820B39E8;
		  /* 820B39E8h */ case   15:  		/* mr R6, R27 */
		/* 820B39E8h case   15:*/		regs.R6 = regs.R27;
		/* 820B39E8h case   15:*/		return 0x820B39EC;
		  /* 820B39ECh */ case   16:  		/* mr R5, R29 */
		/* 820B39ECh case   16:*/		regs.R5 = regs.R29;
		/* 820B39ECh case   16:*/		return 0x820B39F0;
		  /* 820B39F0h */ case   17:  		/* mr R4, R22 */
		/* 820B39F0h case   17:*/		regs.R4 = regs.R22;
		/* 820B39F0h case   17:*/		return 0x820B39F4;
		  /* 820B39F4h */ case   18:  		/* mr R3, R23 */
		/* 820B39F4h case   18:*/		regs.R3 = regs.R23;
		/* 820B39F4h case   18:*/		return 0x820B39F8;
		  /* 820B39F8h */ case   19:  		/* bl -12016 */
		/* 820B39F8h case   19:*/		regs.LR = 0x820B39FC; return 0x820B0B08;
		/* 820B39F8h case   19:*/		return 0x820B39FC;
		  /* 820B39FCh */ case   20:  		/* or. R31, R3, R3 */
		/* 820B39FCh case   20:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B39FCh case   20:*/		return 0x820B3A00;
		  /* 820B3A00h */ case   21:  		/* bc 12, CR0_LT, -384 */
		/* 820B3A00h case   21:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B3A00h case   21:*/		return 0x820B3A04;
		  /* 820B3A04h */ case   22:  		/* oris R30, R30, 8272 */
		/* 820B3A04h case   22:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R30,0x2050);
		/* 820B3A04h case   22:*/		return 0x820B3A08;
		  /* 820B3A08h */ case   23:  		/* li R9, 0 */
		/* 820B3A08h case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3A08h case   23:*/		return 0x820B3A0C;
		  /* 820B3A0Ch */ case   24:  		/* mr R8, R21 */
		/* 820B3A0Ch case   24:*/		regs.R8 = regs.R21;
		/* 820B3A0Ch case   24:*/		return 0x820B3A10;
		  /* 820B3A10h */ case   25:  		/* mr R7, R27 */
		/* 820B3A10h case   25:*/		regs.R7 = regs.R27;
		/* 820B3A10h case   25:*/		return 0x820B3A14;
		  /* 820B3A14h */ case   26:  		/* mr R6, R25 */
		/* 820B3A14h case   26:*/		regs.R6 = regs.R25;
		/* 820B3A14h case   26:*/		return 0x820B3A18;
		  /* 820B3A18h */ case   27:  		/* mr R5, R30 */
		/* 820B3A18h case   27:*/		regs.R5 = regs.R30;
		/* 820B3A18h case   27:*/		return 0x820B3A1C;
		  /* 820B3A1Ch */ case   28:  		/* mr R4, R22 */
		/* 820B3A1Ch case   28:*/		regs.R4 = regs.R22;
		/* 820B3A1Ch case   28:*/		return 0x820B3A20;
		  /* 820B3A20h */ case   29:  		/* mr R3, R23 */
		/* 820B3A20h case   29:*/		regs.R3 = regs.R23;
		/* 820B3A20h case   29:*/		return 0x820B3A24;
		  /* 820B3A24h */ case   30:  		/* bl -12060 */
		/* 820B3A24h case   30:*/		regs.LR = 0x820B3A28; return 0x820B0B08;
		/* 820B3A24h case   30:*/		return 0x820B3A28;
		  /* 820B3A28h */ case   31:  		/* or. R31, R3, R3 */
		/* 820B3A28h case   31:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3A28h case   31:*/		return 0x820B3A2C;
		  /* 820B3A2Ch */ case   32:  		/* bc 12, CR0_LT, -428 */
		/* 820B3A2Ch case   32:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B3A2Ch case   32:*/		return 0x820B3A30;
		  /* 820B3A30h */ case   33:  		/* li R9, 0 */
		/* 820B3A30h case   33:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3A30h case   33:*/		return 0x820B3A34;
		  /* 820B3A34h */ case   34:  		/* mr R8, R20 */
		/* 820B3A34h case   34:*/		regs.R8 = regs.R20;
		/* 820B3A34h case   34:*/		return 0x820B3A38;
		  /* 820B3A38h */ case   35:  		/* mr R7, R19 */
		/* 820B3A38h case   35:*/		regs.R7 = regs.R19;
		/* 820B3A38h case   35:*/		return 0x820B3A3C;
		  /* 820B3A3Ch */ case   36:  		/* mr R6, R28 */
		/* 820B3A3Ch case   36:*/		regs.R6 = regs.R28;
		/* 820B3A3Ch case   36:*/		return 0x820B3A40;
		  /* 820B3A40h */ case   37:  		/* mr R5, R30 */
		/* 820B3A40h case   37:*/		regs.R5 = regs.R30;
		/* 820B3A40h case   37:*/		return 0x820B3A44;
		  /* 820B3A44h */ case   38:  		/* mr R4, R22 */
		/* 820B3A44h case   38:*/		regs.R4 = regs.R22;
		/* 820B3A44h case   38:*/		return 0x820B3A48;
		  /* 820B3A48h */ case   39:  		/* mr R3, R23 */
		/* 820B3A48h case   39:*/		regs.R3 = regs.R23;
		/* 820B3A48h case   39:*/		return 0x820B3A4C;
		  /* 820B3A4Ch */ case   40:  		/* bl -12100 */
		/* 820B3A4Ch case   40:*/		regs.LR = 0x820B3A50; return 0x820B0B08;
		/* 820B3A4Ch case   40:*/		return 0x820B3A50;
		  /* 820B3A50h */ case   41:  		/* or. R31, R3, R3 */
		/* 820B3A50h case   41:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3A50h case   41:*/		return 0x820B3A54;
		  /* 820B3A54h */ case   42:  		/* bc 12, CR0_LT, -468 */
		/* 820B3A54h case   42:*/		if ( regs.CR[0].lt ) { return 0x820B3880;  }
		/* 820B3A54h case   42:*/		return 0x820B3A58;
		  /* 820B3A58h */ case   43:  		/* mr R7, R25 */
		/* 820B3A58h case   43:*/		regs.R7 = regs.R25;
		/* 820B3A58h case   43:*/		return 0x820B3A5C;
		  /* 820B3A5Ch */ case   44:  		/* b -516 */
		/* 820B3A5Ch case   44:*/		return 0x820B3858;
		/* 820B3A5Ch case   44:*/		return 0x820B3A60;
	}
	return 0x820B3A60;
} // Block from 820B39ACh-820B3A60h (45 instructions)

//////////////////////////////////////////////////////
// Block at 820B3A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3A60);
		  /* 820B3A60h */ case    0:  		/* mfspr R12, LR */
		/* 820B3A60h case    0:*/		regs.R12 = regs.LR;
		/* 820B3A60h case    0:*/		return 0x820B3A64;
		  /* 820B3A64h */ case    1:  		/* bl -141360 */
		/* 820B3A64h case    1:*/		regs.LR = 0x820B3A68; return 0x82091234;
		/* 820B3A64h case    1:*/		return 0x820B3A68;
		  /* 820B3A68h */ case    2:  		/* stfd FR30, <#[R1 - 128]> */
		/* 820B3A68h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF80) );
		/* 820B3A68h case    2:*/		return 0x820B3A6C;
		  /* 820B3A6Ch */ case    3:  		/* stfd FR31, <#[R1 - 120]> */
		/* 820B3A6Ch case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 820B3A6Ch case    3:*/		return 0x820B3A70;
		  /* 820B3A70h */ case    4:  		/* stwu R1, <#[R1 - 224]> */
		/* 820B3A70h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 820B3A70h case    4:*/		return 0x820B3A74;
		  /* 820B3A74h */ case    5:  		/* lis R11, -32256 */
		/* 820B3A74h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820B3A74h case    5:*/		return 0x820B3A78;
		  /* 820B3A78h */ case    6:  		/* mr R23, R3 */
		/* 820B3A78h case    6:*/		regs.R23 = regs.R3;
		/* 820B3A78h case    6:*/		return 0x820B3A7C;
		  /* 820B3A7Ch */ case    7:  		/* mr R20, R4 */
		/* 820B3A7Ch case    7:*/		regs.R20 = regs.R4;
		/* 820B3A7Ch case    7:*/		return 0x820B3A80;
		  /* 820B3A80h */ case    8:  		/* mr R21, R5 */
		/* 820B3A80h case    8:*/		regs.R21 = regs.R5;
		/* 820B3A80h case    8:*/		return 0x820B3A84;
		  /* 820B3A84h */ case    9:  		/* mr R19, R6 */
		/* 820B3A84h case    9:*/		regs.R19 = regs.R6;
		/* 820B3A84h case    9:*/		return 0x820B3A88;
		  /* 820B3A88h */ case   10:  		/* lfd FR30, <#[R11 + 1808]> */
		/* 820B3A88h case   10:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000710) );
		/* 820B3A88h case   10:*/		return 0x820B3A8C;
		  /* 820B3A8Ch */ case   11:  		/* mr R22, R7 */
		/* 820B3A8Ch case   11:*/		regs.R22 = regs.R7;
		/* 820B3A8Ch case   11:*/		return 0x820B3A90;
		  /* 820B3A90h */ case   12:  		/* mr R30, R8 */
		/* 820B3A90h case   12:*/		regs.R30 = regs.R8;
		/* 820B3A90h case   12:*/		return 0x820B3A94;
		  /* 820B3A94h */ case   13:  		/* li R25, 0 */
		/* 820B3A94h case   13:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820B3A94h case   13:*/		return 0x820B3A98;
		  /* 820B3A98h */ case   14:  		/* li R27, 1 */
		/* 820B3A98h case   14:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 820B3A98h case   14:*/		return 0x820B3A9C;
		  /* 820B3A9Ch */ case   15:  		/* li R28, 1 */
		/* 820B3A9Ch case   15:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820B3A9Ch case   15:*/		return 0x820B3AA0;
		  /* 820B3AA0h */ case   16:  		/* li R29, 0 */
		/* 820B3AA0h case   16:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B3AA0h case   16:*/		return 0x820B3AA4;
		  /* 820B3AA4h */ case   17:  		/* cmplwi CR6, R8, 0 */
		/* 820B3AA4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820B3AA4h case   17:*/		return 0x820B3AA8;
		  /* 820B3AA8h */ case   18:  		/* bc 12, CR6_EQ, 84 */
		/* 820B3AA8h case   18:*/		if ( regs.CR[6].eq ) { return 0x820B3AFC;  }
		/* 820B3AA8h case   18:*/		return 0x820B3AAC;
		  /* 820B3AACh */ case   19:  		/* lis R11, -32256 */
		/* 820B3AACh case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820B3AACh case   19:*/		return 0x820B3AB0;
		  /* 820B3AB0h */ case   20:  		/* mr R31, R6 */
		/* 820B3AB0h case   20:*/		regs.R31 = regs.R6;
		/* 820B3AB0h case   20:*/		return 0x820B3AB4;
		  /* 820B3AB4h */ case   21:  		/* lfd FR31, <#[R11 + 1848]> */
		/* 820B3AB4h case   21:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000738) );
		/* 820B3AB4h case   21:*/		return 0x820B3AB8;
		  /* 820B3AB8h */ case   22:  		/* addi R5, R1, 80 */
		/* 820B3AB8h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B3AB8h case   22:*/		return 0x820B3ABC;
		  /* 820B3ABCh */ case   23:  		/* lwz R4, <#[R31]> */
		/* 820B3ABCh case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820B3ABCh case   23:*/		return 0x820B3AC0;
		  /* 820B3AC0h */ case   24:  		/* mr R3, R23 */
		/* 820B3AC0h case   24:*/		regs.R3 = regs.R23;
		/* 820B3AC0h case   24:*/		return 0x820B3AC4;
		  /* 820B3AC4h */ case   25:  		/* bl -12988 */
		/* 820B3AC4h case   25:*/		regs.LR = 0x820B3AC8; return 0x820B0808;
		/* 820B3AC4h case   25:*/		return 0x820B3AC8;
		  /* 820B3AC8h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 820B3AC8h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B3AC8h case   26:*/		return 0x820B3ACC;
		  /* 820B3ACCh */ case   27:  		/* bc 12, CR0_LT, 48 */
		/* 820B3ACCh case   27:*/		if ( regs.CR[0].lt ) { return 0x820B3AFC;  }
		/* 820B3ACCh case   27:*/		return 0x820B3AD0;
		  /* 820B3AD0h */ case   28:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820B3AD0h case   28:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3AD0h case   28:*/		return 0x820B3AD4;
		  /* 820B3AD4h */ case   29:  		/* fcmpu CR6, FR0, FR30 */
		/* 820B3AD4h case   29:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 820B3AD4h case   29:*/		return 0x820B3AD8;
		  /* 820B3AD8h */ case   30:  		/* bc 12, CR6_EQ, 8 */
		/* 820B3AD8h case   30:*/		if ( regs.CR[6].eq ) { return 0x820B3AE0;  }
		/* 820B3AD8h case   30:*/		return 0x820B3ADC;
		  /* 820B3ADCh */ case   31:  		/* li R27, 0 */
		/* 820B3ADCh case   31:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820B3ADCh case   31:*/		return 0x820B3AE0;
	}
	return 0x820B3AE0;
} // Block from 820B3A60h-820B3AE0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820B3AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3AE0);
		  /* 820B3AE0h */ case    0:  		/* fcmpu CR6, FR0, FR31 */
		/* 820B3AE0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820B3AE0h case    0:*/		return 0x820B3AE4;
		  /* 820B3AE4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820B3AE4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B3AEC;  }
		/* 820B3AE4h case    1:*/		return 0x820B3AE8;
		  /* 820B3AE8h */ case    2:  		/* li R28, 0 */
		/* 820B3AE8h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820B3AE8h case    2:*/		return 0x820B3AEC;
	}
	return 0x820B3AEC;
} // Block from 820B3AE0h-820B3AECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B3AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3AEC);
		  /* 820B3AECh */ case    0:  		/* addi R29, R29, 1 */
		/* 820B3AECh case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820B3AECh case    0:*/		return 0x820B3AF0;
		  /* 820B3AF0h */ case    1:  		/* addi R31, R31, 4 */
		/* 820B3AF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820B3AF0h case    1:*/		return 0x820B3AF4;
		  /* 820B3AF4h */ case    2:  		/* cmplw CR6, R29, R30 */
		/* 820B3AF4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820B3AF4h case    2:*/		return 0x820B3AF8;
		  /* 820B3AF8h */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 820B3AF8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820B3AB8;  }
		/* 820B3AF8h case    3:*/		return 0x820B3AFC;
	}
	return 0x820B3AFC;
} // Block from 820B3AECh-820B3AFCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B3AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3AFC);
		  /* 820B3AFCh */ case    0:  		/* cmplw CR6, R29, R30 */
		/* 820B3AFCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820B3AFCh case    0:*/		return 0x820B3B00;
		  /* 820B3B00h */ case    1:  		/* bc 4, CR6_EQ, 144 */
		/* 820B3B00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B3B90;  }
		/* 820B3B00h case    1:*/		return 0x820B3B04;
		  /* 820B3B04h */ case    2:  		/* cmpwi CR6, R27, 0 */
		/* 820B3B04h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820B3B04h case    2:*/		return 0x820B3B08;
		  /* 820B3B08h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820B3B08h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B3B14;  }
		/* 820B3B08h case    3:*/		return 0x820B3B0C;
		  /* 820B3B0Ch */ case    4:  		/* cmpwi CR6, R28, 0 */
		/* 820B3B0Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820B3B0Ch case    4:*/		return 0x820B3B10;
		  /* 820B3B10h */ case    5:  		/* bc 12, CR6_EQ, 128 */
		/* 820B3B10h case    5:*/		if ( regs.CR[6].eq ) { return 0x820B3B90;  }
		/* 820B3B10h case    5:*/		return 0x820B3B14;
	}
	return 0x820B3B14;
} // Block from 820B3AFCh-820B3B14h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B3B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3B14);
		  /* 820B3B14h */ case    0:  		/* lis R4, 9345 */
		/* 820B3B14h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3B14h case    0:*/		return 0x820B3B18;
		  /* 820B3B18h */ case    1:  		/* rlwinm R3, R30, 2, 0, 29 */
		/* 820B3B18h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R30);
		/* 820B3B18h case    1:*/		return 0x820B3B1C;
		  /* 820B3B1Ch */ case    2:  		/* bl -178460 */
		/* 820B3B1Ch case    2:*/		regs.LR = 0x820B3B20; return 0x82088200;
		/* 820B3B1Ch case    2:*/		return 0x820B3B20;
		  /* 820B3B20h */ case    3:  		/* or. R25, R3, R3 */
		/* 820B3B20h case    3:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820B3B20h case    3:*/		return 0x820B3B24;
		  /* 820B3B24h */ case    4:  		/* bc 12, CR0_EQ, 916 */
		/* 820B3B24h case    4:*/		if ( regs.CR[0].eq ) { return 0x820B3EB8;  }
		/* 820B3B24h case    4:*/		return 0x820B3B28;
		  /* 820B3B28h */ case    5:  		/* cmplwi CR6, R30, 0 */
		/* 820B3B28h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3B28h case    5:*/		return 0x820B3B2C;
		  /* 820B3B2Ch */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 820B3B2Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820B3B78;  }
		/* 820B3B2Ch case    6:*/		return 0x820B3B30;
		  /* 820B3B30h */ case    7:  		/* addi R10, R25, -4 */
		/* 820B3B30h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R25,0xFFFFFFFC);
		/* 820B3B30h case    7:*/		return 0x820B3B34;
		  /* 820B3B34h */ case    8:  		/* mtspr CTR, R30 */
		/* 820B3B34h case    8:*/		regs.CTR = regs.R30;
		/* 820B3B34h case    8:*/		return 0x820B3B38;
		  /* 820B3B38h */ case    9:  		/* cmpwi CR6, R27, 0 */
		/* 820B3B38h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 820B3B38h case    9:*/		return 0x820B3B3C;
		  /* 820B3B3Ch */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820B3B3Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820B3B48;  }
		/* 820B3B3Ch case   10:*/		return 0x820B3B40;
		  /* 820B3B40h */ case   11:  		/* lwz R11, <#[R23 + 36]> */
		/* 820B3B40h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000024) );
		/* 820B3B40h case   11:*/		return 0x820B3B44;
		  /* 820B3B44h */ case   12:  		/* b 8 */
		/* 820B3B44h case   12:*/		return 0x820B3B4C;
		/* 820B3B44h case   12:*/		return 0x820B3B48;
	}
	return 0x820B3B48;
} // Block from 820B3B14h-820B3B48h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820B3B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3B48);
		  /* 820B3B48h */ case    0:  		/* lwz R11, <#[R23 + 32]> */
		/* 820B3B48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000020) );
		/* 820B3B48h case    0:*/		return 0x820B3B4C;
	}
	return 0x820B3B4C;
} // Block from 820B3B48h-820B3B4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B3B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3B4C);
		  /* 820B3B4Ch */ case    0:  		/* stwu R11, <#[R10 + 4]> */
		/* 820B3B4Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B3B4Ch case    0:*/		return 0x820B3B50;
		  /* 820B3B50h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820B3B50h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3B38;  }
		/* 820B3B50h case    1:*/		return 0x820B3B54;
		  /* 820B3B54h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 820B3B54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3B54h case    2:*/		return 0x820B3B58;
		  /* 820B3B58h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 820B3B58h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B3B78;  }
		/* 820B3B58h case    3:*/		return 0x820B3B5C;
		  /* 820B3B5Ch */ case    4:  		/* addi R11, R21, -4 */
		/* 820B3B5Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0xFFFFFFFC);
		/* 820B3B5Ch case    4:*/		return 0x820B3B60;
		  /* 820B3B60h */ case    5:  		/* li R10, -1 */
		/* 820B3B60h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820B3B60h case    5:*/		return 0x820B3B64;
		  /* 820B3B64h */ case    6:  		/* cmplwi CR0, R30, 0 */
		/* 820B3B64h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B3B64h case    6:*/		return 0x820B3B68;
		  /* 820B3B68h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3B68h case    7:*/		if ( regs.CR[0].eq ) { return 0x820B3B78;  }
		/* 820B3B68h case    7:*/		return 0x820B3B6C;
		  /* 820B3B6Ch */ case    8:  		/* mtspr CTR, R30 */
		/* 820B3B6Ch case    8:*/		regs.CTR = regs.R30;
		/* 820B3B6Ch case    8:*/		return 0x820B3B70;
		  /* 820B3B70h */ case    9:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3B70h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3B70h case    9:*/		return 0x820B3B74;
		  /* 820B3B74h */ case   10:  		/* bc 16, CR0_LT, -4 */
		/* 820B3B74h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3B70;  }
		/* 820B3B74h case   10:*/		return 0x820B3B78;
	}
	return 0x820B3B78;
} // Block from 820B3B4Ch-820B3B78h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B3B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3B78);
		  /* 820B3B78h */ case    0:  		/* mr R5, R30 */
		/* 820B3B78h case    0:*/		regs.R5 = regs.R30;
		/* 820B3B78h case    0:*/		return 0x820B3B7C;
		  /* 820B3B7Ch */ case    1:  		/* li R11, 1 */
		/* 820B3B7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820B3B7Ch case    1:*/		return 0x820B3B80;
		  /* 820B3B80h */ case    2:  		/* li R9, 0 */
		/* 820B3B80h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3B80h case    2:*/		return 0x820B3B84;
		  /* 820B3B84h */ case    3:  		/* rlwimi R5, R11, 28, 0, 11 */
		/* 820B3B84h case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R11);
		/* 820B3B84h case    3:*/		return 0x820B3B88;
		  /* 820B3B88h */ case    4:  		/* mr R7, R25 */
		/* 820B3B88h case    4:*/		regs.R7 = regs.R25;
		/* 820B3B88h case    4:*/		return 0x820B3B8C;
		  /* 820B3B8Ch */ case    5:  		/* b 756 */
		/* 820B3B8Ch case    5:*/		return 0x820B3E80;
		/* 820B3B8Ch case    5:*/		return 0x820B3B90;
	}
	return 0x820B3B90;
} // Block from 820B3B78h-820B3B90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B3B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3B90);
		  /* 820B3B90h */ case    0:  		/* li R10, 1 */
		/* 820B3B90h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820B3B90h case    0:*/		return 0x820B3B94;
		  /* 820B3B94h */ case    1:  		/* cmplwi CR6, R30, 1 */
		/* 820B3B94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 820B3B94h case    1:*/		return 0x820B3B98;
		  /* 820B3B98h */ case    2:  		/* bc 4, CR6_GT, 40 */
		/* 820B3B98h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820B3BC0;  }
		/* 820B3B98h case    2:*/		return 0x820B3B9C;
		  /* 820B3B9Ch */ case    3:  		/* lwz R9, <#[R22]> */
		/* 820B3B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000000) );
		/* 820B3B9Ch case    3:*/		return 0x820B3BA0;
		  /* 820B3BA0h */ case    4:  		/* addi R11, R22, 4 */
		/* 820B3BA0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x4);
		/* 820B3BA0h case    4:*/		return 0x820B3BA4;
		  /* 820B3BA4h */ case    5:  		/* lwz R8, <#[R11]> */
		/* 820B3BA4h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820B3BA4h case    5:*/		return 0x820B3BA8;
		  /* 820B3BA8h */ case    6:  		/* cmplw CR6, R9, R8 */
		/* 820B3BA8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820B3BA8h case    6:*/		return 0x820B3BAC;
		  /* 820B3BACh */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 820B3BACh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820B3BC0;  }
		/* 820B3BACh case    7:*/		return 0x820B3BB0;
		  /* 820B3BB0h */ case    8:  		/* addi R10, R10, 1 */
		/* 820B3BB0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B3BB0h case    8:*/		return 0x820B3BB4;
		  /* 820B3BB4h */ case    9:  		/* addi R11, R11, 4 */
		/* 820B3BB4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B3BB4h case    9:*/		return 0x820B3BB8;
		  /* 820B3BB8h */ case   10:  		/* cmplw CR6, R10, R30 */
		/* 820B3BB8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 820B3BB8h case   10:*/		return 0x820B3BBC;
		  /* 820B3BBCh */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 820B3BBCh case   11:*/		if ( regs.CR[6].lt ) { return 0x820B3BA4;  }
		/* 820B3BBCh case   11:*/		return 0x820B3BC0;
	}
	return 0x820B3BC0;
} // Block from 820B3B90h-820B3BC0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B3BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3BC0);
		  /* 820B3BC0h */ case    0:  		/* cmplw CR6, R29, R30 */
		/* 820B3BC0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820B3BC0h case    0:*/		return 0x820B3BC4;
		  /* 820B3BC4h */ case    1:  		/* bc 4, CR6_EQ, 736 */
		/* 820B3BC4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B3EA4;  }
		/* 820B3BC4h case    1:*/		return 0x820B3BC8;
		  /* 820B3BC8h */ case    2:  		/* addi R5, R1, 80 */
		/* 820B3BC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B3BC8h case    2:*/		return 0x820B3BCC;
		  /* 820B3BCCh */ case    3:  		/* lwz R4, <#[R22]> */
		/* 820B3BCCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000000) );
		/* 820B3BCCh case    3:*/		return 0x820B3BD0;
		  /* 820B3BD0h */ case    4:  		/* mr R3, R23 */
		/* 820B3BD0h case    4:*/		regs.R3 = regs.R23;
		/* 820B3BD0h case    4:*/		return 0x820B3BD4;
		  /* 820B3BD4h */ case    5:  		/* bl -13260 */
		/* 820B3BD4h case    5:*/		regs.LR = 0x820B3BD8; return 0x820B0808;
		/* 820B3BD4h case    5:*/		return 0x820B3BD8;
		  /* 820B3BD8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820B3BD8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B3BD8h case    6:*/		return 0x820B3BDC;
		  /* 820B3BDCh */ case    7:  		/* bc 12, CR0_LT, 712 */
		/* 820B3BDCh case    7:*/		if ( regs.CR[0].lt ) { return 0x820B3EA4;  }
		/* 820B3BDCh case    7:*/		return 0x820B3BE0;
		  /* 820B3BE0h */ case    8:  		/* lfd FR31, <#[R1 + 80]> */
		/* 820B3BE0h case    8:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3BE0h case    8:*/		return 0x820B3BE4;
		  /* 820B3BE4h */ case    9:  		/* lis R11, -32255 */
		/* 820B3BE4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820B3BE4h case    9:*/		return 0x820B3BE8;
		  /* 820B3BE8h */ case   10:  		/* fctiwz FR0, FR31 */
		/* 820B3BE8h case   10:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR31);
		/* 820B3BE8h case   10:*/		return 0x820B3BEC;
		  /* 820B3BECh */ case   11:  		/* stfd FR0, <#[R1 + 80]> */
		/* 820B3BECh case   11:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3BECh case   11:*/		return 0x820B3BF0;
		  /* 820B3BF0h */ case   12:  		/* lwz R24, <#[R1 + 84]> */
		/* 820B3BF0h case   12:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 820B3BF0h case   12:*/		return 0x820B3BF4;
		  /* 820B3BF4h */ case   13:  		/* extsw R10, R24 */
		/* 820B3BF4h case   13:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R24);
		/* 820B3BF4h case   13:*/		return 0x820B3BF8;
		  /* 820B3BF8h */ case   14:  		/* std R10, <#[R1 + 80]> */
		/* 820B3BF8h case   14:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3BF8h case   14:*/		return 0x820B3BFC;
		  /* 820B3BFCh */ case   15:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820B3BFCh case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3BFCh case   15:*/		return 0x820B3C00;
		  /* 820B3C00h */ case   16:  		/* fcfid FR13, FR0 */
		/* 820B3C00h case   16:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR0);
		/* 820B3C00h case   16:*/		return 0x820B3C04;
		  /* 820B3C04h */ case   17:  		/* lfd FR0, <#[R11 + 8072]> */
		/* 820B3C04h case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001F88) );
		/* 820B3C04h case   17:*/		return 0x820B3C08;
		  /* 820B3C08h */ case   18:  		/* fsub FR13, FR31, FR13 */
		/* 820B3C08h case   18:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR31,regs.FR13);
		/* 820B3C08h case   18:*/		return 0x820B3C0C;
		  /* 820B3C0Ch */ case   19:  		/* fabs FR13, FR13 */
		/* 820B3C0Ch case   19:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR13);
		/* 820B3C0Ch case   19:*/		return 0x820B3C10;
		  /* 820B3C10h */ case   20:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B3C10h case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B3C10h case   20:*/		return 0x820B3C14;
		  /* 820B3C14h */ case   21:  		/* bc 4, CR6_LT, 492 */
		/* 820B3C14h case   21:*/		if ( !regs.CR[6].lt ) { return 0x820B3E00;  }
		/* 820B3C14h case   21:*/		return 0x820B3C18;
		  /* 820B3C18h */ case   22:  		/* srawi R11, R24, 31 */
		/* 820B3C18h case   22:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R24);
		/* 820B3C18h case   22:*/		return 0x820B3C1C;
		  /* 820B3C1Ch */ case   23:  		/* li R10, 0 */
		/* 820B3C1Ch case   23:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B3C1Ch case   23:*/		return 0x820B3C20;
		  /* 820B3C20h */ case   24:  		/* xor R8, R24, R11 */
		/* 820B3C20h case   24:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R24,regs.R11);
		/* 820B3C20h case   24:*/		return 0x820B3C24;
		  /* 820B3C24h */ case   25:  		/* li R9, 0 */
		/* 820B3C24h case   25:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3C24h case   25:*/		return 0x820B3C28;
		  /* 820B3C28h */ case   26:  		/* subf. R26, R11, R8 */
		/* 820B3C28h case   26:*/		cpu::op::subf<1>(regs,&regs.R26,regs.R11,regs.R8);
		/* 820B3C28h case   26:*/		return 0x820B3C2C;
		  /* 820B3C2Ch */ case   27:  		/* mr R11, R26 */
		/* 820B3C2Ch case   27:*/		regs.R11 = regs.R26;
		/* 820B3C2Ch case   27:*/		return 0x820B3C30;
		  /* 820B3C30h */ case   28:  		/* bc 12, CR0_EQ, 36 */
		/* 820B3C30h case   28:*/		if ( regs.CR[0].eq ) { return 0x820B3C54;  }
		/* 820B3C30h case   28:*/		return 0x820B3C34;
		  /* 820B3C34h */ case   29:  		/* rlwinm R8, R11, 0, 31, 31 */
		/* 820B3C34h case   29:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R11);
		/* 820B3C34h case   29:*/		return 0x820B3C38;
		  /* 820B3C38h */ case   30:  		/* rlwinm. R11, R11, 31, 1, 31 */
		/* 820B3C38h case   30:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R11,regs.R11);
		/* 820B3C38h case   30:*/		return 0x820B3C3C;
		  /* 820B3C3Ch */ case   31:  		/* addi R10, R10, 1 */
		/* 820B3C3Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B3C3Ch case   31:*/		return 0x820B3C40;
		  /* 820B3C40h */ case   32:  		/* add R9, R8, R9 */
		/* 820B3C40h case   32:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820B3C40h case   32:*/		return 0x820B3C44;
		  /* 820B3C44h */ case   33:  		/* bc 4, CR0_EQ, -16 */
		/* 820B3C44h case   33:*/		if ( !regs.CR[0].eq ) { return 0x820B3C34;  }
		/* 820B3C44h case   33:*/		return 0x820B3C48;
		  /* 820B3C48h */ case   34:  		/* cmplwi CR6, R10, 0 */
		/* 820B3C48h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B3C48h case   34:*/		return 0x820B3C4C;
		  /* 820B3C4Ch */ case   35:  		/* addi R10, R10, -1 */
		/* 820B3C4Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820B3C4Ch case   35:*/		return 0x820B3C50;
		  /* 820B3C50h */ case   36:  		/* bc 4, CR6_EQ, 8 */
		/* 820B3C50h case   36:*/		if ( !regs.CR[6].eq ) { return 0x820B3C58;  }
		/* 820B3C50h case   36:*/		return 0x820B3C54;
	}
	return 0x820B3C54;
} // Block from 820B3BC0h-820B3C54h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820B3C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3C54);
		  /* 820B3C54h */ case    0:  		/* li R10, 0 */
		/* 820B3C54h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B3C54h case    0:*/		return 0x820B3C58;
	}
	return 0x820B3C58;
} // Block from 820B3C54h-820B3C58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B3C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3C58);
		  /* 820B3C58h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 820B3C58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820B3C58h case    0:*/		return 0x820B3C5C;
		  /* 820B3C5Ch */ case    1:  		/* addi R11, R9, -1 */
		/* 820B3C5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 820B3C5Ch case    1:*/		return 0x820B3C60;
		  /* 820B3C60h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820B3C60h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B3C68;  }
		/* 820B3C60h case    2:*/		return 0x820B3C64;
		  /* 820B3C64h */ case    3:  		/* li R11, 0 */
		/* 820B3C64h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B3C64h case    3:*/		return 0x820B3C68;
	}
	return 0x820B3C68;
} // Block from 820B3C58h-820B3C68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B3C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3C68);
		  /* 820B3C68h */ case    0:  		/* add R10, R11, R10 */
		/* 820B3C68h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820B3C68h case    0:*/		return 0x820B3C6C;
		  /* 820B3C6Ch */ case    1:  		/* cmpwi CR6, R24, 0 */
		/* 820B3C6Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820B3C6Ch case    1:*/		return 0x820B3C70;
		  /* 820B3C70h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 820B3C70h case    2:*/		if ( !regs.CR[6].lt ) { return 0x820B3C78;  }
		/* 820B3C70h case    2:*/		return 0x820B3C74;
		  /* 820B3C74h */ case    3:  		/* add R10, R10, R30 */
		/* 820B3C74h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 820B3C74h case    3:*/		return 0x820B3C78;
	}
	return 0x820B3C78;
} // Block from 820B3C68h-820B3C78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B3C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3C78);
		  /* 820B3C78h */ case    0:  		/* lwz R11, <#[R23 + 8]> */
		/* 820B3C78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 820B3C78h case    0:*/		return 0x820B3C7C;
		  /* 820B3C7Ch */ case    1:  		/* lwz R9, <#[R11 + 108]> */
		/* 820B3C7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000006C) );
		/* 820B3C7Ch case    1:*/		return 0x820B3C80;
		  /* 820B3C80h */ case    2:  		/* rlwinm. R9, R9, 0, 7, 7 */
		/* 820B3C80h case    2:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R9,regs.R9);
		/* 820B3C80h case    2:*/		return 0x820B3C84;
		  /* 820B3C84h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 820B3C84h case    3:*/		if ( regs.CR[0].eq ) { return 0x820B3C9C;  }
		/* 820B3C84h case    3:*/		return 0x820B3C88;
		  /* 820B3C88h */ case    4:  		/* lwz R9, <#[R23 + 20]> */
		/* 820B3C88h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 820B3C88h case    4:*/		return 0x820B3C8C;
		  /* 820B3C8Ch */ case    5:  		/* rlwinm. R9, R9, 0, 26, 26 */
		/* 820B3C8Ch case    5:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R9,regs.R9);
		/* 820B3C8Ch case    5:*/		return 0x820B3C90;
		  /* 820B3C90h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 820B3C90h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B3C9C;  }
		/* 820B3C90h case    6:*/		return 0x820B3C94;
		  /* 820B3C94h */ case    7:  		/* addi R11, R30, 1 */
		/* 820B3C94h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 820B3C94h case    7:*/		return 0x820B3C98;
		  /* 820B3C98h */ case    8:  		/* b 32 */
		/* 820B3C98h case    8:*/		return 0x820B3CB8;
		/* 820B3C98h case    8:*/		return 0x820B3C9C;
	}
	return 0x820B3C9C;
} // Block from 820B3C78h-820B3C9Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B3C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3C9C);
		  /* 820B3C9Ch */ case    0:  		/* lwz R11, <#[R11 + 100]> */
		/* 820B3C9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000064) );
		/* 820B3C9Ch case    0:*/		return 0x820B3CA0;
		  /* 820B3CA0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820B3CA0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B3CA0h case    1:*/		return 0x820B3CA4;
		  /* 820B3CA4h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820B3CA4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B3CAC;  }
		/* 820B3CA4h case    2:*/		return 0x820B3CA8;
		  /* 820B3CA8h */ case    3:  		/* li R11, 1 */
		/* 820B3CA8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820B3CA8h case    3:*/		return 0x820B3CAC;
	}
	return 0x820B3CAC;
} // Block from 820B3C9Ch-820B3CACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B3CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3CAC);
		  /* 820B3CACh */ case    0:  		/* mullw R11, R11, R30 */
		/* 820B3CACh case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820B3CACh case    0:*/		return 0x820B3CB0;
		  /* 820B3CB0h */ case    1:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 820B3CB0h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 820B3CB0h case    1:*/		return 0x820B3CB4;
		  /* 820B3CB4h */ case    2:  		/* addi R11, R11, 1 */
		/* 820B3CB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B3CB4h case    2:*/		return 0x820B3CB8;
	}
	return 0x820B3CB8;
} // Block from 820B3CACh-820B3CB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B3CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3CB8);
		  /* 820B3CB8h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 820B3CB8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820B3CB8h case    0:*/		return 0x820B3CBC;
		  /* 820B3CBCh */ case    1:  		/* bc 12, CR6_GT, 488 */
		/* 820B3CBCh case    1:*/		if ( regs.CR[6].gt ) { return 0x820B3EA4;  }
		/* 820B3CBCh case    1:*/		return 0x820B3CC0;
		  /* 820B3CC0h */ case    2:  		/* lis R4, 9345 */
		/* 820B3CC0h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3CC0h case    2:*/		return 0x820B3CC4;
		  /* 820B3CC4h */ case    3:  		/* rlwinm R3, R30, 2, 0, 29 */
		/* 820B3CC4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R30);
		/* 820B3CC4h case    3:*/		return 0x820B3CC8;
		  /* 820B3CC8h */ case    4:  		/* bl -178888 */
		/* 820B3CC8h case    4:*/		regs.LR = 0x820B3CCC; return 0x82088200;
		/* 820B3CC8h case    4:*/		return 0x820B3CCC;
		  /* 820B3CCCh */ case    5:  		/* or. R25, R3, R3 */
		/* 820B3CCCh case    5:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820B3CCCh case    5:*/		return 0x820B3CD0;
		  /* 820B3CD0h */ case    6:  		/* bc 12, CR0_EQ, 488 */
		/* 820B3CD0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B3EB8;  }
		/* 820B3CD0h case    6:*/		return 0x820B3CD4;
		  /* 820B3CD4h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 820B3CD4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3CD4h case    7:*/		return 0x820B3CD8;
		  /* 820B3CD8h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820B3CD8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820B3CF0;  }
		/* 820B3CD8h case    8:*/		return 0x820B3CDC;
		  /* 820B3CDCh */ case    9:  		/* mtspr CTR, R30 */
		/* 820B3CDCh case    9:*/		regs.CTR = regs.R30;
		/* 820B3CDCh case    9:*/		return 0x820B3CE0;
		  /* 820B3CE0h */ case   10:  		/* addi R11, R25, -4 */
		/* 820B3CE0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFFC);
		/* 820B3CE0h case   10:*/		return 0x820B3CE4;
		  /* 820B3CE4h */ case   11:  		/* lwz R10, <#[R23 + 32]> */
		/* 820B3CE4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000020) );
		/* 820B3CE4h case   11:*/		return 0x820B3CE8;
		  /* 820B3CE8h */ case   12:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3CE8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3CE8h case   12:*/		return 0x820B3CEC;
		  /* 820B3CECh */ case   13:  		/* bc 16, CR0_LT, -8 */
		/* 820B3CECh case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3CE4;  }
		/* 820B3CECh case   13:*/		return 0x820B3CF0;
	}
	return 0x820B3CF0;
} // Block from 820B3CB8h-820B3CF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820B3CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3CF0);
		  /* 820B3CF0h */ case    0:  		/* li R27, -1 */
		/* 820B3CF0h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 820B3CF0h case    0:*/		return 0x820B3CF4;
		  /* 820B3CF4h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820B3CF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3CF4h case    1:*/		return 0x820B3CF8;
		  /* 820B3CF8h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820B3CF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B3D18;  }
		/* 820B3CF8h case    2:*/		return 0x820B3CFC;
		  /* 820B3CFCh */ case    3:  		/* addi R11, R21, -4 */
		/* 820B3CFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0xFFFFFFFC);
		/* 820B3CFCh case    3:*/		return 0x820B3D00;
		  /* 820B3D00h */ case    4:  		/* mr R10, R27 */
		/* 820B3D00h case    4:*/		regs.R10 = regs.R27;
		/* 820B3D00h case    4:*/		return 0x820B3D04;
		  /* 820B3D04h */ case    5:  		/* cmplwi CR0, R30, 0 */
		/* 820B3D04h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B3D04h case    5:*/		return 0x820B3D08;
		  /* 820B3D08h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3D08h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B3D18;  }
		/* 820B3D08h case    6:*/		return 0x820B3D0C;
		  /* 820B3D0Ch */ case    7:  		/* mtspr CTR, R30 */
		/* 820B3D0Ch case    7:*/		regs.CTR = regs.R30;
		/* 820B3D0Ch case    7:*/		return 0x820B3D10;
		  /* 820B3D10h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3D10h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3D10h case    8:*/		return 0x820B3D14;
		  /* 820B3D14h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820B3D14h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3D10;  }
		/* 820B3D14h case    9:*/		return 0x820B3D18;
	}
	return 0x820B3D18;
} // Block from 820B3CF0h-820B3D18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B3D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3D18);
		  /* 820B3D18h */ case    0:  		/* rlwinm R29, R30, 0, 12, 31 */
		/* 820B3D18h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R30);
		/* 820B3D18h case    0:*/		return 0x820B3D1C;
		  /* 820B3D1Ch */ case    1:  		/* li R9, 0 */
		/* 820B3D1Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3D1Ch case    1:*/		return 0x820B3D20;
		  /* 820B3D20h */ case    2:  		/* oris R28, R29, 4096 */
		/* 820B3D20h case    2:*/		cpu::op::oris<0>(regs,&regs.R28,regs.R29,0x1000);
		/* 820B3D20h case    2:*/		return 0x820B3D24;
		  /* 820B3D24h */ case    3:  		/* li R8, 0 */
		/* 820B3D24h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B3D24h case    3:*/		return 0x820B3D28;
		  /* 820B3D28h */ case    4:  		/* mr R7, R25 */
		/* 820B3D28h case    4:*/		regs.R7 = regs.R25;
		/* 820B3D28h case    4:*/		return 0x820B3D2C;
		  /* 820B3D2Ch */ case    5:  		/* mr R6, R21 */
		/* 820B3D2Ch case    5:*/		regs.R6 = regs.R21;
		/* 820B3D2Ch case    5:*/		return 0x820B3D30;
		  /* 820B3D30h */ case    6:  		/* mr R5, R28 */
		/* 820B3D30h case    6:*/		regs.R5 = regs.R28;
		/* 820B3D30h case    6:*/		return 0x820B3D34;
		  /* 820B3D34h */ case    7:  		/* mr R4, R20 */
		/* 820B3D34h case    7:*/		regs.R4 = regs.R20;
		/* 820B3D34h case    7:*/		return 0x820B3D38;
		  /* 820B3D38h */ case    8:  		/* mr R3, R23 */
		/* 820B3D38h case    8:*/		regs.R3 = regs.R23;
		/* 820B3D38h case    8:*/		return 0x820B3D3C;
		  /* 820B3D3Ch */ case    9:  		/* bl -12852 */
		/* 820B3D3Ch case    9:*/		regs.LR = 0x820B3D40; return 0x820B0B08;
		/* 820B3D3Ch case    9:*/		return 0x820B3D40;
		  /* 820B3D40h */ case   10:  		/* or. R31, R3, R3 */
		/* 820B3D40h case   10:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3D40h case   10:*/		return 0x820B3D44;
		  /* 820B3D44h */ case   11:  		/* bc 12, CR0_LT, 664 */
		/* 820B3D44h case   11:*/		if ( regs.CR[0].lt ) { return 0x820B3FDC;  }
		/* 820B3D44h case   11:*/		return 0x820B3D48;
		  /* 820B3D48h */ case   12:  		/* cmplwi CR6, R26, 0 */
		/* 820B3D48h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820B3D48h case   12:*/		return 0x820B3D4C;
		  /* 820B3D4Ch */ case   13:  		/* bc 12, CR6_EQ, 160 */
		/* 820B3D4Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820B3DEC;  }
		/* 820B3D4Ch case   13:*/		return 0x820B3D50;
		  /* 820B3D50h */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 820B3D50h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3D50h case   14:*/		return 0x820B3D54;
		  /* 820B3D54h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 820B3D54h case   15:*/		if ( regs.CR[6].eq ) { return 0x820B3D74;  }
		/* 820B3D54h case   15:*/		return 0x820B3D58;
		  /* 820B3D58h */ case   16:  		/* addi R11, R25, -4 */
		/* 820B3D58h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFFC);
		/* 820B3D58h case   16:*/		return 0x820B3D5C;
		  /* 820B3D5Ch */ case   17:  		/* mr R10, R27 */
		/* 820B3D5Ch case   17:*/		regs.R10 = regs.R27;
		/* 820B3D5Ch case   17:*/		return 0x820B3D60;
		  /* 820B3D60h */ case   18:  		/* cmplwi CR0, R30, 0 */
		/* 820B3D60h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B3D60h case   18:*/		return 0x820B3D64;
		  /* 820B3D64h */ case   19:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3D64h case   19:*/		if ( regs.CR[0].eq ) { return 0x820B3D74;  }
		/* 820B3D64h case   19:*/		return 0x820B3D68;
		  /* 820B3D68h */ case   20:  		/* mtspr CTR, R30 */
		/* 820B3D68h case   20:*/		regs.CTR = regs.R30;
		/* 820B3D68h case   20:*/		return 0x820B3D6C;
		  /* 820B3D6Ch */ case   21:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3D6Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3D6Ch case   21:*/		return 0x820B3D70;
		  /* 820B3D70h */ case   22:  		/* bc 16, CR0_LT, -4 */
		/* 820B3D70h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3D6C;  }
		/* 820B3D70h case   22:*/		return 0x820B3D74;
	}
	return 0x820B3D74;
} // Block from 820B3D18h-820B3D74h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820B3D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3D74);
		  /* 820B3D74h */ case    0:  		/* li R9, 0 */
		/* 820B3D74h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3D74h case    0:*/		return 0x820B3D78;
		  /* 820B3D78h */ case    1:  		/* li R8, 0 */
		/* 820B3D78h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B3D78h case    1:*/		return 0x820B3D7C;
		  /* 820B3D7Ch */ case    2:  		/* mr R7, R19 */
		/* 820B3D7Ch case    2:*/		regs.R7 = regs.R19;
		/* 820B3D7Ch case    2:*/		return 0x820B3D80;
		  /* 820B3D80h */ case    3:  		/* mr R5, R28 */
		/* 820B3D80h case    3:*/		regs.R5 = regs.R28;
		/* 820B3D80h case    3:*/		return 0x820B3D84;
		  /* 820B3D84h */ case    4:  		/* b 76 */
		/* 820B3D84h case    4:*/		return 0x820B3DD0;
		/* 820B3D84h case    4:*/		return 0x820B3D88;
		  /* 820B3D88h */ case    5:  		/* rlwinm. R11, R26, 0, 31, 31 */
		/* 820B3D88h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R26);
		/* 820B3D88h case    5:*/		return 0x820B3D8C;
		  /* 820B3D8Ch */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 820B3D8Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820B3DB8;  }
		/* 820B3D8Ch case    6:*/		return 0x820B3D90;
		  /* 820B3D90h */ case    7:  		/* li R9, 0 */
		/* 820B3D90h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3D90h case    7:*/		return 0x820B3D94;
		  /* 820B3D94h */ case    8:  		/* mr R8, R25 */
		/* 820B3D94h case    8:*/		regs.R8 = regs.R25;
		/* 820B3D94h case    8:*/		return 0x820B3D98;
		  /* 820B3D98h */ case    9:  		/* mr R7, R21 */
		/* 820B3D98h case    9:*/		regs.R7 = regs.R21;
		/* 820B3D98h case    9:*/		return 0x820B3D9C;
		  /* 820B3D9Ch */ case   10:  		/* mr R6, R21 */
		/* 820B3D9Ch case   10:*/		regs.R6 = regs.R21;
		/* 820B3D9Ch case   10:*/		return 0x820B3DA0;
		  /* 820B3DA0h */ case   11:  		/* oris R5, R29, 8272 */
		/* 820B3DA0h case   11:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R29,0x2050);
		/* 820B3DA0h case   11:*/		return 0x820B3DA4;
		  /* 820B3DA4h */ case   12:  		/* mr R4, R20 */
		/* 820B3DA4h case   12:*/		regs.R4 = regs.R20;
		/* 820B3DA4h case   12:*/		return 0x820B3DA8;
		  /* 820B3DA8h */ case   13:  		/* mr R3, R23 */
		/* 820B3DA8h case   13:*/		regs.R3 = regs.R23;
		/* 820B3DA8h case   13:*/		return 0x820B3DAC;
		  /* 820B3DACh */ case   14:  		/* bl -12964 */
		/* 820B3DACh case   14:*/		regs.LR = 0x820B3DB0; return 0x820B0B08;
		/* 820B3DACh case   14:*/		return 0x820B3DB0;
		  /* 820B3DB0h */ case   15:  		/* or. R31, R3, R3 */
		/* 820B3DB0h case   15:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3DB0h case   15:*/		return 0x820B3DB4;
		  /* 820B3DB4h */ case   16:  		/* bc 12, CR0_LT, 552 */
		/* 820B3DB4h case   16:*/		if ( regs.CR[0].lt ) { return 0x820B3FDC;  }
		/* 820B3DB4h case   16:*/		return 0x820B3DB8;
	}
	return 0x820B3DB8;
} // Block from 820B3D74h-820B3DB8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B3DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3DB8);
		  /* 820B3DB8h */ case    0:  		/* rlwinm. R26, R26, 31, 1, 31 */
		/* 820B3DB8h case    0:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R26,regs.R26);
		/* 820B3DB8h case    0:*/		return 0x820B3DBC;
		  /* 820B3DBCh */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 820B3DBCh case    1:*/		if ( regs.CR[0].eq ) { return 0x820B3DEC;  }
		/* 820B3DBCh case    1:*/		return 0x820B3DC0;
		  /* 820B3DC0h */ case    2:  		/* li R9, 4 */
		/* 820B3DC0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B3DC0h case    2:*/		return 0x820B3DC4;
		  /* 820B3DC4h */ case    3:  		/* mr R8, R25 */
		/* 820B3DC4h case    3:*/		regs.R8 = regs.R25;
		/* 820B3DC4h case    3:*/		return 0x820B3DC8;
		  /* 820B3DC8h */ case    4:  		/* mr R7, R25 */
		/* 820B3DC8h case    4:*/		regs.R7 = regs.R25;
		/* 820B3DC8h case    4:*/		return 0x820B3DCC;
		  /* 820B3DCCh */ case    5:  		/* oris R5, R29, 8272 */
		/* 820B3DCCh case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R29,0x2050);
		/* 820B3DCCh case    5:*/		return 0x820B3DD0;
	}
	return 0x820B3DD0;
} // Block from 820B3DB8h-820B3DD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B3DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3DD0);
		  /* 820B3DD0h */ case    0:  		/* mr R6, R25 */
		/* 820B3DD0h case    0:*/		regs.R6 = regs.R25;
		/* 820B3DD0h case    0:*/		return 0x820B3DD4;
		  /* 820B3DD4h */ case    1:  		/* mr R4, R20 */
		/* 820B3DD4h case    1:*/		regs.R4 = regs.R20;
		/* 820B3DD4h case    1:*/		return 0x820B3DD8;
		  /* 820B3DD8h */ case    2:  		/* mr R3, R23 */
		/* 820B3DD8h case    2:*/		regs.R3 = regs.R23;
		/* 820B3DD8h case    2:*/		return 0x820B3DDC;
		  /* 820B3DDCh */ case    3:  		/* bl -13012 */
		/* 820B3DDCh case    3:*/		regs.LR = 0x820B3DE0; return 0x820B0B08;
		/* 820B3DDCh case    3:*/		return 0x820B3DE0;
		  /* 820B3DE0h */ case    4:  		/* or. R31, R3, R3 */
		/* 820B3DE0h case    4:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3DE0h case    4:*/		return 0x820B3DE4;
		  /* 820B3DE4h */ case    5:  		/* bc 4, CR0_LT, -92 */
		/* 820B3DE4h case    5:*/		if ( !regs.CR[0].lt ) { return 0x820B3D88;  }
		/* 820B3DE4h case    5:*/		return 0x820B3DE8;
		  /* 820B3DE8h */ case    6:  		/* b 500 */
		/* 820B3DE8h case    6:*/		return 0x820B3FDC;
		/* 820B3DE8h case    6:*/		return 0x820B3DEC;
	}
	return 0x820B3DEC;
} // Block from 820B3DD0h-820B3DECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B3DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3DEC);
		  /* 820B3DECh */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 820B3DECh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820B3DECh case    0:*/		return 0x820B3DF0;
		  /* 820B3DF0h */ case    1:  		/* bc 4, CR6_LT, 172 */
		/* 820B3DF0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820B3E9C;  }
		/* 820B3DF0h case    1:*/		return 0x820B3DF4;
		  /* 820B3DF4h */ case    2:  		/* li R9, 0 */
		/* 820B3DF4h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3DF4h case    2:*/		return 0x820B3DF8;
		  /* 820B3DF8h */ case    3:  		/* oris R5, R29, 4144 */
		/* 820B3DF8h case    3:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R29,0x1030);
		/* 820B3DF8h case    3:*/		return 0x820B3DFC;
		  /* 820B3DFCh */ case    4:  		/* b 128 */
		/* 820B3DFCh case    4:*/		return 0x820B3E7C;
		/* 820B3DFCh case    4:*/		return 0x820B3E00;
	}
	return 0x820B3E00;
} // Block from 820B3DECh-820B3E00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B3E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3E00);
		  /* 820B3E00h */ case    0:  		/* fabs FR12, FR31 */
		/* 820B3E00h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR12,regs.FR31);
		/* 820B3E00h case    0:*/		return 0x820B3E04;
		  /* 820B3E04h */ case    1:  		/* lis R11, -32256 */
		/* 820B3E04h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820B3E04h case    1:*/		return 0x820B3E08;
		  /* 820B3E08h */ case    2:  		/* lfd FR13, <#[R11 + 4736]> */
		/* 820B3E08h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00001280) );
		/* 820B3E08h case    2:*/		return 0x820B3E0C;
		  /* 820B3E0Ch */ case    3:  		/* fsub FR13, FR12, FR13 */
		/* 820B3E0Ch case    3:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 820B3E0Ch case    3:*/		return 0x820B3E10;
		  /* 820B3E10h */ case    4:  		/* fabs FR13, FR13 */
		/* 820B3E10h case    4:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR13);
		/* 820B3E10h case    4:*/		return 0x820B3E14;
		  /* 820B3E14h */ case    5:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B3E14h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B3E14h case    5:*/		return 0x820B3E18;
		  /* 820B3E18h */ case    6:  		/* bc 4, CR6_LT, 140 */
		/* 820B3E18h case    6:*/		if ( !regs.CR[6].lt ) { return 0x820B3EA4;  }
		/* 820B3E18h case    6:*/		return 0x820B3E1C;
		  /* 820B3E1Ch */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 820B3E1Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3E1Ch case    7:*/		return 0x820B3E20;
		  /* 820B3E20h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 820B3E20h case    8:*/		if ( regs.CR[6].eq ) { return 0x820B3E40;  }
		/* 820B3E20h case    8:*/		return 0x820B3E24;
		  /* 820B3E24h */ case    9:  		/* addi R11, R21, -4 */
		/* 820B3E24h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0xFFFFFFFC);
		/* 820B3E24h case    9:*/		return 0x820B3E28;
		  /* 820B3E28h */ case   10:  		/* li R10, -1 */
		/* 820B3E28h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820B3E28h case   10:*/		return 0x820B3E2C;
		  /* 820B3E2Ch */ case   11:  		/* cmplwi CR0, R30, 0 */
		/* 820B3E2Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B3E2Ch case   11:*/		return 0x820B3E30;
		  /* 820B3E30h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3E30h case   12:*/		if ( regs.CR[0].eq ) { return 0x820B3E40;  }
		/* 820B3E30h case   12:*/		return 0x820B3E34;
		  /* 820B3E34h */ case   13:  		/* mtspr CTR, R30 */
		/* 820B3E34h case   13:*/		regs.CTR = regs.R30;
		/* 820B3E34h case   13:*/		return 0x820B3E38;
		  /* 820B3E38h */ case   14:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3E38h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3E38h case   14:*/		return 0x820B3E3C;
		  /* 820B3E3Ch */ case   15:  		/* bc 16, CR0_LT, -4 */
		/* 820B3E3Ch case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3E38;  }
		/* 820B3E3Ch case   15:*/		return 0x820B3E40;
	}
	return 0x820B3E40;
} // Block from 820B3E00h-820B3E40h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B3E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3E40);
		  /* 820B3E40h */ case    0:  		/* rlwinm R30, R30, 0, 12, 31 */
		/* 820B3E40h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R30);
		/* 820B3E40h case    0:*/		return 0x820B3E44;
		  /* 820B3E44h */ case    1:  		/* li R9, 4 */
		/* 820B3E44h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B3E44h case    1:*/		return 0x820B3E48;
		  /* 820B3E48h */ case    2:  		/* li R8, 0 */
		/* 820B3E48h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B3E48h case    2:*/		return 0x820B3E4C;
		  /* 820B3E4Ch */ case    3:  		/* mr R7, R19 */
		/* 820B3E4Ch case    3:*/		regs.R7 = regs.R19;
		/* 820B3E4Ch case    3:*/		return 0x820B3E50;
		  /* 820B3E50h */ case    4:  		/* mr R6, R21 */
		/* 820B3E50h case    4:*/		regs.R6 = regs.R21;
		/* 820B3E50h case    4:*/		return 0x820B3E54;
		  /* 820B3E54h */ case    5:  		/* oris R5, R30, 4208 */
		/* 820B3E54h case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1070);
		/* 820B3E54h case    5:*/		return 0x820B3E58;
		  /* 820B3E58h */ case    6:  		/* mr R4, R20 */
		/* 820B3E58h case    6:*/		regs.R4 = regs.R20;
		/* 820B3E58h case    6:*/		return 0x820B3E5C;
		  /* 820B3E5Ch */ case    7:  		/* mr R3, R23 */
		/* 820B3E5Ch case    7:*/		regs.R3 = regs.R23;
		/* 820B3E5Ch case    7:*/		return 0x820B3E60;
		  /* 820B3E60h */ case    8:  		/* bl -13144 */
		/* 820B3E60h case    8:*/		regs.LR = 0x820B3E64; return 0x820B0B08;
		/* 820B3E60h case    8:*/		return 0x820B3E64;
		  /* 820B3E64h */ case    9:  		/* or. R31, R3, R3 */
		/* 820B3E64h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3E64h case    9:*/		return 0x820B3E68;
		  /* 820B3E68h */ case   10:  		/* bc 12, CR0_LT, 372 */
		/* 820B3E68h case   10:*/		if ( regs.CR[0].lt ) { return 0x820B3FDC;  }
		/* 820B3E68h case   10:*/		return 0x820B3E6C;
		  /* 820B3E6Ch */ case   11:  		/* fcmpu CR6, FR31, FR30 */
		/* 820B3E6Ch case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR30);
		/* 820B3E6Ch case   11:*/		return 0x820B3E70;
		  /* 820B3E70h */ case   12:  		/* bc 12, CR6_LT, 44 */
		/* 820B3E70h case   12:*/		if ( regs.CR[6].lt ) { return 0x820B3E9C;  }
		/* 820B3E70h case   12:*/		return 0x820B3E74;
		  /* 820B3E74h */ case   13:  		/* li R9, 4 */
		/* 820B3E74h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B3E74h case   13:*/		return 0x820B3E78;
		  /* 820B3E78h */ case   14:  		/* oris R5, R30, 4144 */
		/* 820B3E78h case   14:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1030);
		/* 820B3E78h case   14:*/		return 0x820B3E7C;
	}
	return 0x820B3E7C;
} // Block from 820B3E40h-820B3E7Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B3E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3E7C);
		  /* 820B3E7Ch */ case    0:  		/* mr R7, R21 */
		/* 820B3E7Ch case    0:*/		regs.R7 = regs.R21;
		/* 820B3E7Ch case    0:*/		return 0x820B3E80;
	}
	return 0x820B3E80;
} // Block from 820B3E7Ch-820B3E80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B3E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3E80);
		  /* 820B3E80h */ case    0:  		/* li R8, 0 */
		/* 820B3E80h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B3E80h case    0:*/		return 0x820B3E84;
		  /* 820B3E84h */ case    1:  		/* mr R6, R21 */
		/* 820B3E84h case    1:*/		regs.R6 = regs.R21;
		/* 820B3E84h case    1:*/		return 0x820B3E88;
		  /* 820B3E88h */ case    2:  		/* mr R4, R20 */
		/* 820B3E88h case    2:*/		regs.R4 = regs.R20;
		/* 820B3E88h case    2:*/		return 0x820B3E8C;
		  /* 820B3E8Ch */ case    3:  		/* mr R3, R23 */
		/* 820B3E8Ch case    3:*/		regs.R3 = regs.R23;
		/* 820B3E8Ch case    3:*/		return 0x820B3E90;
		  /* 820B3E90h */ case    4:  		/* bl -13192 */
		/* 820B3E90h case    4:*/		regs.LR = 0x820B3E94; return 0x820B0B08;
		/* 820B3E90h case    4:*/		return 0x820B3E94;
		  /* 820B3E94h */ case    5:  		/* or. R31, R3, R3 */
		/* 820B3E94h case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3E94h case    5:*/		return 0x820B3E98;
		  /* 820B3E98h */ case    6:  		/* bc 12, CR0_LT, 324 */
		/* 820B3E98h case    6:*/		if ( regs.CR[0].lt ) { return 0x820B3FDC;  }
		/* 820B3E98h case    6:*/		return 0x820B3E9C;
	}
	return 0x820B3E9C;
} // Block from 820B3E80h-820B3E9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B3E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3E9C);
		  /* 820B3E9Ch */ case    0:  		/* li R31, 0 */
		/* 820B3E9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B3E9Ch case    0:*/		return 0x820B3EA0;
		  /* 820B3EA0h */ case    1:  		/* b 316 */
		/* 820B3EA0h case    1:*/		return 0x820B3FDC;
		/* 820B3EA0h case    1:*/		return 0x820B3EA4;
	}
	return 0x820B3EA4;
} // Block from 820B3E9Ch-820B3EA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B3EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3EA4);
		  /* 820B3EA4h */ case    0:  		/* lis R4, 9345 */
		/* 820B3EA4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3EA4h case    0:*/		return 0x820B3EA8;
		  /* 820B3EA8h */ case    1:  		/* rlwinm R3, R30, 3, 0, 28 */
		/* 820B3EA8h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R30);
		/* 820B3EA8h case    1:*/		return 0x820B3EAC;
		  /* 820B3EACh */ case    2:  		/* bl -179372 */
		/* 820B3EACh case    2:*/		regs.LR = 0x820B3EB0; return 0x82088200;
		/* 820B3EACh case    2:*/		return 0x820B3EB0;
		  /* 820B3EB0h */ case    3:  		/* or. R25, R3, R3 */
		/* 820B3EB0h case    3:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820B3EB0h case    3:*/		return 0x820B3EB4;
		  /* 820B3EB4h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 820B3EB4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820B3EC4;  }
		/* 820B3EB4h case    4:*/		return 0x820B3EB8;
	}
	return 0x820B3EB8;
} // Block from 820B3EA4h-820B3EB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B3EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3EB8);
		  /* 820B3EB8h */ case    0:  		/* lis R31, -32761 */
		/* 820B3EB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820B3EB8h case    0:*/		return 0x820B3EBC;
		  /* 820B3EBCh */ case    1:  		/* ori R31, R31, 14 */
		/* 820B3EBCh case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820B3EBCh case    1:*/		return 0x820B3EC0;
		  /* 820B3EC0h */ case    2:  		/* b 284 */
		/* 820B3EC0h case    2:*/		return 0x820B3FDC;
		/* 820B3EC0h case    2:*/		return 0x820B3EC4;
	}
	return 0x820B3EC4;
} // Block from 820B3EB8h-820B3EC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B3EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3EC4);
		  /* 820B3EC4h */ case    0:  		/* li R10, 2 */
		/* 820B3EC4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820B3EC4h case    0:*/		return 0x820B3EC8;
		  /* 820B3EC8h */ case    1:  		/* addi R11, R1, 80 */
		/* 820B3EC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B3EC8h case    1:*/		return 0x820B3ECC;
		  /* 820B3ECCh */ case    2:  		/* rlwinm R8, R30, 2, 0, 29 */
		/* 820B3ECCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R30);
		/* 820B3ECCh case    2:*/		return 0x820B3ED0;
		  /* 820B3ED0h */ case    3:  		/* addi R9, R11, -4 */
		/* 820B3ED0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B3ED0h case    3:*/		return 0x820B3ED4;
		  /* 820B3ED4h */ case    4:  		/* mr R11, R25 */
		/* 820B3ED4h case    4:*/		regs.R11 = regs.R25;
		/* 820B3ED4h case    4:*/		return 0x820B3ED8;
		  /* 820B3ED8h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B3ED8h case    5:*/		regs.CTR = regs.R10;
		/* 820B3ED8h case    5:*/		return 0x820B3EDC;
		  /* 820B3EDCh */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B3EDCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B3EDCh case    6:*/		return 0x820B3EE0;
		  /* 820B3EE0h */ case    7:  		/* add R11, R11, R8 */
		/* 820B3EE0h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820B3EE0h case    7:*/		return 0x820B3EE4;
		  /* 820B3EE4h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B3EE4h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3EDC;  }
		/* 820B3EE4h case    8:*/		return 0x820B3EE8;
		  /* 820B3EE8h */ case    9:  		/* lwz R28, <#[R1 + 80]> */
		/* 820B3EE8h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 820B3EE8h case    9:*/		return 0x820B3EEC;
		  /* 820B3EECh */ case   10:  		/* li R27, -1 */
		/* 820B3EECh case   10:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 820B3EECh case   10:*/		return 0x820B3EF0;
		  /* 820B3EF0h */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 820B3EF0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3EF0h case   11:*/		return 0x820B3EF4;
		  /* 820B3EF4h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 820B3EF4h case   12:*/		if ( regs.CR[6].eq ) { return 0x820B3F14;  }
		/* 820B3EF4h case   12:*/		return 0x820B3EF8;
		  /* 820B3EF8h */ case   13:  		/* addi R11, R28, -4 */
		/* 820B3EF8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFC);
		/* 820B3EF8h case   13:*/		return 0x820B3EFC;
		  /* 820B3EFCh */ case   14:  		/* mr R10, R27 */
		/* 820B3EFCh case   14:*/		regs.R10 = regs.R27;
		/* 820B3EFCh case   14:*/		return 0x820B3F00;
		  /* 820B3F00h */ case   15:  		/* cmplwi CR0, R30, 0 */
		/* 820B3F00h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B3F00h case   15:*/		return 0x820B3F04;
		  /* 820B3F04h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3F04h case   16:*/		if ( regs.CR[0].eq ) { return 0x820B3F14;  }
		/* 820B3F04h case   16:*/		return 0x820B3F08;
		  /* 820B3F08h */ case   17:  		/* mtspr CTR, R30 */
		/* 820B3F08h case   17:*/		regs.CTR = regs.R30;
		/* 820B3F08h case   17:*/		return 0x820B3F0C;
		  /* 820B3F0Ch */ case   18:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3F0Ch case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3F0Ch case   18:*/		return 0x820B3F10;
		  /* 820B3F10h */ case   19:  		/* bc 16, CR0_LT, -4 */
		/* 820B3F10h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3F0C;  }
		/* 820B3F10h case   19:*/		return 0x820B3F14;
	}
	return 0x820B3F14;
} // Block from 820B3EC4h-820B3F14h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820B3F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3F14);
		  /* 820B3F14h */ case    0:  		/* lwz R29, <#[R1 + 84]> */
		/* 820B3F14h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 820B3F14h case    0:*/		return 0x820B3F18;
		  /* 820B3F18h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 820B3F18h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3F18h case    1:*/		return 0x820B3F1C;
		  /* 820B3F1Ch */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820B3F1Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820B3F60;  }
		/* 820B3F1Ch case    2:*/		return 0x820B3F20;
		  /* 820B3F20h */ case    3:  		/* addi R11, R29, -4 */
		/* 820B3F20h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820B3F20h case    3:*/		return 0x820B3F24;
		  /* 820B3F24h */ case    4:  		/* mr R10, R27 */
		/* 820B3F24h case    4:*/		regs.R10 = regs.R27;
		/* 820B3F24h case    4:*/		return 0x820B3F28;
		  /* 820B3F28h */ case    5:  		/* cmplwi CR0, R30, 0 */
		/* 820B3F28h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B3F28h case    5:*/		return 0x820B3F2C;
		  /* 820B3F2Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3F2Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820B3F3C;  }
		/* 820B3F2Ch case    6:*/		return 0x820B3F30;
		  /* 820B3F30h */ case    7:  		/* mtspr CTR, R30 */
		/* 820B3F30h case    7:*/		regs.CTR = regs.R30;
		/* 820B3F30h case    7:*/		return 0x820B3F34;
		  /* 820B3F34h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3F34h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3F34h case    8:*/		return 0x820B3F38;
		  /* 820B3F38h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820B3F38h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3F34;  }
		/* 820B3F38h case    9:*/		return 0x820B3F3C;
	}
	return 0x820B3F3C;
} // Block from 820B3F14h-820B3F3Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B3F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3F3C);
		  /* 820B3F3Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820B3F3Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B3F3Ch case    0:*/		return 0x820B3F40;
		  /* 820B3F40h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820B3F40h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B3F60;  }
		/* 820B3F40h case    1:*/		return 0x820B3F44;
		  /* 820B3F44h */ case    2:  		/* addi R11, R21, -4 */
		/* 820B3F44h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0xFFFFFFFC);
		/* 820B3F44h case    2:*/		return 0x820B3F48;
		  /* 820B3F48h */ case    3:  		/* mr R10, R27 */
		/* 820B3F48h case    3:*/		regs.R10 = regs.R27;
		/* 820B3F48h case    3:*/		return 0x820B3F4C;
		  /* 820B3F4Ch */ case    4:  		/* cmplwi CR0, R30, 0 */
		/* 820B3F4Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820B3F4Ch case    4:*/		return 0x820B3F50;
		  /* 820B3F50h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B3F50h case    5:*/		if ( regs.CR[0].eq ) { return 0x820B3F60;  }
		/* 820B3F50h case    5:*/		return 0x820B3F54;
		  /* 820B3F54h */ case    6:  		/* mtspr CTR, R30 */
		/* 820B3F54h case    6:*/		regs.CTR = regs.R30;
		/* 820B3F54h case    6:*/		return 0x820B3F58;
		  /* 820B3F58h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B3F58h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B3F58h case    7:*/		return 0x820B3F5C;
		  /* 820B3F5Ch */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B3F5Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B3F58;  }
		/* 820B3F5Ch case    8:*/		return 0x820B3F60;
	}
	return 0x820B3F60;
} // Block from 820B3F3Ch-820B3F60h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B3F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3F60);
		  /* 820B3F60h */ case    0:  		/* rlwinm R30, R30, 0, 12, 31 */
		/* 820B3F60h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R30);
		/* 820B3F60h case    0:*/		return 0x820B3F64;
		  /* 820B3F64h */ case    1:  		/* li R9, 0 */
		/* 820B3F64h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3F64h case    1:*/		return 0x820B3F68;
		  /* 820B3F68h */ case    2:  		/* li R8, 0 */
		/* 820B3F68h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B3F68h case    2:*/		return 0x820B3F6C;
		  /* 820B3F6Ch */ case    3:  		/* mr R7, R19 */
		/* 820B3F6Ch case    3:*/		regs.R7 = regs.R19;
		/* 820B3F6Ch case    3:*/		return 0x820B3F70;
		  /* 820B3F70h */ case    4:  		/* mr R6, R28 */
		/* 820B3F70h case    4:*/		regs.R6 = regs.R28;
		/* 820B3F70h case    4:*/		return 0x820B3F74;
		  /* 820B3F74h */ case    5:  		/* oris R5, R30, 4192 */
		/* 820B3F74h case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1060);
		/* 820B3F74h case    5:*/		return 0x820B3F78;
		  /* 820B3F78h */ case    6:  		/* mr R4, R20 */
		/* 820B3F78h case    6:*/		regs.R4 = regs.R20;
		/* 820B3F78h case    6:*/		return 0x820B3F7C;
		  /* 820B3F7Ch */ case    7:  		/* mr R3, R23 */
		/* 820B3F7Ch case    7:*/		regs.R3 = regs.R23;
		/* 820B3F7Ch case    7:*/		return 0x820B3F80;
		  /* 820B3F80h */ case    8:  		/* bl -13432 */
		/* 820B3F80h case    8:*/		regs.LR = 0x820B3F84; return 0x820B0B08;
		/* 820B3F80h case    8:*/		return 0x820B3F84;
		  /* 820B3F84h */ case    9:  		/* or. R31, R3, R3 */
		/* 820B3F84h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3F84h case    9:*/		return 0x820B3F88;
		  /* 820B3F88h */ case   10:  		/* bc 12, CR0_LT, 84 */
		/* 820B3F88h case   10:*/		if ( regs.CR[0].lt ) { return 0x820B3FDC;  }
		/* 820B3F88h case   10:*/		return 0x820B3F8C;
		  /* 820B3F8Ch */ case   11:  		/* li R9, 0 */
		/* 820B3F8Ch case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B3F8Ch case   11:*/		return 0x820B3F90;
		  /* 820B3F90h */ case   12:  		/* mr R8, R28 */
		/* 820B3F90h case   12:*/		regs.R8 = regs.R28;
		/* 820B3F90h case   12:*/		return 0x820B3F94;
		  /* 820B3F94h */ case   13:  		/* mr R7, R22 */
		/* 820B3F94h case   13:*/		regs.R7 = regs.R22;
		/* 820B3F94h case   13:*/		return 0x820B3F98;
		  /* 820B3F98h */ case   14:  		/* mr R6, R29 */
		/* 820B3F98h case   14:*/		regs.R6 = regs.R29;
		/* 820B3F98h case   14:*/		return 0x820B3F9C;
		  /* 820B3F9Ch */ case   15:  		/* oris R5, R30, 8272 */
		/* 820B3F9Ch case   15:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2050);
		/* 820B3F9Ch case   15:*/		return 0x820B3FA0;
		  /* 820B3FA0h */ case   16:  		/* mr R4, R20 */
		/* 820B3FA0h case   16:*/		regs.R4 = regs.R20;
		/* 820B3FA0h case   16:*/		return 0x820B3FA4;
		  /* 820B3FA4h */ case   17:  		/* mr R3, R23 */
		/* 820B3FA4h case   17:*/		regs.R3 = regs.R23;
		/* 820B3FA4h case   17:*/		return 0x820B3FA8;
		  /* 820B3FA8h */ case   18:  		/* bl -13472 */
		/* 820B3FA8h case   18:*/		regs.LR = 0x820B3FAC; return 0x820B0B08;
		/* 820B3FA8h case   18:*/		return 0x820B3FAC;
		  /* 820B3FACh */ case   19:  		/* or. R31, R3, R3 */
		/* 820B3FACh case   19:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B3FACh case   19:*/		return 0x820B3FB0;
		  /* 820B3FB0h */ case   20:  		/* bc 12, CR0_LT, 44 */
		/* 820B3FB0h case   20:*/		if ( regs.CR[0].lt ) { return 0x820B3FDC;  }
		/* 820B3FB0h case   20:*/		return 0x820B3FB4;
		  /* 820B3FB4h */ case   21:  		/* li R9, 4 */
		/* 820B3FB4h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B3FB4h case   21:*/		return 0x820B3FB8;
	}
	return 0x820B3FB8;
} // Block from 820B3F60h-820B3FB8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B3FB8h
// Function '?EmitLerp@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAI111I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3FB8);
		  /* 820B3FB8h */ case    0:  		/* li R8, 0 */
		/* 820B3FB8h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B3FB8h case    0:*/		return 0x820B3FBC;
		  /* 820B3FBCh */ case    1:  		/* mr R7, R29 */
		/* 820B3FBCh case    1:*/		regs.R7 = regs.R29;
		/* 820B3FBCh case    1:*/		return 0x820B3FC0;
		  /* 820B3FC0h */ case    2:  		/* mr R6, R21 */
		/* 820B3FC0h case    2:*/		regs.R6 = regs.R21;
		/* 820B3FC0h case    2:*/		return 0x820B3FC4;
		  /* 820B3FC4h */ case    3:  		/* oris R5, R30, 4176 */
		/* 820B3FC4h case    3:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1050);
		/* 820B3FC4h case    3:*/		return 0x820B3FC8;
		  /* 820B3FC8h */ case    4:  		/* mr R4, R20 */
		/* 820B3FC8h case    4:*/		regs.R4 = regs.R20;
		/* 820B3FC8h case    4:*/		return 0x820B3FCC;
		  /* 820B3FCCh */ case    5:  		/* mr R3, R23 */
		/* 820B3FCCh case    5:*/		regs.R3 = regs.R23;
		/* 820B3FCCh case    5:*/		return 0x820B3FD0;
		  /* 820B3FD0h */ case    6:  		/* bl -13512 */
		/* 820B3FD0h case    6:*/		regs.LR = 0x820B3FD4; return 0x820B0B08;
		/* 820B3FD0h case    6:*/		return 0x820B3FD4;
		  /* 820B3FD4h */ case    7:  		/* srawi R11, R3, 31 */
		/* 820B3FD4h case    7:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820B3FD4h case    7:*/		return 0x820B3FD8;
		  /* 820B3FD8h */ case    8:  		/* and R31, R11, R3 */
		/* 820B3FD8h case    8:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R3);
		/* 820B3FD8h case    8:*/		return 0x820B3FDC;
	}
	return 0x820B3FDC;
} // Block from 820B3FB8h-820B3FDCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B3FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B3FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B3FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B3FDC);
		  /* 820B3FDCh */ case    0:  		/* lis R4, 9345 */
		/* 820B3FDCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B3FDCh case    0:*/		return 0x820B3FE0;
		  /* 820B3FE0h */ case    1:  		/* mr R3, R25 */
		/* 820B3FE0h case    1:*/		regs.R3 = regs.R25;
		/* 820B3FE0h case    1:*/		return 0x820B3FE4;
		  /* 820B3FE4h */ case    2:  		/* bl -179372 */
		/* 820B3FE4h case    2:*/		regs.LR = 0x820B3FE8; return 0x82088338;
		/* 820B3FE4h case    2:*/		return 0x820B3FE8;
		  /* 820B3FE8h */ case    3:  		/* mr R3, R31 */
		/* 820B3FE8h case    3:*/		regs.R3 = regs.R31;
		/* 820B3FE8h case    3:*/		return 0x820B3FEC;
		  /* 820B3FECh */ case    4:  		/* addi R1, R1, 224 */
		/* 820B3FECh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 820B3FECh case    4:*/		return 0x820B3FF0;
		  /* 820B3FF0h */ case    5:  		/* lfd FR30, <#[R1 - 128]> */
		/* 820B3FF0h case    5:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF80) );
		/* 820B3FF0h case    5:*/		return 0x820B3FF4;
		  /* 820B3FF4h */ case    6:  		/* lfd FR31, <#[R1 - 120]> */
		/* 820B3FF4h case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 820B3FF4h case    6:*/		return 0x820B3FF8;
		  /* 820B3FF8h */ case    7:  		/* b -142708 */
		/* 820B3FF8h case    7:*/		return 0x82091284;
		/* 820B3FF8h case    7:*/		return 0x820B3FFC;
		  /* 820B3FFCh */ case    8:  		/* nop */
		/* 820B3FFCh case    8:*/		cpu::op::nop();
		/* 820B3FFCh case    8:*/		return 0x820B4000;
	}
	return 0x820B4000;
} // Block from 820B3FDCh-820B4000h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B4000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4000);
		  /* 820B4000h */ case    0:  		/* mfspr R12, LR */
		/* 820B4000h case    0:*/		regs.R12 = regs.LR;
		/* 820B4000h case    0:*/		return 0x820B4004;
		  /* 820B4004h */ case    1:  		/* bl -142780 */
		/* 820B4004h case    1:*/		regs.LR = 0x820B4008; return 0x82091248;
		/* 820B4004h case    1:*/		return 0x820B4008;
		  /* 820B4008h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820B4008h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820B4008h case    2:*/		return 0x820B400C;
		  /* 820B400Ch */ case    3:  		/* mr R26, R3 */
		/* 820B400Ch case    3:*/		regs.R26 = regs.R3;
		/* 820B400Ch case    3:*/		return 0x820B4010;
		  /* 820B4010h */ case    4:  		/* mr R25, R4 */
		/* 820B4010h case    4:*/		regs.R25 = regs.R4;
		/* 820B4010h case    4:*/		return 0x820B4014;
		  /* 820B4014h */ case    5:  		/* lis R4, 9345 */
		/* 820B4014h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B4014h case    5:*/		return 0x820B4018;
		  /* 820B4018h */ case    6:  		/* mulli R3, R6, 12 */
		/* 820B4018h case    6:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R6,0xC);
		/* 820B4018h case    6:*/		return 0x820B401C;
		  /* 820B401Ch */ case    7:  		/* mr R30, R5 */
		/* 820B401Ch case    7:*/		regs.R30 = regs.R5;
		/* 820B401Ch case    7:*/		return 0x820B4020;
		  /* 820B4020h */ case    8:  		/* mr R31, R6 */
		/* 820B4020h case    8:*/		regs.R31 = regs.R6;
		/* 820B4020h case    8:*/		return 0x820B4024;
		  /* 820B4024h */ case    9:  		/* bl -179748 */
		/* 820B4024h case    9:*/		regs.LR = 0x820B4028; return 0x82088200;
		/* 820B4024h case    9:*/		return 0x820B4028;
		  /* 820B4028h */ case   10:  		/* or. R24, R3, R3 */
		/* 820B4028h case   10:*/		cpu::op::or<1>(regs,&regs.R24,regs.R3,regs.R3);
		/* 820B4028h case   10:*/		return 0x820B402C;
		  /* 820B402Ch */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 820B402Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x820B403C;  }
		/* 820B402Ch case   11:*/		return 0x820B4030;
		  /* 820B4030h */ case   12:  		/* lis R30, -32761 */
		/* 820B4030h case   12:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8007);
		/* 820B4030h case   12:*/		return 0x820B4034;
		  /* 820B4034h */ case   13:  		/* ori R30, R30, 14 */
		/* 820B4034h case   13:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xE);
		/* 820B4034h case   13:*/		return 0x820B4038;
		  /* 820B4038h */ case   14:  		/* b 352 */
		/* 820B4038h case   14:*/		return 0x820B4198;
		/* 820B4038h case   14:*/		return 0x820B403C;
	}
	return 0x820B403C;
} // Block from 820B4000h-820B403Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B403Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B403C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B403C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B403C);
		  /* 820B403Ch */ case    0:  		/* li R10, 3 */
		/* 820B403Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820B403Ch case    0:*/		return 0x820B4040;
		  /* 820B4040h */ case    1:  		/* addi R11, R1, 80 */
		/* 820B4040h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B4040h case    1:*/		return 0x820B4044;
		  /* 820B4044h */ case    2:  		/* rlwinm R8, R31, 2, 0, 29 */
		/* 820B4044h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R31);
		/* 820B4044h case    2:*/		return 0x820B4048;
		  /* 820B4048h */ case    3:  		/* addi R9, R11, -4 */
		/* 820B4048h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B4048h case    3:*/		return 0x820B404C;
		  /* 820B404Ch */ case    4:  		/* mr R11, R24 */
		/* 820B404Ch case    4:*/		regs.R11 = regs.R24;
		/* 820B404Ch case    4:*/		return 0x820B4050;
		  /* 820B4050h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B4050h case    5:*/		regs.CTR = regs.R10;
		/* 820B4050h case    5:*/		return 0x820B4054;
		  /* 820B4054h */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B4054h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B4054h case    6:*/		return 0x820B4058;
		  /* 820B4058h */ case    7:  		/* add R11, R8, R11 */
		/* 820B4058h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820B4058h case    7:*/		return 0x820B405C;
		  /* 820B405Ch */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B405Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4054;  }
		/* 820B405Ch case    8:*/		return 0x820B4060;
		  /* 820B4060h */ case    9:  		/* lwz R8, <#[R1 + 80]> */
		/* 820B4060h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4060h case    9:*/		return 0x820B4064;
		  /* 820B4064h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820B4064h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B4064h case   10:*/		return 0x820B4068;
		  /* 820B4068h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 820B4068h case   11:*/		if ( regs.CR[6].eq ) { return 0x820B4080;  }
		/* 820B4068h case   11:*/		return 0x820B406C;
		  /* 820B406Ch */ case   12:  		/* mtspr CTR, R31 */
		/* 820B406Ch case   12:*/		regs.CTR = regs.R31;
		/* 820B406Ch case   12:*/		return 0x820B4070;
		  /* 820B4070h */ case   13:  		/* addi R11, R8, -4 */
		/* 820B4070h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFC);
		/* 820B4070h case   13:*/		return 0x820B4074;
		  /* 820B4074h */ case   14:  		/* lwz R10, <#[R26 + 44]> */
		/* 820B4074h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000002C) );
		/* 820B4074h case   14:*/		return 0x820B4078;
		  /* 820B4078h */ case   15:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B4078h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B4078h case   15:*/		return 0x820B407C;
		  /* 820B407Ch */ case   16:  		/* bc 16, CR0_LT, -8 */
		/* 820B407Ch case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4074;  }
		/* 820B407Ch case   16:*/		return 0x820B4080;
	}
	return 0x820B4080;
} // Block from 820B403Ch-820B4080h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820B4080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4080);
		  /* 820B4080h */ case    0:  		/* lwz R28, <#[R1 + 84]> */
		/* 820B4080h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820B4080h case    0:*/		return 0x820B4084;
		  /* 820B4084h */ case    1:  		/* li R10, -1 */
		/* 820B4084h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820B4084h case    1:*/		return 0x820B4088;
		  /* 820B4088h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820B4088h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B4088h case    2:*/		return 0x820B408C;
		  /* 820B408Ch */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820B408Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820B40A8;  }
		/* 820B408Ch case    3:*/		return 0x820B4090;
		  /* 820B4090h */ case    4:  		/* addi R11, R28, -4 */
		/* 820B4090h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFC);
		/* 820B4090h case    4:*/		return 0x820B4094;
		  /* 820B4094h */ case    5:  		/* cmplwi CR0, R31, 0 */
		/* 820B4094h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B4094h case    5:*/		return 0x820B4098;
		  /* 820B4098h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820B4098h case    6:*/		if ( regs.CR[0].eq ) { return 0x820B40A8;  }
		/* 820B4098h case    6:*/		return 0x820B409C;
		  /* 820B409Ch */ case    7:  		/* mtspr CTR, R31 */
		/* 820B409Ch case    7:*/		regs.CTR = regs.R31;
		/* 820B409Ch case    7:*/		return 0x820B40A0;
		  /* 820B40A0h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B40A0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B40A0h case    8:*/		return 0x820B40A4;
		  /* 820B40A4h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820B40A4h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B40A0;  }
		/* 820B40A4h case    9:*/		return 0x820B40A8;
	}
	return 0x820B40A8;
} // Block from 820B4080h-820B40A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B40A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B40A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B40A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B40A8);
		  /* 820B40A8h */ case    0:  		/* lwz R27, <#[R1 + 88]> */
		/* 820B40A8h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 820B40A8h case    0:*/		return 0x820B40AC;
		  /* 820B40ACh */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820B40ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B40ACh case    1:*/		return 0x820B40B0;
		  /* 820B40B0h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820B40B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B40CC;  }
		/* 820B40B0h case    2:*/		return 0x820B40B4;
		  /* 820B40B4h */ case    3:  		/* addi R11, R27, -4 */
		/* 820B40B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFFC);
		/* 820B40B4h case    3:*/		return 0x820B40B8;
		  /* 820B40B8h */ case    4:  		/* cmplwi CR0, R31, 0 */
		/* 820B40B8h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 820B40B8h case    4:*/		return 0x820B40BC;
		  /* 820B40BCh */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820B40BCh case    5:*/		if ( regs.CR[0].eq ) { return 0x820B40CC;  }
		/* 820B40BCh case    5:*/		return 0x820B40C0;
		  /* 820B40C0h */ case    6:  		/* mtspr CTR, R31 */
		/* 820B40C0h case    6:*/		regs.CTR = regs.R31;
		/* 820B40C0h case    6:*/		return 0x820B40C4;
		  /* 820B40C4h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820B40C4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B40C4h case    7:*/		return 0x820B40C8;
		  /* 820B40C8h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820B40C8h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B40C4;  }
		/* 820B40C8h case    8:*/		return 0x820B40CC;
	}
	return 0x820B40CC;
} // Block from 820B40A8h-820B40CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B40CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B40CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B40CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B40CC);
		  /* 820B40CCh */ case    0:  		/* rlwinm R29, R31, 0, 12, 31 */
		/* 820B40CCh case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R29,regs.R31);
		/* 820B40CCh case    0:*/		return 0x820B40D0;
		  /* 820B40D0h */ case    1:  		/* li R9, 0 */
		/* 820B40D0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B40D0h case    1:*/		return 0x820B40D4;
		  /* 820B40D4h */ case    2:  		/* mr R7, R30 */
		/* 820B40D4h case    2:*/		regs.R7 = regs.R30;
		/* 820B40D4h case    2:*/		return 0x820B40D8;
		  /* 820B40D8h */ case    3:  		/* mr R6, R28 */
		/* 820B40D8h case    3:*/		regs.R6 = regs.R28;
		/* 820B40D8h case    3:*/		return 0x820B40DC;
		  /* 820B40DCh */ case    4:  		/* oris R5, R29, 8272 */
		/* 820B40DCh case    4:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R29,0x2050);
		/* 820B40DCh case    4:*/		return 0x820B40E0;
		  /* 820B40E0h */ case    5:  		/* mr R4, R25 */
		/* 820B40E0h case    5:*/		regs.R4 = regs.R25;
		/* 820B40E0h case    5:*/		return 0x820B40E4;
		  /* 820B40E4h */ case    6:  		/* mr R3, R26 */
		/* 820B40E4h case    6:*/		regs.R3 = regs.R26;
		/* 820B40E4h case    6:*/		return 0x820B40E8;
		  /* 820B40E8h */ case    7:  		/* bl -13792 */
		/* 820B40E8h case    7:*/		regs.LR = 0x820B40EC; return 0x820B0B08;
		/* 820B40E8h case    7:*/		return 0x820B40EC;
		  /* 820B40ECh */ case    8:  		/* or. R30, R3, R3 */
		/* 820B40ECh case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B40ECh case    8:*/		return 0x820B40F0;
		  /* 820B40F0h */ case    9:  		/* bc 12, CR0_LT, 168 */
		/* 820B40F0h case    9:*/		if ( regs.CR[0].lt ) { return 0x820B4198;  }
		/* 820B40F0h case    9:*/		return 0x820B40F4;
		  /* 820B40F4h */ case   10:  		/* li R9, 0 */
		/* 820B40F4h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B40F4h case   10:*/		return 0x820B40F8;
		  /* 820B40F8h */ case   11:  		/* li R8, 0 */
		/* 820B40F8h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B40F8h case   11:*/		return 0x820B40FC;
		  /* 820B40FCh */ case   12:  		/* mr R7, R28 */
		/* 820B40FCh case   12:*/		regs.R7 = regs.R28;
		/* 820B40FCh case   12:*/		return 0x820B4100;
		  /* 820B4100h */ case   13:  		/* mr R6, R27 */
		/* 820B4100h case   13:*/		regs.R6 = regs.R27;
		/* 820B4100h case   13:*/		return 0x820B4104;
		  /* 820B4104h */ case   14:  		/* oris R5, R29, 4352 */
		/* 820B4104h case   14:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R29,0x1100);
		/* 820B4104h case   14:*/		return 0x820B4108;
		  /* 820B4108h */ case   15:  		/* mr R4, R25 */
		/* 820B4108h case   15:*/		regs.R4 = regs.R25;
		/* 820B4108h case   15:*/		return 0x820B410C;
		  /* 820B410Ch */ case   16:  		/* mr R3, R26 */
		/* 820B410Ch case   16:*/		regs.R3 = regs.R26;
		/* 820B410Ch case   16:*/		return 0x820B4110;
		  /* 820B4110h */ case   17:  		/* bl -13832 */
		/* 820B4110h case   17:*/		regs.LR = 0x820B4114; return 0x820B0B08;
		/* 820B4110h case   17:*/		return 0x820B4114;
		  /* 820B4114h */ case   18:  		/* or. R30, R3, R3 */
		/* 820B4114h case   18:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B4114h case   18:*/		return 0x820B4118;
		  /* 820B4118h */ case   19:  		/* bc 12, CR0_LT, 128 */
		/* 820B4118h case   19:*/		if ( regs.CR[0].lt ) { return 0x820B4198;  }
		/* 820B4118h case   19:*/		return 0x820B411C;
		  /* 820B411Ch */ case   20:  		/* li R11, 0 */
		/* 820B411Ch case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B411Ch case   20:*/		return 0x820B4120;
		  /* 820B4120h */ case   21:  		/* cmplwi CR6, R31, 0 */
		/* 820B4120h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820B4120h case   21:*/		return 0x820B4124;
		  /* 820B4124h */ case   22:  		/* bc 12, CR6_EQ, 80 */
		/* 820B4124h case   22:*/		if ( regs.CR[6].eq ) { return 0x820B4174;  }
		/* 820B4124h case   22:*/		return 0x820B4128;
		  /* 820B4128h */ case   23:  		/* mtspr CTR, R31 */
		/* 820B4128h case   23:*/		regs.CTR = regs.R31;
		/* 820B4128h case   23:*/		return 0x820B412C;
		  /* 820B412Ch */ case   24:  		/* addi R10, R27, -4 */
		/* 820B412Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFC);
		/* 820B412Ch case   24:*/		return 0x820B4130;
		  /* 820B4130h */ case   25:  		/* lwz R8, <#[R26 + 8]> */
		/* 820B4130h case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000008) );
		/* 820B4130h case   25:*/		return 0x820B4134;
		  /* 820B4134h */ case   26:  		/* lwzu R9, <#[R10 + 4]> */
		/* 820B4134h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820B4134h case   26:*/		return 0x820B4138;
		  /* 820B4138h */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B4138h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B4138h case   27:*/		return 0x820B413C;
		  /* 820B413Ch */ case   28:  		/* lwz R7, <#[R8 + 20]> */
		/* 820B413Ch case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000014) );
		/* 820B413Ch case   28:*/		return 0x820B4140;
		  /* 820B4140h */ case   29:  		/* lwz R8, <#[R8 + 168]> */
		/* 820B4140h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x000000A8) );
		/* 820B4140h case   29:*/		return 0x820B4144;
		  /* 820B4144h */ case   30:  		/* lwzx R9, <#[R9 + R7]> */
		/* 820B4144h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 820B4144h case   30:*/		return 0x820B4148;
		  /* 820B4148h */ case   31:  		/* stw R8, <#[R9 + 4]> */
		/* 820B4148h case   31:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 820B4148h case   31:*/		return 0x820B414C;
		  /* 820B414Ch */ case   32:  		/* lwz R8, <#[R26 + 8]> */
		/* 820B414Ch case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000008) );
		/* 820B414Ch case   32:*/		return 0x820B4150;
		  /* 820B4150h */ case   33:  		/* lwz R7, <#[R8 + 16]> */
		/* 820B4150h case   33:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000010) );
		/* 820B4150h case   33:*/		return 0x820B4154;
		  /* 820B4154h */ case   34:  		/* lwz R8, <#[R8 + 168]> */
		/* 820B4154h case   34:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x000000A8) );
		/* 820B4154h case   34:*/		return 0x820B4158;
		  /* 820B4158h */ case   35:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B4158h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B4158h case   35:*/		return 0x820B415C;
		  /* 820B415Ch */ case   36:  		/* lwzx R8, <#[R8 + R7]> */
		/* 820B415Ch case   36:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820B415Ch case   36:*/		return 0x820B4160;
		  /* 820B4160h */ case   37:  		/* lwz R8, <#[R8 + 8]> */
		/* 820B4160h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 820B4160h case   37:*/		return 0x820B4164;
		  /* 820B4164h */ case   38:  		/* stw R11, <#[R9 + 16]> */
		/* 820B4164h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 820B4164h case   38:*/		return 0x820B4168;
		  /* 820B4168h */ case   39:  		/* addi R11, R11, 1 */
		/* 820B4168h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B4168h case   39:*/		return 0x820B416C;
		  /* 820B416Ch */ case   40:  		/* stw R8, <#[R9 + 12]> */
		/* 820B416Ch case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 820B416Ch case   40:*/		return 0x820B4170;
		  /* 820B4170h */ case   41:  		/* bc 16, CR0_LT, -64 */
		/* 820B4170h case   41:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4130;  }
		/* 820B4170h case   41:*/		return 0x820B4174;
	}
	return 0x820B4174;
} // Block from 820B40CCh-820B4174h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820B4174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4174);
		  /* 820B4174h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 820B4174h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820B4174h case    0:*/		return 0x820B4178;
		  /* 820B4178h */ case    1:  		/* li R30, 0 */
		/* 820B4178h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820B4178h case    1:*/		return 0x820B417C;
		  /* 820B417Ch */ case    2:  		/* lwz R10, <#[R11 + 168]> */
		/* 820B417Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000A8) );
		/* 820B417Ch case    2:*/		return 0x820B4180;
		  /* 820B4180h */ case    3:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B4180h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B4180h case    3:*/		return 0x820B4184;
		  /* 820B4184h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B4184h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B4184h case    4:*/		return 0x820B4188;
		  /* 820B4188h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820B4188h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B4188h case    5:*/		return 0x820B418C;
		  /* 820B418Ch */ case    6:  		/* lwz R10, <#[R11 + 8]> */
		/* 820B418Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B418Ch case    6:*/		return 0x820B4190;
		  /* 820B4190h */ case    7:  		/* addi R10, R10, 1 */
		/* 820B4190h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B4190h case    7:*/		return 0x820B4194;
		  /* 820B4194h */ case    8:  		/* stw R10, <#[R11 + 8]> */
		/* 820B4194h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B4194h case    8:*/		return 0x820B4198;
	}
	return 0x820B4198;
} // Block from 820B4174h-820B4198h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B4198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4198);
		  /* 820B4198h */ case    0:  		/* lis R4, 9345 */
		/* 820B4198h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B4198h case    0:*/		return 0x820B419C;
		  /* 820B419Ch */ case    1:  		/* mr R3, R24 */
		/* 820B419Ch case    1:*/		regs.R3 = regs.R24;
		/* 820B419Ch case    1:*/		return 0x820B41A0;
		  /* 820B41A0h */ case    2:  		/* bl -179816 */
		/* 820B41A0h case    2:*/		regs.LR = 0x820B41A4; return 0x82088338;
		/* 820B41A0h case    2:*/		return 0x820B41A4;
		  /* 820B41A4h */ case    3:  		/* mr R3, R30 */
		/* 820B41A4h case    3:*/		regs.R3 = regs.R30;
		/* 820B41A4h case    3:*/		return 0x820B41A8;
		  /* 820B41A8h */ case    4:  		/* addi R1, R1, 176 */
		/* 820B41A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820B41A8h case    4:*/		return 0x820B41AC;
		  /* 820B41ACh */ case    5:  		/* b -143124 */
		/* 820B41ACh case    5:*/		return 0x82091298;
		/* 820B41ACh case    5:*/		return 0x820B41B0;
	}
	return 0x820B41B0;
} // Block from 820B4198h-820B41B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B41B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B41B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B41B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B41B0);
		  /* 820B41B0h */ case    0:  		/* mfspr R12, LR */
		/* 820B41B0h case    0:*/		regs.R12 = regs.LR;
		/* 820B41B0h case    0:*/		return 0x820B41B4;
		  /* 820B41B4h */ case    1:  		/* bl -143232 */
		/* 820B41B4h case    1:*/		regs.LR = 0x820B41B8; return 0x82091234;
		/* 820B41B4h case    1:*/		return 0x820B41B8;
		  /* 820B41B8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820B41B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820B41B8h case    2:*/		return 0x820B41BC;
		  /* 820B41BCh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 820B41BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820B41BCh case    3:*/		return 0x820B41C0;
		  /* 820B41C0h */ case    4:  		/* mr R23, R4 */
		/* 820B41C0h case    4:*/		regs.R23 = regs.R4;
		/* 820B41C0h case    4:*/		return 0x820B41C4;
		  /* 820B41C4h */ case    5:  		/* mr R25, R3 */
		/* 820B41C4h case    5:*/		regs.R25 = regs.R3;
		/* 820B41C4h case    5:*/		return 0x820B41C8;
		  /* 820B41C8h */ case    6:  		/* mr R20, R5 */
		/* 820B41C8h case    6:*/		regs.R20 = regs.R5;
		/* 820B41C8h case    6:*/		return 0x820B41CC;
		  /* 820B41CCh */ case    7:  		/* mr R19, R6 */
		/* 820B41CCh case    7:*/		regs.R19 = regs.R6;
		/* 820B41CCh case    7:*/		return 0x820B41D0;
		  /* 820B41D0h */ case    8:  		/* mr R24, R7 */
		/* 820B41D0h case    8:*/		regs.R24 = regs.R7;
		/* 820B41D0h case    8:*/		return 0x820B41D4;
		  /* 820B41D4h */ case    9:  		/* lwz R11, <#[R11 + 112]> */
		/* 820B41D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000070) );
		/* 820B41D4h case    9:*/		return 0x820B41D8;
		  /* 820B41D8h */ case   10:  		/* mr R29, R8 */
		/* 820B41D8h case   10:*/		regs.R29 = regs.R8;
		/* 820B41D8h case   10:*/		return 0x820B41DC;
		  /* 820B41DCh */ case   11:  		/* lis R4, 9345 */
		/* 820B41DCh case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B41DCh case   11:*/		return 0x820B41E0;
		  /* 820B41E0h */ case   12:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 820B41E0h case   12:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 820B41E0h case   12:*/		return 0x820B41E4;
		  /* 820B41E4h */ case   13:  		/* bc 4, CR0_EQ, 308 */
		/* 820B41E4h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820B4318;  }
		/* 820B41E4h case   13:*/		return 0x820B41E8;
		  /* 820B41E8h */ case   14:  		/* rlwinm R3, R8, 3, 0, 28 */
		/* 820B41E8h case   14:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R8);
		/* 820B41E8h case   14:*/		return 0x820B41EC;
		  /* 820B41ECh */ case   15:  		/* bl -180204 */
		/* 820B41ECh case   15:*/		regs.LR = 0x820B41F0; return 0x82088200;
		/* 820B41ECh case   15:*/		return 0x820B41F0;
		  /* 820B41F0h */ case   16:  		/* or. R21, R3, R3 */
		/* 820B41F0h case   16:*/		cpu::op::or<1>(regs,&regs.R21,regs.R3,regs.R3);
		/* 820B41F0h case   16:*/		return 0x820B41F4;
		  /* 820B41F4h */ case   17:  		/* bc 12, CR0_EQ, 308 */
		/* 820B41F4h case   17:*/		if ( regs.CR[0].eq ) { return 0x820B4328;  }
		/* 820B41F4h case   17:*/		return 0x820B41F8;
		  /* 820B41F8h */ case   18:  		/* rlwinm. R8, R29, 1, 0, 30 */
		/* 820B41F8h case   18:*/		cpu::op::rlwinm<1,1,0,30>(regs,&regs.R8,regs.R29);
		/* 820B41F8h case   18:*/		return 0x820B41FC;
		  /* 820B41FCh */ case   19:  		/* li R10, 0 */
		/* 820B41FCh case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B41FCh case   19:*/		return 0x820B4200;
		  /* 820B4200h */ case   20:  		/* bc 12, CR0_EQ, 28 */
		/* 820B4200h case   20:*/		if ( regs.CR[0].eq ) { return 0x820B421C;  }
		/* 820B4200h case   20:*/		return 0x820B4204;
		  /* 820B4204h */ case   21:  		/* addi R9, R21, -4 */
		/* 820B4204h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R21,0xFFFFFFFC);
		/* 820B4204h case   21:*/		return 0x820B4208;
		  /* 820B4208h */ case   22:  		/* li R11, -1 */
		/* 820B4208h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820B4208h case   22:*/		return 0x820B420C;
		  /* 820B420Ch */ case   23:  		/* addi R10, R10, 1 */
		/* 820B420Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B420Ch case   23:*/		return 0x820B4210;
		  /* 820B4210h */ case   24:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B4210h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B4210h case   24:*/		return 0x820B4214;
		  /* 820B4214h */ case   25:  		/* cmplw CR6, R10, R8 */
		/* 820B4214h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820B4214h case   25:*/		return 0x820B4218;
		  /* 820B4218h */ case   26:  		/* bc 12, CR6_LT, -12 */
		/* 820B4218h case   26:*/		if ( regs.CR[6].lt ) { return 0x820B420C;  }
		/* 820B4218h case   26:*/		return 0x820B421C;
	}
	return 0x820B421C;
} // Block from 820B41B0h-820B421Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820B421Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B421C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B421C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B421C);
		  /* 820B421Ch */ case    0:  		/* li R10, 2 */
		/* 820B421Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820B421Ch case    0:*/		return 0x820B4220;
		  /* 820B4220h */ case    1:  		/* addi R11, R1, 80 */
		/* 820B4220h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B4220h case    1:*/		return 0x820B4224;
		  /* 820B4224h */ case    2:  		/* rlwinm R27, R29, 2, 0, 29 */
		/* 820B4224h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R29);
		/* 820B4224h case    2:*/		return 0x820B4228;
		  /* 820B4228h */ case    3:  		/* addi R9, R11, -4 */
		/* 820B4228h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B4228h case    3:*/		return 0x820B422C;
		  /* 820B422Ch */ case    4:  		/* mr R11, R21 */
		/* 820B422Ch case    4:*/		regs.R11 = regs.R21;
		/* 820B422Ch case    4:*/		return 0x820B4230;
		  /* 820B4230h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B4230h case    5:*/		regs.CTR = regs.R10;
		/* 820B4230h case    5:*/		return 0x820B4234;
		  /* 820B4234h */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B4234h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B4234h case    6:*/		return 0x820B4238;
		  /* 820B4238h */ case    7:  		/* add R11, R11, R27 */
		/* 820B4238h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 820B4238h case    7:*/		return 0x820B423C;
		  /* 820B423Ch */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B423Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4234;  }
		/* 820B423Ch case    8:*/		return 0x820B4240;
		  /* 820B4240h */ case    9:  		/* li R8, 4 */
		/* 820B4240h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 820B4240h case    9:*/		return 0x820B4244;
		  /* 820B4244h */ case   10:  		/* cmplwi CR6, R29, 0 */
		/* 820B4244h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820B4244h case   10:*/		return 0x820B4248;
		  /* 820B4248h */ case   11:  		/* bc 12, CR6_EQ, 56 */
		/* 820B4248h case   11:*/		if ( regs.CR[6].eq ) { return 0x820B4280;  }
		/* 820B4248h case   11:*/		return 0x820B424C;
		  /* 820B424Ch */ case   12:  		/* lwz R10, <#[R25 + 8]> */
		/* 820B424Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820B424Ch case   12:*/		return 0x820B4250;
		  /* 820B4250h */ case   13:  		/* addi R11, R24, -4 */
		/* 820B4250h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xFFFFFFFC);
		/* 820B4250h case   13:*/		return 0x820B4254;
		  /* 820B4254h */ case   14:  		/* mtspr CTR, R29 */
		/* 820B4254h case   14:*/		regs.CTR = regs.R29;
		/* 820B4254h case   14:*/		return 0x820B4258;
		  /* 820B4258h */ case   15:  		/* lwz R10, <#[R10 + 20]> */
		/* 820B4258h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820B4258h case   15:*/		return 0x820B425C;
		  /* 820B425Ch */ case   16:  		/* lwzu R9, <#[R11 + 4]> */
		/* 820B425Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820B425Ch case   16:*/		return 0x820B4260;
		  /* 820B4260h */ case   17:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B4260h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B4260h case   17:*/		return 0x820B4264;
		  /* 820B4264h */ case   18:  		/* lwzx R9, <#[R9 + R10]> */
		/* 820B4264h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820B4264h case   18:*/		return 0x820B4268;
		  /* 820B4268h */ case   19:  		/* lwz R9, <#[R9]> */
		/* 820B4268h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 820B4268h case   19:*/		return 0x820B426C;
		  /* 820B426Ch */ case   20:  		/* and R9, R9, R8 */
		/* 820B426Ch case   20:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820B426Ch case   20:*/		return 0x820B4270;
		  /* 820B4270h */ case   21:  		/* rlwinm R8, R9, 0, 29, 29 */
		/* 820B4270h case   21:*/		cpu::op::rlwinm<0,0,29,29>(regs,&regs.R8,regs.R9);
		/* 820B4270h case   21:*/		return 0x820B4274;
		  /* 820B4274h */ case   22:  		/* bc 16, CR0_LT, -24 */
		/* 820B4274h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B425C;  }
		/* 820B4274h case   22:*/		return 0x820B4278;
		  /* 820B4278h */ case   23:  		/* cmplwi CR6, R8, 0 */
		/* 820B4278h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820B4278h case   23:*/		return 0x820B427C;
		  /* 820B427Ch */ case   24:  		/* bc 12, CR6_EQ, 20 */
		/* 820B427Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x820B4290;  }
		/* 820B427Ch case   24:*/		return 0x820B4280;
	}
	return 0x820B4280;
} // Block from 820B421Ch-820B4280h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820B4280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4280);
		  /* 820B4280h */ case    0:  		/* rlwinm R30, R29, 0, 12, 31 */
		/* 820B4280h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R29);
		/* 820B4280h case    0:*/		return 0x820B4284;
		  /* 820B4284h */ case    1:  		/* li R8, 0 */
		/* 820B4284h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B4284h case    1:*/		return 0x820B4288;
		  /* 820B4288h */ case    2:  		/* oris R5, R30, 4096 */
		/* 820B4288h case    2:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1000);
		/* 820B4288h case    2:*/		return 0x820B428C;
		  /* 820B428Ch */ case    3:  		/* b 16 */
		/* 820B428Ch case    3:*/		return 0x820B429C;
		/* 820B428Ch case    3:*/		return 0x820B4290;
	}
	return 0x820B4290;
} // Block from 820B4280h-820B4290h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4290);
		  /* 820B4290h */ case    0:  		/* rlwinm R30, R29, 0, 12, 31 */
		/* 820B4290h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R29);
		/* 820B4290h case    0:*/		return 0x820B4294;
		  /* 820B4294h */ case    1:  		/* mr R8, R24 */
		/* 820B4294h case    1:*/		regs.R8 = regs.R24;
		/* 820B4294h case    1:*/		return 0x820B4298;
		  /* 820B4298h */ case    2:  		/* oris R5, R30, 8272 */
		/* 820B4298h case    2:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2050);
		/* 820B4298h case    2:*/		return 0x820B429C;
	}
	return 0x820B429C;
} // Block from 820B4290h-820B429Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B429Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B429C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B429C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B429C);
		  /* 820B429Ch */ case    0:  		/* lwz R29, <#[R1 + 80]> */
		/* 820B429Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820B429Ch case    0:*/		return 0x820B42A0;
		  /* 820B42A0h */ case    1:  		/* li R9, 4 */
		/* 820B42A0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B42A0h case    1:*/		return 0x820B42A4;
		  /* 820B42A4h */ case    2:  		/* mr R7, R24 */
		/* 820B42A4h case    2:*/		regs.R7 = regs.R24;
		/* 820B42A4h case    2:*/		return 0x820B42A8;
		  /* 820B42A8h */ case    3:  		/* mr R6, R29 */
		/* 820B42A8h case    3:*/		regs.R6 = regs.R29;
		/* 820B42A8h case    3:*/		return 0x820B42AC;
		  /* 820B42ACh */ case    4:  		/* mr R4, R23 */
		/* 820B42ACh case    4:*/		regs.R4 = regs.R23;
		/* 820B42ACh case    4:*/		return 0x820B42B0;
		  /* 820B42B0h */ case    5:  		/* mr R3, R25 */
		/* 820B42B0h case    5:*/		regs.R3 = regs.R25;
		/* 820B42B0h case    5:*/		return 0x820B42B4;
		  /* 820B42B4h */ case    6:  		/* bl -14252 */
		/* 820B42B4h case    6:*/		regs.LR = 0x820B42B8; return 0x820B0B08;
		/* 820B42B4h case    6:*/		return 0x820B42B8;
		  /* 820B42B8h */ case    7:  		/* mr R31, R3 */
		/* 820B42B8h case    7:*/		regs.R31 = regs.R3;
		/* 820B42B8h case    7:*/		return 0x820B42BC;
		  /* 820B42BCh */ case    8:  		/* cmpwi CR6, R3, 0 */
		/* 820B42BCh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820B42BCh case    8:*/		return 0x820B42C0;
		  /* 820B42C0h */ case    9:  		/* bc 12, CR6_LT, 508 */
		/* 820B42C0h case    9:*/		if ( regs.CR[6].lt ) { return 0x820B44BC;  }
		/* 820B42C0h case    9:*/		return 0x820B42C4;
		  /* 820B42C4h */ case   10:  		/* lwz R28, <#[R1 + 84]> */
		/* 820B42C4h case   10:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 820B42C4h case   10:*/		return 0x820B42C8;
		  /* 820B42C8h */ case   11:  		/* li R9, 8 */
		/* 820B42C8h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820B42C8h case   11:*/		return 0x820B42CC;
		  /* 820B42CCh */ case   12:  		/* li R8, 0 */
		/* 820B42CCh case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B42CCh case   12:*/		return 0x820B42D0;
		  /* 820B42D0h */ case   13:  		/* mr R7, R29 */
		/* 820B42D0h case   13:*/		regs.R7 = regs.R29;
		/* 820B42D0h case   13:*/		return 0x820B42D4;
		  /* 820B42D4h */ case   14:  		/* mr R6, R28 */
		/* 820B42D4h case   14:*/		regs.R6 = regs.R28;
		/* 820B42D4h case   14:*/		return 0x820B42D8;
		  /* 820B42D8h */ case   15:  		/* oris R5, R30, 4112 */
		/* 820B42D8h case   15:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820B42D8h case   15:*/		return 0x820B42DC;
		  /* 820B42DCh */ case   16:  		/* mr R4, R23 */
		/* 820B42DCh case   16:*/		regs.R4 = regs.R23;
		/* 820B42DCh case   16:*/		return 0x820B42E0;
		  /* 820B42E0h */ case   17:  		/* mr R3, R25 */
		/* 820B42E0h case   17:*/		regs.R3 = regs.R25;
		/* 820B42E0h case   17:*/		return 0x820B42E4;
		  /* 820B42E4h */ case   18:  		/* bl -14300 */
		/* 820B42E4h case   18:*/		regs.LR = 0x820B42E8; return 0x820B0B08;
		/* 820B42E4h case   18:*/		return 0x820B42E8;
		  /* 820B42E8h */ case   19:  		/* or. R31, R3, R3 */
		/* 820B42E8h case   19:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B42E8h case   19:*/		return 0x820B42EC;
		  /* 820B42ECh */ case   20:  		/* bc 12, CR0_LT, 464 */
		/* 820B42ECh case   20:*/		if ( regs.CR[0].lt ) { return 0x820B44BC;  }
		/* 820B42ECh case   20:*/		return 0x820B42F0;
		  /* 820B42F0h */ case   21:  		/* cmplwi CR6, R20, 0 */
		/* 820B42F0h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 820B42F0h case   21:*/		return 0x820B42F4;
		  /* 820B42F4h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 820B42F4h case   22:*/		if ( regs.CR[6].eq ) { return 0x820B4308;  }
		/* 820B42F4h case   22:*/		return 0x820B42F8;
		  /* 820B42F8h */ case   23:  		/* mr R5, R27 */
		/* 820B42F8h case   23:*/		regs.R5 = regs.R27;
		/* 820B42F8h case   23:*/		return 0x820B42FC;
		  /* 820B42FCh */ case   24:  		/* mr R4, R29 */
		/* 820B42FCh case   24:*/		regs.R4 = regs.R29;
		/* 820B42FCh case   24:*/		return 0x820B4300;
		  /* 820B4300h */ case   25:  		/* mr R3, R20 */
		/* 820B4300h case   25:*/		regs.R3 = regs.R20;
		/* 820B4300h case   25:*/		return 0x820B4304;
		  /* 820B4304h */ case   26:  		/* bl -141652 */
		/* 820B4304h case   26:*/		regs.LR = 0x820B4308; return 0x820919B0;
		/* 820B4304h case   26:*/		return 0x820B4308;
	}
	return 0x820B4308;
} // Block from 820B429Ch-820B4308h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820B4308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4308);
		  /* 820B4308h */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 820B4308h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820B4308h case    0:*/		return 0x820B430C;
		  /* 820B430Ch */ case    1:  		/* bc 12, CR6_EQ, 428 */
		/* 820B430Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820B44B8;  }
		/* 820B430Ch case    1:*/		return 0x820B4310;
		  /* 820B4310h */ case    2:  		/* mr R5, R27 */
		/* 820B4310h case    2:*/		regs.R5 = regs.R27;
		/* 820B4310h case    2:*/		return 0x820B4314;
		  /* 820B4314h */ case    3:  		/* b 408 */
		/* 820B4314h case    3:*/		return 0x820B44AC;
		/* 820B4314h case    3:*/		return 0x820B4318;
	}
	return 0x820B4318;
} // Block from 820B4308h-820B4318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4318);
		  /* 820B4318h */ case    0:  		/* mulli R3, R29, 12 */
		/* 820B4318h case    0:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R29,0xC);
		/* 820B4318h case    0:*/		return 0x820B431C;
		  /* 820B431Ch */ case    1:  		/* bl -180508 */
		/* 820B431Ch case    1:*/		regs.LR = 0x820B4320; return 0x82088200;
		/* 820B431Ch case    1:*/		return 0x820B4320;
		  /* 820B4320h */ case    2:  		/* or. R21, R3, R3 */
		/* 820B4320h case    2:*/		cpu::op::or<1>(regs,&regs.R21,regs.R3,regs.R3);
		/* 820B4320h case    2:*/		return 0x820B4324;
		  /* 820B4324h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 820B4324h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820B4334;  }
		/* 820B4324h case    3:*/		return 0x820B4328;
	}
	return 0x820B4328;
} // Block from 820B4318h-820B4328h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4328);
		  /* 820B4328h */ case    0:  		/* lis R31, -32761 */
		/* 820B4328h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820B4328h case    0:*/		return 0x820B432C;
		  /* 820B432Ch */ case    1:  		/* ori R31, R31, 14 */
		/* 820B432Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820B432Ch case    1:*/		return 0x820B4330;
		  /* 820B4330h */ case    2:  		/* b 396 */
		/* 820B4330h case    2:*/		return 0x820B44BC;
		/* 820B4330h case    2:*/		return 0x820B4334;
	}
	return 0x820B4334;
} // Block from 820B4328h-820B4334h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B4334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4334);
		  /* 820B4334h */ case    0:  		/* mulli R8, R29, 3 */
		/* 820B4334h case    0:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R29,0x3);
		/* 820B4334h case    0:*/		return 0x820B4338;
		  /* 820B4338h */ case    1:  		/* li R10, 0 */
		/* 820B4338h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B4338h case    1:*/		return 0x820B433C;
		  /* 820B433Ch */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 820B433Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820B433Ch case    2:*/		return 0x820B4340;
		  /* 820B4340h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820B4340h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B435C;  }
		/* 820B4340h case    3:*/		return 0x820B4344;
		  /* 820B4344h */ case    4:  		/* addi R9, R21, -4 */
		/* 820B4344h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R21,0xFFFFFFFC);
		/* 820B4344h case    4:*/		return 0x820B4348;
		  /* 820B4348h */ case    5:  		/* li R11, -1 */
		/* 820B4348h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820B4348h case    5:*/		return 0x820B434C;
		  /* 820B434Ch */ case    6:  		/* addi R10, R10, 1 */
		/* 820B434Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B434Ch case    6:*/		return 0x820B4350;
		  /* 820B4350h */ case    7:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B4350h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B4350h case    7:*/		return 0x820B4354;
		  /* 820B4354h */ case    8:  		/* cmplw CR6, R10, R8 */
		/* 820B4354h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820B4354h case    8:*/		return 0x820B4358;
		  /* 820B4358h */ case    9:  		/* bc 12, CR6_LT, -12 */
		/* 820B4358h case    9:*/		if ( regs.CR[6].lt ) { return 0x820B434C;  }
		/* 820B4358h case    9:*/		return 0x820B435C;
	}
	return 0x820B435C;
} // Block from 820B4334h-820B435Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B435Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B435C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B435C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B435C);
		  /* 820B435Ch */ case    0:  		/* li R10, 3 */
		/* 820B435Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820B435Ch case    0:*/		return 0x820B4360;
		  /* 820B4360h */ case    1:  		/* addi R11, R1, 80 */
		/* 820B4360h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820B4360h case    1:*/		return 0x820B4364;
		  /* 820B4364h */ case    2:  		/* rlwinm R22, R29, 2, 0, 29 */
		/* 820B4364h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R22,regs.R29);
		/* 820B4364h case    2:*/		return 0x820B4368;
		  /* 820B4368h */ case    3:  		/* addi R9, R11, -4 */
		/* 820B4368h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 820B4368h case    3:*/		return 0x820B436C;
		  /* 820B436Ch */ case    4:  		/* mr R11, R21 */
		/* 820B436Ch case    4:*/		regs.R11 = regs.R21;
		/* 820B436Ch case    4:*/		return 0x820B4370;
		  /* 820B4370h */ case    5:  		/* mtspr CTR, R10 */
		/* 820B4370h case    5:*/		regs.CTR = regs.R10;
		/* 820B4370h case    5:*/		return 0x820B4374;
		  /* 820B4374h */ case    6:  		/* stwu R11, <#[R9 + 4]> */
		/* 820B4374h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820B4374h case    6:*/		return 0x820B4378;
		  /* 820B4378h */ case    7:  		/* add R11, R11, R22 */
		/* 820B4378h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R22);
		/* 820B4378h case    7:*/		return 0x820B437C;
		  /* 820B437Ch */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820B437Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4374;  }
		/* 820B437Ch case    8:*/		return 0x820B4380;
		  /* 820B4380h */ case    9:  		/* rlwinm R28, R29, 0, 12, 31 */
		/* 820B4380h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R29);
		/* 820B4380h case    9:*/		return 0x820B4384;
		  /* 820B4384h */ case   10:  		/* lwz R26, <#[R1 + 80]> */
		/* 820B4384h case   10:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4384h case   10:*/		return 0x820B4388;
		  /* 820B4388h */ case   11:  		/* li R9, 0 */
		/* 820B4388h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B4388h case   11:*/		return 0x820B438C;
		  /* 820B438Ch */ case   12:  		/* oris R27, R28, 4112 */
		/* 820B438Ch case   12:*/		cpu::op::oris<0>(regs,&regs.R27,regs.R28,0x1010);
		/* 820B438Ch case   12:*/		return 0x820B4390;
		  /* 820B4390h */ case   13:  		/* li R8, 0 */
		/* 820B4390h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B4390h case   13:*/		return 0x820B4394;
		  /* 820B4394h */ case   14:  		/* mr R7, R24 */
		/* 820B4394h case   14:*/		regs.R7 = regs.R24;
		/* 820B4394h case   14:*/		return 0x820B4398;
		  /* 820B4398h */ case   15:  		/* mr R6, R26 */
		/* 820B4398h case   15:*/		regs.R6 = regs.R26;
		/* 820B4398h case   15:*/		return 0x820B439C;
		  /* 820B439Ch */ case   16:  		/* mr R5, R27 */
		/* 820B439Ch case   16:*/		regs.R5 = regs.R27;
		/* 820B439Ch case   16:*/		return 0x820B43A0;
		  /* 820B43A0h */ case   17:  		/* mr R4, R23 */
		/* 820B43A0h case   17:*/		regs.R4 = regs.R23;
		/* 820B43A0h case   17:*/		return 0x820B43A4;
		  /* 820B43A4h */ case   18:  		/* mr R3, R25 */
		/* 820B43A4h case   18:*/		regs.R3 = regs.R25;
		/* 820B43A4h case   18:*/		return 0x820B43A8;
		  /* 820B43A8h */ case   19:  		/* bl -14496 */
		/* 820B43A8h case   19:*/		regs.LR = 0x820B43AC; return 0x820B0B08;
		/* 820B43A8h case   19:*/		return 0x820B43AC;
		  /* 820B43ACh */ case   20:  		/* or. R31, R3, R3 */
		/* 820B43ACh case   20:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B43ACh case   20:*/		return 0x820B43B0;
		  /* 820B43B0h */ case   21:  		/* bc 12, CR0_LT, 268 */
		/* 820B43B0h case   21:*/		if ( regs.CR[0].lt ) { return 0x820B44BC;  }
		/* 820B43B0h case   21:*/		return 0x820B43B4;
		  /* 820B43B4h */ case   22:  		/* lwz R30, <#[R1 + 84]> */
		/* 820B43B4h case   22:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820B43B4h case   22:*/		return 0x820B43B8;
		  /* 820B43B8h */ case   23:  		/* li R9, 4 */
		/* 820B43B8h case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820B43B8h case   23:*/		return 0x820B43BC;
		  /* 820B43BCh */ case   24:  		/* mr R8, R26 */
		/* 820B43BCh case   24:*/		regs.R8 = regs.R26;
		/* 820B43BCh case   24:*/		return 0x820B43C0;
		  /* 820B43C0h */ case   25:  		/* mr R7, R24 */
		/* 820B43C0h case   25:*/		regs.R7 = regs.R24;
		/* 820B43C0h case   25:*/		return 0x820B43C4;
		  /* 820B43C4h */ case   26:  		/* mr R6, R30 */
		/* 820B43C4h case   26:*/		regs.R6 = regs.R30;
		/* 820B43C4h case   26:*/		return 0x820B43C8;
		  /* 820B43C8h */ case   27:  		/* oris R5, R28, 8208 */
		/* 820B43C8h case   27:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R28,0x2010);
		/* 820B43C8h case   27:*/		return 0x820B43CC;
		  /* 820B43CCh */ case   28:  		/* mr R4, R23 */
		/* 820B43CCh case   28:*/		regs.R4 = regs.R23;
		/* 820B43CCh case   28:*/		return 0x820B43D0;
		  /* 820B43D0h */ case   29:  		/* mr R3, R25 */
		/* 820B43D0h case   29:*/		regs.R3 = regs.R25;
		/* 820B43D0h case   29:*/		return 0x820B43D4;
		  /* 820B43D4h */ case   30:  		/* bl -14540 */
		/* 820B43D4h case   30:*/		regs.LR = 0x820B43D8; return 0x820B0B08;
		/* 820B43D4h case   30:*/		return 0x820B43D8;
		  /* 820B43D8h */ case   31:  		/* or. R31, R3, R3 */
		/* 820B43D8h case   31:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B43D8h case   31:*/		return 0x820B43DC;
		  /* 820B43DCh */ case   32:  		/* bc 12, CR0_LT, 224 */
		/* 820B43DCh case   32:*/		if ( regs.CR[0].lt ) { return 0x820B44BC;  }
		/* 820B43DCh case   32:*/		return 0x820B43E0;
		  /* 820B43E0h */ case   33:  		/* lwz R28, <#[R1 + 88]> */
		/* 820B43E0h case   33:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000058) );
		/* 820B43E0h case   33:*/		return 0x820B43E4;
		  /* 820B43E4h */ case   34:  		/* li R9, 8 */
		/* 820B43E4h case   34:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820B43E4h case   34:*/		return 0x820B43E8;
		  /* 820B43E8h */ case   35:  		/* li R8, 0 */
		/* 820B43E8h case   35:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B43E8h case   35:*/		return 0x820B43EC;
		  /* 820B43ECh */ case   36:  		/* mr R7, R30 */
		/* 820B43ECh case   36:*/		regs.R7 = regs.R30;
		/* 820B43ECh case   36:*/		return 0x820B43F0;
		  /* 820B43F0h */ case   37:  		/* mr R6, R28 */
		/* 820B43F0h case   37:*/		regs.R6 = regs.R28;
		/* 820B43F0h case   37:*/		return 0x820B43F4;
		  /* 820B43F4h */ case   38:  		/* mr R5, R27 */
		/* 820B43F4h case   38:*/		regs.R5 = regs.R27;
		/* 820B43F4h case   38:*/		return 0x820B43F8;
		  /* 820B43F8h */ case   39:  		/* mr R4, R23 */
		/* 820B43F8h case   39:*/		regs.R4 = regs.R23;
		/* 820B43F8h case   39:*/		return 0x820B43FC;
		  /* 820B43FCh */ case   40:  		/* mr R3, R25 */
		/* 820B43FCh case   40:*/		regs.R3 = regs.R25;
		/* 820B43FCh case   40:*/		return 0x820B4400;
		  /* 820B4400h */ case   41:  		/* bl -14584 */
		/* 820B4400h case   41:*/		regs.LR = 0x820B4404; return 0x820B0B08;
		/* 820B4400h case   41:*/		return 0x820B4404;
		  /* 820B4404h */ case   42:  		/* or. R31, R3, R3 */
		/* 820B4404h case   42:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B4404h case   42:*/		return 0x820B4408;
		  /* 820B4408h */ case   43:  		/* bc 12, CR0_LT, 180 */
		/* 820B4408h case   43:*/		if ( regs.CR[0].lt ) { return 0x820B44BC;  }
		/* 820B4408h case   43:*/		return 0x820B440C;
		  /* 820B440Ch */ case   44:  		/* cmplwi CR6, R29, 0 */
		/* 820B440Ch case   44:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820B440Ch case   44:*/		return 0x820B4410;
		  /* 820B4410h */ case   45:  		/* bc 12, CR6_EQ, 120 */
		/* 820B4410h case   45:*/		if ( regs.CR[6].eq ) { return 0x820B4488;  }
		/* 820B4410h case   45:*/		return 0x820B4414;
		  /* 820B4414h */ case   46:  		/* mr R11, R30 */
		/* 820B4414h case   46:*/		regs.R11 = regs.R30;
		/* 820B4414h case   46:*/		return 0x820B4418;
		  /* 820B4418h */ case   47:  		/* mtspr CTR, R29 */
		/* 820B4418h case   47:*/		regs.CTR = regs.R29;
		/* 820B4418h case   47:*/		return 0x820B441C;
		  /* 820B441Ch */ case   48:  		/* subf R10, R30, R24 */
		/* 820B441Ch case   48:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R24);
		/* 820B441Ch case   48:*/		return 0x820B4420;
		  /* 820B4420h */ case   49:  		/* subf R9, R30, R28 */
		/* 820B4420h case   49:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R28);
		/* 820B4420h case   49:*/		return 0x820B4424;
		  /* 820B4424h */ case   50:  		/* lwz R8, <#[R25 + 8]> */
		/* 820B4424h case   50:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000008) );
		/* 820B4424h case   50:*/		return 0x820B4428;
		  /* 820B4428h */ case   51:  		/* lwzx R7, <#[R10 + R11]> */
		/* 820B4428h case   51:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B4428h case   51:*/		return 0x820B442C;
		  /* 820B442Ch */ case   52:  		/* lwz R6, <#[R11]> */
		/* 820B442Ch case   52:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820B442Ch case   52:*/		return 0x820B4430;
		  /* 820B4430h */ case   53:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820B4430h case   53:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820B4430h case   53:*/		return 0x820B4434;
		  /* 820B4434h */ case   54:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820B4434h case   54:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820B4434h case   54:*/		return 0x820B4438;
		  /* 820B4438h */ case   55:  		/* lwz R8, <#[R8 + 20]> */
		/* 820B4438h case   55:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000014) );
		/* 820B4438h case   55:*/		return 0x820B443C;
		  /* 820B443Ch */ case   56:  		/* lwzx R7, <#[R7 + R8]> */
		/* 820B443Ch case   56:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820B443Ch case   56:*/		return 0x820B4440;
		  /* 820B4440h */ case   57:  		/* lwzx R8, <#[R6 + R8]> */
		/* 820B4440h case   57:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820B4440h case   57:*/		return 0x820B4444;
		  /* 820B4444h */ case   58:  		/* lwz R6, <#[R7]> */
		/* 820B4444h case   58:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 820B4444h case   58:*/		return 0x820B4448;
		  /* 820B4448h */ case   59:  		/* lwz R5, <#[R8]> */
		/* 820B4448h case   59:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000000) );
		/* 820B4448h case   59:*/		return 0x820B444C;
		  /* 820B444Ch */ case   60:  		/* andi. R6, R6, 23 */
		/* 820B444Ch case   60:*/		cpu::op::andi<1>(regs,&regs.R6,regs.R6,0x17);
		/* 820B444Ch case   60:*/		return 0x820B4450;
		  /* 820B4450h */ case   61:  		/* or R6, R6, R5 */
		/* 820B4450h case   61:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 820B4450h case   61:*/		return 0x820B4454;
		  /* 820B4454h */ case   62:  		/* stw R6, <#[R8]> */
		/* 820B4454h case   62:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 820B4454h case   62:*/		return 0x820B4458;
		  /* 820B4458h */ case   63:  		/* lwz R8, <#[R25 + 8]> */
		/* 820B4458h case   63:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000008) );
		/* 820B4458h case   63:*/		return 0x820B445C;
		  /* 820B445Ch */ case   64:  		/* lwzx R6, <#[R9 + R11]> */
		/* 820B445Ch case   64:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B445Ch case   64:*/		return 0x820B4460;
		  /* 820B4460h */ case   65:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 820B4460h case   65:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 820B4460h case   65:*/		return 0x820B4464;
		  /* 820B4464h */ case   66:  		/* lwz R8, <#[R8 + 20]> */
		/* 820B4464h case   66:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000014) );
		/* 820B4464h case   66:*/		return 0x820B4468;
		  /* 820B4468h */ case   67:  		/* addi R11, R11, 4 */
		/* 820B4468h case   67:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B4468h case   67:*/		return 0x820B446C;
		  /* 820B446Ch */ case   68:  		/* lwz R7, <#[R7]> */
		/* 820B446Ch case   68:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 820B446Ch case   68:*/		return 0x820B4470;
		  /* 820B4470h */ case   69:  		/* andi. R7, R7, 18 */
		/* 820B4470h case   69:*/		cpu::op::andi<1>(regs,&regs.R7,regs.R7,0x12);
		/* 820B4470h case   69:*/		return 0x820B4474;
		  /* 820B4474h */ case   70:  		/* lwzx R8, <#[R6 + R8]> */
		/* 820B4474h case   70:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820B4474h case   70:*/		return 0x820B4478;
		  /* 820B4478h */ case   71:  		/* lwz R6, <#[R8]> */
		/* 820B4478h case   71:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 820B4478h case   71:*/		return 0x820B447C;
		  /* 820B447Ch */ case   72:  		/* or R7, R7, R6 */
		/* 820B447Ch case   72:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 820B447Ch case   72:*/		return 0x820B4480;
		  /* 820B4480h */ case   73:  		/* stw R7, <#[R8]> */
		/* 820B4480h case   73:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 820B4480h case   73:*/		return 0x820B4484;
		  /* 820B4484h */ case   74:  		/* bc 16, CR0_LT, -96 */
		/* 820B4484h case   74:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4424;  }
		/* 820B4484h case   74:*/		return 0x820B4488;
	}
	return 0x820B4488;
} // Block from 820B435Ch-820B4488h (75 instructions)

//////////////////////////////////////////////////////
// Block at 820B4488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4488);
		  /* 820B4488h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 820B4488h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 820B4488h case    0:*/		return 0x820B448C;
		  /* 820B448Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820B448Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820B44A0;  }
		/* 820B448Ch case    1:*/		return 0x820B4490;
		  /* 820B4490h */ case    2:  		/* mr R5, R22 */
		/* 820B4490h case    2:*/		regs.R5 = regs.R22;
		/* 820B4490h case    2:*/		return 0x820B4494;
		  /* 820B4494h */ case    3:  		/* mr R4, R30 */
		/* 820B4494h case    3:*/		regs.R4 = regs.R30;
		/* 820B4494h case    3:*/		return 0x820B4498;
	}
	return 0x820B4498;
} // Block from 820B4488h-820B4498h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4498h
// Function '?EmitPow@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAI11I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4498);
		  /* 820B4498h */ case    0:  		/* mr R3, R20 */
		/* 820B4498h case    0:*/		regs.R3 = regs.R20;
		/* 820B4498h case    0:*/		return 0x820B449C;
		  /* 820B449Ch */ case    1:  		/* bl -142060 */
		/* 820B449Ch case    1:*/		regs.LR = 0x820B44A0; return 0x820919B0;
		/* 820B449Ch case    1:*/		return 0x820B44A0;
	}
	return 0x820B44A0;
} // Block from 820B4498h-820B44A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B44A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B44A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B44A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B44A0);
		  /* 820B44A0h */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 820B44A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820B44A0h case    0:*/		return 0x820B44A4;
		  /* 820B44A4h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820B44A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B44B8;  }
		/* 820B44A4h case    1:*/		return 0x820B44A8;
		  /* 820B44A8h */ case    2:  		/* mr R5, R22 */
		/* 820B44A8h case    2:*/		regs.R5 = regs.R22;
		/* 820B44A8h case    2:*/		return 0x820B44AC;
	}
	return 0x820B44AC;
} // Block from 820B44A0h-820B44ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B44ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B44AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B44AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B44AC);
		  /* 820B44ACh */ case    0:  		/* mr R4, R28 */
		/* 820B44ACh case    0:*/		regs.R4 = regs.R28;
		/* 820B44ACh case    0:*/		return 0x820B44B0;
		  /* 820B44B0h */ case    1:  		/* mr R3, R19 */
		/* 820B44B0h case    1:*/		regs.R3 = regs.R19;
		/* 820B44B0h case    1:*/		return 0x820B44B4;
		  /* 820B44B4h */ case    2:  		/* bl -142084 */
		/* 820B44B4h case    2:*/		regs.LR = 0x820B44B8; return 0x820919B0;
		/* 820B44B4h case    2:*/		return 0x820B44B8;
	}
	return 0x820B44B8;
} // Block from 820B44ACh-820B44B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B44B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B44B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B44B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B44B8);
		  /* 820B44B8h */ case    0:  		/* li R31, 0 */
		/* 820B44B8h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820B44B8h case    0:*/		return 0x820B44BC;
	}
	return 0x820B44BC;
} // Block from 820B44B8h-820B44BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B44BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B44BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B44BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B44BC);
		  /* 820B44BCh */ case    0:  		/* lis R4, 9345 */
		/* 820B44BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B44BCh case    0:*/		return 0x820B44C0;
		  /* 820B44C0h */ case    1:  		/* mr R3, R21 */
		/* 820B44C0h case    1:*/		regs.R3 = regs.R21;
		/* 820B44C0h case    1:*/		return 0x820B44C4;
		  /* 820B44C4h */ case    2:  		/* bl -180620 */
		/* 820B44C4h case    2:*/		regs.LR = 0x820B44C8; return 0x82088338;
		/* 820B44C4h case    2:*/		return 0x820B44C8;
		  /* 820B44C8h */ case    3:  		/* mr R3, R31 */
		/* 820B44C8h case    3:*/		regs.R3 = regs.R31;
		/* 820B44C8h case    3:*/		return 0x820B44CC;
		  /* 820B44CCh */ case    4:  		/* addi R1, R1, 208 */
		/* 820B44CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820B44CCh case    4:*/		return 0x820B44D0;
		  /* 820B44D0h */ case    5:  		/* b -143948 */
		/* 820B44D0h case    5:*/		return 0x82091284;
		/* 820B44D0h case    5:*/		return 0x820B44D4;
		  /* 820B44D4h */ case    6:  		/* nop */
		/* 820B44D4h case    6:*/		cpu::op::nop();
		/* 820B44D4h case    6:*/		return 0x820B44D8;
	}
	return 0x820B44D8;
} // Block from 820B44BCh-820B44D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B44D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B44D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B44D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B44D8);
		  /* 820B44D8h */ case    0:  		/* mfspr R12, LR */
		/* 820B44D8h case    0:*/		regs.R12 = regs.LR;
		/* 820B44D8h case    0:*/		return 0x820B44DC;
		  /* 820B44DCh */ case    1:  		/* bl -144008 */
		/* 820B44DCh case    1:*/		regs.LR = 0x820B44E0; return 0x82091254;
		/* 820B44DCh case    1:*/		return 0x820B44E0;
		  /* 820B44E0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820B44E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820B44E0h case    2:*/		return 0x820B44E4;
		  /* 820B44E4h */ case    3:  		/* mr R28, R3 */
		/* 820B44E4h case    3:*/		regs.R28 = regs.R3;
		/* 820B44E4h case    3:*/		return 0x820B44E8;
		  /* 820B44E8h */ case    4:  		/* mr R29, R4 */
		/* 820B44E8h case    4:*/		regs.R29 = regs.R4;
		/* 820B44E8h case    4:*/		return 0x820B44EC;
		  /* 820B44ECh */ case    5:  		/* lis R4, 9345 */
		/* 820B44ECh case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B44ECh case    5:*/		return 0x820B44F0;
		  /* 820B44F0h */ case    6:  		/* rlwinm R3, R6, 2, 0, 29 */
		/* 820B44F0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R6);
		/* 820B44F0h case    6:*/		return 0x820B44F4;
		  /* 820B44F4h */ case    7:  		/* mr R27, R5 */
		/* 820B44F4h case    7:*/		regs.R27 = regs.R5;
		/* 820B44F4h case    7:*/		return 0x820B44F8;
		  /* 820B44F8h */ case    8:  		/* mr R30, R6 */
		/* 820B44F8h case    8:*/		regs.R30 = regs.R6;
		/* 820B44F8h case    8:*/		return 0x820B44FC;
		  /* 820B44FCh */ case    9:  		/* bl -180988 */
		/* 820B44FCh case    9:*/		regs.LR = 0x820B4500; return 0x82088200;
		/* 820B44FCh case    9:*/		return 0x820B4500;
		  /* 820B4500h */ case   10:  		/* or. R31, R3, R3 */
		/* 820B4500h case   10:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B4500h case   10:*/		return 0x820B4504;
		  /* 820B4504h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 820B4504h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820B4514;  }
		/* 820B4504h case   11:*/		return 0x820B4508;
		  /* 820B4508h */ case   12:  		/* lis R3, -32761 */
		/* 820B4508h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820B4508h case   12:*/		return 0x820B450C;
		  /* 820B450Ch */ case   13:  		/* ori R3, R3, 14 */
		/* 820B450Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820B450Ch case   13:*/		return 0x820B4510;
		  /* 820B4510h */ case   14:  		/* b 100 */
		/* 820B4510h case   14:*/		return 0x820B4574;
		/* 820B4510h case   14:*/		return 0x820B4514;
	}
	return 0x820B4514;
} // Block from 820B44D8h-820B4514h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B4514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4514);
		  /* 820B4514h */ case    0:  		/* mr R5, R31 */
		/* 820B4514h case    0:*/		regs.R5 = regs.R31;
		/* 820B4514h case    0:*/		return 0x820B4518;
		  /* 820B4518h */ case    1:  		/* mr R4, R29 */
		/* 820B4518h case    1:*/		regs.R4 = regs.R29;
		/* 820B4518h case    1:*/		return 0x820B451C;
		  /* 820B451Ch */ case    2:  		/* mr R3, R28 */
		/* 820B451Ch case    2:*/		regs.R3 = regs.R28;
		/* 820B451Ch case    2:*/		return 0x820B4520;
		  /* 820B4520h */ case    3:  		/* bl -11904 */
		/* 820B4520h case    3:*/		regs.LR = 0x820B4524; return 0x820B16A0;
		/* 820B4520h case    3:*/		return 0x820B4524;
		  /* 820B4524h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 820B4524h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B4524h case    4:*/		return 0x820B4528;
		  /* 820B4528h */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 820B4528h case    5:*/		if ( regs.CR[6].eq ) { return 0x820B4564;  }
		/* 820B4528h case    5:*/		return 0x820B452C;
		  /* 820B452Ch */ case    6:  		/* mtspr CTR, R30 */
		/* 820B452Ch case    6:*/		regs.CTR = regs.R30;
		/* 820B452Ch case    6:*/		return 0x820B4530;
		  /* 820B4530h */ case    7:  		/* mr R11, R31 */
		/* 820B4530h case    7:*/		regs.R11 = regs.R31;
		/* 820B4530h case    7:*/		return 0x820B4534;
		  /* 820B4534h */ case    8:  		/* subf R10, R31, R27 */
		/* 820B4534h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R27);
		/* 820B4534h case    8:*/		return 0x820B4538;
		  /* 820B4538h */ case    9:  		/* lwz R9, <#[R28 + 8]> */
		/* 820B4538h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 820B4538h case    9:*/		return 0x820B453C;
		  /* 820B453Ch */ case   10:  		/* lwzx R8, <#[R10 + R11]> */
		/* 820B453Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B453Ch case   10:*/		return 0x820B4540;
		  /* 820B4540h */ case   11:  		/* lwz R7, <#[R11]> */
		/* 820B4540h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4540h case   11:*/		return 0x820B4544;
		  /* 820B4544h */ case   12:  		/* addi R11, R11, 4 */
		/* 820B4544h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B4544h case   12:*/		return 0x820B4548;
		  /* 820B4548h */ case   13:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B4548h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B4548h case   13:*/		return 0x820B454C;
		  /* 820B454Ch */ case   14:  		/* lwz R9, <#[R9 + 20]> */
		/* 820B454Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 820B454Ch case   14:*/		return 0x820B4550;
		  /* 820B4550h */ case   15:  		/* lwzx R9, <#[R8 + R9]> */
		/* 820B4550h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820B4550h case   15:*/		return 0x820B4554;
		  /* 820B4554h */ case   16:  		/* lwz R8, <#[R9]> */
		/* 820B4554h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820B4554h case   16:*/		return 0x820B4558;
		  /* 820B4558h */ case   17:  		/* or R8, R8, R7 */
		/* 820B4558h case   17:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 820B4558h case   17:*/		return 0x820B455C;
		  /* 820B455Ch */ case   18:  		/* stw R8, <#[R9]> */
		/* 820B455Ch case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820B455Ch case   18:*/		return 0x820B4560;
		  /* 820B4560h */ case   19:  		/* bc 16, CR0_LT, -40 */
		/* 820B4560h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4538;  }
		/* 820B4560h case   19:*/		return 0x820B4564;
	}
	return 0x820B4564;
} // Block from 820B4514h-820B4564h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820B4564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4564);
		  /* 820B4564h */ case    0:  		/* lis R4, 9345 */
		/* 820B4564h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820B4564h case    0:*/		return 0x820B4568;
		  /* 820B4568h */ case    1:  		/* mr R3, R31 */
		/* 820B4568h case    1:*/		regs.R3 = regs.R31;
		/* 820B4568h case    1:*/		return 0x820B456C;
		  /* 820B456Ch */ case    2:  		/* bl -180788 */
		/* 820B456Ch case    2:*/		regs.LR = 0x820B4570; return 0x82088338;
		/* 820B456Ch case    2:*/		return 0x820B4570;
		  /* 820B4570h */ case    3:  		/* li R3, 0 */
		/* 820B4570h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B4570h case    3:*/		return 0x820B4574;
	}
	return 0x820B4574;
} // Block from 820B4564h-820B4574h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4574);
		  /* 820B4574h */ case    0:  		/* addi R1, R1, 128 */
		/* 820B4574h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820B4574h case    0:*/		return 0x820B4578;
		  /* 820B4578h */ case    1:  		/* b -144084 */
		/* 820B4578h case    1:*/		return 0x820912A4;
		/* 820B4578h case    1:*/		return 0x820B457C;
		  /* 820B457Ch */ case    2:  		/* nop */
		/* 820B457Ch case    2:*/		cpu::op::nop();
		/* 820B457Ch case    2:*/		return 0x820B4580;
	}
	return 0x820B4580;
} // Block from 820B4574h-820B4580h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B4580h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4580);
		  /* 820B4580h */ case    0:  		/* mfspr R12, LR */
		/* 820B4580h case    0:*/		regs.R12 = regs.LR;
		/* 820B4580h case    0:*/		return 0x820B4584;
		  /* 820B4584h */ case    1:  		/* bl -144212 */
		/* 820B4584h case    1:*/		regs.LR = 0x820B4588; return 0x82091230;
		/* 820B4584h case    1:*/		return 0x820B4588;
		  /* 820B4588h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820B4588h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820B4588h case    2:*/		return 0x820B458C;
		  /* 820B458Ch */ case    3:  		/* li R24, 0 */
		/* 820B458Ch case    3:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820B458Ch case    3:*/		return 0x820B4590;
		  /* 820B4590h */ case    4:  		/* mr R26, R3 */
		/* 820B4590h case    4:*/		regs.R26 = regs.R3;
		/* 820B4590h case    4:*/		return 0x820B4594;
		  /* 820B4594h */ case    5:  		/* mr R19, R4 */
		/* 820B4594h case    5:*/		regs.R19 = regs.R4;
		/* 820B4594h case    5:*/		return 0x820B4598;
		  /* 820B4598h */ case    6:  		/* stw R24, <#[R1 + 96]> */
		/* 820B4598h case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000060) );
		/* 820B4598h case    6:*/		return 0x820B459C;
		  /* 820B459Ch */ case    7:  		/* mr R18, R5 */
		/* 820B459Ch case    7:*/		regs.R18 = regs.R5;
		/* 820B459Ch case    7:*/		return 0x820B45A0;
		  /* 820B45A0h */ case    8:  		/* stw R24, <#[R1 + 100]> */
		/* 820B45A0h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000064) );
		/* 820B45A0h case    8:*/		return 0x820B45A4;
		  /* 820B45A4h */ case    9:  		/* mr R25, R6 */
		/* 820B45A4h case    9:*/		regs.R25 = regs.R6;
		/* 820B45A4h case    9:*/		return 0x820B45A8;
		  /* 820B45A8h */ case   10:  		/* mr R23, R7 */
		/* 820B45A8h case   10:*/		regs.R23 = regs.R7;
		/* 820B45A8h case   10:*/		return 0x820B45AC;
		  /* 820B45ACh */ case   11:  		/* mr R28, R8 */
		/* 820B45ACh case   11:*/		regs.R28 = regs.R8;
		/* 820B45ACh case   11:*/		return 0x820B45B0;
		  /* 820B45B0h */ case   12:  		/* mr R21, R9 */
		/* 820B45B0h case   12:*/		regs.R21 = regs.R9;
		/* 820B45B0h case   12:*/		return 0x820B45B4;
		  /* 820B45B4h */ case   13:  		/* mr R20, R10 */
		/* 820B45B4h case   13:*/		regs.R20 = regs.R10;
		/* 820B45B4h case   13:*/		return 0x820B45B8;
		  /* 820B45B8h */ case   14:  		/* cmplwi CR6, R4, 0 */
		/* 820B45B8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820B45B8h case   14:*/		return 0x820B45BC;
		  /* 820B45BCh */ case   15:  		/* bc 12, CR6_EQ, 664 */
		/* 820B45BCh case   15:*/		if ( regs.CR[6].eq ) { return 0x820B4854;  }
		/* 820B45BCh case   15:*/		return 0x820B45C0;
		  /* 820B45C0h */ case   16:  		/* cmpwi CR6, R7, 0 */
		/* 820B45C0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 820B45C0h case   16:*/		return 0x820B45C4;
		  /* 820B45C4h */ case   17:  		/* bc 4, CR6_EQ, 28 */
		/* 820B45C4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820B45E0;  }
		/* 820B45C4h case   17:*/		return 0x820B45C8;
		  /* 820B45C8h */ case   18:  		/* lwz R11, <#[R1 + 324]> */
		/* 820B45C8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000144) );
		/* 820B45C8h case   18:*/		return 0x820B45CC;
		  /* 820B45CCh */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 820B45CCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B45CCh case   19:*/		return 0x820B45D0;
		  /* 820B45D0h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 820B45D0h case   20:*/		if ( regs.CR[6].eq ) { return 0x820B45E0;  }
		/* 820B45D0h case   20:*/		return 0x820B45D4;
		  /* 820B45D4h */ case   21:  		/* mr R21, R11 */
		/* 820B45D4h case   21:*/		regs.R21 = regs.R11;
		/* 820B45D4h case   21:*/		return 0x820B45D8;
		  /* 820B45D8h */ case   22:  		/* addi R20, R1, 100 */
		/* 820B45D8h case   22:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R1,0x64);
		/* 820B45D8h case   22:*/		return 0x820B45DC;
		  /* 820B45DCh */ case   23:  		/* li R23, 1 */
		/* 820B45DCh case   23:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 820B45DCh case   23:*/		return 0x820B45E0;
	}
	return 0x820B45E0;
} // Block from 820B4580h-820B45E0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820B45E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B45E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B45E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B45E0);
		  /* 820B45E0h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 820B45E0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820B45E0h case    0:*/		return 0x820B45E4;
		  /* 820B45E4h */ case    1:  		/* bc 4, CR6_EQ, 572 */
		/* 820B45E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B4820;  }
		/* 820B45E4h case    1:*/		return 0x820B45E8;
		  /* 820B45E8h */ case    2:  		/* lwz R22, <#[R1 + 332]> */
		/* 820B45E8h case    2:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x0000014C) );
		/* 820B45E8h case    2:*/		return 0x820B45EC;
		  /* 820B45ECh */ case    3:  		/* cmplwi CR6, R22, 0 */
		/* 820B45ECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820B45ECh case    3:*/		return 0x820B45F0;
		  /* 820B45F0h */ case    4:  		/* bc 12, CR6_EQ, 560 */
		/* 820B45F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820B4820;  }
		/* 820B45F0h case    4:*/		return 0x820B45F4;
		  /* 820B45F4h */ case    5:  		/* lwz R11, <#[R26 + 136]> */
		/* 820B45F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000088) );
		/* 820B45F4h case    5:*/		return 0x820B45F8;
		  /* 820B45F8h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 820B45F8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820B45F8h case    6:*/		return 0x820B45FC;
		  /* 820B45FCh */ case    7:  		/* bc 4, CR6_EQ, 548 */
		/* 820B45FCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x820B4820;  }
		/* 820B45FCh case    7:*/		return 0x820B4600;
		  /* 820B4600h */ case    8:  		/* lwz R11, <#[R22 + 8]> */
		/* 820B4600h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 820B4600h case    8:*/		return 0x820B4604;
		  /* 820B4604h */ case    9:  		/* mr R27, R24 */
		/* 820B4604h case    9:*/		regs.R27 = regs.R24;
		/* 820B4604h case    9:*/		return 0x820B4608;
		  /* 820B4608h */ case   10:  		/* mr R30, R24 */
		/* 820B4608h case   10:*/		regs.R30 = regs.R24;
		/* 820B4608h case   10:*/		return 0x820B460C;
		  /* 820B460Ch */ case   11:  		/* mr R29, R24 */
		/* 820B460Ch case   11:*/		regs.R29 = regs.R24;
		/* 820B460Ch case   11:*/		return 0x820B4610;
		  /* 820B4610h */ case   12:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B4610h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4610h case   12:*/		return 0x820B4614;
		  /* 820B4614h */ case   13:  		/* cmpwi CR6, R10, 18 */
		/* 820B4614h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000012);
		/* 820B4614h case   13:*/		return 0x820B4618;
		  /* 820B4618h */ case   14:  		/* bc 4, CR6_EQ, 96 */
		/* 820B4618h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820B4678;  }
		/* 820B4618h case   14:*/		return 0x820B461C;
		  /* 820B461Ch */ case   15:  		/* lwz R10, <#[R11 + 20]> */
		/* 820B461Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820B461Ch case   15:*/		return 0x820B4620;
		  /* 820B4620h */ case   16:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B4620h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B4620h case   16:*/		return 0x820B4624;
		  /* 820B4624h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 820B4624h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B4624h case   17:*/		return 0x820B4628;
		  /* 820B4628h */ case   18:  		/* lwz R31, <#[R10 + 24]> */
		/* 820B4628h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000018) );
		/* 820B4628h case   18:*/		return 0x820B462C;
		  /* 820B462Ch */ case   19:  		/* bc 12, CR6_EQ, 72 */
		/* 820B462Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x820B4674;  }
		/* 820B462Ch case   19:*/		return 0x820B4630;
		  /* 820B4630h */ case   20:  		/* addi R5, R1, 104 */
		/* 820B4630h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 820B4630h case   20:*/		return 0x820B4634;
		  /* 820B4634h */ case   21:  		/* lwz R3, <#[R11 + 24]> */
		/* 820B4634h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000018) );
		/* 820B4634h case   21:*/		return 0x820B4638;
		  /* 820B4638h */ case   22:  		/* li R4, 0 */
		/* 820B4638h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B4638h case   22:*/		return 0x820B463C;
		  /* 820B463Ch */ case   23:  		/* bl -88236 */
		/* 820B463Ch case   23:*/		regs.LR = 0x820B4640; return 0x8209ED90;
		/* 820B463Ch case   23:*/		return 0x820B4640;
		  /* 820B4640h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820B4640h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4640h case   24:*/		return 0x820B4644;
		  /* 820B4644h */ case   25:  		/* bc 12, CR0_LT, 52 */
		/* 820B4644h case   25:*/		if ( regs.CR[0].lt ) { return 0x820B4678;  }
		/* 820B4644h case   25:*/		return 0x820B4648;
		  /* 820B4648h */ case   26:  		/* lwz R11, <#[R26 + 16]> */
		/* 820B4648h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 820B4648h case   26:*/		return 0x820B464C;
		  /* 820B464Ch */ case   27:  		/* lwz R10, <#[R1 + 108]> */
		/* 820B464Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 820B464Ch case   27:*/		return 0x820B4650;
		  /* 820B4650h */ case   28:  		/* cmplw CR6, R11, R10 */
		/* 820B4650h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B4650h case   28:*/		return 0x820B4654;
		  /* 820B4654h */ case   29:  		/* bc 4, CR6_EQ, 12 */
		/* 820B4654h case   29:*/		if ( !regs.CR[6].eq ) { return 0x820B4660;  }
		/* 820B4654h case   29:*/		return 0x820B4658;
		  /* 820B4658h */ case   30:  		/* mr R27, R31 */
		/* 820B4658h case   30:*/		regs.R27 = regs.R31;
		/* 820B4658h case   30:*/		return 0x820B465C;
		  /* 820B465Ch */ case   31:  		/* b 28 */
		/* 820B465Ch case   31:*/		return 0x820B4678;
		/* 820B465Ch case   31:*/		return 0x820B4660;
	}
	return 0x820B4660;
} // Block from 820B45E0h-820B4660h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820B4660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4660);
		  /* 820B4660h */ case    0:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820B4660h case    0:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820B4660h case    0:*/		return 0x820B4664;
		  /* 820B4664h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820B4664h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B4664h case    1:*/		return 0x820B4668;
		  /* 820B4668h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820B4668h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B4678;  }
		/* 820B4668h case    2:*/		return 0x820B466C;
		  /* 820B466Ch */ case    3:  		/* mr R30, R31 */
		/* 820B466Ch case    3:*/		regs.R30 = regs.R31;
		/* 820B466Ch case    3:*/		return 0x820B4670;
		  /* 820B4670h */ case    4:  		/* b 8 */
		/* 820B4670h case    4:*/		return 0x820B4678;
		/* 820B4670h case    4:*/		return 0x820B4674;
	}
	return 0x820B4674;
} // Block from 820B4660h-820B4674h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B4674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4674);
		  /* 820B4674h */ case    0:  		/* mr R29, R31 */
		/* 820B4674h case    0:*/		regs.R29 = regs.R31;
		/* 820B4674h case    0:*/		return 0x820B4678;
	}
	return 0x820B4678;
} // Block from 820B4674h-820B4678h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B4678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4678);
		  /* 820B4678h */ case    0:  		/* lwz R22, <#[R22 + 12]> */
		/* 820B4678h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R22 + 0x0000000C) );
		/* 820B4678h case    0:*/		return 0x820B467C;
		  /* 820B467Ch */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820B467Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820B467Ch case    1:*/		return 0x820B4680;
		  /* 820B4680h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 820B4680h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B469C;  }
		/* 820B4680h case    2:*/		return 0x820B4684;
		  /* 820B4684h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 820B4684h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820B4684h case    3:*/		return 0x820B4688;
		  /* 820B4688h */ case    4:  		/* mr R27, R30 */
		/* 820B4688h case    4:*/		regs.R27 = regs.R30;
		/* 820B4688h case    4:*/		return 0x820B468C;
		  /* 820B468Ch */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820B468Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820B4694;  }
		/* 820B468Ch case    5:*/		return 0x820B4690;
		  /* 820B4690h */ case    6:  		/* mr R27, R29 */
		/* 820B4690h case    6:*/		regs.R27 = regs.R29;
		/* 820B4690h case    6:*/		return 0x820B4694;
	}
	return 0x820B4694;
} // Block from 820B4678h-820B4694h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B4694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4694);
		  /* 820B4694h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820B4694h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820B4694h case    0:*/		return 0x820B4698;
		  /* 820B4698h */ case    1:  		/* bc 12, CR6_EQ, 384 */
		/* 820B4698h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B4818;  }
		/* 820B4698h case    1:*/		return 0x820B469C;
	}
	return 0x820B469C;
} // Block from 820B4694h-820B469Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B469Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B469C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B469C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B469C);
		  /* 820B469Ch */ case    0:  		/* lwz R3, <#[R26 + 8]> */
		/* 820B469Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000008) );
		/* 820B469Ch case    0:*/		return 0x820B46A0;
		  /* 820B46A0h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 820B46A0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820B46A0h case    1:*/		return 0x820B46A4;
		  /* 820B46A4h */ case    2:  		/* cmplw CR6, R25, R11 */
		/* 820B46A4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 820B46A4h case    2:*/		return 0x820B46A8;
		  /* 820B46A8h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 820B46A8h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820B46BC;  }
		/* 820B46A8h case    3:*/		return 0x820B46AC;
		  /* 820B46ACh */ case    4:  		/* lwz R11, <#[R3 + 16]> */
		/* 820B46ACh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820B46ACh case    4:*/		return 0x820B46B0;
		  /* 820B46B0h */ case    5:  		/* rlwinm R10, R25, 2, 0, 29 */
		/* 820B46B0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R25);
		/* 820B46B0h case    5:*/		return 0x820B46B4;
		  /* 820B46B4h */ case    6:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820B46B4h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B46B4h case    6:*/		return 0x820B46B8;
		  /* 820B46B8h */ case    7:  		/* b 8 */
		/* 820B46B8h case    7:*/		return 0x820B46C0;
		/* 820B46B8h case    7:*/		return 0x820B46BC;
	}
	return 0x820B46BC;
} // Block from 820B469Ch-820B46BCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B46BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B46BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B46BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B46BC);
		  /* 820B46BCh */ case    0:  		/* mr R4, R24 */
		/* 820B46BCh case    0:*/		regs.R4 = regs.R24;
		/* 820B46BCh case    0:*/		return 0x820B46C0;
	}
	return 0x820B46C0;
} // Block from 820B46BCh-820B46C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B46C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B46C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B46C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B46C0);
		  /* 820B46C0h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820B46C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820B46C0h case    0:*/		return 0x820B46C4;
		  /* 820B46C4h */ case    1:  		/* bc 12, CR6_EQ, 432 */
		/* 820B46C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B4874;  }
		/* 820B46C4h case    1:*/		return 0x820B46C8;
		  /* 820B46C8h */ case    2:  		/* bl 298136 */
		/* 820B46C8h case    2:*/		regs.LR = 0x820B46CC; return 0x820FD360;
		/* 820B46C8h case    2:*/		return 0x820B46CC;
		  /* 820B46CCh */ case    3:  		/* lwz R11, <#[R26 + 8]> */
		/* 820B46CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820B46CCh case    3:*/		return 0x820B46D0;
		  /* 820B46D0h */ case    4:  		/* mr R25, R3 */
		/* 820B46D0h case    4:*/		regs.R25 = regs.R3;
		/* 820B46D0h case    4:*/		return 0x820B46D4;
		  /* 820B46D4h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B46D4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B46D4h case    5:*/		return 0x820B46D8;
		  /* 820B46D8h */ case    6:  		/* cmplw CR6, R3, R10 */
		/* 820B46D8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820B46D8h case    6:*/		return 0x820B46DC;
		  /* 820B46DCh */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 820B46DCh case    7:*/		if ( !regs.CR[6].lt ) { return 0x820B46F0;  }
		/* 820B46DCh case    7:*/		return 0x820B46E0;
		  /* 820B46E0h */ case    8:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B46E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B46E0h case    8:*/		return 0x820B46E4;
		  /* 820B46E4h */ case    9:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820B46E4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820B46E4h case    9:*/		return 0x820B46E8;
		  /* 820B46E8h */ case   10:  		/* lwzx R28, <#[R11 + R10]> */
		/* 820B46E8h case   10:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B46E8h case   10:*/		return 0x820B46EC;
		  /* 820B46ECh */ case   11:  		/* b 8 */
		/* 820B46ECh case   11:*/		return 0x820B46F4;
		/* 820B46ECh case   11:*/		return 0x820B46F0;
	}
	return 0x820B46F0;
} // Block from 820B46C0h-820B46F0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B46F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B46F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B46F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B46F0);
		  /* 820B46F0h */ case    0:  		/* mr R28, R24 */
		/* 820B46F0h case    0:*/		regs.R28 = regs.R24;
		/* 820B46F0h case    0:*/		return 0x820B46F4;
	}
	return 0x820B46F4;
} // Block from 820B46F0h-820B46F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B46F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B46F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B46F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B46F4);
		  /* 820B46F4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820B46F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820B46F4h case    0:*/		return 0x820B46F8;
		  /* 820B46F8h */ case    1:  		/* bc 12, CR6_EQ, 392 */
		/* 820B46F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B4880;  }
		/* 820B46F8h case    1:*/		return 0x820B46FC;
		  /* 820B46FCh */ case    2:  		/* lwz R11, <#[R28 + 4]> */
		/* 820B46FCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820B46FCh case    2:*/		return 0x820B4700;
		  /* 820B4700h */ case    3:  		/* rlwinm. R10, R11, 0, 20, 20 */
		/* 820B4700h case    3:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R11);
		/* 820B4700h case    3:*/		return 0x820B4704;
		  /* 820B4704h */ case    4:  		/* bc 4, CR0_EQ, 108 */
		/* 820B4704h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820B4770;  }
		/* 820B4704h case    4:*/		return 0x820B4708;
		  /* 820B4708h */ case    5:  		/* ori R11, R11, 2112 */
		/* 820B4708h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x840);
		/* 820B4708h case    5:*/		return 0x820B470C;
		  /* 820B470Ch */ case    6:  		/* stw R27, <#[R28]> */
		/* 820B470Ch case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R28 + 0x00000000) );
		/* 820B470Ch case    6:*/		return 0x820B4710;
		  /* 820B4710h */ case    7:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820B4710h case    7:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820B4710h case    7:*/		return 0x820B4714;
		  /* 820B4714h */ case    8:  		/* stw R11, <#[R28 + 4]> */
		/* 820B4714h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820B4714h case    8:*/		return 0x820B4718;
		  /* 820B4718h */ case    9:  		/* bc 12, CR0_EQ, 252 */
		/* 820B4718h case    9:*/		if ( regs.CR[0].eq ) { return 0x820B4814;  }
		/* 820B4718h case    9:*/		return 0x820B471C;
		  /* 820B471Ch */ case   10:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 820B471Ch case   10:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 820B471Ch case   10:*/		return 0x820B4720;
		  /* 820B4720h */ case   11:  		/* bc 4, CR0_EQ, 244 */
		/* 820B4720h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820B4814;  }
		/* 820B4720h case   11:*/		return 0x820B4724;
		  /* 820B4724h */ case   12:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820B4724h case   12:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820B4724h case   12:*/		return 0x820B4728;
		  /* 820B4728h */ case   13:  		/* bc 12, CR0_EQ, 28 */
		/* 820B4728h case   13:*/		if ( regs.CR[0].eq ) { return 0x820B4744;  }
		/* 820B4728h case   13:*/		return 0x820B472C;
		  /* 820B472Ch */ case   14:  		/* lwz R10, <#[R26 + 8]> */
		/* 820B472Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 820B472Ch case   14:*/		return 0x820B4730;
		  /* 820B4730h */ case   15:  		/* lwz R10, <#[R10 + 112]> */
		/* 820B4730h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000070) );
		/* 820B4730h case   15:*/		return 0x820B4734;
		  /* 820B4734h */ case   16:  		/* rlwinm. R10, R10, 0, 10, 10 */
		/* 820B4734h case   16:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R10,regs.R10);
		/* 820B4734h case   16:*/		return 0x820B4738;
		  /* 820B4738h */ case   17:  		/* bc 12, CR0_EQ, 12 */
		/* 820B4738h case   17:*/		if ( regs.CR[0].eq ) { return 0x820B4744;  }
		/* 820B4738h case   17:*/		return 0x820B473C;
		  /* 820B473Ch */ case   18:  		/* ori R11, R11, 1024 */
		/* 820B473Ch case   18:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 820B473Ch case   18:*/		return 0x820B4740;
		  /* 820B4740h */ case   19:  		/* stw R11, <#[R28 + 4]> */
		/* 820B4740h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820B4740h case   19:*/		return 0x820B4744;
	}
	return 0x820B4744;
} // Block from 820B46F4h-820B4744h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820B4744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4744);
		  /* 820B4744h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 820B4744h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820B4744h case    0:*/		return 0x820B4748;
		  /* 820B4748h */ case    1:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 820B4748h case    1:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 820B4748h case    1:*/		return 0x820B474C;
		  /* 820B474Ch */ case    2:  		/* bc 4, CR0_EQ, 200 */
		/* 820B474Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B4814;  }
		/* 820B474Ch case    2:*/		return 0x820B4750;
		  /* 820B4750h */ case    3:  		/* lwz R10, <#[R26 + 8]> */
		/* 820B4750h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 820B4750h case    3:*/		return 0x820B4754;
		  /* 820B4754h */ case    4:  		/* lwz R10, <#[R10 + 112]> */
		/* 820B4754h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000070) );
		/* 820B4754h case    4:*/		return 0x820B4758;
		  /* 820B4758h */ case    5:  		/* rlwinm. R10, R10, 0, 11, 11 */
		/* 820B4758h case    5:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R10,regs.R10);
		/* 820B4758h case    5:*/		return 0x820B475C;
		  /* 820B475Ch */ case    6:  		/* bc 12, CR0_EQ, 184 */
		/* 820B475Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820B4814;  }
		/* 820B475Ch case    6:*/		return 0x820B4760;
		  /* 820B4760h */ case    7:  		/* oris R11, R11, 16 */
		/* 820B4760h case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 820B4760h case    7:*/		return 0x820B4764;
		  /* 820B4764h */ case    8:  		/* ori R11, R11, 1024 */
		/* 820B4764h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 820B4764h case    8:*/		return 0x820B4768;
		  /* 820B4768h */ case    9:  		/* stw R11, <#[R28 + 4]> */
		/* 820B4768h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820B4768h case    9:*/		return 0x820B476C;
		  /* 820B476Ch */ case   10:  		/* b 168 */
		/* 820B476Ch case   10:*/		return 0x820B4814;
		/* 820B476Ch case   10:*/		return 0x820B4770;
	}
	return 0x820B4770;
} // Block from 820B4744h-820B4770h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B4770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4770);
		  /* 820B4770h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 820B4770h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820B4770h case    0:*/		return 0x820B4774;
		  /* 820B4774h */ case    1:  		/* mr R10, R11 */
		/* 820B4774h case    1:*/		regs.R10 = regs.R11;
		/* 820B4774h case    1:*/		return 0x820B4778;
		  /* 820B4778h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820B4778h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4778h case    2:*/		return 0x820B477C;
		  /* 820B477Ch */ case    3:  		/* addi R11, R11, 1 */
		/* 820B477Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B477Ch case    3:*/		return 0x820B4780;
		  /* 820B4780h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 820B4780h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820B4780h case    4:*/		return 0x820B4784;
		  /* 820B4784h */ case    5:  		/* bc 4, CR6_EQ, -12 */
		/* 820B4784h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820B4778;  }
		/* 820B4784h case    5:*/		return 0x820B4788;
		  /* 820B4788h */ case    6:  		/* subf R10, R10, R11 */
		/* 820B4788h case    6:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820B4788h case    6:*/		return 0x820B478C;
		  /* 820B478Ch */ case    7:  		/* mr R11, R27 */
		/* 820B478Ch case    7:*/		regs.R11 = regs.R27;
		/* 820B478Ch case    7:*/		return 0x820B4790;
		  /* 820B4790h */ case    8:  		/* addi R10, R10, -1 */
		/* 820B4790h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820B4790h case    8:*/		return 0x820B4794;
		  /* 820B4794h */ case    9:  		/* rlwinm R30, R10, 0, 0, 31 */
		/* 820B4794h case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R30,regs.R10);
		/* 820B4794h case    9:*/		return 0x820B4798;
		  /* 820B4798h */ case   10:  		/* lbz R10, <#[R11]> */
		/* 820B4798h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4798h case   10:*/		return 0x820B479C;
		  /* 820B479Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 820B479Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B479Ch case   11:*/		return 0x820B47A0;
		  /* 820B47A0h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 820B47A0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B47A0h case   12:*/		return 0x820B47A4;
		  /* 820B47A4h */ case   13:  		/* bc 4, CR6_EQ, -12 */
		/* 820B47A4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820B4798;  }
		/* 820B47A4h case   13:*/		return 0x820B47A8;
		  /* 820B47A8h */ case   14:  		/* subf R11, R27, R11 */
		/* 820B47A8h case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 820B47A8h case   14:*/		return 0x820B47AC;
		  /* 820B47ACh */ case   15:  		/* lwz R3, <#[R26]> */
		/* 820B47ACh case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000000) );
		/* 820B47ACh case   15:*/		return 0x820B47B0;
		  /* 820B47B0h */ case   16:  		/* li R5, 4 */
		/* 820B47B0h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820B47B0h case   16:*/		return 0x820B47B4;
		  /* 820B47B4h */ case   17:  		/* addi R11, R11, -1 */
		/* 820B47B4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820B47B4h case   17:*/		return 0x820B47B8;
		  /* 820B47B8h */ case   18:  		/* rlwinm R29, R11, 0, 0, 31 */
		/* 820B47B8h case   18:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R29,regs.R11);
		/* 820B47B8h case   18:*/		return 0x820B47BC;
		  /* 820B47BCh */ case   19:  		/* add R11, R29, R30 */
		/* 820B47BCh case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R30);
		/* 820B47BCh case   19:*/		return 0x820B47C0;
		  /* 820B47C0h */ case   20:  		/* addi R4, R11, 3 */
		/* 820B47C0h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3);
		/* 820B47C0h case   20:*/		return 0x820B47C4;
		  /* 820B47C4h */ case   21:  		/* bl 84252 */
		/* 820B47C4h case   21:*/		regs.LR = 0x820B47C8; return 0x820C90E0;
		/* 820B47C4h case   21:*/		return 0x820B47C8;
		  /* 820B47C8h */ case   22:  		/* or. R31, R3, R3 */
		/* 820B47C8h case   22:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820B47C8h case   22:*/		return 0x820B47CC;
		  /* 820B47CCh */ case   23:  		/* bc 12, CR0_EQ, 180 */
		/* 820B47CCh case   23:*/		if ( regs.CR[0].eq ) { return 0x820B4880;  }
		/* 820B47CCh case   23:*/		return 0x820B47D0;
		  /* 820B47D0h */ case   24:  		/* mr R5, R30 */
		/* 820B47D0h case   24:*/		regs.R5 = regs.R30;
		/* 820B47D0h case   24:*/		return 0x820B47D4;
		  /* 820B47D4h */ case   25:  		/* lwz R4, <#[R28]> */
		/* 820B47D4h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 820B47D4h case   25:*/		return 0x820B47D8;
		  /* 820B47D8h */ case   26:  		/* mr R3, R31 */
		/* 820B47D8h case   26:*/		regs.R3 = regs.R31;
		/* 820B47D8h case   26:*/		return 0x820B47DC;
		  /* 820B47DCh */ case   27:  		/* bl -142892 */
		/* 820B47DCh case   27:*/		regs.LR = 0x820B47E0; return 0x820919B0;
		/* 820B47DCh case   27:*/		return 0x820B47E0;
		  /* 820B47E0h */ case   28:  		/* add R11, R31, R30 */
		/* 820B47E0h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 820B47E0h case   28:*/		return 0x820B47E4;
		  /* 820B47E4h */ case   29:  		/* li R10, 59 */
		/* 820B47E4h case   29:*/		cpu::op::li<0>(regs,&regs.R10,0x3B);
		/* 820B47E4h case   29:*/		return 0x820B47E8;
		  /* 820B47E8h */ case   30:  		/* li R9, 32 */
		/* 820B47E8h case   30:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 820B47E8h case   30:*/		return 0x820B47EC;
		  /* 820B47ECh */ case   31:  		/* stbx R10, <#[R31 + R30]> */
		/* 820B47ECh case   31:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 820B47ECh case   31:*/		return 0x820B47F0;
		  /* 820B47F0h */ case   32:  		/* mr R5, R29 */
		/* 820B47F0h case   32:*/		regs.R5 = regs.R29;
		/* 820B47F0h case   32:*/		return 0x820B47F4;
		  /* 820B47F4h */ case   33:  		/* mr R4, R27 */
		/* 820B47F4h case   33:*/		regs.R4 = regs.R27;
		/* 820B47F4h case   33:*/		return 0x820B47F8;
		  /* 820B47F8h */ case   34:  		/* stb R9, <#[R11 + 1]> */
		/* 820B47F8h case   34:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000001) );
		/* 820B47F8h case   34:*/		return 0x820B47FC;
		  /* 820B47FCh */ case   35:  		/* addi R3, R11, 2 */
		/* 820B47FCh case   35:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2);
		/* 820B47FCh case   35:*/		return 0x820B4800;
		  /* 820B4800h */ case   36:  		/* bl -142928 */
		/* 820B4800h case   36:*/		regs.LR = 0x820B4804; return 0x820919B0;
		/* 820B4800h case   36:*/		return 0x820B4804;
		  /* 820B4804h */ case   37:  		/* add R11, R31, R29 */
		/* 820B4804h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 820B4804h case   37:*/		return 0x820B4808;
		  /* 820B4808h */ case   38:  		/* add R11, R11, R30 */
		/* 820B4808h case   38:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820B4808h case   38:*/		return 0x820B480C;
		  /* 820B480Ch */ case   39:  		/* stb R24, <#[R11 + 2]> */
		/* 820B480Ch case   39:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R11 + 0x00000002) );
		/* 820B480Ch case   39:*/		return 0x820B4810;
		  /* 820B4810h */ case   40:  		/* stw R31, <#[R28]> */
		/* 820B4810h case   40:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 820B4810h case   40:*/		return 0x820B4814;
	}
	return 0x820B4814;
} // Block from 820B4770h-820B4814h (41 instructions)

//////////////////////////////////////////////////////
// Block at 820B4814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4814);
		  /* 820B4814h */ case    0:  		/* li R28, 1 */
		/* 820B4814h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820B4814h case    0:*/		return 0x820B4818;
	}
	return 0x820B4818;
} // Block from 820B4814h-820B4818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B4818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4818);
		  /* 820B4818h */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 820B4818h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820B4818h case    0:*/		return 0x820B481C;
		  /* 820B481Ch */ case    1:  		/* bc 4, CR6_EQ, -540 */
		/* 820B481Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B4600;  }
		/* 820B481Ch case    1:*/		return 0x820B4820;
	}
	return 0x820B4820;
} // Block from 820B4818h-820B4820h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B4820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4820);
		  /* 820B4820h */ case    0:  		/* addi R11, R1, 96 */
		/* 820B4820h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 820B4820h case    0:*/		return 0x820B4824;
		  /* 820B4824h */ case    1:  		/* mr R10, R20 */
		/* 820B4824h case    1:*/		regs.R10 = regs.R20;
		/* 820B4824h case    1:*/		return 0x820B4828;
		  /* 820B4828h */ case    2:  		/* mr R9, R21 */
		/* 820B4828h case    2:*/		regs.R9 = regs.R21;
		/* 820B4828h case    2:*/		return 0x820B482C;
		  /* 820B482Ch */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 820B482Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820B482Ch case    3:*/		return 0x820B4830;
		  /* 820B4830h */ case    4:  		/* mr R8, R28 */
		/* 820B4830h case    4:*/		regs.R8 = regs.R28;
		/* 820B4830h case    4:*/		return 0x820B4834;
		  /* 820B4834h */ case    5:  		/* mr R7, R23 */
		/* 820B4834h case    5:*/		regs.R7 = regs.R23;
		/* 820B4834h case    5:*/		return 0x820B4838;
		  /* 820B4838h */ case    6:  		/* mr R6, R25 */
		/* 820B4838h case    6:*/		regs.R6 = regs.R25;
		/* 820B4838h case    6:*/		return 0x820B483C;
		  /* 820B483Ch */ case    7:  		/* mr R5, R18 */
		/* 820B483Ch case    7:*/		regs.R5 = regs.R18;
		/* 820B483Ch case    7:*/		return 0x820B4840;
		  /* 820B4840h */ case    8:  		/* mr R4, R19 */
		/* 820B4840h case    8:*/		regs.R4 = regs.R19;
		/* 820B4840h case    8:*/		return 0x820B4844;
		  /* 820B4844h */ case    9:  		/* mr R3, R26 */
		/* 820B4844h case    9:*/		regs.R3 = regs.R26;
		/* 820B4844h case    9:*/		return 0x820B4848;
		  /* 820B4848h */ case   10:  		/* bl -12224 */
		/* 820B4848h case   10:*/		regs.LR = 0x820B484C; return 0x820B1888;
		/* 820B4848h case   10:*/		return 0x820B484C;
		  /* 820B484Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820B484Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B484Ch case   11:*/		return 0x820B4850;
		  /* 820B4850h */ case   12:  		/* bc 12, CR0_LT, 28 */
		/* 820B4850h case   12:*/		if ( regs.CR[0].lt ) { return 0x820B486C;  }
		/* 820B4850h case   12:*/		return 0x820B4854;
	}
	return 0x820B4854;
} // Block from 820B4820h-820B4854h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820B4854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4854);
		  /* 820B4854h */ case    0:  		/* lwz R11, <#[R1 + 340]> */
		/* 820B4854h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000154) );
		/* 820B4854h case    0:*/		return 0x820B4858;
		  /* 820B4858h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820B4858h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B4858h case    1:*/		return 0x820B485C;
		  /* 820B485Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820B485Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820B4868;  }
		/* 820B485Ch case    2:*/		return 0x820B4860;
		  /* 820B4860h */ case    3:  		/* lwz R10, <#[R1 + 96]> */
		/* 820B4860h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 820B4860h case    3:*/		return 0x820B4864;
		  /* 820B4864h */ case    4:  		/* stw R10, <#[R11]> */
		/* 820B4864h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4864h case    4:*/		return 0x820B4868;
	}
	return 0x820B4868;
} // Block from 820B4854h-820B4868h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B4868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4868);
		  /* 820B4868h */ case    0:  		/* li R3, 0 */
		/* 820B4868h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B4868h case    0:*/		return 0x820B486C;
	}
	return 0x820B486C;
} // Block from 820B4868h-820B486Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B486Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B486C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B486C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B486C);
		  /* 820B486Ch */ case    0:  		/* addi R1, R1, 240 */
		/* 820B486Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820B486Ch case    0:*/		return 0x820B4870;
		  /* 820B4870h */ case    1:  		/* b -144880 */
		/* 820B4870h case    1:*/		return 0x82091280;
		/* 820B4870h case    1:*/		return 0x820B4874;
	}
	return 0x820B4874;
} // Block from 820B486Ch-820B4874h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B4874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4874);
		  /* 820B4874h */ case    0:  		/* lis R3, -32768 */
		/* 820B4874h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820B4874h case    0:*/		return 0x820B4878;
		  /* 820B4878h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820B4878h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820B4878h case    1:*/		return 0x820B487C;
		  /* 820B487Ch */ case    2:  		/* b -16 */
		/* 820B487Ch case    2:*/		return 0x820B486C;
		/* 820B487Ch case    2:*/		return 0x820B4880;
	}
	return 0x820B4880;
} // Block from 820B4874h-820B4880h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B4880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4880);
		  /* 820B4880h */ case    0:  		/* lis R3, -32761 */
		/* 820B4880h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820B4880h case    0:*/		return 0x820B4884;
		  /* 820B4884h */ case    1:  		/* ori R3, R3, 14 */
		/* 820B4884h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820B4884h case    1:*/		return 0x820B4888;
		  /* 820B4888h */ case    2:  		/* b -28 */
		/* 820B4888h case    2:*/		return 0x820B486C;
		/* 820B4888h case    2:*/		return 0x820B488C;
		  /* 820B488Ch */ case    3:  		/* nop */
		/* 820B488Ch case    3:*/		cpu::op::nop();
		/* 820B488Ch case    3:*/		return 0x820B4890;
	}
	return 0x820B4890;
} // Block from 820B4880h-820B4890h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4890);
		  /* 820B4890h */ case    0:  		/* mfspr R12, LR */
		/* 820B4890h case    0:*/		regs.R12 = regs.LR;
		/* 820B4890h case    0:*/		return 0x820B4894;
		  /* 820B4894h */ case    1:  		/* bl -144972 */
		/* 820B4894h case    1:*/		regs.LR = 0x820B4898; return 0x82091248;
		/* 820B4894h case    1:*/		return 0x820B4898;
		  /* 820B4898h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820B4898h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820B4898h case    2:*/		return 0x820B489C;
		  /* 820B489Ch */ case    3:  		/* mr R31, R3 */
		/* 820B489Ch case    3:*/		regs.R31 = regs.R3;
		/* 820B489Ch case    3:*/		return 0x820B48A0;
		  /* 820B48A0h */ case    4:  		/* mr R29, R4 */
		/* 820B48A0h case    4:*/		regs.R29 = regs.R4;
		/* 820B48A0h case    4:*/		return 0x820B48A4;
		  /* 820B48A4h */ case    5:  		/* mr R27, R5 */
		/* 820B48A4h case    5:*/		regs.R27 = regs.R5;
		/* 820B48A4h case    5:*/		return 0x820B48A8;
		  /* 820B48A8h */ case    6:  		/* mr R26, R7 */
		/* 820B48A8h case    6:*/		regs.R26 = regs.R7;
		/* 820B48A8h case    6:*/		return 0x820B48AC;
		  /* 820B48ACh */ case    7:  		/* mr R25, R8 */
		/* 820B48ACh case    7:*/		regs.R25 = regs.R8;
		/* 820B48ACh case    7:*/		return 0x820B48B0;
		  /* 820B48B0h */ case    8:  		/* mr R30, R9 */
		/* 820B48B0h case    8:*/		regs.R30 = regs.R9;
		/* 820B48B0h case    8:*/		return 0x820B48B4;
		  /* 820B48B4h */ case    9:  		/* mr R24, R10 */
		/* 820B48B4h case    9:*/		regs.R24 = regs.R10;
		/* 820B48B4h case    9:*/		return 0x820B48B8;
		  /* 820B48B8h */ case   10:  		/* cmplwi CR6, R4, 0 */
		/* 820B48B8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820B48B8h case   10:*/		return 0x820B48BC;
		  /* 820B48BCh */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 820B48BCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x820B48C8;  }
		/* 820B48BCh case   11:*/		return 0x820B48C0;
		  /* 820B48C0h */ case   12:  		/* li R3, 0 */
		/* 820B48C0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B48C0h case   12:*/		return 0x820B48C4;
		  /* 820B48C4h */ case   13:  		/* b 276 */
		/* 820B48C4h case   13:*/		return 0x820B49D8;
		/* 820B48C4h case   13:*/		return 0x820B48C8;
	}
	return 0x820B48C8;
} // Block from 820B4890h-820B48C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820B48C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B48C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B48C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B48C8);
		  /* 820B48C8h */ case    0:  		/* lwz R3, <#[R31 + 8]> */
		/* 820B48C8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820B48C8h case    0:*/		return 0x820B48CC;
		  /* 820B48CCh */ case    1:  		/* li R28, 0 */
		/* 820B48CCh case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820B48CCh case    1:*/		return 0x820B48D0;
		  /* 820B48D0h */ case    2:  		/* stw R28, <#[R1 + 112]> */
		/* 820B48D0h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000070) );
		/* 820B48D0h case    2:*/		return 0x820B48D4;
		  /* 820B48D4h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 820B48D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820B48D4h case    3:*/		return 0x820B48D8;
		  /* 820B48D8h */ case    4:  		/* cmplw CR6, R6, R11 */
		/* 820B48D8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820B48D8h case    4:*/		return 0x820B48DC;
		  /* 820B48DCh */ case    5:  		/* bc 4, CR6_LT, 20 */
		/* 820B48DCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x820B48F0;  }
		/* 820B48DCh case    5:*/		return 0x820B48E0;
		  /* 820B48E0h */ case    6:  		/* lwz R11, <#[R3 + 16]> */
		/* 820B48E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820B48E0h case    6:*/		return 0x820B48E4;
		  /* 820B48E4h */ case    7:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 820B48E4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 820B48E4h case    7:*/		return 0x820B48E8;
		  /* 820B48E8h */ case    8:  		/* lwzx R4, <#[R11 + R10]> */
		/* 820B48E8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B48E8h case    8:*/		return 0x820B48EC;
		  /* 820B48ECh */ case    9:  		/* b 8 */
		/* 820B48ECh case    9:*/		return 0x820B48F4;
		/* 820B48ECh case    9:*/		return 0x820B48F0;
	}
	return 0x820B48F0;
} // Block from 820B48C8h-820B48F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B48F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B48F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B48F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B48F0);
		  /* 820B48F0h */ case    0:  		/* mr R4, R28 */
		/* 820B48F0h case    0:*/		regs.R4 = regs.R28;
		/* 820B48F0h case    0:*/		return 0x820B48F4;
	}
	return 0x820B48F4;
} // Block from 820B48F0h-820B48F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B48F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B48F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B48F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B48F4);
		  /* 820B48F4h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820B48F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820B48F4h case    0:*/		return 0x820B48F8;
		  /* 820B48F8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820B48F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B4908;  }
		/* 820B48F8h case    1:*/		return 0x820B48FC;
		  /* 820B48FCh */ case    2:  		/* lis R3, -32768 */
		/* 820B48FCh case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820B48FCh case    2:*/		return 0x820B4900;
		  /* 820B4900h */ case    3:  		/* ori R3, R3, 16389 */
		/* 820B4900h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820B4900h case    3:*/		return 0x820B4904;
		  /* 820B4904h */ case    4:  		/* b 212 */
		/* 820B4904h case    4:*/		return 0x820B49D8;
		/* 820B4904h case    4:*/		return 0x820B4908;
	}
	return 0x820B4908;
} // Block from 820B48F4h-820B4908h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B4908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4908);
		  /* 820B4908h */ case    0:  		/* bl 297560 */
		/* 820B4908h case    0:*/		regs.LR = 0x820B490C; return 0x820FD360;
		/* 820B4908h case    0:*/		return 0x820B490C;
		  /* 820B490Ch */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B490Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B490Ch case    1:*/		return 0x820B4910;
		  /* 820B4910h */ case    2:  		/* mr R6, R3 */
		/* 820B4910h case    2:*/		regs.R6 = regs.R3;
		/* 820B4910h case    2:*/		return 0x820B4914;
		  /* 820B4914h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B4914h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4914h case    3:*/		return 0x820B4918;
		  /* 820B4918h */ case    4:  		/* cmplw CR6, R3, R10 */
		/* 820B4918h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820B4918h case    4:*/		return 0x820B491C;
		  /* 820B491Ch */ case    5:  		/* bc 4, CR6_LT, 20 */
		/* 820B491Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x820B4930;  }
		/* 820B491Ch case    5:*/		return 0x820B4920;
		  /* 820B4920h */ case    6:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B4920h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B4920h case    6:*/		return 0x820B4924;
		  /* 820B4924h */ case    7:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820B4924h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820B4924h case    7:*/		return 0x820B4928;
		  /* 820B4928h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B4928h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B4928h case    8:*/		return 0x820B492C;
		  /* 820B492Ch */ case    9:  		/* b 8 */
		/* 820B492Ch case    9:*/		return 0x820B4934;
		/* 820B492Ch case    9:*/		return 0x820B4930;
	}
	return 0x820B4930;
} // Block from 820B4908h-820B4930h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B4930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4930);
		  /* 820B4930h */ case    0:  		/* mr R11, R28 */
		/* 820B4930h case    0:*/		regs.R11 = regs.R28;
		/* 820B4930h case    0:*/		return 0x820B4934;
	}
	return 0x820B4934;
} // Block from 820B4930h-820B4934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B4934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4934);
		  /* 820B4934h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820B4934h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820B4934h case    0:*/		return 0x820B4938;
		  /* 820B4938h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820B4938h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B4948;  }
		/* 820B4938h case    1:*/		return 0x820B493C;
		  /* 820B493Ch */ case    2:  		/* lis R3, -32761 */
		/* 820B493Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820B493Ch case    2:*/		return 0x820B4940;
		  /* 820B4940h */ case    3:  		/* ori R3, R3, 14 */
		/* 820B4940h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820B4940h case    3:*/		return 0x820B4944;
		  /* 820B4944h */ case    4:  		/* b 148 */
		/* 820B4944h case    4:*/		return 0x820B49D8;
		/* 820B4944h case    4:*/		return 0x820B4948;
	}
	return 0x820B4948;
} // Block from 820B4934h-820B4948h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B4948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4948);
		  /* 820B4948h */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B4948h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4948h case    0:*/		return 0x820B494C;
		  /* 820B494Ch */ case    1:  		/* ori R10, R10, 64 */
		/* 820B494Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x40);
		/* 820B494Ch case    1:*/		return 0x820B4950;
		  /* 820B4950h */ case    2:  		/* rlwinm. R9, R10, 0, 27, 27 */
		/* 820B4950h case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R10);
		/* 820B4950h case    2:*/		return 0x820B4954;
		  /* 820B4954h */ case    3:  		/* stw R10, <#[R11 + 4]> */
		/* 820B4954h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4954h case    3:*/		return 0x820B4958;
		  /* 820B4958h */ case    4:  		/* bc 12, CR0_EQ, 84 */
		/* 820B4958h case    4:*/		if ( regs.CR[0].eq ) { return 0x820B49AC;  }
		/* 820B4958h case    4:*/		return 0x820B495C;
		  /* 820B495Ch */ case    5:  		/* rlwinm. R9, R10, 0, 24, 24 */
		/* 820B495Ch case    5:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R9,regs.R10);
		/* 820B495Ch case    5:*/		return 0x820B4960;
		  /* 820B4960h */ case    6:  		/* bc 4, CR0_EQ, 76 */
		/* 820B4960h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820B49AC;  }
		/* 820B4960h case    6:*/		return 0x820B4964;
		  /* 820B4964h */ case    7:  		/* rlwinm. R9, R10, 0, 22, 22 */
		/* 820B4964h case    7:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R9,regs.R10);
		/* 820B4964h case    7:*/		return 0x820B4968;
		  /* 820B4968h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 820B4968h case    8:*/		if ( regs.CR[0].eq ) { return 0x820B4984;  }
		/* 820B4968h case    8:*/		return 0x820B496C;
		  /* 820B496Ch */ case    9:  		/* lwz R9, <#[R31 + 8]> */
		/* 820B496Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820B496Ch case    9:*/		return 0x820B4970;
		  /* 820B4970h */ case   10:  		/* lwz R9, <#[R9 + 112]> */
		/* 820B4970h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000070) );
		/* 820B4970h case   10:*/		return 0x820B4974;
		  /* 820B4974h */ case   11:  		/* rlwinm. R9, R9, 0, 10, 10 */
		/* 820B4974h case   11:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R9,regs.R9);
		/* 820B4974h case   11:*/		return 0x820B4978;
		  /* 820B4978h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 820B4978h case   12:*/		if ( regs.CR[0].eq ) { return 0x820B4984;  }
		/* 820B4978h case   12:*/		return 0x820B497C;
		  /* 820B497Ch */ case   13:  		/* ori R10, R10, 1024 */
		/* 820B497Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x400);
		/* 820B497Ch case   13:*/		return 0x820B4980;
		  /* 820B4980h */ case   14:  		/* stw R10, <#[R11 + 4]> */
		/* 820B4980h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4980h case   14:*/		return 0x820B4984;
	}
	return 0x820B4984;
} // Block from 820B4948h-820B4984h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820B4984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4984);
		  /* 820B4984h */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 820B4984h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4984h case    0:*/		return 0x820B4988;
		  /* 820B4988h */ case    1:  		/* rlwinm. R9, R10, 0, 22, 22 */
		/* 820B4988h case    1:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R9,regs.R10);
		/* 820B4988h case    1:*/		return 0x820B498C;
		  /* 820B498Ch */ case    2:  		/* bc 4, CR0_EQ, 32 */
		/* 820B498Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820B49AC;  }
		/* 820B498Ch case    2:*/		return 0x820B4990;
		  /* 820B4990h */ case    3:  		/* lwz R9, <#[R31 + 8]> */
		/* 820B4990h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4990h case    3:*/		return 0x820B4994;
		  /* 820B4994h */ case    4:  		/* lwz R9, <#[R9 + 112]> */
		/* 820B4994h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000070) );
		/* 820B4994h case    4:*/		return 0x820B4998;
		  /* 820B4998h */ case    5:  		/* rlwinm. R9, R9, 0, 11, 11 */
		/* 820B4998h case    5:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R9,regs.R9);
		/* 820B4998h case    5:*/		return 0x820B499C;
		  /* 820B499Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820B499Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820B49AC;  }
		/* 820B499Ch case    6:*/		return 0x820B49A0;
		  /* 820B49A0h */ case    7:  		/* oris R10, R10, 16 */
		/* 820B49A0h case    7:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x10);
		/* 820B49A0h case    7:*/		return 0x820B49A4;
		  /* 820B49A4h */ case    8:  		/* ori R10, R10, 1024 */
		/* 820B49A4h case    8:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x400);
		/* 820B49A4h case    8:*/		return 0x820B49A8;
		  /* 820B49A8h */ case    9:  		/* stw R10, <#[R11 + 4]> */
		/* 820B49A8h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820B49A8h case    9:*/		return 0x820B49AC;
	}
	return 0x820B49AC;
} // Block from 820B4984h-820B49ACh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B49ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B49AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B49AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B49AC);
		  /* 820B49ACh */ case    0:  		/* addi R10, R1, 112 */
		/* 820B49ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 820B49ACh case    0:*/		return 0x820B49B0;
		  /* 820B49B0h */ case    1:  		/* stw R24, <#[R1 + 92]> */
		/* 820B49B0h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x0000005C) );
		/* 820B49B0h case    1:*/		return 0x820B49B4;
		  /* 820B49B4h */ case    2:  		/* mr R9, R30 */
		/* 820B49B4h case    2:*/		regs.R9 = regs.R30;
		/* 820B49B4h case    2:*/		return 0x820B49B8;
		  /* 820B49B8h */ case    3:  		/* stw R30, <#[R1 + 84]> */
		/* 820B49B8h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 820B49B8h case    3:*/		return 0x820B49BC;
		  /* 820B49BCh */ case    4:  		/* mr R8, R25 */
		/* 820B49BCh case    4:*/		regs.R8 = regs.R25;
		/* 820B49BCh case    4:*/		return 0x820B49C0;
		  /* 820B49C0h */ case    5:  		/* stw R28, <#[R1 + 100]> */
		/* 820B49C0h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000064) );
		/* 820B49C0h case    5:*/		return 0x820B49C4;
		  /* 820B49C4h */ case    6:  		/* mr R7, R26 */
		/* 820B49C4h case    6:*/		regs.R7 = regs.R26;
		/* 820B49C4h case    6:*/		return 0x820B49C8;
		  /* 820B49C8h */ case    7:  		/* mr R5, R27 */
		/* 820B49C8h case    7:*/		regs.R5 = regs.R27;
		/* 820B49C8h case    7:*/		return 0x820B49CC;
		  /* 820B49CCh */ case    8:  		/* mr R4, R29 */
		/* 820B49CCh case    8:*/		regs.R4 = regs.R29;
		/* 820B49CCh case    8:*/		return 0x820B49D0;
		  /* 820B49D0h */ case    9:  		/* mr R3, R31 */
		/* 820B49D0h case    9:*/		regs.R3 = regs.R31;
		/* 820B49D0h case    9:*/		return 0x820B49D4;
		  /* 820B49D4h */ case   10:  		/* bl -1108 */
		/* 820B49D4h case   10:*/		regs.LR = 0x820B49D8; return 0x820B4580;
		/* 820B49D4h case   10:*/		return 0x820B49D8;
	}
	return 0x820B49D8;
} // Block from 820B49ACh-820B49D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B49D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B49D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B49D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B49D8);
		  /* 820B49D8h */ case    0:  		/* addi R1, R1, 192 */
		/* 820B49D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820B49D8h case    0:*/		return 0x820B49DC;
		  /* 820B49DCh */ case    1:  		/* b -145220 */
		/* 820B49DCh case    1:*/		return 0x82091298;
		/* 820B49DCh case    1:*/		return 0x820B49E0;
	}
	return 0x820B49E0;
} // Block from 820B49D8h-820B49E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B49E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B49E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B49E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B49E0);
		  /* 820B49E0h */ case    0:  		/* mfspr R12, LR */
		/* 820B49E0h case    0:*/		regs.R12 = regs.LR;
		/* 820B49E0h case    0:*/		return 0x820B49E4;
		  /* 820B49E4h */ case    1:  		/* bl -145304 */
		/* 820B49E4h case    1:*/		regs.LR = 0x820B49E8; return 0x8209124C;
		/* 820B49E4h case    1:*/		return 0x820B49E8;
		  /* 820B49E8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820B49E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820B49E8h case    2:*/		return 0x820B49EC;
		  /* 820B49ECh */ case    3:  		/* mr R28, R3 */
		/* 820B49ECh case    3:*/		regs.R28 = regs.R3;
		/* 820B49ECh case    3:*/		return 0x820B49F0;
		  /* 820B49F0h */ case    4:  		/* mr R25, R4 */
		/* 820B49F0h case    4:*/		regs.R25 = regs.R4;
		/* 820B49F0h case    4:*/		return 0x820B49F4;
		  /* 820B49F4h */ case    5:  		/* mr R26, R5 */
		/* 820B49F4h case    5:*/		regs.R26 = regs.R5;
		/* 820B49F4h case    5:*/		return 0x820B49F8;
		  /* 820B49F8h */ case    6:  		/* mr R27, R6 */
		/* 820B49F8h case    6:*/		regs.R27 = regs.R6;
		/* 820B49F8h case    6:*/		return 0x820B49FC;
		  /* 820B49FCh */ case    7:  		/* li R8, 1 */
		/* 820B49FCh case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820B49FCh case    7:*/		return 0x820B4A00;
		  /* 820B4A00h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 820B4A00h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820B4A00h case    8:*/		return 0x820B4A04;
		  /* 820B4A04h */ case    9:  		/* bc 12, CR6_EQ, 180 */
		/* 820B4A04h case    9:*/		if ( regs.CR[6].eq ) { return 0x820B4AB8;  }
		/* 820B4A04h case    9:*/		return 0x820B4A08;
		  /* 820B4A08h */ case   10:  		/* mtspr CTR, R6 */
		/* 820B4A08h case   10:*/		regs.CTR = regs.R6;
		/* 820B4A08h case   10:*/		return 0x820B4A0C;
		  /* 820B4A0Ch */ case   11:  		/* mr R9, R5 */
		/* 820B4A0Ch case   11:*/		regs.R9 = regs.R5;
		/* 820B4A0Ch case   11:*/		return 0x820B4A10;
		  /* 820B4A10h */ case   12:  		/* lwz R11, <#[R28 + 8]> */
		/* 820B4A10h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820B4A10h case   12:*/		return 0x820B4A14;
		  /* 820B4A14h */ case   13:  		/* lwz R10, <#[R9]> */
		/* 820B4A14h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820B4A14h case   13:*/		return 0x820B4A18;
		  /* 820B4A18h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B4A18h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B4A18h case   14:*/		return 0x820B4A1C;
		  /* 820B4A1Ch */ case   15:  		/* lwz R11, <#[R11 + 20]> */
		/* 820B4A1Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820B4A1Ch case   15:*/		return 0x820B4A20;
		  /* 820B4A20h */ case   16:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B4A20h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B4A20h case   16:*/		return 0x820B4A24;
		  /* 820B4A24h */ case   17:  		/* lwz R10, <#[R11 + 52]> */
		/* 820B4A24h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 820B4A24h case   17:*/		return 0x820B4A28;
		  /* 820B4A28h */ case   18:  		/* b 80 */
		/* 820B4A28h case   18:*/		return 0x820B4A78;
		/* 820B4A28h case   18:*/		return 0x820B4A2C;
		  /* 820B4A2Ch */ case   19:  		/* lwz R10, <#[R11 + 8]> */
		/* 820B4A2Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B4A2Ch case   19:*/		return 0x820B4A30;
		  /* 820B4A30h */ case   20:  		/* cmpwi CR6, R10, -1 */
		/* 820B4A30h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B4A30h case   20:*/		return 0x820B4A34;
		  /* 820B4A34h */ case   21:  		/* bc 4, CR6_EQ, 76 */
		/* 820B4A34h case   21:*/		if ( !regs.CR[6].eq ) { return 0x820B4A80;  }
		/* 820B4A34h case   21:*/		return 0x820B4A38;
	}
	return 0x820B4A38;
} // Block from 820B49E0h-820B4A38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820B4A38h
// Function '?EmitClip@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4A38);
		  /* 820B4A38h */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 820B4A38h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 820B4A38h case    0:*/		return 0x820B4A3C;
		  /* 820B4A3Ch */ case    1:  		/* lwz R7, <#[R11 + 52]> */
		/* 820B4A3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000034) );
		/* 820B4A3Ch case    1:*/		return 0x820B4A40;
		  /* 820B4A40h */ case    2:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820B4A40h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820B4A40h case    2:*/		return 0x820B4A44;
		  /* 820B4A44h */ case    3:  		/* lwz R10, <#[R10 + 20]> */
		/* 820B4A44h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820B4A44h case    3:*/		return 0x820B4A48;
		  /* 820B4A48h */ case    4:  		/* lwzx R10, <#[R7 + R10]> */
		/* 820B4A48h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820B4A48h case    4:*/		return 0x820B4A4C;
		  /* 820B4A4Ch */ case    5:  		/* lwz R7, <#[R10 + 96]> */
		/* 820B4A4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000060) );
		/* 820B4A4Ch case    5:*/		return 0x820B4A50;
		  /* 820B4A50h */ case    6:  		/* cmplwi CR6, R7, 0 */
		/* 820B4A50h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820B4A50h case    6:*/		return 0x820B4A54;
		  /* 820B4A54h */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 820B4A54h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820B4A68;  }
		/* 820B4A54h case    7:*/		return 0x820B4A58;
		  /* 820B4A58h */ case    8:  		/* lwz R7, <#[R11 + 96]> */
		/* 820B4A58h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000060) );
		/* 820B4A58h case    8:*/		return 0x820B4A5C;
		  /* 820B4A5Ch */ case    9:  		/* stw R7, <#[R10 + 96]> */
		/* 820B4A5Ch case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000060) );
		/* 820B4A5Ch case    9:*/		return 0x820B4A60;
		  /* 820B4A60h */ case   10:  		/* lwz R7, <#[R11 + 100]> */
		/* 820B4A60h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000064) );
		/* 820B4A60h case   10:*/		return 0x820B4A64;
		  /* 820B4A64h */ case   11:  		/* stw R7, <#[R10 + 100]> */
		/* 820B4A64h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000064) );
		/* 820B4A64h case   11:*/		return 0x820B4A68;
	}
	return 0x820B4A68;
} // Block from 820B4A38h-820B4A68h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B4A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4A68);
		  /* 820B4A68h */ case    0:  		/* lwz R7, <#[R11 + 52]> */
		/* 820B4A68h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000034) );
		/* 820B4A68h case    0:*/		return 0x820B4A6C;
		  /* 820B4A6Ch */ case    1:  		/* mr R11, R10 */
		/* 820B4A6Ch case    1:*/		regs.R11 = regs.R10;
		/* 820B4A6Ch case    1:*/		return 0x820B4A70;
		  /* 820B4A70h */ case    2:  		/* stw R7, <#[R9]> */
		/* 820B4A70h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 820B4A70h case    2:*/		return 0x820B4A74;
		  /* 820B4A74h */ case    3:  		/* lwz R10, <#[R10 + 52]> */
		/* 820B4A74h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000034) );
		/* 820B4A74h case    3:*/		return 0x820B4A78;
	}
	return 0x820B4A78;
} // Block from 820B4A68h-820B4A78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4A78);
		  /* 820B4A78h */ case    0:  		/* cmpwi CR6, R10, -1 */
		/* 820B4A78h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B4A78h case    0:*/		return 0x820B4A7C;
		  /* 820B4A7Ch */ case    1:  		/* bc 4, CR6_EQ, -80 */
		/* 820B4A7Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B4A2C;  }
		/* 820B4A7Ch case    1:*/		return 0x820B4A80;
	}
	return 0x820B4A80;
} // Block from 820B4A78h-820B4A80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B4A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4A80);
		  /* 820B4A80h */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 820B4A80h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 820B4A80h case    0:*/		return 0x820B4A84;
		  /* 820B4A84h */ case    1:  		/* lwz R7, <#[R11 + 4]> */
		/* 820B4A84h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4A84h case    1:*/		return 0x820B4A88;
		  /* 820B4A88h */ case    2:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820B4A88h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820B4A88h case    2:*/		return 0x820B4A8C;
		  /* 820B4A8Ch */ case    3:  		/* lwz R10, <#[R10 + 16]> */
		/* 820B4A8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820B4A8Ch case    3:*/		return 0x820B4A90;
		  /* 820B4A90h */ case    4:  		/* lwzx R10, <#[R7 + R10]> */
		/* 820B4A90h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820B4A90h case    4:*/		return 0x820B4A94;
		  /* 820B4A94h */ case    5:  		/* lwz R10, <#[R10 + 4]> */
		/* 820B4A94h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820B4A94h case    5:*/		return 0x820B4A98;
		  /* 820B4A98h */ case    6:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 820B4A98h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 820B4A98h case    6:*/		return 0x820B4A9C;
		  /* 820B4A9Ch */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820B4A9Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820B4AAC;  }
		/* 820B4A9Ch case    7:*/		return 0x820B4AA0;
		  /* 820B4AA0h */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 820B4AA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820B4AA0h case    8:*/		return 0x820B4AA4;
		  /* 820B4AA4h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 820B4AA4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B4AA4h case    9:*/		return 0x820B4AA8;
		  /* 820B4AA8h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 820B4AA8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820B4AB0;  }
		/* 820B4AA8h case   10:*/		return 0x820B4AAC;
	}
	return 0x820B4AAC;
} // Block from 820B4A80h-820B4AACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820B4AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4AAC);
		  /* 820B4AACh */ case    0:  		/* li R8, 0 */
		/* 820B4AACh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B4AACh case    0:*/		return 0x820B4AB0;
	}
	return 0x820B4AB0;
} // Block from 820B4AACh-820B4AB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B4AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4AB0);
		  /* 820B4AB0h */ case    0:  		/* addi R9, R9, 4 */
		/* 820B4AB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820B4AB0h case    0:*/		return 0x820B4AB4;
		  /* 820B4AB4h */ case    1:  		/* bc 16, CR0_LT, -164 */
		/* 820B4AB4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820B4A10;  }
		/* 820B4AB4h case    1:*/		return 0x820B4AB8;
	}
	return 0x820B4AB8;
} // Block from 820B4AB0h-820B4AB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B4AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4AB8);
		  /* 820B4AB8h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820B4AB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820B4AB8h case    0:*/		return 0x820B4ABC;
		  /* 820B4ABCh */ case    1:  		/* bc 12, CR6_EQ, 176 */
		/* 820B4ABCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820B4B6C;  }
		/* 820B4ABCh case    1:*/		return 0x820B4AC0;
		  /* 820B4AC0h */ case    2:  		/* cmpwi CR6, R8, 0 */
		/* 820B4AC0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820B4AC0h case    2:*/		return 0x820B4AC4;
		  /* 820B4AC4h */ case    3:  		/* bc 12, CR6_EQ, 168 */
		/* 820B4AC4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B4B6C;  }
		/* 820B4AC4h case    3:*/		return 0x820B4AC8;
		  /* 820B4AC8h */ case    4:  		/* li R29, 0 */
		/* 820B4AC8h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820B4AC8h case    4:*/		return 0x820B4ACC;
		  /* 820B4ACCh */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 820B4ACCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820B4ACCh case    5:*/		return 0x820B4AD0;
		  /* 820B4AD0h */ case    6:  		/* bc 12, CR6_EQ, 108 */
		/* 820B4AD0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820B4B3C;  }
		/* 820B4AD0h case    6:*/		return 0x820B4AD4;
		  /* 820B4AD4h */ case    7:  		/* mr R31, R26 */
		/* 820B4AD4h case    7:*/		regs.R31 = regs.R26;
		/* 820B4AD4h case    7:*/		return 0x820B4AD8;
		  /* 820B4AD8h */ case    8:  		/* lwz R3, <#[R28 + 8]> */
		/* 820B4AD8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000008) );
		/* 820B4AD8h case    8:*/		return 0x820B4ADC;
		  /* 820B4ADCh */ case    9:  		/* li R6, 0 */
		/* 820B4ADCh case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820B4ADCh case    9:*/		return 0x820B4AE0;
		  /* 820B4AE0h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 820B4AE0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B4AE0h case   10:*/		return 0x820B4AE4;
		  /* 820B4AE4h */ case   11:  		/* li R5, 0 */
		/* 820B4AE4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B4AE4h case   11:*/		return 0x820B4AE8;
		  /* 820B4AE8h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B4AE8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B4AE8h case   12:*/		return 0x820B4AEC;
		  /* 820B4AECh */ case   13:  		/* lwz R10, <#[R3 + 20]> */
		/* 820B4AECh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820B4AECh case   13:*/		return 0x820B4AF0;
		  /* 820B4AF0h */ case   14:  		/* lwz R4, <#[R3 + 120]> */
		/* 820B4AF0h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820B4AF0h case   14:*/		return 0x820B4AF4;
		  /* 820B4AF4h */ case   15:  		/* lwzx R30, <#[R11 + R10]> */
		/* 820B4AF4h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B4AF4h case   15:*/		return 0x820B4AF8;
		  /* 820B4AF8h */ case   16:  		/* lfd FR1, <#[R30 + 32]> */
		/* 820B4AF8h case   16:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R30 + 0x00000020) );
		/* 820B4AF8h case   16:*/		return 0x820B4AFC;
		  /* 820B4AFCh */ case   17:  		/* bl 296748 */
		/* 820B4AFCh case   17:*/		regs.LR = 0x820B4B00; return 0x820FD228;
		/* 820B4AFCh case   17:*/		return 0x820B4B00;
		  /* 820B4B00h */ case   18:  		/* stw R3, <#[R31]> */
		/* 820B4B00h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820B4B00h case   18:*/		return 0x820B4B04;
		  /* 820B4B04h */ case   19:  		/* cmpwi CR6, R3, -1 */
		/* 820B4B04h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820B4B04h case   19:*/		return 0x820B4B08;
		  /* 820B4B08h */ case   20:  		/* bc 12, CR6_EQ, 112 */
		/* 820B4B08h case   20:*/		if ( regs.CR[6].eq ) { return 0x820B4B78;  }
		/* 820B4B08h case   20:*/		return 0x820B4B0C;
		  /* 820B4B0Ch */ case   21:  		/* lwz R11, <#[R28 + 8]> */
		/* 820B4B0Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820B4B0Ch case   21:*/		return 0x820B4B10;
		  /* 820B4B10h */ case   22:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820B4B10h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820B4B10h case   22:*/		return 0x820B4B14;
		  /* 820B4B14h */ case   23:  		/* lwz R9, <#[R30 + 96]> */
		/* 820B4B14h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000060) );
		/* 820B4B14h case   23:*/		return 0x820B4B18;
		  /* 820B4B18h */ case   24:  		/* addi R29, R29, 1 */
		/* 820B4B18h case   24:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820B4B18h case   24:*/		return 0x820B4B1C;
		  /* 820B4B1Ch */ case   25:  		/* addi R31, R31, 4 */
		/* 820B4B1Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820B4B1Ch case   25:*/		return 0x820B4B20;
		  /* 820B4B20h */ case   26:  		/* cmplw CR6, R29, R27 */
		/* 820B4B20h case   26:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R27);
		/* 820B4B20h case   26:*/		return 0x820B4B24;
		  /* 820B4B24h */ case   27:  		/* lwz R11, <#[R11 + 20]> */
		/* 820B4B24h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820B4B24h case   27:*/		return 0x820B4B28;
		  /* 820B4B28h */ case   28:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820B4B28h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B4B28h case   28:*/		return 0x820B4B2C;
		  /* 820B4B2Ch */ case   29:  		/* stw R9, <#[R11 + 96]> */
		/* 820B4B2Ch case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000060) );
		/* 820B4B2Ch case   29:*/		return 0x820B4B30;
		  /* 820B4B30h */ case   30:  		/* lwz R10, <#[R30 + 100]> */
		/* 820B4B30h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000064) );
		/* 820B4B30h case   30:*/		return 0x820B4B34;
		  /* 820B4B34h */ case   31:  		/* stw R10, <#[R11 + 100]> */
		/* 820B4B34h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000064) );
		/* 820B4B34h case   31:*/		return 0x820B4B38;
		  /* 820B4B38h */ case   32:  		/* bc 12, CR6_LT, -96 */
		/* 820B4B38h case   32:*/		if ( regs.CR[6].lt ) { return 0x820B4AD8;  }
		/* 820B4B38h case   32:*/		return 0x820B4B3C;
	}
	return 0x820B4B3C;
} // Block from 820B4AB8h-820B4B3Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 820B4B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4B3C);
		  /* 820B4B3Ch */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820B4B3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820B4B3Ch case    0:*/		return 0x820B4B40;
		  /* 820B4B40h */ case    1:  		/* li R10, 0 */
		/* 820B4B40h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820B4B40h case    1:*/		return 0x820B4B44;
		  /* 820B4B44h */ case    2:  		/* li R9, 0 */
		/* 820B4B44h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B4B44h case    2:*/		return 0x820B4B48;
		  /* 820B4B48h */ case    3:  		/* li R8, 1 */
		/* 820B4B48h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820B4B48h case    3:*/		return 0x820B4B4C;
		  /* 820B4B4Ch */ case    4:  		/* li R7, 1 */
		/* 820B4B4Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820B4B4Ch case    4:*/		return 0x820B4B50;
		  /* 820B4B50h */ case    5:  		/* mr R5, R26 */
		/* 820B4B50h case    5:*/		regs.R5 = regs.R26;
		/* 820B4B50h case    5:*/		return 0x820B4B54;
		  /* 820B4B54h */ case    6:  		/* mr R4, R25 */
		/* 820B4B54h case    6:*/		regs.R4 = regs.R25;
		/* 820B4B54h case    6:*/		return 0x820B4B58;
		  /* 820B4B58h */ case    7:  		/* lwz R6, <#[R11 + 120]> */
		/* 820B4B58h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000078) );
		/* 820B4B58h case    7:*/		return 0x820B4B5C;
		  /* 820B4B5Ch */ case    8:  		/* mr R3, R28 */
		/* 820B4B5Ch case    8:*/		regs.R3 = regs.R28;
		/* 820B4B5Ch case    8:*/		return 0x820B4B60;
		  /* 820B4B60h */ case    9:  		/* bl -720 */
		/* 820B4B60h case    9:*/		regs.LR = 0x820B4B64; return 0x820B4890;
		/* 820B4B60h case    9:*/		return 0x820B4B64;
		  /* 820B4B64h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820B4B64h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4B64h case   10:*/		return 0x820B4B68;
		  /* 820B4B68h */ case   11:  		/* bc 12, CR0_LT, 8 */
		/* 820B4B68h case   11:*/		if ( regs.CR[0].lt ) { return 0x820B4B70;  }
		/* 820B4B68h case   11:*/		return 0x820B4B6C;
	}
	return 0x820B4B6C;
} // Block from 820B4B3Ch-820B4B6Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 820B4B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4B6C);
		  /* 820B4B6Ch */ case    0:  		/* li R3, 0 */
		/* 820B4B6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B4B6Ch case    0:*/		return 0x820B4B70;
	}
	return 0x820B4B70;
} // Block from 820B4B6Ch-820B4B70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B4B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4B70);
		  /* 820B4B70h */ case    0:  		/* addi R1, R1, 144 */
		/* 820B4B70h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820B4B70h case    0:*/		return 0x820B4B74;
		  /* 820B4B74h */ case    1:  		/* b -145624 */
		/* 820B4B74h case    1:*/		return 0x8209129C;
		/* 820B4B74h case    1:*/		return 0x820B4B78;
	}
	return 0x820B4B78;
} // Block from 820B4B70h-820B4B78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B4B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4B78);
		  /* 820B4B78h */ case    0:  		/* lis R3, -32761 */
		/* 820B4B78h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820B4B78h case    0:*/		return 0x820B4B7C;
		  /* 820B4B7Ch */ case    1:  		/* ori R3, R3, 14 */
		/* 820B4B7Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820B4B7Ch case    1:*/		return 0x820B4B80;
		  /* 820B4B80h */ case    2:  		/* b -16 */
		/* 820B4B80h case    2:*/		return 0x820B4B70;
		/* 820B4B80h case    2:*/		return 0x820B4B84;
		  /* 820B4B84h */ case    3:  		/* nop */
		/* 820B4B84h case    3:*/		cpu::op::nop();
		/* 820B4B84h case    3:*/		return 0x820B4B88;
	}
	return 0x820B4B88;
} // Block from 820B4B78h-820B4B88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4B88);
		  /* 820B4B88h */ case    0:  		/* mfspr R12, LR */
		/* 820B4B88h case    0:*/		regs.R12 = regs.LR;
		/* 820B4B88h case    0:*/		return 0x820B4B8C;
		  /* 820B4B8Ch */ case    1:  		/* bl -145740 */
		/* 820B4B8Ch case    1:*/		regs.LR = 0x820B4B90; return 0x82091240;
		/* 820B4B8Ch case    1:*/		return 0x820B4B90;
		  /* 820B4B90h */ case    2:  		/* stfd FR31, <#[R1 - 96]> */
		/* 820B4B90h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820B4B90h case    2:*/		return 0x820B4B94;
		  /* 820B4B94h */ case    3:  		/* stwu R1, <#[R1 - 208]> */
		/* 820B4B94h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820B4B94h case    3:*/		return 0x820B4B98;
		  /* 820B4B98h */ case    4:  		/* mr R29, R3 */
		/* 820B4B98h case    4:*/		regs.R29 = regs.R3;
		/* 820B4B98h case    4:*/		return 0x820B4B9C;
		  /* 820B4B9Ch */ case    5:  		/* mr R24, R5 */
		/* 820B4B9Ch case    5:*/		regs.R24 = regs.R5;
		/* 820B4B9Ch case    5:*/		return 0x820B4BA0;
		  /* 820B4BA0h */ case    6:  		/* mr R23, R6 */
		/* 820B4BA0h case    6:*/		regs.R23 = regs.R6;
		/* 820B4BA0h case    6:*/		return 0x820B4BA4;
		  /* 820B4BA4h */ case    7:  		/* mr R22, R7 */
		/* 820B4BA4h case    7:*/		regs.R22 = regs.R7;
		/* 820B4BA4h case    7:*/		return 0x820B4BA8;
		  /* 820B4BA8h */ case    8:  		/* cmpwi CR6, R4, -1 */
		/* 820B4BA8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 820B4BA8h case    8:*/		return 0x820B4BAC;
		  /* 820B4BACh */ case    9:  		/* bc 12, CR6_EQ, 196 */
		/* 820B4BACh case    9:*/		if ( regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4BACh case    9:*/		return 0x820B4BB0;
		  /* 820B4BB0h */ case   10:  		/* lis R11, -32256 */
		/* 820B4BB0h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820B4BB0h case   10:*/		return 0x820B4BB4;
		  /* 820B4BB4h */ case   11:  		/* lfd FR31, <#[R11 + 1848]> */
		/* 820B4BB4h case   11:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000738) );
		/* 820B4BB4h case   11:*/		return 0x820B4BB8;
		  /* 820B4BB8h */ case   12:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B4BB8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B4BB8h case   12:*/		return 0x820B4BBC;
		  /* 820B4BBCh */ case   13:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 820B4BBCh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 820B4BBCh case   13:*/		return 0x820B4BC0;
		  /* 820B4BC0h */ case   14:  		/* lwz R9, <#[R11 + 20]> */
		/* 820B4BC0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820B4BC0h case   14:*/		return 0x820B4BC4;
		  /* 820B4BC4h */ case   15:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820B4BC4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820B4BC4h case   15:*/		return 0x820B4BC8;
		  /* 820B4BC8h */ case   16:  		/* lwz R10, <#[R10 + 72]> */
		/* 820B4BC8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 820B4BC8h case   16:*/		return 0x820B4BCC;
		  /* 820B4BCCh */ case   17:  		/* cmpwi CR6, R10, -1 */
		/* 820B4BCCh case   17:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B4BCCh case   17:*/		return 0x820B4BD0;
		  /* 820B4BD0h */ case   18:  		/* bc 12, CR6_EQ, 160 */
		/* 820B4BD0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4BD0h case   18:*/		return 0x820B4BD4;
		  /* 820B4BD4h */ case   19:  		/* lwz R9, <#[R11 + 24]> */
		/* 820B4BD4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 820B4BD4h case   19:*/		return 0x820B4BD8;
		  /* 820B4BD8h */ case   20:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 820B4BD8h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 820B4BD8h case   20:*/		return 0x820B4BDC;
		  /* 820B4BDCh */ case   21:  		/* lis R10, 4096 */
		/* 820B4BDCh case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 820B4BDCh case   21:*/		return 0x820B4BE0;
		  /* 820B4BE0h */ case   22:  		/* ori R10, R10, 1 */
		/* 820B4BE0h case   22:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B4BE0h case   22:*/		return 0x820B4BE4;
		  /* 820B4BE4h */ case   23:  		/* lwzx R31, <#[R11 + R9]> */
		/* 820B4BE4h case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820B4BE4h case   23:*/		return 0x820B4BE8;
	}
	return 0x820B4BE8;
} // Block from 820B4B88h-820B4BE8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820B4BE8h
// Function '?EmitPositive@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAI11I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4BE8);
		  /* 820B4BE8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820B4BE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820B4BE8h case    0:*/		return 0x820B4BEC;
		  /* 820B4BECh */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820B4BECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B4BECh case    1:*/		return 0x820B4BF0;
		  /* 820B4BF0h */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 820B4BF0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B4C60;  }
		/* 820B4BF0h case    2:*/		return 0x820B4BF4;
		  /* 820B4BF4h */ case    3:  		/* lis R10, 8272 */
		/* 820B4BF4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 820B4BF4h case    3:*/		return 0x820B4BF8;
		  /* 820B4BF8h */ case    4:  		/* ori R10, R10, 1 */
		/* 820B4BF8h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B4BF8h case    4:*/		return 0x820B4BFC;
		  /* 820B4BFCh */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820B4BFCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B4BFCh case    5:*/		return 0x820B4C00;
		  /* 820B4C00h */ case    6:  		/* bc 4, CR6_EQ, 128 */
		/* 820B4C00h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820B4C80;  }
		/* 820B4C00h case    6:*/		return 0x820B4C04;
		  /* 820B4C04h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4C04h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4C04h case    7:*/		return 0x820B4C08;
		  /* 820B4C08h */ case    8:  		/* addi R5, R1, 80 */
		/* 820B4C08h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B4C08h case    8:*/		return 0x820B4C0C;
		  /* 820B4C0Ch */ case    9:  		/* mr R3, R29 */
		/* 820B4C0Ch case    9:*/		regs.R3 = regs.R29;
		/* 820B4C0Ch case    9:*/		return 0x820B4C10;
		  /* 820B4C10h */ case   10:  		/* lwz R4, <#[R11]> */
		/* 820B4C10h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4C10h case   10:*/		return 0x820B4C14;
		  /* 820B4C14h */ case   11:  		/* bl -17420 */
		/* 820B4C14h case   11:*/		regs.LR = 0x820B4C18; return 0x820B0808;
		/* 820B4C14h case   11:*/		return 0x820B4C18;
		  /* 820B4C18h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820B4C18h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4C18h case   12:*/		return 0x820B4C1C;
		  /* 820B4C1Ch */ case   13:  		/* bc 12, CR0_LT, 28 */
		/* 820B4C1Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820B4C38;  }
		/* 820B4C1Ch case   13:*/		return 0x820B4C20;
		  /* 820B4C20h */ case   14:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820B4C20h case   14:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4C20h case   14:*/		return 0x820B4C24;
		  /* 820B4C24h */ case   15:  		/* fcmpu CR6, FR0, FR31 */
		/* 820B4C24h case   15:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820B4C24h case   15:*/		return 0x820B4C28;
		  /* 820B4C28h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 820B4C28h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820B4C38;  }
		/* 820B4C28h case   16:*/		return 0x820B4C2C;
		  /* 820B4C2Ch */ case   17:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4C2Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4C2Ch case   17:*/		return 0x820B4C30;
		  /* 820B4C30h */ case   18:  		/* lwz R4, <#[R11 + 4]> */
		/* 820B4C30h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4C30h case   18:*/		return 0x820B4C34;
		  /* 820B4C34h */ case   19:  		/* b 52 */
		/* 820B4C34h case   19:*/		return 0x820B4C68;
		/* 820B4C34h case   19:*/		return 0x820B4C38;
	}
	return 0x820B4C38;
} // Block from 820B4BE8h-820B4C38h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820B4C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4C38);
		  /* 820B4C38h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4C38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4C38h case    0:*/		return 0x820B4C3C;
		  /* 820B4C3Ch */ case    1:  		/* addi R5, R1, 80 */
		/* 820B4C3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B4C3Ch case    1:*/		return 0x820B4C40;
		  /* 820B4C40h */ case    2:  		/* mr R3, R29 */
		/* 820B4C40h case    2:*/		regs.R3 = regs.R29;
		/* 820B4C40h case    2:*/		return 0x820B4C44;
		  /* 820B4C44h */ case    3:  		/* lwz R4, <#[R11 + 4]> */
		/* 820B4C44h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4C44h case    3:*/		return 0x820B4C48;
		  /* 820B4C48h */ case    4:  		/* bl -17472 */
		/* 820B4C48h case    4:*/		regs.LR = 0x820B4C4C; return 0x820B0808;
		/* 820B4C48h case    4:*/		return 0x820B4C4C;
		  /* 820B4C4Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820B4C4Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4C4Ch case    5:*/		return 0x820B4C50;
		  /* 820B4C50h */ case    6:  		/* bc 12, CR0_LT, 32 */
		/* 820B4C50h case    6:*/		if ( regs.CR[0].lt ) { return 0x820B4C70;  }
		/* 820B4C50h case    6:*/		return 0x820B4C54;
		  /* 820B4C54h */ case    7:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820B4C54h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4C54h case    7:*/		return 0x820B4C58;
		  /* 820B4C58h */ case    8:  		/* fcmpu CR6, FR0, FR31 */
		/* 820B4C58h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820B4C58h case    8:*/		return 0x820B4C5C;
		  /* 820B4C5Ch */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 820B4C5Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4C5Ch case    9:*/		return 0x820B4C60;
	}
	return 0x820B4C60;
} // Block from 820B4C38h-820B4C60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820B4C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4C60);
		  /* 820B4C60h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4C60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4C60h case    0:*/		return 0x820B4C64;
		  /* 820B4C64h */ case    1:  		/* lwz R4, <#[R11]> */
		/* 820B4C64h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4C64h case    1:*/		return 0x820B4C68;
	}
	return 0x820B4C68;
} // Block from 820B4C60h-820B4C68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B4C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4C68);
		  /* 820B4C68h */ case    0:  		/* cmpwi CR6, R4, -1 */
		/* 820B4C68h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 820B4C68h case    0:*/		return 0x820B4C6C;
		  /* 820B4C6Ch */ case    1:  		/* bc 4, CR6_EQ, -180 */
		/* 820B4C6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B4BB8;  }
		/* 820B4C6Ch case    1:*/		return 0x820B4C70;
	}
	return 0x820B4C70;
} // Block from 820B4C68h-820B4C70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B4C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4C70);
		  /* 820B4C70h */ case    0:  		/* li R3, 0 */
		/* 820B4C70h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820B4C70h case    0:*/		return 0x820B4C74;
		  /* 820B4C74h */ case    1:  		/* addi R1, R1, 208 */
		/* 820B4C74h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820B4C74h case    1:*/		return 0x820B4C78;
		  /* 820B4C78h */ case    2:  		/* lfd FR31, <#[R1 - 96]> */
		/* 820B4C78h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 820B4C78h case    2:*/		return 0x820B4C7C;
		  /* 820B4C7Ch */ case    3:  		/* b -145900 */
		/* 820B4C7Ch case    3:*/		return 0x82091290;
		/* 820B4C7Ch case    3:*/		return 0x820B4C80;
	}
	return 0x820B4C80;
} // Block from 820B4C70h-820B4C80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820B4C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4C80);
		  /* 820B4C80h */ case    0:  		/* lis R10, 8224 */
		/* 820B4C80h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x2020);
		/* 820B4C80h case    0:*/		return 0x820B4C84;
		  /* 820B4C84h */ case    1:  		/* ori R10, R10, 1 */
		/* 820B4C84h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B4C84h case    1:*/		return 0x820B4C88;
		  /* 820B4C88h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820B4C88h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B4C88h case    2:*/		return 0x820B4C8C;
		  /* 820B4C8Ch */ case    3:  		/* bc 4, CR6_EQ, 252 */
		/* 820B4C8Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B4D88;  }
		/* 820B4C8Ch case    3:*/		return 0x820B4C90;
		  /* 820B4C90h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4C90h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4C90h case    4:*/		return 0x820B4C94;
		  /* 820B4C94h */ case    5:  		/* addi R5, R1, 88 */
		/* 820B4C94h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820B4C94h case    5:*/		return 0x820B4C98;
		  /* 820B4C98h */ case    6:  		/* mr R3, R29 */
		/* 820B4C98h case    6:*/		regs.R3 = regs.R29;
		/* 820B4C98h case    6:*/		return 0x820B4C9C;
		  /* 820B4C9Ch */ case    7:  		/* lwz R4, <#[R11]> */
		/* 820B4C9Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4C9Ch case    7:*/		return 0x820B4CA0;
		  /* 820B4CA0h */ case    8:  		/* bl -17560 */
		/* 820B4CA0h case    8:*/		regs.LR = 0x820B4CA4; return 0x820B0808;
		/* 820B4CA0h case    8:*/		return 0x820B4CA4;
		  /* 820B4CA4h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820B4CA4h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4CA4h case    9:*/		return 0x820B4CA8;
		  /* 820B4CA8h */ case   10:  		/* bc 12, CR0_LT, -56 */
		/* 820B4CA8h case   10:*/		if ( regs.CR[0].lt ) { return 0x820B4C70;  }
		/* 820B4CA8h case   10:*/		return 0x820B4CAC;
		  /* 820B4CACh */ case   11:  		/* rldicl R11, R24, 0, 32 */
		/* 820B4CACh case   11:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R24);
		/* 820B4CACh case   11:*/		return 0x820B4CB0;
		  /* 820B4CB0h */ case   12:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820B4CB0h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820B4CB0h case   12:*/		return 0x820B4CB4;
		  /* 820B4CB4h */ case   13:  		/* std R11, <#[R1 + 88]> */
		/* 820B4CB4h case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820B4CB4h case   13:*/		return 0x820B4CB8;
		  /* 820B4CB8h */ case   14:  		/* lfd FR13, <#[R1 + 88]> */
		/* 820B4CB8h case   14:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 820B4CB8h case   14:*/		return 0x820B4CBC;
		  /* 820B4CBCh */ case   15:  		/* fcfid FR13, FR13 */
		/* 820B4CBCh case   15:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820B4CBCh case   15:*/		return 0x820B4CC0;
		  /* 820B4CC0h */ case   16:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B4CC0h case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B4CC0h case   16:*/		return 0x820B4CC4;
		  /* 820B4CC4h */ case   17:  		/* bc 4, CR6_EQ, -84 */
		/* 820B4CC4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4CC4h case   17:*/		return 0x820B4CC8;
		  /* 820B4CC8h */ case   18:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4CC8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4CC8h case   18:*/		return 0x820B4CCC;
		  /* 820B4CCCh */ case   19:  		/* li R6, 1 */
		/* 820B4CCCh case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820B4CCCh case   19:*/		return 0x820B4CD0;
		  /* 820B4CD0h */ case   20:  		/* addi R5, R1, 80 */
		/* 820B4CD0h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B4CD0h case   20:*/		return 0x820B4CD4;
		  /* 820B4CD4h */ case   21:  		/* li R4, 0 */
		/* 820B4CD4h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B4CD4h case   21:*/		return 0x820B4CD8;
		  /* 820B4CD8h */ case   22:  		/* mr R3, R29 */
		/* 820B4CD8h case   22:*/		regs.R3 = regs.R29;
		/* 820B4CD8h case   22:*/		return 0x820B4CDC;
		  /* 820B4CDCh */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 820B4CDCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4CDCh case   23:*/		return 0x820B4CE0;
		  /* 820B4CE0h */ case   24:  		/* stw R11, <#[R1 + 80]> */
		/* 820B4CE0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4CE0h case   24:*/		return 0x820B4CE4;
		  /* 820B4CE4h */ case   25:  		/* bl -772 */
		/* 820B4CE4h case   25:*/		regs.LR = 0x820B4CE8; return 0x820B49E0;
		/* 820B4CE4h case   25:*/		return 0x820B4CE8;
		  /* 820B4CE8h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 820B4CE8h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4CE8h case   26:*/		return 0x820B4CEC;
		  /* 820B4CECh */ case   27:  		/* bc 12, CR0_LT, -124 */
		/* 820B4CECh case   27:*/		if ( regs.CR[0].lt ) { return 0x820B4C70;  }
		/* 820B4CECh case   27:*/		return 0x820B4CF0;
		  /* 820B4CF0h */ case   28:  		/* lwz R11, <#[R22]> */
		/* 820B4CF0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 820B4CF0h case   28:*/		return 0x820B4CF4;
		  /* 820B4CF4h */ case   29:  		/* cmpwi CR6, R11, -1 */
		/* 820B4CF4h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B4CF4h case   29:*/		return 0x820B4CF8;
		  /* 820B4CF8h */ case   30:  		/* bc 12, CR6_EQ, 24 */
		/* 820B4CF8h case   30:*/		if ( regs.CR[6].eq ) { return 0x820B4D10;  }
		/* 820B4CF8h case   30:*/		return 0x820B4CFC;
		  /* 820B4CFCh */ case   31:  		/* lwz R10, <#[R1 + 80]> */
		/* 820B4CFCh case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4CFCh case   31:*/		return 0x820B4D00;
		  /* 820B4D00h */ case   32:  		/* subf R11, R10, R11 */
		/* 820B4D00h case   32:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820B4D00h case   32:*/		return 0x820B4D04;
		  /* 820B4D04h */ case   33:  		/* cntlzw R11, R11 */
		/* 820B4D04h case   33:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820B4D04h case   33:*/		return 0x820B4D08;
		  /* 820B4D08h */ case   34:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820B4D08h case   34:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820B4D08h case   34:*/		return 0x820B4D0C;
		  /* 820B4D0Ch */ case   35:  		/* b -152 */
		/* 820B4D0Ch case   35:*/		return 0x820B4C74;
		/* 820B4D0Ch case   35:*/		return 0x820B4D10;
	}
	return 0x820B4D10;
} // Block from 820B4C80h-820B4D10h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820B4D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4D10);
		  /* 820B4D10h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B4D10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B4D10h case    0:*/		return 0x820B4D14;
		  /* 820B4D14h */ case    1:  		/* lwz R8, <#[R1 + 80]> */
		/* 820B4D14h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4D14h case    1:*/		return 0x820B4D18;
		  /* 820B4D18h */ case    2:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 820B4D18h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 820B4D18h case    2:*/		return 0x820B4D1C;
		  /* 820B4D1Ch */ case    3:  		/* lwz R9, <#[R11 + 20]> */
		/* 820B4D1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820B4D1Ch case    3:*/		return 0x820B4D20;
		  /* 820B4D20h */ case    4:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820B4D20h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820B4D20h case    4:*/		return 0x820B4D24;
		  /* 820B4D24h */ case    5:  		/* lwz R7, <#[R10]> */
		/* 820B4D24h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820B4D24h case    5:*/		return 0x820B4D28;
		  /* 820B4D28h */ case    6:  		/* rlwinm. R7, R7, 0, 30, 30 */
		/* 820B4D28h case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R7);
		/* 820B4D28h case    6:*/		return 0x820B4D2C;
		  /* 820B4D2Ch */ case    7:  		/* bc 12, CR0_EQ, -188 */
		/* 820B4D2Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820B4C70;  }
		/* 820B4D2Ch case    7:*/		return 0x820B4D30;
		  /* 820B4D30h */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 820B4D30h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820B4D30h case    8:*/		return 0x820B4D34;
		  /* 820B4D34h */ case    9:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B4D34h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B4D34h case    9:*/		return 0x820B4D38;
		  /* 820B4D38h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B4D38h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B4D38h case   10:*/		return 0x820B4D3C;
		  /* 820B4D3Ch */ case   11:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820B4D3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B4D3Ch case   11:*/		return 0x820B4D40;
		  /* 820B4D40h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 820B4D40h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4D40h case   12:*/		return 0x820B4D44;
		  /* 820B4D44h */ case   13:  		/* rlwinm. R10, R11, 0, 23, 23 */
		/* 820B4D44h case   13:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R11);
		/* 820B4D44h case   13:*/		return 0x820B4D48;
		  /* 820B4D48h */ case   14:  		/* bc 4, CR0_EQ, -216 */
		/* 820B4D48h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820B4C70;  }
		/* 820B4D48h case   14:*/		return 0x820B4D4C;
		  /* 820B4D4Ch */ case   15:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820B4D4Ch case   15:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820B4D4Ch case   15:*/		return 0x820B4D50;
		  /* 820B4D50h */ case   16:  		/* bc 12, CR0_EQ, -224 */
		/* 820B4D50h case   16:*/		if ( regs.CR[0].eq ) { return 0x820B4C70;  }
		/* 820B4D50h case   16:*/		return 0x820B4D54;
		  /* 820B4D54h */ case   17:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820B4D54h case   17:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820B4D54h case   17:*/		return 0x820B4D58;
		  /* 820B4D58h */ case   18:  		/* bc 12, CR0_EQ, -232 */
		/* 820B4D58h case   18:*/		if ( regs.CR[0].eq ) { return 0x820B4C70;  }
		/* 820B4D58h case   18:*/		return 0x820B4D5C;
		  /* 820B4D5Ch */ case   19:  		/* cmplwi CR6, R23, 0 */
		/* 820B4D5Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820B4D5Ch case   19:*/		return 0x820B4D60;
		  /* 820B4D60h */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 820B4D60h case   20:*/		if ( regs.CR[6].eq ) { return 0x820B4D7C;  }
		/* 820B4D60h case   20:*/		return 0x820B4D64;
		  /* 820B4D64h */ case   21:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4D64h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4D64h case   21:*/		return 0x820B4D68;
		  /* 820B4D68h */ case   22:  		/* lwz R11, <#[R11]> */
		/* 820B4D68h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4D68h case   22:*/		return 0x820B4D6C;
		  /* 820B4D6Ch */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B4D6Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B4D6Ch case   23:*/		return 0x820B4D70;
		  /* 820B4D70h */ case   24:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820B4D70h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820B4D70h case   24:*/		return 0x820B4D74;
		  /* 820B4D74h */ case   25:  		/* lwz R11, <#[R11 + 48]> */
		/* 820B4D74h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 820B4D74h case   25:*/		return 0x820B4D78;
		  /* 820B4D78h */ case   26:  		/* stw R11, <#[R23]> */
		/* 820B4D78h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 820B4D78h case   26:*/		return 0x820B4D7C;
	}
	return 0x820B4D7C;
} // Block from 820B4D10h-820B4D7Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 820B4D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4D7C);
		  /* 820B4D7Ch */ case    0:  		/* stw R8, <#[R22]> */
		/* 820B4D7Ch case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R22 + 0x00000000) );
		/* 820B4D7Ch case    0:*/		return 0x820B4D80;
		  /* 820B4D80h */ case    1:  		/* li R3, 1 */
		/* 820B4D80h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820B4D80h case    1:*/		return 0x820B4D84;
		  /* 820B4D84h */ case    2:  		/* b -272 */
		/* 820B4D84h case    2:*/		return 0x820B4C74;
		/* 820B4D84h case    2:*/		return 0x820B4D88;
	}
	return 0x820B4D88;
} // Block from 820B4D7Ch-820B4D88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820B4D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4D88);
		  /* 820B4D88h */ case    0:  		/* lis R10, 12288 */
		/* 820B4D88h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x3000);
		/* 820B4D88h case    0:*/		return 0x820B4D8C;
		  /* 820B4D8Ch */ case    1:  		/* ori R10, R10, 1 */
		/* 820B4D8Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820B4D8Ch case    1:*/		return 0x820B4D90;
		  /* 820B4D90h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820B4D90h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B4D90h case    2:*/		return 0x820B4D94;
		  /* 820B4D94h */ case    3:  		/* bc 4, CR6_EQ, -292 */
		/* 820B4D94h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4D94h case    3:*/		return 0x820B4D98;
		  /* 820B4D98h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B4D98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B4D98h case    4:*/		return 0x820B4D9C;
		  /* 820B4D9Ch */ case    5:  		/* lwz R10, <#[R29 + 8]> */
		/* 820B4D9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 820B4D9Ch case    5:*/		return 0x820B4DA0;
		  /* 820B4DA0h */ case    6:  		/* lwz R8, <#[R11 + 4]> */
		/* 820B4DA0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4DA0h case    6:*/		return 0x820B4DA4;
		  /* 820B4DA4h */ case    7:  		/* lwz R7, <#[R10 + 20]> */
		/* 820B4DA4h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000014) );
		/* 820B4DA4h case    7:*/		return 0x820B4DA8;
		  /* 820B4DA8h */ case    8:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B4DA8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B4DA8h case    8:*/		return 0x820B4DAC;
		  /* 820B4DACh */ case    9:  		/* lwz R6, <#[R10 + 16]> */
		/* 820B4DACh case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 820B4DACh case    9:*/		return 0x820B4DB0;
		  /* 820B4DB0h */ case   10:  		/* lwzx R10, <#[R8 + R7]> */
		/* 820B4DB0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820B4DB0h case   10:*/		return 0x820B4DB4;
		  /* 820B4DB4h */ case   11:  		/* lwz R8, <#[R10 + 4]> */
		/* 820B4DB4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 820B4DB4h case   11:*/		return 0x820B4DB8;
		  /* 820B4DB8h */ case   12:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B4DB8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B4DB8h case   12:*/		return 0x820B4DBC;
		  /* 820B4DBCh */ case   13:  		/* lwzx R8, <#[R8 + R6]> */
		/* 820B4DBCh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 820B4DBCh case   13:*/		return 0x820B4DC0;
		  /* 820B4DC0h */ case   14:  		/* lwz R8, <#[R8 + 4]> */
		/* 820B4DC0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820B4DC0h case   14:*/		return 0x820B4DC4;
		  /* 820B4DC4h */ case   15:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 820B4DC4h case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 820B4DC4h case   15:*/		return 0x820B4DC8;
		  /* 820B4DC8h */ case   16:  		/* bc 12, CR0_EQ, -344 */
		/* 820B4DC8h case   16:*/		if ( regs.CR[0].eq ) { return 0x820B4C70;  }
		/* 820B4DC8h case   16:*/		return 0x820B4DCC;
		  /* 820B4DCCh */ case   17:  		/* lwz R8, <#[R10 + 8]> */
		/* 820B4DCCh case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820B4DCCh case   17:*/		return 0x820B4DD0;
		  /* 820B4DD0h */ case   18:  		/* cmpwi CR6, R8, -1 */
		/* 820B4DD0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820B4DD0h case   18:*/		return 0x820B4DD4;
		  /* 820B4DD4h */ case   19:  		/* bc 4, CR6_EQ, -356 */
		/* 820B4DD4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4DD4h case   19:*/		return 0x820B4DD8;
		  /* 820B4DD8h */ case   20:  		/* lis R8, -32256 */
		/* 820B4DD8h case   20:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 820B4DD8h case   20:*/		return 0x820B4DDC;
		  /* 820B4DDCh */ case   21:  		/* lfd FR13, <#[R10 + 32]> */
		/* 820B4DDCh case   21:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 820B4DDCh case   21:*/		return 0x820B4DE0;
		  /* 820B4DE0h */ case   22:  		/* lfd FR0, <#[R8 + 1808]> */
		/* 820B4DE0h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000710) );
		/* 820B4DE0h case   22:*/		return 0x820B4DE4;
		  /* 820B4DE4h */ case   23:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B4DE4h case   23:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B4DE4h case   23:*/		return 0x820B4DE8;
		  /* 820B4DE8h */ case   24:  		/* bc 4, CR6_EQ, -376 */
		/* 820B4DE8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4DE8h case   24:*/		return 0x820B4DEC;
		  /* 820B4DECh */ case   25:  		/* lwz R10, <#[R29 + 8]> */
		/* 820B4DECh case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 820B4DECh case   25:*/		return 0x820B4DF0;
		  /* 820B4DF0h */ case   26:  		/* lwz R8, <#[R11 + 8]> */
		/* 820B4DF0h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 820B4DF0h case   26:*/		return 0x820B4DF4;
		  /* 820B4DF4h */ case   27:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B4DF4h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B4DF4h case   27:*/		return 0x820B4DF8;
		  /* 820B4DF8h */ case   28:  		/* lwz R7, <#[R10 + 20]> */
		/* 820B4DF8h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000014) );
		/* 820B4DF8h case   28:*/		return 0x820B4DFC;
		  /* 820B4DFCh */ case   29:  		/* lwz R6, <#[R10 + 16]> */
		/* 820B4DFCh case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 820B4DFCh case   29:*/		return 0x820B4E00;
		  /* 820B4E00h */ case   30:  		/* lwzx R10, <#[R8 + R7]> */
		/* 820B4E00h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820B4E00h case   30:*/		return 0x820B4E04;
		  /* 820B4E04h */ case   31:  		/* lwz R8, <#[R10 + 4]> */
		/* 820B4E04h case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 820B4E04h case   31:*/		return 0x820B4E08;
		  /* 820B4E08h */ case   32:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B4E08h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B4E08h case   32:*/		return 0x820B4E0C;
		  /* 820B4E0Ch */ case   33:  		/* lwzx R8, <#[R8 + R6]> */
		/* 820B4E0Ch case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 820B4E0Ch case   33:*/		return 0x820B4E10;
		  /* 820B4E10h */ case   34:  		/* lwz R8, <#[R8 + 4]> */
		/* 820B4E10h case   34:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 820B4E10h case   34:*/		return 0x820B4E14;
		  /* 820B4E14h */ case   35:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 820B4E14h case   35:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 820B4E14h case   35:*/		return 0x820B4E18;
		  /* 820B4E18h */ case   36:  		/* bc 12, CR0_EQ, -424 */
		/* 820B4E18h case   36:*/		if ( regs.CR[0].eq ) { return 0x820B4C70;  }
		/* 820B4E18h case   36:*/		return 0x820B4E1C;
		  /* 820B4E1Ch */ case   37:  		/* lwz R8, <#[R10 + 8]> */
		/* 820B4E1Ch case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 820B4E1Ch case   37:*/		return 0x820B4E20;
		  /* 820B4E20h */ case   38:  		/* cmpwi CR6, R8, -1 */
		/* 820B4E20h case   38:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820B4E20h case   38:*/		return 0x820B4E24;
		  /* 820B4E24h */ case   39:  		/* bc 4, CR6_EQ, -436 */
		/* 820B4E24h case   39:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4E24h case   39:*/		return 0x820B4E28;
		  /* 820B4E28h */ case   40:  		/* lfd FR0, <#[R10 + 32]> */
		/* 820B4E28h case   40:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820B4E28h case   40:*/		return 0x820B4E2C;
		  /* 820B4E2Ch */ case   41:  		/* fcmpu CR6, FR0, FR31 */
		/* 820B4E2Ch case   41:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820B4E2Ch case   41:*/		return 0x820B4E30;
		  /* 820B4E30h */ case   42:  		/* bc 4, CR6_EQ, -448 */
		/* 820B4E30h case   42:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4E30h case   42:*/		return 0x820B4E34;
		  /* 820B4E34h */ case   43:  		/* lwz R10, <#[R29 + 8]> */
		/* 820B4E34h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 820B4E34h case   43:*/		return 0x820B4E38;
		  /* 820B4E38h */ case   44:  		/* lwz R8, <#[R11]> */
		/* 820B4E38h case   44:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820B4E38h case   44:*/		return 0x820B4E3C;
		  /* 820B4E3Ch */ case   45:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 820B4E3Ch case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 820B4E3Ch case   45:*/		return 0x820B4E40;
		  /* 820B4E40h */ case   46:  		/* lwz R7, <#[R10 + 20]> */
		/* 820B4E40h case   46:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000014) );
		/* 820B4E40h case   46:*/		return 0x820B4E44;
		  /* 820B4E44h */ case   47:  		/* lwz R10, <#[R10 + 16]> */
		/* 820B4E44h case   47:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820B4E44h case   47:*/		return 0x820B4E48;
		  /* 820B4E48h */ case   48:  		/* lwzx R11, <#[R7 + R11]> */
		/* 820B4E48h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820B4E48h case   48:*/		return 0x820B4E4C;
		  /* 820B4E4Ch */ case   49:  		/* lwz R7, <#[R11 + 4]> */
		/* 820B4E4Ch case   49:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4E4Ch case   49:*/		return 0x820B4E50;
		  /* 820B4E50h */ case   50:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820B4E50h case   50:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820B4E50h case   50:*/		return 0x820B4E54;
		  /* 820B4E54h */ case   51:  		/* lwzx R10, <#[R7 + R10]> */
		/* 820B4E54h case   51:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820B4E54h case   51:*/		return 0x820B4E58;
		  /* 820B4E58h */ case   52:  		/* lwz R10, <#[R10 + 4]> */
		/* 820B4E58h case   52:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820B4E58h case   52:*/		return 0x820B4E5C;
		  /* 820B4E5Ch */ case   53:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820B4E5Ch case   53:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820B4E5Ch case   53:*/		return 0x820B4E60;
		  /* 820B4E60h */ case   54:  		/* bc 12, CR0_EQ, -496 */
		/* 820B4E60h case   54:*/		if ( regs.CR[0].eq ) { return 0x820B4C70;  }
		/* 820B4E60h case   54:*/		return 0x820B4E64;
		  /* 820B4E64h */ case   55:  		/* lwz R10, <#[R11 + 8]> */
		/* 820B4E64h case   55:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B4E64h case   55:*/		return 0x820B4E68;
		  /* 820B4E68h */ case   56:  		/* cmpwi CR6, R10, -1 */
		/* 820B4E68h case   56:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B4E68h case   56:*/		return 0x820B4E6C;
		  /* 820B4E6Ch */ case   57:  		/* bc 4, CR6_EQ, -508 */
		/* 820B4E6Ch case   57:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4E6Ch case   57:*/		return 0x820B4E70;
		  /* 820B4E70h */ case   58:  		/* lwz R11, <#[R11 + 72]> */
		/* 820B4E70h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820B4E70h case   58:*/		return 0x820B4E74;
		  /* 820B4E74h */ case   59:  		/* lis R10, 8256 */
		/* 820B4E74h case   59:*/		cpu::op::lis<0>(regs,&regs.R10,0x2040);
		/* 820B4E74h case   59:*/		return 0x820B4E78;
		  /* 820B4E78h */ case   60:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B4E78h case   60:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B4E78h case   60:*/		return 0x820B4E7C;
		  /* 820B4E7Ch */ case   61:  		/* lwzx R27, <#[R11 + R9]> */
		/* 820B4E7Ch case   61:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820B4E7Ch case   61:*/		return 0x820B4E80;
		  /* 820B4E80h */ case   62:  		/* lwz R11, <#[R27]> */
		/* 820B4E80h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820B4E80h case   62:*/		return 0x820B4E84;
		  /* 820B4E84h */ case   63:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820B4E84h case   63:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820B4E84h case   63:*/		return 0x820B4E88;
		  /* 820B4E88h */ case   64:  		/* cmplw CR6, R11, R10 */
		/* 820B4E88h case   64:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820B4E88h case   64:*/		return 0x820B4E8C;
		  /* 820B4E8Ch */ case   65:  		/* bc 4, CR6_EQ, -540 */
		/* 820B4E8Ch case   65:*/		if ( !regs.CR[6].eq ) { return 0x820B4C70;  }
		/* 820B4E8Ch case   65:*/		return 0x820B4E90;
		  /* 820B4E90h */ case   66:  		/* lwz R9, <#[R27 + 12]> */
		/* 820B4E90h case   66:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x0000000C) );
		/* 820B4E90h case   66:*/		return 0x820B4E94;
		  /* 820B4E94h */ case   67:  		/* li R28, 0 */
		/* 820B4E94h case   67:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820B4E94h case   67:*/		return 0x820B4E98;
		  /* 820B4E98h */ case   68:  		/* cmplwi CR6, R9, 0 */
		/* 820B4E98h case   68:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820B4E98h case   68:*/		return 0x820B4E9C;
		  /* 820B4E9Ch */ case   69:  		/* bc 12, CR6_EQ, 40 */
		/* 820B4E9Ch case   69:*/		if ( regs.CR[6].eq ) { return 0x820B4EC4;  }
		/* 820B4E9Ch case   69:*/		return 0x820B4EA0;
		  /* 820B4EA0h */ case   70:  		/* lwz R10, <#[R27 + 16]> */
		/* 820B4EA0h case   70:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 820B4EA0h case   70:*/		return 0x820B4EA4;
		  /* 820B4EA4h */ case   71:  		/* li R11, 0 */
		/* 820B4EA4h case   71:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B4EA4h case   71:*/		return 0x820B4EA8;
		  /* 820B4EA8h */ case   72:  		/* lwzx R7, <#[R11 + R10]> */
		/* 820B4EA8h case   72:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B4EA8h case   72:*/		return 0x820B4EAC;
		  /* 820B4EACh */ case   73:  		/* cmplw CR6, R7, R8 */
		/* 820B4EACh case   73:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 820B4EACh case   73:*/		return 0x820B4EB0;
		  /* 820B4EB0h */ case   74:  		/* bc 12, CR6_EQ, 20 */
		/* 820B4EB0h case   74:*/		if ( regs.CR[6].eq ) { return 0x820B4EC4;  }
		/* 820B4EB0h case   74:*/		return 0x820B4EB4;
		  /* 820B4EB4h */ case   75:  		/* addi R28, R28, 1 */
		/* 820B4EB4h case   75:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820B4EB4h case   75:*/		return 0x820B4EB8;
		  /* 820B4EB8h */ case   76:  		/* addi R11, R11, 4 */
		/* 820B4EB8h case   76:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B4EB8h case   76:*/		return 0x820B4EBC;
		  /* 820B4EBCh */ case   77:  		/* cmplw CR6, R28, R9 */
		/* 820B4EBCh case   77:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R9);
		/* 820B4EBCh case   77:*/		return 0x820B4EC0;
		  /* 820B4EC0h */ case   78:  		/* bc 12, CR6_LT, -24 */
		/* 820B4EC0h case   78:*/		if ( regs.CR[6].lt ) { return 0x820B4EA8;  }
		/* 820B4EC0h case   78:*/		return 0x820B4EC4;
	}
	return 0x820B4EC4;
} // Block from 820B4D88h-820B4EC4h (79 instructions)

//////////////////////////////////////////////////////
// Block at 820B4EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4EC4);
		  /* 820B4EC4h */ case    0:  		/* li R26, 0 */
		/* 820B4EC4h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820B4EC4h case    0:*/		return 0x820B4EC8;
		  /* 820B4EC8h */ case    1:  		/* li R25, 1 */
		/* 820B4EC8h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820B4EC8h case    1:*/		return 0x820B4ECC;
		  /* 820B4ECCh */ case    2:  		/* lwz R8, <#[R27 + 12]> */
		/* 820B4ECCh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x0000000C) );
		/* 820B4ECCh case    2:*/		return 0x820B4ED0;
		  /* 820B4ED0h */ case    3:  		/* lwz R7, <#[R27 + 8]> */
		/* 820B4ED0h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000008) );
		/* 820B4ED0h case    3:*/		return 0x820B4ED4;
		  /* 820B4ED4h */ case    4:  		/* mullw R11, R8, R26 */
		/* 820B4ED4h case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R8,regs.R26);
		/* 820B4ED4h case    4:*/		return 0x820B4ED8;
		  /* 820B4ED8h */ case    5:  		/* lwz R10, <#[R29 + 8]> */
		/* 820B4ED8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 820B4ED8h case    5:*/		return 0x820B4EDC;
		  /* 820B4EDCh */ case    6:  		/* lwz R9, <#[R10 + 20]> */
		/* 820B4EDCh case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 820B4EDCh case    6:*/		return 0x820B4EE0;
		  /* 820B4EE0h */ case    7:  		/* lwz R10, <#[R10 + 16]> */
		/* 820B4EE0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820B4EE0h case    7:*/		return 0x820B4EE4;
		  /* 820B4EE4h */ case    8:  		/* add R11, R11, R28 */
		/* 820B4EE4h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 820B4EE4h case    8:*/		return 0x820B4EE8;
		  /* 820B4EE8h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B4EE8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B4EE8h case    9:*/		return 0x820B4EEC;
		  /* 820B4EECh */ case   10:  		/* lwzx R6, <#[R11 + R7]> */
		/* 820B4EECh case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820B4EECh case   10:*/		return 0x820B4EF0;
		  /* 820B4EF0h */ case   11:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 820B4EF0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 820B4EF0h case   11:*/		return 0x820B4EF4;
		  /* 820B4EF4h */ case   12:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820B4EF4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B4EF4h case   12:*/		return 0x820B4EF8;
		  /* 820B4EF8h */ case   13:  		/* lwz R9, <#[R11 + 4]> */
		/* 820B4EF8h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820B4EF8h case   13:*/		return 0x820B4EFC;
		  /* 820B4EFCh */ case   14:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B4EFCh case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B4EFCh case   14:*/		return 0x820B4F00;
		  /* 820B4F00h */ case   15:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820B4F00h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820B4F00h case   15:*/		return 0x820B4F04;
		  /* 820B4F04h */ case   16:  		/* lwz R10, <#[R10 + 4]> */
		/* 820B4F04h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820B4F04h case   16:*/		return 0x820B4F08;
		  /* 820B4F08h */ case   17:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820B4F08h case   17:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820B4F08h case   17:*/		return 0x820B4F0C;
		  /* 820B4F0Ch */ case   18:  		/* bc 12, CR0_EQ, 324 */
		/* 820B4F0Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x820B5050;  }
		/* 820B4F0Ch case   18:*/		return 0x820B4F10;
	}
	return 0x820B4F10;
} // Block from 820B4EC4h-820B4F10h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820B4F10h
// Function '?ApplyType@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4F10);
		  /* 820B4F10h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 820B4F10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820B4F10h case    0:*/		return 0x820B4F14;
		  /* 820B4F14h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 820B4F14h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B4F14h case    1:*/		return 0x820B4F18;
		  /* 820B4F18h */ case    2:  		/* bc 4, CR6_EQ, 312 */
		/* 820B4F18h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B5050;  }
		/* 820B4F18h case    2:*/		return 0x820B4F1C;
		  /* 820B4F1Ch */ case    3:  		/* lwz R10, <#[R29 + 8]> */
		/* 820B4F1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 820B4F1Ch case    3:*/		return 0x820B4F20;
		  /* 820B4F20h */ case    4:  		/* lis R9, 4112 */
		/* 820B4F20h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x1010);
		/* 820B4F20h case    4:*/		return 0x820B4F24;
		  /* 820B4F24h */ case    5:  		/* lwz R11, <#[R11 + 72]> */
		/* 820B4F24h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 820B4F24h case    5:*/		return 0x820B4F28;
		  /* 820B4F28h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B4F28h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B4F28h case    6:*/		return 0x820B4F2C;
		  /* 820B4F2Ch */ case    7:  		/* lwz R10, <#[R10 + 24]> */
		/* 820B4F2Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 820B4F2Ch case    7:*/		return 0x820B4F30;
		  /* 820B4F30h */ case    8:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820B4F30h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B4F30h case    8:*/		return 0x820B4F34;
		  /* 820B4F34h */ case    9:  		/* lwz R11, <#[R10]> */
		/* 820B4F34h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820B4F34h case    9:*/		return 0x820B4F38;
		  /* 820B4F38h */ case   10:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820B4F38h case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820B4F38h case   10:*/		return 0x820B4F3C;
		  /* 820B4F3Ch */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 820B4F3Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B4F3Ch case   11:*/		return 0x820B4F40;
		  /* 820B4F40h */ case   12:  		/* bc 4, CR6_EQ, 272 */
		/* 820B4F40h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820B5050;  }
		/* 820B4F40h case   12:*/		return 0x820B4F44;
		  /* 820B4F44h */ case   13:  		/* lwz R4, <#[R10 + 12]> */
		/* 820B4F44h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 820B4F44h case   13:*/		return 0x820B4F48;
		  /* 820B4F48h */ case   14:  		/* li R9, 0 */
		/* 820B4F48h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820B4F48h case   14:*/		return 0x820B4F4C;
		  /* 820B4F4Ch */ case   15:  		/* cmplwi CR6, R4, 0 */
		/* 820B4F4Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820B4F4Ch case   15:*/		return 0x820B4F50;
		  /* 820B4F50h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 820B4F50h case   16:*/		if ( regs.CR[6].eq ) { return 0x820B4F78;  }
		/* 820B4F50h case   16:*/		return 0x820B4F54;
		  /* 820B4F54h */ case   17:  		/* lwz R5, <#[R10 + 16]> */
		/* 820B4F54h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000010) );
		/* 820B4F54h case   17:*/		return 0x820B4F58;
		  /* 820B4F58h */ case   18:  		/* li R11, 0 */
		/* 820B4F58h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820B4F58h case   18:*/		return 0x820B4F5C;
		  /* 820B4F5Ch */ case   19:  		/* lwzx R3, <#[R11 + R5]> */
		/* 820B4F5Ch case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 820B4F5Ch case   19:*/		return 0x820B4F60;
		  /* 820B4F60h */ case   20:  		/* cmplw CR6, R3, R6 */
		/* 820B4F60h case   20:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R6);
		/* 820B4F60h case   20:*/		return 0x820B4F64;
		  /* 820B4F64h */ case   21:  		/* bc 12, CR6_EQ, 20 */
		/* 820B4F64h case   21:*/		if ( regs.CR[6].eq ) { return 0x820B4F78;  }
		/* 820B4F64h case   21:*/		return 0x820B4F68;
		  /* 820B4F68h */ case   22:  		/* addi R9, R9, 1 */
		/* 820B4F68h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820B4F68h case   22:*/		return 0x820B4F6C;
		  /* 820B4F6Ch */ case   23:  		/* addi R11, R11, 4 */
		/* 820B4F6Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B4F6Ch case   23:*/		return 0x820B4F70;
		  /* 820B4F70h */ case   24:  		/* cmplw CR6, R9, R4 */
		/* 820B4F70h case   24:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 820B4F70h case   24:*/		return 0x820B4F74;
		  /* 820B4F74h */ case   25:  		/* bc 12, CR6_LT, -24 */
		/* 820B4F74h case   25:*/		if ( regs.CR[6].lt ) { return 0x820B4F5C;  }
		/* 820B4F74h case   25:*/		return 0x820B4F78;
	}
	return 0x820B4F78;
} // Block from 820B4F10h-820B4F78h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820B4F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4F78);
		  /* 820B4F78h */ case    0:  		/* mullw R11, R8, R25 */
		/* 820B4F78h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R8,regs.R25);
		/* 820B4F78h case    0:*/		return 0x820B4F7C;
		  /* 820B4F7Ch */ case    1:  		/* lwz R10, <#[R10 + 8]> */
		/* 820B4F7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820B4F7Ch case    1:*/		return 0x820B4F80;
		  /* 820B4F80h */ case    2:  		/* add R11, R11, R28 */
		/* 820B4F80h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 820B4F80h case    2:*/		return 0x820B4F84;
		  /* 820B4F84h */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B4F84h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B4F84h case    3:*/		return 0x820B4F88;
		  /* 820B4F88h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B4F88h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B4F88h case    4:*/		return 0x820B4F8C;
		  /* 820B4F8Ch */ case    5:  		/* addi R5, R1, 88 */
		/* 820B4F8Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 820B4F8Ch case    5:*/		return 0x820B4F90;
		  /* 820B4F90h */ case    6:  		/* mr R3, R29 */
		/* 820B4F90h case    6:*/		regs.R3 = regs.R29;
		/* 820B4F90h case    6:*/		return 0x820B4F94;
		  /* 820B4F94h */ case    7:  		/* lwzx R31, <#[R9 + R10]> */
		/* 820B4F94h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820B4F94h case    7:*/		return 0x820B4F98;
		  /* 820B4F98h */ case    8:  		/* lwzx R30, <#[R11 + R7]> */
		/* 820B4F98h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820B4F98h case    8:*/		return 0x820B4F9C;
		  /* 820B4F9Ch */ case    9:  		/* mr R4, R30 */
		/* 820B4F9Ch case    9:*/		regs.R4 = regs.R30;
		/* 820B4F9Ch case    9:*/		return 0x820B4FA0;
		  /* 820B4FA0h */ case   10:  		/* bl -18328 */
		/* 820B4FA0h case   10:*/		regs.LR = 0x820B4FA4; return 0x820B0808;
		/* 820B4FA0h case   10:*/		return 0x820B4FA4;
		  /* 820B4FA4h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820B4FA4h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4FA4h case   11:*/		return 0x820B4FA8;
		  /* 820B4FA8h */ case   12:  		/* bc 12, CR0_LT, 168 */
		/* 820B4FA8h case   12:*/		if ( regs.CR[0].lt ) { return 0x820B5050;  }
		/* 820B4FA8h case   12:*/		return 0x820B4FAC;
		  /* 820B4FACh */ case   13:  		/* rldicl R11, R24, 0, 32 */
		/* 820B4FACh case   13:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R24);
		/* 820B4FACh case   13:*/		return 0x820B4FB0;
		  /* 820B4FB0h */ case   14:  		/* lfd FR0, <#[R1 + 88]> */
		/* 820B4FB0h case   14:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820B4FB0h case   14:*/		return 0x820B4FB4;
		  /* 820B4FB4h */ case   15:  		/* std R11, <#[R1 + 96]> */
		/* 820B4FB4h case   15:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820B4FB4h case   15:*/		return 0x820B4FB8;
	}
	return 0x820B4FB8;
} // Block from 820B4F78h-820B4FB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B4FB8h
// Function '?VectorizeVar@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAIIHH01001@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B4FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B4FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B4FB8);
		  /* 820B4FB8h */ case    0:  		/* lfd FR13, <#[R1 + 96]> */
		/* 820B4FB8h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000060) );
		/* 820B4FB8h case    0:*/		return 0x820B4FBC;
		  /* 820B4FBCh */ case    1:  		/* fcfid FR13, FR13 */
		/* 820B4FBCh case    1:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820B4FBCh case    1:*/		return 0x820B4FC0;
		  /* 820B4FC0h */ case    2:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B4FC0h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B4FC0h case    2:*/		return 0x820B4FC4;
		  /* 820B4FC4h */ case    3:  		/* bc 4, CR6_EQ, 140 */
		/* 820B4FC4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B5050;  }
		/* 820B4FC4h case    3:*/		return 0x820B4FC8;
		  /* 820B4FC8h */ case    4:  		/* stw R31, <#[R1 + 80]> */
		/* 820B4FC8h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4FC8h case    4:*/		return 0x820B4FCC;
		  /* 820B4FCCh */ case    5:  		/* li R6, 1 */
		/* 820B4FCCh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820B4FCCh case    5:*/		return 0x820B4FD0;
		  /* 820B4FD0h */ case    6:  		/* addi R5, R1, 80 */
		/* 820B4FD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820B4FD0h case    6:*/		return 0x820B4FD4;
		  /* 820B4FD4h */ case    7:  		/* li R4, 0 */
		/* 820B4FD4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B4FD4h case    7:*/		return 0x820B4FD8;
		  /* 820B4FD8h */ case    8:  		/* mr R3, R29 */
		/* 820B4FD8h case    8:*/		regs.R3 = regs.R29;
		/* 820B4FD8h case    8:*/		return 0x820B4FDC;
		  /* 820B4FDCh */ case    9:  		/* bl -1532 */
		/* 820B4FDCh case    9:*/		regs.LR = 0x820B4FE0; return 0x820B49E0;
		/* 820B4FDCh case    9:*/		return 0x820B4FE0;
		  /* 820B4FE0h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 820B4FE0h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B4FE0h case   10:*/		return 0x820B4FE4;
		  /* 820B4FE4h */ case   11:  		/* bc 12, CR0_LT, 108 */
		/* 820B4FE4h case   11:*/		if ( regs.CR[0].lt ) { return 0x820B5050;  }
		/* 820B4FE4h case   11:*/		return 0x820B4FE8;
		  /* 820B4FE8h */ case   12:  		/* lwz R11, <#[R22]> */
		/* 820B4FE8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 820B4FE8h case   12:*/		return 0x820B4FEC;
		  /* 820B4FECh */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 820B4FECh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B4FECh case   13:*/		return 0x820B4FF0;
		  /* 820B4FF0h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820B4FF0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820B5004;  }
		/* 820B4FF0h case   14:*/		return 0x820B4FF4;
		  /* 820B4FF4h */ case   15:  		/* lwz R10, <#[R1 + 80]> */
		/* 820B4FF4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820B4FF4h case   15:*/		return 0x820B4FF8;
		  /* 820B4FF8h */ case   16:  		/* cmplw CR6, R10, R11 */
		/* 820B4FF8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820B4FF8h case   16:*/		return 0x820B4FFC;
		  /* 820B4FFCh */ case   17:  		/* bc 12, CR6_EQ, -636 */
		/* 820B4FFCh case   17:*/		if ( regs.CR[6].eq ) { return 0x820B4D80;  }
		/* 820B4FFCh case   17:*/		return 0x820B5000;
		  /* 820B5000h */ case   18:  		/* b 80 */
		/* 820B5000h case   18:*/		return 0x820B5050;
		/* 820B5000h case   18:*/		return 0x820B5004;
	}
	return 0x820B5004;
} // Block from 820B4FB8h-820B5004h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820B5004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5004);
		  /* 820B5004h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B5004h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B5004h case    0:*/		return 0x820B5008;
		  /* 820B5008h */ case    1:  		/* lwz R8, <#[R1 + 80]> */
		/* 820B5008h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820B5008h case    1:*/		return 0x820B500C;
		  /* 820B500Ch */ case    2:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 820B500Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 820B500Ch case    2:*/		return 0x820B5010;
		  /* 820B5010h */ case    3:  		/* lwz R9, <#[R11 + 20]> */
		/* 820B5010h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820B5010h case    3:*/		return 0x820B5014;
		  /* 820B5014h */ case    4:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820B5014h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820B5014h case    4:*/		return 0x820B5018;
		  /* 820B5018h */ case    5:  		/* lwz R7, <#[R10]> */
		/* 820B5018h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820B5018h case    5:*/		return 0x820B501C;
		  /* 820B501Ch */ case    6:  		/* rlwinm. R7, R7, 0, 30, 30 */
		/* 820B501Ch case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R7);
		/* 820B501Ch case    6:*/		return 0x820B5020;
		  /* 820B5020h */ case    7:  		/* bc 12, CR0_EQ, 48 */
		/* 820B5020h case    7:*/		if ( regs.CR[0].eq ) { return 0x820B5050;  }
		/* 820B5020h case    7:*/		return 0x820B5024;
		  /* 820B5024h */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 820B5024h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820B5024h case    8:*/		return 0x820B5028;
		  /* 820B5028h */ case    9:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B5028h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B5028h case    9:*/		return 0x820B502C;
		  /* 820B502Ch */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B502Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B502Ch case   10:*/		return 0x820B5030;
		  /* 820B5030h */ case   11:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820B5030h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B5030h case   11:*/		return 0x820B5034;
		  /* 820B5034h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 820B5034h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820B5034h case   12:*/		return 0x820B5038;
		  /* 820B5038h */ case   13:  		/* rlwinm. R10, R11, 0, 23, 23 */
		/* 820B5038h case   13:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R11);
		/* 820B5038h case   13:*/		return 0x820B503C;
		  /* 820B503Ch */ case   14:  		/* bc 4, CR0_EQ, 20 */
		/* 820B503Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x820B5050;  }
		/* 820B503Ch case   14:*/		return 0x820B5040;
		  /* 820B5040h */ case   15:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820B5040h case   15:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820B5040h case   15:*/		return 0x820B5044;
		  /* 820B5044h */ case   16:  		/* bc 12, CR0_EQ, 12 */
		/* 820B5044h case   16:*/		if ( regs.CR[0].eq ) { return 0x820B5050;  }
		/* 820B5044h case   16:*/		return 0x820B5048;
		  /* 820B5048h */ case   17:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820B5048h case   17:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820B5048h case   17:*/		return 0x820B504C;
		  /* 820B504Ch */ case   18:  		/* bc 4, CR0_EQ, 24 */
		/* 820B504Ch case   18:*/		if ( !regs.CR[0].eq ) { return 0x820B5064;  }
		/* 820B504Ch case   18:*/		return 0x820B5050;
	}
	return 0x820B5050;
} // Block from 820B5004h-820B5050h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820B5050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5050);
		  /* 820B5050h */ case    0:  		/* addi R26, R26, 1 */
		/* 820B5050h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820B5050h case    0:*/		return 0x820B5054;
		  /* 820B5054h */ case    1:  		/* addi R25, R25, -1 */
		/* 820B5054h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFF);
		/* 820B5054h case    1:*/		return 0x820B5058;
		  /* 820B5058h */ case    2:  		/* cmplwi CR6, R26, 2 */
		/* 820B5058h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000002);
		/* 820B5058h case    2:*/		return 0x820B505C;
		  /* 820B505Ch */ case    3:  		/* bc 12, CR6_LT, -400 */
		/* 820B505Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820B4ECC;  }
		/* 820B505Ch case    3:*/		return 0x820B5060;
		  /* 820B5060h */ case    4:  		/* b -1008 */
		/* 820B5060h case    4:*/		return 0x820B4C70;
		/* 820B5060h case    4:*/		return 0x820B5064;
	}
	return 0x820B5064;
} // Block from 820B5050h-820B5064h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B5064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5064);
		  /* 820B5064h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820B5064h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820B5064h case    0:*/		return 0x820B5068;
		  /* 820B5068h */ case    1:  		/* bc 12, CR6_EQ, -748 */
		/* 820B5068h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B4D7C;  }
		/* 820B5068h case    1:*/		return 0x820B506C;
		  /* 820B506Ch */ case    2:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820B506Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820B506Ch case    2:*/		return 0x820B5070;
		  /* 820B5070h */ case    3:  		/* b -768 */
		/* 820B5070h case    3:*/		return 0x820B4D70;
		/* 820B5070h case    3:*/		return 0x820B5074;
		  /* 820B5074h */ case    4:  		/* nop */
		/* 820B5074h case    4:*/		cpu::op::nop();
		/* 820B5074h case    4:*/		return 0x820B5078;
	}
	return 0x820B5078;
} // Block from 820B5064h-820B5078h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820B5078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5078);
		  /* 820B5078h */ case    0:  		/* mfspr R12, LR */
		/* 820B5078h case    0:*/		regs.R12 = regs.LR;
		/* 820B5078h case    0:*/		return 0x820B507C;
		  /* 820B507Ch */ case    1:  		/* bl -147036 */
		/* 820B507Ch case    1:*/		regs.LR = 0x820B5080; return 0x82091220;
		/* 820B507Ch case    1:*/		return 0x820B5080;
		  /* 820B5080h */ case    2:  		/* stwu R1, <#[R1 - 384]> */
		/* 820B5080h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE80);
		/* 820B5080h case    2:*/		return 0x820B5084;
		  /* 820B5084h */ case    3:  		/* addi R11, R3, 44 */
		/* 820B5084h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x2C);
		/* 820B5084h case    3:*/		return 0x820B5088;
		  /* 820B5088h */ case    4:  		/* lwz R10, <#[R3 + 48]> */
		/* 820B5088h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 820B5088h case    4:*/		return 0x820B508C;
		  /* 820B508Ch */ case    5:  		/* mr R16, R8 */
		/* 820B508Ch case    5:*/		regs.R16 = regs.R8;
		/* 820B508Ch case    5:*/		return 0x820B5090;
		  /* 820B5090h */ case    6:  		/* lwz R9, <#[R3 + 52]> */
		/* 820B5090h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000034) );
		/* 820B5090h case    6:*/		return 0x820B5094;
		  /* 820B5094h */ case    7:  		/* stw R11, <#[R1 + 172]> */
		/* 820B5094h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000AC) );
		/* 820B5094h case    7:*/		return 0x820B5098;
		  /* 820B5098h */ case    8:  		/* mr R21, R7 */
		/* 820B5098h case    8:*/		regs.R21 = regs.R7;
		/* 820B5098h case    8:*/		return 0x820B509C;
		  /* 820B509Ch */ case    9:  		/* lwz R8, <#[R3 + 60]> */
		/* 820B509Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000003C) );
		/* 820B509Ch case    9:*/		return 0x820B50A0;
		  /* 820B50A0h */ case   10:  		/* li R18, 0 */
		/* 820B50A0h case   10:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 820B50A0h case   10:*/		return 0x820B50A4;
		  /* 820B50A4h */ case   11:  		/* lwz R7, <#[R3 + 64]> */
		/* 820B50A4h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000040) );
		/* 820B50A4h case   11:*/		return 0x820B50A8;
		  /* 820B50A8h */ case   12:  		/* mr R14, R4 */
		/* 820B50A8h case   12:*/		regs.R14 = regs.R4;
		/* 820B50A8h case   12:*/		return 0x820B50AC;
		  /* 820B50ACh */ case   13:  		/* lwz R11, <#[R11]> */
		/* 820B50ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820B50ACh case   13:*/		return 0x820B50B0;
		  /* 820B50B0h */ case   14:  		/* mr R31, R3 */
		/* 820B50B0h case   14:*/		regs.R31 = regs.R3;
		/* 820B50B0h case   14:*/		return 0x820B50B4;
		  /* 820B50B4h */ case   15:  		/* mr R4, R5 */
		/* 820B50B4h case   15:*/		regs.R4 = regs.R5;
		/* 820B50B4h case   15:*/		return 0x820B50B8;
		  /* 820B50B8h */ case   16:  		/* stw R5, <#[R1 + 420]> */
		/* 820B50B8h case   16:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000001A4) );
		/* 820B50B8h case   16:*/		return 0x820B50BC;
		  /* 820B50BCh */ case   17:  		/* mr R23, R6 */
		/* 820B50BCh case   17:*/		regs.R23 = regs.R6;
		/* 820B50BCh case   17:*/		return 0x820B50C0;
		  /* 820B50C0h */ case   18:  		/* stw R10, <#[R1 + 164]> */
		/* 820B50C0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000A4) );
		/* 820B50C0h case   18:*/		return 0x820B50C4;
		  /* 820B50C4h */ case   19:  		/* mr R17, R18 */
		/* 820B50C4h case   19:*/		regs.R17 = regs.R18;
		/* 820B50C4h case   19:*/		return 0x820B50C8;
		  /* 820B50C8h */ case   20:  		/* stw R9, <#[R1 + 168]> */
		/* 820B50C8h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000A8) );
		/* 820B50C8h case   20:*/		return 0x820B50CC;
		  /* 820B50CCh */ case   21:  		/* mr R15, R18 */
		/* 820B50CCh case   21:*/		regs.R15 = regs.R18;
		/* 820B50CCh case   21:*/		return 0x820B50D0;
		  /* 820B50D0h */ case   22:  		/* stw R8, <#[R1 + 192]> */
		/* 820B50D0h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000C0) );
		/* 820B50D0h case   22:*/		return 0x820B50D4;
		  /* 820B50D4h */ case   23:  		/* stw R11, <#[R1 + 156]> */
		/* 820B50D4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 820B50D4h case   23:*/		return 0x820B50D8;
		  /* 820B50D8h */ case   24:  		/* cmplwi CR6, R16, 0 */
		/* 820B50D8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820B50D8h case   24:*/		return 0x820B50DC;
		  /* 820B50DCh */ case   25:  		/* stw R7, <#[R1 + 196]> */
		/* 820B50DCh case   25:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x000000C4) );
		/* 820B50DCh case   25:*/		return 0x820B50E0;
		  /* 820B50E0h */ case   26:  		/* stw R18, <#[R1 + 140]> */
		/* 820B50E0h case   26:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x0000008C) );
		/* 820B50E0h case   26:*/		return 0x820B50E4;
		  /* 820B50E4h */ case   27:  		/* stw R18, <#[R1 + 188]> */
		/* 820B50E4h case   27:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x000000BC) );
		/* 820B50E4h case   27:*/		return 0x820B50E8;
		  /* 820B50E8h */ case   28:  		/* stw R18, <#[R1 + 148]> */
		/* 820B50E8h case   28:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000094) );
		/* 820B50E8h case   28:*/		return 0x820B50EC;
		  /* 820B50ECh */ case   29:  		/* stw R18, <#[R1 + 152]> */
		/* 820B50ECh case   29:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000098) );
		/* 820B50ECh case   29:*/		return 0x820B50F0;
		  /* 820B50F0h */ case   30:  		/* stw R18, <#[R1 + 184]> */
		/* 820B50F0h case   30:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x000000B8) );
		/* 820B50F0h case   30:*/		return 0x820B50F4;
		  /* 820B50F4h */ case   31:  		/* stw R18, <#[R1 + 160]> */
		/* 820B50F4h case   31:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x000000A0) );
		/* 820B50F4h case   31:*/		return 0x820B50F8;
		  /* 820B50F8h */ case   32:  		/* bc 4, CR6_EQ, 8 */
		/* 820B50F8h case   32:*/		if ( !regs.CR[6].eq ) { return 0x820B5100;  }
		/* 820B50F8h case   32:*/		return 0x820B50FC;
		  /* 820B50FCh */ case   33:  		/* lwz R16, <#[R3 + 24]> */
		/* 820B50FCh case   33:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R3 + 0x00000018) );
		/* 820B50FCh case   33:*/		return 0x820B5100;
	}
	return 0x820B5100;
} // Block from 820B5078h-820B5100h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820B5100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5100);
		  /* 820B5100h */ case    0:  		/* addi R5, R1, 208 */
		/* 820B5100h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xD0);
		/* 820B5100h case    0:*/		return 0x820B5104;
		  /* 820B5104h */ case    1:  		/* mr R3, R31 */
		/* 820B5104h case    1:*/		regs.R3 = regs.R31;
		/* 820B5104h case    1:*/		return 0x820B5108;
		  /* 820B5108h */ case    2:  		/* bl -25320 */
		/* 820B5108h case    2:*/		regs.LR = 0x820B510C; return 0x820AEE20;
		/* 820B5108h case    2:*/		return 0x820B510C;
		  /* 820B510Ch */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820B510Ch case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820B510Ch case    3:*/		return 0x820B5110;
		  /* 820B5110h */ case    4:  		/* bc 12, CR0_LT, 96 */
		/* 820B5110h case    4:*/		if ( regs.CR[0].lt ) { return 0x820B5170;  }
		/* 820B5110h case    4:*/		return 0x820B5114;
		  /* 820B5114h */ case    5:  		/* lis R11, -32256 */
		/* 820B5114h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820B5114h case    5:*/		return 0x820B5118;
		  /* 820B5118h */ case    6:  		/* lfd FR12, <#[R1 + 208]> */
		/* 820B5118h case    6:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x000000D0) );
		/* 820B5118h case    6:*/		return 0x820B511C;
		  /* 820B511Ch */ case    7:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 820B511Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 820B511Ch case    7:*/		return 0x820B5120;
		  /* 820B5120h */ case    8:  		/* fcmpu CR6, FR12, FR0 */
		/* 820B5120h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 820B5120h case    8:*/		return 0x820B5124;
		  /* 820B5124h */ case    9:  		/* bc 12, CR6_GT, 68 */
		/* 820B5124h case    9:*/		if ( regs.CR[6].gt ) { return 0x820B5168;  }
		/* 820B5124h case    9:*/		return 0x820B5128;
		  /* 820B5128h */ case   10:  		/* lfd FR13, <#[R1 + 216]> */
		/* 820B5128h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000D8) );
		/* 820B5128h case   10:*/		return 0x820B512C;
		  /* 820B512Ch */ case   11:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B512Ch case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B512Ch case   11:*/		return 0x820B5130;
		  /* 820B5130h */ case   12:  		/* bc 12, CR6_LT, 56 */
		/* 820B5130h case   12:*/		if ( regs.CR[6].lt ) { return 0x820B5168;  }
		/* 820B5130h case   12:*/		return 0x820B5134;
		  /* 820B5134h */ case   13:  		/* fcmpu CR6, FR12, FR0 */
		/* 820B5134h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 820B5134h case   13:*/		return 0x820B5138;
		  /* 820B5138h */ case   14:  		/* bc 4, CR6_EQ, 56 */
		/* 820B5138h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820B5170;  }
		/* 820B5138h case   14:*/		return 0x820B513C;
		  /* 820B513Ch */ case   15:  		/* fcmpu CR6, FR13, FR0 */
		/* 820B513Ch case   15:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820B513Ch case   15:*/		return 0x820B5140;
		  /* 820B5140h */ case   16:  		/* bc 4, CR6_EQ, 48 */
		/* 820B5140h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820B5170;  }
		/* 820B5140h case   16:*/		return 0x820B5144;
		  /* 820B5144h */ case   17:  		/* mr R4, R21 */
		/* 820B5144h case   17:*/		regs.R4 = regs.R21;
		/* 820B5144h case   17:*/		return 0x820B5148;
		  /* 820B5148h */ case   18:  		/* lwz R29, <#[R31 + 24]> */
		/* 820B5148h case   18:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000018) );
		/* 820B5148h case   18:*/		return 0x820B514C;
		  /* 820B514Ch */ case   19:  		/* li R5, 0 */
		/* 820B514Ch case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820B514Ch case   19:*/		return 0x820B5150;
		  /* 820B5150h */ case   20:  		/* stw R16, <#[R31 + 24]> */
		/* 820B5150h case   20:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R31 + 0x00000018) );
		/* 820B5150h case   20:*/		return 0x820B5154;
		  /* 820B5154h */ case   21:  		/* mr R3, R31 */
		/* 820B5154h case   21:*/		regs.R3 = regs.R31;
		/* 820B5154h case   21:*/		return 0x820B5158;
		  /* 820B5158h */ case   22:  		/* bl 43336 */
		/* 820B5158h case   22:*/		regs.LR = 0x820B515C; return 0x820BFAA0;
		/* 820B5158h case   22:*/		return 0x820B515C;
		  /* 820B515Ch */ case   23:  		/* mr R30, R3 */
		/* 820B515Ch case   23:*/		regs.R30 = regs.R3;
		/* 820B515Ch case   23:*/		return 0x820B5160;
		  /* 820B5160h */ case   24:  		/* stw R29, <#[R31 + 24]> */
		/* 820B5160h case   24:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000018) );
		/* 820B5160h case   24:*/		return 0x820B5164;
		  /* 820B5164h */ case   25:  		/* b 3868 */
		/* 820B5164h case   25:*/		return 0x820B6080;
		/* 820B5164h case   25:*/		return 0x820B5168;
	}
	return 0x820B5168;
} // Block from 820B5100h-820B5168h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820B5168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5168);
		  /* 820B5168h */ case    0:  		/* mr R4, R23 */
		/* 820B5168h case    0:*/		regs.R4 = regs.R23;
		/* 820B5168h case    0:*/		return 0x820B516C;
		  /* 820B516Ch */ case    1:  		/* b -36 */
		/* 820B516Ch case    1:*/		return 0x820B5148;
		/* 820B516Ch case    1:*/		return 0x820B5170;
	}
	return 0x820B5170;
} // Block from 820B5168h-820B5170h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B5170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5170);
		  /* 820B5170h */ case    0:  		/* li R6, 1 */
		/* 820B5170h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820B5170h case    0:*/		return 0x820B5174;
		  /* 820B5174h */ case    1:  		/* addi R5, R1, 420 */
		/* 820B5174h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1A4);
		/* 820B5174h case    1:*/		return 0x820B5178;
		  /* 820B5178h */ case    2:  		/* li R4, 0 */
		/* 820B5178h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B5178h case    2:*/		return 0x820B517C;
		  /* 820B517Ch */ case    3:  		/* mr R3, R31 */
		/* 820B517Ch case    3:*/		regs.R3 = regs.R31;
		/* 820B517Ch case    3:*/		return 0x820B5180;
		  /* 820B5180h */ case    4:  		/* bl -1952 */
		/* 820B5180h case    4:*/		regs.LR = 0x820B5184; return 0x820B49E0;
		/* 820B5180h case    4:*/		return 0x820B5184;
		  /* 820B5184h */ case    5:  		/* or. R30, R3, R3 */
		/* 820B5184h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B5184h case    5:*/		return 0x820B5188;
		  /* 820B5188h */ case    6:  		/* bc 12, CR0_LT, 3832 */
		/* 820B5188h case    6:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B5188h case    6:*/		return 0x820B518C;
		  /* 820B518Ch */ case    7:  		/* lwz R9, <#[R31 + 8]> */
		/* 820B518Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820B518Ch case    7:*/		return 0x820B5190;
		  /* 820B5190h */ case    8:  		/* li R19, -1 */
		/* 820B5190h case    8:*/		cpu::op::li<0>(regs,&regs.R19,0xFFFFFFFF);
		/* 820B5190h case    8:*/		return 0x820B5194;
		  /* 820B5194h */ case    9:  		/* stw R18, <#[R1 + 132]> */
		/* 820B5194h case    9:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000084) );
		/* 820B5194h case    9:*/		return 0x820B5198;
		  /* 820B5198h */ case   10:  		/* stw R19, <#[R1 + 136]> */
		/* 820B5198h case   10:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000088) );
		/* 820B5198h case   10:*/		return 0x820B519C;
		  /* 820B519Ch */ case   11:  		/* lwz R5, <#[R1 + 420]> */
		/* 820B519Ch case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001A4) );
		/* 820B519Ch case   11:*/		return 0x820B51A0;
		  /* 820B51A0h */ case   12:  		/* lwz R11, <#[R9 + 20]> */
		/* 820B51A0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 820B51A0h case   12:*/		return 0x820B51A4;
		  /* 820B51A4h */ case   13:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 820B51A4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 820B51A4h case   13:*/		return 0x820B51A8;
		  /* 820B51A8h */ case   14:  		/* lwzx R29, <#[R10 + R11]> */
		/* 820B51A8h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B51A8h case   14:*/		return 0x820B51AC;
		  /* 820B51ACh */ case   15:  		/* lwz R11, <#[R29 + 72]> */
		/* 820B51ACh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000048) );
		/* 820B51ACh case   15:*/		return 0x820B51B0;
		  /* 820B51B0h */ case   16:  		/* cmpwi CR6, R11, -1 */
		/* 820B51B0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B51B0h case   16:*/		return 0x820B51B4;
		  /* 820B51B4h */ case   17:  		/* bc 12, CR6_EQ, 468 */
		/* 820B51B4h case   17:*/		if ( regs.CR[6].eq ) { return 0x820B5388;  }
		/* 820B51B4h case   17:*/		return 0x820B51B8;
		  /* 820B51B8h */ case   18:  		/* lwz R10, <#[R9 + 24]> */
		/* 820B51B8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000018) );
		/* 820B51B8h case   18:*/		return 0x820B51BC;
		  /* 820B51BCh */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B51BCh case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B51BCh case   19:*/		return 0x820B51C0;
		  /* 820B51C0h */ case   20:  		/* lis R8, 8240 */
		/* 820B51C0h case   20:*/		cpu::op::lis<0>(regs,&regs.R8,0x2030);
		/* 820B51C0h case   20:*/		return 0x820B51C4;
		  /* 820B51C4h */ case   21:  		/* lwzx R10, <#[R11 + R10]> */
		/* 820B51C4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B51C4h case   21:*/		return 0x820B51C8;
		  /* 820B51C8h */ case   22:  		/* lwz R11, <#[R10]> */
		/* 820B51C8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820B51C8h case   22:*/		return 0x820B51CC;
		  /* 820B51CCh */ case   23:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820B51CCh case   23:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820B51CCh case   23:*/		return 0x820B51D0;
		  /* 820B51D0h */ case   24:  		/* cmplw CR6, R11, R8 */
		/* 820B51D0h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820B51D0h case   24:*/		return 0x820B51D4;
		  /* 820B51D4h */ case   25:  		/* bc 4, CR6_EQ, 436 */
		/* 820B51D4h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820B5388;  }
		/* 820B51D4h case   25:*/		return 0x820B51D8;
		  /* 820B51D8h */ case   26:  		/* lwz R7, <#[R10 + 12]> */
		/* 820B51D8h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 820B51D8h case   26:*/		return 0x820B51DC;
		  /* 820B51DCh */ case   27:  		/* mr R11, R18 */
		/* 820B51DCh case   27:*/		regs.R11 = regs.R18;
		/* 820B51DCh case   27:*/		return 0x820B51E0;
		  /* 820B51E0h */ case   28:  		/* cmplwi CR6, R7, 0 */
		/* 820B51E0h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820B51E0h case   28:*/		return 0x820B51E4;
		  /* 820B51E4h */ case   29:  		/* bc 12, CR6_EQ, 40 */
		/* 820B51E4h case   29:*/		if ( regs.CR[6].eq ) { return 0x820B520C;  }
		/* 820B51E4h case   29:*/		return 0x820B51E8;
		  /* 820B51E8h */ case   30:  		/* lwz R6, <#[R10 + 16]> */
		/* 820B51E8h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 820B51E8h case   30:*/		return 0x820B51EC;
		  /* 820B51ECh */ case   31:  		/* mr R8, R18 */
		/* 820B51ECh case   31:*/		regs.R8 = regs.R18;
		/* 820B51ECh case   31:*/		return 0x820B51F0;
		  /* 820B51F0h */ case   32:  		/* lwzx R4, <#[R6 + R8]> */
		/* 820B51F0h case   32:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 820B51F0h case   32:*/		return 0x820B51F4;
		  /* 820B51F4h */ case   33:  		/* cmplw CR6, R4, R5 */
		/* 820B51F4h case   33:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 820B51F4h case   33:*/		return 0x820B51F8;
		  /* 820B51F8h */ case   34:  		/* bc 12, CR6_EQ, 20 */
		/* 820B51F8h case   34:*/		if ( regs.CR[6].eq ) { return 0x820B520C;  }
		/* 820B51F8h case   34:*/		return 0x820B51FC;
		  /* 820B51FCh */ case   35:  		/* addi R11, R11, 1 */
		/* 820B51FCh case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820B51FCh case   35:*/		return 0x820B5200;
		  /* 820B5200h */ case   36:  		/* addi R8, R8, 4 */
		/* 820B5200h case   36:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820B5200h case   36:*/		return 0x820B5204;
		  /* 820B5204h */ case   37:  		/* cmplw CR6, R11, R7 */
		/* 820B5204h case   37:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 820B5204h case   37:*/		return 0x820B5208;
		  /* 820B5208h */ case   38:  		/* bc 12, CR6_LT, -24 */
		/* 820B5208h case   38:*/		if ( regs.CR[6].lt ) { return 0x820B51F0;  }
		/* 820B5208h case   38:*/		return 0x820B520C;
	}
	return 0x820B520C;
} // Block from 820B5170h-820B520Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 820B520Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B520C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B520C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B520C);
		  /* 820B520Ch */ case    0:  		/* add R8, R7, R11 */
		/* 820B520Ch case    0:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R11);
		/* 820B520Ch case    0:*/		return 0x820B5210;
		  /* 820B5210h */ case    1:  		/* lwz R10, <#[R10 + 8]> */
		/* 820B5210h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820B5210h case    1:*/		return 0x820B5214;
		  /* 820B5214h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820B5214h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820B5214h case    2:*/		return 0x820B5218;
		  /* 820B5218h */ case    3:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820B5218h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820B5218h case    3:*/		return 0x820B521C;
		  /* 820B521Ch */ case    4:  		/* lwzx R6, <#[R11 + R10]> */
		/* 820B521Ch case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820B521Ch case    4:*/		return 0x820B5220;
		  /* 820B5220h */ case    5:  		/* lwzx R5, <#[R8 + R10]> */
		/* 820B5220h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820B5220h case    5:*/		return 0x820B5224;
		  /* 820B5224h */ case    6:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 820B5224h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 820B5224h case    6:*/		return 0x820B5228;
		  /* 820B5228h */ case    7:  		/* stw R5, <#[R1 + 176]> */
		/* 820B5228h case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000B0) );
		/* 820B5228h case    7:*/		return 0x820B522C;
		  /* 820B522Ch */ case    8:  		/* lwz R11, <#[R9 + 20]> */
		/* 820B522Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 820B522Ch case    8:*/		return 0x820B5230;
		  /* 820B5230h */ case    9:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820B5230h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B5230h case    9:*/		return 0x820B5234;
		  /* 820B5234h */ case   10:  		/* lwz R10, <#[R10 + 72]> */
		/* 820B5234h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 820B5234h case   10:*/		return 0x820B5238;
		  /* 820B5238h */ case   11:  		/* cmpwi CR6, R10, -1 */
		/* 820B5238h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B5238h case   11:*/		return 0x820B523C;
		  /* 820B523Ch */ case   12:  		/* bc 12, CR6_EQ, 332 */
		/* 820B523Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820B5388;  }
		/* 820B523Ch case   12:*/		return 0x820B5240;
		  /* 820B5240h */ case   13:  		/* rlwinm R8, R5, 2, 0, 29 */
		/* 820B5240h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R5);
		/* 820B5240h case   13:*/		return 0x820B5244;
		  /* 820B5244h */ case   14:  		/* lwzx R11, <#[R8 + R11]> */
		/* 820B5244h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820B5244h case   14:*/		return 0x820B5248;
		  /* 820B5248h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 820B5248h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820B5248h case   15:*/		return 0x820B524C;
		  /* 820B524Ch */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820B524Ch case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820B524Ch case   16:*/		return 0x820B5250;
		  /* 820B5250h */ case   17:  		/* bc 12, CR0_EQ, 312 */
		/* 820B5250h case   17:*/		if ( regs.CR[0].eq ) { return 0x820B5388;  }
		/* 820B5250h case   17:*/		return 0x820B5254;
		  /* 820B5254h */ case   18:  		/* lwz R11, <#[R9 + 24]> */
		/* 820B5254h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 820B5254h case   18:*/		return 0x820B5258;
		  /* 820B5258h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B5258h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B5258h case   19:*/		return 0x820B525C;
		  /* 820B525Ch */ case   20:  		/* lis R9, 4112 */
		/* 820B525Ch case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0x1010);
		/* 820B525Ch case   20:*/		return 0x820B5260;
		  /* 820B5260h */ case   21:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820B5260h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B5260h case   21:*/		return 0x820B5264;
		  /* 820B5264h */ case   22:  		/* lwz R11, <#[R10]> */
		/* 820B5264h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820B5264h case   22:*/		return 0x820B5268;
		  /* 820B5268h */ case   23:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 820B5268h case   23:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 820B5268h case   23:*/		return 0x820B526C;
		  /* 820B526Ch */ case   24:  		/* cmplw CR6, R11, R9 */
		/* 820B526Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820B526Ch case   24:*/		return 0x820B5270;
		  /* 820B5270h */ case   25:  		/* bc 4, CR6_EQ, 280 */
		/* 820B5270h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820B5388;  }
		/* 820B5270h case   25:*/		return 0x820B5274;
		  /* 820B5274h */ case   26:  		/* lwz R7, <#[R10 + 12]> */
		/* 820B5274h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 820B5274h case   26:*/		return 0x820B5278;
		  /* 820B5278h */ case   27:  		/* mr R9, R18 */
		/* 820B5278h case   27:*/		regs.R9 = regs.R18;
		/* 820B5278h case   27:*/		return 0x820B527C;
		  /* 820B527Ch */ case   28:  		/* cmplwi CR6, R7, 0 */
		/* 820B527Ch case   28:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820B527Ch case   28:*/		return 0x820B5280;
		  /* 820B5280h */ case   29:  		/* bc 12, CR6_EQ, 40 */
		/* 820B5280h case   29:*/		if ( regs.CR[6].eq ) { return 0x820B52A8;  }
		/* 820B5280h case   29:*/		return 0x820B5284;
		  /* 820B5284h */ case   30:  		/* lwz R8, <#[R10 + 16]> */
		/* 820B5284h case   30:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 820B5284h case   30:*/		return 0x820B5288;
		  /* 820B5288h */ case   31:  		/* mr R11, R18 */
		/* 820B5288h case   31:*/		regs.R11 = regs.R18;
		/* 820B5288h case   31:*/		return 0x820B528C;
		  /* 820B528Ch */ case   32:  		/* lwzx R4, <#[R8 + R11]> */
		/* 820B528Ch case   32:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 820B528Ch case   32:*/		return 0x820B5290;
		  /* 820B5290h */ case   33:  		/* cmplw CR6, R4, R6 */
		/* 820B5290h case   33:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 820B5290h case   33:*/		return 0x820B5294;
		  /* 820B5294h */ case   34:  		/* bc 12, CR6_EQ, 20 */
		/* 820B5294h case   34:*/		if ( regs.CR[6].eq ) { return 0x820B52A8;  }
		/* 820B5294h case   34:*/		return 0x820B5298;
		  /* 820B5298h */ case   35:  		/* addi R9, R9, 1 */
		/* 820B5298h case   35:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820B5298h case   35:*/		return 0x820B529C;
		  /* 820B529Ch */ case   36:  		/* addi R11, R11, 4 */
		/* 820B529Ch case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820B529Ch case   36:*/		return 0x820B52A0;
		  /* 820B52A0h */ case   37:  		/* cmplw CR6, R9, R7 */
		/* 820B52A0h case   37:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820B52A0h case   37:*/		return 0x820B52A4;
		  /* 820B52A4h */ case   38:  		/* bc 12, CR6_LT, -24 */
		/* 820B52A4h case   38:*/		if ( regs.CR[6].lt ) { return 0x820B528C;  }
		/* 820B52A4h case   38:*/		return 0x820B52A8;
	}
	return 0x820B52A8;
} // Block from 820B520Ch-820B52A8h (39 instructions)

//////////////////////////////////////////////////////
// Block at 820B52A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B52A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B52A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B52A8);
		  /* 820B52A8h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 820B52A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820B52A8h case    0:*/		return 0x820B52AC;
		  /* 820B52ACh */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 820B52ACh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 820B52ACh case    1:*/		return 0x820B52B0;
		  /* 820B52B0h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820B52B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B52B0h case    2:*/		return 0x820B52B4;
		  /* 820B52B4h */ case    3:  		/* cmplw CR6, R11, R5 */
		/* 820B52B4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820B52B4h case    3:*/		return 0x820B52B8;
		  /* 820B52B8h */ case    4:  		/* bc 4, CR6_EQ, 208 */
		/* 820B52B8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820B5388;  }
		/* 820B52B8h case    4:*/		return 0x820B52BC;
		  /* 820B52BCh */ case    5:  		/* li R6, 1 */
		/* 820B52BCh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820B52BCh case    5:*/		return 0x820B52C0;
		  /* 820B52C0h */ case    6:  		/* addi R5, R1, 176 */
		/* 820B52C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB0);
		/* 820B52C0h case    6:*/		return 0x820B52C4;
		  /* 820B52C4h */ case    7:  		/* li R4, 0 */
		/* 820B52C4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B52C4h case    7:*/		return 0x820B52C8;
	}
	return 0x820B52C8;
} // Block from 820B52A8h-820B52C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B52C8h
// Function '?Vectorize@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAIIHH00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B52C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B52C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B52C8);
		  /* 820B52C8h */ case    0:  		/* mr R3, R31 */
		/* 820B52C8h case    0:*/		regs.R3 = regs.R31;
		/* 820B52C8h case    0:*/		return 0x820B52CC;
		  /* 820B52CCh */ case    1:  		/* bl -2284 */
		/* 820B52CCh case    1:*/		regs.LR = 0x820B52D0; return 0x820B49E0;
		/* 820B52CCh case    1:*/		return 0x820B52D0;
		  /* 820B52D0h */ case    2:  		/* or. R30, R3, R3 */
		/* 820B52D0h case    2:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B52D0h case    2:*/		return 0x820B52D4;
		  /* 820B52D4h */ case    3:  		/* bc 12, CR0_LT, 3500 */
		/* 820B52D4h case    3:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B52D4h case    3:*/		return 0x820B52D8;
		  /* 820B52D8h */ case    4:  		/* stw R19, <#[R1 + 128]> */
		/* 820B52D8h case    4:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000080) );
		/* 820B52D8h case    4:*/		return 0x820B52DC;
		  /* 820B52DCh */ case    5:  		/* lis R5, 4096 */
		/* 820B52DCh case    5:*/		cpu::op::lis<0>(regs,&regs.R5,0x1000);
		/* 820B52DCh case    5:*/		return 0x820B52E0;
		  /* 820B52E0h */ case    6:  		/* stw R19, <#[R1 + 132]> */
		/* 820B52E0h case    6:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000084) );
		/* 820B52E0h case    6:*/		return 0x820B52E4;
		  /* 820B52E4h */ case    7:  		/* li R9, 23 */
		/* 820B52E4h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B52E4h case    7:*/		return 0x820B52E8;
		  /* 820B52E8h */ case    8:  		/* li R8, 0 */
		/* 820B52E8h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B52E8h case    8:*/		return 0x820B52EC;
		  /* 820B52ECh */ case    9:  		/* addi R7, R1, 176 */
		/* 820B52ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xB0);
		/* 820B52ECh case    9:*/		return 0x820B52F0;
		  /* 820B52F0h */ case   10:  		/* addi R6, R1, 128 */
		/* 820B52F0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820B52F0h case   10:*/		return 0x820B52F4;
		  /* 820B52F4h */ case   11:  		/* ori R5, R5, 1 */
		/* 820B52F4h case   11:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B52F4h case   11:*/		return 0x820B52F8;
		  /* 820B52F8h */ case   12:  		/* mr R4, R14 */
		/* 820B52F8h case   12:*/		regs.R4 = regs.R14;
		/* 820B52F8h case   12:*/		return 0x820B52FC;
		  /* 820B52FCh */ case   13:  		/* mr R3, R31 */
		/* 820B52FCh case   13:*/		regs.R3 = regs.R31;
		/* 820B52FCh case   13:*/		return 0x820B5300;
		  /* 820B5300h */ case   14:  		/* bl -18424 */
		/* 820B5300h case   14:*/		regs.LR = 0x820B5304; return 0x820B0B08;
		/* 820B5300h case   14:*/		return 0x820B5304;
		  /* 820B5304h */ case   15:  		/* or. R30, R3, R3 */
		/* 820B5304h case   15:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B5304h case   15:*/		return 0x820B5308;
		  /* 820B5308h */ case   16:  		/* bc 12, CR0_LT, 3448 */
		/* 820B5308h case   16:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B5308h case   16:*/		return 0x820B530C;
		  /* 820B530Ch */ case   17:  		/* lis R5, 4096 */
		/* 820B530Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R5,0x1000);
		/* 820B530Ch case   17:*/		return 0x820B5310;
		  /* 820B5310h */ case   18:  		/* li R9, 23 */
		/* 820B5310h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B5310h case   18:*/		return 0x820B5314;
		  /* 820B5314h */ case   19:  		/* li R8, 0 */
		/* 820B5314h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B5314h case   19:*/		return 0x820B5318;
		  /* 820B5318h */ case   20:  		/* addi R7, R1, 420 */
		/* 820B5318h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x1A4);
		/* 820B5318h case   20:*/		return 0x820B531C;
		  /* 820B531Ch */ case   21:  		/* addi R6, R1, 132 */
		/* 820B531Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x84);
		/* 820B531Ch case   21:*/		return 0x820B5320;
		  /* 820B5320h */ case   22:  		/* ori R5, R5, 1 */
		/* 820B5320h case   22:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B5320h case   22:*/		return 0x820B5324;
		  /* 820B5324h */ case   23:  		/* mr R4, R14 */
		/* 820B5324h case   23:*/		regs.R4 = regs.R14;
		/* 820B5324h case   23:*/		return 0x820B5328;
		  /* 820B5328h */ case   24:  		/* mr R3, R31 */
		/* 820B5328h case   24:*/		regs.R3 = regs.R31;
		/* 820B5328h case   24:*/		return 0x820B532C;
		  /* 820B532Ch */ case   25:  		/* bl -18468 */
		/* 820B532Ch case   25:*/		regs.LR = 0x820B5330; return 0x820B0B08;
		/* 820B532Ch case   25:*/		return 0x820B5330;
		  /* 820B5330h */ case   26:  		/* or. R30, R3, R3 */
		/* 820B5330h case   26:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B5330h case   26:*/		return 0x820B5334;
		  /* 820B5334h */ case   27:  		/* bc 12, CR0_LT, 3404 */
		/* 820B5334h case   27:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B5334h case   27:*/		return 0x820B5338;
		  /* 820B5338h */ case   28:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B5338h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B5338h case   28:*/		return 0x820B533C;
		  /* 820B533Ch */ case   29:  		/* mr R20, R18 */
		/* 820B533Ch case   29:*/		regs.R20 = regs.R18;
		/* 820B533Ch case   29:*/		return 0x820B5340;
		  /* 820B5340h */ case   30:  		/* lwz R10, <#[R1 + 176]> */
		/* 820B5340h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B0) );
		/* 820B5340h case   30:*/		return 0x820B5344;
		  /* 820B5344h */ case   31:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B5344h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B5344h case   31:*/		return 0x820B5348;
		  /* 820B5348h */ case   32:  		/* lwz R9, <#[R11 + 20]> */
		/* 820B5348h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820B5348h case   32:*/		return 0x820B534C;
		  /* 820B534Ch */ case   33:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B534Ch case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B534Ch case   33:*/		return 0x820B5350;
		  /* 820B5350h */ case   34:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820B5350h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820B5350h case   34:*/		return 0x820B5354;
		  /* 820B5354h */ case   35:  		/* lwz R9, <#[R10 + 4]> */
		/* 820B5354h case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820B5354h case   35:*/		return 0x820B5358;
		  /* 820B5358h */ case   36:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820B5358h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820B5358h case   36:*/		return 0x820B535C;
		  /* 820B535Ch */ case   37:  		/* lwzx R11, <#[R9 + R11]> */
		/* 820B535Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820B535Ch case   37:*/		return 0x820B5360;
		  /* 820B5360h */ case   38:  		/* lwz R11, <#[R11 + 4]> */
		/* 820B5360h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820B5360h case   38:*/		return 0x820B5364;
		  /* 820B5364h */ case   39:  		/* rlwinm. R9, R11, 0, 27, 27 */
		/* 820B5364h case   39:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R9,regs.R11);
		/* 820B5364h case   39:*/		return 0x820B5368;
		  /* 820B5368h */ case   40:  		/* bc 12, CR0_EQ, 356 */
		/* 820B5368h case   40:*/		if ( regs.CR[0].eq ) { return 0x820B54CC;  }
		/* 820B5368h case   40:*/		return 0x820B536C;
		  /* 820B536Ch */ case   41:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820B536Ch case   41:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820B536Ch case   41:*/		return 0x820B5370;
		  /* 820B5370h */ case   42:  		/* bc 12, CR0_EQ, 348 */
		/* 820B5370h case   42:*/		if ( regs.CR[0].eq ) { return 0x820B54CC;  }
		/* 820B5370h case   42:*/		return 0x820B5374;
		  /* 820B5374h */ case   43:  		/* lwz R11, <#[R10 + 8]> */
		/* 820B5374h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820B5374h case   43:*/		return 0x820B5378;
		  /* 820B5378h */ case   44:  		/* cmpwi CR6, R11, -1 */
		/* 820B5378h case   44:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820B5378h case   44:*/		return 0x820B537C;
		  /* 820B537Ch */ case   45:  		/* bc 4, CR6_EQ, 336 */
		/* 820B537Ch case   45:*/		if ( !regs.CR[6].eq ) { return 0x820B54CC;  }
		/* 820B537Ch case   45:*/		return 0x820B5380;
		  /* 820B5380h */ case   46:  		/* li R28, 1 */
		/* 820B5380h case   46:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 820B5380h case   46:*/		return 0x820B5384;
		  /* 820B5384h */ case   47:  		/* b 332 */
		/* 820B5384h case   47:*/		return 0x820B54D0;
		/* 820B5384h case   47:*/		return 0x820B5388;
	}
	return 0x820B5388;
} // Block from 820B52C8h-820B5388h (48 instructions)

//////////////////////////////////////////////////////
// Block at 820B5388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5388);
		  /* 820B5388h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820B5388h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820B5388h case    0:*/		return 0x820B538C;
		  /* 820B538Ch */ case    1:  		/* addi R7, R1, 420 */
		/* 820B538Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x1A4);
		/* 820B538Ch case    1:*/		return 0x820B5390;
		  /* 820B5390h */ case    2:  		/* stw R19, <#[R1 + 144]> */
		/* 820B5390h case    2:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000090) );
		/* 820B5390h case    2:*/		return 0x820B5394;
		  /* 820B5394h */ case    3:  		/* addi R6, R1, 144 */
		/* 820B5394h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 820B5394h case    3:*/		return 0x820B5398;
		  /* 820B5398h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820B5398h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820B5398h case    4:*/		return 0x820B539C;
		  /* 820B539Ch */ case    5:  		/* stw R19, <#[R1 + 128]> */
		/* 820B539Ch case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000080) );
		/* 820B539Ch case    5:*/		return 0x820B53A0;
		  /* 820B53A0h */ case    6:  		/* stw R19, <#[R1 + 132]> */
		/* 820B53A0h case    6:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000084) );
		/* 820B53A0h case    6:*/		return 0x820B53A4;
		  /* 820B53A4h */ case    7:  		/* mr R4, R14 */
		/* 820B53A4h case    7:*/		regs.R4 = regs.R14;
		/* 820B53A4h case    7:*/		return 0x820B53A8;
		  /* 820B53A8h */ case    8:  		/* mr R3, R31 */
		/* 820B53A8h case    8:*/		regs.R3 = regs.R31;
		/* 820B53A8h case    8:*/		return 0x820B53AC;
		  /* 820B53ACh */ case    9:  		/* bc 12, CR0_EQ, 172 */
		/* 820B53ACh case    9:*/		if ( regs.CR[0].eq ) { return 0x820B5458;  }
		/* 820B53ACh case    9:*/		return 0x820B53B0;
		  /* 820B53B0h */ case   10:  		/* lis R5, 4112 */
		/* 820B53B0h case   10:*/		cpu::op::lis<0>(regs,&regs.R5,0x1010);
		/* 820B53B0h case   10:*/		return 0x820B53B4;
		  /* 820B53B4h */ case   11:  		/* li R9, 16 */
		/* 820B53B4h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820B53B4h case   11:*/		return 0x820B53B8;
		  /* 820B53B8h */ case   12:  		/* li R8, 0 */
		/* 820B53B8h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B53B8h case   12:*/		return 0x820B53BC;
		  /* 820B53BCh */ case   13:  		/* ori R5, R5, 1 */
		/* 820B53BCh case   13:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B53BCh case   13:*/		return 0x820B53C0;
		  /* 820B53C0h */ case   14:  		/* bl -18616 */
		/* 820B53C0h case   14:*/		regs.LR = 0x820B53C4; return 0x820B0B08;
		/* 820B53C0h case   14:*/		return 0x820B53C4;
		  /* 820B53C4h */ case   15:  		/* or. R30, R3, R3 */
		/* 820B53C4h case   15:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B53C4h case   15:*/		return 0x820B53C8;
		  /* 820B53C8h */ case   16:  		/* bc 12, CR0_LT, 3256 */
		/* 820B53C8h case   16:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B53C8h case   16:*/		return 0x820B53CC;
		  /* 820B53CCh */ case   17:  		/* lis R5, 4096 */
		/* 820B53CCh case   17:*/		cpu::op::lis<0>(regs,&regs.R5,0x1000);
		/* 820B53CCh case   17:*/		return 0x820B53D0;
		  /* 820B53D0h */ case   18:  		/* li R9, 23 */
		/* 820B53D0h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B53D0h case   18:*/		return 0x820B53D4;
		  /* 820B53D4h */ case   19:  		/* li R8, 0 */
		/* 820B53D4h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820B53D4h case   19:*/		return 0x820B53D8;
		  /* 820B53D8h */ case   20:  		/* addi R7, R1, 420 */
		/* 820B53D8h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x1A4);
		/* 820B53D8h case   20:*/		return 0x820B53DC;
		  /* 820B53DCh */ case   21:  		/* addi R6, R1, 128 */
		/* 820B53DCh case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820B53DCh case   21:*/		return 0x820B53E0;
		  /* 820B53E0h */ case   22:  		/* ori R5, R5, 1 */
		/* 820B53E0h case   22:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B53E0h case   22:*/		return 0x820B53E4;
		  /* 820B53E4h */ case   23:  		/* mr R4, R14 */
		/* 820B53E4h case   23:*/		regs.R4 = regs.R14;
		/* 820B53E4h case   23:*/		return 0x820B53E8;
		  /* 820B53E8h */ case   24:  		/* mr R3, R31 */
		/* 820B53E8h case   24:*/		regs.R3 = regs.R31;
		/* 820B53E8h case   24:*/		return 0x820B53EC;
		  /* 820B53ECh */ case   25:  		/* bl -18660 */
		/* 820B53ECh case   25:*/		regs.LR = 0x820B53F0; return 0x820B0B08;
		/* 820B53ECh case   25:*/		return 0x820B53F0;
		  /* 820B53F0h */ case   26:  		/* or. R30, R3, R3 */
		/* 820B53F0h case   26:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B53F0h case   26:*/		return 0x820B53F4;
		  /* 820B53F4h */ case   27:  		/* bc 12, CR0_LT, 3212 */
		/* 820B53F4h case   27:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B53F4h case   27:*/		return 0x820B53F8;
		  /* 820B53F8h */ case   28:  		/* lis R5, 8240 */
		/* 820B53F8h case   28:*/		cpu::op::lis<0>(regs,&regs.R5,0x2030);
		/* 820B53F8h case   28:*/		return 0x820B53FC;
		  /* 820B53FCh */ case   29:  		/* li R9, 23 */
		/* 820B53FCh case   29:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B53FCh case   29:*/		return 0x820B5400;
		  /* 820B5400h */ case   30:  		/* addi R8, R1, 420 */
		/* 820B5400h case   30:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x1A4);
		/* 820B5400h case   30:*/		return 0x820B5404;
		  /* 820B5404h */ case   31:  		/* addi R7, R1, 144 */
		/* 820B5404h case   31:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820B5404h case   31:*/		return 0x820B5408;
		  /* 820B5408h */ case   32:  		/* addi R6, R1, 132 */
		/* 820B5408h case   32:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x84);
		/* 820B5408h case   32:*/		return 0x820B540C;
		  /* 820B540Ch */ case   33:  		/* ori R5, R5, 1 */
		/* 820B540Ch case   33:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B540Ch case   33:*/		return 0x820B5410;
		  /* 820B5410h */ case   34:  		/* mr R4, R14 */
		/* 820B5410h case   34:*/		regs.R4 = regs.R14;
		/* 820B5410h case   34:*/		return 0x820B5414;
		  /* 820B5414h */ case   35:  		/* mr R3, R31 */
		/* 820B5414h case   35:*/		regs.R3 = regs.R31;
		/* 820B5414h case   35:*/		return 0x820B5418;
	}
	return 0x820B5418;
} // Block from 820B5388h-820B5418h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820B5418h
// Function '?Unalias@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5418);
		  /* 820B5418h */ case    0:  		/* bl -18704 */
		/* 820B5418h case    0:*/		regs.LR = 0x820B541C; return 0x820B0B08;
		/* 820B5418h case    0:*/		return 0x820B541C;
		  /* 820B541Ch */ case    1:  		/* or. R30, R3, R3 */
		/* 820B541Ch case    1:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B541Ch case    1:*/		return 0x820B5420;
		  /* 820B5420h */ case    2:  		/* bc 12, CR0_LT, 3168 */
		/* 820B5420h case    2:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B5420h case    2:*/		return 0x820B5424;
		  /* 820B5424h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B5424h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B5424h case    3:*/		return 0x820B5428;
		  /* 820B5428h */ case    4:  		/* li R20, 1 */
		/* 820B5428h case    4:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 820B5428h case    4:*/		return 0x820B542C;
		  /* 820B542Ch */ case    5:  		/* lwz R10, <#[R29 + 4]> */
		/* 820B542Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 820B542Ch case    5:*/		return 0x820B5430;
		  /* 820B5430h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B5430h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B5430h case    6:*/		return 0x820B5434;
		  /* 820B5434h */ case    7:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B5434h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B5434h case    7:*/		return 0x820B5438;
		  /* 820B5438h */ case    8:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820B5438h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B5438h case    8:*/		return 0x820B543C;
		  /* 820B543Ch */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 820B543Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820B543Ch case    9:*/		return 0x820B5440;
		  /* 820B5440h */ case   10:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820B5440h case   10:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820B5440h case   10:*/		return 0x820B5444;
		  /* 820B5444h */ case   11:  		/* bc 12, CR0_EQ, 136 */
		/* 820B5444h case   11:*/		if ( regs.CR[0].eq ) { return 0x820B54CC;  }
		/* 820B5444h case   11:*/		return 0x820B5448;
		  /* 820B5448h */ case   12:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 820B5448h case   12:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820B5448h case   12:*/		return 0x820B544C;
		  /* 820B544Ch */ case   13:  		/* bc 12, CR0_EQ, 128 */
		/* 820B544Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x820B54CC;  }
		/* 820B544Ch case   13:*/		return 0x820B5450;
		  /* 820B5450h */ case   14:  		/* lwz R11, <#[R29 + 8]> */
		/* 820B5450h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820B5450h case   14:*/		return 0x820B5454;
		  /* 820B5454h */ case   15:  		/* b -220 */
		/* 820B5454h case   15:*/		return 0x820B5378;
		/* 820B5454h case   15:*/		return 0x820B5458;
	}
	return 0x820B5458;
} // Block from 820B5418h-820B5458h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820B5458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5458);
		  /* 820B5458h */ case    0:  		/* stw R19, <#[R1 + 180]> */
		/* 820B5458h case    0:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x000000B4) );
		/* 820B5458h case    0:*/		return 0x820B545C;
		  /* 820B545Ch */ case    1:  		/* li R8, 1 */
		/* 820B545Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820B545Ch case    1:*/		return 0x820B5460;
		  /* 820B5460h */ case    2:  		/* addi R5, R1, 180 */
		/* 820B5460h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB4);
		/* 820B5460h case    2:*/		return 0x820B5464;
		  /* 820B5464h */ case    3:  		/* bl -4788 */
		/* 820B5464h case    3:*/		regs.LR = 0x820B5468; return 0x820B41B0;
		/* 820B5464h case    3:*/		return 0x820B5468;
		  /* 820B5468h */ case    4:  		/* or. R30, R3, R3 */
		/* 820B5468h case    4:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B5468h case    4:*/		return 0x820B546C;
		  /* 820B546Ch */ case    5:  		/* bc 12, CR0_LT, 3092 */
		/* 820B546Ch case    5:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B546Ch case    5:*/		return 0x820B5470;
		  /* 820B5470h */ case    6:  		/* lis R5, 8224 */
		/* 820B5470h case    6:*/		cpu::op::lis<0>(regs,&regs.R5,0x2020);
		/* 820B5470h case    6:*/		return 0x820B5474;
		  /* 820B5474h */ case    7:  		/* li R9, 23 */
		/* 820B5474h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B5474h case    7:*/		return 0x820B5478;
		  /* 820B5478h */ case    8:  		/* addi R8, R1, 180 */
		/* 820B5478h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xB4);
		/* 820B5478h case    8:*/		return 0x820B547C;
		  /* 820B547Ch */ case    9:  		/* addi R7, R1, 144 */
		/* 820B547Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820B547Ch case    9:*/		return 0x820B5480;
		  /* 820B5480h */ case   10:  		/* addi R6, R1, 128 */
		/* 820B5480h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 820B5480h case   10:*/		return 0x820B5484;
		  /* 820B5484h */ case   11:  		/* ori R5, R5, 1 */
		/* 820B5484h case   11:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B5484h case   11:*/		return 0x820B5488;
		  /* 820B5488h */ case   12:  		/* mr R4, R14 */
		/* 820B5488h case   12:*/		regs.R4 = regs.R14;
		/* 820B5488h case   12:*/		return 0x820B548C;
		  /* 820B548Ch */ case   13:  		/* mr R3, R31 */
		/* 820B548Ch case   13:*/		regs.R3 = regs.R31;
		/* 820B548Ch case   13:*/		return 0x820B5490;
		  /* 820B5490h */ case   14:  		/* bl -18824 */
		/* 820B5490h case   14:*/		regs.LR = 0x820B5494; return 0x820B0B08;
		/* 820B5490h case   14:*/		return 0x820B5494;
		  /* 820B5494h */ case   15:  		/* or. R30, R3, R3 */
		/* 820B5494h case   15:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B5494h case   15:*/		return 0x820B5498;
		  /* 820B5498h */ case   16:  		/* bc 12, CR0_LT, 3048 */
		/* 820B5498h case   16:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B5498h case   16:*/		return 0x820B549C;
		  /* 820B549Ch */ case   17:  		/* lis R5, 8240 */
		/* 820B549Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R5,0x2030);
		/* 820B549Ch case   17:*/		return 0x820B54A0;
		  /* 820B54A0h */ case   18:  		/* li R9, 23 */
		/* 820B54A0h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820B54A0h case   18:*/		return 0x820B54A4;
		  /* 820B54A4h */ case   19:  		/* addi R8, R1, 180 */
		/* 820B54A4h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xB4);
		/* 820B54A4h case   19:*/		return 0x820B54A8;
		  /* 820B54A8h */ case   20:  		/* addi R7, R1, 144 */
		/* 820B54A8h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x90);
		/* 820B54A8h case   20:*/		return 0x820B54AC;
		  /* 820B54ACh */ case   21:  		/* addi R6, R1, 132 */
		/* 820B54ACh case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x84);
		/* 820B54ACh case   21:*/		return 0x820B54B0;
		  /* 820B54B0h */ case   22:  		/* ori R5, R5, 1 */
		/* 820B54B0h case   22:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820B54B0h case   22:*/		return 0x820B54B4;
		  /* 820B54B4h */ case   23:  		/* mr R4, R14 */
		/* 820B54B4h case   23:*/		regs.R4 = regs.R14;
		/* 820B54B4h case   23:*/		return 0x820B54B8;
		  /* 820B54B8h */ case   24:  		/* mr R3, R31 */
		/* 820B54B8h case   24:*/		regs.R3 = regs.R31;
		/* 820B54B8h case   24:*/		return 0x820B54BC;
		  /* 820B54BCh */ case   25:  		/* bl -18868 */
		/* 820B54BCh case   25:*/		regs.LR = 0x820B54C0; return 0x820B0B08;
		/* 820B54BCh case   25:*/		return 0x820B54C0;
		  /* 820B54C0h */ case   26:  		/* or. R30, R3, R3 */
		/* 820B54C0h case   26:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B54C0h case   26:*/		return 0x820B54C4;
		  /* 820B54C4h */ case   27:  		/* bc 12, CR0_LT, 3004 */
		/* 820B54C4h case   27:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B54C4h case   27:*/		return 0x820B54C8;
		  /* 820B54C8h */ case   28:  		/* li R20, 1 */
		/* 820B54C8h case   28:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 820B54C8h case   28:*/		return 0x820B54CC;
	}
	return 0x820B54CC;
} // Block from 820B5458h-820B54CCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 820B54CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B54CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B54CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B54CC);
		  /* 820B54CCh */ case    0:  		/* mr R28, R18 */
		/* 820B54CCh case    0:*/		regs.R28 = regs.R18;
		/* 820B54CCh case    0:*/		return 0x820B54D0;
	}
	return 0x820B54D0;
} // Block from 820B54CCh-820B54D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B54D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B54D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B54D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B54D0);
		  /* 820B54D0h */ case    0:  		/* li R6, 1 */
		/* 820B54D0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820B54D0h case    0:*/		return 0x820B54D4;
		  /* 820B54D4h */ case    1:  		/* addi R5, R1, 128 */
		/* 820B54D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 820B54D4h case    1:*/		return 0x820B54D8;
		  /* 820B54D8h */ case    2:  		/* li R4, 0 */
		/* 820B54D8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820B54D8h case    2:*/		return 0x820B54DC;
		  /* 820B54DCh */ case    3:  		/* mr R3, R31 */
		/* 820B54DCh case    3:*/		regs.R3 = regs.R31;
		/* 820B54DCh case    3:*/		return 0x820B54E0;
		  /* 820B54E0h */ case    4:  		/* bl -2816 */
		/* 820B54E0h case    4:*/		regs.LR = 0x820B54E4; return 0x820B49E0;
		/* 820B54E0h case    4:*/		return 0x820B54E4;
		  /* 820B54E4h */ case    5:  		/* or. R30, R3, R3 */
		/* 820B54E4h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820B54E4h case    5:*/		return 0x820B54E8;
		  /* 820B54E8h */ case    6:  		/* bc 12, CR0_LT, 2968 */
		/* 820B54E8h case    6:*/		if ( regs.CR[0].lt ) { return 0x820B6080;  }
		/* 820B54E8h case    6:*/		return 0x820B54EC;
		  /* 820B54ECh */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B54ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B54ECh case    7:*/		return 0x820B54F0;
		  /* 820B54F0h */ case    8:  		/* li R22, 1 */
		/* 820B54F0h case    8:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820B54F0h case    8:*/		return 0x820B54F4;
		  /* 820B54F4h */ case    9:  		/* lwz R10, <#[R1 + 128]> */
		/* 820B54F4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820B54F4h case    9:*/		return 0x820B54F8;
		  /* 820B54F8h */ case   10:  		/* mr R29, R18 */
		/* 820B54F8h case   10:*/		regs.R29 = regs.R18;
		/* 820B54F8h case   10:*/		return 0x820B54FC;
		  /* 820B54FCh */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B54FCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B54FCh case   11:*/		return 0x820B5500;
		  /* 820B5500h */ case   12:  		/* lwz R9, <#[R11 + 20]> */
		/* 820B5500h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820B5500h case   12:*/		return 0x820B5504;
		  /* 820B5504h */ case   13:  		/* lwz R11, <#[R11 + 16]> */
		/* 820B5504h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820B5504h case   13:*/		return 0x820B5508;
		  /* 820B5508h */ case   14:  		/* lwzx R10, <#[R9 + R10]> */
		/* 820B5508h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820B5508h case   14:*/		return 0x820B550C;
		  /* 820B550Ch */ case   15:  		/* lwz R10, <#[R10 + 4]> */
		/* 820B550Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820B550Ch case   15:*/		return 0x820B5510;
		  /* 820B5510h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820B5510h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820B5510h case   16:*/		return 0x820B5514;
		  /* 820B5514h */ case   17:  		/* lwzx R30, <#[R10 + R11]> */
		/* 820B5514h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820B5514h case   17:*/		return 0x820B5518;
		  /* 820B5518h */ case   18:  		/* lwz R11, <#[R30 + 4]> */
		/* 820B5518h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820B5518h case   18:*/		return 0x820B551C;
		  /* 820B551Ch */ case   19:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820B551Ch case   19:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820B551Ch case   19:*/		return 0x820B5520;
		  /* 820B5520h */ case   20:  		/* bc 12, CR0_EQ, 76 */
		/* 820B5520h case   20:*/		if ( regs.CR[0].eq ) { return 0x820B556C;  }
		/* 820B5520h case   20:*/		return 0x820B5524;
		  /* 820B5524h */ case   21:  		/* li R4, 98 */
		/* 820B5524h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x62);
		/* 820B5524h case   21:*/		return 0x820B5528;
		  /* 820B5528h */ case   22:  		/* lwz R3, <#[R30]> */
		/* 820B5528h case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820B5528h case   22:*/		return 0x820B552C;
		  /* 820B552Ch */ case   23:  		/* bl 1780052 */
		/* 820B552Ch case   23:*/		regs.LR = 0x820B5530; return 0x82267E80;
		/* 820B552Ch case   23:*/		return 0x820B5530;
		  /* 820B5530h */ case   24:  		/* cmplwi CR0, R3, 0 */
		/* 820B5530h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B5530h case   24:*/		return 0x820B5534;
		  /* 820B5534h */ case   25:  		/* bc 4, CR0_EQ, 24 */
		/* 820B5534h case   25:*/		if ( !regs.CR[0].eq ) { return 0x820B554C;  }
		/* 820B5534h case   25:*/		return 0x820B5538;
		  /* 820B5538h */ case   26:  		/* li R4, 66 */
		/* 820B5538h case   26:*/		cpu::op::li<0>(regs,&regs.R4,0x42);
		/* 820B5538h case   26:*/		return 0x820B553C;
		  /* 820B553Ch */ case   27:  		/* lwz R3, <#[R30]> */
		/* 820B553Ch case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820B553Ch case   27:*/		return 0x820B5540;
		  /* 820B5540h */ case   28:  		/* bl 1780032 */
		/* 820B5540h case   28:*/		regs.LR = 0x820B5544; return 0x82267E80;
		/* 820B5540h case   28:*/		return 0x820B5544;
		  /* 820B5544h */ case   29:  		/* cmplwi CR0, R3, 0 */
		/* 820B5544h case   29:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B5544h case   29:*/		return 0x820B5548;
		  /* 820B5548h */ case   30:  		/* bc 12, CR0_EQ, 36 */
		/* 820B5548h case   30:*/		if ( regs.CR[0].eq ) { return 0x820B556C;  }
		/* 820B5548h case   30:*/		return 0x820B554C;
	}
	return 0x820B554C;
} // Block from 820B54D0h-820B554Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 820B554Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B554C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B554C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B554C);
		  /* 820B554Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B554Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B554Ch case    0:*/		return 0x820B5550;
		  /* 820B5550h */ case    1:  		/* lwz R10, <#[R11 + 84]> */
		/* 820B5550h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 820B5550h case    1:*/		return 0x820B5554;
		  /* 820B5554h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820B5554h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B5554h case    2:*/		return 0x820B5558;
		  /* 820B5558h */ case    3:  		/* bc 12, CR6_EQ, 196 */
		/* 820B5558h case    3:*/		if ( regs.CR[6].eq ) { return 0x820B561C;  }
		/* 820B5558h case    3:*/		return 0x820B555C;
		  /* 820B555Ch */ case    4:  		/* cmpwi CR6, R28, 0 */
		/* 820B555Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820B555Ch case    4:*/		return 0x820B5560;
		  /* 820B5560h */ case    5:  		/* bc 12, CR6_EQ, 188 */
		/* 820B5560h case    5:*/		if ( regs.CR[6].eq ) { return 0x820B561C;  }
		/* 820B5560h case    5:*/		return 0x820B5564;
		  /* 820B5564h */ case    6:  		/* mr R22, R18 */
		/* 820B5564h case    6:*/		regs.R22 = regs.R18;
		/* 820B5564h case    6:*/		return 0x820B5568;
		  /* 820B5568h */ case    7:  		/* b 176 */
		/* 820B5568h case    7:*/		return 0x820B5618;
		/* 820B5568h case    7:*/		return 0x820B556C;
	}
	return 0x820B556C;
} // Block from 820B554Ch-820B556Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B556Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B556C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B556C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B556C);
		  /* 820B556Ch */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 820B556Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820B556Ch case    0:*/		return 0x820B5570;
		  /* 820B5570h */ case    1:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820B5570h case    1:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820B5570h case    1:*/		return 0x820B5574;
		  /* 820B5574h */ case    2:  		/* bc 12, CR0_EQ, 100 */
		/* 820B5574h case    2:*/		if ( regs.CR[0].eq ) { return 0x820B55D8;  }
		/* 820B5574h case    2:*/		return 0x820B5578;
		  /* 820B5578h */ case    3:  		/* li R4, 99 */
		/* 820B5578h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x63);
		/* 820B5578h case    3:*/		return 0x820B557C;
		  /* 820B557Ch */ case    4:  		/* lwz R3, <#[R30]> */
		/* 820B557Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820B557Ch case    4:*/		return 0x820B5580;
		  /* 820B5580h */ case    5:  		/* bl 1779968 */
		/* 820B5580h case    5:*/		regs.LR = 0x820B5584; return 0x82267E80;
		/* 820B5580h case    5:*/		return 0x820B5584;
		  /* 820B5584h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820B5584h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B5584h case    6:*/		return 0x820B5588;
		  /* 820B5588h */ case    7:  		/* bc 4, CR0_EQ, 24 */
		/* 820B5588h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820B55A0;  }
		/* 820B5588h case    7:*/		return 0x820B558C;
		  /* 820B558Ch */ case    8:  		/* li R4, 67 */
		/* 820B558Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x43);
		/* 820B558Ch case    8:*/		return 0x820B5590;
		  /* 820B5590h */ case    9:  		/* lwz R3, <#[R30]> */
		/* 820B5590h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820B5590h case    9:*/		return 0x820B5594;
		  /* 820B5594h */ case   10:  		/* bl 1779948 */
		/* 820B5594h case   10:*/		regs.LR = 0x820B5598; return 0x82267E80;
		/* 820B5594h case   10:*/		return 0x820B5598;
		  /* 820B5598h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820B5598h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820B5598h case   11:*/		return 0x820B559C;
		  /* 820B559Ch */ case   12:  		/* bc 12, CR0_EQ, 60 */
		/* 820B559Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x820B55D8;  }
		/* 820B559Ch case   12:*/		return 0x820B55A0;
	}
	return 0x820B55A0;
} // Block from 820B556Ch-820B55A0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820B55A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B55A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B55A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B55A0);
		  /* 820B55A0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B55A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B55A0h case    0:*/		return 0x820B55A4;
		  /* 820B55A4h */ case    1:  		/* lwz R10, <#[R11 + 88]> */
		/* 820B55A4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000058) );
		/* 820B55A4h case    1:*/		return 0x820B55A8;
		  /* 820B55A8h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820B55A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B55A8h case    2:*/		return 0x820B55AC;
		  /* 820B55ACh */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 820B55ACh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B55C8;  }
		/* 820B55ACh case    3:*/		return 0x820B55B0;
		  /* 820B55B0h */ case    4:  		/* lwz R10, <#[R11 + 52]> */
		/* 820B55B0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 820B55B0h case    4:*/		return 0x820B55B4;
		  /* 820B55B4h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 820B55B4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B55B4h case    5:*/		return 0x820B55B8;
		  /* 820B55B8h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820B55B8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820B55D0;  }
		/* 820B55B8h case    6:*/		return 0x820B55BC;
		  /* 820B55BCh */ case    7:  		/* lwz R10, <#[R31 + 48]> */
		/* 820B55BCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 820B55BCh case    7:*/		return 0x820B55C0;
	}
	return 0x820B55C0;
} // Block from 820B55A0h-820B55C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820B55C0h
// Function '?IsLimited@CCompiler@D3DXShader@@IAAHIIPAI0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B55C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B55C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B55C0);
		  /* 820B55C0h */ case    0:  		/* cmpwi CR6, R10, -1 */
		/* 820B55C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B55C0h case    0:*/		return 0x820B55C4;
		  /* 820B55C4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820B55C4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820B55D0;  }
		/* 820B55C4h case    1:*/		return 0x820B55C8;
	}
	return 0x820B55C8;
} // Block from 820B55C0h-820B55C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B55C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B55C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B55C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B55C8);
		  /* 820B55C8h */ case    0:  		/* li R22, 1 */
		/* 820B55C8h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820B55C8h case    0:*/		return 0x820B55CC;
		  /* 820B55CCh */ case    1:  		/* li R29, 1 */
		/* 820B55CCh case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820B55CCh case    1:*/		return 0x820B55D0;
	}
	return 0x820B55D0;
} // Block from 820B55C8h-820B55D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B55D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B55D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B55D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B55D0);
		  /* 820B55D0h */ case    0:  		/* mr R28, R18 */
		/* 820B55D0h case    0:*/		regs.R28 = regs.R18;
		/* 820B55D0h case    0:*/		return 0x820B55D4;
		  /* 820B55D4h */ case    1:  		/* b 72 */
		/* 820B55D4h case    1:*/		return 0x820B561C;
		/* 820B55D4h case    1:*/		return 0x820B55D8;
	}
	return 0x820B55D8;
} // Block from 820B55D0h-820B55D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820B55D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B55D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B55D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B55D8);
		  /* 820B55D8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820B55D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820B55D8h case    0:*/		return 0x820B55DC;
		  /* 820B55DCh */ case    1:  		/* lwz R10, <#[R11 + 88]> */
		/* 820B55DCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000058) );
		/* 820B55DCh case    1:*/		return 0x820B55E0;
		  /* 820B55E0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820B55E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B55E0h case    2:*/		return 0x820B55E4;
		  /* 820B55E4h */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 820B55E4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820B5614;  }
		/* 820B55E4h case    3:*/		return 0x820B55E8;
		  /* 820B55E8h */ case    4:  		/* lwz R10, <#[R11 + 84]> */
		/* 820B55E8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 820B55E8h case    4:*/		return 0x820B55EC;
		  /* 820B55ECh */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 820B55ECh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B55ECh case    5:*/		return 0x820B55F0;
		  /* 820B55F0h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820B55F0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820B55FC;  }
		/* 820B55F0h case    6:*/		return 0x820B55F4;
		  /* 820B55F4h */ case    7:  		/* cmpwi CR6, R28, 0 */
		/* 820B55F4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820B55F4h case    7:*/		return 0x820B55F8;
		  /* 820B55F8h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 820B55F8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820B5614;  }
		/* 820B55F8h case    8:*/		return 0x820B55FC;
	}
	return 0x820B55FC;
} // Block from 820B55D8h-820B55FCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820B55FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B55FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B55FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B55FC);
		  /* 820B55FCh */ case    0:  		/* lwz R10, <#[R11 + 52]> */
		/* 820B55FCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 820B55FCh case    0:*/		return 0x820B5600;
		  /* 820B5600h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820B5600h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B5600h case    1:*/		return 0x820B5604;
		  /* 820B5604h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820B5604h case    2:*/		if ( regs.CR[6].eq ) { return 0x820B561C;  }
		/* 820B5604h case    2:*/		return 0x820B5608;
		  /* 820B5608h */ case    3:  		/* lwz R10, <#[R31 + 48]> */
		/* 820B5608h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 820B5608h case    3:*/		return 0x820B560C;
		  /* 820B560Ch */ case    4:  		/* cmpwi CR6, R10, -1 */
		/* 820B560Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 820B560Ch case    4:*/		return 0x820B5610;
		  /* 820B5610h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 820B5610h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820B561C;  }
		/* 820B5610h case    5:*/		return 0x820B5614;
	}
	return 0x820B5614;
} // Block from 820B55FCh-820B5614h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820B5614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5614);
		  /* 820B5614h */ case    0:  		/* li R22, 1 */
		/* 820B5614h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820B5614h case    0:*/		return 0x820B5618;
	}
	return 0x820B5618;
} // Block from 820B5614h-820B5618h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B5618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5618);
		  /* 820B5618h */ case    0:  		/* li R29, 1 */
		/* 820B5618h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820B5618h case    0:*/		return 0x820B561C;
	}
	return 0x820B561C;
} // Block from 820B5618h-820B561Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820B561Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B561C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B561C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B561C);
		  /* 820B561Ch */ case    0:  		/* lwz R10, <#[R11 + 52]> */
		/* 820B561Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 820B561Ch case    0:*/		return 0x820B5620;
		  /* 820B5620h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820B5620h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820B5620h case    1:*/		return 0x820B5624;
		  /* 820B5624h */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 820B5624h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820B5654;  }
		/* 820B5624h case    2:*/		return 0x820B5628;
		  /* 820B5628h */ case    3:  		/* cmpwi CR6, R22, 0 */
		/* 820B5628h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 820B5628h case    3:*/		return 0x820B562C;
		  /* 820B562Ch */ case    4:  		/* bc 12, CR6_EQ, 68 */
		/* 820B562Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820B5670;  }
		/* 820B562Ch case    4:*/		return 0x820B5630;
		  /* 820B5630h */ case    5:  		/* cmpwi CR6, R29, 0 */
		/* 820B5630h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820B5630h case    5:*/		return 0x820B5634;
		  /* 820B5634h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 820B5634h case    6:*/		if ( regs.CR[6].eq ) { return 0x820B5654;  }
		/* 820B5634h case    6:*/		return 0x820B5638;
		  /* 820B5638h */ case    7:  		/* cmpwi CR6, R28, 0 */
		/* 820B5638h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 820B5638h case    7:*/		return 0x820B563C;
		  /* 820B563Ch */ case    8:  		/* bc 12, CR6_EQ, 228 */
		/* 820B563Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820B5720;  }
		/* 820B563Ch case    8:*/		return 0x820B5640;
		  /* 820B5640h */ case    9:  		/* lwz R10, <#[R31 + 60]> */
		/* 820B5640h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 820B5640h case    9:*/		return 0x820B5644;
		  /* 820B5644h */ case   10:  		/* lwz R11, <#[R11 + 84]> */
		/* 820B5644h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 820B5644h case   10:*/		return 0x820B5648;
		  /* 820B5648h */ case   11:  		/* cmplw CR6, R10, R11 */
		/* 820B5648h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820B5648h case   11:*/		return 0x820B564C;
		  /* 820B564Ch */ case   12:  		/* bc 12, CR6_LT, 8 */
		/* 820B564Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x820B5654;  }
		/* 820B564Ch case   12:*/		return 0x820B5650;
		  /* 820B5650h */ case   13:  		/* mr R29, R18 */
		/* 820B5650h case   13:*/		regs.R29 = regs.R18;
		/* 820B5650h case   13:*/		return 0x820B5654;
	}
	return 0x820B5654;
} // Block from 820B561Ch-820B5654h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820B5654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5654);
		  /* 820B5654h */ case    0:  		/* cmpwi CR6, R22, 0 */
		/* 820B5654h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 820B5654h case    0:*/		return 0x820B5658;
		  /* 820B5658h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820B5658h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B5670;  }
		/* 820B5658h case    1:*/		return 0x820B565C;
		  /* 820B565Ch */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 820B565Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820B565Ch case    2:*/		return 0x820B5660;
		  /* 820B5660h */ case    3:  		/* rlwinm R11, R11, 0, 22, 22 */
		/* 820B5660h case    3:*/		cpu::op::rlwinm<0,0,22,22>(regs,&regs.R11,regs.R11);
		/* 820B5660h case    3:*/		return 0x820B5664;
		  /* 820B5664h */ case    4:  		/* addic R11, R11, -1 */
		/* 820B5664h case    4:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820B5664h case    4:*/		return 0x820B5668;
		  /* 820B5668h */ case    5:  		/* subfe R11, R11, R11 */
		/* 820B5668h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820B5668h case    5:*/		return 0x820B566C;
		  /* 820B566Ch */ case    6:  		/* and R29, R11, R29 */
		/* 820B566Ch case    6:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820B566Ch case    6:*/		return 0x820B5670;
	}
	return 0x820B5670;
} // Block from 820B5654h-820B5670h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820B5670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820B5670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820B5670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820B5670);
		  /* 820B5670h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 820B5670h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820B5670h case    0:*/		return 0x820B5674;
		  /* 820B5674h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 820B5674h case    1:*/		if ( regs.CR[6].eq ) { return 0x820B568C;  }
		/* 820B5674h case    1:*/		return 0x820B5678;
		  /* 820B5678h */ case    2:  		/* lwz R11, <#[R31 + 20]> */
		/* 820B5678h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820B5678h case    2:*/		return 0x820B567C;
		  /* 820B567Ch */ case    3:  		/* rlwinm R11, R11, 0, 21, 21 */
		/* 820B567Ch case    3:*/		cpu::op::rlwinm<0,0,21,21>(regs,&regs.R11,regs.R11);
		/* 820B567Ch case    3:*/		return 0x820B5680;
		  /* 820B5680h */ case    4:  		/* addic R11, R11, -1 */
		/* 820B5680h case    4:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820B5680h case    4:*/		return 0x820B5684;
		  /* 820B5684h */ case    5:  		/* subfe R11, R11, R11 */
		/* 820B5684h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820B5684h case    5:*/		return 0x820B5688;
		  /* 820B5688h */ case    6:  		/* and R22, R11, R22 */
		/* 820B5688h case    6:*/		cpu::op::and<0>(regs,&regs.R22,regs.R11,regs.R22);
		/* 820B5688h case    6:*/		return 0x820B568C;
	}
	return 0x820B568C;
} // Block from 820B5670h-820B568Ch (7 instructions)

